[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			if (args.isRawCFGOutput()) {, +				passes.add(new DotGraphVisitor(outDir, false, true));, +			}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			if (args.isRawCFGOutput()) {, +				passes.add(new DotGraphVisitor(outDir, false, true));, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	public int getExceptionHandlersCount() {, +		return exceptionHandlers.size();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			if (args.isRawCFGOutput()) {, +				passes.add(new DotGraphVisitor(outDir, false, true));, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	public int getExceptionHandlersCount() {, +		return exceptionHandlers.size();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, +import jadx.core.dex.instructions.args.SSAVar;, +import jadx.core.utils.BlockUtils;, +		List<InsnNode> toRemove = new ArrayList<InsnNode>();, +			toRemove.clear();, +					toRemove.add(insn);, +			if (!toRemove.isEmpty()) {, +				InstructionRemover.removeAll(mth, block, toRemove);, +			}, +		if (insn.getType() != InsnType.CONST) {, +			return false;, +		}, +		if (!arg.isLiteral()) {, +			return false;, +		}, +		SSAVar sVar = insn.getResult().getSVar();, +		if (mth.getExceptionHandlersCount() != 0) {, +			for (RegisterArg useArg : sVar.getUseList()) {, +				InsnNode parentInsn = useArg.getParentInsn();, +				if (parentInsn != null) {, +					// TODO: speed up expensive operations, +					BlockNode useBlock = BlockUtils.getBlockByInsn(mth, parentInsn);, +					if (!BlockUtils.isCleanPathExists(block, useBlock)) {, +						return false;, +					}, +				}, +			}, +		}, +		return replaceConst(mth, sVar, lit);, +	private static boolean replaceConst(MethodNode mth, SSAVar sVar, long literal) {, +		List<RegisterArg> use = new ArrayList<RegisterArg>(sVar.getUseList());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +			if (args.isRawCFGOutput()) {, +				passes.add(new DotGraphVisitor(outDir, false, true));, +			}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +	public int getExceptionHandlersCount() {, +		return exceptionHandlers.size();, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, +import jadx.core.dex.instructions.args.SSAVar;, +import jadx.core.utils.BlockUtils;, +		List<InsnNode> toRemove = new ArrayList<InsnNode>();, +			toRemove.clear();, +					toRemove.add(insn);, +			if (!toRemove.isEmpty()) {, +				InstructionRemover.removeAll(mth, block, toRemove);, +			}, +		if (insn.getType() != InsnType.CONST) {, +			return false;, +		}, +		if (!arg.isLiteral()) {, +			return false;, +		}, +		SSAVar sVar = insn.getResult().getSVar();, +		if (mth.getExceptionHandlersCount() != 0) {, +			for (RegisterArg useArg : sVar.getUseList()) {, +				InsnNode parentInsn = useArg.getParentInsn();, +				if (parentInsn != null) {, +					// TODO: speed up expensive operations, +					BlockNode useBlock = BlockUtils.getBlockByInsn(mth, parentInsn);, +					if (!BlockUtils.isCleanPathExists(block, useBlock)) {, +						return false;, +					}, +				}, +			}, +		}, +		return replaceConst(mth, sVar, lit);, +	private static boolean replaceConst(MethodNode mth, SSAVar sVar, long literal) {, +		List<RegisterArg> use = new ArrayList<RegisterArg>(sVar.getUseList());, +++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, +	public static boolean isCleanPathExists(BlockNode start, BlockNode end) {, +		if (start == end || start.getCleanSuccessors().contains(end)) {, +			return true;, +		}, +		return traverseCleanSuccessorsUntil(start, end, new BitSet());, +	}]