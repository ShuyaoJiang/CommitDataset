[+++ b/src/main/java/jadx/Main.java, +			passes.add(new ClassModifier());, +++ b/src/main/java/jadx/Main.java, +			passes.add(new ClassModifier());, +++ b/src/main/java/jadx/dex/info/AccessInfo.java, +	public boolean isPublic() {, +		return (accFlags & AccessFlags.ACC_PUBLIC) != 0;, +	}, +, +	public boolean isProtected() {, +		return (accFlags & AccessFlags.ACC_PROTECTED) != 0;, +	}, +, +	public boolean isPrivate() {, +		return (accFlags & AccessFlags.ACC_PRIVATE) != 0;, +	}, +, +		if (isPublic()), +		if (isPrivate()), +		if (isProtected()), +++ b/src/main/java/jadx/Main.java, +			passes.add(new ClassModifier());, +++ b/src/main/java/jadx/dex/info/AccessInfo.java, +	public boolean isPublic() {, +		return (accFlags & AccessFlags.ACC_PUBLIC) != 0;, +	}, +, +	public boolean isProtected() {, +		return (accFlags & AccessFlags.ACC_PROTECTED) != 0;, +	}, +, +	public boolean isPrivate() {, +		return (accFlags & AccessFlags.ACC_PRIVATE) != 0;, +	}, +, +		if (isPublic()), +		if (isPrivate()), +		if (isProtected()), +++ b/src/main/java/jadx/dex/info/ClassInfo.java, +import java.util.WeakHashMap;, +	private static final Map<ArgType, ClassInfo> CLASSINFO_CACHE = new WeakHashMap<ArgType, ClassInfo>();, +++ b/src/main/java/jadx/Main.java, +			passes.add(new ClassModifier());, +++ b/src/main/java/jadx/dex/info/AccessInfo.java, +	public boolean isPublic() {, +		return (accFlags & AccessFlags.ACC_PUBLIC) != 0;, +	}, +, +	public boolean isProtected() {, +		return (accFlags & AccessFlags.ACC_PROTECTED) != 0;, +	}, +, +	public boolean isPrivate() {, +		return (accFlags & AccessFlags.ACC_PRIVATE) != 0;, +	}, +, +		if (isPublic()), +		if (isPrivate()), +		if (isProtected()), +++ b/src/main/java/jadx/dex/info/ClassInfo.java, +import java.util.WeakHashMap;, +	private static final Map<ArgType, ClassInfo> CLASSINFO_CACHE = new WeakHashMap<ArgType, ClassInfo>();, +++ b/src/main/java/jadx/dex/visitors/ClassModifier.java, +import jadx.dex.nodes.BlockNode;, +import java.util.List;, +				if (!isMethodIdUniq(cls, mth)) {, +					// TODO add more checks before method deletion, +, +			// remove public empty constructors, +			if (af.isConstructor(), +					&& af.isPublic(), +					&& mth.getArguments(false).isEmpty()) {, +				List<BlockNode> bb = mth.getBasicBlocks();, +				if (bb.isEmpty() || (bb.size() == 1 && bb.get(0).getInstructions().isEmpty())) {, +					it.remove();, +				}, +			}, +		}, +, +	private boolean isMethodIdUniq(ClassNode cls, MethodNode mth) {, +		String shortId = mth.getMethodInfo().getShortId();, +		for (MethodNode otherMth : cls.getMethods()) {, +			if (otherMth.getMethodInfo().getShortId().equals(shortId), +					&& otherMth != mth), +				return false;, +		}, +		return true;, +	}]