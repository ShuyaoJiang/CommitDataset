[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.SimplifyVisitor;, +			passes.add(new ConstInlinerVisitor());, +			passes.add(new FinishTypeResolver());, +, +			passes.add(new SimplifyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.SimplifyVisitor;, +			passes.add(new ConstInlinerVisitor());, +			passes.add(new FinishTypeResolver());, +, +			passes.add(new SimplifyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		// TODO: add jadx argument "", +		// FIXME: check variable names in scope, +		if (false && arg.isThis()) {, +				return name;, +					if (lit.isInteger() && lit.getLiteral() == 1) {, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.SimplifyVisitor;, +			passes.add(new ConstInlinerVisitor());, +			passes.add(new FinishTypeResolver());, +, +			passes.add(new SimplifyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		// TODO: add jadx argument "", +		// FIXME: check variable names in scope, +		if (false && arg.isThis()) {, +				return name;, +					if (lit.isInteger() && lit.getLiteral() == 1) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.nodes.BlockNode;, +		BlockNode header = region.getHeader();, +		if (header != null) {, +			List<InsnNode> headerInsns = header.getInstructions();, +			if (headerInsns.size() > 1) {, +				// write not inlined instructions from header, +				mth.getAttributes().add(AttributeFlag.INCONSISTENT_CODE);, +				for (int i = 0; i < headerInsns.size() - 1; i++) {, +					InsnNode insn = headerInsns.get(i);, +					makeInsn(insn, code);, +				}, +			}, +		}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.SimplifyVisitor;, +			passes.add(new ConstInlinerVisitor());, +			passes.add(new FinishTypeResolver());, +, +			passes.add(new SimplifyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		// TODO: add jadx argument "", +		// FIXME: check variable names in scope, +		if (false && arg.isThis()) {, +				return name;, +					if (lit.isInteger() && lit.getLiteral() == 1) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.nodes.BlockNode;, +		BlockNode header = region.getHeader();, +		if (header != null) {, +			List<InsnNode> headerInsns = header.getInstructions();, +			if (headerInsns.size() > 1) {, +				// write not inlined instructions from header, +				mth.getAttributes().add(AttributeFlag.INCONSISTENT_CODE);, +				for (int i = 0; i < headerInsns.size() - 1; i++) {, +					InsnNode insn = headerInsns.get(i);, +					makeInsn(insn, code);, +				}, +			}, +		}, +, +++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.SimplifyVisitor;, +			passes.add(new ConstInlinerVisitor());, +			passes.add(new FinishTypeResolver());, +, +			passes.add(new SimplifyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		// TODO: add jadx argument "", +		// FIXME: check variable names in scope, +		if (false && arg.isThis()) {, +				return name;, +					if (lit.isInteger() && lit.getLiteral() == 1) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.nodes.BlockNode;, +		BlockNode header = region.getHeader();, +		if (header != null) {, +			List<InsnNode> headerInsns = header.getInstructions();, +			if (headerInsns.size() > 1) {, +				// write not inlined instructions from header, +				mth.getAttributes().add(AttributeFlag.INCONSISTENT_CODE);, +				for (int i = 0; i < headerInsns.size() - 1; i++) {, +					InsnNode insn = headerInsns.get(i);, +					makeInsn(insn, code);, +				}, +			}, +		}, +]