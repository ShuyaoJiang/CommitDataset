[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +			insertContinue(loop);, +					insertBreak(stack, loopExit, exitEdge);, +		insertContinue(loop);, +			if (insertBreak(stack, exit, exitEdge)) {, +	private boolean insertBreak(RegionStack stack, BlockNode loopExit, Edge exitEdge) {, +		addBreakLabel(exitEdge, exit, breakInsn);, +	private void addBreakLabel(Edge exitEdge, BlockNode exit, InsnNode breakInsn) {, +		BlockNode outBlock = BlockUtils.getNextBlock(exitEdge.getTarget());, +		if (outBlock == null) {, +			return;, +		}, +		List<LoopInfo> exitLoop = mth.getAllLoopsForBlock(outBlock);, +		if (!exitLoop.isEmpty()) {, +			return;, +		}, +		List<LoopInfo> inLoops = mth.getAllLoopsForBlock(exitEdge.getSource());, +		if (inLoops.size() < 2) {, +			return;, +		}, +		// search for parent loop, +		LoopInfo parentLoop = null;, +		for (LoopInfo loop : inLoops) {, +			if (loop.getParentLoop() == null) {, +				parentLoop = loop;, +				break;, +			}, +		}, +		if (parentLoop == null) {, +			return;, +		}, +		if (parentLoop.getEnd() != exit && !parentLoop.getExitNodes().contains(exit)) {, +			LoopLabelAttr labelAttr = new LoopLabelAttr(parentLoop);, +			breakInsn.addAttr(labelAttr);, +			parentLoop.getStart().addAttr(labelAttr);, +		}, +	}, +, +	private static void insertContinue(LoopInfo loop) {, +		Set<BlockNode> loopExitNodes = loop.getExitNodes();, +			if (canInsertContinue(pred, predecessors, loopEnd, loopExitNodes)) {, +, +	private static boolean canInsertContinue(BlockNode pred, List<BlockNode> predecessors, BlockNode loopEnd,, +			Set<BlockNode> loopExitNodes) {, +		if (!pred.contains(AFlag.SYNTHETIC), +				|| BlockUtils.checkLastInsnType(pred, InsnType.CONTINUE)) {, +			return false;, +		List<BlockNode> preds = pred.getPredecessors();, +		if (preds.isEmpty()) {, +			return false;, +		}, +		BlockNode codePred = preds.get(0);, +		if (codePred.contains(AFlag.SKIP)) {, +			return false;, +		}, +		if (loopEnd.isDominator(codePred), +				|| loopExitNodes.contains(codePred)) {, +			return false;, +		}, +		if (isDominatedOnBlocks(codePred, predecessors)) {, +			return false;, +		}, +		boolean gotoExit = false;, +		for (BlockNode exit : loopExitNodes) {, +			if (BlockUtils.isPathExists(codePred, exit)) {, +				gotoExit = true;, +				break;, +			}, +		}, +		return gotoExit;, +		for (Map.Entry<Integer, List<Object>> entry : casesMap.entrySet()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +			insertContinue(loop);, +					insertBreak(stack, loopExit, exitEdge);, +		insertContinue(loop);, +			if (insertBreak(stack, exit, exitEdge)) {, +	private boolean insertBreak(RegionStack stack, BlockNode loopExit, Edge exitEdge) {, +		addBreakLabel(exitEdge, exit, breakInsn);, +	private void addBreakLabel(Edge exitEdge, BlockNode exit, InsnNode breakInsn) {, +		BlockNode outBlock = BlockUtils.getNextBlock(exitEdge.getTarget());, +		if (outBlock == null) {, +			return;, +		}, +		List<LoopInfo> exitLoop = mth.getAllLoopsForBlock(outBlock);, +		if (!exitLoop.isEmpty()) {, +			return;, +		}, +		List<LoopInfo> inLoops = mth.getAllLoopsForBlock(exitEdge.getSource());, +		if (inLoops.size() < 2) {, +			return;, +		}, +		// search for parent loop, +		LoopInfo parentLoop = null;, +		for (LoopInfo loop : inLoops) {, +			if (loop.getParentLoop() == null) {, +				parentLoop = loop;, +				break;, +			}, +		}, +		if (parentLoop == null) {]