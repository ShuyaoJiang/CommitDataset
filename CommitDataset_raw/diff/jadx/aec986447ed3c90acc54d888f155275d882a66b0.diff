[+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import java.util.Iterator;, +import jadx.core.dex.info.ClassInfo;, +			Iterator<ClassInfo> it = handler.getCatchTypes().iterator();, +			if (it.hasNext()) {, +				useClass(code, it.next());, +			}, +			while (it.hasNext()) {, +				code.add(" | ");, +				useClass(code, it.next());, +			}, +		InsnArg arg = handler.getArg();, +		if (arg instanceof RegisterArg) {, +			code.add(mgen.getNameGen().assignArg((RegisterArg) arg));, +		} else if (arg instanceof NamedArg) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import java.util.Iterator;, +import jadx.core.dex.info.ClassInfo;, +			Iterator<ClassInfo> it = handler.getCatchTypes().iterator();, +			if (it.hasNext()) {, +				useClass(code, it.next());, +			}, +			while (it.hasNext()) {, +				code.add(" | ");, +				useClass(code, it.next());, +			}, +		InsnArg arg = handler.getArg();, +		if (arg instanceof RegisterArg) {, +			code.add(mgen.getNameGen().assignArg((RegisterArg) arg));, +		} else if (arg instanceof NamedArg) {, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +import org.jetbrains.annotations.NotNull;, +, +public final class ClassInfo implements Comparable<ClassInfo> {, +, +	@Override, +	public int compareTo(@NotNull ClassInfo o) {, +		return fullName.compareTo(o.fullName);, +	}, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import java.util.Iterator;, +import jadx.core.dex.info.ClassInfo;, +			Iterator<ClassInfo> it = handler.getCatchTypes().iterator();, +			if (it.hasNext()) {, +				useClass(code, it.next());, +			}, +			while (it.hasNext()) {, +				code.add(" | ");, +				useClass(code, it.next());, +			}, +		InsnArg arg = handler.getArg();, +		if (arg instanceof RegisterArg) {, +			code.add(mgen.getNameGen().assignArg((RegisterArg) arg));, +		} else if (arg instanceof NamedArg) {, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +import org.jetbrains.annotations.NotNull;, +, +public final class ClassInfo implements Comparable<ClassInfo> {, +, +	@Override, +	public int compareTo(@NotNull ClassInfo o) {, +		return fullName.compareTo(o.fullName);, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +			this.regsCount = mthCode.getRegistersSize();, +			this.instructions = decoder.process();, +			this.codeSize = instructions.length;, +			initTryCatches(this, mthCode, instructions);, +			initJumps(instructions);, +	private static void initTryCatches(MethodNode mth, Code mthCode, InsnNode[] insnByOffset) {, +		int handlersCount = 0;, +			int[] handlerAddrArr = handler.getAddresses();, +			for (int i = 0; i < handlerAddrArr.length; i++) {, +				int addr = handlerAddrArr[i];, +				ClassInfo type = ClassInfo.fromDex(mth.dex(), handler.getTypeIndexes()[i]);, +				tcBlock.addHandler(mth, addr, type);, +				handlersCount++;, +				tcBlock.addHandler(mth, addr, null);, +				handlersCount++;, +		if (handlersCount > 0 && handlersCount != addrs.size()) {, +							ct2.removeHandler(mth, h);, +				// TODO: don't override existing attribute, +	private static void initJumps(InsnNode[] insnByOffset) {, +				if (h.equals(handler)) {, +					return h;, +				}, +				if (h.getHandleOffset() == handler.getHandleOffset()) {, +					if (h.getTryBlock() == handler.getTryBlock()) {, +						for (ClassInfo catchType : handler.getCatchTypes()) {, +							h.addCatchType(catchType);, +						}, +					} else {, +						// same handlers from different try blocks, +						// will merge later, +					}, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import java.util.Iterator;, +import jadx.core.dex.info.ClassInfo;, +			Iterator<ClassInfo> it = handler.getCatchTypes().iterator();, +			if (it.hasNext()) {]