[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (callMthNode != null && inlineMethod(callMthNode, insn, code)) {, +			code.add(callMthNode.getAlias());, +		} else {, +		}, +		ArgType origType;, +		List<RegisterArg> arguments = callMth.getArguments(false);, +		if (arguments.isEmpty()) {, +			mth.addComment("JADX WARN: used method not loaded: " + callMth + ", types can be incorrect");, +			origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);, +		} else {, +			origType = arguments.get(origPos).getInitType();, +		}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (callMthNode != null && inlineMethod(callMthNode, insn, code)) {, +			code.add(callMthNode.getAlias());, +		} else {, +		}, +		ArgType origType;, +		List<RegisterArg> arguments = callMth.getArguments(false);, +		if (arguments.isEmpty()) {, +			mth.addComment("JADX WARN: used method not loaded: " + callMth + ", types can be incorrect");, +			origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);, +		} else {, +			origType = arguments.get(origPos).getInitType();, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java, +import jadx.core.dex.instructions.mods.ConstructorInsn;, +		} else if (insn instanceof ConstructorInsn) {, +			ClassInfo declClass = ((ConstructorInsn) insn).getCallMth().getDeclClass();, +			addDep(dex, depList, declClass);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (callMthNode != null && inlineMethod(callMthNode, insn, code)) {, +			code.add(callMthNode.getAlias());, +		} else {, +		}, +		ArgType origType;, +		List<RegisterArg> arguments = callMth.getArguments(false);, +		if (arguments.isEmpty()) {, +			mth.addComment("JADX WARN: used method not loaded: " + callMth + ", types can be incorrect");, +			origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);, +		} else {, +			origType = arguments.get(origPos).getInitType();, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java, +import jadx.core.dex.instructions.mods.ConstructorInsn;, +		} else if (insn instanceof ConstructorInsn) {, +			ClassInfo declClass = ((ConstructorInsn) insn).getCallMth().getDeclClass();, +			addDep(dex, depList, declClass);, +++ b/jadx-core/src/main/java/jadx/core/utils/CodegenUtils.java, +			code.startLine("/* ").addMultiLine(comment).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +		if (callMthNode != null && inlineMethod(callMthNode, insn, code)) {, +			code.add(callMthNode.getAlias());, +		} else {, +		}, +		ArgType origType;, +		List<RegisterArg> arguments = callMth.getArguments(false);, +		if (arguments.isEmpty()) {, +			mth.addComment("JADX WARN: used method not loaded: " + callMth + ", types can be incorrect");, +			origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);, +		} else {, +			origType = arguments.get(origPos).getInitType();, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java, +import jadx.core.dex.instructions.mods.ConstructorInsn;, +		} else if (insn instanceof ConstructorInsn) {, +			ClassInfo declClass = ((ConstructorInsn) insn).getCallMth().getDeclClass();, +			addDep(dex, depList, declClass);, +++ b/jadx-core/src/main/java/jadx/core/utils/CodegenUtils.java, +			code.startLine("/* ").addMultiLine(comment).add(" */");, +++ b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestInheritedStaticInvoke.java, +package jadx.tests.integration.invoke;, +, +import org.junit.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestInheritedStaticInvoke extends IntegrationTest {, +, +	public static class TestCls {, +		public static class A {, +			public static int a() {, +				return 1;, +			}, +		}, +, +		public static class B extends A {, +		}, +, +		public int test() {, +			return B.a(); // not A.a(), +		}, +	}, +, +	@Test]