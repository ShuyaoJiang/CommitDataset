[+++ b/src/main/java/jadx/IJadxArgs.java, +++ b/src/main/java/jadx/IJadxArgs.java, +++ b/src/main/java/jadx/JadxArgs.java, +++ b/src/main/java/jadx/IJadxArgs.java, +++ b/src/main/java/jadx/JadxArgs.java, +++ b/src/main/java/jadx/codegen/ClassGen.java, +		if (cls.getAttributes().contains(AttributeFlag.INCONSISTENT_CODE)), +			code.startLine("// jadx: inconsistent code");, +, +		CodeWriter fieldsCode = makeFields(clsCode, cls, cls.getFields());, +		clsCode.add(fieldsCode);, +		if (fieldsCode.notEmpty() && mthsCode.notEmpty()), +			clsCode.endl();, +			if (mthsCode.notEmpty()), +				clsCode.endl();, +			InsnGen igen = null;, +						if (igen == null) {, +							// don't init mth gen if this is simple enum, +							MethodGen mthGen = new MethodGen(this, enumFields.getStaticMethod());, +							igen = new InsnGen(mthGen, enumFields.getStaticMethod(), false);, +						}, +		return useClass(ClassInfo.fromType(clsType));, +		String baseClass = useClassInternal(classInfo);, +	private String useClassInternal(ClassInfo classInfo) {, +			return parentGen.useClassInternal(classInfo);, +++ b/src/main/java/jadx/IJadxArgs.java, +++ b/src/main/java/jadx/JadxArgs.java, +++ b/src/main/java/jadx/codegen/ClassGen.java, +		if (cls.getAttributes().contains(AttributeFlag.INCONSISTENT_CODE)), +			code.startLine("// jadx: inconsistent code");, +, +		CodeWriter fieldsCode = makeFields(clsCode, cls, cls.getFields());, +		clsCode.add(fieldsCode);, +		if (fieldsCode.notEmpty() && mthsCode.notEmpty()), +			clsCode.endl();, +			if (mthsCode.notEmpty()), +				clsCode.endl();, +			InsnGen igen = null;, +						if (igen == null) {, +							// don't init mth gen if this is simple enum, +							MethodGen mthGen = new MethodGen(this, enumFields.getStaticMethod());, +							igen = new InsnGen(mthGen, enumFields.getStaticMethod(), false);, +						}, +		return useClass(ClassInfo.fromType(clsType));, +		String baseClass = useClassInternal(classInfo);, +	private String useClassInternal(ClassInfo classInfo) {, +			return parentGen.useClassInternal(classInfo);, +++ b/src/main/java/jadx/codegen/CodeWriter.java, +	public boolean notEmpty() {, +		return buf.length() != 0;, +	}, +, +++ b/src/main/java/jadx/IJadxArgs.java, +++ b/src/main/java/jadx/JadxArgs.java, +++ b/src/main/java/jadx/codegen/ClassGen.java, +		if (cls.getAttributes().contains(AttributeFlag.INCONSISTENT_CODE)), +			code.startLine("// jadx: inconsistent code");, +, +		CodeWriter fieldsCode = makeFields(clsCode, cls, cls.getFields());, +		clsCode.add(fieldsCode);, +		if (fieldsCode.notEmpty() && mthsCode.notEmpty()), +			clsCode.endl();, +			if (mthsCode.notEmpty()), +				clsCode.endl();, +			InsnGen igen = null;, +						if (igen == null) {, +							// don't init mth gen if this is simple enum, +							MethodGen mthGen = new MethodGen(this, enumFields.getStaticMethod());, +							igen = new InsnGen(mthGen, enumFields.getStaticMethod(), false);, +						}, +		return useClass(ClassInfo.fromType(clsType));, +		String baseClass = useClassInternal(classInfo);, +	private String useClassInternal(ClassInfo classInfo) {, +			return parentGen.useClassInternal(classInfo);, +++ b/src/main/java/jadx/codegen/CodeWriter.java, +	public boolean notEmpty() {, +		return buf.length() != 0;, +	}, +, +++ b/src/main/java/jadx/dex/info/ClassInfo.java, +		return fromType(type);, +	public static ClassInfo fromName(String clsName) {, +		return fromType(ArgType.object(clsName));, +	public static ClassInfo fromType(ArgType type) {, +			cls = new ClassInfo(type);, +	private final ArgType type;, +	private String pkg;, +	private String name;, +	private String fullName;, +	private ClassInfo parentClass; // not equals null if this is inner class, +, +	private ClassInfo(ArgType type) {, +		splitNames(true);, +	}, +, +	private void splitNames(boolean canBeInner) {, +			pkg = DEFAULT_PACKAGE_NAME;, +		if (canBeInner && sep > 0 && sep != name.length() - 1) {, +			parentClass = fromName(parClsName);, +		char firstChar = name.charAt(0);]