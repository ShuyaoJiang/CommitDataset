[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				useClass(code, ClassInfo.fromType(cls.dex(), type));, +						useClass(code, ClassInfo.fromType(cls.dex(), g));, +				useClass(code, ClassInfo.fromType(cls.dex(), type));, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				useClass(code, ClassInfo.fromType(cls.dex(), type));, +						useClass(code, ClassInfo.fromType(cls.dex(), g));, +				useClass(code, ClassInfo.fromType(cls.dex(), type));, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		this.nameGen = new NameGen(mth, classGen.isFallbackMode());, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				useClass(code, ClassInfo.fromType(cls.dex(), type));, +						useClass(code, ClassInfo.fromType(cls.dex(), g));, +				useClass(code, ClassInfo.fromType(cls.dex(), type));, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		this.nameGen = new NameGen(mth, classGen.isFallbackMode());, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.dex.nodes.MethodNode;, +	private final MethodNode mth;, +	public NameGen(MethodNode mth, boolean fallback) {, +		this.mth = mth;, +			varName = guessName(arg);, +	private String guessName(RegisterArg arg) {, +		SSAVar sVar = arg.getSVar();, +		if (sVar != null && sVar.getName() == null) {, +			RegisterArg assignArg = sVar.getAssign();, +			InsnNode assignInsn = assignArg.getParentInsn();, +			if (assignInsn != null) {, +				String name = makeNameFromInsn(assignInsn);, +				if (name != null && !NameMapper.isReserved(name)) {, +					assignArg.setName(name);, +					return name;, +				}, +			}, +		}, +		return makeNameForType(arg.getType());, +	}, +, +	private String makeNameForType(ArgType type) {, +	private String makeNameForObject(ArgType type) {, +			ClassInfo clsInfo = ClassInfo.fromType(mth.dex(), type);, +	private String makeNameFromInsn(InsnNode insn) {, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +				useClass(code, ClassInfo.fromType(cls.dex(), type));, +						useClass(code, ClassInfo.fromType(cls.dex(), g));, +				useClass(code, ClassInfo.fromType(cls.dex(), type));, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +		this.nameGen = new NameGen(mth, classGen.isFallbackMode());, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.dex.nodes.MethodNode;, +	private final MethodNode mth;, +	public NameGen(MethodNode mth, boolean fallback) {, +		this.mth = mth;, +			varName = guessName(arg);, +	private String guessName(RegisterArg arg) {, +		SSAVar sVar = arg.getSVar();, +		if (sVar != null && sVar.getName() == null) {, +			RegisterArg assignArg = sVar.getAssign();, +			InsnNode assignInsn = assignArg.getParentInsn();, +			if (assignInsn != null) {, +				String name = makeNameFromInsn(assignInsn);, +				if (name != null && !NameMapper.isReserved(name)) {, +					assignArg.setName(name);, +					return name;, +				}, +			}, +		}, +		return makeNameForType(arg.getType());, +	}, +, +	private String makeNameForType(ArgType type) {, +	private String makeNameForObject(ArgType type) {, +			ClassInfo clsInfo = ClassInfo.fromType(mth.dex(), type);, +	private String makeNameFromInsn(InsnNode insn) {, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +	private ClassInfo(DexNode dex, ArgType type) {, +		if (!type.isObject()) {, +			throw new JadxRuntimeException("Not class type: " + type);, +		}, +		splitNames(dex, true);, +	}, +, +	public static ClassInfo fromType(DexNode dex, ArgType type) {, +		ClassInfo cls = dex.getInfoStorage().getCls(type);, +		if (cls != null) {, +			return cls;, +		}, +		cls = new ClassInfo(dex, type);, +		return dex.getInfoStorage().putCls(cls);, +		return fromType(dex, type);, +	public static ClassInfo fromName(DexNode dex, String clsName) {, +		return fromType(dex, ArgType.object(clsName));, +	private void splitNames(DexNode dex, boolean canBeInner) {, +			parentClass = fromName(dex, parClsName);]