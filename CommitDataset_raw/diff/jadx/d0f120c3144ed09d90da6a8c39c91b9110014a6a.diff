[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				StringBuilder sb = new StringBuilder();, +					sb.append(arg(it.next()));, +					if (it.hasNext()) {, +						sb.append(" + ");, +				}, +				// TODO: wrap in braces only if necessary, +				if (state.contains(InsnGenState.BODY_ONLY)) {, +					code.add('(').add(sb.toString()).add(')');, +				} else {, +					code.add(sb.toString());, +				}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				StringBuilder sb = new StringBuilder();, +					sb.append(arg(it.next()));, +					if (it.hasNext()) {, +						sb.append(" + ");, +				}, +				// TODO: wrap in braces only if necessary, +				if (state.contains(InsnGenState.BODY_ONLY)) {, +					code.add('(').add(sb.toString()).add(')');, +				} else {, +					code.add(sb.toString());, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +import jadx.core.dex.instructions.InsnType;, +	public InsnArg wrapInstruction(InsnNode insn) {, +				InsnArg arg;, +				if (insn.getType() == InsnType.MOVE) {, +					arg = insn.getArg(0);, +				} else {, +					arg = wrap(insn);, +				}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				StringBuilder sb = new StringBuilder();, +					sb.append(arg(it.next()));, +					if (it.hasNext()) {, +						sb.append(" + ");, +				}, +				// TODO: wrap in braces only if necessary, +				if (state.contains(InsnGenState.BODY_ONLY)) {, +					code.add('(').add(sb.toString()).add(')');, +				} else {, +					code.add(sb.toString());, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +import jadx.core.dex.instructions.InsnType;, +	public InsnArg wrapInstruction(InsnNode insn) {, +				InsnArg arg;, +				if (insn.getType() == InsnType.MOVE) {, +					arg = insn.getArg(0);, +				} else {, +					arg = wrap(insn);, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, +		prettify(mth);, +	private static void prettify(MethodNode mth) {, +			List<InsnNode> list = block.getInstructions();, +			for (int i = 0; i < list.size(); i++) {, +				InsnNode modInsn = pretifyInsn(mth, list.get(i));, +				if (modInsn != null) {, +					list.set(i, modInsn);, +				}, +					try {, +					} catch (Throwable e) {, +						LOG.debug("Can't convert string concatenation: {} insn: {}", mth, insn, e);, +					}, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +				StringBuilder sb = new StringBuilder();, +					sb.append(arg(it.next()));, +					if (it.hasNext()) {, +						sb.append(" + ");, +				}, +				// TODO: wrap in braces only if necessary, +				if (state.contains(InsnGenState.BODY_ONLY)) {, +					code.add('(').add(sb.toString()).add(')');, +				} else {, +					code.add(sb.toString());, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +import jadx.core.dex.instructions.InsnType;, +	public InsnArg wrapInstruction(InsnNode insn) {, +				InsnArg arg;, +				if (insn.getType() == InsnType.MOVE) {, +					arg = insn.getArg(0);, +				} else {, +					arg = wrap(insn);, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, +		prettify(mth);, +	private static void prettify(MethodNode mth) {, +			List<InsnNode> list = block.getInstructions();, +			for (int i = 0; i < list.size(); i++) {, +				InsnNode modInsn = pretifyInsn(mth, list.get(i));, +				if (modInsn != null) {, +					list.set(i, modInsn);, +				}, +					try {, +					} catch (Throwable e) {, +						LOG.debug("Can't convert string concatenation: {} insn: {}", mth, insn, e);]