[+++ b/jadx-cli/src/main/java/jadx/cli/JadxArgs.java, +package jadx.cli;, +, +import jadx.core.Consts;, +import jadx.api.IJadxArgs;, +import jadx.core.utils.exceptions.JadxException;, +, +import java.io.File;, +import java.io.PrintStream;, +import java.lang.reflect.Field;, +import java.util.ArrayList;, +import java.util.List;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import com.beust.jcommander.JCommander;, +import com.beust.jcommander.Parameter;, +import com.beust.jcommander.ParameterDescription;, +import com.beust.jcommander.ParameterException;, +, +public class JadxArgs implements IJadxArgs {, +	private static final Logger LOG = LoggerFactory.getLogger(JadxArgs.class);, +, +	@Parameter(description = "<input files> (.dex, .apk, .jar or .class)"), +	protected List<String> files;, +, +	@Parameter(names = {"-d", "--output-dir"}, description = "output directory"), +	protected String outDirName;, +, +	@Parameter(names = {"-j", "--threads-count"}, description = "processing threads count"), +	protected int threadsCount = Runtime.getRuntime().availableProcessors();, +, +	@Parameter(names = {"-f", "--fallback"}, description = "make simple dump (using goto instead of 'if', 'for', etc)", help = true), +	protected boolean fallbackMode = false;, +, +	@Parameter(names = {"--cfg"}, description = "save methods control flow graph"), +	protected boolean cfgOutput = false;, +, +	@Parameter(names = {"--raw-cfg"}, description = "save methods control flow graph (use raw instructions)"), +	protected boolean rawCfgOutput = false;, +, +	@Parameter(names = {"-v", "--verbose"}, description = "verbose output"), +	protected boolean verbose = false;, +, +	@Parameter(names = {"-h", "--help"}, description = "print this help", help = true), +	protected boolean printHelp = false;, +, +	private final List<File> input = new ArrayList<File>();, +	private File outputDir;, +, +	private final boolean inputRequired;, +, +	public JadxArgs(String[] args, boolean inputRequired) {, +		this.inputRequired = inputRequired;, +		parse(args);, +		checkArguments();, +	}, +, +	private void parse(String[] args) {, +		try {, +			new JCommander(this, args);, +		} catch (ParameterException e) {, +			System.out.println("Arguments parse error: " + e.getMessage());, +			System.out.println();, +			printHelp = true;, +		}, +	}, +, +	private void checkArguments() {, +		if (isPrintHelp()) {, +			printUsage();, +			System.exit(0);, +		}, +		if (isVerbose()) {, +			ch.qos.logback.classic.Logger rootLogger =, +					(ch.qos.logback.classic.Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);, +			rootLogger.setLevel(ch.qos.logback.classic.Level.DEBUG);, +		}, +		try {, +			processArgs();, +		} catch (JadxException e) {, +			LOG.error(e.getMessage());, +			System.exit(1);, +		}, +	}, +, +	public void processArgs() throws JadxException {, +		if (printHelp), +			return;, +, +		if (threadsCount <= 0), +			throw new JadxException("Threads count must be positive");, +, +		if (files != null) {, +			for (String fileName : files) {, +				File file = new File(fileName);, +				if (file.exists()), +					input.add(file);, +				else]