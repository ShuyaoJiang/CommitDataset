[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfInfo.java, +	private BlockNode outBlock;, +	public BlockNode getOutBlock() {, +		return outBlock;, +	}, +, +	public void setOutBlock(BlockNode outBlock) {, +		this.outBlock = outBlock;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfInfo.java, +	private BlockNode outBlock;, +	public BlockNode getOutBlock() {, +		return outBlock;, +	}, +, +	public void setOutBlock(BlockNode outBlock) {, +		this.outBlock = outBlock;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/LoopRegion.java, +		if (body != null) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfInfo.java, +	private BlockNode outBlock;, +	public BlockNode getOutBlock() {, +		return outBlock;, +	}, +, +	public void setOutBlock(BlockNode outBlock) {, +		this.outBlock = outBlock;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/LoopRegion.java, +		if (body != null) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java, +			if (BlockUtils.checkLastInsnType(block, InsnType.RETURN)) {, +				if (!edges.isEmpty()) {, +		return splitReturn(mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfInfo.java, +	private BlockNode outBlock;, +	public BlockNode getOutBlock() {, +		return outBlock;, +	}, +, +	public void setOutBlock(BlockNode outBlock) {, +		this.outBlock = outBlock;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/LoopRegion.java, +		if (body != null) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java, +			if (BlockUtils.checkLastInsnType(block, InsnType.RETURN)) {, +				if (!edges.isEmpty()) {, +		return splitReturn(mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +import jadx.core.dex.nodes.MethodNode;, +import java.util.Collection;, +import java.util.Set;, +, +		IfNode ifNode = (IfNode) ifBlock.getInstructions().get(0);, +		IfCondition condition = IfCondition.fromIfNode(ifNode);, +		IfInfo info = new IfInfo(condition, ifNode.getThenBlock(), ifNode.getElseBlock());, +		info.setIfBlock(ifBlock);, +		info.getMergedBlocks().add(ifBlock);, +		return info;, +	static IfInfo restructureIf(MethodNode mth, BlockNode block, IfInfo info) {, +		final BlockNode thenBlock = info.getThenBlock();, +		final BlockNode elseBlock = info.getElseBlock();, +, +		// select 'then', 'else' and 'exit' blocks, +		if (thenBlock.contains(AFlag.RETURN) && elseBlock.contains(AFlag.RETURN)) {, +			info.setOutBlock(null);, +			return info;, +		}, +		boolean badThen = !allPathsFromIf(thenBlock, info);, +		boolean badElse = !allPathsFromIf(elseBlock, info);, +		if (badThen && badElse) {, +			return null;, +		}, +		if (badThen || badElse) {, +			if (badElse && isPathExists(thenBlock, elseBlock)) {, +				info = new IfInfo(info.getCondition(), thenBlock, null);, +				info.setOutBlock(elseBlock);, +			} else if (badThen && isPathExists(elseBlock, thenBlock)) {, +				info = IfInfo.invert(info);, +				info = new IfInfo(info.getCondition(), info.getThenBlock(), null);, +				info.setOutBlock(thenBlock);, +			} else if (badElse) {, +				info = new IfInfo(info.getCondition(), thenBlock, null);, +				info.setOutBlock(null);, +			} else {, +				info = IfInfo.invert(info);, +				info = new IfInfo(info.getCondition(), info.getThenBlock(), null);, +				info.setOutBlock(null);, +			}, +		} else {, +			List<BlockNode> thenSC = thenBlock.getCleanSuccessors();]