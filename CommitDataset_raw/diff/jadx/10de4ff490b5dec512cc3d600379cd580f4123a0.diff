[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.codegen.CodeGen;, +	private CodeGen codeGen;, +, +		this.codeGen = new CodeGen(args);, +		ProcessClass.process(cls, passes, codeGen);, +	public IJadxArgs getArgs() {, +		return args;, +	}, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.codegen.CodeGen;, +	private CodeGen codeGen;, +, +		this.codeGen = new CodeGen(args);, +		ProcessClass.process(cls, passes, codeGen);, +	public IJadxArgs getArgs() {, +		return args;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DependencyCollector;, +, +			passes.add(new DependencyCollector());, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.codegen.CodeGen;, +	private CodeGen codeGen;, +, +		this.codeGen = new CodeGen(args);, +		ProcessClass.process(cls, passes, codeGen);, +	public IJadxArgs getArgs() {, +		return args;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DependencyCollector;, +, +			passes.add(new DependencyCollector());, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +import jadx.core.codegen.CodeGen;, +import jadx.core.utils.ErrorsCounter;, +import org.jetbrains.annotations.Nullable;, +import static jadx.core.dex.nodes.ProcessState.GENERATED;, +import static jadx.core.dex.nodes.ProcessState.NOT_LOADED;, +import static jadx.core.dex.nodes.ProcessState.PROCESSED;, +import static jadx.core.dex.nodes.ProcessState.STARTED;, +import static jadx.core.dex.nodes.ProcessState.UNLOADED;, +, +	public static void process(ClassNode cls, List<IDexTreeVisitor> passes, @Nullable CodeGen codeGen) {, +		synchronized (cls) {, +				if (cls.getState() == NOT_LOADED) {, +					cls.setState(STARTED);, +					for (ClassNode clsNode : cls.getDependencies()) {, +						process(clsNode, passes, null);, +					}, +					cls.setState(PROCESSED);, +				}, +				if (cls.getState() == PROCESSED && codeGen != null) {, +					codeGen.visit(cls);, +					cls.setState(GENERATED);, +				}, +				ErrorsCounter.classError(cls, e.getClass().getSimpleName(), e);, +				if (cls.getState() == GENERATED) {, +					cls.setState(UNLOADED);, +				}, +			}, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.codegen.CodeGen;, +	private CodeGen codeGen;, +, +		this.codeGen = new CodeGen(args);, +		ProcessClass.process(cls, passes, codeGen);, +	public IJadxArgs getArgs() {, +		return args;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DependencyCollector;, +, +			passes.add(new DependencyCollector());, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +import jadx.core.codegen.CodeGen;, +import jadx.core.utils.ErrorsCounter;, +import org.jetbrains.annotations.Nullable;, +import static jadx.core.dex.nodes.ProcessState.GENERATED;, +import static jadx.core.dex.nodes.ProcessState.NOT_LOADED;, +import static jadx.core.dex.nodes.ProcessState.PROCESSED;, +import static jadx.core.dex.nodes.ProcessState.STARTED;, +import static jadx.core.dex.nodes.ProcessState.UNLOADED;, +, +	public static void process(ClassNode cls, List<IDexTreeVisitor> passes, @Nullable CodeGen codeGen) {, +		synchronized (cls) {, +				if (cls.getState() == NOT_LOADED) {, +					cls.setState(STARTED);, +					for (ClassNode clsNode : cls.getDependencies()) {, +						process(clsNode, passes, null);, +					}, +					cls.setState(PROCESSED);, +				}, +				if (cls.getState() == PROCESSED && codeGen != null) {]