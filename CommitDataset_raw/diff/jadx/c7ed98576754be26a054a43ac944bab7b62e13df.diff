[+++ b/src/main/java/jadx/codegen/InsnGen.java, +				return mgen.makeArgName(arg);, +	}, +	public boolean makeInsn(InsnNode insn, CodeWriter code) throws CodegenException {, +		return makeInsn(insn, code, false);, +	private boolean makeInsn(InsnNode insn, CodeWriter code, boolean bodyOnly) throws CodegenException {, +					return false;, +		return true;, +			code.add(arg(insn, i));, +			state.add(InsnGenState.NO_RESULT);, +++ b/src/main/java/jadx/codegen/InsnGen.java, +				return mgen.makeArgName(arg);, +	}, +	public boolean makeInsn(InsnNode insn, CodeWriter code) throws CodegenException {, +		return makeInsn(insn, code, false);, +	private boolean makeInsn(InsnNode insn, CodeWriter code, boolean bodyOnly) throws CodegenException {, +					return false;, +		return true;, +			code.add(arg(insn, i));, +			state.add(InsnGenState.NO_RESULT);, +++ b/src/main/java/jadx/codegen/MethodGen.java, +			if (mth.getAttributes().contains(AttributeFlag.INCONSISTENT_CODE), +					&& !mth.getAttributes().contains(AttributeType.JADX_ERROR)) {, +				code.startLine("// jadx: inconsistent code");, +			code.startLine("// jadx: method processing error");, +				code.endl();, +				code.add("/*");, +			makeMethodDump(code, mth);, +				if (mth.getAttributes().contains(AttributeFlag.INCONSISTENT_CODE)) {, +					LOG.debug(ErrorsCounter.formatErrorMsg(mth, " Inconsistent code"));, +					// makeMethodDump(code, mth);, +				}, +	public void makeMethodDump(CodeWriter code, MethodNode mth) {, +		code.startLine("/*");, +		code.startLine("*/");, +		if (mth.getInstructions() == null) {, +			// load original instructions, +			try {, +				mth.load();, +				DepthTraverser.visit(new FallbackModeVisitor(), mth);, +			} catch (DecodeException e) {, +				// ignore, +				code.startLine("Can't load method instructions");, +				return;, +			}, +		}, +				if (insnGen.makeInsn(insn, code)) {, +			} catch (CodegenException e) {, +				code.startLine("// error: " + insn);, +			}, +		}, +++ b/src/main/java/jadx/codegen/InsnGen.java, +				return mgen.makeArgName(arg);, +	}, +	public boolean makeInsn(InsnNode insn, CodeWriter code) throws CodegenException {, +		return makeInsn(insn, code, false);, +	private boolean makeInsn(InsnNode insn, CodeWriter code, boolean bodyOnly) throws CodegenException {, +					return false;, +		return true;, +			code.add(arg(insn, i));, +			state.add(InsnGenState.NO_RESULT);, +++ b/src/main/java/jadx/codegen/MethodGen.java, +			if (mth.getAttributes().contains(AttributeFlag.INCONSISTENT_CODE), +					&& !mth.getAttributes().contains(AttributeType.JADX_ERROR)) {, +				code.startLine("// jadx: inconsistent code");, +			code.startLine("// jadx: method processing error");, +				code.endl();, +				code.add("/*");, +			makeMethodDump(code, mth);, +				if (mth.getAttributes().contains(AttributeFlag.INCONSISTENT_CODE)) {, +					LOG.debug(ErrorsCounter.formatErrorMsg(mth, " Inconsistent code"));, +					// makeMethodDump(code, mth);, +				}, +	public void makeMethodDump(CodeWriter code, MethodNode mth) {, +		code.startLine("/*");, +		code.startLine("*/");, +		if (mth.getInstructions() == null) {, +			// load original instructions, +			try {, +				mth.load();, +				DepthTraverser.visit(new FallbackModeVisitor(), mth);, +			} catch (DecodeException e) {, +				// ignore, +				code.startLine("Can't load method instructions");, +				return;, +			}, +		}, +				if (insnGen.makeInsn(insn, code)) {, +			} catch (CodegenException e) {, +				code.startLine("// error: " + insn);, +			}, +		}, +++ b/src/main/java/jadx/dex/trycatch/ExcHandlerAttr.java, +		return "ExcHandler: ", +				+ (handler.isCatchAll() ? "all" : handler.getCatchType()), +				+ " " + handler.getArg();, +++ b/src/main/java/jadx/codegen/InsnGen.java, +				return mgen.makeArgName(arg);, +	}, +	public boolean makeInsn(InsnNode insn, CodeWriter code) throws CodegenException {]