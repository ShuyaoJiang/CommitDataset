[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +import jadx.core.dex.attributes.AttributeFlag;, +import jadx.core.dex.instructions.ConstClassNode;, +import jadx.core.dex.instructions.ConstStringNode;, +import jadx.core.dex.instructions.FillArrayNode;, +import jadx.core.dex.instructions.IndexInsnNode;, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.dex.instructions.InvokeNode;, +import jadx.core.dex.instructions.SwitchNode;, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.instructions.args.LiteralArg;, +import jadx.core.dex.instructions.args.RegisterArg;, +import jadx.core.dex.nodes.BlockNode;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.InsnNode;, +import jadx.core.dex.nodes.MethodNode;, +		if (mth.isNoCode()) {, +		}, +		ClassNode parentClass = mth.getParentClass();, +									mth.getAttributes().add(AttributeFlag.INCONSISTENT_CODE);, +										FieldNode f = parentClass.getConstFieldByLiteralArg((LiteralArg) arg);, +					case CONST_CLASS: {, +						FieldNode f;, +					}, +							FieldNode f = parentClass.getConstField(sn.getKeys()[k]);, +						if (insn.getArgsCount() > 0 && insn.getArg(0).isLiteral()) {, +							FieldNode f = parentClass.getConstFieldByLiteralArg(arg);, +		if (superCall != null && !parentClass.isEnum() && superCall.getArgsCount() != 0) {, +		if (handlerAttr == null) {, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +import jadx.core.dex.attributes.AttributeFlag;, +import jadx.core.dex.instructions.ConstClassNode;, +import jadx.core.dex.instructions.ConstStringNode;, +import jadx.core.dex.instructions.FillArrayNode;, +import jadx.core.dex.instructions.IndexInsnNode;, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.dex.instructions.InvokeNode;, +import jadx.core.dex.instructions.SwitchNode;, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.instructions.args.LiteralArg;, +import jadx.core.dex.instructions.args.RegisterArg;, +import jadx.core.dex.nodes.BlockNode;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.InsnNode;, +import jadx.core.dex.nodes.MethodNode;, +		if (mth.isNoCode()) {, +		}, +		ClassNode parentClass = mth.getParentClass();, +									mth.getAttributes().add(AttributeFlag.INCONSISTENT_CODE);, +										FieldNode f = parentClass.getConstFieldByLiteralArg((LiteralArg) arg);, +					case CONST_CLASS: {, +						FieldNode f;, +					}, +							FieldNode f = parentClass.getConstField(sn.getKeys()[k]);, +						if (insn.getArgsCount() > 0 && insn.getArg(0).isLiteral()) {, +							FieldNode f = parentClass.getConstFieldByLiteralArg(arg);, +		if (superCall != null && !parentClass.isEnum() && superCall.getArgsCount() != 0) {, +		if (handlerAttr == null) {, +		}, +++ b/jadx-core/src/test/java/jadx/tests/internal/TestInnerClass.java, +import static org.hamcrest.CoreMatchers.not;, +			public class Inner2 extends Thread {, +		assertThat(code, containsString("Inner {"));, +		assertThat(code, containsString("Inner2 extends Thread {"));, +		assertThat(code, not(containsString("super();")));]