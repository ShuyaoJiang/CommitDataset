[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +		return "DEX: " + file;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +		return "DEX: " + file;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.dex.instructions.args.ArgType;, +			} else {, +					List<RegisterArg> args = mth.getArguments(false);, +					if (isRemovedClassInArgs(cls, args)) {, +						modifySyntheticMethod(cls, mth, args);, +					}, +				}, +			}, +		}, +	}, +, +	private static boolean isRemovedClassInArgs(ClassNode cls, List<RegisterArg> mthArgs) {, +		for (RegisterArg arg : mthArgs) {, +			ArgType argType = arg.getType();, +			if (!argType.isObject()) {, +				continue;, +			}, +			ClassNode argCls = cls.dex().resolveClass(argType);, +			if (argCls == null) {, +				// check if missing class from current top class, +				ClassInfo argClsInfo = ClassInfo.fromType(cls.root(), argType);, +				if (argClsInfo.isInner(), +						&& cls.getFullName().startsWith(argClsInfo.getParentClass().getFullName())) {, +					return true;, +				}, +			} else {, +				if (argCls.contains(AFlag.DONT_GENERATE)) {, +					return true;, +				}, +			}, +		}, +		return false;, +	}, +, +	/**, +	 * Remove synthetic constructor and redirect calls to existing constructor, +	 */, +	private static void modifySyntheticMethod(ClassNode cls, MethodNode mth, List<RegisterArg> args) {, +				RegisterArg firstArg = args.get(0);, +				if (firstArg.getType().equals(cls.getParentClass().getClassInfo().getType())) {, +					firstArg.add(AFlag.SKIP_ARG);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +		return "DEX: " + file;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.dex.instructions.args.ArgType;, +			} else {, +					List<RegisterArg> args = mth.getArguments(false);, +					if (isRemovedClassInArgs(cls, args)) {, +						modifySyntheticMethod(cls, mth, args);, +					}, +				}, +			}, +		}, +	}, +, +	private static boolean isRemovedClassInArgs(ClassNode cls, List<RegisterArg> mthArgs) {, +		for (RegisterArg arg : mthArgs) {, +			ArgType argType = arg.getType();, +			if (!argType.isObject()) {, +				continue;, +			}, +			ClassNode argCls = cls.dex().resolveClass(argType);, +			if (argCls == null) {, +				// check if missing class from current top class, +				ClassInfo argClsInfo = ClassInfo.fromType(cls.root(), argType);, +				if (argClsInfo.isInner(), +						&& cls.getFullName().startsWith(argClsInfo.getParentClass().getFullName())) {, +					return true;, +				}, +			} else {, +				if (argCls.contains(AFlag.DONT_GENERATE)) {, +					return true;, +				}, +			}, +		}, +		return false;, +	}, +, +	/**, +	 * Remove synthetic constructor and redirect calls to existing constructor, +	 */, +	private static void modifySyntheticMethod(ClassNode cls, MethodNode mth, List<RegisterArg> args) {, +				RegisterArg firstArg = args.get(0);, +				if (firstArg.getType().equals(cls.getParentClass().getClassInfo().getType())) {, +					firstArg.add(AFlag.SKIP_ARG);, +++ b/jadx-core/src/test/java/jadx/tests/api/SmaliTest.java, +		throw new AssertionError("Smali file not found: " + smaliFile.getAbsolutePath());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +		return "DEX: " + file;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.dex.instructions.args.ArgType;, +			} else {, +					List<RegisterArg> args = mth.getArguments(false);, +					if (isRemovedClassInArgs(cls, args)) {, +						modifySyntheticMethod(cls, mth, args);]