[+++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +	private final JavaNode node;, +	public CodePosition(JavaNode node, int line, int offset) {, +		this.node = node;, +		this.node = null;, +	public JavaNode getNode() {, +		return node;, +	}, +, +		JavaClass parent = node.getDeclaringClass();, +		if (parent == null && node instanceof JavaClass) {, +			return (JavaClass) node;, +		}, +		return parent;, +		return line + ":" + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +	private final JavaNode node;, +	public CodePosition(JavaNode node, int line, int offset) {, +		this.node = node;, +		this.node = null;, +	public JavaNode getNode() {, +		return node;, +	}, +, +		JavaClass parent = node.getDeclaringClass();, +		if (parent == null && node instanceof JavaClass) {, +			return (JavaClass) node;, +		}, +		return parent;, +		return line + ":" + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.MethodNode;, +	private Map<ClassNode, JavaClass> classesMap = new HashMap<ClassNode, JavaClass>();, +	private Map<MethodNode, JavaMethod> methodsMap = new HashMap<MethodNode, JavaMethod>();, +	private Map<FieldNode, JavaField> fieldsMap = new HashMap<FieldNode, JavaField>();, +, +			classesMap.clear();, +				JavaClass javaClass = new JavaClass(classNode, this);, +				clsList.add(javaClass);, +				classesMap.put(classNode, javaClass);, +	Map<ClassNode, JavaClass> getClassesMap() {, +		return classesMap;, +, +	Map<MethodNode, JavaMethod> getMethodsMap() {, +		return methodsMap;, +, +	Map<FieldNode, JavaField> getFieldsMap() {, +		return fieldsMap;, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +	private final JavaNode node;, +	public CodePosition(JavaNode node, int line, int offset) {, +		this.node = node;, +		this.node = null;, +	public JavaNode getNode() {, +		return node;, +	}, +, +		JavaClass parent = node.getDeclaringClass();, +		if (parent == null && node instanceof JavaClass) {, +			return (JavaClass) node;, +		}, +		return parent;, +		return line + ":" + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.MethodNode;, +	private Map<ClassNode, JavaClass> classesMap = new HashMap<ClassNode, JavaClass>();, +	private Map<MethodNode, JavaMethod> methodsMap = new HashMap<MethodNode, JavaMethod>();, +	private Map<FieldNode, JavaField> fieldsMap = new HashMap<FieldNode, JavaField>();, +, +			classesMap.clear();, +				JavaClass javaClass = new JavaClass(classNode, this);, +				clsList.add(javaClass);, +				classesMap.put(classNode, javaClass);, +	Map<ClassNode, JavaClass> getClassesMap() {, +		return classesMap;, +, +	Map<MethodNode, JavaMethod> getMethodsMap() {, +		return methodsMap;, +, +	Map<FieldNode, JavaField> getFieldsMap() {, +		return fieldsMap;, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import java.util.HashMap;, +import org.jetbrains.annotations.Nullable;, +, +		}, +		return code.getCodeStr();, +	public synchronized void decompile() {, +		JadxDecompiler rootDecompiler = getRootDecompiler();, +					rootDecompiler.getClassesMap().put(inner, javaClass);, +					JavaField javaField = new JavaField(f, this);, +					flds.add(javaField);, +					rootDecompiler.getFieldsMap().put(f, javaField);, +					JavaMethod javaMethod = new JavaMethod(this, m);, +					mths.add(javaMethod);, +					rootDecompiler.getMethodsMap().put(m, javaMethod);, +	private JadxDecompiler getRootDecompiler() {, +		if (parent != null) {]