[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfCondition.java, +		return fromIfNode((IfNode) header.getInstructions().get(0));, +	}, +, +	public static IfCondition fromIfNode(IfNode insn) {, +		return new IfCondition(new Compare(insn));, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfCondition.java, +		return fromIfNode((IfNode) header.getInstructions().get(0));, +	}, +, +	public static IfCondition fromIfNode(IfNode insn) {, +		return new IfCondition(new Compare(insn));, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import jadx.core.dex.instructions.args.RegisterArg;, +import static jadx.core.utils.BlockUtils.getBlockByOffset;, +import static jadx.core.utils.BlockUtils.isPathExists;, +import static jadx.core.utils.BlockUtils.selectOther;, +, +					if (isPathExists(loopExit, next)) {, +		BlockNode bThen = getBlockByOffset(ifnode.getTarget(), condBlock.getSuccessors());, +			BlockNode bElse = selectOther(bThen, condBlock.getSuccessors());, +			out = selectOther(loopBody, condBlock.getSuccessors());, +				boolean p = isPathExists(exitBlock, node);, +		BlockNode bThen = getBlockByOffset(ifnode.getTarget(), block.getSuccessors());, +		BlockNode bElse;, +		if (block.getSuccessors().size() == 1) {, +			// TODO eliminate useless 'if' instruction, +			bElse = bThen;, +		} else {, +			bElse = selectOther(bThen, block.getSuccessors());, +		}, +, +		BlockNode thenBlock = null;, +		for (BlockNode d : block.getDominatesOn()) {, +			if (d != bThen && d != bElse) {, +				out = d;, +				break;, +			}, +		}, +, +		IfRegion ifRegion = new IfRegion(currentRegion, block);, +		currentRegion.getSubBlocks().add(ifRegion);, +, +		// merge nested if nodes, +		boolean found;, +		do {, +			found = false;, +			for (BlockNode succ : block.getSuccessors()) {, +				BlockNode nestedIfBlock = getIfNode(succ);, +				if (nestedIfBlock != null && nestedIfBlock != block) {, +					IfNode nestedIfInsn = (IfNode) nestedIfBlock.getInstructions().get(0);, +					BlockNode nbThen = getBlockByOffset(nestedIfInsn.getTarget(), nestedIfBlock.getSuccessors());, +					BlockNode nbElse = selectOther(nbThen, nestedIfBlock.getSuccessors());, +, +					IfCondition condition;, +					boolean inverted = false;, +					if (isPathExists(bElse, nestedIfBlock)) {, +						// else branch, +						if (bThen != nbThen) {, +							if (bThen != nbElse) {, +								break; // not connected conditions, +							}, +							nestedIfInsn.invertOp(nbElse.getStartOffset());, +							inverted = true;, +						}, +						condition = IfCondition.or(ifRegion.getCondition(), IfCondition.fromIfNode(nestedIfInsn));, +					} else {, +						// then branch, +						if (bElse != nbElse) {, +							if (bElse != nbThen) {, +								break; // not connected conditions, +							}, +							nestedIfInsn.invertOp(nbElse.getStartOffset());, +							inverted = true;, +						}, +						condition = IfCondition.and(ifRegion.getCondition(), IfCondition.fromIfNode(nestedIfInsn));, +					}, +					ifRegion.setCondition(condition);, +					nestedIfBlock.getAttributes().add(AttributeFlag.SKIP);, +					// set new blocks, +					if (inverted) {, +						thenBlock = nbElse;, +						elseBlock = nbThen;, +					} else {, +						thenBlock = nbThen;, +						elseBlock = nbElse;, +					}, +					found = true;, +					block = nestedIfBlock;, +					bThen = thenBlock;, +					bElse = elseBlock;, +					break;, +				}, +			}, +		} while (found);, +, +		if (thenBlock == null) {, +			// invert condition (compiler often do it), +			ifnode.invertOp(bElse.getStartOffset());, +			BlockNode tmp = bThen;]