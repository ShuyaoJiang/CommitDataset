[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/TryCatchRegion.java, +		StringBuilder sb = new StringBuilder();, +		sb.append("Try: ").append(tryRegion);, +		if (!catchRegions.isEmpty()) {, +			sb.append(" catches: ").append(Utils.listToString(catchRegions.values()));, +		}, +		if (finallyRegion != null) {, +			sb.append(" finally: ").append(finallyRegion);, +		}, +		return sb.toString();, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/TryCatchRegion.java, +		StringBuilder sb = new StringBuilder();, +		sb.append("Try: ").append(tryRegion);, +		if (!catchRegions.isEmpty()) {, +			sb.append(" catches: ").append(Utils.listToString(catchRegions.values()));, +		}, +		if (finallyRegion != null) {, +			sb.append(" finally: ").append(finallyRegion);, +		}, +		return sb.toString();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockExceptionHandler.java, +		if (handlerAttr == null) {, +			return;, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/TryCatchRegion.java, +		StringBuilder sb = new StringBuilder();, +		sb.append("Try: ").append(tryRegion);, +		if (!catchRegions.isEmpty()) {, +			sb.append(" catches: ").append(Utils.listToString(catchRegions.values()));, +		}, +		if (finallyRegion != null) {, +			sb.append(" finally: ").append(finallyRegion);, +		}, +		return sb.toString();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockExceptionHandler.java, +		if (handlerAttr == null) {, +			return;, +		}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, +import jadx.core.dex.attributes.AType;, +import jadx.core.dex.trycatch.ExcHandlerAttr;, +import jadx.core.dex.trycatch.SplitterBlockAttr;, +import jadx.core.utils.BlockUtils;, +import java.util.HashMap;, +import java.util.Map;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +	private static final Logger LOG = LoggerFactory.getLogger(BlockFinish.class);, +, +			fixSplitterBlock(block);, +, +	/**, +	 * For evey exception handler must be only one splitter block,, +	 * select correct one and remove others if necessary., +	 */, +	private static void fixSplitterBlock(BlockNode block) {, +		ExcHandlerAttr excHandlerAttr = block.get(AType.EXC_HANDLER);, +		if (excHandlerAttr == null) {, +			return;, +		}, +		BlockNode handlerBlock = excHandlerAttr.getHandler().getHandlerBlock();, +		if (handlerBlock.getPredecessors().size() < 2) {, +			return;, +		}, +		Map<BlockNode, SplitterBlockAttr> splitters = new HashMap<BlockNode, SplitterBlockAttr>();, +		for (BlockNode pred : handlerBlock.getPredecessors()) {, +			pred = BlockUtils.skipSyntheticPredecessor(pred);, +			SplitterBlockAttr splitterAttr = pred.get(AType.SPLITTER_BLOCK);, +			if (splitterAttr != null && pred == splitterAttr.getBlock()) {, +				splitters.put(pred, splitterAttr);, +			}, +		}, +		if (splitters.size() < 2) {, +			return;, +		}, +		BlockNode topSplitter = BlockUtils.getTopBlock(splitters.keySet());, +		if (topSplitter == null) {, +			LOG.warn("Unknown top splitter block from list: {}", splitters);, +			return;, +		}, +		for (Map.Entry<BlockNode, SplitterBlockAttr> entry : splitters.entrySet()) {, +			BlockNode pred = entry.getKey();, +			SplitterBlockAttr splitterAttr = entry.getValue();, +			if (pred == topSplitter) {, +				block.addAttr(splitterAttr);, +			} else {, +				pred.remove(AType.SPLITTER_BLOCK);, +				for (BlockNode s : pred.getCleanSuccessors()) {, +					s.remove(AType.SPLITTER_BLOCK);, +				}, +			}, +		}, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/TryCatchRegion.java, +		StringBuilder sb = new StringBuilder();, +		sb.append("Try: ").append(tryRegion);, +		if (!catchRegions.isEmpty()) {, +			sb.append(" catches: ").append(Utils.listToString(catchRegions.values()));, +		}]