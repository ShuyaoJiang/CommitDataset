[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.BlockUtils;, +			if (BlockUtils.isBlockMustBeCleared(b)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.BlockUtils;, +			if (BlockUtils.isBlockMustBeCleared(b)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import jadx.core.utils.BlockUtils;, +			// skip synthetic loop exit blocks, +			BlockUtils.skipPredSyntheticPaths(block);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.BlockUtils;, +			if (BlockUtils.isBlockMustBeCleared(b)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import jadx.core.utils.BlockUtils;, +			// skip synthetic loop exit blocks, +			BlockUtils.skipPredSyntheticPaths(block);, +++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, +	public static boolean isBlockMustBeCleared(BlockNode b) {, +		if (b.contains(AType.EXC_HANDLER) || b.contains(AFlag.SKIP)) {, +			return true;, +		}, +		if (b.contains(AFlag.SYNTHETIC)) {, +			List<BlockNode> s = b.getSuccessors();, +			if (s.size() == 1 && s.get(0).contains(AType.EXC_HANDLER)) {, +				return true;, +			}, +		}, +		return false;, +	}, +, +	/**, +	 * Remove exception handlers from block nodes list, +	 */, +			if (!isBlockMustBeCleared(block)) {, +	 * Remove exception handlers from block nodes bitset, +	 */, +	public static void cleanBitSet(MethodNode mth, BitSet bs) {, +		for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {, +			BlockNode block = mth.getBasicBlocks().get(i);, +			if (isBlockMustBeCleared(block)) {, +				bs.clear(i);, +			}, +		}, +	}, +, +	/**, +	 * Set 'SKIP' flag for all synthetic predecessors from start block., +	 */, +	public static void skipPredSyntheticPaths(BlockNode block) {, +		for (BlockNode pred : block.getPredecessors()) {, +			if (pred.contains(AFlag.SYNTHETIC), +					&& !pred.contains(AType.SPLITTER_BLOCK), +					&& pred.getInstructions().isEmpty()) {, +				pred.add(AFlag.SKIP);, +				skipPredSyntheticPaths(pred);, +			}, +		}, +	}, +, +	/**, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.BlockUtils;, +			if (BlockUtils.isBlockMustBeCleared(b)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import jadx.core.utils.BlockUtils;, +			// skip synthetic loop exit blocks, +			BlockUtils.skipPredSyntheticPaths(block);, +++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, +	public static boolean isBlockMustBeCleared(BlockNode b) {, +		if (b.contains(AType.EXC_HANDLER) || b.contains(AFlag.SKIP)) {, +			return true;, +		}, +		if (b.contains(AFlag.SYNTHETIC)) {, +			List<BlockNode> s = b.getSuccessors();, +			if (s.size() == 1 && s.get(0).contains(AType.EXC_HANDLER)) {, +				return true;, +			}, +		}, +		return false;, +	}, +, +	/**, +	 * Remove exception handlers from block nodes list, +	 */, +			if (!isBlockMustBeCleared(block)) {, +	 * Remove exception handlers from block nodes bitset, +	 */, +	public static void cleanBitSet(MethodNode mth, BitSet bs) {, +		for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {, +			BlockNode block = mth.getBasicBlocks().get(i);, +			if (isBlockMustBeCleared(block)) {, +				bs.clear(i);, +			}, +		}, +	}, +, +	/**, +	 * Set 'SKIP' flag for all synthetic predecessors from start block., +	 */]