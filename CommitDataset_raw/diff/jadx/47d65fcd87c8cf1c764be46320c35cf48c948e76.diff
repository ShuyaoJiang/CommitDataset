[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		ArgType type = classInfo.getType();, +		ArgType[] generics = type.getGenericTypes();, +		if (generics == null) {, +			return baseClass;, +		}, +, +			ArgType wt = gt.getWildcardType();, +			if (wt != null) {, +				int bounds = gt.getWildcardBounds();, +				if (bounds != 0) {, +					sb.append(bounds == -1 ? " super " : " extends ");, +					sb.append(TypeGen.translate(this, wt));, +				}, +			} else {, +				sb.append(TypeGen.translate(this, gt));, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		ArgType type = classInfo.getType();, +		ArgType[] generics = type.getGenericTypes();, +		if (generics == null) {, +			return baseClass;, +		}, +, +			ArgType wt = gt.getWildcardType();, +			if (wt != null) {, +				int bounds = gt.getWildcardBounds();, +				if (bounds != 0) {, +					sb.append(bounds == -1 ? " super " : " extends ");, +					sb.append(TypeGen.translate(this, wt));, +				}, +			} else {, +				sb.append(TypeGen.translate(this, gt));, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +				LOG.error("Error reload instructions in fallback mode:", e);, +				code.startLine("// Can't loadFile method instructions: " + e.getMessage());, +		List<InsnNode> insns = mth.getInstructions();, +		if (insns == null) {, +			code.startLine("// Can't load method instructions.");, +			return;, +		}, +		addFallbackInsns(code, mth, insns, true);, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +		ArgType type = classInfo.getType();, +		ArgType[] generics = type.getGenericTypes();, +		if (generics == null) {, +			return baseClass;, +		}, +, +			ArgType wt = gt.getWildcardType();, +			if (wt != null) {, +				int bounds = gt.getWildcardBounds();, +				if (bounds != 0) {, +					sb.append(bounds == -1 ? " super " : " extends ");, +					sb.append(TypeGen.translate(this, wt));, +				}, +			} else {, +				sb.append(TypeGen.translate(this, gt));, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +				LOG.error("Error reload instructions in fallback mode:", e);, +				code.startLine("// Can't loadFile method instructions: " + e.getMessage());, +		List<InsnNode> insns = mth.getInstructions();, +		if (insns == null) {, +			code.startLine("// Can't load method instructions.");, +			return;, +		}, +		addFallbackInsns(code, mth, insns, true);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +import jadx.core.dex.nodes.parser.SignatureParser;, +		return new ObjectType(obj);, +		return new GenericType(type);, +	}, +, +	public static ArgType wildcard() {, +		return new WildcardType(OBJECT, 0);, +	}, +, +	public static ArgType wildcard(ArgType obj, int bound) {, +		return new WildcardType(obj, bound);, +		return new SignatureParser(sign).consumeType();, +		return new GenericObject(obj, generics);, +	}, +, +	public static ArgType genericInner(ArgType genericType, String innerName, ArgType[] generics) {, +		return new GenericObject((GenericObject) genericType, innerName, generics);, +	private abstract static class KnownType extends ArgType {, +	private static final class PrimitiveArg extends KnownType {, +	private static class ObjectType extends KnownType {, +		public ObjectType(String obj) {, +			return object.equals(((ObjectType) obj).object);, +	private static final class GenericType extends ObjectType {, +		public GenericType(String obj) {, +	private static final class WildcardType extends ObjectType {, +		private final ArgType type;, +		private final int bounds;, +		public WildcardType(ArgType obj, int bound) {, +			super(obj.getObject());, +			this.type = obj;, +			this.bounds = bound;, +		}, +]