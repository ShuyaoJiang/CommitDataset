[+++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +import jadx.core.deobf.NameMapper;, +				char ch = (char) lit;, +				if (!NameMapper.isPrintableChar(ch)) {, +					return Integer.toString(ch);, +				}, +				return stringUtils.unescapeChar(ch);, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +import jadx.core.deobf.NameMapper;, +				char ch = (char) lit;, +				if (!NameMapper.isPrintableChar(ch)) {, +					return Integer.toString(ch);, +				}, +				return stringUtils.unescapeChar(ch);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessVariables.java, +						&& canDeclareInRegion(u, assignRegion), +				if (canDeclareInRegion(u, region)) {, +	private static boolean canDeclareInRegion(Usage u, IRegion region) {, +		// TODO: make index for faster search, +		return isAllRegionsAfter(region, u.getAssigns()), +				&& isAllRegionsAfter(region, u.getUseRegions());, +	private static boolean isAllRegionsAfter(IRegion region, Set<IRegion> others) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +import jadx.core.deobf.NameMapper;, +				char ch = (char) lit;, +				if (!NameMapper.isPrintableChar(ch)) {, +					return Integer.toString(ch);, +				}, +				return stringUtils.unescapeChar(ch);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessVariables.java, +						&& canDeclareInRegion(u, assignRegion), +				if (canDeclareInRegion(u, region)) {, +	private static boolean canDeclareInRegion(Usage u, IRegion region) {, +		// TODO: make index for faster search, +		return isAllRegionsAfter(region, u.getAssigns()), +				&& isAllRegionsAfter(region, u.getUseRegions());, +	private static boolean isAllRegionsAfter(IRegion region, Set<IRegion> others) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +					if (exitBlocks.contains(exitEdge.getSource())) {, +		}, +			Region body = makeRegion(loopStart, stack);, +			loopRegion.setBody(body);, +		BlockNode out = null;, +		if (exitEdges.size() == 1) {, +			Edge exitEdge = exitEdges.get(0);, +					out = nextBlock;, +				}, +			}, +		} else {, +			for (Edge exitEdge : exitEdges) {, +				BlockNode exit = exitEdge.getTarget();, +				List<BlockNode> blocks = BlockUtils.bitSetToBlocks(mth, exit.getDomFrontier());, +				for (BlockNode block : blocks) {, +					if (BlockUtils.isPathExists(exit, block)) {, +						stack.addExit(block);, +						insertBreak(stack, block, exitEdge);, +						out = block;, +					} else {, +						insertBreak(stack, exit, exitEdge);, +					}, +		if (out == null) {, +			out = RegionUtils.isRegionContainsBlock(body, next) ? null : next;, +		return out;, +	private static void traverseMonitorExits(SynchronizedRegion region, InsnArg arg, BlockNode block, Set<BlockNode> exits,, +	                                         Set<BlockNode> visited) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +import jadx.core.deobf.NameMapper;, +				char ch = (char) lit;, +				if (!NameMapper.isPrintableChar(ch)) {, +					return Integer.toString(ch);, +				}, +				return stringUtils.unescapeChar(ch);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessVariables.java, +						&& canDeclareInRegion(u, assignRegion), +				if (canDeclareInRegion(u, region)) {, +	private static boolean canDeclareInRegion(Usage u, IRegion region) {, +		// TODO: make index for faster search, +		return isAllRegionsAfter(region, u.getAssigns()), +				&& isAllRegionsAfter(region, u.getUseRegions());, +	private static boolean isAllRegionsAfter(IRegion region, Set<IRegion> others) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +					if (exitBlocks.contains(exitEdge.getSource())) {, +		}, +			Region body = makeRegion(loopStart, stack);, +			loopRegion.setBody(body);, +		BlockNode out = null;, +		if (exitEdges.size() == 1) {, +			Edge exitEdge = exitEdges.get(0);, +					out = nextBlock;, +				}, +			}, +		} else {, +			for (Edge exitEdge : exitEdges) {, +				BlockNode exit = exitEdge.getTarget();, +				List<BlockNode> blocks = BlockUtils.bitSetToBlocks(mth, exit.getDomFrontier());, +				for (BlockNode block : blocks) {, +					if (BlockUtils.isPathExists(exit, block)) {, +						stack.addExit(block);, +						insertBreak(stack, block, exitEdge);, +						out = block;]