[+++ b/src/main/java/jadx/Consts.java, +	public static final String CLASS_STRING_BUILDER = "java.lang.StringBuilder";, +, +++ b/src/main/java/jadx/Consts.java, +	public static final String CLASS_STRING_BUILDER = "java.lang.StringBuilder";, +, +++ b/src/main/java/jadx/codegen/InsnGen.java, +import java.util.Iterator;, +					code.add("return ").add(arg(insn.getArg(0)));, +				code.add("throw ").add(arg(insn.getArg(0)));, +				code.add(ifield((IndexInsnNode) insn, 1)).add(" = ").add(arg(insn.getArg(0)));, +				code.add(sfield(node)).add(" = ").add(arg(node.getArg(0)));, +				break;, +, +			case STR_CONCAT:, +				// TODO: wrap in braces only if necessary, +				code.add('(');, +				for (Iterator<InsnArg> it = insn.getArguments().iterator(); it.hasNext(); ) {, +					code.add(arg(it.next()));, +					if (it.hasNext()), +						code.add(" + ");, +				}, +				code.add(')');, +++ b/src/main/java/jadx/Consts.java, +	public static final String CLASS_STRING_BUILDER = "java.lang.StringBuilder";, +, +++ b/src/main/java/jadx/codegen/InsnGen.java, +import java.util.Iterator;, +					code.add("return ").add(arg(insn.getArg(0)));, +				code.add("throw ").add(arg(insn.getArg(0)));, +				code.add(ifield((IndexInsnNode) insn, 1)).add(" = ").add(arg(insn.getArg(0)));, +				code.add(sfield(node)).add(" = ").add(arg(node.getArg(0)));, +				break;, +, +			case STR_CONCAT:, +				// TODO: wrap in braces only if necessary, +				code.add('(');, +				for (Iterator<InsnArg> it = insn.getArguments().iterator(); it.hasNext(); ) {, +					code.add(arg(it.next()));, +					if (it.hasNext()), +						code.add(" + ");, +				}, +				code.add(')');, +++ b/src/main/java/jadx/dex/info/MethodInfo.java, +, +	public String getFullId() {, +		return declClass.getFullName() + "." + shortId;, +	}, +++ b/src/main/java/jadx/Consts.java, +	public static final String CLASS_STRING_BUILDER = "java.lang.StringBuilder";, +, +++ b/src/main/java/jadx/codegen/InsnGen.java, +import java.util.Iterator;, +					code.add("return ").add(arg(insn.getArg(0)));, +				code.add("throw ").add(arg(insn.getArg(0)));, +				code.add(ifield((IndexInsnNode) insn, 1)).add(" = ").add(arg(insn.getArg(0)));, +				code.add(sfield(node)).add(" = ").add(arg(node.getArg(0)));, +				break;, +, +			case STR_CONCAT:, +				// TODO: wrap in braces only if necessary, +				code.add('(');, +				for (Iterator<InsnArg> it = insn.getArguments().iterator(); it.hasNext(); ) {, +					code.add(arg(it.next()));, +					if (it.hasNext()), +						code.add(" + ");, +				}, +				code.add(')');, +++ b/src/main/java/jadx/dex/info/MethodInfo.java, +, +	public String getFullId() {, +		return declClass.getFullName() + "." + shortId;, +	}, +++ b/src/main/java/jadx/dex/instructions/InsnType.java, +	STR_CONCAT, // strings concatenation, +, +++ b/src/main/java/jadx/Consts.java, +	public static final String CLASS_STRING_BUILDER = "java.lang.StringBuilder";, +, +++ b/src/main/java/jadx/codegen/InsnGen.java, +import java.util.Iterator;, +					code.add("return ").add(arg(insn.getArg(0)));, +				code.add("throw ").add(arg(insn.getArg(0)));, +				code.add(ifield((IndexInsnNode) insn, 1)).add(" = ").add(arg(insn.getArg(0)));, +				code.add(sfield(node)).add(" = ").add(arg(node.getArg(0)));, +				break;, +, +			case STR_CONCAT:, +				// TODO: wrap in braces only if necessary, +				code.add('(');, +				for (Iterator<InsnArg> it = insn.getArguments().iterator(); it.hasNext(); ) {, +					code.add(arg(it.next()));, +					if (it.hasNext()), +						code.add(" + ");, +				}, +				code.add(')');, +++ b/src/main/java/jadx/dex/info/MethodInfo.java, +, +	public String getFullId() {, +		return declClass.getFullName() + "." + shortId;]