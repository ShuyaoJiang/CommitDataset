[+++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import java.nio.file.Files;, +import java.nio.file.Path;, +import java.nio.file.StandardCopyOption;, +import jadx.core.dex.instructions.args.RegisterArg;, +import jadx.core.dex.nodes.MethodNode;, +	private static final int VERSION = 2;, +	private enum ARG_TYPE {WILDCARD, GENERIC, GENERIC_TYPE, OBJECT, ARRAY, PRIMITIVE}, +, +				cls.load();, +				nClass.setMethods(loadMethods(cls, nClass));, +	private NMethod[] loadMethods(ClassNode cls, NClass nClass) {, +		List<NMethod> methods = new ArrayList<>();, +		for (MethodNode m : cls.getMethods()) {, +			if (!m.getAccessFlags().isPublic(), +					&& !m.getAccessFlags().isProtected()) {, +				continue;, +			}, +, +			List<ArgType> args = new ArrayList<>();, +, +			boolean genericArg = false;, +			for (RegisterArg r: m.getArguments(false)) {, +				ArgType argType = r.getType();, +				if (argType.isGeneric()) {, +					args.add(argType);, +					genericArg = true;, +				} else if (argType.isGenericType()) {, +					args.add(argType);, +					genericArg = true;, +				} else {, +					args.add(null);, +				}, +			}, +, +			ArgType retType = m.getReturnType();, +			if (!retType.isGeneric() && !retType.isGenericType()) {, +				retType = null;, +			}, +, +			boolean varArgs = m.getAccessFlags().isVarArgs();, +, +			if (genericArg || retType != null || varArgs) {, +				methods.add(new NMethod(, +						m.getMethodInfo().getShortId(),, +						args.isEmpty(), +							? new ArgType[0], +							: args.toArray(new ArgType[args.size()]),, +						retType,, +						varArgs));, +			}, +		}, +		return methods.toArray(new NMethod[methods.size()]);, +	}, +, +	void save(Path path) throws IOException {, +		Files.createDirectories(path.getParent());, +		String outputName = path.getFileName().toString();, +			try (BufferedOutputStream outputStream = new BufferedOutputStream(Files.newOutputStream(path))) {, +		} else if (outputName.endsWith(".jar")) {, +			Path temp = Files.createTempFile("jadx", ".zip");, +			Files.copy(path, temp, StandardCopyOption.REPLACE_EXISTING);, +, +			try (ZipOutputStream out = new ZipOutputStream(Files.newOutputStream(path));, +					ZipInputStream in = new ZipInputStream(Files.newInputStream(temp))) {, +				String clst = CLST_PKG_PATH + '/' + CLST_FILENAME;, +				out.putNextEntry(new ZipEntry(clst));, +				save(out);, +				ZipEntry entry = in.getNextEntry();, +				while (entry != null) {, +					if (!entry.getName().equals(clst)) {, +						out.putNextEntry(new ZipEntry(entry.getName()));, +						FileUtils.copyStream(in, out);, +					}, +					entry = in.getNextEntry();, +				}, +			}, +			Files.delete(temp);, +, +		DataOutputStream out = new DataOutputStream(output);, +		Map<String, NClass> names = new HashMap<>(classes.length);, +			names.put(cls.getName(), cls);, +			NMethod[] methods = cls.getMethods();, +			out.writeByte(methods.length);, +			for (NMethod method : methods) {, +				writeMethod(out, method, names);, +	private static void writeMethod(DataOutputStream out, NMethod method, Map<String, NClass> names) throws IOException {, +		int argCount = 0;, +		ArgType[] argTypes = method.getArgType();, +		for (ArgType arg : argTypes) {, +			if (arg != null) {, +				argCount++;, +			}, +		}, +, +		writeLongString(out, method.getShortId());, +		out.writeByte(argCount);, +]