[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java, +import jadx.core.dex.instructions.args.ArgType;, +import java.util.Iterator;, +		if (mth.isNoCode()) {, +		}, +					if (type == InsnType.RETURN || type == InsnType.THROW) {, +					}, +					if (type == InsnType.MONITOR_ENTER || type == InsnType.MONITOR_EXIT) {, +					}, +							if (jump.getSrc() == prevInsn.getOffset()) {, +					}, +							if (jump.getDest() == insn.getOffset()) {, +					}, +						if (targBlock == curBlock) {, +					}, +							if (connBlock != destBlock) {, +		}, +			if (i > 100) {, +		}, +		if (!from.getSuccessors().contains(to)) {, +		}, +		if (!to.getPredecessors().contains(from)) {, +	}, +				if (block == entryBlock) {, +				}, +				if (!d.equals(dset)) {, +			}, +			if (block == entryBlock) {, +			}, +		mth.getExitBlocks().clear();, +				if (insns.get(0).getType() == InsnType.RETURN) {, +					mth.getExitBlocks().add(block);, +				}, +		if (splitReturn(mth)) {, +		if (mergeReturn(mth)) {, +			return true;, +	/**, +	 * Merge return blocks for void methods, +	 */, +	private static boolean mergeReturn(MethodNode mth) {, +		if (mth.getExitBlocks().size() == 1 || !mth.getReturnType().equals(ArgType.VOID)) {, +			return false;, +		}, +		boolean merge = false;, +		for (BlockNode exitBlock : mth.getExitBlocks()) {, +			List<BlockNode> preds = exitBlock.getPredecessors();, +			if (preds.size() == 1) {, +				BlockNode pred = preds.get(0);, +				for (BlockNode otherExitBlock : mth.getExitBlocks()) {, +					if (exitBlock != otherExitBlock, +							&& otherExitBlock.isDominator(pred), +							&& otherExitBlock.getPredecessors().size() == 1) {, +						// merge, +						BlockNode otherPred = otherExitBlock.getPredecessors().get(0);, +						removeConnection(otherPred, otherExitBlock);, +						connect(otherPred, exitBlock);, +						merge = true;, +					}, +				}, +			}, +		}, +		if (merge) {, +			cleanExitNodes(mth);, +		}, +		return merge;, +	}, +, +	/**, +	 * Splice return block if several predecessors presents, +	 */, +	private static boolean splitReturn(MethodNode mth) {, +		if (mth.getExitBlocks().size() != 1) {, +			return false;, +		}, +		boolean split = false;, +		BlockNode exitBlock = mth.getExitBlocks().get(0);, +		if (exitBlock.getPredecessors().size() > 1, +				&& exitBlock.getInstructions().size() == 1, +				&& !exitBlock.getInstructions().get(0).getAttributes().contains(AttributeType.CATCH_BLOCK), +				&& !exitBlock.getAttributes().contains(AttributeFlag.SYNTHETIC)) {, +			InsnNode returnInsn = exitBlock.getInstructions().get(0);, +			List<BlockNode> preds = new ArrayList<BlockNode>(exitBlock.getPredecessors());, +			if (returnInsn.getArgsCount() != 0 && !isReturnArgAssignInPred(mth, preds, returnInsn)) {, +				return false;, +			}, +			split = true;, +			for (BlockNode pred : preds) {, +				BlockNode newRetBlock = startNewBlock(mth, exitBlock.getStartOffset());, +				newRetBlock.getAttributes().add(AttributeFlag.SYNTHETIC);, +				newRetBlock.getInstructions().add(duplicateReturnInsn(returnInsn));, +				removeConnection(pred, exitBlock);, +				connect(pred, newRetBlock);, +			}, +		}, +		if (split) {, +			cleanExitNodes(mth);, +		}, +		return split;, +	}, +]