[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import jadx.core.dex.instructions.args.LiteralArg;, +	public FieldNode getConstFieldByLiteralArg(LiteralArg arg) {, +		ArgType type = arg.getType();, +		long literal = arg.getLiteral();, +, +		if (type.equals(ArgType.DOUBLE)), +			return getConstField(Double.longBitsToDouble(literal));, +		else if (type.equals(ArgType.FLOAT)), +			return getConstField(Float.intBitsToFloat((int) literal));, +		else if (Math.abs(literal) > 0x1) {, +			if (type.equals(ArgType.INT)), +				return getConstField((int) literal);, +			else if (type.equals(ArgType.LONG)), +				return getConstField(literal);, +		}, +		return null;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import jadx.core.dex.instructions.args.LiteralArg;, +	public FieldNode getConstFieldByLiteralArg(LiteralArg arg) {, +		ArgType type = arg.getType();, +		long literal = arg.getLiteral();, +, +		if (type.equals(ArgType.DOUBLE)), +			return getConstField(Double.longBitsToDouble(literal));, +		else if (type.equals(ArgType.FLOAT)), +			return getConstField(Float.intBitsToFloat((int) literal));, +		else if (Math.abs(literal) > 0x1) {, +			if (type.equals(ArgType.INT)), +				return getConstField((int) literal);, +			else if (type.equals(ArgType.LONG)), +				return getConstField(literal);, +		}, +		return null;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java, +		}, +		// splice return block if several predecessors presents, +		for (BlockNode block : mth.getExitBlocks()) {, +			if (block.getInstructions().size() == 1, +			&&  block.getInstructions().get(0).getArgsCount() > 0, +			&& !block.getInstructions().get(0).getAttributes().contains(AttributeType.CATCH_BLOCK), +			&& !block.getAttributes().contains(AttributeFlag.SYNTHETIC)) {, +				InsnNode origReturnInsn = block.getInstructions().get(0);, +					BlockNode newRetBlock;, +					InsnNode predInsn = pred.getInstructions().get(0);, +, +					switch (predInsn.getType()) {, +						case IF:, +							newRetBlock = startNewBlock(mth, block.getStartOffset());, +							newRetBlock.getAttributes().add(AttributeFlag.SYNTHETIC);, +, +							if (pred.getSuccessors().get(0) == block) {, +								pred.getSuccessors().set(0, newRetBlock);, +							} else if (pred.getSuccessors().get(1) == block){, +								pred.getSuccessors().set(1, newRetBlock);, +							}, +							block.getPredecessors().remove(pred);, +							newRetBlock.getPredecessors().add(pred);, +							break;, +, +						case SWITCH:, +							// TODO: is it ok to just skip this predecessor?, +							block.getAttributes().add(AttributeFlag.SYNTHETIC);, +							continue;, +, +						default:, +							removeConnection(pred, block);, +							newRetBlock = pred;, +							break;, +					}, +					if (retArg != null) {, +						ret.getArg(0).forceSetTypedVar(retArg.getTypedVar());, +					}, +				if (block.getPredecessors().size() == 0) {, +					mth.getBasicBlocks().remove(block);, +					mth.getExitBlocks().remove(block);, +				return block.getAttributes().contains(AttributeFlag.SYNTHETIC);, +		}, +		// TODO detect ternary operator, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import jadx.core.dex.instructions.args.LiteralArg;, +	public FieldNode getConstFieldByLiteralArg(LiteralArg arg) {, +		ArgType type = arg.getType();, +		long literal = arg.getLiteral();, +, +		if (type.equals(ArgType.DOUBLE)), +			return getConstField(Double.longBitsToDouble(literal));, +		else if (type.equals(ArgType.FLOAT)), +			return getConstField(Float.intBitsToFloat((int) literal));, +		else if (Math.abs(literal) > 0x1) {, +			if (type.equals(ArgType.INT)), +				return getConstField((int) literal);, +			else if (type.equals(ArgType.LONG)), +				return getConstField(literal);, +		}, +		return null;]