[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, +	public static final Set<InsnType> SEPARATE_INSNS = EnumSet.of(, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, +	public static final Set<InsnType> SEPARATE_INSNS = EnumSet.of(, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +					mth.addWarn("Code restructure failed: missing block: " + block + ", code lost:" + blockCode);, +					// check loop conditions, +	private static String getBlockInsnStr(MethodNode mth, IBlock block) {, +		code.newLine();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, +	public static final Set<InsnType> SEPARATE_INSNS = EnumSet.of(, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +					mth.addWarn("Code restructure failed: missing block: " + block + ", code lost:" + blockCode);, +					// check loop conditions, +	private static String getBlockInsnStr(MethodNode mth, IBlock block) {, +		code.newLine();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java, +import jadx.core.dex.visitors.blocksmaker.BlockSplitter;, +import jadx.core.utils.BlockUtils;, +				LOG.warn("Initial immutable type set rejected: {} -> {}", ssaVar, initType);, +				BlockNode blockNode = entry.getValue();, +				InsnNode lastInsn = BlockUtils.getLastInsn(blockNode);, +				if (lastInsn != null && BlockSplitter.SEPARATE_INSNS.contains(lastInsn.getType())) {, +					if (Consts.DEBUG) {, +						LOG.warn("Can't insert move for PHI in block with separate insn: {}", lastInsn);, +					}, +					return false;, +				}, +, +				blockNode.getInstructions().add(moveInsn);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, +	public static final Set<InsnType> SEPARATE_INSNS = EnumSet.of(, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +					mth.addWarn("Code restructure failed: missing block: " + block + ", code lost:" + blockCode);, +					// check loop conditions, +	private static String getBlockInsnStr(MethodNode mth, IBlock block) {, +		code.newLine();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java, +import jadx.core.dex.visitors.blocksmaker.BlockSplitter;, +import jadx.core.utils.BlockUtils;, +				LOG.warn("Initial immutable type set rejected: {} -> {}", ssaVar, initType);, +				BlockNode blockNode = entry.getValue();, +				InsnNode lastInsn = BlockUtils.getLastInsn(blockNode);, +				if (lastInsn != null && BlockSplitter.SEPARATE_INSNS.contains(lastInsn.getType())) {, +					if (Consts.DEBUG) {, +						LOG.warn("Can't insert move for PHI in block with separate insn: {}", lastInsn);, +					}, +					return false;, +				}, +, +				blockNode.getInstructions().add(moveInsn);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java, +import jadx.core.dex.attributes.AFlag;, +			allowReject = arg.isThis() || arg.contains(AFlag.IMMUTABLE_TYPE);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, +	public static final Set<InsnType> SEPARATE_INSNS = EnumSet.of(, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +					mth.addWarn("Code restructure failed: missing block: " + block + ", code lost:" + blockCode);, +					// check loop conditions, +	private static String getBlockInsnStr(MethodNode mth, IBlock block) {, +		code.newLine();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java, +import jadx.core.dex.visitors.blocksmaker.BlockSplitter;, +import jadx.core.utils.BlockUtils;, +				LOG.warn("Initial immutable type set rejected: {} -> {}", ssaVar, initType);, +				BlockNode blockNode = entry.getValue();, +				InsnNode lastInsn = BlockUtils.getLastInsn(blockNode);, +				if (lastInsn != null && BlockSplitter.SEPARATE_INSNS.contains(lastInsn.getType())) {, +					if (Consts.DEBUG) {, +						LOG.warn("Can't insert move for PHI in block with separate insn: {}", lastInsn);, +					}, +					return false;, +				}, +, +				blockNode.getInstructions().add(moveInsn);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java, +import jadx.core.dex.attributes.AFlag;, +			allowReject = arg.isThis() || arg.contains(AFlag.IMMUTABLE_TYPE);, +++ b/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java, +import jadx.core.dex.visitors.AbstractVisitor;, +import jadx.core.dex.visitors.IDexTreeVisitor;, +import jadx.core.utils.exceptions.JadxException;, +	public static IDexTreeVisitor printRegionsVisitor() {, +		return new AbstractVisitor() {, +			@Override, +			public void visit(MethodNode mth) throws JadxException {, +				printRegions(mth, true);, +			}, +		};, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, +	public static final Set<InsnType> SEPARATE_INSNS = EnumSet.of(, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +					mth.addWarn("Code restructure failed: missing block: " + block + ", code lost:" + blockCode);, +					// check loop conditions, +	private static String getBlockInsnStr(MethodNode mth, IBlock block) {, +		code.newLine();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java, +import jadx.core.dex.visitors.blocksmaker.BlockSplitter;]