[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java, +, +	public boolean isAttrStorageEmpty() {, +		return storage.isEmpty();, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java, +, +	public boolean isAttrStorageEmpty() {, +		return storage.isEmpty();, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +import java.util.Objects;, +		if (insnType != other.insnType) {, +			return false;, +		}, +		int size = arguments.size();, +		if (size != other.arguments.size()) {, +	/**, +	 * 'Hard' equals, compare all arguments, +	 */, +	public boolean isDeepEquals(InsnNode other) {, +		if (this == other) {, +			return true;, +		}, +		return isSame(other), +				&& Objects.equals(arguments, other.arguments);, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java, +, +	public boolean isAttrStorageEmpty() {, +		return storage.isEmpty();, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +import java.util.Objects;, +		if (insnType != other.insnType) {, +			return false;, +		}, +		int size = arguments.size();, +		if (size != other.arguments.size()) {, +	/**, +	 * 'Hard' equals, compare all arguments, +	 */, +	public boolean isDeepEquals(InsnNode other) {, +		if (this == other) {, +			return true;, +		}, +		return isSame(other), +				&& Objects.equals(arguments, other.arguments);, +	}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java, +		if (independentBlockTreeMod(mth)) {, +			clearBlocksState(mth);, +			computeDominators(mth);, +		}, +	private static boolean removeEmptyBlock(MethodNode mth, BlockNode block) {, +		if (block.getInstructions().isEmpty(), +				&& !block.isSynthetic(), +				&& block.isAttrStorageEmpty(), +				&& block.getSuccessors().size() <= 1) {, +			LOG.debug("Removing empty block: {}", block);, +			if (block.getSuccessors().size() == 1) {, +				BlockNode successor = block.getSuccessors().get(0);, +				block.getPredecessors().forEach(pred -> {, +					pred.getSuccessors().remove(block);, +					BlockSplitter.connect(pred, successor);, +					BlockSplitter.replaceTarget(pred, block, successor);, +					pred.updateCleanSuccessors();, +				});, +				BlockSplitter.removeConnection(block, successor);, +			} else {, +				block.getPredecessors().forEach(pred -> {, +					pred.getSuccessors().remove(block);, +					pred.updateCleanSuccessors();, +				});, +			}, +			block.add(AFlag.REMOVE);, +			block.getSuccessors().clear();, +			block.getPredecessors().clear();, +			return true;, +		}, +		return false;, +	}, +, +	private static boolean deduplicateBlockInsns(BlockNode block) {, +		if (block.contains(AFlag.LOOP_START) || block.contains(AFlag.LOOP_END)) {, +			// search for same instruction at end of all predecessors blocks, +			List<BlockNode> predecessors = block.getPredecessors();, +			int predsCount = predecessors.size();, +			if (predsCount > 1) {, +				InsnNode lastInsn = BlockUtils.getLastInsn(block);, +				if (lastInsn != null && lastInsn.getType() == InsnType.IF) {, +					return false;, +				}, +				int sameInsnCount = getSameLastInsnCount(predecessors);, +				if (sameInsnCount > 0) {, +					List<InsnNode> insns = getLastInsns(predecessors.get(0), sameInsnCount);, +					insertAtStart(block, insns);, +					predecessors.forEach(pred -> getLastInsns(pred, sameInsnCount).clear());, +					LOG.debug("Move duplicate insns, count: {} to block {}", sameInsnCount, block);, +					return true;]