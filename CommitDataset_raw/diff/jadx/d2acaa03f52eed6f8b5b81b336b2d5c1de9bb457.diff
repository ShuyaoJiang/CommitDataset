[+++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.dex.instructions.InvokeNode;, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.instructions.args.InsnWrapArg;, +import jadx.core.dex.instructions.mods.ConstructorInsn;, +import jadx.core.dex.nodes.InsnNode;, +import java.util.HashMap;, +import java.util.Map;, +	private static final Map<String, String> OBJ_ALIAS;, +, +	static {, +		OBJ_ALIAS = new HashMap<String, String>();, +		OBJ_ALIAS.put(Consts.CLASS_STRING, "str");, +		OBJ_ALIAS.put(Consts.CLASS_CLASS, "cls");, +		OBJ_ALIAS.put(Consts.CLASS_THROWABLE, "th");, +		OBJ_ALIAS.put(Consts.CLASS_OBJECT, "obj");, +		OBJ_ALIAS.put("java.util.Iterator", "it");, +		OBJ_ALIAS.put("java.lang.Boolean", "bool");, +		OBJ_ALIAS.put("java.lang.Short", "sh");, +		OBJ_ALIAS.put("java.lang.Integer", "num");, +		OBJ_ALIAS.put("java.lang.Character", "ch");, +		OBJ_ALIAS.put("java.lang.Byte", "b");, +		OBJ_ALIAS.put("java.lang.Float", "f");, +		OBJ_ALIAS.put("java.lang.Long", "l");, +		OBJ_ALIAS.put("java.lang.Double", "d");, +	}, +, +			if ("this".equals(name)) {, +			String alias = getAliasForObject(type.getObject());, +			if (alias != null) {, +				return alias;, +			String vName = fromName(shortName);, +			if (vName != null) {, +				return vName;, +, +	private static String fromName(String name) {, +		if (name == null || name.isEmpty()) {, +			return null;, +		}, +		if (name.toUpperCase().equals(name)) {, +			// all characters are upper case, +			return name.toLowerCase();, +		}, +		String v1 = Character.toLowerCase(name.charAt(0)) + name.substring(1);, +		if (!v1.equals(name)) {, +			return v1;, +		}, +		if (name.length() < 3) {, +			return name + "Var";, +		}, +		return null;, +	}, +, +	public static void guessName(RegisterArg arg) {, +		SSAVar sVar = arg.getSVar();, +		if (sVar == null || sVar.getName() != null) {, +			return;, +		}, +		RegisterArg assignArg = sVar.getAssign();, +		InsnNode assignInsn = assignArg.getParentInsn();, +		String name = makeNameFromInsn(assignInsn);, +		if (name != null && !NameMapper.isReserved(name)) {, +			assignArg.setName(name);, +		}, +	}, +, +	public static String getAliasForObject(String name) {, +		return OBJ_ALIAS.get(name);, +	}, +, +	private static String makeNameFromInsn(InsnNode insn) {, +		switch (insn.getType()) {, +			case INVOKE:, +				InvokeNode inv = (InvokeNode) insn;, +				String name = inv.getCallMth().getName();, +				if (name.startsWith("get") || name.startsWith("set")) {, +					return fromName(name.substring(3));, +				}, +				if ("iterator".equals(name)) {, +					return "it";, +				}, +				return name;, +, +			case CONSTRUCTOR:, +				ConstructorInsn co = (ConstructorInsn) insn;, +				return makeNameForObject(co.getClassType().getType());, +, +			case ARRAY_LENGTH:, +				return "length";, +, +			case ARITH:, +			case TERNARY:, +			case CAST:, +				for (InsnArg arg : insn.getArguments()) {, +					if (arg.isInsnWrap()) {, +						InsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();, +						String wName = makeNameFromInsn(wrapInsn);, +						if (wName != null) {, +							return wName;, +						}]