[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +import java.util.Random;, +	private final Map<String, String> tagAttrDeobfNames = new HashMap<>();, +		currentTag = getValidTagAttributeName(getString(startNSName));, +		String attrName = getValidTagAttributeName(getAttributeName(attributeName));, +		String elemName = getValidTagAttributeName(getString(elementNameId));, +	, +	private String getValidTagAttributeName(String originalName) {, +		if(XMLChar.isValidName(originalName)) {, +			return originalName;, +		}, +		if(tagAttrDeobfNames.containsKey(originalName)) {, +			return tagAttrDeobfNames.get(originalName);, +		}, +		String generated;, +		do {, +			generated = generateTagAttrName();, +		}, +		while(tagAttrDeobfNames.containsValue(generated));, +		tagAttrDeobfNames.put(originalName, generated);, +		return generated;, +	}, +	, +	private static String generateTagAttrName() {, +		final int length = 6;, +		Random r = new Random();, +		StringBuilder sb = new StringBuilder();, +		for(int i = 1; i <= length; i++) {, +			sb.append((char)(r.nextInt(26) + 'a'));, +		}, +		return sb.toString();, +	}, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +import java.util.Random;, +	private final Map<String, String> tagAttrDeobfNames = new HashMap<>();, +		currentTag = getValidTagAttributeName(getString(startNSName));, +		String attrName = getValidTagAttributeName(getAttributeName(attributeName));, +		String elemName = getValidTagAttributeName(getString(elementNameId));, +	, +	private String getValidTagAttributeName(String originalName) {, +		if(XMLChar.isValidName(originalName)) {, +			return originalName;, +		}, +		if(tagAttrDeobfNames.containsKey(originalName)) {, +			return tagAttrDeobfNames.get(originalName);, +		}, +		String generated;, +		do {, +			generated = generateTagAttrName();, +		}, +		while(tagAttrDeobfNames.containsValue(generated));, +		tagAttrDeobfNames.put(originalName, generated);, +		return generated;, +	}, +	, +	private static String generateTagAttrName() {, +		final int length = 6;, +		Random r = new Random();, +		StringBuilder sb = new StringBuilder();, +		for(int i = 1; i <= length; i++) {, +			sb.append((char)(r.nextInt(26) + 'a'));, +		}, +		return sb.toString();, +	}, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/XMLChar.java, +/*, + * Licensed to the Apache Software Foundation (ASF) under one or more, + * contributor license agreements.  See the NOTICE file distributed with, + * this work for additional information regarding copyright ownership., + * The ASF licenses this file to You under the Apache License, Version 2.0, + * (the "License"); you may not use this file except in compliance with, + * the License.  You may obtain a copy of the License at, + * , + *      http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package jadx.core.xmlgen;, +, +import java.util.Arrays;, +, +/**, + * This class defines the basic XML character properties. The data, + * in this class can be used to verify that a character is a valid, + * XML character or if the character is a space, name start, or name, + * character., + * <p>, + * A series of convenience methods are supplied to ease the burden, + * of the developer. Because inlining the checks can improve per, + * character performance, the tables of character properties are, + * public. Using the character as an index into the <code>CHARS</code>, + * array and applying the appropriate mask flag (e.g., + * <code>MASK_VALID</code>), yields the same results as calling the, + * convenience methods. There is one exception: check the comments, + * for the <code>isValid</code> method for details.]