[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	FALL_THROUGH,, +, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	FALL_THROUGH,, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import java.util.Collections;, +import java.util.Comparator;, +		Map<BlockNode, BlockNode> fallThroughCases = new LinkedHashMap<BlockNode, BlockNode>();, +, +			BitSet df = s.getDomFrontier();, +			// fall through case block, +			if (df.cardinality() > 1) {, +				if (df.cardinality() > 2) {, +					LOG.debug("Unexpected case pattern, block: {}, mth: {}", s, mth);, +				} else {, +					BlockNode first = mth.getBasicBlocks().get(df.nextSetBit(0));, +					BlockNode second = mth.getBasicBlocks().get(df.nextSetBit(first.getId() + 1));, +					if (second.getDomFrontier().get(first.getId())) {, +						fallThroughCases.put(s, second);, +						df = new BitSet(df.size());, +						df.set(first.getId());, +					} else if (first.getDomFrontier().get(second.getId())) {, +						fallThroughCases.put(s, first);, +						df = new BitSet(df.size());, +						df.set(second.getId());, +					}, +				}, +			}, +			outs.or(df);, +		// check cases order if fall through case exists, +		if (!fallThroughCases.isEmpty()) {, +			if (isBadCasesOrder(blocksMap, fallThroughCases)) {, +				LOG.debug("Fixing incorrect switch cases order");, +				blocksMap = reOrderSwitchCases(blocksMap, fallThroughCases);, +				if (isBadCasesOrder(blocksMap, fallThroughCases)) {, +					LOG.error("Can't fix incorrect switch cases order, method: {}", mth);, +					mth.add(AFlag.INCONSISTENT_CODE);, +				}, +			}, +		}, +, +				outs.andNot(b.getDomFrontier());, +			BlockNode caseBlock = entry.getKey();, +			if (stack.containsExit(caseBlock)) {, +				BlockNode next = fallThroughCases.get(caseBlock);, +				stack.addExit(next);, +				Region caseRegion = makeRegion(caseBlock, stack);, +				stack.removeExit(next);, +				if (next != null) {, +					next.add(AFlag.FALL_THROUGH);, +					caseRegion.add(AFlag.FALL_THROUGH);, +				}, +				sw.addCase(entry.getValue(), caseRegion);, +				// 'break' instruction will be inserted in RegionMakerVisitor.PostRegionVisitor, +	private boolean isBadCasesOrder(final Map<BlockNode, List<Object>> blocksMap,, +			final Map<BlockNode, BlockNode> fallThroughCases) {, +		BlockNode nextCaseBlock = null;, +		for (BlockNode caseBlock : blocksMap.keySet()) {, +			if (nextCaseBlock != null && !caseBlock.equals(nextCaseBlock)) {, +				return true;, +			}, +			nextCaseBlock = fallThroughCases.get(caseBlock);, +		}, +		return nextCaseBlock != null;, +	}, +, +	private Map<BlockNode, List<Object>> reOrderSwitchCases(Map<BlockNode, List<Object>> blocksMap,, +			final Map<BlockNode, BlockNode> fallThroughCases) {, +		List<BlockNode> list = new ArrayList<BlockNode>(blocksMap.size());, +		list.addAll(blocksMap.keySet());, +		Collections.sort(list, new Comparator<BlockNode>() {, +			@Override, +			public int compare(BlockNode a, BlockNode b) {, +				BlockNode nextA = fallThroughCases.get(a);, +				if (nextA != null) {, +					if (b.equals(nextA)) {, +						return -1;, +					}, +				} else if (a.equals(fallThroughCases.get(b))) {, +					return 1;, +				}, +				return 0;, +			}, +		});, +, +		Map<BlockNode, List<Object>> newBlocksMap = new LinkedHashMap<BlockNode, List<Object>>(blocksMap.size());, +		for (BlockNode key : list) {, +			newBlocksMap.put(key, blocksMap.get(key));, +		}, +		return newBlocksMap;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +	FALL_THROUGH,, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import java.util.Collections;, +import java.util.Comparator;]