[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockExceptionHandler.java, +			processTryCatchBlocks(block);, +		ExcHandlerAttr handlerAttr = block.get(AType.EXC_HANDLER);, +		if (!block.getInstructions().isEmpty()) {, +			InsnNode me = block.getInstructions().get(0);, +				resArg.copyAttributesFrom(me);, +				return;, +			}, +		}, +			return eh.isCatchAll() || eh.isFinally();, +	private static void processTryCatchBlocks(BlockNode block) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockExceptionHandler.java, +			processTryCatchBlocks(block);, +		ExcHandlerAttr handlerAttr = block.get(AType.EXC_HANDLER);, +		if (!block.getInstructions().isEmpty()) {, +			InsnNode me = block.getInstructions().get(0);, +				resArg.copyAttributesFrom(me);, +				return;, +			}, +		}, +			return eh.isCatchAll() || eh.isFinally();, +	private static void processTryCatchBlocks(BlockNode block) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, +import jadx.core.dex.trycatch.ExcHandlerAttr;, +					BlockNode newBlock = startNewBlock(mth, insn.getOffset());, +						connect(curBlock, newBlock);, +					curBlock = newBlock;, +						curBlock = connectNewBlock(mth, curBlock, insn.getOffset());, +				curBlock = insertSplitterBlock(mth, blocksMap, curBlock, insn, startNew);, +			} else if (insn.contains(AType.EXC_HANDLER)) {, +				processExceptionHandler(mth, curBlock, insn);, +				curBlock.getInstructions().add(insn);, +			}, +	/**, +	 * Make separate block for exception handler. New block already added if MOVE_EXCEPTION insn exists., +	 * Also link ExceptionHandler with current block., +	 */, +	private static void processExceptionHandler(MethodNode mth, BlockNode curBlock, InsnNode insn) {, +		ExcHandlerAttr excHandlerAttr = insn.get(AType.EXC_HANDLER);, +		insn.remove(AType.EXC_HANDLER);, +, +		BlockNode excHandlerBlock;, +		if (insn.getType() == InsnType.MOVE_EXCEPTION) {, +			excHandlerBlock = curBlock;, +		} else {, +			BlockNode newBlock = startNewBlock(mth, -1);, +			newBlock.add(AFlag.SYNTHETIC);, +			connect(newBlock, curBlock);, +, +			excHandlerBlock = newBlock;, +		}, +		excHandlerBlock.addAttr(excHandlerAttr);, +		excHandlerAttr.getHandler().setHandlerBlock(excHandlerBlock);, +	}, +, +	/**, +	 * For try/catch make empty (splitter) block for connect handlers, +	 */, +	private static BlockNode insertSplitterBlock(MethodNode mth, Map<Integer, BlockNode> blocksMap,, +	                                             BlockNode curBlock, InsnNode insn, boolean startNew) {, +		BlockNode splitterBlock;, +		if (insn.getOffset() == 0 || startNew) {, +			splitterBlock = curBlock;, +		} else {, +			splitterBlock = connectNewBlock(mth, curBlock, insn.getOffset());, +		}, +		blocksMap.put(insn.getOffset(), splitterBlock);, +, +		SplitterBlockAttr splitterAttr = new SplitterBlockAttr(splitterBlock);, +		splitterBlock.add(AFlag.SYNTHETIC);, +		splitterBlock.addAttr(splitterAttr);, +, +		// add this insn in new block, +		BlockNode newBlock = startNewBlock(mth, -1);, +		newBlock.getInstructions().add(insn);, +		newBlock.addAttr(splitterAttr);, +		connect(splitterBlock, newBlock);, +		return newBlock;, +	}, +, +	private static BlockNode connectNewBlock(MethodNode mth, BlockNode curBlock, int offset) {, +		BlockNode block = startNewBlock(mth, offset);, +		connect(curBlock, block);, +		return block;, +	}, +, +				connectExceptionHandlers(block, insn);, +	private static void connectExceptionHandlers(BlockNode block, InsnNode insn) {, +			BlockNode handlerBlock = h.getHandlerBlock();, +				if (!insn.isAttrStorageEmpty()) {, +					return false;, +				}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockExceptionHandler.java, +			processTryCatchBlocks(block);, +		ExcHandlerAttr handlerAttr = block.get(AType.EXC_HANDLER);, +		if (!block.getInstructions().isEmpty()) {, +			InsnNode me = block.getInstructions().get(0);, +				resArg.copyAttributesFrom(me);, +				return;, +			}]