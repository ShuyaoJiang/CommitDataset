[+++ b/src/main/java/jadx/Main.java, +import jadx.dex.visitors.MethodInlinerVisitor;, +			passes.add(new MethodInlinerVisitor());, +++ b/src/main/java/jadx/Main.java, +import jadx.dex.visitors.MethodInlinerVisitor;, +			passes.add(new MethodInlinerVisitor());, +++ b/src/main/java/jadx/codegen/ClassGen.java, +			if (mth.getAttributes().contains(AttributeFlag.DONT_GENERATE)), +				continue;, +, +++ b/src/main/java/jadx/Main.java, +import jadx.dex.visitors.MethodInlinerVisitor;, +			passes.add(new MethodInlinerVisitor());, +++ b/src/main/java/jadx/codegen/ClassGen.java, +			if (mth.getAttributes().contains(AttributeFlag.DONT_GENERATE)), +				continue;, +, +++ b/src/main/java/jadx/codegen/InsnGen.java, +import jadx.dex.attributes.IAttribute;, +import jadx.dex.attributes.MethodInlineAttr;, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.Map.Entry;, +			case ARGS:, +				code.add(arg(insn.getArg(0)));, +				break;, +, +		// inline method if METHOD_INLINE attribute is attached, +		MethodNode callMthNode = mth.dex().resolveMethod(callMth);, +		if (callMthNode != null, +				&& callMthNode.getAttributes().contains(AttributeType.METHOD_INLINE)) {, +			inlineMethod(callMthNode, insn, code);, +			return;, +		}, +, +	private void inlineMethod(MethodNode callMthNode, InvokeNode insn, CodeWriter code) throws CodegenException {, +		IAttribute mia = callMthNode.getAttributes().get(AttributeType.METHOD_INLINE);, +		InsnNode inl = ((MethodInlineAttr) mia).getInsn();, +		if (callMthNode.getMethodInfo().getArgumentsTypes().isEmpty()) {, +			makeInsn(inl, code, true);, +		} else {, +			// remap args, +			InsnArg[] regs = new InsnArg[callMthNode.getRegsCount()];, +			List<RegisterArg> callArgs = callMthNode.getArguments(true);, +			for (int i = 0; i < callArgs.size(); i++) {, +				InsnArg arg = insn.getArg(i);, +				RegisterArg callArg = callArgs.get(i);, +				regs[callArg.getRegNum()] = arg;, +			}, +			// replace args, +			List<RegisterArg> inlArgs = new ArrayList<RegisterArg>();, +			inl.getRegisterArgs(inlArgs);, +			Map<RegisterArg, InsnArg> toRevert = new HashMap<RegisterArg, InsnArg>();, +			for (RegisterArg r : inlArgs) {, +				if (r.getRegNum() >= regs.length) {, +					LOG.warn("Unknown register number {} in method call: {}, {}", r, callMthNode, mth);, +				} else {, +					InsnArg repl = regs[r.getRegNum()];, +					if (repl == null) {, +						LOG.warn("Not passed register {} in method call: {}, {}", r, callMthNode, mth);, +					} else {, +						inl.replaceArg(r, repl);, +						toRevert.put(r, repl);, +					}, +				}, +			}, +			makeInsn(inl, code, true);, +			// revert changes, +			for (Entry<RegisterArg, InsnArg> e : toRevert.entrySet()) {, +				inl.replaceArg(e.getValue(), e.getKey());, +			}, +		}, +	}, +, +		code.add(')');, +++ b/src/main/java/jadx/Main.java, +import jadx.dex.visitors.MethodInlinerVisitor;, +			passes.add(new MethodInlinerVisitor());, +++ b/src/main/java/jadx/codegen/ClassGen.java, +			if (mth.getAttributes().contains(AttributeFlag.DONT_GENERATE)), +				continue;, +, +++ b/src/main/java/jadx/codegen/InsnGen.java, +import jadx.dex.attributes.IAttribute;, +import jadx.dex.attributes.MethodInlineAttr;, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.Map.Entry;, +			case ARGS:, +				code.add(arg(insn.getArg(0)));, +				break;, +, +		// inline method if METHOD_INLINE attribute is attached, +		MethodNode callMthNode = mth.dex().resolveMethod(callMth);, +		if (callMthNode != null, +				&& callMthNode.getAttributes().contains(AttributeType.METHOD_INLINE)) {]