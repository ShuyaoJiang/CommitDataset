[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayNode.java, +import jadx.core.dex.nodes.DexNode;, +	public void mergeElementType(DexNode dex, ArgType foundElemType) {, +		ArgType r = ArgType.merge(dex, elemType, foundElemType);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayNode.java, +import jadx.core.dex.nodes.DexNode;, +	public void mergeElementType(DexNode dex, ArgType foundElemType) {, +		ArgType r = ArgType.merge(dex, elemType, foundElemType);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +import jadx.core.dex.nodes.DexNode;, +	public static ArgType merge(@Nullable DexNode dex, ArgType a, ArgType b) {, +		ArgType res = mergeInternal(dex, a, b);, +			res = mergeInternal(dex, b, a); // swap, +	private static ArgType mergeInternal(@Nullable DexNode dex, ArgType a, ArgType b) {, +			return mergeArrays(dex, (ArrayArg) a, b);, +			return mergeArrays(dex, (ArrayArg) b, a);, +				if (dex == null) {, +					return null;, +				}, +				String obj = dex.root().getClsp().getCommonAncestor(aObj, bObj);, +	private static ArgType mergeArrays(DexNode dex, ArrayArg array, ArgType b) {, +			ArgType res = merge(dex, ea, eb);, +	public static boolean isCastNeeded(DexNode dex, ArgType from, ArgType to) {, +				&& dex.root().getClsp().isImplements(from.getObject(), to.getObject())) {, +	public static boolean isInstanceOf(DexNode dex, ArgType type, ArgType of) {, +		return dex.root().getClsp().isImplements(type.getObject(), of.getObject());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayNode.java, +import jadx.core.dex.nodes.DexNode;, +	public void mergeElementType(DexNode dex, ArgType foundElemType) {, +		ArgType r = ArgType.merge(dex, elemType, foundElemType);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +import jadx.core.dex.nodes.DexNode;, +	public static ArgType merge(@Nullable DexNode dex, ArgType a, ArgType b) {, +		ArgType res = mergeInternal(dex, a, b);, +			res = mergeInternal(dex, b, a); // swap, +	private static ArgType mergeInternal(@Nullable DexNode dex, ArgType a, ArgType b) {, +			return mergeArrays(dex, (ArrayArg) a, b);, +			return mergeArrays(dex, (ArrayArg) b, a);, +				if (dex == null) {, +					return null;, +				}, +				String obj = dex.root().getClsp().getCommonAncestor(aObj, bObj);, +	private static ArgType mergeArrays(DexNode dex, ArrayArg array, ArgType b) {, +			ArgType res = merge(dex, ea, eb);, +	public static boolean isCastNeeded(DexNode dex, ArgType from, ArgType to) {, +				&& dex.root().getClsp().isImplements(from.getObject(), to.getObject())) {, +	public static boolean isInstanceOf(DexNode dex, ArgType type, ArgType of) {, +		return dex.root().getClsp().isImplements(type.getObject(), of.getObject());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java, +				ArgType m = ArgType.merge(null, type, ArgType.NARROW_NUMBERS);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayNode.java, +import jadx.core.dex.nodes.DexNode;, +	public void mergeElementType(DexNode dex, ArgType foundElemType) {, +		ArgType r = ArgType.merge(dex, elemType, foundElemType);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +import jadx.core.dex.nodes.DexNode;, +	public static ArgType merge(@Nullable DexNode dex, ArgType a, ArgType b) {, +		ArgType res = mergeInternal(dex, a, b);, +			res = mergeInternal(dex, b, a); // swap, +	private static ArgType mergeInternal(@Nullable DexNode dex, ArgType a, ArgType b) {, +			return mergeArrays(dex, (ArrayArg) a, b);, +			return mergeArrays(dex, (ArrayArg) b, a);, +				if (dex == null) {, +					return null;, +				}, +				String obj = dex.root().getClsp().getCommonAncestor(aObj, bObj);, +	private static ArgType mergeArrays(DexNode dex, ArrayArg array, ArgType b) {, +			ArgType res = merge(dex, ea, eb);, +	public static boolean isCastNeeded(DexNode dex, ArgType from, ArgType to) {, +				&& dex.root().getClsp().isImplements(from.getObject(), to.getObject())) {, +	public static boolean isInstanceOf(DexNode dex, ArgType type, ArgType of) {, +		return dex.root().getClsp().isImplements(type.getObject(), of.getObject());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java, +				ArgType m = ArgType.merge(null, type, ArgType.NARROW_NUMBERS);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/Typed.java, +import jadx.core.dex.nodes.DexNode;, +, +	public boolean merge(DexNode dex, ArgType newType) {, +		ArgType m = ArgType.merge(dex, type, newType);, +	public boolean merge(DexNode dex, InsnArg arg) {, +		return merge(dex, arg.getType());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayNode.java, +import jadx.core.dex.nodes.DexNode;, +	public void mergeElementType(DexNode dex, ArgType foundElemType) {, +		ArgType r = ArgType.merge(dex, elemType, foundElemType);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +import jadx.core.dex.nodes.DexNode;, +	public static ArgType merge(@Nullable DexNode dex, ArgType a, ArgType b) {, +		ArgType res = mergeInternal(dex, a, b);, +			res = mergeInternal(dex, b, a); // swap, +	private static ArgType mergeInternal(@Nullable DexNode dex, ArgType a, ArgType b) {, +			return mergeArrays(dex, (ArrayArg) a, b);, +			return mergeArrays(dex, (ArrayArg) b, a);, +				if (dex == null) {, +					return null;, +				}, +				String obj = dex.root().getClsp().getCommonAncestor(aObj, bObj);, +	private static ArgType mergeArrays(DexNode dex, ArrayArg array, ArgType b) {, +			ArgType res = merge(dex, ea, eb);, +	public static boolean isCastNeeded(DexNode dex, ArgType from, ArgType to) {]