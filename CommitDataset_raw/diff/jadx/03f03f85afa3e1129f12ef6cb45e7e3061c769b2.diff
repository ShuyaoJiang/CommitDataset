[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, +	public ConstructorInsn(MethodInfo callMth, CallType callType, RegisterArg instanceArg) {, +		super(InsnType.CONSTRUCTOR, callMth.getArgsCount());, +		this.callMth = callMth;, +		this.callType = callType;, +		this.instanceArg = instanceArg;, +	}, +, +	public CallType getCallType() {, +		return callType;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, +	public ConstructorInsn(MethodInfo callMth, CallType callType, RegisterArg instanceArg) {, +		super(InsnType.CONSTRUCTOR, callMth.getArgsCount());, +		this.callMth = callMth;, +		this.callType = callType;, +		this.instanceArg = instanceArg;, +	}, +, +	public CallType getCallType() {, +		return callType;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +import jadx.core.codegen.TypeGen;, +				ConstructorInsn replace = processConstructor(mth, co);, +				if (replace != null) {, +					replaceInsn(block, insnNumber, replace);, +				}, +	 * Replace call of synthetic constructor, +	 */, +	private static ConstructorInsn processConstructor(MethodNode mth, ConstructorInsn co) {, +		MethodNode callMth = mth.dex().resolveMethod(co.getCallMth());, +		if (callMth != null, +				&& callMth.getAccessFlags().isSynthetic(), +				&& allArgsNull(co)) {, +			// if all arguments is null => replace with default constructor, +			ClassNode classNode = mth.dex().resolveClass(callMth.getParentClass().getClassInfo());, +			boolean passThis = co.getArgsCount() >= 1 && co.getArg(0).isThis();, +			String ctrId = "<init>(" + (passThis ? TypeGen.signature(co.getArg(0).getType()) : "") + ")V";, +			MethodNode defCtr = classNode.searchMethodByName(ctrId);, +			if (defCtr != null) {, +				ConstructorInsn newInsn = new ConstructorInsn(defCtr.getMethodInfo(), co.getCallType(), co.getInstanceArg());, +				newInsn.setResult(co.getResult());, +				return newInsn;, +			}, +		}, +		return null;, +	}, +, +	private static boolean allArgsNull(InsnNode insn) {, +		for (InsnArg insnArg : insn.getArguments()) {, +			if (insnArg.isLiteral()) {, +				LiteralArg lit = (LiteralArg) insnArg;, +				if (lit.getLiteral() != 0) {, +					return false;, +				}, +			} else if (!insnArg.isThis()) {, +				return false;, +			}, +		}, +		return true;, +	}, +, +	/**, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, +	public ConstructorInsn(MethodInfo callMth, CallType callType, RegisterArg instanceArg) {, +		super(InsnType.CONSTRUCTOR, callMth.getArgsCount());, +		this.callMth = callMth;, +		this.callType = callType;, +		this.instanceArg = instanceArg;, +	}, +, +	public CallType getCallType() {, +		return callType;, +	}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +import jadx.core.codegen.TypeGen;, +				ConstructorInsn replace = processConstructor(mth, co);, +				if (replace != null) {, +					replaceInsn(block, insnNumber, replace);, +				}, +	 * Replace call of synthetic constructor, +	 */, +	private static ConstructorInsn processConstructor(MethodNode mth, ConstructorInsn co) {, +		MethodNode callMth = mth.dex().resolveMethod(co.getCallMth());, +		if (callMth != null, +				&& callMth.getAccessFlags().isSynthetic(), +				&& allArgsNull(co)) {, +			// if all arguments is null => replace with default constructor, +			ClassNode classNode = mth.dex().resolveClass(callMth.getParentClass().getClassInfo());, +			boolean passThis = co.getArgsCount() >= 1 && co.getArg(0).isThis();, +			String ctrId = "<init>(" + (passThis ? TypeGen.signature(co.getArg(0).getType()) : "") + ")V";, +			MethodNode defCtr = classNode.searchMethodByName(ctrId);, +			if (defCtr != null) {, +				ConstructorInsn newInsn = new ConstructorInsn(defCtr.getMethodInfo(), co.getCallType(), co.getInstanceArg());, +				newInsn.setResult(co.getResult());, +				return newInsn;]