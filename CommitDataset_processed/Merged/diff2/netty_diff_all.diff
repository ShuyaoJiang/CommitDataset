[+++ b/pom.xml, + <version>2-SNAPSHOT</version>, +++ b/pom.xml, + <version>2-SNAPSHOT</version>, +++ /dev/null, +++ b/pom.xml, + <version>2-SNAPSHOT</version>, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, + <version>2-SNAPSHOT</version>, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, + <version>2-SNAPSHOT</version>, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, + <version>2-SNAPSHOT</version>, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, + <version>2-SNAPSHOT</version>, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannel.java, +/*, + * Copyright 2011 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +, + @Test, + public void testInternalNioBuffer() {, + testInternalNioBuffer(128);, + testInternalNioBuffer(1024);, + testInternalNioBuffer(4 * 1024);, + testInternalNioBuffer(64 * 1024);, + testInternalNioBuffer(32 * 1024 * 1024);, + testInternalNioBuffer(64 * 1024 * 1024);, + }, +, + private void testInternalNioBuffer(int a) {, + ByteBuf buffer = freeLater(newBuffer(2));, + ByteBuffer buf = buffer.internalNioBuffer(0, 1);, + assertEquals(1, buf.remaining());, +, + for (int i = 0; i < a; i++) {, + buffer.writeByte(i);, + }, +, + buf = buffer.internalNioBuffer(0, a);, + assertEquals(a, buf.remaining());, +, + for (int i = 0; i < a; i++) {, + assertEquals((byte) i, buf.get());, +
[+++ b/codec/src/main/java/io/netty/handler/codec/serialization/CompactObjectInputStream.java, + return ObjectStreamClass.lookupAny(clazz);]
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java, +import io.netty.util.internal.PlatformDependent;, + // If on windows just use the DefaultDnsServerAddressStreamProvider.INSTANCE as otherwise, + // we will log some error which may be confusing., + PlatformDependent.isWindows() ? DefaultDnsServerAddressStreamProvider.INSTANCE :]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + // Clean-up the previous decoder if not cleaned up correctly., + ByteBuf buf = decoder.readInbound();]
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +import io.netty.handler.codec.dns.DnsRawRecord;, +import io.netty.handler.codec.dns.DnsRecord;, +import static io.netty.util.internal.ObjectUtil.checkNonEmpty;, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +import static io.netty.util.internal.ObjectUtil.checkPositive;, +import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;, + private InetAddress loopbackAddress() {, + if (inetHost == null || inetHost.isEmpty()) {, + // If an empty hostname is used we should use "localhost", just like InetAddress.getByName(...) does., + promise.setSuccess(loopbackAddress());, + return;, + }, + if (inetHost == null || inetHost.isEmpty()) {, + // If an empty hostname is used we should use "localhost", just like InetAddress.getAllByName(...) does., + promise.setSuccess(Collections.singletonList(loopbackAddress()));, + return;, + }, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +import io.netty.handler.codec.dns.DnsRawRecord;, +import io.netty.handler.codec.dns.DnsRecord;, +import static io.netty.util.internal.ObjectUtil.checkNonEmpty;, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +import static io.netty.util.internal.ObjectUtil.checkPositive;, +import
[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, + private final EventExecutorGroup parent;, +, + protected AbstractEventExecutor() {, + this(null);, + }, +, + protected AbstractEventExecutor(EventExecutorGroup parent) {, + this.parent = parent;, + }, +, + @Override, + public EventExecutorGroup parent() {, + return parent;, + }, +, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, + private final EventExecutorGroup parent;, +, + protected AbstractEventExecutor() {, + this(null);, + }, +, + protected AbstractEventExecutor(EventExecutorGroup parent) {, + this.parent = parent;, + }, +, + @Override, + public EventExecutorGroup parent() {, + return parent;, + }, +, +++ b/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java, + // Waken up., +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, + private final EventExecutorGroup parent;, +, +
[+++ b/all/pom.xml, + <artifactId>netty-codec-redis</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-codec-xml</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>]
[+++ b/all/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, + * specified message. If {@code set} is {@code true},, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, + * specified message. If {@code set} is {@code true},, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java, + * specified message. If {@code expected} is {@code true},]
[+++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java, + * <li>Request #2 for {@code /file1.txt} does not return the contents of the]
[+++ b/codec-socks/src/main/java/io/netty/codec/socks/SocksMessage.java, + return b;, + return b;, + return b;, + return b;, + return b;, + return b;, +++ b/codec-socks/src/main/java/io/netty/codec/socks/SocksMessage.java, + return b;, + return b;, + return b;, + return b;, + return b;, + return b;, +++ b/codec-socks/src/test/java/io/netty/codec/socks/SocksAuthRequestDecoderTest.java, +import org.slf4j.Logger;, + private static final Logger logger = LoggerFactory.getLogger(SocksAuthRequestDecoderTest.class);, +++ b/codec-socks/src/main/java/io/netty/codec/socks/SocksMessage.java, + return b;, + return b;, + return b;, + return b;, + return b;, + return b;, +++ b/codec-socks/src/test/java/io/netty/codec/socks/SocksAuthRequestDecoderTest.java, +import org.slf4j.Logger;, + private static final Logger logger = LoggerFactory.getLogger(SocksAuthRequestDecoderTest.class);, +++ b/codec-socks/src/test/java/io/netty/codec/socks/SocksAuthResponseDecoderTest.java, +import org.slf4j.Logger;, + private static final Logger logger = LoggerFactory.getLogger(SocksAuthResponseDecoderTest.class);, +++ b/codec-socks/src/main/java/io/netty/codec/socks/SocksMessage.java, +
[+++ b/codec-mqtt/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-mqtt/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + *
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + request.addHeader(Names.ORIGIN, originValue);, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + request.addHeader(Names.ORIGIN, originValue);, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + request.addHeader(Names.ORIGIN, originValue);, +]
[+++ b/common/src/main/java/io/netty/util/internal/DetectionUtil.java, + String os = SystemPropertyUtil.get("os.name").toLowerCase();, + boolean noUnsafe = SystemPropertyUtil.getBoolean("io.netty.noUnsafe", false);, + if (noUnsafe) {, + boolean tryUnsafe = false;, + if (SystemPropertyUtil.contains("io.netty.tryUnsafe")) {, + tryUnsafe = SystemPropertyUtil.getBoolean("io.netty.tryUnsafe", true);, + } else {, + tryUnsafe = SystemPropertyUtil.getBoolean("org.jboss.netty.tryUnsafe", true);, +, + if (!tryUnsafe) {, +, +++ b/common/src/main/java/io/netty/util/internal/DetectionUtil.java, + String os = SystemPropertyUtil.get("os.name").toLowerCase();, + boolean noUnsafe = SystemPropertyUtil.getBoolean("io.netty.noUnsafe", false);, + if (noUnsafe) {, + boolean tryUnsafe = false;, + if (SystemPropertyUtil.contains("io.netty.tryUnsafe")) {, + tryUnsafe = SystemPropertyUtil.getBoolean("io.netty.tryUnsafe", true);, + } else {, + tryUnsafe = SystemPropertyUtil.getBoolean("org.jboss.netty.tryUnsafe", true);, +, + if (!tryUnsafe) {, +, +++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, +,
[+++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, +import java.io.ByteArrayOutputStream;, +import java.lang.reflect.Method;, +import java.security.AccessController;, +import java.security.PrivilegedAction;, + load(name, loader);, + * Load the given library with the specified {@link ClassLoader}, + loadLibrary(loader, name, false);, + loadLibrary(loader, tmpFile.getPath(), true);, + closeQuietly(in);, + closeQuietly(out);, + /**, + * Loading the native library into the specified {@link ClassLoader}., + * @param loader - The {@link ClassLoader} where the native library will be loaded into, + * @param name - The native library path or name, + * @param absolute - Whether the native library will be loaded by path or by name, + */, + private static void
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java, + while (!inflater.needsInput()) {, + if (length == 0) {, + // completely filled the buffer allocate a new one and start to fill it, + out.add(decompressed);, + decompressed = ctx.alloc().heapBuffer(maxOutputLength);, + outArray = decompressed.array();, + continue;, + }, + int outputLength = inflater.inflate(outArray, outIndex, length);, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java, + while (!inflater.needsInput()) {, + if (length == 0) {, + // completely filled the buffer allocate a new one and start to fill it, + out.add(decompressed);, + decompressed = ctx.alloc().heapBuffer(maxOutputLength);, + outArray = decompressed.array();, + continue;, + }, + int outputLength = inflater.inflate(outArray, outIndex, length);, +++ b/codec/src/test/java/io/netty/handler/codec/compression/ZlibTest.java, +import
[+++ b/common/src/test/java/io/netty/util/HashedWheelTimerTest.java, + @Test(timeout = 3000), + final CountDownLatch latch = new CountDownLatch(3);, + timerProcessed.newTimeout(new TimerTask() {, + @Override, + public void run(final Timeout timeout) throws Exception {, + latch.countDown();, + }, 1, TimeUnit.MILLISECONDS);, + }, +, + latch.await();, + @Test(timeout = 3000), + final CountDownLatch latch = new CountDownLatch(3);, + latch.countDown();, + latch.await();, + timer.newTimeout(createNoOpTimerTask(), 1, TimeUnit.MILLISECONDS);, + fail("Expected exception didn't occur.");, + } catch (IllegalStateException ignored) {, + // expected, + @Test(timeout = 5000), + final CountDownLatch latch = new CountDownLatch(3);, + timer.newTimeout(this, 100, TimeUnit.MILLISECONDS);, + latch.countDown();, + }, 100, TimeUnit.MILLISECONDS);, +, + latch.await();, + assertFalse(timer.stop().isEmpty());, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + // Acknowledge receipt of the settings. We should do this before we process the settings to ensure our, + // remote peer applies these settings before any subsequent frames that we may send which depend upon these, + // new settings. See https://github.com/netty/netty/issues/6520., + encoder.remoteSettings(settings);, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + // Acknowledge receipt of the settings. We should do this before we process the settings to ensure our, + // remote peer applies these settings before any subsequent frames that we may send which depend upon these, + // new settings. See https://github.com/netty/netty/issues/6520., + encoder.remoteSettings(settings);, +, +++
[+++ b/common/src/main/java/io/netty/util/concurrent/FastThreadLocal.java, + if (FastThreadLocalThread.willCleanupFastThreadLocals(current) || threadLocalMap.isCleanerFlagSet(index)) {, +, + threadLocalMap.setCleanerFlag(index);, +++ b/common/src/main/java/io/netty/util/concurrent/FastThreadLocal.java, + if (FastThreadLocalThread.willCleanupFastThreadLocals(current) || threadLocalMap.isCleanerFlagSet(index)) {, +, + threadLocalMap.setCleanerFlag(index);, +++ b/common/src/main/java/io/netty/util/internal/InternalThreadLocalMap.java, +import java.util.BitSet;, + private BitSet cleanerFlags;, +, +, + public boolean isCleanerFlagSet(int index) {, + return cleanerFlags != null && cleanerFlags.get(index);, + }, +, + public void setCleanerFlag(int index) {, + if (cleanerFlags == null) {, + cleanerFlags = new BitSet();, + }, + cleanerFlags.set(index);, + }, +++ b/common/src/main/java/io/netty/util/concurrent/FastThreadLocal.java, + if (FastThreadLocalThread.willCleanupFastThreadLocals(current) || threadLocalMap.isCleanerFlagSet(index)) {, +, + threadLocalMap.setCleanerFlag(index);, +++ b/common/src/main/java/io/netty/util/internal/InternalThreadLocalMap.java, +import java.util.BitSet;, + private BitSet cleanerFlags;, +, +, + public boolean isCleanerFlagSet(int index) {, +
[+++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyUnsafeDirectByteBuf.java, + @Override, + public boolean hasMemoryAddress() {, + return true;, + }, +, + @Override, + public long memoryAddress() {, + return memoryAddress;, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyUnsafeDirectByteBuf.java, + @Override, + public boolean hasMemoryAddress() {, + return true;, + }, +, + @Override, + public long memoryAddress() {, + return memoryAddress;, + }, +, +++ b/buffer/src/test/java/io/netty/buffer/ReadOnlyDirectByteBufferBufTest.java, +, + @Test, + public void testMemoryAddress() {, + ByteBuf buf = buffer(allocate(8).asReadOnlyBuffer());, + try {, + Assert.assertFalse(buf.hasMemoryAddress());, + try {, + buf.memoryAddress();, + Assert.fail();, + } catch (UnsupportedOperationException expected) {, + // expected, + }, + } finally {, +
[+++ b/bom/pom.xml, + <groupId>org.sonatype.oss</groupId>, + <artifactId>oss-parent</artifactId>, + <version>7</version>, + <relativePath />, + <groupId>io.netty</groupId>, + <version>4.1.10.Final-SNAPSHOT</version>, + <description>Netty (Bill of Materials)</description>, + <url>http://netty.io/</url>, +, + <organization>, + <name>The Netty Project</name>, + <url>http://netty.io/</url>, + </organization>, +, + <licenses>, + <license>, + <name>Apache License, Version 2.0</name>, + <url>http://www.apache.org/licenses/LICENSE-2.0</url>, + </license>, + </licenses>, + <inceptionYear>2008</inceptionYear>, +, + <scm>, + <url>https://github.com/netty/netty</url>, + <connection>scm:git:git://github.com/netty/netty.git</connection>, + <developerConnection>scm:git:ssh://git@github.com/netty/netty.git</developerConnection>, + <tag>HEAD</tag>, + </scm>, +, + <developers>, + <developer>, + <id>netty.io</id>, + <name>The Netty Project Contributors</name>, + <email>netty@googlegroups.com</email>, + <url>http://netty.io/</url>, + <organization>The Netty Project</organization>, + <organizationUrl>http://netty.io/</organizationUrl>, + </developer>, + </developers>, + <groupId>io.netty</groupId>, + <version>4.1.10.Final-SNAPSHOT</version>, + <groupId>io.netty</groupId>, + <version>4.1.10.Final-SNAPSHOT</version>, +
[+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, + incrementPendingOutboundBytes(size);, + void incrementPendingOutboundBytes(int size) {, + void decrementPendingOutboundBytes(int size) {, + decrementPendingOutboundBytes(size);, + decrementPendingOutboundBytes(size);, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, + incrementPendingOutboundBytes(size);, + void incrementPendingOutboundBytes(int size) {, + void decrementPendingOutboundBytes(int size) {, + decrementPendingOutboundBytes(size);, + decrementPendingOutboundBytes(size);, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + buffer.incrementPendingOutboundBytes(size);, + buffer.decrementPendingOutboundBytes(size);, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, + incrementPendingOutboundBytes(size);, + void incrementPendingOutboundBytes(int size) {, + void decrementPendingOutboundBytes(int size) {, + decrementPendingOutboundBytes(size);, + decrementPendingOutboundBytes(size);, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + buffer.incrementPendingOutboundBytes(size);, + buffer.decrementPendingOutboundBytes(size);, +++ b/transport/src/test/java/io/netty/channel/ReentrantChannelTest.java, + "WRITABILITY: writable=false\n" +, + "WRITABILITY: writable=true\n" +, + "WRITABILITY: writable=false\n" +, + "FLUSH\n" +, + "WRITABILITY: writable=true\n" +]
[+++ b/common/src/main/java/io/netty/util/AbstractReferenceCounted.java, + if (refCnt == 0 || refCnt == Integer.MAX_VALUE) {, + throw new IllegalReferenceCountException(refCnt, 1);, + final int nextCnt;, + if (refCnt == 0 || (nextCnt = refCnt + increment) < 0) {, + if (refCntUpdater.compareAndSet(this, refCnt, nextCnt)) {]
[+++ b/NOTICE.txt, + * http://netty.io/, +++ b/NOTICE.txt, + * http://netty.io/, +++ b/src/argouml/netty.uml, + http://netty.io/, +++ b/NOTICE.txt, + * http://netty.io/, +++ b/src/argouml/netty.uml, + http://netty.io/, +++ b/src/javadoc/overview.html, +<p style="text-align: justify;"><a href="http://netty.io/" target="_top"><em>The Netty project</em></a> is an effort to provide an asynchronous event-driven network application framework and tools for rapid development of maintainable high performance and high scalability protocol servers and clients&#46; In other words, Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients&#46; It greatly simplifies and streamlines network programming such as TCP/IP socket server&#46;</p>, +++ b/NOTICE.txt, +
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + } catch (CodecException e) {, + throw e;, + } catch (Throwable cause) {, + throw new DecoderException(cause);, + } catch (CodecException e) {, + throw e;, + } catch (Throwable cause) {, + throw new DecoderException(cause);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + } catch (CodecException e) {, + throw e;, + } catch (Throwable cause) {, + throw new DecoderException(cause);, + } catch (CodecException e) {, + throw e;, + } catch (Throwable cause) {, + throw new DecoderException(cause);, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, + } catch (CodecException e) {, + throw e;, + } catch (Throwable cause) {, + throw
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, + // Using the intermediate collection to prevent ConcurrentModificationException., + // In the `close()` method, the channel is deleted from `channels` map.]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + return encodeString0(alloc, false, src, charset, 0);, + /**, + * Encode the given {@link CharBuffer} using the given {@link Charset} into a new {@link ByteBuf} which, + * is allocated via the {@link ByteBufAllocator}., + *, + * @param alloc The {@link ByteBufAllocator} to allocate {@link ByteBuf}., + * @param src The {@link CharBuffer} to encode., + * @param charset The specified {@link Charset}., + * @param extraCapacity the extra capacity to alloc except the space for decoding., + */, + public static ByteBuf encodeString(ByteBufAllocator alloc, CharBuffer src, Charset charset, int extraCapacity) {, + return encodeString0(alloc,
[+++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, + super(null, id, ChannelBufferHolders.discardMessageBuffer());, + public ChannelType type() {, + return ChannelType.MESSAGE;, + }, +, + @Override, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, + super(null, id, ChannelBufferHolders.discardMessageBuffer());, + public ChannelType type() {, + return ChannelType.MESSAGE;, + }, +, + @Override, +++ b/transport/src/main/java/io/netty/channel/Channel.java, + ChannelType type();, +, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, + super(null, id, ChannelBufferHolders.discardMessageBuffer());, + public ChannelType type() {, + return ChannelType.MESSAGE;, + }, +, + @Override, +++ b/transport/src/main/java/io/netty/channel/Channel.java, + ChannelType type();, +, +++ b/transport/src/main/java/io/netty/channel/ChannelBufferHolder.java, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, + super(null, id, ChannelBufferHolders.discardMessageBuffer());, + public ChannelType type() {, + return ChannelType.MESSAGE;, + }, +, + @Override, +++ b/transport/src/main/java/io/netty/channel/Channel.java, + ChannelType type();, +, +++ b/transport/src/main/java/io/netty/channel/ChannelBufferHolder.java, +++
[+++ b/transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java, + private static final byte[] EMPTY_DATA = new byte[0];, +, + private final java.net.DatagramPacket tmpPacket = new java.net.DatagramPacket(EMPTY_DATA, 0);, + tmpPacket.setData(data);, + socket.receive(tmpPacket);, + InetSocketAddress remoteAddr = (InetSocketAddress) tmpPacket.getSocketAddress();, + buf.add(new DatagramPacket(ChannelBuffers.wrappedBuffer(, + data, tmpPacket.getOffset(), tmpPacket.getLength()), remoteAddr));, + tmpPacket.setSocketAddress(p.remoteAddress());, + tmpPacket.setData(data.array(), data.arrayOffset() + data.readerIndex(), length);, + tmpPacket.setData(tmp);, + socket.send(tmpPacket);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + private boolean done;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + private boolean done;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, + private boolean finished;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + private boolean done;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, + private boolean finished;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java, + private int currentStreamId;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + private boolean done;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, + private boolean finished;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java, + private int currentStreamId;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java, + private boolean remoteSideClosed;, + private boolean localSideClosed;, + private int receiveWindowSizeLowerBound;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + private boolean done;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, + private boolean finished;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java, + private int currentStreamId;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java, + private boolean remoteSideClosed;, + private boolean localSideClosed;, + private int
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java, +import java.util.Date;, +, + HttpHeaders.setContentLength(response, 0);, + HttpHeaders.setDate(response, new Date());]
[+++ b/pom.xml, + <version>2.0.8.GA</version>, + <version>1.5.8</version>, + <version>4.6</version>, + <version>1.5.8</version>, + <version>1.0b3</version>, + <version>2.2.0</version>, + <exclusions>, + <exclusion>, + <groupId>org.eclipse.wst.css</groupId>, + <artifactId>core</artifactId>, + </exclusion>, + <exclusion>, + <groupId>org.eclipse.wst.sse</groupId>, + <artifactId>core</artifactId>, + </exclusion>, + </exclusions>, + <exclusions>, + <exclusion>, + <groupId>org.eclipse.wst.css</groupId>, + <artifactId>core</artifactId>, + </exclusion>, + <exclusion>, + <groupId>org.eclipse.wst.sse</groupId>, + <artifactId>core</artifactId>, + </exclusion>, + </exclusions>, + </dependency>, + <dependency>, + <groupId>org.jboss</groupId>, + <artifactId>jbossorg-fonts</artifactId>, + <version>1.0.0</version>, + <type>jdocbook-style</type>, + <localeSeparator>-</localeSeparator>, + <version>2.2-beta-4</version>, + <version>2.7</version>, +++ b/pom.xml, + <version>2.0.8.GA</version>, + <version>1.5.8</version>, + <version>4.6</version>, + <version>1.5.8</version>, + <version>1.0b3</version>, + <version>2.2.0</version>, + <exclusions>, + <exclusion>, + <groupId>org.eclipse.wst.css</groupId>, + <artifactId>core</artifactId>, + </exclusion>, + <exclusion>, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import io.netty.util.internal.StringUtil;, +, + // Verify the subprotocol that we received from the server., + // This must be one of our expected subprotocols - or null/empty if we didn't want to speak a subprotocol, + String receivedProtocol = response.headers().get(HttpHeaders.Names.SEC_WEBSOCKET_PROTOCOL);, + receivedProtocol = receivedProtocol != null ? receivedProtocol.trim() : null;, + String expectedProtocol = expectedSubprotocol != null ? expectedSubprotocol : "";, + boolean protocolValid = false;, +, + if (expectedProtocol.isEmpty() && receivedProtocol == null) {, + // No subprotocol required and none received, + protocolValid = true;, + setActualSubprotocol(expectedSubprotocol); // null or "" - we echo what
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + boolean isAndroid = "Dalvik".equals(vmName);]
[+++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, + public final ByteBuf newInboundBuffer(ChannelHandlerContext ctx) throws Exception {, + cumulation = newInboundBuffer0(ctx);, + protected ByteBuf newInboundBuffer0(ChannelHandlerContext ctx) throws Exception {, + return super.newInboundBuffer(ctx);, + }, +, + public final void discardInboundReadBytes(ChannelHandlerContext ctx) throws Exception {, + discardInboundReadBytes0(ctx);, + protected void discardInboundReadBytes0(ChannelHandlerContext ctx) throws Exception {, + super.discardInboundReadBytes(ctx);, + }, +]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + return StringUtil.decodeHexByte(s, pos);, + return StringUtil.decodeHexDump(hexDump, 0, hexDump.length());, + return StringUtil.decodeHexDump(hexDump, fromIndex, length);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + return StringUtil.decodeHexByte(s, pos);, + return StringUtil.decodeHexDump(hexDump, 0, hexDump.length());, + return StringUtil.decodeHexDump(hexDump, fromIndex, length);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + return StringUtil.decodeHexByte(s, pos);, + return StringUtil.decodeHexDump(hexDump, 0, hexDump.length());, + return StringUtil.decodeHexDump(hexDump, fromIndex, length);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/HpackDecoderTest.java, +import io.netty.util.internal.StringUtil;, + return StringUtil.toHexString(s.getBytes());, + byte[] b = StringUtil.decodeHexDump(encoded);, + assertEquals(MAX_VALUE, decodeULE128(in, 0));, + byte[] compressed = StringUtil.decodeHexDump("FFF0");, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + return StringUtil.decodeHexByte(s, pos);, + return StringUtil.decodeHexDump(hexDump, 0, hexDump.length());, + return StringUtil.decodeHexDump(hexDump, fromIndex, length);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/HpackDecoderTest.java, +import io.netty.util.internal.StringUtil;, + return StringUtil.toHexString(s.getBytes());, +
[+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java, + if (port < 0 && port >= 65536) {]
[+++ b/codec/src/main/java/io/netty/handler/codec/MessageAggregator.java, + * Returns the maximum allowed length of the aggregated message in bytes.]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, +public abstract class ChannelInitializer<C extends Channel> extends ChannelInboundHandlerAdapter<Object> {, + public abstract void initChannel(C ch) throws Exception;, + initChannel((C) ctx.channel());]
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java]
[+++ b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpCommand.java, + public static final SmtpCommand EHLO = new SmtpCommand(AsciiString.cached("EHLO"));, + public static final SmtpCommand HELO = new SmtpCommand(AsciiString.cached("HELO"));, + public static final SmtpCommand MAIL = new SmtpCommand(AsciiString.cached("MAIL"));, + public static final SmtpCommand RCPT = new SmtpCommand(AsciiString.cached("RCPT"));, + public static final SmtpCommand DATA = new SmtpCommand(AsciiString.cached("DATA"));, + public static final SmtpCommand NOOP = new SmtpCommand(AsciiString.cached("NOOP"));, + public static final SmtpCommand RSET = new SmtpCommand(AsciiString.cached("RSET"));, + public static final SmtpCommand EXPN = new SmtpCommand(AsciiString.cached("EXPN"));, + public static final SmtpCommand VRFY = new SmtpCommand(AsciiString.cached("VRFY"));, + public static final SmtpCommand HELP = new SmtpCommand(AsciiString.cached("HELP"));, + public static final SmtpCommand QUIT =
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + ReferenceCountUtil.touch(msg);, + ReferenceCountUtil.touch(msg);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + if (file.length() == 0) {, + return;, + } else {, + if (!file.delete() || !file.createNewFile()) {, + }, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + if (file.length() == 0) {, + return;, + } else {, + if (!file.delete() || !file.createNewFile()) {, + }, + }, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/DiskFileUploadTest.java, +import io.netty.buffer.Unpooled;, +import java.io.IOException;, +, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertTrue;, +, + assertEquals(f2, f2);, + f2.delete();, + }, +, + @Test, + public void testEmptyBufferSetMultipleTimes() throws IOException {, + DiskFileUpload f =, + new DiskFileUpload("d1", "d1", "application/json", null, null, 100);, +, + f.setContent(Unpooled.EMPTY_BUFFER);, +, + assertTrue(f.getFile().exists());, + assertEquals(0,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, + Queue<Object> in = ctx.inbound().messageBuffer();, + ctx.nextInboundMessageBuffer().add(msg);, + Queue<Object> in = ctx.outbound().messageBuffer();, + ctx.nextOutboundMessageBuffer().add(msg);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, + Queue<Object> in = ctx.inbound().messageBuffer();, + ctx.nextInboundMessageBuffer().add(msg);, + Queue<Object> in = ctx.outbound().messageBuffer();, + ctx.nextOutboundMessageBuffer().add(msg);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + ChannelBuffer m = ctx.inbound().byteBuffer().readBytes(ctx.inbound().byteBuffer().readableBytes());, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, + Queue<Object> in = ctx.inbound().messageBuffer();, + ctx.nextInboundMessageBuffer().add(msg);, + Queue<Object> in = ctx.outbound().messageBuffer();, + ctx.nextOutboundMessageBuffer().add(msg);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + ChannelBuffer m = ctx.inbound().byteBuffer().readBytes(ctx.inbound().byteBuffer().readableBytes());, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, + Queue<I> in = ctx.inbound().messageBuffer();, + if (unfoldAndAdd(ctx, ctx.nextInboundMessageBuffer(), emsg)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, + Queue<Object> in = ctx.inbound().messageBuffer();, + ctx.nextInboundMessageBuffer().add(msg);, + Queue<Object> in = ctx.outbound().messageBuffer();, + ctx.nextOutboundMessageBuffer().add(msg);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + ChannelBuffer m = ctx.inbound().byteBuffer().readBytes(ctx.inbound().byteBuffer().readableBytes());, +++
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/NOTICE.txt, +Also, please refer to each LICENSE.<component>.txt file, which is located in, +the 'license' directory of the distribution file, for the license terms of the, +components that this
[+++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, + @Override, + public final void channelRegistered(ChannelHandlerContext ctx), + throws Exception {, + boolean removed = false;, + removed = true;, + if (!removed) {]
[+++ b/pom.xml, + <!-- IoC/DI containers - completely optional -->, + <dependency>, + <groupId>org.jboss.microcontainer</groupId>, + <artifactId>jboss-kernel</artifactId>, + <version>2.0.2.GA</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>org.apache.felix</groupId>, + <artifactId>org.osgi.core</artifactId>, + <version>1.2.0</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>com.google.code.guice</groupId>, + <artifactId>guice</artifactId>, + <version>1.0</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>org.springframework</groupId>, + <artifactId>spring</artifactId>, + <version>2.0.8</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + ]
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, + ChannelHandlerContext fireUserEventTriggered(Object evt);]
[+++ b/pom.xml, + <version>11</version>]
[+++ b/transport/src/main/java/io/netty/channel/ChannelFuture.java, + * Adds the specified listeners to this future. The, + * specified listeners are notified when this future is, + * {@linkplain #isDone() done}. If this future is already, + * completed, the specified listeners are notified immediately., + */, + ChannelFuture addListeners(ChannelFutureListener... listeners);, +, + /**, + * Removes the specified listeners from this future., + * The specified listeners are no longer notified when this, + * future is {@linkplain #isDone() done}. If the specified, + * listeners are not associated with this future, this method, + * does nothing and returns silently., +
[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, + public boolean cancel() {, + return false;, + return true;, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, + public boolean cancel() {, + return false;, + return true;, +++ b/common/src/main/java/io/netty/util/Timeout.java, + * Attempts to cancel the {@link TimerTask} associated with this handle., + * If the task has been executed or cancelled already, it will return with, + * no side effect., + *, + * @return True if the cancellation completed successfully, otherwise false, + boolean cancel();]
[+++ b/microbench/src/main/java/io/netty/microbench/util/AbstractMicrobenchmarkBase.java, + "-server", "-dsa", "-da", "-ea:io.netty...",]
[+++ b/pom.xml, +<?xml version="1.0" encoding="UTF-8"?><project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">, + <version>3.0.0.CR3</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.0.0.CR3</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.0.0.CR3</developerConnection>]
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractClientSocketTest.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + maybeMoreDataToRead = allocHandle.maybeMoreDataToRead();, +, + if (allocHandle.isReceivedRdHup() || (readPending && maybeMoreDataToRead)) {, + } else if (!readPending && !config.isAutoRead()) {, + // Check if there is a readPending which was not processed yet., + // This could be for two reasons:, + // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method, + // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method, + //, + // See https://github.com/netty/netty/issues/2254, + clearEpollIn();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + maybeMoreDataToRead = allocHandle.maybeMoreDataToRead();, +, + if (allocHandle.isReceivedRdHup() || (readPending && maybeMoreDataToRead)) {, + } else if (!readPending && !config.isAutoRead()) {,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + if (frame != null) {, + }]
[+++ b/common/src/main/java/io/netty/util/internal/ObjectCleaner.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, + final AutomaticCleanerReference reference;, + reference = (AutomaticCleanerReference) REFERENCE_QUEUE.remove(REFERENCE_QUEUE_POLL_TIMEOUT_MS);, + continue;, + }, + if (reference != null) {, + try {, + reference.cleanup();, + } catch (Throwable ignored) {, + // ignore exceptions, and don't log in case the logger throws an exception, blocks, or has, + // other unexpected side effects., + }, + LIVE_SET.remove(reference);, +++ b/common/src/main/java/io/netty/util/internal/ObjectCleaner.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, + final AutomaticCleanerReference reference;, + reference = (AutomaticCleanerReference) REFERENCE_QUEUE.remove(REFERENCE_QUEUE_POLL_TIMEOUT_MS);, + continue;, + }, + if (reference != null) {, + try {, + reference.cleanup();, + } catch (Throwable ignored) {,
[+++ b/src/assembly/default.xml, + <directory>target/docbook/publish/en-US</directory>]
[+++ b/all/.gitignore, +src, +++ b/all/.gitignore, +src, +++ b/all/pom.xml, + <id>clean-src</id>, + <phase>clean</phase>, + <goals>, + <goal>clean</goal>, + </goals>, + <configuration>, + <filesets>, + <fileset>, + <directory>${project.basedir}/src</directory>, + <followSymlinks>false</followSymlinks>, + <useDefaultExcludes>false</useDefaultExcludes>, + </fileset>, + <fileset>, + <directory>${project.basedir}/target</directory>, + <followSymlinks>false</followSymlinks>, + </fileset>, + </filesets>, + </configuration>, + </execution>, + <execution>, + <id>clean-all</id>, + <configuration>, + <filesets>, + <fileset>, + <directory>${project.basedir}/src</directory>, + <followSymlinks>false</followSymlinks>, + <useDefaultExcludes>false</useDefaultExcludes>, + </fileset>, + <fileset>, + <directory>${project.basedir}/target</directory>, + <followSymlinks>false</followSymlinks>, + </fileset>, + </filesets>, + </configuration>, + <includeGroupIds>io.netty</includeGroupIds>, + <outputDirectory>${project.basedir}/src/main/java</outputDirectory>, + <overWriteReleases>false</overWriteReleases>, + <overWriteSnapshots>true</overWriteSnapshots>, + <overWriteReleases>false</overWriteReleases>, + <overWriteSnapshots>true</overWriteSnapshots>, + <artifactId>maven-jxr-plugin</artifactId>, + <version>2.2</version>, + <id>generate-xref</id>, + <phase>package</phase>, + <goal>jxr</goal>, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslCachingKeyMaterialProvider.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/transport/src/main/java/io/netty/channel/ChannelInboundInvoker.java, + * This will result in having the {@link ChannelStateHandler#channelRegistered(ChannelHandlerContext)} method, + * called of the next {@link ChannelStateHandler} contained in the {@link ChannelPipeline} of the, + * This will result in having the {@link ChannelStateHandler#channelUnregistered(ChannelHandlerContext)} method, + * called of the next {@link ChannelStateHandler} contained in the {@link ChannelPipeline} of the, + * This will result in having the {@link ChannelStateHandler#channelActive(ChannelHandlerContext)} method, + * called of the next {@link ChannelStateHandler} contained in the {@link ChannelPipeline} of the, + * This will result in having the {@link ChannelStateHandler#channelInactive(ChannelHandlerContext)} method, + * called of the next {@link ChannelStateHandler}
[+++ b/codec-dns/pom.xml, +++ b/codec-dns/pom.xml, +++ b/codec-xml/src/main/java/io/netty/handler/codec/xml/XmlDecoder.java, +import com.fasterxml.aalto.AsyncByteArrayFeeder;, + private final AsyncXMLStreamReader streamReader = XML_INPUT_FACTORY.createAsyncForByteArray();, + private final AsyncByteArrayFeeder streamFeeder = (AsyncByteArrayFeeder) streamReader.getInputFeeder();, +++ b/codec-dns/pom.xml, +++ b/codec-xml/src/main/java/io/netty/handler/codec/xml/XmlDecoder.java, +import com.fasterxml.aalto.AsyncByteArrayFeeder;, + private final AsyncXMLStreamReader streamReader = XML_INPUT_FACTORY.createAsyncForByteArray();, + private final AsyncByteArrayFeeder streamFeeder = (AsyncByteArrayFeeder) streamReader.getInputFeeder();, +++ b/microbench/pom.xml, + <version>1.12</version>, + <version>1.12</version>, +++ b/codec-dns/pom.xml, +++ b/codec-xml/src/main/java/io/netty/handler/codec/xml/XmlDecoder.java, +import com.fasterxml.aalto.AsyncByteArrayFeeder;, + private final AsyncXMLStreamReader streamReader = XML_INPUT_FACTORY.createAsyncForByteArray();, + private final AsyncByteArrayFeeder streamFeeder = (AsyncByteArrayFeeder) streamReader.getInputFeeder();, +++ b/microbench/pom.xml, + <version>1.12</version>, + <version>1.12</version>, +++ b/pom.xml, + <jboss.marshalling.version>1.4.8.Final</jboss.marshalling.version>, + <jetty.alpnAgent.version>2.0.1</jetty.alpnAgent.version>, + <jetty.alpnAgent.path>${settings.localRepository}/org/mortbay/jetty/alpn/jetty-alpn-agent/${jetty.alpnAgent.version}/jetty-alpn-agent-${jetty.alpnAgent.version}.jar</jetty.alpnAgent.path>, + <version>3.20.0-GA</version>, + <version>2.6.1</version>, + <version>3.0.0-alpha-5</version>, + <version>1.54</version>, + <version>1.0.0</version>, + <version>1.7.21</version>, + <version>1.2</version>,
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameRoundtripTest.java, + private CountDownLatch requestLatch;, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameRoundtripTest.java, + private CountDownLatch requestLatch;, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapterTest.java, + private CountDownLatch serverLatch;, + private CountDownLatch clientLatch;, + private CountDownLatch settingsLatch;, + }, + @After, + public void teardown() throws Exception {, + cleanupCapturedRequests();, + cleanupCapturedResponses();, + if (clientChannel != null) {, + clientChannel.close().sync();, + clientChannel = null;, + }, + if (serverChannel != null) {, + serverChannel.close().sync();, + serverChannel = null;, + }, + Future<?> serverGroup = sb.group().shutdownGracefully(0, 0, MILLISECONDS);, + Future<?> serverChildGroup = sb.childGroup().shutdownGracefully(0, 0, MILLISECONDS);, + Future<?> clientGroup = cb.group().shutdownGracefully(0, 0, MILLISECONDS);, + serverGroup.sync();, + serverChildGroup.sync();, + clientGroup.sync();, + clientDelegator =
[+++ b/pom.xml, + <Bundle-Activator>, + ${project.groupId}.container.osgi.BundleActivatorImpl, + </Bundle-Activator>, + <Export-Package>, + !${project.groupId}.example.*,, + !${project.groupId}.logging.*,, + !${project.groupId}.util.*,, + ${project.groupId}.*, + </Export-Package>, + <Private-Package>, + ${project.groupId}.example.*,, + ${project.groupId}.logging.*,, + ${project.groupId}.util.*,, + </Private-Package>, + <Import-Package>, + *;resolution:=optional, + </Import-Package>, + <!--, + org.slf4j.*;resolution:=optional,org.apache.commons.logging.*;resolution:=optional,org.jboss.logging.*;resolution:=optional,org.apache.log4j.*;resolution:=optional,*</Import-Package> , + -->, +++ b/pom.xml, + <Bundle-Activator>, + ${project.groupId}.container.osgi.BundleActivatorImpl, + </Bundle-Activator>, + <Export-Package>, + !${project.groupId}.example.*,, + !${project.groupId}.logging.*,, + !${project.groupId}.util.*,, + ${project.groupId}.*, + </Export-Package>, + <Private-Package>, + ${project.groupId}.example.*,, + ${project.groupId}.logging.*,, + ${project.groupId}.util.*,, + </Private-Package>, + <Import-Package>, + *;resolution:=optional, + </Import-Package>, + <!--, + org.slf4j.*;resolution:=optional,org.apache.commons.logging.*;resolution:=optional,org.jboss.logging.*;resolution:=optional,org.apache.log4j.*;resolution:=optional,*</Import-Package> , + -->, +++ b/src/main/java/org/jboss/netty/container/osgi/BundleActivatorImpl.java, +/*, + * JBoss, Home of Professional Open Source, + *,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + out.add(message);, + decodeContent(c, out);, + // Replace the content length., + int contentLength = 0;, + int size = out.size();, + for (int i = 0; i < size; i++) {, + Object o = out.get(i);, + if (o instanceof HttpContent) {, + contentLength += ((HttpContent) o).content().readableBytes();, + }, + }, + Integer.toString(contentLength));, + decodeContent(c, out);, + private void decodeContent(HttpContent c, List<Object> out) {, +, + decode(content, out);, + finishDecode(out);, + out.add(LastHttpContent.EMPTY_LAST_CONTENT);, + // Clean-up the previous encoder if not cleaned up correctly., + if (decoder.finish()) {, + for (;;) {, + ByteBuf buf = (ByteBuf)
[+++ b/microbench/README.md, +++ b/microbench/README.md, +++ b/microbench/pom.xml, + <groupId>org.openjdk.jmh</groupId>, + <artifactId>jmh-core</artifactId>, + <version>0.2.1</version>, + <plugin>, + <groupId>org.apache.maven.plugins</groupId>, + <artifactId>maven-surefire-plugin</artifactId>, + <configuration>, + <excludes>, + <exclude>**/AbstractMicrobenchmark.java</exclude>, + <exclude>**/*$*.class</exclude>, + </excludes>, + <systemPropertyVariables>, + <perfReportDir>${project.build.directory}/reports/performance/</perfReportDir>, + </systemPropertyVariables>, + </configuration>, + </plugin>, +++ b/microbench/README.md, +++ b/microbench/pom.xml, + <groupId>org.openjdk.jmh</groupId>, + <artifactId>jmh-core</artifactId>, + <version>0.2.1</version>, + <plugin>, + <groupId>org.apache.maven.plugins</groupId>, + <artifactId>maven-surefire-plugin</artifactId>, + <configuration>, + <excludes>, + <exclude>**/AbstractMicrobenchmark.java</exclude>, + <exclude>**/*$*.class</exclude>, + </excludes>, + <systemPropertyVariables>, + <perfReportDir>${project.build.directory}/reports/performance/</perfReportDir>, + </systemPropertyVariables>, + </configuration>, + </plugin>, +++ /dev/null, +++ b/microbench/README.md, +++ b/microbench/pom.xml, + <groupId>org.openjdk.jmh</groupId>, + <artifactId>jmh-core</artifactId>, + <version>0.2.1</version>, + <plugin>, + <groupId>org.apache.maven.plugins</groupId>, + <artifactId>maven-surefire-plugin</artifactId>, + <configuration>, + <excludes>, + <exclude>**/AbstractMicrobenchmark.java</exclude>, +
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + return ctx.isWritable();, + return ctx.isWritable();]
[+++ b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufDecoderNano.java, + MessageNano prototype = clazz.getConstructor().newInstance();, +++ b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufDecoderNano.java, + MessageNano prototype = clazz.getConstructor().newInstance();, +++ b/transport-udt/src/test/java/io/netty/test/udt/util/CaliperRunner.java, + final CaliperBench booter = klaz.getConstructor().newInstance();, +++ b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufDecoderNano.java, + MessageNano prototype = clazz.getConstructor().newInstance();, +++ b/transport-udt/src/test/java/io/netty/test/udt/util/CaliperRunner.java, + final CaliperBench booter = klaz.getConstructor().newInstance();, +++ b/transport/src/main/java/io/netty/channel/ReflectiveChannelFactory.java, + return clazz.getConstructor().newInstance();]
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java, + testName.getMethodName(), Bootstrap.class, Bootstrap.class);, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java, + testName.getMethodName(), Bootstrap.class, Bootstrap.class);, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramMulticastTest.java, +import io.netty.bootstrap.Bootstrap;, + public void testMulticast(Bootstrap sb, Bootstrap cb) throws Throwable {, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java, + testName.getMethodName(), Bootstrap.class, Bootstrap.class);, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramMulticastTest.java, +import io.netty.bootstrap.Bootstrap;, + public void testMulticast(Bootstrap sb, Bootstrap cb) throws Throwable {, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java, +import io.netty.bootstrap.Bootstrap;, + public void testSimpleSend(Bootstrap sb, Bootstrap cb) throws Throwable {, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java, + testName.getMethodName(), Bootstrap.class, Bootstrap.class);, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramMulticastTest.java, +import io.netty.bootstrap.Bootstrap;, + public void testMulticast(Bootstrap sb, Bootstrap cb) throws Throwable {, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java, +import io.netty.bootstrap.Bootstrap;, + public void testSimpleSend(Bootstrap sb, Bootstrap cb) throws Throwable {, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java, +import io.netty.bootstrap.ChannelFactory;, +++
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + @Override, + public ByteBuf discardSomeReadBytes() {, + if (readerIndex == 0) {, + return this;, + }, +, + if (readerIndex == writerIndex) {, + adjustMarkers(readerIndex);, + writerIndex = readerIndex = 0;, + return this;, + }, +, + if (readerIndex >= capacity() >>> 1) {, + setBytes(0, this, readerIndex, writerIndex - readerIndex);, + writerIndex -= readerIndex;, + adjustMarkers(readerIndex);, + readerIndex = 0;, + }, + return this;, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + @Override, + public ByteBuf discardSomeReadBytes() {, + if (readerIndex == 0) {, + return this;, + }, +, + if (readerIndex ==
[+++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ /dev/null, +++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +, + // If the list is empty we need to assign a new one because, + // we get a List that is immutable. , + //, + // See https://github.com/netty/netty/issues/325, + if (list.isEmpty()) {, + list = new ArrayList<ChannelBuffer>(1);, + }, + ,
[+++ b/testsuite-http2/pom.xml, + <version>0.6</version>, + <excludeSpec>5.1 - half closed (remote): Sends a HEADERS frame</excludeSpec>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java, + return isExpectHeaderValid(message), + && message.headers().contains(HttpHeaderNames.EXPECT, HttpHeaderValues.CONTINUE, true);]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + // We don't create the stream in a `halfClosed` state because if this is an initial, + // HEADERS frame we don't want the connection state to signify that the HEADERS have, + // been sent until after they have been encoded and placed in the outbound buffer., + // Therefore, we let the `LifeCycleManager` will take care of transitioning the state, + // as appropriate., + stream = connection.local().createStream(streamId, /*endOfStream*/ false);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + // We don't create the stream in a `halfClosed` state because if this is an initial, + // HEADERS frame we
[+++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java, + if (!request.getDecoderResult().isSuccess()) {, + sendError(ctx, BAD_REQUEST);, + return;, + }, +, + public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {, +++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java, + if (!request.getDecoderResult().isSuccess()) {, + sendError(ctx, BAD_REQUEST);, + return;, + }, +, + public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {, +++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java, +import io.netty.handler.codec.DecoderResult;, +import io.netty.handler.codec.http.HttpObject;, + List<Map.Entry<String, String>> headers = request.getHeaders();, + if (!headers.isEmpty()) {, + }, + appendDecoderResult(buf, request);, + writeResponse(ctx, request);, + appendDecoderResult(buf, chunk);, + writeResponse(ctx, chunk);, + appendDecoderResult(buf, chunk);, + private static void appendDecoderResult(StringBuilder buf, HttpObject o) {, + DecoderResult result = o.getDecoderResult();, + if (result.isSuccess()) {,
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java, + NONE, DUP, SLICE, READ_ONLY, + switch (wrapType) {, + case DUP:, + break;, + case SLICE:, + break;, + case READ_ONLY:, + cc.write(new DatagramPacket(buf.retain().asReadOnly(), addr));, + break;, + case NONE:, + break;, + default:, + throw new Error("unknown wrap type: " + wrapType);, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java, + NONE, DUP, SLICE, READ_ONLY, + switch (wrapType) {, + case DUP:, + break;, + case SLICE:, + break;, + case READ_ONLY:, + cc.write(new DatagramPacket(buf.retain().asReadOnly(), addr));, + break;, + case NONE:, + break;, + default:, + throw new Error("unknown wrap type: " + wrapType);, +++ b/transport-native-unix-common-tests/src/main/java/io/netty/channel/unix/tests/UnixChannelUtilTest.java, + assertTrue(isBufferCopyNeededForWrite(byteBuf.asReadOnly()));, +, + assertTrue(isBufferCopyNeededForWrite(byteBuf.asReadOnly()));,
[+++ b/all/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/codec-http2/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.4.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/pom.xml, + <artifactId>maven-source-plugin</artifactId>, + <version>2.1.1</version>, + <executions>, + <execution>, + <id>attach-source</id>, + <phase>package</phase>, + <goals>, + <goal>jar</goal>, + </goals>, + <configuration>, + <attach>true</attach>, + </configuration>, + </execution>, + </executions>, + </plugin>, + <plugin>, +++ b/pom.xml, + <artifactId>maven-source-plugin</artifactId>, + <version>2.1.1</version>, + <executions>, + <execution>, + <id>attach-source</id>, + <phase>package</phase>, + <goals>, + <goal>jar</goal>, + </goals>, + <configuration>, + <attach>true</attach>, + </configuration>, + </execution>, + </executions>, + </plugin>, + <plugin>, +++ b/src/javadoc/resources/bkg_blkheader.png, +++ b/pom.xml, + <artifactId>maven-source-plugin</artifactId>, + <version>2.1.1</version>, + <executions>, + <execution>, + <id>attach-source</id>, + <phase>package</phase>, + <goals>, + <goal>jar</goal>, + </goals>, + <configuration>, + <attach>true</attach>, + </configuration>, + </execution>, +
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + if (PlatformDependent.isUnaligned()) {, + if (PlatformDependent.isUnaligned()) {, + PlatformDependent.copyMemory(, + PlatformDependent.directBufferAddress(src) + srcOffset,, + PlatformDependent.directBufferAddress(dst) + dstOffset, length);, + } else {, +}, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + if (PlatformDependent.isUnaligned()) {, + if (PlatformDependent.isUnaligned()) {, + PlatformDependent.copyMemory(, + PlatformDependent.directBufferAddress(src) + srcOffset,, + PlatformDependent.directBufferAddress(dst) + dstOffset, length);, + } else {, +}, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, + * Copyright 2013 The Netty Project, + initMemoryAddress();, + initMemoryAddress();, + private void initMemoryAddress() {, + memoryAddress = PlatformDependent.directBufferAddress(memory) + offset;, + return PlatformDependent.getByte(addr(index));, + short v = PlatformDependent.getShort(addr(index));, + return NATIVE_ORDER? v : Short.reverseBytes(v);, + return (PlatformDependent.getByte(addr) & 0xff) << 16 |, +
[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, + public boolean cancel() {, + return false;, + return true;, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, + public boolean cancel() {, + return false;, + return true;, +++ b/common/src/main/java/io/netty/util/Timeout.java, + * Attempts to cancel the {@link TimerTask} associated with this handle., + * If the task has been executed or cancelled already, it will return with, + * no side effect., + *, + * @return True if the cancellation completed successfully, otherwise false, + boolean cancel();]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java, + * SPDY specific headers must be added to pushed {@link HttpRequest}s:, + last = spdySynStreamFrame.isLast() || spdySynStreamFrame.isUnidirectional();, + SpdyHeadersFrame spdyHeadersFrame = createHeadersFrame(httpResponse);, + out.add(spdyHeadersFrame);, + last = spdyHeadersFrame.isLast();, + spdyDataFrame.setLast(true);, + spdyHeadersFrame.setLast(true);, + // Write DATA frame and append HEADERS frame, + out.add(spdyHeadersFrame);, + @SuppressWarnings("deprecation"), + private SpdySynStreamFrame createSynStreamFrame(HttpRequest httpRequest) throws Exception {, + // Get the Stream-ID, Associated-To-Stream-ID, Priority, and scheme from the headers, + final HttpHeaders httpHeaders = httpRequest.headers();, + int streamId = httpHeaders.getInt(Names.STREAM_ID);, + int associatedToStreamId = httpHeaders.getInt(Names.ASSOCIATED_TO_STREAM_ID, 0);, + byte priority = (byte) httpHeaders.getInt(Names.PRIORITY, 0);, + CharSequence scheme = httpHeaders.get(Names.SCHEME);, + new
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecompressor.java, +, + private final boolean strict;, +, + /**, + * Create a new {@link HttpContentDecompressor} in non-strict mode., + */, + public HttpContentDecompressor() {, + this(false);, + }, +, + /**, + * Create a new {@link HttpContentDecompressor}., + *, + * @param strict if {@code true} use strict handling of deflate if used, otherwise handle it in a, + * more lenient fashion., + */, + public HttpContentDecompressor(boolean strict) {, + this.strict = strict;, + }, +, + ZlibWrapper wrapper;, + if (strict) {, + wrapper = ZlibWrapper.ZLIB;, + } else {, + wrapper =
[+++ b/common/src/main/java/io/netty/util/internal/ObjectUtil.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the, + * "License"); you may not use this file except in compliance with the License. You may obtain a, + * copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express, + *
[+++ b/all/pom.xml, + <version>4.1.24.Final</version>, +++ b/all/pom.xml, + <version>4.1.24.Final</version>, +++ b/bom/pom.xml, + <version>4.1.24.Final</version>, + <tag>netty-4.1.24.Final</tag>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, +++ b/all/pom.xml, + <version>4.1.24.Final</version>, +++ b/bom/pom.xml, + <version>4.1.24.Final</version>, + <tag>netty-4.1.24.Final</tag>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, + <version>4.1.24.Final</version>, +
[+++ b/transport/src/main/java/io/netty/channel/ChannelPromiseAggregator.java, + if (aggregatePromise == null) {, + throw new NullPointerException("aggregatePromise");, + }, + /**, + * Add the given {@link ChannelPromise}s to the aggregator., + */, + if (promises.length == 0) {, + return this;, + }, + int size;, + if (promises.length > 1) {, + size = promises.length;, + } else {, + size = 2;, + }, + pendingPromises = new HashSet<ChannelPromise>(size);]
[+++ b/common/src/main/java/io/netty/util/concurrent/PromiseNotifier.java, + } else if (future.isCancelled()) {, + for (Promise<? super V> p: promises) {, + if (!p.cancel(false)) {, + logger.warn("Failed to cancel a promise because it is done already: {}", p);, + }, + } else {, +}, +++ b/common/src/main/java/io/netty/util/concurrent/PromiseNotifier.java, + } else if (future.isCancelled()) {, + for (Promise<? super V> p: promises) {, + if (!p.cancel(false)) {, + logger.warn("Failed to cancel a promise because it is done already: {}", p);, + }, + } else {, +}, +++ b/common/src/main/java/io/netty/util/concurrent/UnaryPromiseNotifier.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpScheme.java, +, + /**, + * Scheme for non-secure HTTP connection., + */, +, + /**, + * Scheme for secure HTTP connection., + */, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpScheme.java, +, + /**, + * Scheme for non-secure HTTP connection., + */, +, + /**, + * Scheme for secure HTTP connection., + */, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import io.netty.util.NetUtil;, +import java.net.InetSocketAddress;, + return WebSocketScheme.WSS.name().contentEquals(wsURL.getScheme()), + ? WebSocketScheme.WSS.port() : WebSocketScheme.WS.port();, + static CharSequence websocketHostValue(URI wsURL) {, + int port = wsURL.getPort();, + if (port == -1) {, + return wsURL.getHost();, + }, + String host = wsURL.getHost();, + if (port == HttpScheme.HTTP.port()) {,
[+++ b/transport-native-epoll/src/main/c/netty_epoll_linuxsocket.c, +static void netty_epoll_linuxsocket_setIpTransparent(JNIEnv* env, jclass clazz, jint fd, jint optval) {, + netty_unix_socket_setOption(env, fd, SOL_IP, IP_TRANSPARENT, &optval, sizeof(optval));, +}, +, +static jint netty_epoll_linuxsocket_isIpTransparent(JNIEnv* env, jclass clazz, jint fd) {, + int optval;, + if (netty_unix_socket_getOption(env, fd, SOL_IP, IP_TRANSPARENT, &optval, sizeof(optval)) == -1) {, + return -1;, + }, + return optval;, +}, +, + { "setIpTransparent", "(II)V", (void *) netty_epoll_linuxsocket_setIpTransparent },, + { "isIpTransparent", "(I)I", (void *) netty_epoll_linuxsocket_isIpTransparent },, +++ b/transport-native-epoll/src/main/c/netty_epoll_linuxsocket.c, +static void netty_epoll_linuxsocket_setIpTransparent(JNIEnv* env, jclass clazz, jint fd, jint optval) {, + netty_unix_socket_setOption(env, fd, SOL_IP, IP_TRANSPARENT, &optval, sizeof(optval));, +}, +, +static jint netty_epoll_linuxsocket_isIpTransparent(JNIEnv* env, jclass clazz,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java, + MessageToMessageCodec<Object, Object, HttpMessage, HttpMessage> {, + super(new Class<?>[] { HttpMessage.class, SpdyRstStreamFrame.class }, new Class<?>[] { HttpMessage.class });, + public HttpMessage encode(ChannelHandlerContext ctx, HttpMessage msg) throws Exception {, + Integer id = ids.poll();, + if (id != null && id != NO_ID && !msg.containsHeader(SpdyHttpHeaders.Names.STREAM_ID)) {, + SpdyHttpHeaders.setStreamId(msg, id);, + }, + return msg;, + }, +, + @Override, + public Object decode(ChannelHandlerContext ctx, Object msg) throws Exception {]
[+++ b/microbench/pom.xml, + <jmh.version>1.21</jmh.version>]
[+++ b/src/docbook/master.xml, +<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.docbook.org/xml/4.5/docbookx.dtd" [, +<!ENTITY home "http://www.jboss.org/netty">, +<!ENTITY doc "http://www.jboss.org/file-access/default/members/netty/freezone">, +<!ENTITY api "&doc;/api/3.0">, +<!ENTITY xref "&doc;/xref/3.0">, +]>, +++ b/src/docbook/master.xml, +<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.docbook.org/xml/4.5/docbookx.dtd" [, +<!ENTITY home "http://www.jboss.org/netty">, +<!ENTITY doc "http://www.jboss.org/file-access/default/members/netty/freezone">, +<!ENTITY api "&doc;/api/3.0">, +<!ENTITY xref "&doc;/xref/3.0">, +]>, +++ b/src/docbook/module/appendix.xml, +<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.docbook.org/xml/4.5/docbookx.dtd" [, +<!ENTITY home "http://www.jboss.org/netty">, +<!ENTITY doc "http://www.jboss.org/file-access/default/members/netty/freezone">, +<!ENTITY api "&doc;/api/3.0">, +<!ENTITY xref "&doc;/xref/3.0">, +]>, +++ b/src/docbook/master.xml, +<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.docbook.org/xml/4.5/docbookx.dtd" [, +<!ENTITY home "http://www.jboss.org/netty">, +<!ENTITY doc "http://www.jboss.org/file-access/default/members/netty/freezone">, +<!ENTITY api "&doc;/api/3.0">, +<!ENTITY xref "&doc;/xref/3.0">, +]>, +++ b/src/docbook/module/appendix.xml, +<!DOCTYPE
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslContext.java, + return newServerContextInternal(provider, trustCertChainFile, trustManagerFactory, keyCertChainFile,, + keyCertChainFile, keyFile, keyPassword, keyManagerFactory, ciphers, cipherFilter,, + apn,]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfigBuilder.java, + * with a 'null' value for the the CORS response header 'Access-Control-Allow-Origin'., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfigBuilder.java, + * with a 'null' value for the the CORS response header 'Access-Control-Allow-Origin'., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java, + private static final String NULL_ORIGIN = "null";, + if (NULL_ORIGIN.equals(origin) && config.isNullOriginAllowed()) {, + setNullOrigin(response);, + private static void setNullOrigin(final HttpResponse response) {, + setOrigin(response, NULL_ORIGIN);, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfigBuilder.java, + * with a 'null' value for the the CORS response header 'Access-Control-Allow-Origin'., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java, + private static final String NULL_ORIGIN = "null";, + if (NULL_ORIGIN.equals(origin) && config.isNullOriginAllowed()) {, + setNullOrigin(response);, + private static void
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + CompositeByteBuf buf = (CompositeByteBuf) wrappedBuffer(new byte[]{1, 2, 3, 4, 5},, + new byte[]{4, 5, 6, 7, 8, 9, 26});, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + CompositeByteBuf buf = (CompositeByteBuf) wrappedBuffer(new byte[]{1, 2, 3, 4, 5},, + new byte[]{4, 5, 6, 7, 8, 9, 26});, +++ b/buffer/src/test/java/io/netty/buffer/ByteBufDerivationTest.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + CompositeByteBuf buf = (CompositeByteBuf) wrappedBuffer(new byte[]{1, 2, 3, 4, 5},, + new byte[]{4, 5, 6, 7, 8, 9, 26});, +++ b/buffer/src/test/java/io/netty/buffer/ByteBufDerivationTest.java, +++ b/buffer/src/test/java/io/netty/buffer/ByteBufStreamTest.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + CompositeByteBuf buf = (CompositeByteBuf) wrappedBuffer(new byte[]{1, 2, 3, 4, 5},, + new byte[]{4, 5,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +import io.netty.util.internal.AppendableCharSequence;, + private final AppendableCharSequence sb = new AppendableCharSequence(128);, + AppendableCharSequence line = readLine(buffer, maxInitialLineLength);, + AppendableCharSequence line = readHeader(buffer);, + AppendableCharSequence line = readHeader(buffer);, + private AppendableCharSequence readHeader(ByteBuf buffer) {, + AppendableCharSequence sb = this.sb;, + sb.reset();, + private AppendableCharSequence readLine(ByteBuf buffer, int maxLineLength) {, + AppendableCharSequence sb = this.sb;, + sb.reset();, + private static String[] splitInitialLine(AppendableCharSequence sb) {, + private static String[] splitHeader(AppendableCharSequence sb) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +import io.netty.util.internal.AppendableCharSequence;, + private final AppendableCharSequence sb = new AppendableCharSequence(128);, + AppendableCharSequence line = readLine(buffer, maxInitialLineLength);, + AppendableCharSequence line = readHeader(buffer);, + AppendableCharSequence line = readHeader(buffer);, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/CaseIgnoringComparator.java, + @SuppressWarnings("MethodMayBeStatic"), +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/CaseIgnoringComparator.java, + @SuppressWarnings("MethodMayBeStatic"), +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshakerFactory.java, + public static void sendUnsupportedWebSocketVersionResponse(Channel channel) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/CaseIgnoringComparator.java, + @SuppressWarnings("MethodMayBeStatic"), +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshakerFactory.java, + public static void sendUnsupportedWebSocketVersionResponse(Channel channel) {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java, +import static io.netty.handler.codec.http.HttpHeaders.Values.*;, +import static io.netty.handler.codec.http.HttpResponseStatus.*;, +import static io.netty.handler.codec.http.HttpVersion.*;, +import static org.junit.Assert.*;, +, + assertEquals(BAD_REQUEST, response.getStatus());, + assertEquals(BAD_REQUEST, response.getStatus());, + private static EmbeddedMessageChannel createChannel() {, + private static EmbeddedMessageChannel createChannel(ChannelHandler handler) {, + private static void writeUpgradeRequest(EmbeddedMessageChannel ch) {, + private static String getResponseMessage(HttpResponse response) {, + private static HttpResponse getHttpResponse(EmbeddedMessageChannel ch) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/CaseIgnoringComparator.java, + @SuppressWarnings("MethodMayBeStatic"), +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshakerFactory.java, + public static void sendUnsupportedWebSocketVersionResponse(Channel channel) {, +++
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +import io.netty.buffer.CompositeByteBuf;, +import io.netty.buffer.SlicedByteBuf;, + flowController().addFlowControlled(ctx, stream,, + flowController().addFlowControlled(ctx, stream,, + private FlowControlledData(ChannelHandlerContext ctx, Http2Stream stream, ByteBuf buf, int padding,, + this.data = buf;, + if (size == bytesWritten && !promise.isVoid()) {, + if (toWrite instanceof SlicedByteBuf && data instanceof CompositeByteBuf) {, + // If we're writing a subset of a composite buffer then we want to release, + // any underlying buffers that have been consumed. CompositeByteBuf only releases, + // underlying buffers on write if all of its data has been consumed and its refCnt becomes, + // 0., + final CompositeByteBuf toFree = (CompositeByteBuf)
[+++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, + private Bootstrap(Bootstrap bootstrap) {, +++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, + private Bootstrap(Bootstrap bootstrap) {, +++ b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java, + private ServerBootstrap(ServerBootstrap bootstrap) {]
[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java, +import io.netty.util.internal.OneTimeTask;, + task.cancelWithoutRemove(false);, + execute(new OneTimeTask() {, + final void removeScheduled(final ScheduledFutureTask<?> task) {, + if (inEventLoop()) {, + scheduledTaskQueue().remove(task);, + } else {, + execute(new OneTimeTask() {, + @Override, + public void run() {, + removeScheduled(task);, + });, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java, +import io.netty.util.internal.OneTimeTask;, + task.cancelWithoutRemove(false);, + execute(new OneTimeTask() {, + final void removeScheduled(final ScheduledFutureTask<?> task) {, + if (inEventLoop()) {, + scheduledTaskQueue().remove(task);, + } else {, + execute(new OneTimeTask() {, + @Override, + public void run() {, + removeScheduled(task);, + });, +++ b/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java, + private static final long SCHEDULE_QUIET_PERIOD_INTERVAL = TimeUnit.SECONDS.toNanos(1);, + final ScheduledFutureTask<Void> quietPeriodTask =
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + IovArray array = ((EpollEventLoop) eventLoop()).cleanIovArray();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + IovArray array = ((EpollEventLoop) eventLoop()).cleanIovArray();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java, + NativeDatagramPacketArray array = ((EpollEventLoop) eventLoop()).cleanDatagramPacketArray();, + in.forEachFlushedMessage(array);, + IovArray array = ((EpollEventLoop) eventLoop()).cleanIovArray();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + IovArray array = ((EpollEventLoop) eventLoop()).cleanIovArray();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java, + NativeDatagramPacketArray array = ((EpollEventLoop) eventLoop()).cleanDatagramPacketArray();, + in.forEachFlushedMessage(array);, + IovArray array = ((EpollEventLoop) eventLoop()).cleanIovArray();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, + private final NativeDatagramPacketArray datagramPacketArray = new NativeDatagramPacketArray();, +, + IovArray cleanIovArray() {, + /**, + * Return a cleared {@link NativeDatagramPacketArray} that can be used for writes in this {@link EventLoop}., + */, + NativeDatagramPacketArray cleanDatagramPacketArray() {, + datagramPacketArray.clear();, +
[+++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, + // Create a new socket and configure it., + s.pipeline().addLast("echoer", new EchoClientHandler(firstMessageSize));, + // Begin the communication by registering the channel to an event loop and connecting, + // to the peer., + EventLoop loop = new MultithreadEventLoop(SelectorEventLoop.FACTORY);, + s.connect(new InetSocketAddress(host, port));, + // Wait until the connection is closed., + s.closeFuture().awaitUninterruptibly();, +, + // Terminate the event loop., + loop.shutdown();, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, + // Create a new socket and configure it., + s.pipeline().addLast("echoer", new EchoClientHandler(firstMessageSize));, + // Begin the communication by registering the channel to an event loop and connecting, + // to the peer.,
[+++ b/example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java, + uri, WebSocketVersion.V13, null, true, new DefaultHttpHeaders()));]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DefaultHttpDataFactory.java, +import java.util.Map;, + private final Map<HttpRequest, List<HttpData>> requestFileDeleteMap = PlatformDependent.newConcurrentHashMap();]
[+++ b/common/src/main/java/io/netty/util/UniqueName.java, +++ b/common/src/main/java/io/netty/util/UniqueName.java, +++ b/pom.xml, + <ignore>java.nio.channels.InterruptedByTimeoutException</ignore>, +++ b/common/src/main/java/io/netty/util/UniqueName.java, +++ b/pom.xml, + <ignore>java.nio.channels.InterruptedByTimeoutException</ignore>, +++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, + public static final ChannelOption<Long> AIO_READ_TIMEOUT =, + new ChannelOption<Long>("AIO_READ_TIMEOUT");, + public static final ChannelOption<Long> AIO_WRITE_TIMEOUT =, + new ChannelOption<Long>("AIO_WRITE_TIMEOUT");, +, +++ b/common/src/main/java/io/netty/util/UniqueName.java, +++ b/pom.xml, + <ignore>java.nio.channels.InterruptedByTimeoutException</ignore>, +++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, + public static final ChannelOption<Long> AIO_READ_TIMEOUT =, + new ChannelOption<Long>("AIO_READ_TIMEOUT");, + public static final ChannelOption<Long> AIO_WRITE_TIMEOUT =, + new ChannelOption<Long>("AIO_WRITE_TIMEOUT");, +, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java, +import java.nio.channels.InterruptedByTimeoutException;, +import java.util.concurrent.TimeUnit;, + javaChannel().write(buffers, 0, buffers.length, config.getReadTimeout(),, + TimeUnit.MILLISECONDS, AioSocketChannel.this, GATHERING_WRITE_HANDLER);, + javaChannel().write(buf.nioBuffer(), config.getReadTimeout(), TimeUnit.MILLISECONDS,, + this, WRITE_HANDLER);, + javaChannel().read(buffers, 0, buffers.length, config.getWriteTimeout(),, + TimeUnit.MILLISECONDS, AioSocketChannel.this, SCATTERING_READ_HANDLER);, + javaChannel().read(buffer,
[+++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, + public static final ChannelOption<Boolean> SINGLE_EVENTEXECUTOR_PER_GROUP =, + valueOf("SINGLE_EVENTEXECUTOR_PER_GROUP");, +, +++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, + public static final ChannelOption<Boolean> SINGLE_EVENTEXECUTOR_PER_GROUP =, + valueOf("SINGLE_EVENTEXECUTOR_PER_GROUP");, +, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java, +import static io.netty.channel.ChannelOption.SINGLE_EVENTEXECUTOR_PER_GROUP;, + private volatile boolean pinEventExecutor = true;, + WRITE_BUFFER_LOW_WATER_MARK, WRITE_BUFFER_WATER_MARK, MESSAGE_SIZE_ESTIMATOR,, + SINGLE_EVENTEXECUTOR_PER_GROUP);, + if (option == SINGLE_EVENTEXECUTOR_PER_GROUP) {, + return (T) Boolean.valueOf(getPinEventExecutorPerGroup());, + }, + } else if (option == SINGLE_EVENTEXECUTOR_PER_GROUP) {, + setPinEventExecutorPerGroup((Boolean) value);, +, + private ChannelConfig setPinEventExecutorPerGroup(boolean pinEventExecutor) {, + this.pinEventExecutor = pinEventExecutor;, + return this;, + }, +, + private boolean getPinEventExecutorPerGroup() {, + return pinEventExecutor;, + }, +, +++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, + public static final
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketFileRegionTest.java, +import io.netty.util.internal.ThreadLocalRandom;, +import static org.hamcrest.CoreMatchers.is;, + ThreadLocalRandom.current().nextBytes(data);, + final File file = File.createTempFile("netty-", ".tmp");, + final FileOutputStream out = new FileOutputStream(file);, + final Random random = ThreadLocalRandom.current();, +, + // Prepend random data which will not be transferred, so that we can test non-zero start offset, + final int startOffset = random.nextInt(8192);, + for (int i = 0; i < startOffset; i ++) {, + out.write(random.nextInt());, + }, +, + // .. and here comes the real data to transfer., +, + // .. and then some extra data which is not supposed to be transferred., +
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java, +import java.io.File;, + * @deprecated Use the constructors that accept {@link ApplicationProtocolConfig} or, + * {@link ApplicationProtocolNegotiator} instead., + *, + * Creates a new instance., + *, + * @param certChainFile an X.509 certificate chain file in PEM format., + * {@code null} to use the system default, + * @param trustManagerFactory the {@link TrustManagerFactory} that provides the {@link TrustManager}s, + * that verifies the certificates sent from servers., + * {@code null} to use the default., + * @param ciphers the cipher suites to enable, in the order of preference., + * {@code null} to
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, + * @param buffer The buffer which provides the content for this {@link InputStream}., +++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, + * @param buffer The buffer which provides the content for this {@link InputStream}., +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, + * technics of, + * <a href="https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919">, + * Scalable memory allocation using jemalloc</a>., +++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, + * @param buffer The buffer which provides the content for this {@link InputStream}., +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, + * technics of, + * <a href="https://www.facebook.com/notes/facebook-engineering/scalable-memory-allocation-using-jemalloc/480222803919">, + * Scalable memory allocation using jemalloc</a>., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, +import io.netty.handler.codec.http.cookie.ClientCookieDecoder;, +, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, + * @param buffer The buffer which provides the content
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, + * {@deprecated Renegotiation is not supported}, + @Deprecated, + if (!rejectRemoteInitiatedRenegotiation) {, + throw new UnsupportedOperationException("Renegotiation is not supported");, + }, + * {@deprecated Renegotiation is not supported}, + * @return {@code true} because renegotiation is not supported., + @Deprecated, + return true;, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, + * {@deprecated Renegotiation is not supported}, + @Deprecated, + if (!rejectRemoteInitiatedRenegotiation) {, + throw new UnsupportedOperationException("Renegotiation is not supported");, + }, + * {@deprecated Renegotiation is not supported}, + * @return {@code true} because renegotiation is not supported., + @Deprecated, + return true;, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, + if (!isDestroyed() && SSL.getHandshakeCount(ssl)
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + @Override, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + @Override, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioChannel.java, + protected abstract class AbstractNioUnsafe extends AbstractUnsafe implements NioUnsafe {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + @Override, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioChannel.java, + protected abstract class AbstractNioUnsafe extends AbstractUnsafe implements NioUnsafe {, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioMessageChannel.java, +package io.netty.channel.socket.nio;, +, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelBufferHolder;, +import io.netty.channel.ChannelBufferHolders;, +import io.netty.channel.ChannelPipeline;, +, +import java.io.IOException;, +import java.nio.channels.SelectableChannel;, +import java.util.Queue;, +, +abstract class AbstractNioMessageChannel extends AbstractNioChannel {, +, + private final ChannelBufferHolder<Object> firstOut = ChannelBufferHolders.messageBuffer();, +, + protected AbstractNioMessageChannel(, + Channel parent, Integer id, SelectableChannel ch, int defaultInterestOps) {, + super(parent, id, ch, defaultInterestOps);, + }, +, + @Override, + protected ChannelBufferHolder<Object> firstOut()
[+++ b/pom.xml, + <log4j2.version>2.6.2</log4j2.version>]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + throw new IllegalArgumentException("promise already done: " + promise);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + // If keep-alive is off and 'Expect: 100-continue' is missing, no need to leave the connection open., + (!HttpHeaders.is100ContinueExpected(oversized) && !HttpHeaders.isKeepAlive(oversized))) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + // If keep-alive is off and 'Expect: 100-continue' is missing, no need to leave the connection open., + (!HttpHeaders.is100ContinueExpected(oversized) && !HttpHeaders.isKeepAlive(oversized))) {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java, + @Test, + public void testRequestAfterOversized100ContinueAndDecoder() {, + EmbeddedChannel embedder = new EmbeddedChannel(new HttpRequestDecoder(), new HttpObjectAggregator(15));, +, + // Write first request with Expect: 100-continue, + HttpRequest message = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.PUT, "http://localhost");, + HttpHeaders.set100ContinueExpected(message);, + HttpHeaders.setContentLength(message, 16);, +, + HttpContent chunk1 = releaseLater(new DefaultHttpContent(Unpooled.copiedBuffer("some", CharsetUtil.US_ASCII)));, +
[+++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + if (src.nioBufferCount() > 0) {, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + if (src.nioBufferCount() > 0) {, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java, + } else if (src.hasArray()) {]
[+++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, + * @throws Exception is thrown if an error occours. In that case the {@link Channel} will be closed., +++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, + * @throws Exception is thrown if an error occours. In that case the {@link Channel} will be closed., +++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java, + * Connect to the remote peer, +++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, + * @throws Exception is thrown if an error occours. In that case the {@link Channel} will be closed., +++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java, + * Connect to the remote peer, +++ b/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java, + * break out of its selection process. In our case we use a timeout for]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/FastLzFrameDecoder.java, + if (!success && uncompressed != null) {]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + throw new IllegalArgumentException("initialCapacity: " + initialCapacity + " (expected: 0+)");, + throw new IllegalArgumentException("minNewCapacity: " + minNewCapacity + " (expected: 0+)");, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + throw new IllegalArgumentException("initialCapacity: " + initialCapacity + " (expected: 0+)");, + throw new IllegalArgumentException("minNewCapacity: " + minNewCapacity + " (expected: 0+)");, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, + * Return {@link ByteBuf#toString()} without checking the reference count first. This is useful to implement, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + throw new IllegalArgumentException("initialCapacity: " + initialCapacity + " (expected: 0+)");, + throw new IllegalArgumentException("minNewCapacity: " + minNewCapacity + " (expected: 0+)");, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, + * Return {@link ByteBuf#toString()} without checking
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, + ByteBuf data = headerBlockEncoder.encode(spdySynStreamFrame);, + ByteBuf data = headerBlockEncoder.encode(spdySynReplyFrame);, + ByteBuf data = headerBlockEncoder.encode(spdyHeadersFrame);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, + ByteBuf data = headerBlockEncoder.encode(spdySynStreamFrame);, + ByteBuf data = headerBlockEncoder.encode(spdySynReplyFrame);, + ByteBuf data = headerBlockEncoder.encode(spdyHeadersFrame);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockEncoder.java, + abstract ByteBuf encode(SpdyHeadersFrame frame) throws Exception;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, + ByteBuf data = headerBlockEncoder.encode(spdySynStreamFrame);, + ByteBuf data = headerBlockEncoder.encode(spdySynReplyFrame);, + ByteBuf data = headerBlockEncoder.encode(spdyHeadersFrame);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockEncoder.java, + abstract ByteBuf encode(SpdyHeadersFrame frame) throws Exception;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockJZlibEncoder.java, + SpdyHeaderBlockJZlibEncoder(, + public ByteBuf encode(SpdyHeadersFrame frame) throws Exception {, + ByteBuf decompressed = super.encode(frame);, + ByteBuf compressed = decompressed.alloc().buffer();, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, + ByteBuf data = headerBlockEncoder.encode(spdySynStreamFrame);, +
[+++ b/pom.xml, + <tcnative.version>1.1.33.Fork17</tcnative.version>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, + private final int contentSizeThreshold;, + this(compressionLevel, 15, 8, 0);, + this(compressionLevel, windowBits, memLevel, 0);, + }, +, + /**, + * Creates a new handler with the specified compression level, window size,, + * and memory level.., + *, + * @param compressionLevel, + * {@code 1} yields the fastest compression and {@code 9} yields the, + * best compression. {@code 0} means no compression. The default, + * compression level is {@code 6}., + * @param windowBits, + * The base two logarithm of the size of the history buffer. The, + * value should
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +import io.netty.channel.ChannelPromise;, +import io.netty.util.collection.IntObjectMap.PrimitiveEntry;, +import io.netty.util.concurrent.Future;, +import io.netty.util.concurrent.FutureListener;, +import io.netty.util.concurrent.Promise;, +, +import static io.netty.handler.codec.http2.Http2CodecUtil.CONNECTION_STREAM_ID;, +import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_PRIORITY_WEIGHT;, +import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_WEIGHT;, +import static io.netty.handler.codec.http2.Http2CodecUtil.MIN_WEIGHT;, +import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;, +import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;, +import static io.netty.handler.codec.http2.Http2Error.REFUSED_STREAM;, +import static io.netty.handler.codec.http2.Http2Exception.closedStreamError;, +import static io.netty.handler.codec.http2.Http2Exception.connectionError;, +import static io.netty.handler.codec.http2.Http2Exception.streamError;, +import static io.netty.handler.codec.http2.Http2Stream.State.CLOSED;, +import static io.netty.handler.codec.http2.Http2Stream.State.HALF_CLOSED_LOCAL;, +import static io.netty.handler.codec.http2.Http2Stream.State.HALF_CLOSED_REMOTE;, +import static io.netty.handler.codec.http2.Http2Stream.State.IDLE;, +import static io.netty.handler.codec.http2.Http2Stream.State.OPEN;, +import static io.netty.handler.codec.http2.Http2Stream.State.RESERVED_LOCAL;, +import static io.netty.handler.codec.http2.Http2Stream.State.RESERVED_REMOTE;, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, + Promise<Void> closePromise;, + /**, + * Determine if {@link #close(Promise)} has been called and no more streams are allowed to be created., + */, + final boolean isClosed() {, + return
[+++ b/.fbfilter.xml, + ~ Copyright 2011 The Netty Project, +++ b/.fbfilter.xml, + ~ Copyright 2011 The Netty Project, +++ b/all/assembly.xml, +++ b/.fbfilter.xml, + ~ Copyright 2011 The Netty Project, +++ b/all/assembly.xml, +++ b/all/pom.xml, + ~ Copyright 2011 The Netty Project, +++ b/.fbfilter.xml, + ~ Copyright 2011 The Netty Project, +++ b/all/assembly.xml, +++ b/all/pom.xml, + ~ Copyright 2011 The Netty Project, +++ b/buffer/pom.xml, + ~ Copyright 2011 The Netty Project, +++ b/.fbfilter.xml, + ~ Copyright 2011 The Netty Project, +++ b/all/assembly.xml, +++ b/all/pom.xml, + ~ Copyright 2011 The Netty Project, +++ b/buffer/pom.xml, + ~ Copyright 2011 The Netty Project, +++
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java, + static final NameValidator<CharSequence> HTTP2_NAME_VALIDATOR = new NameValidator<CharSequence>() {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java, + static final NameValidator<CharSequence> HTTP2_NAME_VALIDATOR = new NameValidator<CharSequence>() {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/ReadOnlyHttp2Headers.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + *
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractUnpooledSlicedByteBuf.java, + return unwrap().getCharSequence(idx(index), length, charset);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractUnpooledSlicedByteBuf.java, + return unwrap().getCharSequence(idx(index), length, charset);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +, + // Clear the buffer so we are sure the reader and writer indices are 0., + // This is important as we may return a slice from newBuffer(...)., + buffer.clear();, + public void testSetUsAsciiCharSequenceAfterRelease() {, + testSetCharSequenceAfterRelease0(CharsetUtil.US_ASCII);, + }, +, + @Test(expected = IllegalReferenceCountException.class), + public void testSetIso88591CharSequenceAfterRelease() {, + testSetCharSequenceAfterRelease0(CharsetUtil.ISO_8859_1);, + }, +, + @Test(expected = IllegalReferenceCountException.class), + public void testSetUtf8CharSequenceAfterRelease() {, + testSetCharSequenceAfterRelease0(CharsetUtil.UTF_8);, + }, +, + @Test(expected = IllegalReferenceCountException.class), + public void testSetUtf16CharSequenceAfterRelease() {, + testSetCharSequenceAfterRelease0(CharsetUtil.UTF_16);, + },
[+++ b/pom.xml, + <version>1.1.33.Fork8</version>]
[+++ b/README.md, +- __3__ branch contains code for Netty 3.x, +++ b/README.md, +- __3__ branch contains code for Netty 3.x, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + public ByteBuffer[] nioBuffers() {, + return nioBuffers(readerIndex, readableBytes());, + }, +, + @Override, +++ b/README.md, +- __3__ branch contains code for Netty 3.x, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + public ByteBuffer[] nioBuffers() {, + return nioBuffers(readerIndex, readableBytes());, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * Returns {@code true} if and only if {@link #nioBuffers()} method will not fail., + */, + boolean hasNioBuffers();, +, + /**, + * Exposes this buffer's readable bytes as an NIO {@link ByteBuffer}'s.
[+++ b/example/src/main/java/io/netty/example/redis/RedisClient.java, +/*, + * Copyright 2011 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java, +import io.netty.util.AsciiString;, +import java.util.Iterator;, +import java.util.Map.Entry;, + Iterator<Entry<CharSequence, CharSequence>> itr = trailers.iteratorCharSequence();, + while (itr.hasNext()) {, + Map.Entry<CharSequence, CharSequence> entry = itr.next();, + spdyHeadersFrame.headers().add(AsciiString.of(entry.getKey()).toLowerCase(), entry.getValue());, + Iterator<Entry<CharSequence, CharSequence>> itr = httpHeaders.iteratorCharSequence();, + while (itr.hasNext()) {, + Map.Entry<CharSequence, CharSequence> entry = itr.next();, + frameHeaders.add(AsciiString.of(entry.getKey()).toLowerCase(), entry.getValue());, + Iterator<Entry<CharSequence, CharSequence>> itr = httpHeaders.iteratorCharSequence();, + while (itr.hasNext()) {, + Map.Entry<CharSequence, CharSequence> entry = itr.next();, + spdyHeadersFrame.headers().add(AsciiString.of(entry.getKey()).toLowerCase(), entry.getValue());]
[+++ b/example/src/main/java/io/netty/example/worldclock/WorldClockProtocol.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/example/src/main/java/io/netty/example/worldclock/WorldClockClient.java, +/*, + * Copyright 2012 The Netty Project, +
[+++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ConnectionlessBootstrap.java, + ch.getConfig().setPipelineFactory(getPipelineFactory());, +++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ConnectionlessBootstrap.java, + ch.getConfig().setPipelineFactory(getPipelineFactory());, +++ b/src/main/java/io/netty/bootstrap/ServerBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ConnectionlessBootstrap.java, + ch.getConfig().setPipelineFactory(getPipelineFactory());, +++ b/src/main/java/io/netty/bootstrap/ServerBootstrap.java, +++ b/src/main/java/io/netty/example/http/websocketx/autobahn/WebSocketServer.java, +++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ConnectionlessBootstrap.java, + ch.getConfig().setPipelineFactory(getPipelineFactory());, +++ b/src/main/java/io/netty/bootstrap/ServerBootstrap.java, +++ b/src/main/java/io/netty/example/http/websocketx/autobahn/WebSocketServer.java, +++ b/src/main/java/io/netty/example/http/websocketx/autobahn/WebSocketServerHandler.java, +++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ConnectionlessBootstrap.java, + ch.getConfig().setPipelineFactory(getPipelineFactory());, +++ b/src/main/java/io/netty/bootstrap/ServerBootstrap.java, +++ b/src/main/java/io/netty/example/http/websocketx/autobahn/WebSocketServer.java, +++ b/src/main/java/io/netty/example/http/websocketx/autobahn/WebSocketServerHandler.java, +++ b/src/main/java/io/netty/example/http/websocketx/autobahn/WebSocketServerPipelineFactory.java, +++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ConnectionlessBootstrap.java, + ch.getConfig().setPipelineFactory(getPipelineFactory());, +++ b/src/main/java/io/netty/bootstrap/ServerBootstrap.java, +++ b/src/main/java/io/netty/example/http/websocketx/autobahn/WebSocketServer.java, +++ b/src/main/java/io/netty/example/http/websocketx/autobahn/WebSocketServerHandler.java, +++ b/src/main/java/io/netty/example/http/websocketx/autobahn/WebSocketServerPipelineFactory.java, +++ b/src/main/java/io/netty/example/http/websocketx/autobahn/package-info.java, + * <p>10. Run <tt>WebSocketServer</tt> in this package, + * , + * <p>11. Run the test <tt>python fuzzing_client.py</tt>. Note that the actual test case python code is , + *
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/LzfDecoder.java, + final int outPos = uncompressed.arrayOffset() + uncompressed.writerIndex();]
[+++ b/transport/src/main/java/io/netty/channel/pool/SimpleChannelPool.java, + * @param releaseHealthCheck will check channel health before offering back if this parameter set to {@code true};, + * otherwise, channel health is only checked at acquisition time, + /**, + * Returns the {@link Bootstrap} this pool will use to open new connections., + *, + * @return the {@link Bootstrap} this pool will use to open new connections, + */, + protected Bootstrap bootstrap() {, + return bootstrap;, + }, +, + /**, + * Returns the {@link ChannelPoolHandler} that will be notified for the different pool actions., + *, + * @return the
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + name, ChannelInboundByteHandler.class.getSimpleName()));, + name, ChannelInboundMessageHandler.class.getSimpleName()));, + name, ChannelOutboundByteHandler.class.getSimpleName()));, + name, ChannelOutboundMessageHandler.class.getSimpleName()));]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/transport-native-epoll/src/main/c/netty_epoll_native.c, +/*, + * Copyright 2013 The Netty Project, +
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * Gets a 32-bit floating point number at the specified absolute, + * {@code index} in this buffer in Little Endian Byte Order., + * This method does not modify {@code readerIndex} or, + * {@code writerIndex} of this buffer., + *, + * @throws IndexOutOfBoundsException, + * if the specified {@code index} is less than {@code 0} or, + * {@code index + 4} is greater than {@code this.capacity}, + */, + public float getFloatLE(int index) {, + return Float.intBitsToFloat(getIntLE(index));, + }, +, + /**, + * Gets a 64-bit floating point number at the
[+++ /dev/null, +++ /dev/null, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, +import io.netty.handler.ssl.ApplicationProtocolNames;, + public static final String TLS_UPGRADE_PROTOCOL_NAME = ApplicationProtocolNames.HTTP_2;, +++ /dev/null, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, +import io.netty.handler.ssl.ApplicationProtocolNames;, + public static final String TLS_UPGRADE_PROTOCOL_NAME = ApplicationProtocolNames.HTTP_2;, +++ /dev/null, +++ /dev/null, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, +import io.netty.handler.ssl.ApplicationProtocolNames;, + public static final String TLS_UPGRADE_PROTOCOL_NAME = ApplicationProtocolNames.HTTP_2;, +++ /dev/null, +++ b/example/src/main/java/io/netty/example/http2/helloworld/client/Http2Client.java, +import io.netty.handler.ssl.ApplicationProtocolNames;, + ApplicationProtocolNames.HTTP_2,, + ApplicationProtocolNames.HTTP_1_1)), +++ /dev/null, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, +import io.netty.handler.ssl.ApplicationProtocolNames;, + public static final String TLS_UPGRADE_PROTOCOL_NAME = ApplicationProtocolNames.HTTP_2;, +++ /dev/null, +++ b/example/src/main/java/io/netty/example/http2/helloworld/client/Http2Client.java, +import io.netty.handler.ssl.ApplicationProtocolNames;, + ApplicationProtocolNames.HTTP_2,, + ApplicationProtocolNames.HTTP_1_1)), +++ b/example/src/main/java/io/netty/example/http2/helloworld/server/Http2OrHttpHandler.java, +import io.netty.handler.ssl.ApplicationProtocolNames;, +import io.netty.handler.ssl.ApplicationProtocolNegotiationHandler;, +public class Http2OrHttpHandler extends ApplicationProtocolNegotiationHandler {, + protected Http2OrHttpHandler() {, + super(ApplicationProtocolNames.HTTP_1_1);, +
[+++ b/example/pom.xml, + , + <!-- Needed for OCSP -->, + <dependency>, + <groupId>org.bouncycastle</groupId>, + <artifactId>bcpkix-jdk15on</artifactId>, + </dependency>, + <dependency>, + <groupId>org.bouncycastle</groupId>, + <artifactId>bcprov-jdk15on</artifactId>, + </dependency>, +++ b/example/pom.xml, + , + <!-- Needed for OCSP -->, + <dependency>, + <groupId>org.bouncycastle</groupId>, + <artifactId>bcpkix-jdk15on</artifactId>, + </dependency>, + <dependency>, + <groupId>org.bouncycastle</groupId>, + <artifactId>bcprov-jdk15on</artifactId>, + </dependency>, +++ b/example/src/main/java/io/netty/example/ocsp/Digester.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version, + * 2.0 (the "License"); you may not use this file except in compliance with the, + * License. You
[+++ b/all/pom.xml, + <version>4.1.19.Final</version>, +++ b/all/pom.xml, + <version>4.1.19.Final</version>, +++ b/bom/pom.xml, + <version>4.1.19.Final</version>, + <tag>netty-4.1.19.Final</tag>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, +++ b/all/pom.xml, + <version>4.1.19.Final</version>, +++ b/bom/pom.xml, + <version>4.1.19.Final</version>, + <tag>netty-4.1.19.Final</tag>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, + <version>4.1.19.Final</version>, +
[+++ b/example/src/main/java/io/netty/example/localecho/LocalEcho.java, + // Start the server., + sb.bind().sync();, +, + // Start the client., +++ b/example/src/main/java/io/netty/example/localecho/LocalEcho.java, + // Start the server., + sb.bind().sync();, +, + // Start the client., +++ b/transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, +import java.util.ArrayList;, +import java.util.HashSet;, +import java.util.Set;, + private static final InternalLogger logger =, + InternalLoggerFactory.getInstance(SingleThreadEventLoop.class);, +, + private final Set<Runnable> shutdownHooks = new HashSet<Runnable>();, + runShutdownHooks();, + // Do nothing. Subclases will override., + public void addShutdownHook(Runnable task) {, + ensureShutdownHookAccess();, + shutdownHooks.add(task);, + }, +, + public void removeShutdownHook(Runnable task) {, + ensureShutdownHookAccess();, + shutdownHooks.remove(task);, + }, +, + private void ensureShutdownHookAccess()
[+++ b/codec/src/test/java/io/netty/handler/codec/compression/ZlibTest.java, +import io.netty.buffer.ByteBufInputStream;, +import io.netty.util.internal.EmptyArrays;, +import java.util.zip.GZIPInputStream;, + public void testGZ() throws Exception {, + private void testDecompressOnly(ZlibWrapper decoderWrapper, byte[] compressed, byte[] data) throws Exception {, + testDecompressOnly(ZlibWrapper.ZLIB, deflate(BYTES_LARGE2), BYTES_LARGE2);, + testDecompressOnly(ZlibWrapper.GZIP, gzip(BYTES_LARGE2), BYTES_LARGE2);, + }, +, + @Test, + public void testGZIPCompressOnly() throws Exception {, + testGZIPCompressOnly0(null); // Do not write anything; just finish the stream., + testGZIPCompressOnly0(EmptyArrays.EMPTY_BYTES); // Write an empty array., + testGZIPCompressOnly0(BYTES_SMALL);, + testGZIPCompressOnly0(BYTES_LARGE);, + }, +, + private void testGZIPCompressOnly0(byte[] data) throws IOException {, + EmbeddedChannel chEncoder = new EmbeddedChannel(createEncoder(ZlibWrapper.GZIP));, + if (data != null) {, + chEncoder.writeOutbound(Unpooled.wrappedBuffer(data));, + }, + assertTrue(chEncoder.finish());, +,
[+++ b/transport-native-kqueue/pom.xml, + <!-- support for __attribute__((weak_import)) by the linker was added in 10.2 so ensure we, + explicitly set the target platform. Otherwise we may get fatal link errors due to weakly linked, + methods which are not expected to be present on MacOS (e.g. accept4). -->, + <arg>MACOSX_DEPLOYMENT_TARGET=10.2</arg>, + <jni.compiler.args.ldflags>LDFLAGS=-z now -L${unix.common.lib.unpacked.dir} -Wl,--whole-archive -l${unix.common.lib.name} -Wl,--no-whole-archive</jni.compiler.args.ldflags>, +++ b/transport-native-kqueue/pom.xml, + <!-- support for __attribute__((weak_import)) by the linker was added in 10.2 so ensure we, + explicitly set the target platform. Otherwise we may get fatal link errors due to weakly linked, + methods which are not expected to be
[+++ b/src/main/java/org/jboss/netty/handler/codec/rtsp/RtspRequestDecoder.java, + * {@link RtspMethods} and protocol version is {@link RtspVersions}., + return new DefaultHttpRequest(RtspVersions.valueOf(initialLine[2]),, +++ b/src/main/java/org/jboss/netty/handler/codec/rtsp/RtspRequestDecoder.java, + * {@link RtspMethods} and protocol version is {@link RtspVersions}., + return new DefaultHttpRequest(RtspVersions.valueOf(initialLine[2]),, +++ b/src/main/java/org/jboss/netty/handler/codec/rtsp/RtspResponseDecoder.java, + * {@link RtspResponseStatuses} and protocol version is {@link RtspVersions}., + RtspVersions.valueOf(initialLine[0]),, +++ b/src/main/java/org/jboss/netty/handler/codec/rtsp/RtspRequestDecoder.java, + * {@link RtspMethods} and protocol version is {@link RtspVersions}., + return new DefaultHttpRequest(RtspVersions.valueOf(initialLine[2]),, +++ b/src/main/java/org/jboss/netty/handler/codec/rtsp/RtspResponseDecoder.java, + * {@link RtspResponseStatuses} and protocol version is {@link RtspVersions}., + RtspVersions.valueOf(initialLine[0]),, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/handler/codec/rtsp/RtspRequestDecoder.java, + * {@link RtspMethods} and protocol version is {@link RtspVersions}., + return new DefaultHttpRequest(RtspVersions.valueOf(initialLine[2]),, +++ b/src/main/java/org/jboss/netty/handler/codec/rtsp/RtspResponseDecoder.java, + * {@link
[+++ b/pom.xml, + <Bundle-Name>${project.name}</Bundle-Name>, + <Bundle-SymbolicName>${project.groupId}.${project.artifactId}.source</Bundle-SymbolicName>, + <Bundle-Vendor>${project.organization.name}</Bundle-Vendor>, + <Eclipse-SourceBundle>${project.groupId}.${project.artifactId};version="${parsedVersion.osgiVersion}";roots:="."</Eclipse-SourceBundle>]
[+++ b/pom.xml, + <version>3.2.0.CR1-SNAPSHOT</version>, + <url>http://fisheye.jboss.org/browse/Netty</url>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (checkAccessible && !isAccessible()) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (checkAccessible && !isAccessible()) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + final boolean isAccessible() {, + return unwrap().isAccessible();, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (checkAccessible && !isAccessible()) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + final boolean isAccessible() {, + return unwrap().isAccessible();, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + boolean isAccessible() {, +, + // This is copied explicitly from the nonVolatileRawCnt() method above to reduce call stack depth,, + // to avoid hitting the default limit for inlining (9), + final int rawCnt = REFCNT_FIELD_OFFSET != -1 ? PlatformDependent.getInt(this, REFCNT_FIELD_OFFSET),
[+++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E> {, +, + public ObjectArray(E[] array, int offset, int length) {, + super(array, offset, length);, + }, +, + @Override, + public E[] array() {, + return (E[]) super.array();, + }, +}, +++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E> {, +, + public ObjectArray(E[] array, int offset, int length) {, + super(array, offset, length);, + }, +, + @Override, + public E[] array() {, + return (E[]) super.array();, + }, +}, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return writerIndex > readerIndex;, +, + if (readerIndex == writerIndex)
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + if (!promise.setUncancellable()) {, + return;, + }, + if (!promise.setUncancellable()) {, + return;, + }, + if (!promise.setUncancellable()) {, + return;, + }, + if (!promise.setUncancellable()) {, + return;, + }, + if (!promise.setUncancellable()) {, + return;, + }, + if (!promise.setUncancellable()) {, + return;, + }, + if (!isActive()) {, + ReferenceCountUtil.release(msg);, + promise.setFailure(CLOSED_CHANNEL_EXCEPTION);, + return;, + }, +]
[+++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannel.java, +import io.netty.channel.socket.oio.StreamOioByteChannel;, +public class RxtxChannel extends StreamOioByteChannel {, + activate(serialPort.getInputStream(), serialPort.getOutputStream());, + super.doClose();, + } finally {, + }, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannel.java, +import io.netty.channel.socket.oio.StreamOioByteChannel;, +public class RxtxChannel extends StreamOioByteChannel {, + activate(serialPort.getInputStream(), serialPort.getOutputStream());, + super.doClose();, + } finally {, + }, +++ b/transport/src/main/java/io/netty/channel/socket/oio/AbstractOioByteChannel.java, +import io.netty.buffer.BufType;, +import io.netty.channel.ChannelMetadata;, + private static final ChannelMetadata METADATA = new ChannelMetadata(BufType.BYTE, false);, + public ChannelMetadata metadata() {, + return METADATA;, + }, +, + @Override, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannel.java, +import io.netty.channel.socket.oio.StreamOioByteChannel;, +public class RxtxChannel extends StreamOioByteChannel {, + activate(serialPort.getInputStream(), serialPort.getOutputStream());, + super.doClose();, + } finally {, + }, +++ b/transport/src/main/java/io/netty/channel/socket/oio/AbstractOioByteChannel.java, +import io.netty.buffer.BufType;, +import io.netty.channel.ChannelMetadata;, +
[+++ b/src/main/java/org/jboss/netty/bootstrap/ClientBootstrap.java, + * TODO: Show how to shut down a service., +++ b/src/main/java/org/jboss/netty/bootstrap/ClientBootstrap.java, + * TODO: Show how to shut down a service., +++ b/src/main/java/org/jboss/netty/bootstrap/ServerBootstrap.java, + * TODO: Show how to shut down a service., +++ b/src/main/java/org/jboss/netty/bootstrap/ClientBootstrap.java, + * TODO: Show how to shut down a service., +++ b/src/main/java/org/jboss/netty/bootstrap/ServerBootstrap.java, + * TODO: Show how to shut down a service., +++ b/src/main/java/org/jboss/netty/channel/ChannelFactory.java, +import java.util.concurrent.Executor;, +, + * <h3>Graceful shutdown</h3>, + * <p>, + * To shut down a network application service which is managed by a factory., + * you should follow the following steps:, + * <ol>, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.ByteBufUtil;, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelFutureListener;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelOutboundHandler;, +import io.netty.channel.ChannelPromise;, +import io.netty.handler.codec.ByteToMessageDecoder;, +import io.netty.handler.codec.http2.Http2Exception.CompositeStreamException;, +import io.netty.handler.codec.http2.Http2Exception.StreamException;, +import io.netty.util.concurrent.ScheduledFuture;, +import io.netty.util.internal.OneTimeTask;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +import java.net.SocketAddress;, +import java.util.List;, +import java.util.concurrent.TimeUnit;, +, +import static java.util.concurrent.TimeUnit.MILLISECONDS;, +import static java.util.concurrent.TimeUnit.SECONDS;, + private static final long DEFAULT_GRACEFUL_SHUTDOWN_TIMEOUT_MILLIS = MILLISECONDS.convert(30, SECONDS);, +, + private long gracefulShutdownTimeoutMillis = DEFAULT_GRACEFUL_SHUTDOWN_TIMEOUT_MILLIS;, + /**, + * Get the amount of time (in milliseconds) this endpoint will wait for all streams to be closed before closing, + * the connection during the graceful shutdown process., + */, + public long gracefulShutdownTimeoutMillis() {,
[+++ b/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<!--, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2008, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version.,
[+++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, +import io.netty.util.ThreadDeathWatcher;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(PoolThreadCache.class);, +, + private final Thread thread = Thread.currentThread();, + private final Runnable freeTask = new Runnable() {, + @Override, + public void run() {, + free0();, + }, + };, +, +, + // The thread-local cache will keep a list of pooled buffers which must be returned to, + // the pool when the thread is not alive anymore., + ThreadDeathWatcher.watch(thread, freeTask);, + void free() {, + ThreadDeathWatcher.unwatch(thread, freeTask);, + free0();, + }, +, + private void free0() {, +
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufHolder.java, + /**, + * Duplicate the {@link ByteBufHolder}. Be aware that this will not automatically call {@link #retain()}., + */, + ByteBufHolder duplicate();, +, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufHolder.java, + /**, + * Duplicate the {@link ByteBufHolder}. Be aware that this will not automatically call {@link #retain()}., + */, + ByteBufHolder duplicate();, +, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, + public ByteBufHolder duplicate() {, + return new DefaultByteBufHolder(data.duplicate());, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufHolder.java, + /**, + * Duplicate the {@link ByteBufHolder}. Be aware that this will not automatically call {@link #retain()}., + */, + ByteBufHolder duplicate();, +, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, + public ByteBufHolder
[+++ b/codec/src/main/java/io/netty/handler/codec/xml/XmlFrameDecoder.java, + if (atLeastOneXmlElementFound && openBracketsCount == 0) {, + if (length >= in.writerIndex()) {, + length = in.readableBytes();, + }, +++ b/codec/src/main/java/io/netty/handler/codec/xml/XmlFrameDecoder.java, + if (atLeastOneXmlElementFound && openBracketsCount == 0) {, + if (length >= in.writerIndex()) {, + length = in.readableBytes();, + }, +++ b/codec/src/main/java/io/netty/handler/codec/xml/package-info.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, + int size = calculateRemainingSize();, + ByteBuf buffer = fillByteBuf();, + HttpContent chunk;, + chunk = encodeNextChunkMultipart(size);, + chunk = encodeNextChunkUrlEncoded(size);, + }, + // NextChunk from data, + size = calculateRemainingSize();, + return lastChunk();, + size = calculateRemainingSize();, + return lastChunk();, + }, +, + private int calculateRemainingSize() {, + int size = HttpPostBodyUtil.chunkSize;, + if (currentBuffer != null) {, + size -= currentBuffer.readableBytes();, + }, + return size;, + }, +, + private HttpContent lastChunk() {, + // NextChunk as last non empty from buffer, + ByteBuf buffer = currentBuffer;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, + int size
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslContext.java]
[+++ b/codec/src/main/java/io/netty/handler/codec/marshalling/CompatibleMarshallingDecoder.java, + throw new TooLongFrameException();]
[+++ b/transport/src/main/java/io/netty/channel/CombinedChannelDuplexHandler.java, + return ctx.deregister(promise);, +++ b/transport/src/main/java/io/netty/channel/CombinedChannelDuplexHandler.java, + return ctx.deregister(promise);, +++ b/transport/src/test/java/io/netty/channel/CombinedChannelDuplexHandlerTest.java, +, + @Test(timeout = 3000), + public void testPromisesPassed() {, + ChannelOutboundHandler outboundHandler = new ChannelOutboundHandlerAdapter() {, + @Override, + public void bind(ChannelHandlerContext ctx, SocketAddress localAddress,, + ChannelPromise promise) throws Exception {, + promise.setSuccess();, + }, +, + @Override, + public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,, + SocketAddress localAddress, ChannelPromise promise) throws Exception {, + promise.setSuccess();, + }, +, + @Override, + public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {, + promise.setSuccess();, + }, +, + @Override, + public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception
[+++ b/transport/src/main/java/io/netty/channel/pool/FixedChannelPool.java, + this(bootstrap, handler, healthCheck, action, acquireTimeoutMillis, maxConnections, maxPendingAcquires, true);, + }, +, + /**, + * Creates a new instance., + *, + * @param bootstrap the{@link Bootstrap} that is used for connections, + * @param handler the {@link ChannelPoolHandler} that will be notified for the different pool actions, + * @param healthCheck the {@link ChannelHealthChecker} that will be used to check if a {@link Channel} is, + * still healty when obtain from the {@link ChannelPool}, + * @param action the {@link AcquireTimeoutAction} to use or {@code null} if non should be used., + * In
[+++ b/transport/src/main/java/io/netty/channel/VoidChannelPromise.java]
[+++ b/common/src/test/java/io/netty/util/ThreadDeathWatcherTest.java]
[+++ b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufDecoder.java, +import com.google.protobuf.ExtensionRegistryLite;, + private final ExtensionRegistryLite extensionRegistry;, + this(prototype, (ExtensionRegistryLite) extensionRegistry);, + }, +, + public ProtobufDecoder(MessageLite prototype, ExtensionRegistryLite extensionRegistry) {]
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DataCompressionHttp2Test.java, + private volatile Channel serverConnectedChannel;, + final Channel serverConnectedChannel = this.serverConnectedChannel;, + if (serverConnectedChannel != null) {, + serverConnectedChannel.close().sync();, + this.serverConnectedChannel = null;, + }, + serverConnectedChannel = ch;, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DataCompressionHttp2Test.java, + private volatile Channel serverConnectedChannel;, + final Channel serverConnectedChannel = this.serverConnectedChannel;, + if (serverConnectedChannel != null) {, + serverConnectedChannel.close().sync();, + this.serverConnectedChannel = null;, + }, + serverConnectedChannel = ch;, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2CodecTest.java, + if (clientChannel != null) {, + clientChannel = null;, + }, + if (serverChannel != null) {, + serverChannel = null;, + }, + final Channel serverConnectedChannel = this.serverConnectedChannel;, + this.serverConnectedChannel = null;, +++
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + executor.execute(new Runnable() {, + });, + executor.execute(new Runnable() {, + });, + executor.execute(new Runnable() {, + });, + executor.execute(new Runnable() {, + });, + executor.execute(new Runnable() {, + });, + executor.execute(new Runnable() {, + });, + executor.execute(new Runnable() {, + });]
[+++ b/pom.xml, + </properties>, + </profile>, + <profile>, + <id>alpn-8</id>, + <activation>, + <property>, + <name>java.version</name>, + <value>1.8</value>, + </property>, + </activation>, + <properties>, + </properties>, + </profile>, + <profile>, + <id>alpn-8u05</id>, + <activation>, + <property>, + <name>java.version</name>, + <value>1.8.0_05</value>, + </property>, + </activation>, + <properties>, + <jetty.alpn.version>8.1.0.v20141016</jetty.alpn.version>, + </properties>, + </profile>, + <profile>, + <id>alpn-8u11</id>, + <activation>, + <property>, + <name>java.version</name>, + <value>1.8.0_11</value>, + </property>, + </activation>, + <properties>, + <jetty.alpn.version>8.1.0.v20141016</jetty.alpn.version>, + </properties>, + </profile>, + <profile>, + <id>alpn-8u20</id>, + <activation>, + <property>, + <name>java.version</name>, + <value>1.8.0_20</value>, + </property>, + </activation>, + <properties>, + <jetty.alpn.version>8.1.0.v20141016</jetty.alpn.version>, + <jetty.alpn.version>8.1.2.v20141202</jetty.alpn.version>, +
[+++ b/codec/src/main/java/io/netty/handler/codec/marshalling/ChannelBufferByteOutput.java, +import org.jboss.marshalling.ByteOutput;, +++ b/codec/src/main/java/io/netty/handler/codec/marshalling/ChannelBufferByteOutput.java, +import org.jboss.marshalling.ByteOutput;, +++ b/codec/src/main/java/io/netty/handler/codec/marshalling/LimitingByteInput.java, +import java.io.IOException;, +, +++ b/codec/src/main/java/io/netty/handler/codec/marshalling/ChannelBufferByteOutput.java, +import org.jboss.marshalling.ByteOutput;, +++ b/codec/src/main/java/io/netty/handler/codec/marshalling/LimitingByteInput.java, +import java.io.IOException;, +, +++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java, +import static io.netty.handler.codec.http.HttpHeaders.Names.*;, +import static io.netty.handler.codec.http.HttpHeaders.*;, +import static io.netty.handler.codec.http.HttpResponseStatus.*;, +import static io.netty.handler.codec.http.HttpVersion.*;, +, +++ b/codec/src/main/java/io/netty/handler/codec/marshalling/ChannelBufferByteOutput.java, +import org.jboss.marshalling.ByteOutput;, +++ b/codec/src/main/java/io/netty/handler/codec/marshalling/LimitingByteInput.java, +import java.io.IOException;, +, +++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java, +import static io.netty.handler.codec.http.HttpHeaders.Names.*;, +import static io.netty.handler.codec.http.HttpHeaders.*;, +import static io.netty.handler.codec.http.HttpResponseStatus.*;, +import static io.netty.handler.codec.http.HttpVersion.*;, +, +++ b/example/src/main/java/io/netty/example/localecho/LocalEchoClientHandler.java, +++ b/codec/src/main/java/io/netty/handler/codec/marshalling/ChannelBufferByteOutput.java, +import org.jboss.marshalling.ByteOutput;, +++ b/codec/src/main/java/io/netty/handler/codec/marshalling/LimitingByteInput.java, +import java.io.IOException;, +, +++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java, +import static io.netty.handler.codec.http.HttpHeaders.Names.*;, +import static io.netty.handler.codec.http.HttpHeaders.*;, +import static io.netty.handler.codec.http.HttpResponseStatus.*;, +import static io.netty.handler.codec.http.HttpVersion.*;, +, +++ b/example/src/main/java/io/netty/example/localecho/LocalEchoClientHandler.java, +++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, + public void read(ChannelHandlerContext ctx) {, + ctx.read();,
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00Test.java]
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + return EXPLICIT_NO_UNSAFE_CAUSE != null;]
[+++ b/pom.xml, + <repositories>, + <repository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </repository>, + </repositories>, +, + <pluginRepositories>, + <pluginRepository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </pluginRepository>, + </pluginRepositories>, +, +++ b/pom.xml, + <repositories>, + <repository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </repository>, + </repositories>, +, + <pluginRepositories>, + <pluginRepository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </pluginRepository>, + </pluginRepositories>, +, +++ b/src/docbook/en-US/module/start.xml, + time.writeInt(System.currentTimeMillis() / 1000);, +++ b/pom.xml, + <repositories>, + <repository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </repository>, + </repositories>, +, + <pluginRepositories>, + <pluginRepository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </pluginRepository>, + </pluginRepositories>, +, +++ b/src/docbook/en-US/module/start.xml, + time.writeInt(System.currentTimeMillis() / 1000);, +++ b/src/main/java/org/jboss/netty/buffer/ChannelBuffers.java, +
[+++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, + ctx.fireChannelRegistered();]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractMessageBuf.java, + refCntFieldOffset = PlatformDependent.objectFieldOffset(, + AbstractMessageBuf.class.getDeclaredField("refCnt"));, + } catch (Throwable t) {, + // Ignored, + }, +++ b/buffer/src/main/java/io/netty/buffer/AbstractMessageBuf.java, + refCntFieldOffset = PlatformDependent.objectFieldOffset(, + AbstractMessageBuf.class.getDeclaredField("refCnt"));, + } catch (Throwable t) {, + // Ignored, + }, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCounted.java, + refCntFieldOffset = PlatformDependent.objectFieldOffset(, + AbstractReferenceCounted.class.getDeclaredField("refCnt"));, + } catch (Throwable t) {, + // Ignored, + }, +++ b/buffer/src/main/java/io/netty/buffer/AbstractMessageBuf.java, + refCntFieldOffset = PlatformDependent.objectFieldOffset(, + AbstractMessageBuf.class.getDeclaredField("refCnt"));, + } catch (Throwable t) {, + // Ignored, + }, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCounted.java, + refCntFieldOffset = PlatformDependent.objectFieldOffset(, + AbstractReferenceCounted.class.getDeclaredField("refCnt"));, + } catch (Throwable t) {, + // Ignored, + }, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + refCntFieldOffset
[+++ b/pom.xml, + <version>1.6.1</version>, + <version>2.1.2.GA</version>, + <version>4.8.2</version>, + <version>1.6.1</version>, + <version>2.3.2</version>, + <version>2.4.3</version>, + <version>2.7.2</version>, + <version>2.3.4</version>, + <version>2.1.2</version>, + <version>1.6</version>, + <version>1.8.2</version>, + <version>1.8.2</version>, + <version>2.7</version>, + <version>2.2</version>, + <version>2.2</version>, + <version>2.1</version>]
[+++ b/pom.xml, + <!-- Disabled temporarily until all violations are fixed., + <failOnViolation>true</failOnViolation>, + -->, + <failsOnError>false</failsOnError>, + <failOnViolation>false</failOnViolation>]
[+++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, + int maxCachedBufferCapacity, int freeSweepAllocationThreshold,, + boolean useThreadDeathWatcher) {, + // Only check if there are caches in use., + if ((tinySubPageDirectCaches != null || smallSubPageDirectCaches != null || normalDirectCaches != null, + || tinySubPageHeapCaches != null || smallSubPageHeapCaches != null || normalHeapCaches != null), + && freeSweepAllocationThreshold < 1) {, +, + if (useThreadDeathWatcher) {, +, +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, + int maxCachedBufferCapacity, int freeSweepAllocationThreshold,, + boolean useThreadDeathWatcher) {, + // Only check if there are caches in use., + if ((tinySubPageDirectCaches != null || smallSubPageDirectCaches != null || normalDirectCaches != null, + || tinySubPageHeapCaches != null ||
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, + // also check for code of 101 as 101 == Response to a websockets upgrade in earlier websocket versions., + //, + // See https://github.com/netty/netty/issues/222, + if (code < 200 && code != 101) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, + // also check for code of 101 as 101 == Response to a websockets upgrade in earlier websocket versions., + //, + // See https://github.com/netty/netty/issues/222, + if (code < 200 && code != 101) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + return frame;]
[+++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, + * we store 2 pieces of information depth_of_id and x as two byte values in memoryMap and depthMap respectively, + * memoryMap[id]= depth_of_id is defined above, + * depthMap[id]= x indicates that the first node which is free to be allocated is at depth x (from root)]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufOutputStream.java, +import io.netty.util.CharsetUtil;, +, + buffer.writeByte(b);, + buffer.writeBoolean(v);, + buffer.writeByte(v);, + buffer.writeCharSequence(s, CharsetUtil.US_ASCII);, + buffer.writeChar(v);, + buffer.writeChar(s.charAt(i));, + buffer.writeDouble(v);, + buffer.writeFloat(v);]
[+++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketChannelConfigTest.java, +import static org.junit.Assume.*;, + final long expected = randLong(0, 0xFFFFFFFFL);, + final long actual;, + try {, + ch.config().setTcpNotSentLowAt(expected);, + actual = ch.config().getTcpNotSentLowAt();, + } catch (RuntimeException e) {, + assumeNoException(e);, + return; // Needed to prevent compile error for final variables to be used below, + }, + assertEquals(expected, actual);, + @Test, + try {, + } catch (IllegalArgumentException e) {, + return;, + } catch (RuntimeException e) {, + assumeNoException(e);, + }, + @Test, + try {, + } catch (IllegalArgumentException e) {, + return;, + } catch (RuntimeException e) {, + assumeNoException(e);, + }]
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/AbstractSingleThreadEventLoopTest.java, +/*, + * Copyright 2019 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/pom.xml, + <version>3.0.0.GA</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.0.0.GA</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.0.0.GA</developerConnection>]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + /**, + * Should be called by every method that tries to access the buffers content to check, + * if the buffer was released before., + */, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + /**, + * Should be called by every method that tries to access the buffers content to check, + * if the buffer was released before., + */, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCounted.java, +/**, + * Abstract base class for classes wants to implement {@link ReferenceCounted}., + */, + /**, + * Called once {@link #refCnt()} is equals 0., + */, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + /**, + * Should
[+++ b/all/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/example/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec/pom.xml, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CombinedHttpHeaders.java, +import static io.netty.util.internal.StringUtil.unescapeCsvFields;, + public Iterator<CharSequence> valueIterator(CharSequence name) {, + Iterator<CharSequence> itr = super.valueIterator(name);, + if (!itr.hasNext()) {, + return itr;, + }, + Iterator<CharSequence> unescapedItr = unescapeCsvFields(itr.next()).iterator();, + if (itr.hasNext()) {, + throw new IllegalStateException("CombinedHttpHeaders should only have one value");, + }, + return unescapedItr;, + }, +, + @Override, + return unescapeCsvFields(values.get(0));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CombinedHttpHeaders.java, +import static io.netty.util.internal.StringUtil.unescapeCsvFields;, + public Iterator<CharSequence> valueIterator(CharSequence name) {, + Iterator<CharSequence> itr = super.valueIterator(name);, + if (!itr.hasNext()) {, + return itr;, + }, + Iterator<CharSequence> unescapedItr = unescapeCsvFields(itr.next()).iterator();, + if (itr.hasNext()) {, + throw new IllegalStateException("CombinedHttpHeaders should only have one value");,
[+++ b/all/pom.xml, + <version>4.1.24.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.24.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.24.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.24.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.24.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, + <version>4.1.24.Final-SNAPSHOT</version>, +
[+++ /dev/null, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, + // also check for code of 101 as 101 == Response to a websockets upgrade in earlier websocket versions., + //, + if (code < 200 && code != 101) {, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, + // also check for code of 101 as 101 == Response to a websockets upgrade in earlier websocket versions., + //, + if (code < 200 && code != 101) {, +++ b/codec/src/main/java/io/netty/handler/codec/redis/BulkReply.java, +/*, + * Copyright 2011 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageEncoder.java, + buf.writeBytes(header.getBytes(CharsetUtil.US_ASCII));, + buf.writeBytes(value.getBytes(CharsetUtil.US_ASCII));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageEncoder.java, + buf.writeBytes(header.getBytes(CharsetUtil.US_ASCII));, + buf.writeBytes(value.getBytes(CharsetUtil.US_ASCII));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java, +import io.netty.util.CharsetUtil;, + buf.writeBytes(response.getProtocolVersion().toString().getBytes(CharsetUtil.US_ASCII));, + buf.writeBytes(String.valueOf(response.getStatus().getCode()).getBytes(CharsetUtil.US_ASCII));, + buf.writeBytes(String.valueOf(response.getStatus().getReasonPhrase()).getBytes(CharsetUtil.US_ASCII));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageEncoder.java, + buf.writeBytes(header.getBytes(CharsetUtil.US_ASCII));, + buf.writeBytes(value.getBytes(CharsetUtil.US_ASCII));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java, +import io.netty.util.CharsetUtil;, + buf.writeBytes(response.getProtocolVersion().toString().getBytes(CharsetUtil.US_ASCII));, + buf.writeBytes(String.valueOf(response.getStatus().getCode()).getBytes(CharsetUtil.US_ASCII));, + buf.writeBytes(String.valueOf(response.getStatus().getReasonPhrase()).getBytes(CharsetUtil.US_ASCII));, +++ b/codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspRequestEncoder.java, +import io.netty.util.CharsetUtil;, + buf.writeBytes(request.getMethod().toString().getBytes(CharsetUtil.US_ASCII));, + buf.writeBytes(request.getUri().getBytes(CharsetUtil.UTF_8));, + buf.writeBytes(request.getProtocolVersion().toString().getBytes(CharsetUtil.US_ASCII));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageEncoder.java, + buf.writeBytes(header.getBytes(CharsetUtil.US_ASCII));, + buf.writeBytes(value.getBytes(CharsetUtil.US_ASCII));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java, +import io.netty.util.CharsetUtil;, + buf.writeBytes(response.getProtocolVersion().toString().getBytes(CharsetUtil.US_ASCII));, + buf.writeBytes(String.valueOf(response.getStatus().getCode()).getBytes(CharsetUtil.US_ASCII));, + buf.writeBytes(String.valueOf(response.getStatus().getReasonPhrase()).getBytes(CharsetUtil.US_ASCII));, +++ b/codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspRequestEncoder.java, +import io.netty.util.CharsetUtil;, + buf.writeBytes(request.getMethod().toString().getBytes(CharsetUtil.US_ASCII));, + buf.writeBytes(request.getUri().getBytes(CharsetUtil.UTF_8));, + buf.writeBytes(request.getProtocolVersion().toString().getBytes(CharsetUtil.US_ASCII));, +++ b/codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspResponseEncoder.java, +import io.netty.util.CharsetUtil;, + buf.writeBytes(response.getProtocolVersion().toString().getBytes(CharsetUtil.US_ASCII));, + buf.writeBytes(String.valueOf(response.getStatus().getCode()).getBytes(CharsetUtil.US_ASCII));, + buf.writeBytes(String.valueOf(response.getStatus().getReasonPhrase()).getBytes(CharsetUtil.US_ASCII));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageEncoder.java, + buf.writeBytes(header.getBytes(CharsetUtil.US_ASCII));, + buf.writeBytes(value.getBytes(CharsetUtil.US_ASCII));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java, +import io.netty.util.CharsetUtil;, + buf.writeBytes(response.getProtocolVersion().toString().getBytes(CharsetUtil.US_ASCII));, + buf.writeBytes(String.valueOf(response.getStatus().getCode()).getBytes(CharsetUtil.US_ASCII));, +
[+++ b/pom.xml, +++ b/pom.xml, +++ b/src/main/java/org/jboss/netty/handler/execution/MemoryAwareThreadPoolExecutor.java, +++ b/pom.xml, +++ b/src/main/java/org/jboss/netty/handler/execution/MemoryAwareThreadPoolExecutor.java, +++ b/src/test/java/org/jboss/netty/util/internal/ConversionUtilTest.java]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +import io.netty.buffer.ChannelBuffers;, +import io.netty.util.internal.QueueFactory;, +import java.util.ArrayDeque;, + EventExecutor executor; // not thread-safe but OK because it never changes once set., + // each other's buffers can be accessed at the same time resulting in a race condition., + final AtomicReference<MessageBridge> inMsgBridge;, + final AtomicReference<MessageBridge> outMsgBridge;, + final AtomicReference<StreamBridge> inByteBridge;, + final AtomicReference<StreamBridge> outByteBridge;, + final Runnable curCtxFireInboundBufferUpdatedTask = new Runnable() {, + private final Runnable nextCtxFireInboundBufferUpdatedTask = new Runnable() {, + @Override, + public void run() {, + DefaultChannelHandlerContext next =, + DefaultChannelPipeline.nextInboundContext(DefaultChannelHandlerContext.this.next);, + if (next != null) {, + next.fillBridge();, + DefaultChannelPipeline.fireInboundBufferUpdated(next);, + }, + },
[+++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtProvider.java, + if (channel instanceof NioUdtByteConnectorChannel) {, + return ((NioUdtByteConnectorChannel) channel).javaChannel();, + }, +, + if (channel instanceof NioUdtMessageConnectorChannel) {, + return ((NioUdtMessageConnectorChannel) channel).javaChannel();, + }, +, +++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtProvider.java, + if (channel instanceof NioUdtByteConnectorChannel) {, + return ((NioUdtByteConnectorChannel) channel).javaChannel();, + }, +, + if (channel instanceof NioUdtMessageConnectorChannel) {, + return ((NioUdtMessageConnectorChannel) channel).javaChannel();, + }, +, +++ b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtProviderTest.java, +import io.netty.channel.udt.nio.NioUdtByteAcceptorChannel;, +import io.netty.channel.udt.nio.NioUdtByteConnectorChannel;, +import io.netty.channel.udt.nio.NioUdtByteRendezvousChannel;, +import io.netty.channel.udt.nio.NioUdtMessageAcceptorChannel;, +import io.netty.channel.udt.nio.NioUdtMessageConnectorChannel;, +import io.netty.channel.udt.nio.NioUdtMessageRendezvousChannel;, +, + NioUdtByteAcceptorChannel nioUdtByteAcceptorChannel, + = (NioUdtByteAcceptorChannel) NioUdtProvider.BYTE_ACCEPTOR.newChannel();, + NioUdtByteConnectorChannel nioUdtByteConnectorChannel, + = (NioUdtByteConnectorChannel) NioUdtProvider.BYTE_CONNECTOR.newChannel();, + NioUdtByteRendezvousChannel nioUdtByteRendezvousChannel, + = (NioUdtByteRendezvousChannel) NioUdtProvider.BYTE_RENDEZVOUS.newChannel();, + NioUdtMessageAcceptorChannel nioUdtMessageAcceptorChannel, + = (NioUdtMessageAcceptorChannel) NioUdtProvider.MESSAGE_ACCEPTOR.newChannel();,
[+++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, +public class UnpooledDirectByteBuf extends AbstractReferenceCountedByteBuf {, + protected UnpooledDirectByteBuf(ByteBufAllocator alloc, int initialCapacity, int maxCapacity) {, + protected UnpooledDirectByteBuf(ByteBufAllocator alloc, ByteBuffer initialBuffer, int maxCapacity) {, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, +public class UnpooledDirectByteBuf extends AbstractReferenceCountedByteBuf {, + protected UnpooledDirectByteBuf(ByteBufAllocator alloc, int initialCapacity, int maxCapacity) {, + protected UnpooledDirectByteBuf(ByteBufAllocator alloc, ByteBuffer initialBuffer, int maxCapacity) {, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java, +public class UnpooledHeapByteBuf extends AbstractReferenceCountedByteBuf {, + protected UnpooledHeapByteBuf(ByteBufAllocator alloc, int initialCapacity, int maxCapacity) {, + protected UnpooledHeapByteBuf(ByteBufAllocator alloc, byte[] initialArray, int maxCapacity) {, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, +public class UnpooledDirectByteBuf extends AbstractReferenceCountedByteBuf {, + protected UnpooledDirectByteBuf(ByteBufAllocator alloc, int initialCapacity, int maxCapacity) {, + protected UnpooledDirectByteBuf(ByteBufAllocator alloc,
[+++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java, + public boolean release() {, + leak.record();, + return super.release();, + }, +, + @Override, + public boolean release(int decrement) {, + leak.record();, + return super.release(decrement);, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java, + public boolean release() {, + leak.record();, + return super.release();, + }, +, + @Override, + public boolean release(int decrement) {, + leak.record();, + return super.release(decrement);, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBuf.java, + public boolean release() {, + leak.record();, + return super.release();, + }, +, + @Override, + public boolean release(int decrement) {, + leak.record();, + return super.release(decrement);, + }, +, + @Override,
[+++ b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java, + return serverChannels.containsValue(o);, + } else if (o instanceof Channel) {, + return nonServerChannels.containsValue(o);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java, + private final class StreamComparator implements Comparator<Integer> {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java, + private final class StreamComparator implements Comparator<Integer> {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java, + private boolean encoderEnforceMaxConcurrentStreams;, + return encoderEnforceMaxConcurrentStreams;]
[+++ b/pom.xml, + <conscrypt.version>1.0.0</conscrypt.version>]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + public boolean isReadOnly() {, + return false;, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + public boolean isReadOnly() {, + return false;, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + public boolean isReadOnly() {, + return unwrap().isReadOnly();, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + public boolean isReadOnly() {, + return false;, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + public boolean isReadOnly() {, + return unwrap().isReadOnly();, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * Returns {@code true} if and only if this buffer is read-only., + */, + public abstract boolean isReadOnly();, +, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/PemReader.java, + throw new KeyException("could not find key file: " + file);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockCompressor.java, +import java.util.zip.Deflater;, +, + private static final boolean USE_ZLIB;, +, + static {, + boolean java7 = false;, + try {, + Deflater.class.getDeclaredMethod(, + "deflate",, + new Class<?>[] { byte[].class, int.class, int.class, int.class });, + java7 = true;, + } catch (Exception e) {, + // Ignore, + }, +, + USE_ZLIB = java7;, + }, +, + if (USE_ZLIB) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockCompressor.java, +import java.util.zip.Deflater;, +, + private static final boolean USE_ZLIB;, +, + static {, + boolean java7 = false;, + try {, + Deflater.class.getDeclaredMethod(, + "deflate",, + new Class<?>[]
[+++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, +import io.netty.util.internal.Signal;, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, +import io.netty.util.internal.Signal;, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoderBuffer.java, +import io.netty.util.internal.Signal;, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, +import io.netty.util.internal.Signal;, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoderBuffer.java, +import io.netty.util.internal.Signal;, +++ b/codec/src/test/java/io/netty/handler/codec/ReplayingDecoderBufferTest.java, +import io.netty.util.internal.Signal;, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, +import io.netty.util.internal.Signal;, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoderBuffer.java, +import io.netty.util.internal.Signal;, +++ b/codec/src/test/java/io/netty/handler/codec/ReplayingDecoderBufferTest.java, +import io.netty.util.internal.Signal;, +++ /dev/null, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, +import io.netty.util.internal.Signal;, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoderBuffer.java, +import io.netty.util.internal.Signal;, +++ b/codec/src/test/java/io/netty/handler/codec/ReplayingDecoderBufferTest.java, +import io.netty.util.internal.Signal;, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/internal/Signal.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +, + this.content = checkNotNull(content, "content");, + }, +, + public DefaultFullHttpRequest(HttpVersion httpVersion, HttpMethod method, String uri,, + ByteBuf content, HttpHeaders headers, HttpHeaders trailingHeader) {, + super(httpVersion, method, uri, headers);, + this.content = checkNotNull(content, "content");, + this.trailingHeader = checkNotNull(trailingHeader, "trailingHeader");, + return new DefaultFullHttpRequest(, + newContent == null ? Unpooled.buffer(0) : newContent,, + headers(),, + trailingHeaders());, + return new DefaultFullHttpRequest(, + protocolVersion(), method(), uri(), content().duplicate(), headers(), trailingHeaders());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +, + this.content = checkNotNull(content, "content");, + }, +, + public DefaultFullHttpRequest(HttpVersion httpVersion, HttpMethod method, String uri,, + ByteBuf content, HttpHeaders headers,
[+++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, +import io.netty.util.concurrent.GlobalEventExecutor;, + * <strong>{@link ChannelGroup} recipients =, + * new {@link DefaultChannelGroup}({@link GlobalEventExecutor}.INSTANCE);</strong>, + * <strong>{@link ChannelGroup} allChannels =, + * new {@link DefaultChannelGroup}({@link GlobalEventExecutor}.INSTANCE);</strong>, + * b.childHandler(new MyHandler());, + * {@link Channel} serverChannel = b.bind(..).sync();, + * <strong>allChannels.add(ctx.channel());</strong>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java, + CharSequence charsetCharSequence = getCharsetAsSequence(message);, + * @deprecated use {@link #getCharsetAsSequence(HttpMessage)}, + @Deprecated, + return getCharsetAsSequence(message);, + }, +, + /**, + * Fetch charset from message's Content-Type header as a char sequence., + *, + * A lot of sites/possibly clients have charset="CHARSET", for example charset="utf-8". Or "utf8" instead of "utf-8", + * This is not according to standard, but this method provide an ability to catch desired mistakes manually in code, + *, + * @return the {@code CharSequence} with charset from message's Content-Type header, + * or {@code null} if charset is not presented,
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannelConfig.java, +, + EpollChannelOption.SO_REUSEPORT, EpollChannelOption.IP_TRANSPARENT);, + if (option == EpollChannelOption.IP_TRANSPARENT) {, + return (T) Boolean.valueOf(isIpTransparent());, + }, + } else if (option == EpollChannelOption.IP_TRANSPARENT) {, + setIpTransparent((Boolean) value);, +, + /**, + * Returns {@code true} if <a href="http://man7.org/linux/man-pages/man7/ip.7.html">IP_TRANSPARENT</a> is enabled,, + * {@code false} otherwise., + */, + public boolean isIpTransparent() {, + try {, + return datagramChannel.socket.isIpTransparent();, + } catch (IOException e) {, + throw new ChannelException(e);, + }, + }, +, + /**, + * If {@code true} is used <a href="http://man7.org/linux/man-pages/man7/ip.7.html">IP_TRANSPARENT</a> is enabled,, + * {@code false} for disable it. Default is disabled., +
[+++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/util/SimpleTrustManagerFactory.java, +import io.netty.util.internal.PlatformDependent;, +import javax.net.ssl.X509ExtendedTrustManager;, +import javax.net.ssl.X509TrustManager;, + private volatile TrustManager[] trustManagers;, + TrustManager[] trustManagers = this.trustManagers;, + if (trustManagers == null) {, + trustManagers = parent.engineGetTrustManagers();, + if (PlatformDependent.javaVersion() >= 7) {, + for (int i = 0; i < trustManagers.length; i++) {, + final TrustManager tm = trustManagers[i];, + if (tm instanceof X509TrustManager && !(tm instanceof X509ExtendedTrustManager)) {, + trustManagers[i] = new X509TrustManagerWrapper((X509TrustManager) tm);, + }, + }, + }, + this.trustManagers = trustManagers;, + }, + return trustManagers.clone();, +++ b/handler/src/main/java/io/netty/handler/ssl/util/SimpleTrustManagerFactory.java, +import io.netty.util.internal.PlatformDependent;, +import javax.net.ssl.X509ExtendedTrustManager;, +import javax.net.ssl.X509TrustManager;, + private volatile TrustManager[] trustManagers;, + TrustManager[] trustManagers =
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (processor.process(_getByte(i))) {, + i ++;, + } else {, + }, + } while (i < endIndex);, + if (processor.process(_getByte(i))) {, + i --;, + } else {, + }, + } while (i >= index);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (processor.process(_getByte(i))) {, + i ++;, + } else {, + }, + } while (i < endIndex);, + if (processor.process(_getByte(i))) {, + i --;, + } else {, + }, + } while (i >= index);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * The last-visited index If the {@link ByteBufProcessor#process(byte)} returned {@code false}., + * The last-visited index
[+++ b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufDecoder.java, + // MessageLite.getParserForType() is not available until protobuf 2.5.0.]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + * @param rawValue The raw value to set]
[+++ b/pom.xml, + <tcnative.version>2.0.8.Final</tcnative.version>]
[+++ b/transport-sctp/pom.xml, +, + <build>, + <plugins>, + <plugin>, + <artifactId>maven-surefire-plugin</artifactId>, + <version>2.7.2</version>, + <executions>, + <execution>, + <id>default-test</id>, + <configuration>, + <!--, + Ignore SCTP Test cases by default, + Note: Java SCTP only available for Linux and Solaris, + -->, + <skipTests>true</skipTests>, + </configuration>, + </execution>, + </executions>, + </plugin>, + </plugins>, + </build>]
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, + * Triggers an {@link ChannelInboundHandler#channelReadComplete(ChannelHandlerContext)}]
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, + ByteBuf value = directBuffer(BLOCK_SIZE * 2);, + ByteBuf expectedValue = directBuffer(BLOCK_SIZE * 2);, + value.release();, + expectedValue.release();, + ByteBuf value = directBuffer(BLOCK_SIZE * 2);, + ByteBuf expectedValue = wrappedBuffer(expectedValueContent);, + value.release();, + expectedValue.release();, + ByteBuf value = directBuffer(BLOCK_SIZE * 2);, + ByteBuf expectedValue = wrappedBuffer(expectedValueContent);, + value.release();, + expectedValue.release();, + ByteBuf copy = copiedBuffer(buffer);, + copy.release();, + ByteBuf copy = copiedBuffer(buffer);, + copy.release();, + ByteBuf copy = buffer.copy();, + copy.release();, + ByteBuf copied = copiedBuffer("Hello, World!", CharsetUtil.ISO_8859_1);, + buffer.writeBytes(copied);, + copied.release();, + ByteBuf elemA = buffer(15);, + ByteBuf elemB = directBuffer(15);, + ByteBuf elemACopy = elemA.copy();,
[+++ b/all/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.5.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, +++ b/handler/src/test/java/io/netty/handler/ssl/SslErrorTest.java, + // BoringSSL uses "expired" in this case while others use "bad", + if ("BoringSSL".equals(OpenSsl.versionString())) {, + verifyException(unwrappedCause, "expired", promise);, + } else {, + }, + // BoringSSL uses "expired" in this case while others use "bad", + if ("BoringSSL".equals(OpenSsl.versionString())) {, + verifyException(unwrappedCause, "expired", promise);, + } else {, + }, + Throwable error = new AssertionError("message not contains '" + messagePart + "': " + message);, + error.initCause(cause);, + promise.setFailure(error);]
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, + * Replaces the inbound byte buffer with the given buffer. This returns the, + * old buffer, so any readable bytes can be handled appropriately by the caller., + *, + * @param newInboundByteBuf the new inbound byte buffer, + * @return the old buffer., + * @throws NullPointerException if the argument is {@code null}., + */, + ByteBuf replaceInboundByteBuffer(ByteBuf newInboundByteBuf);, +, + /**, + * Replaces the inbound message buffer with the given buffer. This returns the, + * old buffer, so any pending messages can be handled appropriately by the caller., + *, +
[+++ b/pom.xml, + <version>3.19.0-GA</version>]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, + * See <a href="http://code.google.com/p/snappy/source/browse/trunk/format_description.txt">snappy format</a>., +public final class Snappy {, + static int calculateChecksum(ByteBuf data) {, + static int calculateChecksum(ByteBuf data, int offset, int length) {]
[+++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffers.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffers.java, +++ b/buffer/src/test/java/io/netty/buffer/ChannelBuffersTest.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffers.java, +++ b/buffer/src/test/java/io/netty/buffer/ChannelBuffersTest.java, +++ b/codec/src/main/java/io/netty/handler/codec/embedder/AbstractCodecEmbedder.java, +, + @Override, + public void fireUpstreamEventLater(ChannelPipeline pipeline, ChannelEvent e) throws Exception {, + handleEvent(e);, + }, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffers.java, +++ b/buffer/src/test/java/io/netty/buffer/ChannelBuffersTest.java, +++ b/codec/src/main/java/io/netty/handler/codec/embedder/AbstractCodecEmbedder.java, +, + @Override, + public void fireUpstreamEventLater(ChannelPipeline pipeline, ChannelEvent e) throws Exception {, + handleEvent(e);, + }, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffers.java, +++ b/buffer/src/test/java/io/netty/buffer/ChannelBuffersTest.java, +++ b/codec/src/main/java/io/netty/handler/codec/embedder/AbstractCodecEmbedder.java, +, + @Override, + public void fireUpstreamEventLater(ChannelPipeline pipeline, ChannelEvent e) throws Exception {, + handleEvent(e);, + }, +++ /dev/null, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java, + flush(ctx, false);, + flush(ctx, false);, + discard(ctx, false);, + flush(ctx, true);, + discard(ctx, true);, + private void
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java, + return fd().isOpen() && (config.getActiveOnOpen() && isRegistered() || active);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java, + return fd().isOpen() && (config.getActiveOnOpen() && isRegistered() || active);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannelConfig.java, + boolean getActiveOnOpen() {, + return activeOnOpen;, + }, +]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java, + if (dataLength < MIN_COMPRESSIBLE_LENGTH) {, + ByteBuf slice = in.readSlice(dataLength);, + writeUnencodedChunk(slice, out, dataLength);, + break;, + }, +, + writeUnencodedChunk(in, out, dataLength);, + }, + }, +, + private static void writeUnencodedChunk(ByteBuf in, ByteBuf out, int dataLength) {]
[+++ b/transport-rxtx/pom.xml, + <name>Netty/Transport/RXTX</name>]
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + logger.debug("java.nio.Buffer.address: unavailable", (Throwable) maybeAddressField);, + logger.debug("sun.misc.Unsafe.copyMemory: unavailable", (Throwable) maybeException);, + final Constructor<?> constructor =, + ((Constructor<?>) maybeDirectBufferConstructor).newInstance(address, 1);, + (Throwable) maybeDirectBufferConstructor);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, +package io.netty.handler.codec.http;, +, +import static io.netty.handler.codec.http.CookieEncoderUtil.*;, +, +import java.util.Collection;, +, +/**, + * Encodes client-side {@link Cookie}s into an HTTP header value. This encoder can encode, + * the HTTP cookie version 0, 1, and 2., + * <pre>, + * // Example, + * {@link HttpRequest} req = ...;, + * res.setHeader("Cookie", {@link ClientCookieEncoder}.encode("JSESSIONID", "1234"));, + * </pre>, + *, + * @see CookieDecoder, + *, + * @apiviz.stereotype utility, + * @apiviz.has io.netty.handler.codec.http.Cookie oneway - - encodes, + */, +public final class ClientCookieEncoder {, +, + /**, + * Encodes the specified cookie into an
[+++ b/testsuite-osgi/testsuite-osgi-deps/pom.xml, +, +++ b/testsuite-osgi/testsuite-osgi-deps/pom.xml, +, +++ b/testsuite-osgi/testsuite-osgi-exam/pom.xml, +++ b/testsuite-osgi/testsuite-osgi-deps/pom.xml, +, +++ b/testsuite-osgi/testsuite-osgi-exam/pom.xml, +++ b/testsuite-osgi/testsuite-osgi-split/pom.xml, +]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshakerFactory.java, +public final class WebSocketClientHandshakerFactory {, +, + /**, + * Private constructor so this static class cannot be instanced., + */, + private WebSocketClientHandshakerFactory() {, + }, + public static WebSocketClientHandshaker newHandshaker(, + public static WebSocketClientHandshaker newHandshaker(, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshakerFactory.java, +public final class WebSocketClientHandshakerFactory {, +, + /**, + * Private constructor so this static class cannot be instanced., + */, + private WebSocketClientHandshakerFactory() {, + }, + public static WebSocketClientHandshaker newHandshaker(, + public static WebSocketClientHandshaker newHandshaker(, +++ b/example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java, + WebSocketClientHandshakerFactory.newHandshaker(]
[+++ b/pom.xml, + <tcnative.version>2.0.25.Final</tcnative.version>]
[+++ b/transport-native-epoll/src/main/c/exception_helper.h, +void throwChannelExceptionErrorNo(JNIEnv* env, char* message, int errorNumber);, +++ b/transport-native-epoll/src/main/c/exception_helper.h, +void throwChannelExceptionErrorNo(JNIEnv* env, char* message, int errorNumber);, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +jclass channelExceptionClass = NULL;, +void throwChannelExceptionErrorNo(JNIEnv* env, char* message, int errorNumber) {, + char* allocatedMessage = exceptionMessage(message, errorNumber);, + (*env)->ThrowNew(env, channelExceptionClass, allocatedMessage);, + free(allocatedMessage);, +}, +, +, + throwChannelExceptionErrorNo(env, "getsockopt() failed: ", err);, + throwChannelExceptionErrorNo(env, "setsockopt() failed: ", err);, + jclass localChannelExceptionClass = (*env)->FindClass(env, "io/netty/channel/ChannelException");, + if (localChannelExceptionClass == NULL) {, + // pending exception..., + return JNI_ERR;, + }, + channelExceptionClass = (jclass) (*env)->NewGlobalRef(env, localChannelExceptionClass);, + if (channelExceptionClass == NULL) {, + // out-of-memory!, + throwOutOfMemoryError(env);, + return
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +import io.netty.channel.SelectStrategy;, +import io.netty.util.IntSupplier;, +import io.netty.util.internal.ObjectUtil;, + private final SelectStrategy selectStrategy;, + private final IntSupplier selectNowSupplier = new IntSupplier() {, + @Override, + public int get() throws Exception {, + return Native.epollWait(epollFd.intValue(), events, 0);, + }, + };, + EpollEventLoop(EventLoopGroup parent, Executor executor, int maxEvents, SelectStrategy strategy) {, + selectStrategy = ObjectUtil.checkNotNull(strategy, "strategy");, + int strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());, + switch (strategy) {, + case SelectStrategy.CONTINUE:, + continue;, + case SelectStrategy.SELECT:, + strategy = epollWait(WAKEN_UP_UPDATER.getAndSet(this, 0) == 1);, + default:, + // fallthrough, + if (strategy > 0) {, + processReady(events, strategy);, + if (strategy > 0)
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibDecoder.java, + decompressed.discardReadBytes();]
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +, + if (packetLength == SslUtils.NOT_ENCRYPTED) {, + throw new NotSslRecordException("not an SSL/TLS record");, + }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +, + if (packetLength == SslUtils.NOT_ENCRYPTED) {, + throw new NotSslRecordException("not an SSL/TLS record");, + }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/SniHandler.java, + if (len == SslUtils.NOT_ENCRYPTED) {, + if (len == SslUtils.NOT_ENOUGH_DATA ||, + writerIndex - readerIndex - SslUtils.SSL_RECORD_HEADER_LENGTH < len) {, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +, + if (packetLength == SslUtils.NOT_ENCRYPTED) {, + throw new NotSslRecordException("not an SSL/TLS record");, + }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/SniHandler.java, + if (len == SslUtils.NOT_ENCRYPTED) {, + if (len == SslUtils.NOT_ENOUGH_DATA ||, + writerIndex - readerIndex -
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerUpgradeHandler.java, +import java.util.ArrayList;, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, + * Creates a new {@link UpgradeCodec} for the requested protocol name., + */, + public interface UpgradeCodecFactory {, + /**, + * Invoked by {@link HttpServerUpgradeHandler} for all the requested protocol names in the order of, + * the client preference. The first non-{@code null} {@link UpgradeCodec} returned by this method, + * will be selected., + *, + * @return a new {@link UpgradeCodec}, or {@code null} if the specified protocol name is not supported, + */, + UpgradeCodec newUpgradeCodec(String protocol);, + }, +, + /**, + private static final
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + private final PropertyKey upgradeKey;, + upgradeKey = connection().newKey();, + stream.setProperty(upgradeKey, true);, + // upgraded requests are ineligible for stream control, + if (streamId == Http2CodecUtil.HTTP_UPGRADE_STREAM_ID) {, + Boolean upgraded = stream.getProperty(upgradeKey);, + if (Boolean.TRUE.equals(upgraded)) {, + return false;, + }, + }, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + private final PropertyKey upgradeKey;, + upgradeKey = connection().newKey();, + stream.setProperty(upgradeKey, true);, + // upgraded requests are ineligible for stream control, + if (streamId == Http2CodecUtil.HTTP_UPGRADE_STREAM_ID) {, + Boolean upgraded = stream.getProperty(upgradeKey);, + if (Boolean.TRUE.equals(upgraded)) {, + return false;, + }, + }, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttpToHttp2Adapter.java, + // note that this
[+++ b/src/docbook/module/preface.xml, + <firstterm><ulink url="http://www.jboss.org/netty/">The Netty, + project</ulink></firstterm> is an effort to provide an asynchronous, + &middot; event-driven network application framework and tooling for the, + rapid development of maintainable high-performance &middot;, + high-scalability protocol servers and clients. To simplify, Netty helps, + you write your own network application very easily -- it's often called, + <firstterm>rapid network application development</firstterm>., + read this guide on and play with Netty. ]
[+++ b/codec/src/main/java/io/netty/handler/codec/serialization/ObjectDecoder.java, +import java.io.ObjectInputStream;, + ObjectInputStream is = new CompactObjectInputStream(new ByteBufInputStream(frame), classResolver);, + Object result = is.readObject();, + is.close();, + return result;]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + private static void extractKeyValuePairs(, + private static String decodeValue(String value) {, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + private static void extractKeyValuePairs(, + private static String decodeValue(String value) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, + sb.append((char) HttpConstants.SEMICOLON);, + sb.append((char) HttpConstants.SEMICOLON);, + sb.append((char) HttpConstants.EQUALS);, + sb.append((char) HttpConstants.DOUBLE_QUOTE);, + sb.append((char) HttpConstants.COMMA);, + sb.setCharAt(sb.length() - 1,
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, + private final boolean releaseOnClose;, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, + private final boolean releaseOnClose;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2GoAwayFrame.java, + private final int lastStreamId;, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, + private final boolean releaseOnClose;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2GoAwayFrame.java, + private final int lastStreamId;, +++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/FixedRedisMessagePool.java, + private final Map<ByteBuf, SimpleStringRedisMessage> byteBufToSimpleStrings;, + private final Map<String, SimpleStringRedisMessage> stringToSimpleStrings;, + private final Map<ByteBuf, ErrorRedisMessage> byteBufToErrors;, + private final Map<String, ErrorRedisMessage> stringToErrors;, + private final Map<ByteBuf, IntegerRedisMessage> byteBufToIntegers;, + private final LongObjectMap<IntegerRedisMessage> longToIntegers;, + private final LongObjectMap<byte[]> longToByteBufs;, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, + private final boolean releaseOnClose;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2GoAwayFrame.java, + private final int lastStreamId;, +++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/FixedRedisMessagePool.java, + private final Map<ByteBuf, SimpleStringRedisMessage> byteBufToSimpleStrings;,
[+++ b/pom.xml, + <version>4.10</version>, +++ b/pom.xml, + <version>4.10</version>, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +++ b/pom.xml, + <version>4.10</version>, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ClientBootstrap.java, +++ b/pom.xml, + <version>4.10</version>, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ConnectionlessBootstrap.java, +++ b/pom.xml, + <version>4.10</version>, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ConnectionlessBootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ServerBootstrap.java, +++ b/pom.xml, + <version>4.10</version>, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ConnectionlessBootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ServerBootstrap.java, +++ b/src/main/java/org/jboss/netty/buffer/AbstractChannelBuffer.java, + public boolean getBoolean(int index) {, + return (getByte(index) == 1);, + }, +, + @Override, + public void setBoolean(int index, boolean value) {, + setByte(index, value ? 1 : 0);, + }, +, + @Override, + public boolean readBoolean() {, + return (readByte() ==
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java, +++ b/codec/src/test/java/io/netty/handler/codec/frame/DelimiterBasedFrameDecoderTest.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java, +++ b/codec/src/test/java/io/netty/handler/codec/frame/DelimiterBasedFrameDecoderTest.java, +++ b/codec/src/test/java/io/netty/handler/codec/frame/LengthFieldBasedFrameDecoderTest.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java, +++ b/codec/src/test/java/io/netty/handler/codec/frame/DelimiterBasedFrameDecoderTest.java, +++ b/codec/src/test/java/io/netty/handler/codec/frame/LengthFieldBasedFrameDecoderTest.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java, +++ b/codec/src/test/java/io/netty/handler/codec/frame/DelimiterBasedFrameDecoderTest.java, +++ b/codec/src/test/java/io/netty/handler/codec/frame/LengthFieldBasedFrameDecoderTest.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java, +++ b/codec/src/test/java/io/netty/handler/codec/frame/DelimiterBasedFrameDecoderTest.java, +++ b/codec/src/test/java/io/netty/handler/codec/frame/LengthFieldBasedFrameDecoderTest.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java, +++ b/example/src/main/java/io/netty/example/sctp/NioSctpEchoClient.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java, +++ b/codec/src/test/java/io/netty/handler/codec/frame/DelimiterBasedFrameDecoderTest.java, +++ b/codec/src/test/java/io/netty/handler/codec/frame/LengthFieldBasedFrameDecoderTest.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java, +++ b/example/src/main/java/io/netty/example/sctp/NioSctpEchoClient.java, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramMulticastTest.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java, +++ b/codec/src/test/java/io/netty/handler/codec/frame/DelimiterBasedFrameDecoderTest.java, +++
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Codec.java, +import static io.netty.handler.logging.LogLevel.INFO;, +, + private static final Http2FrameLogger HTTP2_FRAME_LOGGER = new Http2FrameLogger(INFO, Http2Codec.class);, + this(server, streamHandler, null, HTTP2_FRAME_LOGGER);, + EventLoopGroup streamGroup, Http2FrameLogger frameLogger) {, + this(server, streamHandler, streamGroup, new DefaultHttp2FrameWriter(), frameLogger);, + EventLoopGroup streamGroup, Http2FrameWriter frameWriter,, + Http2FrameLogger frameLogger) {, + frameCodec = new Http2FrameCodec(server, frameWriter, frameLogger);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Codec.java, +import static io.netty.handler.logging.LogLevel.INFO;, +, + private static final Http2FrameLogger HTTP2_FRAME_LOGGER = new Http2FrameLogger(INFO, Http2Codec.class);, + this(server, streamHandler, null, HTTP2_FRAME_LOGGER);, + EventLoopGroup streamGroup, Http2FrameLogger frameLogger) {, + this(server, streamHandler, streamGroup, new DefaultHttp2FrameWriter(), frameLogger);, + EventLoopGroup streamGroup, Http2FrameWriter frameWriter,, + Http2FrameLogger frameLogger) {, + frameCodec = new Http2FrameCodec(server, frameWriter,
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import java.util.LinkedHashSet;, +import java.util.Set;, + Set<String> algorithmList = new LinkedHashSet<String>(algs.length);, +, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import java.util.LinkedHashSet;, +import java.util.Set;, + Set<String> algorithmList = new LinkedHashSet<String>(algs.length);, +, +++ b/handler/src/main/java/io/netty/handler/ssl/SignatureAlgorithmConverter.java, + //, + // BoringSSL uses a different format:, + // https://github.com/google/boringssl/blob/8525ff3/ssl/ssl_privkey.cc#L436, + //, + // group 1 - 2, + "(?:(^[a-zA-Z].+)With(.+)Encryption$)|" +, + // group 3 - 4, + "(?:(^[a-zA-Z].+)(?:_with_|-with-|_pkcs1_|_pss_rsae_)(.+$))|" +, + // group 5 - 6, + "(?:(^[a-zA-Z].+)_(.+$))");, + String group1 = matcher.group(1);, + if (group1 != null) {, + return group1.toUpperCase(Locale.ROOT) + "with" + matcher.group(2).toUpperCase(Locale.ROOT);, + if (matcher.group(3) != null) {, + return matcher.group(4).toUpperCase(Locale.ROOT) + "with" + matcher.group(3).toUpperCase(Locale.ROOT);,
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + * identical to each other for {@code length} bytes starting at {@code aStartIndex}, + * index for the {@code a} buffer and {@code bStartIndex} index for the {@code b} buffer., + * A more compact way to express this is:, + * <p>, + * {@code a[aStartIndex : aStartIndex + length] == b[bStartIndex : bStartIndex + length]}, + */, + public static boolean equals(ByteBuf a, int aStartIndex, ByteBuf b, int bStartIndex, int length) {, + if (aStartIndex < 0 || bStartIndex < 0 || length < 0) {, + throw new IllegalArgumentException("All indexes and lengths must
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java, + private static final AsciiString SEMICOLON = AsciiString.of(";");, + * Fetch charset from message's Content-Type header as a char sequence., + * @return the {@code CharSequence} with charset from message's Content-Type header, + * or {@code null} if charset is not presented, + /**, + * Fetch MIME type part from message's Content-Type header as a char sequence., + *, + * @return the MIME type as a {@code CharSequence} from message's Content-Type header, + * or {@code null} if content-type header or MIME type part of this header are not presented, + * <p/>, + *
[+++ b/pom.xml, + <version>2.2.1</version>]
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, + private final boolean decodeIdn;, + * @deprecated use {@link #DnsNameResolver(EventLoop, ChannelFactory, DnsServerAddresses, DnsCache, long,, + * InternetProtocolFamily[], boolean, int, boolean, int,, + * boolean, HostsFileEntriesResolver, String[], int, boolean)}, + @Deprecated, + this(eventLoop, channelFactory, nameServerAddresses, resolveCache, queryTimeoutMillis, resolvedAddressTypes,, + recursionDesired, maxQueriesPerResolve, traceEnabled, maxPayloadSize, optResourceEnabled,, + hostsFileEntriesResolver, searchDomains, ndots, true);, + }, +, + /**, + * Creates a new DNS-based name resolver that communicates with the specified list of DNS servers., + *, + * @param eventLoop the {@link EventLoop} which will perform the communication with the DNS servers, + * @param channelFactory the {@link ChannelFactory} that
[+++ b/pom.xml, +++ b/pom.xml, +++ b/src/docbook/en-US/module/architecture.xml, + to represent a sequence of bytes. This approach has significant advantages, + &ChannelBuffer; has been designed from the ground up to address the problems, + You can define your own buffer type if necessary., + Transparent zero copy is achieved by a built-in composite buffer type., +++ b/pom.xml, +++ b/src/docbook/en-US/module/architecture.xml, + to represent a sequence of bytes. This approach has significant advantages, + &ChannelBuffer; has been designed from the ground up to address the problems, + You can define your own buffer type if necessary., + Transparent zero copy is achieved by
[+++ b/example/src/main/java/io/netty/example/factorial/FactorialServerHandler.java, + Formatter fmt = new Formatter();, + logger.info(fmt.format(, + fmt.close();]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java, +import io.netty.util.IllegalReferenceCountException;, + /**, + * Used to cache the value of the hash code and avoid {@link IllegalRefCountException}., + */, + private int hash;, + int hash = this.hash;, + if (hash == 0) {, + if (content().refCnt() != 0) {, + try {, + hash = 31 + content().hashCode();, + } catch (IllegalReferenceCountException ignored) {, + // Handle race condition between checking refCnt() == 0 and using the object., + hash = 31;, + }, + } else {, + hash = 31;, + }, + hash = 31 * hash + trailingHeaders().hashCode();, + hash
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/StreamBufferingEncoderTest.java, + connection.goAwayReceived(1, 8, EMPTY_BUFFER);]
[+++ b/transport/src/main/java/io/netty/channel/EventLoop.java, + ChannelFuture register(Channel channel);, + void register(Channel channel, ChannelFuture future);, +++ b/transport/src/main/java/io/netty/channel/EventLoop.java, + ChannelFuture register(Channel channel);, + void register(Channel channel, ChannelFuture future);, +++ b/transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java, + public ChannelFuture register(Channel channel) {, + register(channel, future);, +++ b/transport/src/main/java/io/netty/channel/EventLoop.java, + ChannelFuture register(Channel channel);, + void register(Channel channel, ChannelFuture future);, +++ b/transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java, + public ChannelFuture register(Channel channel) {, + register(channel, future);, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioWorker.java, + public void register(final Channel channel, final ChannelFuture future) {, +++ b/transport/src/main/java/io/netty/channel/EventLoop.java, + ChannelFuture register(Channel channel);, + void register(Channel channel, ChannelFuture future);, +++ b/transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java, + public ChannelFuture register(Channel channel) {, + register(channel, future);, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioWorker.java, + public void register(final
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, + * Copyright 2013 The Netty Project, + static final int SPDY_DATA_FRAME = 0;, + static final int SPDY_PUSH_PROMISE_FRAME = 5;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, + * Copyright 2013 The Netty Project, + static final int SPDY_DATA_FRAME = 0;, + static final int SPDY_PUSH_PROMISE_FRAME = 5;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + private static final SpdyProtocolException INVALID_FRAME =, + new SpdyProtocolException("Received invalid frame");, +, + private final SpdyHeaderBlockDecoder headerBlockDecoder;, + private int streamId;, + this(version, maxChunkSize, SpdyHeaderBlockDecoder.newInstance(version, maxHeaderSize));, + }, +, + protected SpdyFrameDecoder(, + int version, int maxChunkSize, SpdyHeaderBlockDecoder headerBlockDecoder) {, + this.headerBlockDecoder = headerBlockDecoder;, + headerBlockDecoder.end();, + fireInvalidFrameException(ctx);, + SpdyDataFrame
[+++ b/common/src/main/java/io/netty/util/Attribute.java, + * Atomically sets to the given value if this {@link Attribute}'s value is {@code null}., + * Removes this attribute from the {@link AttributeMap} and returns the old value. Subsequent {@link #get()}, + * calls will return {@code null}., + *, + * If you only want to return the old value and clear the {@link Attribute} while still keep it in, + * {@link AttributeMap} use {@link #getAndSet(Object)} with a value of {@code null}., + *, + * If you only want to remove the value and clear the {@link Attribute} while still keep it
[+++ b/all/pom.xml, + <version>4.1.12.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.12.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.12.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.12.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.12.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, + <version>4.1.12.Final-SNAPSHOT</version>, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java, + public boolean contains(CharSequence name, CharSequence value) {, + return contains(name, value, false);, + }, +, + @Override, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java, + public boolean contains(CharSequence name, CharSequence value) {, + return contains(name, value, false);, + }, +, + @Override, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2HeadersTest.java, + assertTrue(headers.contains("name1", "value2"));, + assertFalse(headers.contains("name1", "Value2"));, + assertTrue(headers.contains("2name", "Value3", true));, + assertFalse(headers.contains("2name", "Value3", false));]
[+++ b/src/main/java/org/jboss/netty/example/securechat/SecureChatServerHandler.java, +import org.jboss.netty.channel.group.ChannelGroup;, +import org.jboss.netty.channel.group.DefaultChannelGroup;, + static final ChannelGroup channels = new DefaultChannelGroup();, +++ b/src/main/java/org/jboss/netty/example/securechat/SecureChatServerHandler.java, +import org.jboss.netty.channel.group.ChannelGroup;, +import org.jboss.netty.channel.group.DefaultChannelGroup;, + static final ChannelGroup channels = new DefaultChannelGroup();, +++ b/src/main/java/org/jboss/netty/util/HashedWheelTimer.java, +++ b/src/main/java/org/jboss/netty/example/securechat/SecureChatServerHandler.java, +import org.jboss.netty.channel.group.ChannelGroup;, +import org.jboss.netty.channel.group.DefaultChannelGroup;, + static final ChannelGroup channels = new DefaultChannelGroup();, +++ b/src/main/java/org/jboss/netty/util/HashedWheelTimer.java, +++ b/src/main/java/org/jboss/netty/util/MapBackedSet.java, +/*, + * Copyright 2009 Red Hat, Inc., + *, + * Red Hat licenses this file to you under the Apache License, version 2.0, + * (the "License"); you may not use this file except in compliance with the, + * License. You may obtain a copy of the License
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + return encodeString0(alloc, false, src, charset);, + }, +, + static ByteBuf encodeString0(ByteBufAllocator alloc, boolean enforceHeap, CharBuffer src, Charset charset) {, + final ByteBuf dst;, + if (enforceHeap) {, + dst = alloc.heapBuffer(length);, + } else {, + dst = alloc.buffer(length);, + }, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + return encodeString0(alloc, false, src, charset);, + }, +, + static ByteBuf encodeString0(ByteBufAllocator alloc, boolean enforceHeap, CharBuffer src, Charset charset) {, + final ByteBuf dst;, + if (enforceHeap) {, + dst = alloc.heapBuffer(length);, + } else {, + dst = alloc.buffer(length);, + }, +++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, + ByteBuf copy = buffer(readable);, + if
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + int index = readerIndex;, + int length = writerIndex - index;, + return forEachByteAsc0(index, length, processor);, + public int forEachByte(int index, int length, ByteBufProcessor processor) {, + checkIndex(index, length);, + return forEachByteAsc0(index, length, processor);, + private int forEachByteAsc0(int index, int length, ByteBufProcessor processor) {, + if (length == 0) {, + final int endIndex = index + length;, + int i = index;, + i += processor.process(_getByte(i));, + } while (i < endIndex);, + int index = readerIndex;, + int length = writerIndex - index;, + return forEachByteDesc0(index, length, processor);, + public int forEachByteDesc(int index, int
[+++ b/handler/src/main/java/io/netty/handler/ssl/CipherSuiteConverter.java, + /**, + * Convert the given ciphers if needed to OpenSSL format and append them to the correct {@link StringBuilder}, + * depending on if its a TLSv1.3 cipher or not. If this methods returns without throwing an exception its, + * guaranteed that at least one of the {@link StringBuilder}s contain some ciphers that can be used to configure, + * OpenSSL., + */, + static void convertToCipherStrings(, + Iterable<String> cipherSuites, StringBuilder cipherBuilder, StringBuilder cipherTLSv13Builder) {, + for (String c: cipherSuites) {, + if (c == null) {, + break;, + }, +, + String
[+++ b/handler/src/test/java/io/netty/handler/ssl/ConscryptOpenSslEngineInteropTest.java, +/*, + * Copyright 2019 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + PooledByteBuf<T> allocate(PoolThreadCache cache, int reqCapacity, int maxCapacity) {, + allocate(cache, buf, reqCapacity);, + private void allocate(PoolThreadCache cache, PooledByteBuf<T> buf, final int reqCapacity) {, + final int normCapacity = normalizeCapacity(reqCapacity);, + if ((normCapacity & subpageOverflowMask) == 0) { // capacity < pageSize, + if ((normCapacity & 0xFFFFFE00) == 0) { // < 512, + tableIdx = normCapacity >>> 4;, + int i = normCapacity >>> 10;, + if (!s.doNotDestroy || s.elemSize != normCapacity) {, + s.chunk.initBufWithSubpage(buf, handle, reqCapacity);, + allocateNormal(buf, reqCapacity, normCapacity);, + private synchronized void allocateNormal(PooledByteBuf<T> buf, int reqCapacity, int normCapacity) {, + if (q050.allocate(buf, reqCapacity,
[+++ b/all/pom.xml, + <version>4.0.5.Final</version>, +++ b/all/pom.xml, + <version>4.0.5.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.5.Final</version>, +++ b/all/pom.xml, + <version>4.0.5.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.5.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.5.Final</version>, +++ b/all/pom.xml, + <version>4.0.5.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.5.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.5.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.5.Final</version>, +++ b/all/pom.xml, + <version>4.0.5.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.5.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.5.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.5.Final</version>, +++ b/codec/pom.xml, + <version>4.0.5.Final</version>, +++ b/all/pom.xml, + <version>4.0.5.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.5.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.5.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.5.Final</version>, +++ b/codec/pom.xml, + <version>4.0.5.Final</version>, +++ b/common/pom.xml, + <version>4.0.5.Final</version>, +++ b/all/pom.xml, + <version>4.0.5.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.5.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.5.Final</version>, +++ b/codec-socks/pom.xml, +
[+++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, + @Deprecated, + @Deprecated, + @Deprecated, +++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, + @Deprecated, + @Deprecated, + @Deprecated, +++ b/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtChannelConfig.java, +import io.netty.buffer.ByteBufAllocator;, + @Override, + public UdtChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis) {, + super.setConnectTimeoutMillis(connectTimeoutMillis);, + return this;, + }, +, + @Override, + public UdtChannelConfig setWriteSpinCount(int writeSpinCount) {, + super.setWriteSpinCount(writeSpinCount);, + return this;, + }, +, + @Override, + public UdtChannelConfig setAllocator(ByteBufAllocator allocator) {, + super.setAllocator(allocator);, + return this;, + }, +, + @Override, + public UdtChannelConfig setAutoRead(boolean autoRead) {, + super.setAutoRead(autoRead);, + return this;, + }, +++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, + @Deprecated, + @Deprecated, + @Deprecated, +++ b/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtChannelConfig.java, +import io.netty.buffer.ByteBufAllocator;, + @Override, + public
[+++ b/transport/src/main/java/io/netty/channel/ChannelInboundMessageHandlerAdapter.java, +++ b/transport/src/main/java/io/netty/channel/ChannelInboundMessageHandlerAdapter.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + notifyHandlerException(e);, + notifyHandlerException(e);, + notifyHandlerException(t);, + notifyHandlerException(t);, + notifyHandlerException(t);, + notifyHandlerException(t);, + findContextInbound().invokeExceptionCaught(cause);, + return this;, + }, +, + private void invokeExceptionCaught(final Throwable cause) {, + EventExecutor executor = executor();, + invokeExceptionCaught0(cause);, + invokeExceptionCaught0(cause);, + private void invokeExceptionCaught0(Throwable cause) {, + notifyHandlerException(t);, + notifyHandlerException(t);, + notifyHandlerException(t);, + notifyHandlerException(t);, + notifyHandlerException(t);, + notifyHandlerException(t);, + notifyHandlerException(t);, + notifyHandlerException(t);, + notifyHandlerException(t);, + notifyHandlerException(t);, + notifyHandlerException(t);, + notifyHandlerException(t);, + notifyHandlerException(t);, + notifyHandlerException(t);, + notifyHandlerException(t);, + notifyHandlerException(t);, + private void notifyHandlerException(Throwable cause) {, + if (inExceptionCaught(cause)) {, + if (logger.isWarnEnabled()) {, + logger.warn(, + "An exception
[+++ b/common/src/main/java/io/netty/util/internal/IntegerHolder.java, +/**, + * @deprecated For removal in netty 4.2, + */, +@Deprecated, +++ b/common/src/main/java/io/netty/util/internal/IntegerHolder.java, +/**, + * @deprecated For removal in netty 4.2, + */, +@Deprecated, +++ b/common/src/main/java/io/netty/util/internal/InternalThreadLocalMap.java, + @Deprecated, + @Deprecated]
[+++ b/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08Test.java, +/*, + * Copyright 2011 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, + protected boolean acceptOutboundMessage(Object msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, + protected boolean acceptOutboundMessage(Object msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java, + protected boolean acceptOutboundMessage(Object msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, + protected boolean acceptOutboundMessage(Object msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java, + protected boolean acceptOutboundMessage(Object msg) throws Exception {, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundMessageHandlerAdapter.java, + protected boolean acceptOutboundMessage(Object msg) throws Exception {]
[+++ b/transport-udt/pom.xml]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, + private static final byte[] CRLF = { CR, LF };, + private static final byte[] CRLF_END = { CR, LF, 0 };, + private static final byte[] HEADER_SEPARATOR = { COLON , SP };, + out.writeBytes(CRLF);, + out.writeBytes(CRLF);, + out.writeBytes(CRLF);, + out.writeBytes(CRLF_END);, + out.writeBytes(CRLF);, +, + buf.writeBytes(HEADER_SEPARATOR);, + buf.writeBytes(CRLF);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, + private static final byte[] CRLF = { CR, LF };, + private static final byte[] CRLF_END = { CR, LF, 0 };, + private static final byte[] HEADER_SEPARATOR = { COLON , SP };, + out.writeBytes(CRLF);, + out.writeBytes(CRLF);, + out.writeBytes(CRLF);, + out.writeBytes(CRLF_END);, + out.writeBytes(CRLF);,
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.handler.codec.http2.StreamByteDistributor.Writer;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +import java.util.ArrayDeque;, +import java.util.Deque;, +, +import static io.netty.handler.codec.http2.Http2Stream.State.HALF_CLOSED_LOCAL;, + private static final InternalLogger logger =, + InternalLoggerFactory.getInstance(DefaultHttp2RemoteFlowController.class);, + private WritabilityMonitor monitor;, + this(connection, (Listener) null);, + this(connection, streamByteDistributor, null);, + }, +, + public DefaultHttp2RemoteFlowController(Http2Connection connection, final Listener listener) {, + this(connection, new PriorityStreamByteDistributor(connection), listener);, + }, +, + public DefaultHttp2RemoteFlowController(Http2Connection connection,, + StreamByteDistributor streamByteDistributor,, + final Listener listener) {, + connectionState = new DefaultState(connection.connectionStream(), initialWindowSize,, + initialWindowSize > 0 && isChannelWritable());, + // Monitor may depend upon connectionState, and so initialize after connectionState, + listener(listener);, +, +
[+++ b/all/pom.xml, + <outputDirectory>${project.build.directory}/src</outputDirectory>]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/CleartextHttp2ServerUpgradeHandler.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + return PlatformDependent0.isAndroid();, + return PlatformDependent0.javaVersion();, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + return PlatformDependent0.isAndroid();, + return PlatformDependent0.javaVersion();, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + private static final int JAVA_VERSION = javaVersion0();, + private static final boolean IS_ANDROID = isAndroid0();, + if (javaVersion() >= 9) {, + } else {, + logger.debug("jdk.internal.misc.Unsafe.allocateUninitializedArray(int): unavailable prior to Java9");, + }, + ALLOCATE_ARRAY_METHOD = allocateArrayMethod;, + static boolean isAndroid() {, + return IS_ANDROID;, + }, +, + private static boolean isAndroid0() {, + boolean android;, + try {, + Class.forName("android.app.Application", false, getSystemClassLoader());, + android = true;, + } catch (Throwable ignored) {, + // Failed to load the
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, +, + if (msg instanceof LastHttpContent) {, + state = ST_INIT;, + }, +, + break;, + }, + // fall-through!, + case ST_CONTENT_ALWAYS_EMPTY:, +, + // We allocated a buffer so add it now., +, + break;, + case ST_CONTENT_CHUNK:, + if (buf != null) {, + // We allocated a buffer so add it now., + out.add(buf);, + }, + encodeChunkedContent(ctx, msg, contentLength(msg), out);, +, + break;, + default:, + throw new Error();, + } else if (buf != null) {, + } else if (contentLength == 0) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, +, + if (msg
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * whose name starts with {@code write} will write the data at the current]
[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, +import java.util.Iterator;, +import java.util.NoSuchElementException;, + public Iterator<EventExecutor> iterator() {, + return new EventExecutorIterator();, + }, +, + @Override, + private final class EventExecutorIterator implements Iterator<EventExecutor> {, + private boolean nextCalled;, +, + @Override, + public boolean hasNext() {, + return !nextCalled;, + }, +, + @Override, + public EventExecutor next() {, + if (!hasNext()) {, + throw new NoSuchElementException();, + }, + nextCalled = true;, + return AbstractEventExecutor.this;, + }, +, + @Override, + public void remove() {, + throw new UnsupportedOperationException("read-only");, + }, + }, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, +import java.util.Iterator;, +import java.util.NoSuchElementException;, + public Iterator<EventExecutor> iterator() {,
[+++ b/all/pom.xml, + <dependencies>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-build</artifactId>, + <version>10</version>, + </dependency>, + </dependencies>, +++ b/all/pom.xml, + <dependencies>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-build</artifactId>, + <version>10</version>, + </dependency>, + </dependencies>, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + if (index < 0) {, + throw new IndexOutOfBoundsException("index must be >= 0");, + }, + if (length == 0) {, + return;, + }, + int i = toComponentIndex(index);, +, + if (index < 0) {, + throw new IndexOutOfBoundsException("index must be >= 0");, + }, + if (length == 0) {, + return;, + }, + int i = toComponentIndex(index);, + if
[+++ b/all/pom.xml, + <attach>true</attach>, +++ b/all/pom.xml, + <attach>true</attach>, +++ b/pom.xml]
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java, +import java.util.Collection;, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, + static DnsServerAddressStreamProvider parseSilently() {, + if (etcResolverFiles != null && etcResolverFiles.length == 0) {, + throw new IllegalArgumentException("etcResolverFiles must either be null or non-empty");, + Map<String, DnsServerAddresses> etcResolvConfMap = parse(checkNotNull(etcResolvConf, "etcResolvConf"));, + domainToNameServerStreamMap = etcResolverFiles != null ? parse(etcResolverFiles) : etcResolvConfMap;, +, + DnsServerAddresses defaultNameServerAddresses = etcResolvConfMap.get(etcResolvConf.getName());, + if (defaultNameServerAddresses == null) {, + Collection<DnsServerAddresses> values = etcResolvConfMap.values();, + if (values.isEmpty()) {, + throw new IllegalArgumentException(etcResolvConf + " didn't provide any name servers");, + }, + this.defaultNameServerAddresses = values.iterator().next();, + } else {, + this.defaultNameServerAddresses = defaultNameServerAddresses;, + }, +, +
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + unwrap().retain();, + unwrap().retain(increment);, + return unwrap().release();, + return unwrap().release(decrement);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + unwrap().retain();, + unwrap().retain(increment);, + return unwrap().release();, + return unwrap().release(decrement);, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + array[i] = list.get(i).buf.retain();, + compositeBuf.release();, + return addComponents0(cIndex, array);, + }, +, + if (buffers instanceof CompositeByteBuf) {, + CompositeByteBuf compositeBuf = (CompositeByteBuf) buffers;, + final int nComponents = compositeBuf.numComponents();, + ByteBuf[] array = new ByteBuf[nComponents];, + for (int i = 0; i < nComponents; i ++) {, + array[i] = compositeBuf.component(i).retain();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + unwrap().retain();, + unwrap().retain(increment);, + return unwrap().release();, + return unwrap().release(decrement);, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + array[i] = list.get(i).buf.retain();, + compositeBuf.release();,
[+++ b/resolver/src/main/java/io/netty/resolver/AddressResolverGroup.java, + synchronized (resolvers) {, + }]
[+++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java, + logger.debug("io.netty.resourceLeakDetection: {}", ENABLED);, +, +++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java, + logger.debug("io.netty.resourceLeakDetection: {}", ENABLED);, +, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +import io.netty.util.CharsetUtil;, +import java.io.BufferedReader;, +import java.io.IOException;, +import java.io.InputStreamReader;, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(PlatformDependent.class);, +, + if (logger.isDebugEnabled()) {, + logger.debug("io.netty.preferDirect: {}", DIRECT_BUFFER_PREFERRED);, + }, +, + "Unless explicitly requested, heap buffer will always be preferred to avoid potential system " +, + "unstability.");, +, + logger.debug("Platform: Android");, + boolean windows = SystemPropertyUtil.get("os.name", "").toLowerCase(Locale.US).contains("win");, + if (windows) {, + logger.debug("Platform: Windows");, + }, + return windows;, + if (isWindows()) {, + return false;, + }, +, + String[] ID_COMMANDS = {
[+++ b/pom.xml, + <cssResource>, + <directory>${basedir}/src/docbook</directory>, + <includes>, + <include>css/**/*</include>, + </includes>, + </cssResource>, + <stylesheetResource>file://${basedir}/src/docbook/xslt/xhtml.xsl</stylesheetResource>, + <stylesheetResource>file://${basedir}/src/docbook/xslt/xhtml-single.xsl</stylesheetResource>, + <format>, + <formatName>eclipse</formatName>, + <stylesheetResource>file://${basedir}/src/docbook/xslt/eclipse.xsl</stylesheetResource>, + <finalName>index.html</finalName>, + </format>, + <format>, + <formatName>pdf</formatName>, + <stylesheetResource>file://${basedir}/src/docbook/xslt/pdf.xsl</stylesheetResource>, + <finalName>netty.pdf</finalName>, + </format>, +++ b/pom.xml, + <cssResource>, + <directory>${basedir}/src/docbook</directory>, + <includes>, + <include>css/**/*</include>, + </includes>, + </cssResource>, + <stylesheetResource>file://${basedir}/src/docbook/xslt/xhtml.xsl</stylesheetResource>, + <stylesheetResource>file://${basedir}/src/docbook/xslt/xhtml-single.xsl</stylesheetResource>, + <format>, + <formatName>eclipse</formatName>, + <stylesheetResource>file://${basedir}/src/docbook/xslt/eclipse.xsl</stylesheetResource>, + <finalName>index.html</finalName>, + </format>, + <format>, + <formatName>pdf</formatName>, + <stylesheetResource>file://${basedir}/src/docbook/xslt/pdf.xsl</stylesheetResource>, + <finalName>netty.pdf</finalName>, + </format>, +++ b/src/docbook/css/jbossorg.css, +@import url("documentation.css");, +@import url("docnav.css");, +@import url("reports.css");, +@import url("extensions.css");, +@import url("codehighlight.css");, +, +body {, + background-image:url(../images/community/bkg_gradient.gif);, + background-repeat:repeat-x;, + margin:0 auto;, +
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + if (prev != null && executor.inEventLoop()) {, + if (prev == null) {, +, + }, + if (prev != null && executor.inEventLoop()) {, + if (prev != null && executor.inEventLoop()) {, + if (!pipeline.isInboundShutdown()) {, + if (!pipeline.isInboundShutdown()) {, + if (handler instanceof ChannelInboundByteHandler && !pipeline.isInboundShutdown()) {, + if (pipeline.isOutboundShutdown()) {, + if (handler instanceof ChannelOutboundByteHandler && !pipeline.isOutboundShutdown()) {, + if (pipeline.isOutboundShutdown()) {, + if (prev != null && executor.inEventLoop()) {, + pipeline.shutdownInbound();, + if (next == null) {, + if (executor.inEventLoop()) {, + pipeline.shutdownOutbound();, + invokeFreeOutboundBuffer0();, + } else {, + Runnable task =
[+++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, + * @throws Exception is thrown if an error occurs. In that case it will be handled by, + * {@link #exceptionCaught(ChannelHandlerContext, Throwable)} which will by default close, + * the {@link Channel}., + ctx.pipeline().remove(this);, + }, +, + /**, + * Handle the {@link Throwable} by logging and closing the {@link Channel}. Sub-classes may override this., + */, + @Override, + public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {, + logger.warn("Failed to initialize a channel. Closing: " + ctx.channel(), cause);, + try {, + ChannelPipeline pipeline = ctx.pipeline();, + } finally {, +++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, +
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java, + int len = uncompressed.readableBytes();, + int offset;, + byte[] inAry;, + if (uncompressed.hasArray()) {, + // if it is backed by an array we not need to to do a copy at all, + inAry = uncompressed.array();, + offset = uncompressed.arrayOffset() + uncompressed.readerIndex();, + // skip all bytes as we will consume all of them, + uncompressed.skipBytes(len);, + } else {, + inAry = new byte[len];, + offset = 0;, + }, + deflater.setInput(inAry, offset, len);, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java, + int len = uncompressed.readableBytes();, + int offset;, + byte[] inAry;, + if (uncompressed.hasArray()) {, + // if
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +import static io.netty.buffer.ByteBufUtil.*;, + if (maxChunkSize <= 0) {, + out.add(message);, + out.add(LastHttpContent.EMPTY_LAST_CONTENT);, + reset();, + out.add(message);, + out.add(LastHttpContent.EMPTY_LAST_CONTENT);, + reset();, + assert nextState == State.READ_FIXED_LENGTH_CONTENT || nextState == State.READ_VARIABLE_LENGTH_CONTENT;, +, + out.add(message);, +, + if (nextState == State.READ_FIXED_LENGTH_CONTENT) {, + // chunkSize will be decreased as the READ_FIXED_LENGTH_CONTENT state reads data chunk by chunk., +, + int toRead = Math.min(actualReadableBytes(), maxChunkSize);, + if (toRead > 0) {, + if (buffer.isReadable()) {, + } else {, + // End of connection., + out.add(new DefaultLastHttpContent(content, validateHeaders));, + reset();, + }, + } else if (!buffer.isReadable()) {, + //
[+++ b/all/pom.xml, + <plugin>, + <artifactId>maven-antrun-plugin</artifactId>, + <executions>, + <execution>, + <id>clean-source-directory</id>, + <phase>package</phase>, + <goals>, + <goal>run</goal>, + </goals>, + </execution>, + </executions>, + <configuration>, + <target>, + <delete dir="${project.build.directory}/src" quiet="true"/>, + <delete dir="${project.build.directory}/classes" quiet="true"/>, + </target>, + </configuration>, + </plugin>]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + int capacity = buffer.capacity();, + fromIndex = Math.min(fromIndex, capacity);, + if (fromIndex < 0 || capacity == 0) {, + int capacity = buf.capacity();, + if (isOutOfBounds(start, length, capacity)) {, + + ") <= " + "buf.capacity(" + capacity + ')');, + if (copy || start != 0 || length != capacity) {, + getBytes(buffer, threadLocalTempArray(chunkLen), 0, chunkLen, out, length);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + int capacity = buffer.capacity();, + fromIndex = Math.min(fromIndex, capacity);, + if (fromIndex < 0 || capacity == 0) {, + int capacity = buf.capacity();, + if (isOutOfBounds(start, length, capacity)) {, + + ")
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameLogger.java, + logger.log(level, "{} {} DATA: streamId={} padding={} endStream={} length={} bytes={}", ctx.channel(),, + logger.log(level, "{} {} HEADERS: streamId={} headers={} padding={} endStream={}", ctx.channel(),, + logger.log(level, "{} {} HEADERS: streamId={} headers={} streamDependency={} weight={} exclusive={} " +]
[+++ b/handler/src/test/java/io/netty/handler/ssl/SniClientTest.java, + @Test(timeout = 5000), + @Test(timeout = 5000), + @Test(timeout = 5000), + @Test(timeout = 5000), + cc.close().syncUninterruptibly();, + sc.close().syncUninterruptibly();]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + public short getShortLE(int index) {, + checkIndex(index, 2);, + return _getShortLE(index);, + }, +, + protected abstract short _getShortLE(int index);, +, + @Override, + public int getUnsignedShortLE(int index) {, + return getShortLE(index) & 0xFFFF;, + }, +, + @Override, + public int getUnsignedMediumLE(int index) {, + checkIndex(index, 3);, + return _getUnsignedMediumLE(index);, + }, +, + protected abstract int _getUnsignedMediumLE(int index);, +, + @Override, + public int getMediumLE(int index) {, + int value = getUnsignedMediumLE(index);, + if ((value & 0x800000) != 0) {, + value |= 0xff000000;, + }, + return value;, + }, +, + @Override,
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + private final OpenSslSession session;, + session = new OpenSslSession(ssl, sessionContext);, + if (isDestroyed()) {, + if (isDestroyed()) {, + if (handshakeState != HandshakeState.NOT_STARTED && !isDestroyed()) {, + if (!isDestroyed()) {, + if (!isDestroyed()) {, + if (!isDestroyed()) {, + if (!isDestroyed()) {, + if (engineClosed || isDestroyed()) {, + session.handshakeFinished();, +, + return handshakeState != HandshakeState.NOT_STARTED && !isDestroyed(), + private boolean isDestroyed() {, + return destroyed != 0;, + }, +, + private final OpenSslSessionContext sessionContext;, + private final long creationTime;, +, + // These are guarded by synchronized(OpenSslEngine.this) as handshakeFinished() may be triggered by any,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + dup.setDecoderResult(decoderResult());, + dup.setDecoderResult(decoderResult());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + dup.setDecoderResult(decoderResult());, + dup.setDecoderResult(decoderResult());, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java, +import io.netty.handler.codec.DecoderResult;, +, + @Test, + public void testReplaceAggregatedRequest() {, + EmbeddedChannel embedder = new EmbeddedChannel(new HttpObjectAggregator(1024 * 1024));, +, + Exception boom = new Exception("boom");, + HttpRequest req = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "http://localhost");, + req.setDecoderResult(DecoderResult.failure(boom));, +, + assertTrue(embedder.writeInbound(req) && embedder.finish());, +, + FullHttpRequest aggregatedReq = embedder.readInbound();, + FullHttpRequest replacedReq = aggregatedReq.replace(Unpooled.EMPTY_BUFFER);, +, + assertEquals(replacedReq.decoderResult(), aggregatedReq.decoderResult());, + aggregatedReq.release();, + replacedReq.release();, + }, +, + @Test, + public void testReplaceAggregatedResponse() {, + EmbeddedChannel embedder = new EmbeddedChannel(new HttpObjectAggregator(1024 * 1024));, +, + Exception boom = new
[+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java, +import io.netty.util.NetUtil;, + if (!NetUtil.isValidIpV4Address(host)) {, + if (!NetUtil.isValidIp6Address(host)) {, + byteBuf.writeBytes(NetUtil.createByteArrayFromIpAddressString(host));, + byteBuf.writeBytes(NetUtil.createByteArrayFromIpAddressString(host));, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java, +import io.netty.util.NetUtil;, + if (!NetUtil.isValidIpV4Address(host)) {, + if (!NetUtil.isValidIp6Address(host)) {, + byteBuf.writeBytes(NetUtil.createByteArrayFromIpAddressString(host));, + byteBuf.writeBytes(NetUtil.createByteArrayFromIpAddressString(host));, +++ /dev/null, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java, +import io.netty.util.NetUtil;, + if (!NetUtil.isValidIpV4Address(host)) {, + if (!NetUtil.isValidIp6Address(host)) {, + byteBuf.writeBytes(NetUtil.createByteArrayFromIpAddressString(host));, + byteBuf.writeBytes(NetUtil.createByteArrayFromIpAddressString(host));, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/NetUtil.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequest.java, + * support is also provided separately via {@link ClientCookieDecoder}, {@link ServerCookieDecoder},, + * {@link ClientCookieEncoder}, and {@link @ServerCookieEncoder}., + * @see ClientCookieDecoder, + * @see ServerCookieDecoder, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequest.java, + * support is also provided separately via {@link ClientCookieDecoder}, {@link ServerCookieDecoder},, + * {@link ClientCookieEncoder}, and {@link @ServerCookieEncoder}., + * @see ClientCookieDecoder, + * @see ServerCookieDecoder, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponse.java, + * Unlike the Servlet API, {@link Cookie} support is provided separately via {@link ClientCookieDecoder},, + * {@link ServerCookieDecoder}, {@link ClientCookieEncoder}, and {@link @ServerCookieEncoder}., + * @see ClientCookieDecoder, + * @see ServerCookieDecoder, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequest.java, + * support is also
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java, + public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java, + public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java, + public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerInvokerUtil.java, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java, + public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerInvokerUtil.java, +++ b/transport/src/main/java/io/netty/channel/ChannelInboundHandler.java, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +++
[+++ b/pom.xml, + <version>2.5</version>, + <ignore/>, + <ignore/>, + <ignore/>, + <goal>get</goal>, + <goal>properties</goal>]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameLogger.java, +, +import io.netty.handler.logging.LogLevel;, + public Http2FrameLogger(LogLevel level) {, + this(level.toInternalLevel(), InternalLoggerFactory.getInstance(Http2FrameLogger.class));, + public Http2FrameLogger(LogLevel level, String name) {, + this(level.toInternalLevel(), InternalLoggerFactory.getInstance(name));, + }, +, + public Http2FrameLogger(LogLevel level, Class<?> clazz) {, + this(level.toInternalLevel(), InternalLoggerFactory.getInstance(clazz));, + }, +, + private Http2FrameLogger(InternalLogLevel level, InternalLogger logger) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameLogger.java, +, +import io.netty.handler.logging.LogLevel;, + public Http2FrameLogger(LogLevel level) {, + this(level.toInternalLevel(), InternalLoggerFactory.getInstance(Http2FrameLogger.class));, + public Http2FrameLogger(LogLevel level, String name) {, + this(level.toInternalLevel(), InternalLoggerFactory.getInstance(name));, + }, +, + public Http2FrameLogger(LogLevel level, Class<?> clazz) {, + this(level.toInternalLevel(), InternalLoggerFactory.getInstance(clazz));, + }, +, + private Http2FrameLogger(InternalLogLevel level, InternalLogger logger) {, +++ b/example/src/main/java/io/netty/example/http2/client/Http2ClientInitializer.java, +import static io.netty.handler.logging.LogLevel.INFO;, +, +
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + private static final String NORMALIZED_ARCH = normalizeArch(SystemPropertyUtil.get("os.arch", ""));, + private static final String NORMALIZED_OS = normalizeOs(SystemPropertyUtil.get("os.name", ""));, + public static String normalizedArch() {, + return NORMALIZED_ARCH;, + }, +, + public static String normalizedOs() {, + return NORMALIZED_OS;, + }, +, + private static String normalize(String value) {, + return value.toLowerCase(Locale.US).replaceAll("[^a-z0-9]+", "");, + }, +, + private static String normalizeArch(String value) {, + value = normalize(value);, + if (value.matches("^(x8664|amd64|ia32e|em64t|x64)$")) {, + return "x86_64";, + }, + if (value.matches("^(x8632|x86|i[3-6]86|ia32|x32)$")) {, + return "x86_32";, + }, + if (value.matches("^(ia64|itanium64)$")) {, + return "itanium_64";, + }, + if (value.matches("^(sparc|sparc32)$"))
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, + Set<ChannelHandlerType> types();, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, + Set<ChannelHandlerType> types();, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + public Set<ChannelHandlerType> types() {]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufIndexFinder.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufIndexFinder.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, + *, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufIndexFinder.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, + *, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufOutputStream.java, + *, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufIndexFinder.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, + *, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufOutputStream.java, + *, +++ b/buffer/src/main/java/io/netty/buffer/MessageBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufIndexFinder.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, + *, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufOutputStream.java, + *, +++ b/buffer/src/main/java/io/netty/buffer/MessageBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufIndexFinder.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, + *, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufOutputStream.java, + *, +++ b/buffer/src/main/java/io/netty/buffer/MessageBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, +++ b/buffer/src/main/java/io/netty/buffer/package-info.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufIndexFinder.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, +
[+++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, + @SuppressWarnings("unchecked"), + public B validate() {, + return (B) this;, +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, + @SuppressWarnings("unchecked"), + public B validate() {, + return (B) this;, +++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, + public Bootstrap validate() {, + return this;, +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, + @SuppressWarnings("unchecked"), + public B validate() {, + return (B) this;, +++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, + public Bootstrap validate() {, + return this;, +++ b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java, + public ServerBootstrap validate() {, + return this;]
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/ServerSocketSuspendTest.java, + //@Ignore("Need to investigate why it fails on osx"), +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/ServerSocketSuspendTest.java, + //@Ignore("Need to investigate why it fails on osx"), +++ b/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java, + protected final Channel channel;, +, + public DefaultChannelConfig(Channel channel) {, + if (channel == null) {, + throw new NullPointerException("channel");, + }, + this.channel = channel;, + }, +, + boolean oldAutoRead = this.autoRead;, + if (autoRead && !oldAutoRead) {, + channel.read();, + }, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/ServerSocketSuspendTest.java, + //@Ignore("Need to investigate why it fails on osx"), +++ b/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java, + protected final Channel channel;, +, + public DefaultChannelConfig(Channel channel) {, + if (channel == null) {,
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + static final boolean checkAccessible; // accessed from CompositeByteBuf, + if (endianness == null) {, + throw new NullPointerException("endianness");, + }, + int forEachByteAsc0(int start, int end, ByteProcessor processor) throws Exception {, + int forEachByteDesc0(int rStart, final int rEnd, ByteProcessor processor) throws Exception {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + static final boolean checkAccessible; // accessed from CompositeByteBuf, + if (endianness == null) {, + throw new NullPointerException("endianness");, + }, + int forEachByteAsc0(int start, int end, ByteProcessor processor) throws Exception {, + int forEachByteDesc0(int rStart, final int rEnd, ByteProcessor processor) throws Exception {, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, +import io.netty.util.ByteProcessor;, +import io.netty.util.IllegalReferenceCountException;, +import
[+++ b/testsuite-osgi/testsuite-osgi-deps/pom.xml, + <updatePolicy>43200</updatePolicy> <!-- Update every 30 days -->]
[+++ b/common/pom.xml, + <dependency>, + <groupId>org.apache.logging.log4j</groupId>, + <artifactId>log4j-api</artifactId>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>org.apache.logging.log4j</groupId>, + <artifactId>log4j-core</artifactId>, + <scope>test</scope>, + </dependency>, +++ b/common/pom.xml, + <dependency>, + <groupId>org.apache.logging.log4j</groupId>, + <artifactId>log4j-api</artifactId>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>org.apache.logging.log4j</groupId>, + <artifactId>log4j-core</artifactId>, + <scope>test</scope>, + </dependency>, +++ b/common/src/main/java/io/netty/util/internal/logging/Log4J2Logger.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:,
[+++ b/buffer/pom.xml, + io.netty.buffer, +++ b/buffer/pom.xml, + io.netty.buffer, +++ b/codec-http/pom.xml, + io.netty.handler.codec.http.websocketx,, +++ b/buffer/pom.xml, + io.netty.buffer, +++ b/codec-http/pom.xml, + io.netty.handler.codec.http.websocketx,, +++ b/codec/pom.xml, + io.netty.handler.codec.sctp,, +++ b/buffer/pom.xml, + io.netty.buffer, +++ b/codec-http/pom.xml, + io.netty.handler.codec.http.websocketx,, +++ b/codec/pom.xml, + io.netty.handler.codec.sctp,, +++ b/common/pom.xml, + io.netty.util.internal.jzlib , +++ b/buffer/pom.xml, + io.netty.buffer, +++ b/codec-http/pom.xml, + io.netty.handler.codec.http.websocketx,, +++ b/codec/pom.xml, + io.netty.handler.codec.sctp,, +++ b/common/pom.xml, + io.netty.util.internal.jzlib , +++ b/handler/pom.xml, +++ b/buffer/pom.xml, + io.netty.buffer, +++ b/codec-http/pom.xml, + io.netty.handler.codec.http.websocketx,, +++ b/codec/pom.xml, + io.netty.handler.codec.sctp,, +++ b/common/pom.xml, + io.netty.util.internal.jzlib , +++ b/handler/pom.xml, +++ b/metrics-yammer/pom.xml, +++ b/buffer/pom.xml, + io.netty.buffer, +++ b/codec-http/pom.xml, + io.netty.handler.codec.http.websocketx,, +++ b/codec/pom.xml, + io.netty.handler.codec.sctp,, +++ b/common/pom.xml, + io.netty.util.internal.jzlib , +++
[+++ b/example/src/main/java/io/netty/example/http/cors/OkResponseHandler.java, +import io.netty.channel.SimpleChannelInboundHandler;, +public class OkResponseHandler extends SimpleChannelInboundHandler<Object> {, + public void channelRead0(ChannelHandlerContext ctx, Object msg) {]
[+++ b/handler/src/main/java/io/netty/handler/ssl/Java9SslEngine.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/src/assembly/default.xml, + <include>**/Implementation/**</include>, + <include>**/FilesystemBased/**</include>, + <include>**/Common/**</include>, + <include>**/Main/**</include>]
[+++ b/src/docbook/master.xml, + &security;]
[+++ b/codec/src/main/java/io/netty/handler/codec/string/StringEncoder.java, + public StringEncoder() {, + this(Charset.defaultCharset());, + public StringEncoder(Charset charset) {, + if (msg.length() == 0) {, + return;, + }, + switch (ctx.nextOutboundBufferType()) {, + ctx.nextOutboundMessageBuffer().add(Unpooled.wrappedBuffer(encoded));]
[+++ b/pom.xml, + <version>1.2.5.GA</version>, + -overview ${basedir}/src/javadoc/overview.html, + -group "Central interface for all I/O operations" ${project.groupId}.channel*:${project.groupId}.group*, + -group "Client &amp; Server bootstrapping utilities" ${project.groupId}.bootstrap*, + -nopackagediagram, +++ b/pom.xml, + <version>1.2.5.GA</version>, + -overview ${basedir}/src/javadoc/overview.html, + -group "Central interface for all I/O operations" ${project.groupId}.channel*:${project.groupId}.group*, + -group "Client &amp; Server bootstrapping utilities" ${project.groupId}.bootstrap*, + -nopackagediagram, +++ b/src/javadoc/overview.html, +<html>, +<head>, + <title>The Netty Project API Reference</title>, +</head>, +<body>, +<p style="text-align: justify;"><a href="http://www.jboss.org/netty/" target="_top"><em>The Netty project</em></a> is an effort to provide an asynchronous event-driven network application framework and tools for rapid development of maintainable high performance and high scalability protocol servers and clients&#46; In
[+++ b/all/pom.xml, + <version>4.0.3.Final</version>, +++ b/all/pom.xml, + <version>4.0.3.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.3.Final</version>, +++ b/all/pom.xml, + <version>4.0.3.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.3.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.3.Final</version>, +++ b/all/pom.xml, + <version>4.0.3.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.3.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.3.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.3.Final</version>, +++ b/all/pom.xml, + <version>4.0.3.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.3.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.3.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.3.Final</version>, +++ b/codec/pom.xml, + <version>4.0.3.Final</version>, +++ b/all/pom.xml, + <version>4.0.3.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.3.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.3.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.3.Final</version>, +++ b/codec/pom.xml, + <version>4.0.3.Final</version>, +++ b/common/pom.xml, + <version>4.0.3.Final</version>, +++ b/all/pom.xml, + <version>4.0.3.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.3.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.3.Final</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + if (decoder != null) {, + // Clean-up the previous decoder if not cleaned up correctly., + finishDecode(Unpooled.buffer());, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + if (decoder != null) {, + // Clean-up the previous decoder if not cleaned up correctly., + finishDecode(Unpooled.buffer());, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + if (encoder != null) {, + // Clean-up the previous encoder if not cleaned up correctly., + finishEncode(Unpooled.buffer());, + }]
[+++ b/pom.xml, + <version>3.1.0.BETA2-SNAPSHOT</version>]
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsConfigTest.java, + withOrigin("*").preflightResponseHeader("HeaderName", new Object[]{null}).build();]
[+++ b/src/main/resources/META-INF/jboss-beans.xml, + name="org.jboss.netty.channel.socket.nio.NioDatagramChannelFactory", + class="org.jboss.netty.channel.socket.nio.NioDatagramChannelFactory">, + <depends>org.jboss.netty.internal.ChannelFactoryExecutor</depends>, + <constructor>, + <parameter class="java.util.concurrent.Executor">, + <inject bean="org.jboss.netty.internal.ChannelFactoryExecutor"/>, + </parameter>, + </constructor>, + </bean>, +, + <bean mode="On Demand"]
[+++ b/transport/src/main/java/io/netty/channel/Channel.java, +import java.io.IOException;, +import java.net.InetSocketAddress;, +import java.net.SocketAddress;, +import java.nio.channels.NotYetConnectedException;, +import java.nio.channels.SelectionKey;, +, + EventLoop eventLoop();, +, +, + Unsafe unsafe();, +, + public interface Unsafe {, + void setEventLoop(EventLoop eventLoop);, + void clearEventLoop();, + java.nio.channels.Channel ch();, +, + void bind(SocketAddress local) throws IOException;, + void connect(SocketAddress remote) throws IOException;, + boolean finishConnect() throws IOException;, + boolean read() throws IOException;, + boolean write() throws IOException;, + void unbind() throws IOException;, + void disconnect() throws IOException;, + void close() throws IOException;, + }, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +import java.io.IOException;, +import java.net.InetSocketAddress;, +import java.net.SocketAddress;, +import java.nio.channels.NotYetConnectedException;, +import java.nio.channels.SelectionKey;, +, + EventLoop eventLoop();, +,
[+++ b/pom.xml, + <version>3.0.0.CR2-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultThreadFactory.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +import static java.lang.Math.max;, + max(1, SystemPropertyUtil.getInt("io.netty.http2.childrenMapSize", 4));, + /**, + * The minimum stream ID allowed when creating the next stream. This only applies at the time the stream is, + * created. If the ID of the stream being created is less than this value, stream creation will fail. Upon, + * successful creation of a stream, this value is incremented to the next valid stream ID., + */, + private int nextStreamIdToCreate;, + /**, + * Used for reservation of stream IDs. Stream IDs can be reserved in advance by applications before the streams, +
[+++ b/README.md, +- __3__ branch contains code for Netty 3.x, +++ b/README.md, +- __3__ branch contains code for Netty 3.x, +++ b/transport/pom.xml, +++ b/README.md, +- __3__ branch contains code for Netty 3.x, +++ b/transport/pom.xml, +++ /dev/null, +++ b/README.md, +- __3__ branch contains code for Netty 3.x, +++ b/transport/pom.xml, +++ /dev/null, +++ /dev/null, +++ b/README.md, +- __3__ branch contains code for Netty 3.x, +++ b/transport/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/README.md, +- __3__ branch contains code for Netty 3.x, +++ b/transport/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/README.md, +- __3__ branch contains code for Netty
[+++ b/common/src/test/java/io/netty/util/DefaultAttributeMapTest.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/all/pom.xml, +++ b/all/pom.xml, +++ b/pom.xml, + <artifactId>maven-javadoc-plugin</artifactId>, + <version>2.8.1</version>, + </plugin>, + <plugin>]
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + decodeWasNull = !out.insertSinceRecycled();, + fireChannelRead(ctx, out, size);, + /**, + * Get {@code numElements} out of the {@link List} and forward these through the pipeline., + */, + static void fireChannelRead(ChannelHandlerContext ctx, List<Object> msgs, int numElements) {, + for (int i = 0; i < numElements; i ++) {, + ctx.fireChannelRead(msgs.get(i));, + }, + }, +, + fireChannelRead(ctx, out, size);, +, + if (outSize > 0) {, + fireChannelRead(ctx, out, outSize);, + out.clear();, + outSize = 0;, + }, +, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + decodeWasNull = !out.insertSinceRecycled();, + fireChannelRead(ctx, out, size);, + /**, + * Get {@code
[+++ b/example/src/main/java/io/netty/example/localtime/LocalTimeClient.java, + logger.info(String.format("%28s: %s%n", i1.next(), i2.next()));, +++ b/example/src/main/java/io/netty/example/localtime/LocalTimeClient.java, + logger.info(String.format("%28s: %s%n", i1.next(), i2.next()));, +++ b/example/src/main/java/io/netty/example/uptime/UptimeClientHandler.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, + private static final InternalLogger logger =, + InternalLoggerFactory.getInstance(UptimeClientHandler.class);, +, + logger.error(String.format("[SERVER IS DOWN] %s%n", msg));, + logger.error(String.format("[UPTIME: %5ds] %s%n", (System.currentTimeMillis() - startTime) / 1000, msg));]
[+++ b/common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java, + final long startTime = System.nanoTime();, + logger.debug(String.format(, + "-Dio.netty.initialSeedUniquifier: 0x%016x (took %d ms)",, + actualCurrent, TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)));]
[+++ b/all/pom.xml, + <version>4.1.5.Final</version>, +++ b/all/pom.xml, + <version>4.1.5.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.5.Final</version>, +++ b/all/pom.xml, + <version>4.1.5.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.5.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.5.Final</version>, +++ b/all/pom.xml, + <version>4.1.5.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.5.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.5.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.5.Final</version>, +++ b/all/pom.xml, + <version>4.1.5.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.5.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.5.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.5.Final</version>, +++ b/codec-http/pom.xml, + <version>4.1.5.Final</version>, +++ b/all/pom.xml, + <version>4.1.5.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.5.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.5.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.5.Final</version>, +++ b/codec-http/pom.xml, + <version>4.1.5.Final</version>, +++ b/codec-http2/pom.xml, + <version>4.1.5.Final</version>, +++ b/all/pom.xml, + <version>4.1.5.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.5.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.5.Final</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, + * Manages the {@link DnsQueryContext}s in progress and their query IDs., + final DnsQueryContextManager queryContextManager = new DnsQueryContextManager();, + final DnsQueryContext qCtx = queryContextManager.get(res.sender(), queryId);, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, + * Manages the {@link DnsQueryContext}s in progress and their query IDs., + final DnsQueryContextManager queryContextManager = new DnsQueryContextManager();, + final DnsQueryContext qCtx = queryContextManager.get(res.sender(), queryId);, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java, + id = parent.queryContextManager.add(this);, +, + InetSocketAddress nameServerAddr() {, + return nameServerAddr;, + DnsQuestion question() {, + return question;, + final DnsQuestion question = question();, + final InetSocketAddress nameServerAddr = nameServerAddr();, + final DnsResponse res
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, + if (!read) {, + if (!ctx.channel().config().isAutoRead()) {, + ctx.read();, + }, + }, + super.channelReadComplete(ctx);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, + if (!read) {, + if (!ctx.channel().config().isAutoRead()) {, + ctx.read();, + }, + }, + super.channelReadComplete(ctx);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + if (decodeWasNull) {, + if (!ctx.channel().config().isAutoRead()) {, + ctx.fireChannelReadComplete();, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, + if (!read) {, + if (!ctx.channel().config().isAutoRead()) {, + ctx.read();, + }, + }, + super.channelReadComplete(ctx);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + if (decodeWasNull) {, + if (!ctx.channel().config().isAutoRead()) {, + ctx.fireChannelReadComplete();, + }, +++ b/codec/src/test/java/io/netty/handler/codec/ByteToMessageDecoderTest.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, + if (!read) {, + if (!ctx.channel().config().isAutoRead()) {, + ctx.read();, + }, +
[+++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java, + * <li>1 and 2 don't implement {@link ChannelOutboundHandler}, and therefore the actual evaluation order of a]
[+++ b/common/src/test/java/io/netty/util/concurrent/SingleThreadEventExecutorTest.java, + public void testThreadProperties() {]
[+++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + .parentOption(ChannelOption.SO_BACKLOG, 100)]
[+++ b/handler/src/main/java/io/netty/handler/stream/ChunkedByteInput.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java, + private final Map<Integer, FullHttpMessage> messageMap;, + this(version, maxContentLength, new HashMap<Integer, FullHttpMessage>());, + }, +, + /**, + * Creates a new instance with the specified parameters., + *, + * @param version the protocol version, + * @param maxContentLength the maximum length of the message content., + * If the length of the message content exceeds this value,, + * a {@link TooLongFrameException} will be raised., + * @param messageMap the {@link Map} used to hold partially received messages., + */, + protected SpdyHttpDecoder(int version, int maxContentLength, Map<Integer, FullHttpMessage> messageMap) {, + this.messageMap = messageMap;, +
[+++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java]
[+++ b/transport/src/main/java/io/netty/channel/socket/DefaultDatagramChannelConfig.java]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return writerIndex > readerIndex;, +, + if (readerIndex == writerIndex) {, + clear();, + return;, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return writerIndex > readerIndex;, +, + if (readerIndex == writerIndex) {, + clear();, + return;, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return writerIndex > readerIndex;, +, + if (readerIndex == writerIndex) {, + clear();, + return;, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return writerIndex > readerIndex;, +, + if (readerIndex == writerIndex) {, + clear();, + return;, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractDiskHttpData.java, + localfileChannel.force(false);, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +++ b/handler/src/main/java/io/netty/handler/ssl/PemX509Certificate.java, + public byte[] getEncoded() {, + public void checkValidity() {, + public void checkValidity(Date date) {, + public byte[] getTBSCertificate() {, + public void verify(PublicKey key) {, + public void verify(PublicKey key, String sigProvider) {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +++ b/handler/src/main/java/io/netty/handler/ssl/PemX509Certificate.java, + public byte[] getEncoded() {, + public void checkValidity() {, + public void checkValidity(Date date) {, + public byte[] getTBSCertificate() {, + public void verify(PublicKey key) {, + public void verify(PublicKey key, String sigProvider) {, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslServerContext.java, + private static final byte[] ID = {'n', 'e',
[+++ b/.gitignore]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + return directBuffer(DEFAULT_INITIAL_CAPACITY);, + return heapBuffer(DEFAULT_INITIAL_CAPACITY);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + return directBuffer(DEFAULT_INITIAL_CAPACITY);, + return heapBuffer(DEFAULT_INITIAL_CAPACITY);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java, + * Allocate a {@link ByteBuf}, preferably a direct buffer which is suitable for I/O., +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + return directBuffer(DEFAULT_INITIAL_CAPACITY);, + return heapBuffer(DEFAULT_INITIAL_CAPACITY);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java, + * Allocate a {@link ByteBuf}, preferably a direct buffer which is suitable for I/O., +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, + buf = allocateBuffer(ctx, cast, preferDirect);, + * Allocate a {@link ByteBuf} which will be used as argument of {@link #encode(ChannelHandlerContext, I, ByteBuf)}., + * Sub-classes may override this method to returna {@link ByteBuf} with a perfect matching {@code
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java, + * Be aware this <strong>won't</strong> be called with timeout / cancel / transport exceptions., + *, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java, + * Be aware this <strong>won't</strong> be called with timeout / cancel / transport exceptions., + *, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, + /**, + * Returns {@code true} if the {@link Throwable} was caused by an timeout or transport error., + * These methods can be used on the {@link Future#cause()} that is returned by the various methods exposed by this, + * {@link DnsNameResolver}., + */, + public static boolean isTransportOrTimeoutError(Throwable cause) {, + return cause != null &&
[+++ b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpResponseDecoder.java, + if (detail == null) {, + details = Collections.emptyList();, + } else {, + }, +++ b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpResponseDecoder.java, + if (detail == null) {, + details = Collections.emptyList();, + } else {, + }, +++ b/codec-smtp/src/test/java/io/netty/handler/codec/smtp/SmtpResponseDecoderTest.java, + public void testDecodeOneLineResponseNoDetails() {, + EmbeddedChannel channel = newChannel();, + assertTrue(channel.writeInbound(newBuffer("250 \r\n")));, + assertTrue(channel.finish());, +, + SmtpResponse response = channel.readInbound();, + assertEquals(250, response.code());, + List<CharSequence> sequences = response.details();, + assertEquals(0, sequences.size());, + }, +, + @Test]
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, +++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, +++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, +++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java]
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jlong JNICALL Java_io_netty_channel_epoll_Native_sendfile0(JNIEnv *env, jclass clazz, jint fd, jobject fileRegion, jlong base_off, jlong off, jlong len) {, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jlong JNICALL Java_io_netty_channel_epoll_Native_sendfile0(JNIEnv *env, jclass clazz, jint fd, jobject fileRegion, jlong base_off, jlong off, jlong len) {, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +jlong Java_io_netty_channel_epoll_Native_sendfile0(JNIEnv *env, jclass clazz, jint fd, jobject fileRegion, jlong base_off, jlong off, jlong len);, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jlong JNICALL Java_io_netty_channel_epoll_Native_sendfile0(JNIEnv *env, jclass clazz, jint fd, jobject fileRegion, jlong base_off, jlong off, jlong len) {, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +jlong Java_io_netty_channel_epoll_Native_sendfile0(JNIEnv *env, jclass clazz, jint fd, jobject fileRegion, jlong base_off, jlong off, jlong len);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java, + public static
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + writerIndex(markedWriterIndex);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + writerIndex(markedWriterIndex);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +, + @Test(expected = IndexOutOfBoundsException.class), + public void testReaderIndexLargerThanWriterIndex() {, + String content1 = "hello";, + String content2 = "world";, + int length = content1.length() + content2.length();, + ByteBuf buffer = newBuffer(length);, + buffer.setIndex(0, 0);, + buffer.writeCharSequence(content1, CharsetUtil.US_ASCII);, + buffer.markWriterIndex();, + buffer.skipBytes(content1.length());, + buffer.writeCharSequence(content2, CharsetUtil.US_ASCII);, + buffer.skipBytes(content2.length());, + assertTrue(buffer.readerIndex() <= buffer.writerIndex());, +, + try {, + buffer.resetWriterIndex();, + } finally {, + buffer.release();, + }, + }]
[+++ b/pom.xml, + <groupId>org.jmock</groupId>, + <artifactId>jmock-junit4</artifactId>, + <version>2.5.1</version>, + <scope>test</scope>, + </dependency>, + <dependency>, + <forkMode>once</forkMode>, +++ b/pom.xml, + <groupId>org.jmock</groupId>, + <artifactId>jmock-junit4</artifactId>, + <version>2.5.1</version>, + <scope>test</scope>, + </dependency>, + <dependency>, + <forkMode>once</forkMode>, +++ b/src/main/java/org/jboss/netty/channel/socket/httptunnel/AcceptedServerChannelPipelineFactory.java, +/*, + * Copyright 2009 Red Hat, Inc., + *, + * Red Hat licenses this file to you under the Apache License, version 2.0, + * (the "License"); you may not use this file except in compliance with the, + * License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable
[+++ b/pom.xml, + <version>3.0.1.GA</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.0.1.GA</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.0.1.GA</developerConnection>]
[+++ b/transport/src/main/java/io/netty/channel/ChannelInboundHandlerAdapter.java, + /**, + * Calls {@link ChannelHandlerContext#fireChannelReadComplete()} to forward, + * to the next {@link ChannelInboundHandler} in the {@link ChannelPipeline}., + *, + * Sub-classes may override this method to change behavior., + */, +++ b/transport/src/main/java/io/netty/channel/ChannelInboundHandlerAdapter.java, + /**, + * Calls {@link ChannelHandlerContext#fireChannelReadComplete()} to forward, + * to the next {@link ChannelInboundHandler} in the {@link ChannelPipeline}., + *, + * Sub-classes may override this method to change behavior., + */, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundHandler.java, + /**, + * Called once a write operation is made. The write operation will write the messages through the, + * {@link ChannelPipeline}. Those
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractMessageBuf.java, +import io.netty.util.internal.PlatformDependent;, +, +import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;, + @SuppressWarnings("rawtypes"), + private static final AtomicIntegerFieldUpdater<AbstractMessageBuf> refCntUpdater =, + AtomicIntegerFieldUpdater.newUpdater(AbstractMessageBuf.class, "refCnt");, +, + private static final long REFCNT_FIELD_OFFSET;, +, + static {, + long refCntFieldOffset = -1;, + try {, + if (PlatformDependent.hasUnsafe()) {, + refCntFieldOffset = PlatformDependent.objectFieldOffset(AbstractMessageBuf.class.getDeclaredField("refCnt"));, + }, + } catch (Throwable ignored) { }, +, + REFCNT_FIELD_OFFSET = refCntFieldOffset;, + }, +, +, + @SuppressWarnings("FieldMayBeFinal"), + private volatile int refCnt = 1;, + if (REFCNT_FIELD_OFFSET >= 0) {, + // Try to do non-volatile read for performance., + return PlatformDependent.getInt(this, REFCNT_FIELD_OFFSET);, + } else {, + }, +
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketDataReadInitialStateTest.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, + private static final ByteBuf CRLF_BUF = unreleasableBuffer(directBuffer(CRLF.length).writeBytes(CRLF));]
[+++ b/src/docbook/en-US/module/start.xml, + bootstrap.setPipelineFactory(new &ChannelPipelineFactory;() {<co id="example.discard2.co3" />, + public &ChannelPipeline; getPipeline() {, + return &Channels;.pipeline(new DiscardServerHandler());<co id="example.discard2.co4" />, + }, + });, + bootstrap.setOption("child.tcpNoDelay", true);<co id="example.discard2.co5" />, + bootstrap.bind(new InetSocketAddress(8080));<co id="example.discard2.co6" />, + Here, we configure the &ChannelPipelineFactory;. Whenever a new, + connection is accepted by the server, a new &ChannelPipeline; will be, + created by the specified &ChannelPipelineFactory;. The new pipeline, + contains the <classname>DiscardServerHandler</classname>. As the, + application gets complicated, it is likely that you will add more, + handlers to the pipeline and extract this anonymous class into a top, + level class eventually., +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/pom.xml, + <excludes>, + <!-- Exclude sctp from build for now -->, + <!-- See: https://github.com/netty/netty/issues/120 -->, + <exclude>**/sctp/*.java</exclude>, + </excludes>, +++ b/pom.xml, + <excludes>, + <!-- Exclude sctp from build for now -->, + <!-- See: https://github.com/netty/netty/issues/120 -->, + <exclude>**/sctp/*.java</exclude>, + </excludes>, +++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, + boolean success = false;, + try {, + success = true;, + } finally {, + if (!success) {, + ch.close();, + }, + }, +++ b/pom.xml, + <excludes>, + <!-- Exclude sctp from build for now -->, + <!-- See: https://github.com/netty/netty/issues/120 -->, + <exclude>**/sctp/*.java</exclude>, + </excludes>, +++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, + boolean success
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, + WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, + WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, + WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, + WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, + WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java, + WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, + WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, + WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java, + WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java, + WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());]
[+++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java, + return (ByteBuffer) buffer.duplicate().position(index).limit(index + length);, +++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java, + return (ByteBuffer) buffer.duplicate().position(index).limit(index + length);, +++ b/buffer/src/test/java/io/netty/buffer/ReadOnlyDirectByteBufferBufTest.java, +, + @Test, + public void testWrapBufferRoundTrip() {, + ByteBuf buf = buffer(((ByteBuffer) allocate(16).putInt(1).putInt(2).flip()).asReadOnlyBuffer());, + buffers.add(buf);, +, + Assert.assertEquals(1, buf.readInt());, +, + ByteBuffer nioBuffer = buf.nioBuffer();, +, + // Ensure this can be accessed without throwing a BufferUnderflowException, + Assert.assertEquals(2, nioBuffer.getInt());, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoder.java, + private ByteBuf cumulation;, +, + if (cumulation == null) {, + decodeHeaderBlock(headerBlock, frame);, + if (headerBlock.isReadable()) {, + cumulation = headerBlock.alloc().buffer(headerBlock.readableBytes());, + cumulation.writeBytes(headerBlock);, + }, + } else {, + cumulation.writeBytes(headerBlock);, + decodeHeaderBlock(cumulation, frame);, + if (cumulation.isReadable()) {, + cumulation.discardReadBytes();, + } else {, + cumulation = null;, + }, + }, + }, +, + protected void decodeHeaderBlock(ByteBuf headerBlock, SpdyHeadersFrame frame) throws Exception {, +, + releaseBuffer();, +, + releaseBuffer();, + }, +, + private void releaseBuffer() {, + if (cumulation != null) {, + cumulation.release();, + cumulation = null;, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoder.java, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;, +, + while (numHeaders -- > 0) {, + if (valueLength < 0) {, +, + // SPDY/3 allows zero-length (empty) header values, + if (valueLength == 0) {, + if (version < 3) {, + spdyHeaderBlock.setInvalid();, + return;, + } else {, + spdyHeaderBlock.addHeader(name, "");, + this.headerSize = headerSize;, + continue;, + }, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;, +, + while (numHeaders -- > 0) {, + if (valueLength < 0) {, +, + // SPDY/3 allows zero-length (empty) header values, + if (valueLength
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, + write(ctx, succeededFuture(ctx.channel()), CONTINUE.duplicate());, + m.setContent(ChannelBuffers.dynamicBuffer(e.channel().getConfig().getBufferFactory()));, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, + write(ctx, succeededFuture(ctx.channel()), CONTINUE.duplicate());, + m.setContent(ChannelBuffers.dynamicBuffer(e.channel().getConfig().getBufferFactory()));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + this(4096, 8192, 8192);, + return super.encode(ctx, channel, msg);, + return super.decode(ctx, channel, buffer, state);, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, + write(ctx, succeededFuture(ctx.channel()), CONTINUE.duplicate());, + m.setContent(ChannelBuffers.dynamicBuffer(e.channel().getConfig().getBufferFactory()));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + this(4096, 8192, 8192);, + return super.encode(ctx, channel, msg);, + return super.decode(ctx, channel, buffer, state);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + ctx, Channels.succeededFuture(e.channel()), new DefaultHttpChunk(lastProduct), e.getRemoteAddress());, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++
[+++ b/src/docbook/module/architecture.xml, + create a new big buffer and copy the two parts into the new, + as an array of <classname>ByteBuffer</classname>s rather than a]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + return NetUtil.toSocketAddressString(host, port);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + return NetUtil.toSocketAddressString(host, port);, +++ b/common/src/main/java/io/netty/util/NetUtil.java, + host, portStr, !isValidIpV6Address(host)).append(':').append(portStr).toString();]
[+++ b/buffer/src/main/java/io/netty/buffer/SimpleLeakAwareByteBuf.java, + // Update the parent to point to this buffer so we correctly close the ResourceLeakTracker., + ((AbstractPooledDerivedByteBuf) unwrappedDerived).parent(this);, +, + return newLeakAwareByteBuf(derived, newLeak);]
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslUtils.java, + * HeartBeat Extension, + */, + static final int SSL_CONTENT_TYPE_EXTENSION_HEARTBEAT = 24;, +, + /**, + case SSL_CONTENT_TYPE_EXTENSION_HEARTBEAT:, + case SSL_CONTENT_TYPE_EXTENSION_HEARTBEAT:]
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + return pipeline.bind(localAddress);, + return pipeline.connect(remoteAddress);, + return pipeline.connect(remoteAddress, localAddress);, + return pipeline.disconnect();, + return pipeline.close();, + return pipeline.deregister();, + return pipeline.flush();, + return pipeline.write(message);, + return pipeline.bind(localAddress, future);, + return pipeline.connect(remoteAddress, future);, + return pipeline.connect(remoteAddress, localAddress, future);, + return pipeline.disconnect(future);, + return pipeline.close(future);, + return pipeline.deregister(future);, + return pipeline.outboundByteBuffer();, + return pipeline.outboundMessageBuffer();, + return pipeline.flush(future);, + pipeline.fireChannelRegistered();, + pipeline.fireChannelActive();, + pipeline.fireExceptionCaught(t);, + pipeline.fireChannelActive();, + pipeline.fireExceptionCaught(t);, + pipeline.fireChannelInactive();, + pipeline.fireChannelInactive();, + pipeline.fireChannelUnregistered();, + pipeline.fireExceptionCaught(t);, + pipeline.fireExceptionCaught(cause);, + pipeline.fireExceptionCaught(e);, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + return pipeline.bind(localAddress);, + return pipeline.connect(remoteAddress);, + return pipeline.connect(remoteAddress, localAddress);, + return pipeline.disconnect();, + return pipeline.close();, +
[+++ b/src/docbook/en-US/module/start.xml, + As you read, you might have more questions about the classes introduced, + in this chapter. Please refer to the API reference whenever you want to, + know more about them. All class names in this document are linked to the, + online API reference for your convenience. Also, please don't hesitate to]
[+++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java, + value = value.trim();, + value = value.trim();]
[+++ b/all/pom.xml, + <version>4.0.0.CR4-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR4-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR4-SNAPSHOT</version>, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return ByteBufUtil.decodeString(nioBuffer, charset);, + return ByteBufUtil.indexOf(this, fromIndex, toIndex, value);, + return ByteBufUtil.indexOf(this, fromIndex, toIndex, indexFinder);, + return ByteBufUtil.hashCode(this);, + return ByteBufUtil.equals(this, (ByteBuf) o);, + return ByteBufUtil.compare(this, that);, +++ b/all/pom.xml, + <version>4.0.0.CR4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR4-SNAPSHOT</version>, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return ByteBufUtil.decodeString(nioBuffer, charset);, + return ByteBufUtil.indexOf(this, fromIndex, toIndex, value);, + return ByteBufUtil.indexOf(this, fromIndex, toIndex, indexFinder);, + return ByteBufUtil.hashCode(this);, + return ByteBufUtil.equals(this, (ByteBuf) o);, + return ByteBufUtil.compare(this, that);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, +++ b/all/pom.xml, + <version>4.0.0.CR4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR4-SNAPSHOT</version>, +++
[+++ b/common/src/main/java/io/netty/util/internal/logging/Log4J2Logger.java, +import org.apache.logging.log4j.Level;, +import org.apache.logging.log4j.Logger;, +import org.apache.logging.log4j.spi.ExtendedLogger;, +import org.apache.logging.log4j.spi.ExtendedLoggerWrapper;, +, +class Log4J2Logger extends ExtendedLoggerWrapper implements InternalLogger {, + /** {@linkplain AbstractInternalLogger#EXCEPTION_MESSAGE} */, + private static final String EXCEPTION_MESSAGE = "Unexpected exception:";, + super((ExtendedLogger) logger, logger.getName(), logger.getMessageFactory());, + public String name() {, + return getName();, + public void trace(Throwable t) {, + log(Level.TRACE, EXCEPTION_MESSAGE, t);, + public void debug(Throwable t) {, + log(Level.DEBUG, EXCEPTION_MESSAGE, t);, + public void info(Throwable t) {, + log(Level.INFO, EXCEPTION_MESSAGE, t);, + public void warn(Throwable t) {, + log(Level.WARN, EXCEPTION_MESSAGE, t);, + public void error(Throwable t) {, + log(Level.ERROR, EXCEPTION_MESSAGE, t);, + public boolean isEnabled(InternalLogLevel
[+++ b/example/pom.xml, + <groupId>${conscrypt.groupId}</groupId>, + <artifactId>${conscrypt.artifactId}</artifactId>, + <classifier>${conscrypt.classifier}</classifier>, + </dependency>, + <dependency>, +++ b/example/pom.xml, + <groupId>${conscrypt.groupId}</groupId>, + <artifactId>${conscrypt.artifactId}</artifactId>, + <classifier>${conscrypt.classifier}</classifier>, + </dependency>, + <dependency>, +++ b/handler/pom.xml, + <groupId>${conscrypt.groupId}</groupId>, + <artifactId>${conscrypt.artifactId}</artifactId>, + <classifier>${conscrypt.classifier}</classifier>, + </dependency>, + <dependency>, +++ b/example/pom.xml, + <groupId>${conscrypt.groupId}</groupId>, + <artifactId>${conscrypt.artifactId}</artifactId>, + <classifier>${conscrypt.classifier}</classifier>, + </dependency>, + <dependency>, +++ b/handler/pom.xml, + <groupId>${conscrypt.groupId}</groupId>, + <artifactId>${conscrypt.artifactId}</artifactId>, + <classifier>${conscrypt.classifier}</classifier>, + </dependency>, + <dependency>, +++ b/handler/src/main/java/io/netty/handler/ssl/ConscryptAlpnSslEngine.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except
[+++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + @Test(timeout = 10000), +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + @Test(timeout = 10000), +++ b/codec/src/main/java/io/netty/handler/codec/StreamToMessageDecoder.java, + if (!ctx.executor().inEventLoop()) {, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + @Test(timeout = 10000), +++ b/codec/src/main/java/io/netty/handler/codec/StreamToMessageDecoder.java, + if (!ctx.executor().inEventLoop()) {, +++ b/codec/src/main/java/io/netty/handler/codec/embedder/DecoderEmbedder.java, + if (input instanceof ChannelBuffer) {, + pipeline().inboundByteBuffer().writeBytes((ChannelBuffer) input);, + pipeline().inboundMessageBuffer().add(input);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + @Test(timeout = 10000), +++ b/codec/src/main/java/io/netty/handler/codec/StreamToMessageDecoder.java, + if (!ctx.executor().inEventLoop()) {, +++ b/codec/src/main/java/io/netty/handler/codec/embedder/DecoderEmbedder.java, + if (input instanceof ChannelBuffer) {, + pipeline().inboundByteBuffer().writeBytes((ChannelBuffer) input);, + pipeline().inboundMessageBuffer().add(input);, +++ b/codec/src/main/java/io/netty/handler/codec/embedder/EmbeddedEventLoop.java, +import io.netty.channel.EventExecutor;, + EventLoop, EventExecutor.Unsafe {, +, + @Override, + public EventLoop parent() {, + return null;, + }, +, + @Override, + public Unsafe unsafe() {, + return
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpHeadersTest.java, +import static org.hamcrest.CoreMatchers.is;, +import static org.junit.Assert.assertThat;, +, +, + @Test, + public void testEquansIgnoreCase() {, + assertThat(HttpHeaders.equalsIgnoreCase(null, null), is(true));, + assertThat(HttpHeaders.equalsIgnoreCase(null, "foo"), is(false));, + assertThat(HttpHeaders.equalsIgnoreCase("bar", null), is(false));, + assertThat(HttpHeaders.equalsIgnoreCase("FoO", "fOo"), is(true));, + }]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, + private long pendingBytes;, + return windowSize() > pendingBytes() && !cancelled;, + public long pendingBytes() {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, + private long pendingBytes;, + return windowSize() > pendingBytes() && !cancelled;, + public long pendingBytes() {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, + return max(0, (int) min(state.pendingBytes(), state.windowSize()));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, + private long pendingBytes;, + return windowSize() > pendingBytes() && !cancelled;, + public long pendingBytes() {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, + return max(0, (int) min(state.pendingBytes(), state.windowSize()));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/StreamByteDistributor.java, + long pendingBytes();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, + private long pendingBytes;, + return windowSize() > pendingBytes() && !cancelled;, + public long pendingBytes() {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, + return max(0, (int)
[+++ b/pom.xml, + -group "Miscellaneous" ${project.groupId}.logging* ${project.groupId}.group*]
[+++ b/handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java, + } catch (NotSslRecordException e) {, + // Just rethrow as in this case we also closed the channel and this is consistent with SslHandler., + throw e;, + } catch (Exception e) {, +++ b/handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java, + } catch (NotSslRecordException e) {, + // Just rethrow as in this case we also closed the channel and this is consistent with SslHandler., + throw e;, + } catch (Exception e) {, +++ b/handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java, + public void testNonSslRecord() throws Exception {, + SslContext nettyContext = makeSslContext(provider, false);, + try {, + final AtomicReference<SslHandshakeCompletionEvent> evtRef =, + new AtomicReference<SslHandshakeCompletionEvent>();, +
[+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponse.java, +import io.netty.util.CharsetUtil;, +import io.netty.util.NetUtil;, +, +import java.net.IDN;, + * A socks cmd response., + private final String host;, + private final int port;, +, + private static final byte[] DOMAIN_ZEROED = {0x00};, + this(cmdStatus, addressType, null, 0);, + }, +, + /**, + * Constructs new response and includes provided host and port as part of it., + *, + * @param cmdStatus status of the response, + * @param addressType type of host parameter, + * @param host host (BND.ADDR field) is address that server used when connecting to the target host., + * When null
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2ConnectionDecoder.java, + public void frameListener(Http2FrameListener listener) {, + delegate.frameListener(listener);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2ConnectionDecoder.java, + public void frameListener(Http2FrameListener listener) {, + delegate.frameListener(listener);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + private Http2FrameListener listener;, + Http2FrameReader frameReader) {, + this(connection, encoder, frameReader, ALWAYS_VERIFY);, + public void frameListener(Http2FrameListener listener) {, + this.listener = checkNotNull(listener, "listener");, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2ConnectionDecoder.java, + public void frameListener(Http2FrameListener listener) {, + delegate.frameListener(listener);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + private Http2FrameListener listener;, + Http2FrameReader frameReader) {, + this(connection, encoder, frameReader, ALWAYS_VERIFY);, + public void frameListener(Http2FrameListener listener) {, + this.listener = checkNotNull(listener, "listener");, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionDecoder.java, + * Set the {@link Http2FrameListener} which will be notified when frames are decoded., +
[+++ b/common/src/main/java/io/netty/util/UniqueName.java, +++ b/common/src/main/java/io/netty/util/UniqueName.java, +++ b/pom.xml, +++ b/common/src/main/java/io/netty/util/UniqueName.java, +++ b/pom.xml, +++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, +++ b/common/src/main/java/io/netty/util/UniqueName.java, +++ b/pom.xml, +++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannel.java, + private final AioEventLoopGroup childGroup;, + public AioServerSocketChannel(AioEventLoopGroup group) {, + this(group, group);, + }, +, + public AioServerSocketChannel(AioEventLoopGroup parentGroup, AioEventLoopGroup childGroup) {, + super(null, null, parentGroup, newSocket(parentGroup.group));, + this.childGroup = childGroup;, + this.config = new AioServerSocketChannelConfig(javaChannel());, + new AioSocketChannel(channel, null, channel.childGroup, ch));, +++ b/common/src/main/java/io/netty/util/UniqueName.java, +++ b/pom.xml, +++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannel.java, + private final AioEventLoopGroup childGroup;, + public AioServerSocketChannel(AioEventLoopGroup group) {, + this(group, group);, + }, +, + public AioServerSocketChannel(AioEventLoopGroup parentGroup, AioEventLoopGroup childGroup) {, + super(null, null, parentGroup, newSocket(parentGroup.group));,
[+++ b/common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java, + // Restore the interrupt status because we don't know how to/don't need to handle it here., +, + // Interrupt the generator thread if it's still running,, + // in the hope that the SecureRandom provider raises an exception on interruption., + generatorThread.interrupt();]
[+++ b/pom.xml, + <version>3.2.0.ALPHA4-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoderTest.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/all/pom.xml, + <version>4.0.0.CR8</version>, +++ b/all/pom.xml, + <version>4.0.0.CR8</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR8</version>, +++ b/all/pom.xml, + <version>4.0.0.CR8</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR8</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR8</version>, +++ b/all/pom.xml, + <version>4.0.0.CR8</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR8</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR8</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR8</version>, +++ b/all/pom.xml, + <version>4.0.0.CR8</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR8</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR8</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR8</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR8</version>, +++ b/all/pom.xml, + <version>4.0.0.CR8</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR8</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR8</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR8</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR8</version>, +++ b/common/pom.xml, + <version>4.0.0.CR8</version>, +++ b/all/pom.xml, + <version>4.0.0.CR8</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR8</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR8</version>, +++ b/codec-socks/pom.xml, +
[+++ b/pom.xml, + <version>3.2.2.Final-SNAPSHOT</version>, + <url>http://fisheye.jboss.org/browse/Netty</url>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/codec/pom.xml, + <dependency>, + <groupId>org.jboss.marshalling</groupId>, + <artifactId>jboss-marshalling</artifactId>, + <optional>true</optional>, + </dependency>, + , + <!-- Test dependencies for jboss marshalling encoder/decoder -->, + <dependency>, + <groupId>org.jboss.marshalling</groupId>, + <artifactId>jboss-marshalling-serial</artifactId>, + <scope>test</scope>, + </dependency>, + <dependency>, + <groupId>org.jboss.marshalling</groupId>, + <artifactId>jboss-marshalling-river</artifactId>, + <scope>test</scope>, + </dependency>, +++ b/codec/pom.xml, + <dependency>, + <groupId>org.jboss.marshalling</groupId>, + <artifactId>jboss-marshalling</artifactId>, + <optional>true</optional>, + </dependency>, + , + <!-- Test dependencies for jboss marshalling encoder/decoder -->, + <dependency>, + <groupId>org.jboss.marshalling</groupId>, + <artifactId>jboss-marshalling-serial</artifactId>, + <scope>test</scope>, + </dependency>, + <dependency>, + <groupId>org.jboss.marshalling</groupId>, + <artifactId>jboss-marshalling-river</artifactId>, + <scope>test</scope>, + </dependency>, +++ b/codec/src/main/java/io/netty/handler/codec/marshalling/ChannelBufferByteInput.java, +/*, + * Copyright 2012 The Netty Project, + *, +
[+++ b/codec/src/main/java/io/netty/handler/codec/embedder/DecoderEmbedder.java, +import io.netty.channel.NoSuchBufferException;, + try {, + } catch (NoSuchBufferException e) {, + // Throwing and catching this exception is cheap because we do not fill, + // stack traces internally (see DefaultChannelPipeline)., + pipeline().inboundMessageBuffer().add(input);, + }, +++ b/codec/src/main/java/io/netty/handler/codec/embedder/DecoderEmbedder.java, +import io.netty.channel.NoSuchBufferException;, + try {, + } catch (NoSuchBufferException e) {, + // Throwing and catching this exception is cheap because we do not fill, + // stack traces internally (see DefaultChannelPipeline)., + pipeline().inboundMessageBuffer().add(input);, + }, +++ b/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingDecoderTest.java]
[+++ b/NOTICE.txt]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpVersion.java, +, + if (text.isEmpty()) {, + throw new IllegalArgumentException("text is empty");, + }, +, +]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Lz4FrameEncoder.java, +import static io.netty.handler.codec.compression.Lz4Constants.BLOCK_TYPE_COMPRESSED;, +import static io.netty.handler.codec.compression.Lz4Constants.BLOCK_TYPE_NON_COMPRESSED;, +import static io.netty.handler.codec.compression.Lz4Constants.CHECKSUM_OFFSET;, +import static io.netty.handler.codec.compression.Lz4Constants.COMPRESSED_LENGTH_OFFSET;, +import static io.netty.handler.codec.compression.Lz4Constants.COMPRESSION_LEVEL_BASE;, +import static io.netty.handler.codec.compression.Lz4Constants.DECOMPRESSED_LENGTH_OFFSET;, +import static io.netty.handler.codec.compression.Lz4Constants.DEFAULT_BLOCK_SIZE;, +import static io.netty.handler.codec.compression.Lz4Constants.DEFAULT_SEED;, +import static io.netty.handler.codec.compression.Lz4Constants.HEADER_LENGTH;, +import static io.netty.handler.codec.compression.Lz4Constants.MAGIC_NUMBER;, +import static io.netty.handler.codec.compression.Lz4Constants.MAX_BLOCK_SIZE;, +import static io.netty.handler.codec.compression.Lz4Constants.MIN_BLOCK_SIZE;, +import static io.netty.handler.codec.compression.Lz4Constants.TOKEN_OFFSET;, +import static io.netty.util.internal.ThrowableUtil.unknownStackTrace;, + private static final EncoderException ENCODE_FINSHED_EXCEPTION = unknownStackTrace(new EncoderException(, + new IllegalStateException("encode finished and not enough space to write remaining data")),, + Lz4FrameEncoder.class, "encode");, + private final LZ4Compressor compressor;, + private final ByteBufChecksum checksum;, + if (!out.isWritable(in.readableBytes())) {, + // out should be EMPTY_BUFFER because we should have allocated enough space above in allocateBuffer., +
[+++ b/all/pom.xml, + <skipJapicmp>true</skipJapicmp>, +++ b/all/pom.xml, + <skipJapicmp>true</skipJapicmp>, +++ b/codec-http/pom.xml, +++ b/all/pom.xml, + <skipJapicmp>true</skipJapicmp>, +++ b/codec-http/pom.xml, +++ b/example/pom.xml, + <properties>, + <skipJapicmp>true</skipJapicmp>, + </properties>, +++ b/all/pom.xml, + <skipJapicmp>true</skipJapicmp>, +++ b/codec-http/pom.xml, +++ b/example/pom.xml, + <properties>, + <skipJapicmp>true</skipJapicmp>, + </properties>, +++ b/handler-proxy/src/main/java/io/netty/handler/proxy/HttpProxyHandler.java, + protected boolean handleResponse(ChannelHandlerContext ctx, Object response) throws Exception {, +++ b/all/pom.xml, + <skipJapicmp>true</skipJapicmp>, +++ b/codec-http/pom.xml, +++ b/example/pom.xml, + <properties>, + <skipJapicmp>true</skipJapicmp>, + </properties>, +++ b/handler-proxy/src/main/java/io/netty/handler/proxy/HttpProxyHandler.java, + protected boolean handleResponse(ChannelHandlerContext ctx, Object response) throws Exception {, +++ b/microbench/pom.xml, + <skipJapicmp>true</skipJapicmp>, +++ b/all/pom.xml, + <skipJapicmp>true</skipJapicmp>, +++ b/codec-http/pom.xml, +++ b/example/pom.xml, + <properties>, + <skipJapicmp>true</skipJapicmp>, + </properties>, +++ b/handler-proxy/src/main/java/io/netty/handler/proxy/HttpProxyHandler.java, + protected boolean
[+++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, + * <pre> public class MyDecoder extends {@link ReplayingDecoder}&lt;{@link Void}&gt; {, + * public void decode(.., {@link ByteBuf} in, {@link MessageList} out) throws Exception {, + * out.add(values.poll() + values.poll());, + * <pre> public class MyDecoder extends {@link ReplayingDecoder}&lt;{@link Void}&gt; {, + * public void decode(.., {@link ByteBuf} buffer, {@link MessageList} out) throws Exception {, + * out.add(values.poll() + values.poll());, + * protected void decode({@link ChannelHandlerContext} ctx,, + * {@link ByteBuf} in, {@link MessageList} out) throws Exception {, + * out.add(frame);, + * protected void decode({@link ChannelHandlerContext} ctx,, + * {@link ByteBuf} in, {@link MessageList} out) throws
[+++ b/all/pom.xml, + <excludes>io/netty/internal/tcnative/**,io/netty/example/**,META-INF/native/libnetty-tcnative*,META-INF/native/include/**,META-INF/native/**/*.a</excludes>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshakeHandler.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerInitializer.java, + //pipeline.addLast("aggregator", new HttpObjectAggregator(1048576));]
[+++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java, + sendListing(ctx, file, uri);, + private static void sendListing(ChannelHandlerContext ctx, File dir, String dirPath) {]
[+++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +import java.util.LinkedHashMap;, + private volatile EventLoopGroup group;, + private volatile ChannelFactory<? extends C> channelFactory;, + private volatile SocketAddress localAddress;, + private final Map<ChannelOption<?>, Object> options = new LinkedHashMap<ChannelOption<?>, Object>();, + private final Map<AttributeKey<?>, Object> attrs = new LinkedHashMap<AttributeKey<?>, Object>();, + private volatile ChannelHandler handler;, + synchronized (bootstrap.options) {, + }, + synchronized (bootstrap.attrs) {, + }, + synchronized (options) {, + }, + synchronized (options) {, + }, + synchronized (attrs) {, + }, + synchronized (attrs) {, + }, + synchronized (options) {, + if (!options.isEmpty()) {, + }, + synchronized (attrs) {, + if (!attrs.isEmpty())
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySynStreamFrame.java, + private int streamId;, + private int associatedToStreamId;, + * @param streamId the Stream-ID of this frame, + * @param associatedToStreamId the Associated-To-Stream-ID of this frame, + int streamId, int associatedToStreamId, byte priority) {, + setStreamId(streamId);, + setAssociatedToStreamId(associatedToStreamId);, + public int getStreamId() {, + return streamId;, + public void setStreamId(int streamId) {, + if (streamId <= 0) {, + "Stream-ID must be positive: " + streamId);, + this.streamId = streamId;, + public int getAssociatedToStreamId() {, + return associatedToStreamId;, + public void setAssociatedToStreamId(int associatedToStreamId) {, + if (associatedToStreamId < 0) {, + associatedToStreamId);, + this.associatedToStreamId = associatedToStreamId;, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, +import java.util.Map.Entry;, +import java.util.NoSuchElementException;, + return new HeaderIterator();, + private final class HeaderIterator implements Iterator<Map.Entry<String, String>> {, +, + private HeaderEntry current = head;, +, + @Override, + public boolean hasNext() {, + return current.after != head;, + }, +, + @Override, + public Entry<String, String> next() {, + current = current.after;, +, + if (current == head) {, + throw new NoSuchElementException();, + }, +, + return current;, + }, +, + @Override, + public void remove() {, + throw new UnsupportedOperationException();, + }, + }, +, + private final class HeaderEntry implements Map.Entry<String, String> {,
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.ByteBufAllocator;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.handler.codec.http2.Http2FrameReader.Configuration;, +, +import static io.netty.handler.codec.http2.Http2CodecUtil.PING_FRAME_PAYLOAD_LENGTH;, + if (payloadLength != PING_FRAME_PAYLOAD_LENGTH) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.ByteBufAllocator;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.handler.codec.http2.Http2FrameReader.Configuration;, +, +import static io.netty.handler.codec.http2.Http2CodecUtil.PING_FRAME_PAYLOAD_LENGTH;, + if (payloadLength != PING_FRAME_PAYLOAD_LENGTH) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, +import io.netty.buffer.ByteBuf;, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelPromise;, +import io.netty.handler.codec.http2.Http2CodecUtil.SimpleChannelPromiseAggregator;, +import io.netty.handler.codec.http2.Http2FrameWriter.Configuration;, +, +import static io.netty.handler.codec.http2.Http2CodecUtil.PING_FRAME_PAYLOAD_LENGTH;, + verifyPingPayload(data);, +, + private static void verifyPingPayload(ByteBuf data) {, + if (data == null || data.readableBytes() != PING_FRAME_PAYLOAD_LENGTH) {, + throw new IllegalArgumentException("Opaque data must be " + PING_FRAME_PAYLOAD_LENGTH + " bytes");, + }, + }]
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + int size = out.size();, + if (size == 0) {, + } else {, + for (int i = 0; i < size; i ++) {, + }, + int size = out.size();, + for (int i = 0; i < size; i ++) {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + int size = out.size();, + if (size == 0) {, + } else {, + for (int i = 0; i < size; i ++) {, + }, + int size = out.size();, + for (int i = 0; i < size; i ++) {, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, +
[+++ b/common/src/main/java/io/netty/util/internal/logging/LocationAwareSlf4JLogger.java, + log(TRACE_INT, org.slf4j.helpers.MessageFormatter.arrayFormat(format, argArray));, + log(DEBUG_INT, org.slf4j.helpers.MessageFormatter.arrayFormat(format, argArray));, + log(INFO_INT, org.slf4j.helpers.MessageFormatter.arrayFormat(format, argArray));, + log(WARN_INT, org.slf4j.helpers.MessageFormatter.arrayFormat(format, argArray));, + log(ERROR_INT, org.slf4j.helpers.MessageFormatter.arrayFormat(format, argArray));, +++ b/common/src/main/java/io/netty/util/internal/logging/LocationAwareSlf4JLogger.java, + log(TRACE_INT, org.slf4j.helpers.MessageFormatter.arrayFormat(format, argArray));, + log(DEBUG_INT, org.slf4j.helpers.MessageFormatter.arrayFormat(format, argArray));, + log(INFO_INT, org.slf4j.helpers.MessageFormatter.arrayFormat(format, argArray));, + log(WARN_INT, org.slf4j.helpers.MessageFormatter.arrayFormat(format, argArray));, + log(ERROR_INT, org.slf4j.helpers.MessageFormatter.arrayFormat(format, argArray));, +++ b/common/src/test/java/io/netty/util/internal/logging/Slf4JLoggerFactoryTest.java, + internalLogger.debug("{} {} {}", "debug1", "debug2", "debug3");, + internalLogger.error("{} {} {}", "error1", "error2", "error3");, + internalLogger.info("{} {} {}", "info1", "info2", "info3");, + internalLogger.trace("{} {} {}", "trace1", "trace2", "trace3");, + internalLogger.warn("{} {} {}", "warn1", "warn2", "warn3");, + verify(logger, times(3)).log(ArgumentMatchers.<Marker>isNull(), eq(LocationAwareSlf4JLogger.FQCN),, + verify(logger, times(3)).log(ArgumentMatchers.<Marker>isNull(), eq(LocationAwareSlf4JLogger.FQCN),, + verify(logger, times(3)).log(ArgumentMatchers.<Marker>isNull(), eq(LocationAwareSlf4JLogger.FQCN),, + verify(logger, times(3)).log(ArgumentMatchers.<Marker>isNull(), eq(LocationAwareSlf4JLogger.FQCN),, + verify(logger,
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + private static final Throwable UNSAFE_UNAVAILABILITY_CAUSE = unsafeUnavailabilityCause0();, + UNSAFE_UNAVAILABILITY_CAUSE == null && !SystemPropertyUtil.getBoolean("io.netty.noPreferDirect", false);, + return UNSAFE_UNAVAILABILITY_CAUSE == null;, + return UNSAFE_UNAVAILABILITY_CAUSE;, + private static Throwable unsafeUnavailabilityCause0() {, + return new UnsupportedOperationException("sun.misc.Unsafe: unavailable (Android)");, + Throwable cause = PlatformDependent0.getUnsafeUnavailabilityCause();, + if (cause != null) {, + return cause;, + return hasUnsafe ? null : PlatformDependent0.getUnsafeUnavailabilityCause();, + return new UnsupportedOperationException("Could not determine if Unsafe is available", t);, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + private static final Throwable UNSAFE_UNAVAILABILITY_CAUSE = unsafeUnavailabilityCause0();, + UNSAFE_UNAVAILABILITY_CAUSE == null && !SystemPropertyUtil.getBoolean("io.netty.noPreferDirect", false);, + return UNSAFE_UNAVAILABILITY_CAUSE == null;, + return UNSAFE_UNAVAILABILITY_CAUSE;, + private static Throwable unsafeUnavailabilityCause0()
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java, +import io.netty.util.internal.SocketUtils;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +import java.lang.reflect.Method;, +import java.net.InetSocketAddress;, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, +, +import static io.netty.resolver.dns.DnsServerAddresses.sequential;, + * <p>, + * This may use the JDK's blocking DNS resolution to bootstrap the default DNS server addresses., + private static final InternalLogger logger =, + InternalLoggerFactory.getInstance(DefaultDnsServerAddressStreamProvider.class);, + private static final List<InetSocketAddress> DEFAULT_NAME_SERVER_LIST;, + private static final InetSocketAddress[] DEFAULT_NAME_SERVER_ARRAY;, + private static final DnsServerAddresses DEFAULT_NAME_SERVERS;, + static final int DNS_PORT = 53;, +, + static {, + final List<InetSocketAddress> defaultNameServers = new ArrayList<InetSocketAddress>(2);, + try {, + Class<?> configClass = Class.forName("sun.net.dns.ResolverConfiguration");, + Method open =
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + if (!prefaceSent()) {, + // If the preface was not sent yet it most likely means the handler was not added to the pipeline before, + // calling this method., + throw connectionError(INTERNAL_ERROR, "HTTP upgrade must occur after preface was sent");, + }, + if (decoder.prefaceReceived()) {, + throw connectionError(PROTOCOL_ERROR, "HTTP upgrade must occur before HTTP/2 preface is received");, + if (!prefaceSent()) {, + // If the preface was not sent yet it most likely means the handler was not added to the pipeline before, + // calling this method., + throw connectionError(INTERNAL_ERROR, "HTTP upgrade must
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, + WebSocketServerHandshakerFactory.sendUnsupportedWebSocketVersionResponse(ctx.channel());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, + WebSocketServerHandshakerFactory.sendUnsupportedWebSocketVersionResponse(ctx.channel());, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, +import static io.netty.handler.codec.http.HttpHeaders.*;, +import static io.netty.handler.codec.http.HttpMethod.*;, +import static io.netty.handler.codec.http.HttpResponseStatus.*;, +import static io.netty.handler.codec.http.HttpVersion.*;, +, + WebSocketServerHandshakerFactory.sendUnsupportedWebSocketVersionResponse(ctx.channel());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, + WebSocketServerHandshakerFactory.sendUnsupportedWebSocketVersionResponse(ctx.channel());, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, +import static io.netty.handler.codec.http.HttpHeaders.*;, +import static io.netty.handler.codec.http.HttpMethod.*;, +import static io.netty.handler.codec.http.HttpResponseStatus.*;, +import static io.netty.handler.codec.http.HttpVersion.*;, +, + WebSocketServerHandshakerFactory.sendUnsupportedWebSocketVersionResponse(ctx.channel());, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java, + WebSocketServerHandshakerFactory.sendUnsupportedWebSocketVersionResponse(ctx.channel());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, + WebSocketServerHandshakerFactory.sendUnsupportedWebSocketVersionResponse(ctx.channel());, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, +import static io.netty.handler.codec.http.HttpHeaders.*;, +import static io.netty.handler.codec.http.HttpMethod.*;, +import static io.netty.handler.codec.http.HttpResponseStatus.*;, +import static io.netty.handler.codec.http.HttpVersion.*;, +, + WebSocketServerHandshakerFactory.sendUnsupportedWebSocketVersionResponse(ctx.channel());, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java, + WebSocketServerHandshakerFactory.sendUnsupportedWebSocketVersionResponse(ctx.channel());, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java, + WebSocketServerHandshakerFactory.sendUnsupportedWebSocketVersionResponse(ctx.channel());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, + WebSocketServerHandshakerFactory.sendUnsupportedWebSocketVersionResponse(ctx.channel());, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, +import static io.netty.handler.codec.http.HttpHeaders.*;, +import static io.netty.handler.codec.http.HttpMethod.*;, +import static io.netty.handler.codec.http.HttpResponseStatus.*;, +import static io.netty.handler.codec.http.HttpVersion.*;, +, +
[+++ b/example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java, + * Copyright 2014 The Netty Project, +/**, + * This is an example of a WebSocket client., + * <p>, + * In order to run this example you need a compatible WebSocket server., + * Therefore you can either start the WebSocket server from the examples, + * by running {@link io.netty.example.http.websocketx.server.WebSocketServer}, + * or connect to an existing WebSocket server such as, + * <a href="http://www.websocket.org/echo.html">ws://echo.websocket.org</a>., + * <p>, + * The client will attempt to connect to the URI passed to it as the first argument., + * You don't have to specify
[+++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryDecoder.java, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryDecoder.java, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponseDecoder.java, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryDecoder.java, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponseDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryDecoder.java, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponseDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryDecoder.java, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponseDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ServerUpgradeCodec.java, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryDecoder.java, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponseDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ServerUpgradeCodec.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/Decoder.java, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryDecoder.java, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponseDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ServerUpgradeCodec.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/Decoder.java, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryDecoder.java, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponseDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ServerUpgradeCodec.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/Decoder.java, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameCodecTest.java, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryDecoder.java, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponseDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, +++
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java, + // Create a new SSL_CTX and configure it., + boolean success = false;, + try {]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java, + this(certChainFile, keyFile, keyPassword, null, null,, + OpenSslDefaultApplicationProtocolNegotiator.INSTANCE, 0, 0);, + this(certChainFile, keyFile, keyPassword, null, ciphers,, + toNegotiator(apn, false), sessionCacheSize, sessionTimeout);, + File certChainFile, File keyFile, String keyPassword, TrustManagerFactory trustManagerFactory,, + if (trustManagerFactory == null) {, + // Mimic the way SSLContext.getInstance(KeyManager[], null, null) works, + trustManagerFactory = TrustManagerFactory.getInstance(, + trustManagerFactory.init((KeyStore) null);, + } else {, + trustManagerFactory.init(ks);, + }, +, + final X509TrustManager manager = chooseTrustManager(trustManagerFactory.getTrustManagers());, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java, + this(certChainFile, keyFile, keyPassword, null, null,, + OpenSslDefaultApplicationProtocolNegotiator.INSTANCE, 0, 0);, + this(certChainFile, keyFile, keyPassword, null, ciphers,, + toNegotiator(apn, false), sessionCacheSize, sessionTimeout);, + File certChainFile, File keyFile, String keyPassword,
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + normalizedCapacity --;, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + normalizedCapacity --;, +++ b/buffer/src/test/java/io/netty/buffer/PoolArenaTest.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT,
[+++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, +, +++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, +, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + tmpNioBuf = null;, +++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, +, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + tmpNioBuf = null;, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java]
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java, +++ b/transport/src/main/java/io/netty/channel/ChannelStateHandler.java, +, + /**, + * Gets called if a {@link Throwable} was thrown., + */, + void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;, +, + /**, + * Gets called if an user event was triggered., + */, + void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception;, +++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java, +++ b/transport/src/main/java/io/netty/channel/ChannelStateHandler.java, +, + /**, + * Gets called if a {@link Throwable} was thrown., + */, + void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;, +, + /**, + * Gets called if an user event was
[+++ b/codec/src/main/java/io/netty/handler/codec/CharSequenceValueConverter.java, + if (value instanceof AsciiString && value.length() == 1) {, +++ b/codec/src/main/java/io/netty/handler/codec/CharSequenceValueConverter.java, + if (value instanceof AsciiString && value.length() == 1) {, +++ b/codec/src/test/java/io/netty/handler/codec/CharSequenceValueConverterTest.java, +import io.netty.util.AsciiString;, + public void testByteFromAsciiString() {, + assertEquals(127, converter.convertToByte(AsciiString.of("127")));, + }, +, + @Test(expected = NumberFormatException.class), + public void testByteFromEmptyAsciiString() {, + converter.convertToByte(AsciiString.EMPTY_STRING);, + }, +, + @Test]
[+++ b/pom.xml, + <!-- Used for HTTP tunneling transport -->]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +public abstract class HttpContentEncoder extends MessageToMessageCodec<HttpMessage, HttpObject> {, + public Object encode(ChannelHandlerContext ctx, HttpObject msg), + protected void freeOutboundMessage(HttpObject msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +public abstract class HttpContentEncoder extends MessageToMessageCodec<HttpMessage, HttpObject> {, + public Object encode(ChannelHandlerContext ctx, HttpObject msg), + protected void freeOutboundMessage(HttpObject msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java, + @Override, + public boolean acceptInboundMessage(Object msg) throws Exception {, + return msg instanceof HttpMessage || msg instanceof SpdyRstStreamFrame;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +public abstract class HttpContentEncoder extends MessageToMessageCodec<HttpMessage, HttpObject> {, + public Object encode(ChannelHandlerContext ctx, HttpObject msg), + protected void freeOutboundMessage(HttpObject msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java, +
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, + AbstractEpollChannel[] localChannels = channels.values().toArray(new AbstractEpollChannel[0]);, + for (AbstractEpollChannel ch : localChannels) {]
[+++ b/pom.xml, + <url>https://svn.jboss.org/repos/repository.jboss.org/maven2</url>]
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + OutputMessageBuf out = OutputMessageBuf.get();, + OutputMessageBuf out = OutputMessageBuf.get();, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + OutputMessageBuf out = OutputMessageBuf.get();, + OutputMessageBuf out = OutputMessageBuf.get();, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, + OutputMessageBuf out = OutputMessageBuf.get();, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + OutputMessageBuf out = OutputMessageBuf.get();, + OutputMessageBuf out = OutputMessageBuf.get();, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, + OutputMessageBuf out = OutputMessageBuf.get();, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, + OutputMessageBuf out = OutputMessageBuf.get();, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + OutputMessageBuf out = OutputMessageBuf.get();, + OutputMessageBuf out = OutputMessageBuf.get();, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, + OutputMessageBuf out = OutputMessageBuf.get();, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, + OutputMessageBuf out = OutputMessageBuf.get();, +++ b/codec/src/main/java/io/netty/handler/codec/OutputMessageBuf.java, +, + private static final ThreadLocal<OutputMessageBuf> output =, + new ThreadLocal<OutputMessageBuf>() {, + @Override,
[+++ b/handler/src/main/java/io/netty/handler/ssl/util/OpenJdkSelfSignedCertGenerator.java, +import java.security.cert.CertificateException;, + try {, + } catch (CertificateException ignore) {, + info.set(X509CertInfo.SUBJECT, owner);, + }, + try {, + } catch (CertificateException ignore) {, + info.set(X509CertInfo.ISSUER, owner);, + }]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelId.java, + private static final int PROCESS_ID_LEN = 4;, + // Maximal value for 64bit systems is 2^22. See man 5 proc., + // See https://github.com/netty/netty/issues/2706, + private static final int MAX_PROCESS_ID = 4194304;, + i = writeInt(i, PROCESS_ID);]
[+++ b/transport/src/main/java/io/netty/channel/ChannelStateHandler.java, +++ b/transport/src/main/java/io/netty/channel/ChannelStateHandler.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + final AtomicBoolean suspendRead = new AtomicBoolean();, +++ b/transport/src/main/java/io/netty/channel/ChannelStateHandler.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + final AtomicBoolean suspendRead = new AtomicBoolean();, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, + // make sure the it's set back to readable, + // make sure the it's set back to readable, +++ b/transport/src/main/java/io/netty/channel/ChannelStateHandler.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + final AtomicBoolean suspendRead = new AtomicBoolean();, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, + // make sure the it's set back to readable, + // make sure the it's set back to readable, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AbstractAioChannel.java, + protected abstract class AbstractAioUnsafe extends AbstractUnsafe {, +++ b/transport/src/main/java/io/netty/channel/ChannelStateHandler.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + final AtomicBoolean suspendRead = new
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + if (ctx.hasInboundByteBuffer()) {, + }, + if (ctx.inMsgBuf != null) {, + }, + if (ctx.hasOutboundByteBuffer()) {, + }, + if (ctx.outMsgBuf != null) {, + }]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + static {, + ResourceLeakDetector.addExclusions(AbstractByteBufAllocator.class, "toLeakAwareBuffer");, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + static {, + ResourceLeakDetector.addExclusions(AbstractByteBufAllocator.class, "toLeakAwareBuffer");, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java, +import io.netty.util.ResourceLeakDetector;, +, + ResourceLeakDetector.addExclusions(, + AdvancedLeakAwareByteBuf.class, "touch", "recordLeakNonRefCountingOperation");, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + static {, + ResourceLeakDetector.addExclusions(AbstractByteBufAllocator.class, "toLeakAwareBuffer");, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java, +import io.netty.util.ResourceLeakDetector;, +, + ResourceLeakDetector.addExclusions(, + AdvancedLeakAwareByteBuf.class, "touch", "recordLeakNonRefCountingOperation");, +++ b/common/src/main/java/io/netty/util/ReferenceCountUtil.java, + static {, + ResourceLeakDetector.addExclusions(ReferenceCountUtil.class, "touch");, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + static {, + ResourceLeakDetector.addExclusions(AbstractByteBufAllocator.class, "toLeakAwareBuffer");, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java, +import io.netty.util.ResourceLeakDetector;, +, + ResourceLeakDetector.addExclusions(, + AdvancedLeakAwareByteBuf.class, "touch", "recordLeakNonRefCountingOperation");, +++ b/common/src/main/java/io/netty/util/ReferenceCountUtil.java, + static {, + ResourceLeakDetector.addExclusions(ReferenceCountUtil.class, "touch");, + }, +,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import io.netty.handler.codec.http.HttpScheme;, +, + static int websocketPort(URI wsURL) {, + // Format request, + int wsPort = wsURL.getPort();, + // check if the URI contained a port if not set the correct one depending on the schema., + // See https://github.com/netty/netty/pull/1558, + if (wsPort == -1) {, + return "wss".equals(wsURL.getScheme()) ? HttpScheme.HTTPS.port() : HttpScheme.HTTP.port();, + }, + return wsPort;, + }, +, + static CharSequence websocketOriginValue(String host, int wsPort) {, + String originValue = (wsPort == HttpScheme.HTTPS.port() ?, + HttpScheme.HTTPS.name() : HttpScheme.HTTP.name()) + "://" + host;, + if (wsPort != HttpScheme.HTTP.port() && wsPort != HttpScheme.HTTPS.port()) {, +
[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, + long calculated = deadline / tickDuration;, + final long ticks = Math.max(calculated, tick); // Ensure we don't schedule for past., + remainingRounds = (calculated - tick) / wheel.length;, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, + long calculated = deadline / tickDuration;, + final long ticks = Math.max(calculated, tick); // Ensure we don't schedule for past., + remainingRounds = (calculated - tick) / wheel.length;, +++ b/common/src/test/java/io/netty/util/HashedWheelTimerTest.java, +, +import java.util.concurrent.Executors;, +import java.util.concurrent.atomic.AtomicInteger;, +, +, + @Test, + public void testTimerOverflowWheelLength() throws InterruptedException {, + final HashedWheelTimer timer = new HashedWheelTimer(, + Executors.defaultThreadFactory(), 100, TimeUnit.MILLISECONDS, 32);, + final AtomicInteger counter = new AtomicInteger();,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, + private final boolean checkStartsWith;, + public WebSocketServerProtocolHandler(String websocketPath, boolean checkStartsWith) {, + this(websocketPath, null, false, 65536, false, checkStartsWith);, + }, +, + this(websocketPath, subprotocols, allowExtensions, maxFrameSize, allowMaskMismatch, false);, + }, +, + public WebSocketServerProtocolHandler(String websocketPath, String subprotocols,, + boolean allowExtensions, int maxFrameSize, boolean allowMaskMismatch, boolean checkStartsWith) {, + this.checkStartsWith = checkStartsWith;, + allowExtensions, maxFramePayloadLength, allowMaskMismatch, checkStartsWith));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, + private final boolean checkStartsWith;, + public WebSocketServerProtocolHandler(String websocketPath, boolean checkStartsWith) {, + this(websocketPath, null, false, 65536, false, checkStartsWith);, + }, +, + this(websocketPath, subprotocols, allowExtensions, maxFrameSize, allowMaskMismatch, false);, + }, +, + public WebSocketServerProtocolHandler(String websocketPath, String subprotocols,,
[+++ b/all/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/example/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec/pom.xml, +
[+++ b/transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannel.java, + ConnectTimeoutException cause = new ConnectTimeoutException("connection timed out: " + remoteAddress);, + cause.setStackTrace(e.getStackTrace());, + throw cause;]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + if (!next.isInboundBufferFreed()) {, + }]
[+++ b/handler/src/main/java/io/netty/handler/ssl/CipherSuiteFilter.java, +import javax.net.ssl.SSLEngine;, +++ b/handler/src/main/java/io/netty/handler/ssl/CipherSuiteFilter.java, +import javax.net.ssl.SSLEngine;, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkApplicationProtocolNegotiator.java, +import javax.net.ssl.SSLEngine;, + interface SslEngineWrapperFactory {, + interface ProtocolSelector {, + interface ProtocolSelectionListener {, + interface ProtocolSelectorFactory {, + interface ProtocolSelectionListenerFactory {, +++ b/handler/src/main/java/io/netty/handler/ssl/CipherSuiteFilter.java, +import javax.net.ssl.SSLEngine;, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkApplicationProtocolNegotiator.java, +import javax.net.ssl.SSLEngine;, + interface SslEngineWrapperFactory {, + interface ProtocolSelector {, + interface ProtocolSelectionListener {, + interface ProtocolSelectorFactory {, + interface ProtocolSelectionListenerFactory {, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, +import io.netty.util.internal.EmptyArrays;, +import javax.crypto.Cipher;, +import javax.crypto.EncryptedPrivateKeyInfo;, +import javax.crypto.NoSuchPaddingException;, +import javax.crypto.SecretKey;, +import javax.crypto.SecretKeyFactory;, +import javax.crypto.spec.PBEKeySpec;, +import javax.net.ssl.KeyManagerFactory;, +import javax.net.ssl.SSLContext;, +import javax.net.ssl.SSLEngine;, +import javax.net.ssl.SSLSessionContext;, +import javax.net.ssl.TrustManagerFactory;, +import javax.security.auth.x500.X500Principal;, +import static io.netty.util.internal.ObjectUtil.*;, + for (String n: names) {, + *
[+++ b/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java, + fail(tooLongFrameLength);, + fail(minFrameLength);, + fail(tooLongFrameLength);, + private void fail(long frameLength) {, + throw new TooLongFrameException(, + ": " + frameLength + " - discarded");, + throw new TooLongFrameException(, + " - discarding");, +++ b/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java, + fail(tooLongFrameLength);, + fail(minFrameLength);, + fail(tooLongFrameLength);, + private void fail(long frameLength) {, + throw new TooLongFrameException(, + ": " + frameLength + " - discarded");, + throw new TooLongFrameException(, + " - discarding");, +++ b/codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java, + throw new TooLongFrameException(, + "object length exceeds " + maxObjectLength + ": " + wrtIdx + " bytes discarded");, +, +++ b/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java, + fail(tooLongFrameLength);, + fail(minFrameLength);,
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java, + * @param config Application protocol config., + * @param sessionCacheSize the size of the cache used for storing SSL session objects., + * {@code 0} to use the default value., + * @param sessionTimeout the timeout for the cached SSL session objects, in seconds., + * {@code 0} to use the default value., + */, + public OpenSslServerContext(, + File certChainFile, File keyFile, String keyPassword, TrustManagerFactory trustManagerFactory,, + Iterable<String> ciphers, ApplicationProtocolConfig config,, + long sessionCacheSize, long sessionTimeout) throws SSLException {, + this(certChainFile, keyFile, keyPassword, trustManagerFactory, ciphers,, + toNegotiator(config, true), sessionCacheSize, sessionTimeout);, + }, +, + /**,
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + private Map<InetAddress, List<MembershipKey>> memberships;, + List<MembershipKey> keys = null;, + if (memberships == null) {, + memberships = new HashMap<InetAddress, List<MembershipKey>>();, + } else {, + keys = memberships.get(multicastAddress);, + }]
[+++ b/pom.xml, + <regex>^linux-x86_64-fedora$</regex>]
[+++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, + // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor, + return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);, + }, +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, + // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor, + return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);, + }, +++ b/transport/src/main/java/io/netty/bootstrap/FailedChannel.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + *
[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, + public boolean inEventLoop() {, + return inEventLoop(Thread.currentThread());, + }, +, + @Override, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, + public boolean inEventLoop() {, + return inEventLoop(Thread.currentThread());, + }, +, + @Override, +++ b/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerKeepAliveHandler.java, + promise = promise.unvoid().addListener(ChannelFutureListener.CLOSE);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerKeepAliveHandler.java, + promise = promise.unvoid().addListener(ChannelFutureListener.CLOSE);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpServerKeepAliveHandlerTest.java, + public void testConnectionCloseHeaderHandledCorrectly() throws Exception {, + HttpResponse response = new DefaultFullHttpResponse(httpVersion, responseStatus);, + response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);, + setupMessageLength(response);, +, + channel.writeAndFlush(response);, + HttpResponse writtenResponse = channel.readOutbound();, +, + assertFalse(channel.isOpen());, + ReferenceCountUtil.release(writtenResponse);, + assertFalse(channel.finishAndReleaseAll());, + }, +, + @Test, + public void testConnectionCloseHeaderHandledCorrectlyForVoidPromise() throws Exception {, + HttpResponse response = new DefaultFullHttpResponse(httpVersion, responseStatus);, + response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);, + setupMessageLength(response);, +, + channel.writeAndFlush(response, channel.voidPromise());, + HttpResponse writtenResponse = channel.readOutbound();, +, + assertFalse(channel.isOpen());, + ReferenceCountUtil.release(writtenResponse);, + assertFalse(channel.finishAndReleaseAll());, + }, +, + @Test]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.ReferenceCountException;, + throw new ReferenceCountException(0);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.ReferenceCountException;, + throw new ReferenceCountException(0);, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.ReferenceCountException;, + throw new ReferenceCountException(0);, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +import io.netty.util.ReferenceCountException;, + throw new ReferenceCountException(0, 1);, + throw new ReferenceCountException(Integer.MAX_VALUE, 1);, + throw new ReferenceCountException(0, increment);, + throw new ReferenceCountException(refCnt, increment);, + throw new ReferenceCountException(0, -1);, + throw new ReferenceCountException(refCnt, -decrement);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.ReferenceCountException;, + throw new ReferenceCountException(0);, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +import io.netty.util.ReferenceCountException;, + throw new ReferenceCountException(0, 1);, + throw new ReferenceCountException(Integer.MAX_VALUE, 1);, + throw new ReferenceCountException(0, increment);, + throw new ReferenceCountException(refCnt, increment);, + throw new
[+++ b/transport/src/main/java/io/netty/channel/ChannelFuture.java, +, + /**, + * A {@link ChannelFuture} which is not allowed to be sent to {@link ChannelPipeline} due to, + * implementation details., + */, + interface Unsafe extends ChannelFuture {, + // Tag interface, + }, +++ b/transport/src/main/java/io/netty/channel/ChannelFuture.java, +, + /**, + * A {@link ChannelFuture} which is not allowed to be sent to {@link ChannelPipeline} due to, + * implementation details., + */, + interface Unsafe extends ChannelFuture {, + // Tag interface, + }, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, + if (future.isDone()) {, + throw new IllegalArgumentException("future already done");, + }, + if (future instanceof ChannelFuture.Unsafe)
[+++ b/codec/src/test/java/io/netty/handler/codec/compression/SnappyIntegrationTest.java, +import org.junit.Ignore;, +, + /**, + * The number of random regression tests run by testRandom() runs. Whenever testRandom() finds the case that, + * the snappy codec can't encode/decode, it will print the generated source code of the offending test case., + * You can always reproduce the problem using it rather than relying on testRandom()., + *, + * The default is 1, but you can increase it to increase the chance of finding any unusual cases., + **/, + private static final int RANDOM_RUNS = 1;, +, + public void test1002() throws Throwable {,
[+++ b/codec/src/test/java/io/netty/handler/codec/compression/ZlibTest.java, + public void testGZIP2() throws Exception {]
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/BiDnsQueryLifecycleObserver.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, + buf.append((char) HttpConstants.SP);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, + buf.append((char) HttpConstants.SP);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoderUtil.java, + buf.setLength(buf.length() - 2);, + sb.append((char) HttpConstants.SP);, + sb.append((char) HttpConstants.SP);, + sb.append((char) HttpConstants.SP);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, + buf.append((char) HttpConstants.SP);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoderUtil.java, + buf.setLength(buf.length() - 2);, + sb.append((char) HttpConstants.SP);, + sb.append((char) HttpConstants.SP);, + sb.append((char) HttpConstants.SP);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ServerCookieEncoder.java, + buf.append((char) HttpConstants.SP);, + buf.append((char) HttpConstants.SP);, + buf.append((char) HttpConstants.SP);, + buf.append((char) HttpConstants.SP);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, + buf.append((char) HttpConstants.SP);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoderUtil.java, + buf.setLength(buf.length() - 2);, + sb.append((char) HttpConstants.SP);, + sb.append((char) HttpConstants.SP);, + sb.append((char) HttpConstants.SP);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ServerCookieEncoder.java, + buf.append((char) HttpConstants.SP);, + buf.append((char) HttpConstants.SP);, + buf.append((char) HttpConstants.SP);, + buf.append((char) HttpConstants.SP);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/CookieEncoderTest.java]
[+++ b/src/docbook/en-US/module/architecture.xml, + In this chapter, we will examine what core functionalities are provided in, + Netty and how they constitute a complete network application development, + stack on top of the core. Please keep this diagram in mind as you read this, + chapter.]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + handshake();, + case FINISHED:]
[+++ b/all/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha8</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java, +import io.netty.util.AbstractReferenceCounted;, +public abstract class AbstractMemcacheObject extends AbstractReferenceCounted implements MemcacheObject {, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java, +import io.netty.util.AbstractReferenceCounted;, +public abstract class AbstractMemcacheObject extends AbstractReferenceCounted implements MemcacheObject {, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java, + super.retain();, + super.retain(increment);, + super.touch();, + protected void deallocate() {, + content.release();, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java, +import io.netty.util.AbstractReferenceCounted;, +public abstract class AbstractMemcacheObject extends AbstractReferenceCounted implements MemcacheObject {, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java, + super.retain();, + super.retain(increment);, + super.touch();, + protected void deallocate() {, + content.release();, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java, + super.retain();, + super.retain(increment);, + protected void deallocate() {, + extras.release();, + super.touch();, + return this;, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java, +import io.netty.util.AbstractReferenceCounted;, +public abstract class AbstractMemcacheObject extends AbstractReferenceCounted implements MemcacheObject
[+++ b/example/src/main/java/io/netty/example/filetransfer/FileServer.java, + new StringEncoder(CharsetUtil.UTF_8),, +++ b/example/src/main/java/io/netty/example/filetransfer/FileServer.java, + new StringEncoder(CharsetUtil.UTF_8),, +++ b/example/src/main/java/io/netty/example/rxtx/RxtxClient.java, + new StringEncoder(),, +++ b/example/src/main/java/io/netty/example/filetransfer/FileServer.java, + new StringEncoder(CharsetUtil.UTF_8),, +++ b/example/src/main/java/io/netty/example/rxtx/RxtxClient.java, + new StringEncoder(),, +++ b/example/src/main/java/io/netty/example/securechat/SecureChatClientInitializer.java, + pipeline.addLast("encoder", new StringEncoder());, +++ b/example/src/main/java/io/netty/example/filetransfer/FileServer.java, + new StringEncoder(CharsetUtil.UTF_8),, +++ b/example/src/main/java/io/netty/example/rxtx/RxtxClient.java, + new StringEncoder(),, +++ b/example/src/main/java/io/netty/example/securechat/SecureChatClientInitializer.java, + pipeline.addLast("encoder", new StringEncoder());, +++ b/example/src/main/java/io/netty/example/securechat/SecureChatServerInitializer.java, + pipeline.addLast("encoder", new StringEncoder());, +++ b/example/src/main/java/io/netty/example/filetransfer/FileServer.java, + new StringEncoder(CharsetUtil.UTF_8),, +++ b/example/src/main/java/io/netty/example/rxtx/RxtxClient.java, + new StringEncoder(),, +++ b/example/src/main/java/io/netty/example/securechat/SecureChatClientInitializer.java, + pipeline.addLast("encoder", new StringEncoder());, +++ b/example/src/main/java/io/netty/example/securechat/SecureChatServerInitializer.java, + pipeline.addLast("encoder", new StringEncoder());, +++ b/example/src/main/java/io/netty/example/telnet/TelnetClientInitializer.java, + private static final StringEncoder ENCODER = new StringEncoder();, +++ b/example/src/main/java/io/netty/example/filetransfer/FileServer.java, + new StringEncoder(CharsetUtil.UTF_8),, +++ b/example/src/main/java/io/netty/example/rxtx/RxtxClient.java, + new StringEncoder(),, +++ b/example/src/main/java/io/netty/example/securechat/SecureChatClientInitializer.java, +
[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java, + ensureAccessible();, +++ b/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java, + ensureAccessible();, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, + ensureAccessible();, +++ b/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java, + ensureAccessible();, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, + ensureAccessible();, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java, + ensureAccessible();, +++ b/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java, + ensureAccessible();, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, + ensureAccessible();, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java, + ensureAccessible();, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, + @Test, + public void testArrayAfterRelease() {, + ByteBuf buf = releasedBuffer();, + if (buf.hasArray()) {, + try {, + buf.array();, + fail();, + } catch (IllegalReferenceCountException e) {, + // expected, + }, + }, + }, +, + @Test, + public void testMemoryAddressAfterRelease() {, + ByteBuf buf = releasedBuffer();, + if (buf.hasMemoryAddress()) {, + try {, + buf.memoryAddress();, +
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + // Manual safe-point polling is only needed prior Java9:, + // See https://bugs.openjdk.java.net/browse/JDK-8149596, + if (javaVersion() <= 8) {, + copyMemoryWithSafePointPolling(srcAddr, dstAddr, length);, + } else {, + UNSAFE.copyMemory(srcAddr, dstAddr, length);, + }, + }, +, + private static void copyMemoryWithSafePointPolling(long srcAddr, long dstAddr, long length) {, + // Manual safe-point polling is only needed prior Java9:, + // See https://bugs.openjdk.java.net/browse/JDK-8149596, + if (javaVersion() <= 8) {, + copyMemoryWithSafePointPolling(src, srcOffset, dst, dstOffset, length);, + } else {, + UNSAFE.copyMemory(src, srcOffset, dst, dstOffset, length);, + }, + }, +, + private static void copyMemoryWithSafePointPolling(, + Object src,
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + } else {, + // We were not able to write everything into the BIO so break the write loop as otherwise, + // we will produce an error on the next write attempt, which will trigger a SSL.clearError(), + // later., + break;]
[+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoder.java, + int remainingLength = valueLength - alreadyReadChunkSize;, + if (toRead > remainingLength) {, + toRead = remainingLength;, +, + MemcacheContent chunk;, + if ((alreadyReadChunkSize += toRead) >= valueLength) {, + chunk = new DefaultLastMemcacheContent(chunkBuffer);, + } else {, + chunk = new DefaultMemcacheContent(chunkBuffer);, + }, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoder.java, + int remainingLength = valueLength - alreadyReadChunkSize;, + if (toRead > remainingLength) {, + toRead = remainingLength;, +, + MemcacheContent chunk;, + if ((alreadyReadChunkSize += toRead) >= valueLength) {, + chunk = new DefaultLastMemcacheContent(chunkBuffer);, + } else {, + chunk = new DefaultMemcacheContent(chunkBuffer);, + }, +++ b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java, +import io.netty.util.CharsetUtil;, +
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, + Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();, + if (interfaces != null) {, + while (interfaces.hasMoreElements()) {, + NetworkInterface iface = interfaces.nextElement();, + }, +++ b/common/src/main/java/io/netty/util/NetUtil.java, + Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();, + if (interfaces != null) {, + while (interfaces.hasMoreElements()) {, + NetworkInterface iface = interfaces.nextElement();, + }, +++ b/common/src/main/java/io/netty/util/internal/MacAddressUtil.java, + Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();, + if (interfaces != null) {, + while (interfaces.hasMoreElements()) {, + NetworkInterface iface = interfaces.nextElement();, + }]
[+++ b/codec/src/main/java/io/netty/handler/codec/LengthFieldPrepender.java, +import io.netty.util.internal.ObjectUtil;, +import java.nio.ByteOrder;, + private final ByteOrder byteOrder;, + this(ByteOrder.BIG_ENDIAN, lengthFieldLength, lengthAdjustment, lengthIncludesLengthFieldLength);, + }, +, + /**, + * Creates a new instance., + *, + * @param byteOrder the {@link ByteOrder} of the length field, + * @param lengthFieldLength the length of the prepended length field., + * Only 1, 2, 3, 4, and 8 are allowed., + * @param lengthAdjustment the compensation value to add to the value, + * of the length field, + * @param lengthIncludesLengthFieldLength, + * if {@code true}, the length of the prepended, + * length field is
[+++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, +, + // Check if this handler was removed before continuing with decoding., + // If it was removed, it is not safe to continue to operate on the buffer., + //, + // See:, + // - https://github.com/netty/netty/issues/4635, + if (ctx.isRemoved()) {, + break;, + }]
[+++ b/pom.xml, + Netty must be released from RHEL 6.6 x86_64 or compatible so that:, + Release process must be performed on RHEL 6.6 or its derivatives., + <content>release 6.6</content>]
[+++ b/common/src/main/java/io/netty/util/internal/ObjectCleaner.java, +, + // Package-private for testing, + static final String CLEANER_THREAD_NAME = ObjectCleaner.class.getSimpleName() + "Thread";, + // Mark this as a daemon thread to ensure that we the JVM can exit if this is the only thread that is, + // running., + cleanupThread.setDaemon(true);, +++ b/common/src/main/java/io/netty/util/internal/ObjectCleaner.java, +, + // Package-private for testing, + static final String CLEANER_THREAD_NAME = ObjectCleaner.class.getSimpleName() + "Thread";, + // Mark this as a daemon thread to ensure that we the JVM can exit if this is the only thread that is, + // running., + cleanupThread.setDaemon(true);, +++ b/common/src/test/java/io/netty/util/internal/ObjectCleanerTest.java, +import static org.junit.Assert.assertNotNull;, +import static
[+++ b/transport/src/main/java/io/netty/channel/nio/SelectedSelectionKeySet.java, + public boolean remove(Object o) {, + return false;, + }, +, + @Override, + public boolean contains(Object o) {, + return false;, + }, +, + @Override, +++ b/transport/src/main/java/io/netty/channel/nio/SelectedSelectionKeySet.java, + public boolean remove(Object o) {, + return false;, + }, +, + @Override, + public boolean contains(Object o) {, + return false;, + }, +, + @Override, +++ b/transport/src/test/java/io/netty/channel/nio/SelectedSelectionKeySetTest.java, + assertFalse(set.contains(mockKey));, + assertFalse(set.contains(mockKey2));, + assertFalse(set.remove(mockKey));]
[+++ b/all/pom.xml, + <version>4.1.18.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.18.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.18.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.18.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.18.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, + <version>4.1.18.Final-SNAPSHOT</version>, +
[+++ b/pom.xml, + <tcnative.artifactId>netty-tcnative</tcnative.artifactId>]
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketEchoTest.java, +import io.netty.channel.ChannelInitializer;, +import io.netty.channel.DefaultEventExecutorGroup;, +import io.netty.channel.EventExecutorGroup;, +import io.netty.channel.socket.SocketChannel;, +import org.junit.AfterClass;, +import org.junit.BeforeClass;, + private static EventExecutorGroup group;, +, + @BeforeClass, + public static void createGroup() {, + group = new DefaultEventExecutorGroup(2);, + }, +, + @AfterClass, + public static void destroyGroup() {, + group.shutdown();, + }, +, + @Test(timeout = 30000), + testSimpleEcho0(sb, cb, Integer.MAX_VALUE, false);, + @Test(timeout = 30000), + public void testSimpleEchoWithBridge() throws Throwable {, + run();, + }, +, + public void testSimpleEchoWithBridge(ServerBootstrap sb, Bootstrap cb) throws Throwable {, + testSimpleEcho0(sb, cb, Integer.MAX_VALUE, true);, + }, +, + @Test(timeout = 30000), + testSimpleEcho0(sb, cb,
[+++ b/pom.xml, + <!-- Used for NIO2 -->, + <ignore>java.nio.channels.AsynchronousChannel</ignore>, + <ignore>java.nio.channels.AsynchronousSocketChannel</ignore>, + <ignore>java.nio.channels.AsynchronousServerSocketChannel</ignore>, + <ignore>java.nio.channels.AsynchronousChannelGroup</ignore>, +++ b/pom.xml, + <!-- Used for NIO2 -->, + <ignore>java.nio.channels.AsynchronousChannel</ignore>, + <ignore>java.nio.channels.AsynchronousSocketChannel</ignore>, + <ignore>java.nio.channels.AsynchronousServerSocketChannel</ignore>, + <ignore>java.nio.channels.AsynchronousChannelGroup</ignore>, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + protected boolean inFlushNow;, + public void flushNow() {, + boolean handleFlush = true;, + handleFlush = doFlushByteBuffer(out);, + if (handleFlush) {, + }, + protected boolean doFlushByteBuffer(ByteBuf buf) throws Exception {, + protected final void notifyFlushFutures() {, + protected final void notifyFlushFutures(Throwable cause) {, +++ b/pom.xml, + <!-- Used for NIO2 -->, + <ignore>java.nio.channels.AsynchronousChannel</ignore>, + <ignore>java.nio.channels.AsynchronousSocketChannel</ignore>, + <ignore>java.nio.channels.AsynchronousServerSocketChannel</ignore>, + <ignore>java.nio.channels.AsynchronousChannelGroup</ignore>, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + protected
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + * Set&lt;{@link Cookie}&gt; cookies = {@link CookieDecoder}.decode(value);]
[+++ b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java, +import io.netty.channel.ChannelConfig;, +import java.util.concurrent.TimeUnit;, +, + @Override, + public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {, + final ChannelConfig config = ctx.channel().config();, + if (config.isAutoRead()) {, + // stop accept new connections for 1 second to allow the channel to recover, + // See https://github.com/netty/netty/issues/1328, + config.setAutoRead(false);, + ctx.channel().eventLoop().schedule(new Runnable() {, + @Override, + public void run() {, + config.setAutoRead(true);, + }, + }, 1, TimeUnit.SECONDS);, + }, + // still let the exceptionCaught event flow through the pipeline to give the user, + // a chance to do something with it, + ctx.fireExceptionCaught(cause);, + },
[+++ b/all/pom.xml, +++ b/all/pom.xml, +++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E> {, +, + public ObjectArray(E[] array, int offset, int length) {, + super(array, offset, length);, + }, +, + @Override, + public E[] array() {, + return (E[]) super.array();, + }, +}, +++ b/all/pom.xml, +++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E> {, +, + public ObjectArray(E[] array, int offset, int length) {, + super(array, offset, length);, + }, +, + @Override, + public E[] array() {, + return (E[]) super.array();, + }, +}, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return writerIndex > readerIndex;,
[+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannel.java, + * A SCTP/IP {@link Channel} which was either accepted by {@link SctpServerChannel} or, + * created by {@link SctpClientSocketChannelFactory}., + * local address iterator to support Netty Channel API. In other words, its the application's, + * responsibility to keep track of it's local primary address., + *, + * (To set a local address as primary, the application can request by calling local SCTP stack,, + * with SctpStandardSocketOption.SCTP_PRIMARY_ADDR option)., + * remote address iterator to support Netty Channel API. In other words, its the application's, + * responsibility to keep track of it's peer's
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java]
[+++ b/src/assembly/default.xml, + <format>tar.bz2</format>]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import io.netty.util.internal.PlatformDependent;, + String allocType = SystemPropertyUtil.get(, + "io.netty.allocator.type", PlatformDependent.isAndroid() ? "unpooled" : "pooled");, + allocType = allocType.toLowerCase(Locale.US).trim();, +, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import io.netty.util.internal.PlatformDependent;, + String allocType = SystemPropertyUtil.get(, + "io.netty.allocator.type", PlatformDependent.isAndroid() ? "unpooled" : "pooled");, + allocType = allocType.toLowerCase(Locale.US).trim();, +, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import io.netty.util.internal.PlatformDependent;, + String allocType = SystemPropertyUtil.get(, + "io.netty.allocator.type", PlatformDependent.isAndroid() ? "unpooled" : "pooled");, + allocType = allocType.toLowerCase(Locale.US).trim();, +, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + boolean directBufferFreeable = false;, + Class<?> cls = Class.forName("sun.nio.ch.DirectBuffer", false, PlatformDependent0.class.getClassLoader());, + Method method = cls.getMethod("cleaner");, + if ("sun.misc.Cleaner".equals(method.getReturnType().getName())) {, + directBufferFreeable = true;, + } catch (Throwable t)
[+++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java, + writerIndex(this.buffer.limit());, +++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java, + writerIndex(this.buffer.limit());, +++ b/buffer/src/test/java/io/netty/buffer/ReadOnlyDirectByteBufferBufTest.java, +, + // Test for https://github.com/netty/netty/issues/1708, + @Test, + public void testWrapBufferWithNonZeroPosition() {, + ByteBuf buf = buffer(((ByteBuffer) allocate(16).putLong(1).flip().position(1)).asReadOnlyBuffer());, + buffers.add(buf);, +, + ByteBuf slice = buf.slice();, + Assert.assertEquals(buf, slice);, + }]
[+++ b/pom.xml]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import static io.netty.util.internal.MathUtil.isOutOfBounds;, + if (isOutOfBounds(index, fieldLength, capacity())) {, + if (isOutOfBounds(srcIndex, length, srcCapacity)) {, + if (isOutOfBounds(dstIndex, length, dstCapacity)) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import static io.netty.util.internal.MathUtil.isOutOfBounds;, + if (isOutOfBounds(index, fieldLength, capacity())) {, + if (isOutOfBounds(srcIndex, length, srcCapacity)) {, + if (isOutOfBounds(dstIndex, length, dstCapacity)) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractUnsafeSwappedByteBuf.java, +import static io.netty.util.internal.PlatformDependent.BIG_ENDIAN_NATIVE_ORDER;, +, + nativeByteOrder = BIG_ENDIAN_NATIVE_ORDER == (order() == ByteOrder.BIG_ENDIAN);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import static io.netty.util.internal.MathUtil.isOutOfBounds;, + if (isOutOfBounds(index, fieldLength, capacity())) {, + if (isOutOfBounds(srcIndex, length, srcCapacity)) {, + if (isOutOfBounds(dstIndex, length, dstCapacity)) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractUnsafeSwappedByteBuf.java, +import static io.netty.util.internal.PlatformDependent.BIG_ENDIAN_NATIVE_ORDER;, +, + nativeByteOrder = BIG_ENDIAN_NATIVE_ORDER == (order() == ByteOrder.BIG_ENDIAN);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java,
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFrameDecoder.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, +import static io.netty.util.internal.ObjectUtil.*;, + public static final String NEWLINE = System.getProperty("line.separator");, + BYTE2HEX_PAD[i] = "0" + i;, + BYTE2HEX_PAD[i] = "0" + c;, + String str = Integer.toHexString(i);, + private StringUtil() {, + // Unused., + }, +]
[+++ b/buffer/src/main/java/io/netty/buffer/UnsafeByteBufUtil.java, + return (short) (PlatformDependent.getByte(array, index) << 8 |, + PlatformDependent.getByte(array, index + 1) & 0xff);]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannelConfig.java, + ChannelOption.IP_TOS, ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION,, + EpollChannelOption.SO_REUSEPORT);, + if (option == EpollChannelOption.SO_REUSEPORT) {, + return (T) Boolean.valueOf(isReusePort());, + }, + } else if (option == EpollChannelOption.SO_REUSEPORT) {, + setReusePort((Boolean) value);, + /**, + * Returns {@code true} if the SO_REUSEPORT option is set., + */, + public boolean isReusePort() {, + return Native.isReusePort(datagramChannel.fd) == 1;, + }, +, + /**, + * Set the SO_REUSEPORT option on the underlying Channel. This will allow to bind multiple, + * {@link EpollSocketChannel}s to the same port and so accept connections with multiple threads., + *, + * Be aware this method
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandler.java, + this(handshaker, handleCloseFrames, true);, + }, +, + /**, + * Base constructor, + *, + * @param handshaker, + * The {@link WebSocketClientHandshaker} which will be used to issue the handshake once the connection, + * was established to the remote peer., + * @param handleCloseFrames, + * {@code true} if close frames should not be forwarded and just close the channel, + * @param dropPongFrames, + * {@code true} if pong frames should not be forwarded, + */, + public WebSocketClientProtocolHandler(WebSocketClientHandshaker handshaker, boolean handleCloseFrames,, + boolean dropPongFrames) {, + super(dropPongFrames);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandler.java, + this(handshaker, handleCloseFrames,
[+++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, + String name = calculatePackagePrefix().replace('.', '_') + originalName;, +++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, + String name = calculatePackagePrefix().replace('.', '_') + originalName;, +++ b/transport-native-epoll/pom.xml, + <name>netty_transport_native_epoll</name>, + <Bundle-NativeCode>META-INF/native/libnetty_transport_native_epoll.so; osname=linux; processor=x86_64,*</Bundle-NativeCode>, +++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, + String name = calculatePackagePrefix().replace('.', '_') + originalName;, +++ b/transport-native-epoll/pom.xml, + <name>netty_transport_native_epoll</name>, + <Bundle-NativeCode>META-INF/native/libnetty_transport_native_epoll.so; osname=linux; processor=x86_64,*</Bundle-NativeCode>, +++ b/transport-native-epoll/src/main/c/netty_epoll_native.c, + packagePrefix = netty_unix_util_parse_package_prefix(dlinfo.dli_fname, "netty_transport_native_epoll", &status);, +++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, + String name = calculatePackagePrefix().replace('.', '_') + originalName;, +++ b/transport-native-epoll/pom.xml, + <name>netty_transport_native_epoll</name>, + <Bundle-NativeCode>META-INF/native/libnetty_transport_native_epoll.so; osname=linux; processor=x86_64,*</Bundle-NativeCode>, +++ b/transport-native-epoll/src/main/c/netty_epoll_native.c, + packagePrefix = netty_unix_util_parse_package_prefix(dlinfo.dli_fname, "netty_transport_native_epoll", &status);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java, + NativeLibraryLoader.load("netty_transport_native_epoll", PlatformDependent.getClassLoader(Native.class));, +++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, + String name = calculatePackagePrefix().replace('.', '_') + originalName;, +++ b/transport-native-epoll/pom.xml, + <name>netty_transport_native_epoll</name>,
[+++ b/pom.xml, + <conscrypt.version>1.1.2</conscrypt.version>]
[+++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/SocksMessage.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketClientExtensionHandlerTest.java, +import io.netty.handler.codec.http.HttpHeaderNames;, +import static io.netty.handler.codec.http.websocketx.extensions.WebSocketExtensionTestUtil.*;, +import static org.easymock.EasyMock.*;, +import static org.junit.Assert.*;, +, + req2.headers().get(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS));, + res2.headers().get(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS));, + req2.headers().get(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS));, + res2.headers().get(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS));, + req2.headers().get(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS));, + res2.headers().get(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS));, + req2.headers().get(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS));, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketClientExtensionHandlerTest.java, +import io.netty.handler.codec.http.HttpHeaderNames;, +import static io.netty.handler.codec.http.websocketx.extensions.WebSocketExtensionTestUtil.*;, +import static org.easymock.EasyMock.*;, +import static org.junit.Assert.*;, +, + req2.headers().get(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS));, + res2.headers().get(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS));, + req2.headers().get(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS));, + res2.headers().get(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS));, + req2.headers().get(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS));, + res2.headers().get(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS));, + req2.headers().get(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS));, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketExtensionTestUtil.java, +import io.netty.handler.codec.http.HttpHeaderNames;, +import io.netty.handler.codec.http.HttpHeaderValues;, + req.headers().set(HttpHeaderNames.HOST, "server.example.com");, + req.headers().set(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET.toString().toLowerCase());, + req.headers().set(HttpHeaderNames.CONNECTION, "Upgrade");, + req.headers().set(HttpHeaderNames.ORIGIN, "http://example.com");, + req.headers().set(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS, ext);, + res.headers().set(HttpHeaderNames.HOST, "server.example.com");, + res.headers().set(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET.toString().toLowerCase());, + res.headers().set(HttpHeaderNames.CONNECTION, "Upgrade");, + res.headers().set(HttpHeaderNames.ORIGIN, "http://example.com");, + res.headers().set(HttpHeaderNames.SEC_WEBSOCKET_EXTENSIONS, ext);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketClientExtensionHandlerTest.java, +import io.netty.handler.codec.http.HttpHeaderNames;, +import static io.netty.handler.codec.http.websocketx.extensions.WebSocketExtensionTestUtil.*;,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfig.java, + private final boolean shortCurcuit;, + shortCurcuit = builder.shortCurcuit;, + /**, + * Determines whether a CORS request should be rejected if it's invalid before being, + * further processing., + *, + * CORS headers are set after a request is processed. This may not always be desired, + * and this setting will check that the Origin is valid and if it is not valid no, + * further processing will take place, and a error will be returned to the calling client., + *, + * @return {@code true} if a CORS request should
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, + private SpdySessionStatus status;, + this(lastGoodStreamID, 0);, + }, +, + /**, + * Creates a new instance., + *, + * @param lastGoodStreamID the Last-good-stream-ID of this frame, + * @param statusCode the Status code of this frame, + */, + public DefaultSpdyGoAwayFrame(int lastGoodStreamID, int statusCode) {, + this(lastGoodStreamID, SpdySessionStatus.valueOf(statusCode));, + }, +, + /**, + * Creates a new instance., + *, + * @param lastGoodStreamID the Last-good-stream-ID of this frame, + * @param status the status of this frame, + */, + public DefaultSpdyGoAwayFrame(int lastGoodStreamID, SpdySessionStatus status) {, + setStatus(status);, + public SpdySessionStatus getStatus()
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + * assert decoder.path().equals("/hello");, + * assert decoder.parameters().get("recipient").get(0).equals("world");, + * assert decoder.parameters().get("x").get(0).equals("1");, + * assert decoder.parameters().get("y").get(0).equals("2");]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/FastLzFrameDecoder.java, + * Uncompresses a {@link ByteBuf} encoded by {@link FastLzFrameEncoder} using the FastLZ algorithm.]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + try {, + return forEachByteAsc0(readerIndex, writerIndex, processor);, + } catch (Exception e) {, + PlatformDependent.throwException(e);, + return -1;, + }, + return forEachByteAsc0(index, index + length, processor);, + return -1;, + }, + }, +, + private int forEachByteAsc0(int start, int end, ByteProcessor processor) throws Exception {, + for (; start < end; ++start) {, + if (!processor.process(_getByte(start))) {, + return start;, + }, + try {, + return forEachByteDesc0(writerIndex, readerIndex, processor);, + } catch (Exception e) {, + PlatformDependent.throwException(e);, + return -1;, + }, + return forEachByteDesc0(index + length - 1, index, processor);, + return
[+++ b/pom.xml, +++ b/pom.xml, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/pom.xml, + <version>3.1.0.CR1-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, + private final String host;, + private final int port;, + private final int firstMessageSize;, +, + public DiscardClient(String host, int port, int firstMessageSize) {, + this.host = host;, + this.port = port;, + this.firstMessageSize = firstMessageSize;, + }, +, + public void run() {, + // Configure the client., + ClientBootstrap bootstrap = new ClientBootstrap(, + new NioClientSocketChannelFactory(, + Executors.newCachedThreadPool(),, + Executors.newCachedThreadPool()));, +, + // Set up the pipeline factory., + bootstrap.setPipelineFactory(new ChannelPipelineFactory() {, + public ChannelPipeline getPipeline() throws Exception {, + return Channels.pipeline(, + new DiscardClientHandler(firstMessageSize));, + }, + });, +, + // Start the
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioChannelConfig.java, +/*
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerUpgradeHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerUpgradeHandler.java, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/CleartextHttp2ServerUpgradeHandlerTest.java, + "upgrade: h2c\r\n\r\n";]
[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java, + delay = 0;, + delay = 0;, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java, + delay = 0;, + delay = 0;, +++ b/common/src/test/java/io/netty/util/concurrent/AbstractScheduledEventExecutorTest.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under
[+++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java, + public boolean isWritable() {, + return false;, + }, +, + @Override, + public boolean isWritable(int numBytes) {, + return false;, + }, +, + @Override, + public ByteBuf ensureWritable(int minWritableBytes) {, + throw new ReadOnlyBufferException();, + }, +, + @Override, + public int ensureWritable(int minWritableBytes, boolean force) {, + return 1;, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java, + public boolean isWritable() {, + return false;, + }, +, + @Override, + public boolean isWritable(int numBytes) {, + return false;, + }, +, + @Override, + public ByteBuf ensureWritable(int minWritableBytes) {, + throw new ReadOnlyBufferException();,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + ByteBuf compressed = buffer.slice(buffer.readerIndex(), compressedBytes);, + headerBlockDecoder.decode(compressed, spdyHeadersFrame);, + int readBytes = compressedBytes - compressed.readableBytes();, + buffer.skipBytes(readBytes);, + length -= readBytes;, +]
[+++ b/pom.xml, + <version>3.0.0.CR1-SNAPSHOT</version>, + <name>JBoss - a division of Red Hat</name>, + <url>https://repository.jboss.org/maven2</url>, + <url>https://snapshots.jboss.org/maven2</url>, + <Bundle-DocURL>${project.url}</Bundle-DocURL>, + <Export-Package>!${project.groupId}.util.*,${project.groupId}.*</Export-Package>, + <Import-Package>org.slf4j.*;resolution:=optional,org.apache.commons.logging.*;resolution:=optional,org.jboss.logging.*;resolution:=optional,org.apache.log4j.*;resolution:=optional,*</Import-Package>]
[+++ b/pom.xml, + <stylesheet>${basedir}/src/xref/stylesheet.css</stylesheet>, +++ b/pom.xml, + <stylesheet>${basedir}/src/xref/stylesheet.css</stylesheet>, +++ b/src/xref/stylesheet.css, +* {, + font-family: "Lucida Grande", Geneva, Verdana, "Liberation Sans", Helvetica, Arial, sans-serif;, +}, +, +body {, + background-color: #FFFFFF;, + color:#000000;, + font-size: 10pt;, +}, +, +a:link {color:#0033cc;}, +a:visited {color:#0044cc;}, +, +tt, tt *, pre, pre *, code, code * {, + font-family: "Liberation Mono", "DejaVu Sans Mono", Consolas, Monaco, "Lucida Console", "Courier New", monospace;, +}, +, +/* Headings */, +h1, h2, h3, h4, h5, h6 {, + color:#4a5d75;, + line-height:130%;, + margin-top:0em;, + font-family:'Lucida Grande', Geneva, Verdana, Arial, sans-serif;, + background-color:transparent;, +}, +, +h1 {, + font-size:2em;,
[+++ b/common/src/main/java/io/netty/util/internal/ConversionUtil.java, + * Converts the specified object into a long integer., + */, + public static long toLong(Object value) {, + if (value instanceof Number) {, + return ((Number) value).longValue();, + } else {, + return Long.parseLong(String.valueOf(value));, + }, + }, +, + /**, +++ b/common/src/main/java/io/netty/util/internal/ConversionUtil.java, + * Converts the specified object into a long integer., + */, + public static long toLong(Object value) {, + if (value instanceof Number) {, + return ((Number) value).longValue();, + } else {, + return Long.parseLong(String.valueOf(value));, + }, + }, +, + /**, +++ b/transport/src/main/java/io/netty/channel/ChannelConfig.java, + * Options are available in the
[+++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5AddressEncoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5AddressEncoder.java, +++ b/codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/DefaultSocks5CommandResponseTest.java, + 0x00, // length of domain]
[+++ b/testsuite/pom.xml]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + *, + * @throws IllegalArgumentException if the {@code newCapacity} is greater than {@link #maxCapacity()}, + * Returns the maximum allowed capacity of this buffer. This value provides an upper, + * bound on {@link #capacity()}., + * Expands the buffer {@link #capacity()} to make sure the number of, + * {@linkplain #writableBytes() writable bytes} is equal to or greater than the, + * specified value. If there are enough writable bytes in this buffer, this method, + * returns with no side effect., + * if {@link #writerIndex()} + {@code minWritableBytes} &gt; {@link #maxCapacity()}., + *
[+++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtMessageConnectorChannel.java, +import java.io.IOException;, +import java.security.AccessController;, +import java.security.PrivilegedActionException;, +import java.security.PrivilegedExceptionAction;, + privilegedBind(javaChannel(), localAddress);, +, + private static void privilegedBind(final SocketChannelUDT socketChannel, final SocketAddress localAddress), + throws IOException {, + try {, + AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {, + @Override, + public Void run() throws IOException {, + socketChannel.bind(localAddress);, + return null;, + }, + });, + } catch (PrivilegedActionException e) {, + throw (IOException) e.getCause();, + }, + }]
[+++ b/pom.xml, + <version>3.1.0.CR2-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java, + return willMessage == null ? null : new String(willMessage, CharsetUtil.UTF_8);, + return password == null ? null : new String(password, CharsetUtil.UTF_8);, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java, + return willMessage == null ? null : new String(willMessage, CharsetUtil.UTF_8);, + return password == null ? null : new String(password, CharsetUtil.UTF_8);, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageBuilders.java, + willMessage(willMessage == null ? null : willMessage.getBytes(CharsetUtil.UTF_8));, + password(password == null ? null : password.getBytes(CharsetUtil.UTF_8));, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java, + return willMessage == null ? null : new String(willMessage, CharsetUtil.UTF_8);, + return password == null ? null : new String(password, CharsetUtil.UTF_8);, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageBuilders.java, + willMessage(willMessage == null ? null :
[+++ b/all/pom.xml, + <artifactId>netty-codec-mqtt</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/all/pom.xml, + <artifactId>netty-codec-mqtt</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/codec-mqtt/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<!--, + ~ Copyright 2014 The Netty Project, + ~, + ~ The Netty Project licenses this file to you under the Apache License,, + ~ version 2.0 (the "License"); you may not use this file except in compliance, + ~ with the License. You may obtain a copy of the License at:, + ~, + ~ http://www.apache.org/licenses/LICENSE-2.0, + ~, + ~
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + b = freeLater(wrappedBuffer(, + wrappedBuffer(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, 5, 5).order(order)));]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;, + //, + // Note we use an AtomicReferenceFieldUpdater for atomic operations on these to safe memory. This will safe us, + // 64 bytes per Bridge., + private volatile MessageBridge inMsgBridge;, + private volatile MessageBridge outMsgBridge;, + private volatile ByteBridge inByteBridge;, + private volatile ByteBridge outByteBridge;, +, + private static final AtomicReferenceFieldUpdater<DefaultChannelHandlerContext, MessageBridge> IN_MSG_BRIDGE_UPDATER, + = AtomicReferenceFieldUpdater.newUpdater(DefaultChannelHandlerContext.class,, + MessageBridge.class, "inMsgBridge");, +, + private static final AtomicReferenceFieldUpdater<DefaultChannelHandlerContext, MessageBridge> OUT_MSG_BRIDGE_UPDATER, + = AtomicReferenceFieldUpdater.newUpdater(DefaultChannelHandlerContext.class,, + MessageBridge.class, "outMsgBridge");, +, + private static final AtomicReferenceFieldUpdater<DefaultChannelHandlerContext, ByteBridge> IN_BYTE_BRIDGE_UPDATER, + = AtomicReferenceFieldUpdater.newUpdater(DefaultChannelHandlerContext.class,, + ByteBridge.class, "inByteBridge");, + private static final AtomicReferenceFieldUpdater<DefaultChannelHandlerContext, ByteBridge>
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +import io.netty.buffer.Unpooled;, + private static final long EMPTY_ADDR = Buffer.address(Unpooled.EMPTY_BUFFER.nioBuffer());, +, + * Write encrypted data to the OpenSSL network BIO., + return -1;, + final ByteBuffer[] srcs, int srcsOffset, final int srcsLength,, + final ByteBuffer[] dsts, final int dstsOffset, final int dstsLength) throws SSLException {, + if (srcs == null) {, + throw new NullPointerException("srcs");, + }, + if (srcsOffset >= srcs.length, + || srcsOffset + srcsLength > srcs.length) {, + throw new IndexOutOfBoundsException(, + "offset: " + srcsOffset + ", length: " + srcsLength +, + " (expected: offset <= offset + length <= srcs.length
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2CodecTest.java, +import static java.util.concurrent.TimeUnit.SECONDS;, + assertTrue(serverChannelLatch.await(5, SECONDS));, + group.shutdownGracefully(0, 5, SECONDS);, + clientChannel.close().syncUninterruptibly();, + serverChannel.close().syncUninterruptibly();, + serverConnectedChannel.close().syncUninterruptibly();, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2CodecTest.java, +import static java.util.concurrent.TimeUnit.SECONDS;, + assertTrue(serverChannelLatch.await(5, SECONDS));, + group.shutdownGracefully(0, 5, SECONDS);, + clientChannel.close().syncUninterruptibly();, + serverChannel.close().syncUninterruptibly();, + serverConnectedChannel.close().syncUninterruptibly();, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionRoundtripTest.java, + clientChannel.close().syncUninterruptibly();, + serverChannel.close().syncUninterruptibly();, + serverConnectedChannel.close().syncUninterruptibly();, + Future<?> serverGroup = sb.config().group().shutdownGracefully(0, 5, SECONDS);, + Future<?> serverChildGroup = sb.config().childGroup().shutdownGracefully(0, 5, SECONDS);, + Future<?> clientGroup = cb.config().group().shutdownGracefully(0, 5, SECONDS);, + serverGroup.syncUninterruptibly();, + serverChildGroup.syncUninterruptibly();, + clientGroup.syncUninterruptibly();, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2CodecTest.java, +import static java.util.concurrent.TimeUnit.SECONDS;, + assertTrue(serverChannelLatch.await(5, SECONDS));, + group.shutdownGracefully(0, 5, SECONDS);, + clientChannel.close().syncUninterruptibly();, + serverChannel.close().syncUninterruptibly();, + serverConnectedChannel.close().syncUninterruptibly();, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionRoundtripTest.java, + clientChannel.close().syncUninterruptibly();, + serverChannel.close().syncUninterruptibly();, + serverConnectedChannel.close().syncUninterruptibly();, + Future<?>
[+++ b/pom.xml, + JBoss, Home of Professional Open Source, + Copyright 2008, Red Hat Middleware LLC, and individual contributors, + by the @author tags. See the COPYRIGHT.txt in the distribution for a, + full listing of individual contributors., + This is free software; you can redistribute it and/or modify it, + under the terms of the GNU Lesser General Public License as, + published by the Free Software Foundation; either version 2.1 of, + the License, or (at your option) any later version., + , + This software is distributed in the hope that it will be useful,, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, + static final byte[] CRLF = { CR, LF };, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, + static final byte[] CRLF = { CR, LF };, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, + static final byte[] CRLF = { CR, LF };, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java]
[+++ b/transport/src/main/java/io/netty/channel/ChannelConfig.java, + * @deprecated Use {@link MaxMessagesRecvByteBufAllocator} and, + * {@link MaxMessagesRecvByteBufAllocator#maxMessagesPerRead()}., + * @deprecated Use {@link MaxMessagesRecvByteBufAllocator} and, + * {@link MaxMessagesRecvByteBufAllocator#maxMessagesPerRead(int)}., +++ b/transport/src/main/java/io/netty/channel/ChannelConfig.java, + * @deprecated Use {@link MaxMessagesRecvByteBufAllocator} and, + * {@link MaxMessagesRecvByteBufAllocator#maxMessagesPerRead()}., + * @deprecated Use {@link MaxMessagesRecvByteBufAllocator} and, + * {@link MaxMessagesRecvByteBufAllocator#maxMessagesPerRead(int)}., +++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, + * and {@link MaxMessagesRecvByteBufAllocator#maxMessagesPerRead(int)}.]
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + Class<? super U> tclass, String fieldName) {, + Class<? super T> tclass, String fieldName) {, + Class<? super T> tclass, String fieldName) {, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + Class<? super U> tclass, String fieldName) {, + Class<? super T> tclass, String fieldName) {, + Class<? super T> tclass, String fieldName) {, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + Class<? super U> tclass, String fieldName) throws Exception {, + Class<? super T> tclass, String fieldName) throws Exception {, + Class<? super T> tclass, String fieldName) throws Exception {, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + Class<? super U> tclass, String fieldName) {, + Class<? super T> tclass,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, +import io.netty.handler.codec.ReplayingDecoder;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, +import io.netty.handler.codec.ReplayingDecoder;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, +import io.netty.handler.codec.ReplayingDecoder;, +import io.netty.handler.codec.VoidEnum;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, +import io.netty.handler.codec.ReplayingDecoder;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, +import io.netty.handler.codec.ReplayingDecoder;, +import io.netty.handler.codec.VoidEnum;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +import io.netty.handler.codec.ReplayingDecoder;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, +import io.netty.handler.codec.ReplayingDecoder;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, +import io.netty.handler.codec.ReplayingDecoder;, +import io.netty.handler.codec.VoidEnum;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +import io.netty.handler.codec.ReplayingDecoder;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, + switch (e.state()) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, +import io.netty.handler.codec.ReplayingDecoder;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, +import io.netty.handler.codec.ReplayingDecoder;, +import io.netty.handler.codec.VoidEnum;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +import io.netty.handler.codec.ReplayingDecoder;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, + switch (e.state()) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, + switch (e.state()) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, +import io.netty.handler.codec.ReplayingDecoder;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, +import io.netty.handler.codec.ReplayingDecoder;, +import io.netty.handler.codec.VoidEnum;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +import io.netty.handler.codec.ReplayingDecoder;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, + switch (e.state()) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, + switch (e.state())
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, + private static final byte[] ZERO_CRLF_CRLF = { '0', CR, LF, CR, LF };, +, + out.add(ctx.alloc().buffer(CRLF.length).writeBytes(CRLF));, + out.add(ctx.alloc().buffer(ZERO_CRLF_CRLF.length).writeBytes(ZERO_CRLF_CRLF));]
[+++ b/pom.xml, + <url>https://github.com/netty/netty</url>, + <connection>scm:git:git://github.com/netty/netty.git</connection>, + <developerConnection>scm:git:ssh://git@github.com:netty/netty.git</developerConnection>]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + public byte getByte(int index) {, + checkIndex(index);, + return _getByte(index);, + }, +, + protected abstract byte _getByte(int index);, +, + @Override, + public short getShort(int index) {, + checkIndex(index, 2);, + return _getShort(index);, + }, +, + protected abstract short _getShort(int index);, +, + @Override, + public int getUnsignedMedium(int index) {, + checkIndex(index, 3);, + return _getUnsignedMedium(index);, + }, +, + protected abstract int _getUnsignedMedium(int index);, +, + @Override, + public int getInt(int index) {, + checkIndex(index, 4);, + return _getInt(index);, + }, +, + protected abstract int _getInt(int index);, +, + @Override, + public
[+++ b/all/pom.xml, + <version>4.1.27.Final</version>, +++ b/all/pom.xml, + <version>4.1.27.Final</version>, +++ b/bom/pom.xml, + <version>4.1.27.Final</version>, + <tag>netty-4.1.27.Final</tag>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, +++ b/all/pom.xml, + <version>4.1.27.Final</version>, +++ b/bom/pom.xml, + <version>4.1.27.Final</version>, + <tag>netty-4.1.27.Final</tag>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, + <version>4.1.27.Final</version>, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, + AttributeKey.valueOf(WebSocketServerHandshaker.class.getName() + ".HANDSHAKER");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, + AttributeKey.valueOf(WebSocketServerHandshaker.class.getName() + ".HANDSHAKER");, +++ b/codec/src/main/java/io/netty/handler/codec/DecoderResult.java, + protected static final Signal SIGNAL_UNFINISHED = Signal.valueOf(DecoderResult.class.getName() + ".UNFINISHED");, + protected static final Signal SIGNAL_SUCCESS = Signal.valueOf(DecoderResult.class.getName() + ".SUCCESS");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, + AttributeKey.valueOf(WebSocketServerHandshaker.class.getName() + ".HANDSHAKER");, +++ b/codec/src/main/java/io/netty/handler/codec/DecoderResult.java, + protected static final Signal SIGNAL_UNFINISHED = Signal.valueOf(DecoderResult.class.getName() + ".UNFINISHED");, + protected static final Signal SIGNAL_SUCCESS = Signal.valueOf(DecoderResult.class.getName() + ".SUCCESS");, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, + static final Signal REPLAY = Signal.valueOf(ReplayingDecoder.class.getName() + ".REPLAY");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, + AttributeKey.valueOf(WebSocketServerHandshaker.class.getName() + ".HANDSHAKER");, +++ b/codec/src/main/java/io/netty/handler/codec/DecoderResult.java, + protected static final Signal SIGNAL_UNFINISHED = Signal.valueOf(DecoderResult.class.getName() + ".UNFINISHED");, + protected static final Signal SIGNAL_SUCCESS = Signal.valueOf(DecoderResult.class.getName()
[+++ b/all/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR2-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java, +import io.netty.buffer.ByteBufAllocator;, +import io.netty.util.CharsetUtil;, +import io.netty.util.concurrent.Promise;, +import java.io.ByteArrayInputStream;, + private static final String X509_CERT_PEM =, + "-----BEGIN CERTIFICATE-----\n" +, + "MIIB9jCCAV+gAwIBAgIJAO9fzyjyV5BhMA0GCSqGSIb3DQEBCwUAMBQxEjAQBgNV\n" +, + "BAMMCWxvY2FsaG9zdDAeFw0xNjA5MjAxOTI0MTVaFw00NDEwMDMxOTI0MTVaMBQx\n" +, + "EjAQBgNVBAMMCWxvY2FsaG9zdDCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA\n" +, + "1Kp6DmwRiI+TNs3rZ3WvceDYQ4VTxZQk9jgHVKhHTeA0LptOaazbm9g+aOPiCc6V\n" +, + "5ysu8T8YRLWjej3by2/1zPBO1k25dQRK8dHr0Grmo20FW7+ES+YxohOfmi7bjOVm\n" +, + "NrI3NoVZjf3fQjAlrtKCmaxRPgYEwOT0ucGfJiEyV9cCAwEAAaNQME4wHQYDVR0O\n" +, + "BBYEFIba521hTU1P+1QHcIqAOdAEgd1QMB8GA1UdIwQYMBaAFIba521hTU1P+1QH\n" +, + "cIqAOdAEgd1QMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQELBQADgYEAHG5hBy0b\n" +, + "ysXKJqWQ/3bNId3VCzD9U557oxEYYAuPG0TqyvjvZ3wNQto079Na7lYkTt2kTIYN\n" +, + "/HPW2eflDyXAwXmdNM1Gre213NECY9VxDBTCYJ1R4f2Ogv9iehwzZ4aJGxEDay69\n" +, + "wrGrxKIrKL4OMl/E+R4mi+yZ0i6bfQuli5s=\n" +, + "-----END CERTIFICATE-----\n";, +, + private static final String PRIVATE_KEY_PEM =, + "-----BEGIN PRIVATE KEY-----\n" +, + "MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBANSqeg5sEYiPkzbN\n" +, + "62d1r3Hg2EOFU8WUJPY4B1SoR03gNC6bTmms25vYPmjj4gnOlecrLvE/GES1o3o9\n" +, + "28tv9czwTtZNuXUESvHR69Bq5qNtBVu/hEvmMaITn5ou24zlZjayNzaFWY3930Iw\n" +, + "Ja7SgpmsUT4GBMDk9LnBnyYhMlfXAgMBAAECgYAeyc+B5wNi0eZuOMGr6M3Nns+w\n" +, + "dsz5/cicHOBy0SoBjEQBu1pO0ke4+EWQye0fnlj1brsNEiVhTSqtt+bqPPtIvKtZ\n" +, + "U4Z2M5euUQL390LnVM+jlaRyKUFVYzFnWfNgciT6SLsrbGRz9EhMH2jM6gi8O/cI\n" +, + "n8Do9fgHon9dILOPAQJBAO/3xc0/sWP94Cv25ogsvOLRgXY2NqY/PDfWat31MFt4\n" +, + "pKh9aad7SrqR7oRXIEuJ+16drM0O+KveJEjFnHgcq18CQQDi38CqycxrsL2pzq53\n" +, + "XtlhbzOBpDaNjySMmdg8wIXVVGmFC7Y2zWq+cEirrI0n2BJOC4LLDNvlT6IjnYqF\n" +, + "qp6JAkBQfB0Wyz8XF4aBmG0XzVGJDdXLLUHFHr52x+7OBTez5lHrxSyTpPGag+mo\n"
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, + ByteBuf input = Unpooled.wrappedBuffer(new byte[16]).setIndex(0, 0);]
[+++ b/pom.xml, + <forbiddenapis.skip>true</forbiddenapis.skip>]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +/**, + * Skeltal {@link ByteBufAllocator} implementation to extend., + */, + /**, + * Instance use heap buffers by default, + */, + /**, + * Create new instance, + *, + * @param directByDefault {@code true} if direct buffers should be used by default., + */, + /**, + * Create a heap {@link ByteBuf} with the given initialCapacity and maxCapacity., + */, +, + /**, + * Create a direct {@link ByteBuf} with the given initialCapacity and maxCapacity., + */, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +/**, + * Skeltal {@link ByteBufAllocator} implementation to extend., + */, +
[+++ b/README.md, + * `io.netty.all`, +++ b/README.md, + * `io.netty.all`, +++ b/all/pom.xml, + <manifestEntries>, + <Automatic-Module-Name>io.netty.all</Automatic-Module-Name>, + </manifestEntries>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, + if (name == null || name.length() == 0) {, + throw new IllegalArgumentException("empty headers are not allowed [" + name + "]");, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, + if (name == null || name.length() == 0) {, + throw new IllegalArgumentException("empty headers are not allowed [" + name + "]");, + }, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/DefaultHttpHeadersTest.java, +import io.netty.util.internal.StringUtil;, + @Test(expected = IllegalArgumentException.class), + public void nullHeaderNameNotAllowed() {, + new DefaultHttpHeaders().add(null, "foo");, + }, +, + @Test(expected = IllegalArgumentException.class), + public void emtpyHeaderNameNotAllowed() {, + new DefaultHttpHeaders().add(StringUtil.EMPTY_STRING, "foo");, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, + if (name == null || name.length()
[+++ b/NOTICE.txt, +++ b/NOTICE.txt, +++ /dev/null]
[+++ b/common/src/main/java/io/netty/util/internal/AppendableCharSequence.java, + if (pos == chars.length) {, + char[] old = chars;, + chars = new char[old.length << 1];, + System.arraycopy(old, 0, chars, 0, old.length);, + chars[pos++] = c;]
[+++ b/microbench/src/main/java/io/netty/microbench/buffer/ByteBufBenchmark.java, + public ByteBuffer setByteBufferHeap() {, + return byteBuffer.put(0, BYTE);, + public ByteBuffer setByteBufferDirect() {, + return directByteBuffer.put(0, BYTE);, + public ByteBuf setByteBufHeap() {, + return buffer.setByte(0, BYTE);, + public ByteBuf setByteBufDirect() {, + return directBuffer.setByte(0, BYTE);, + public ByteBuf setByteBufDirectPooled() {, + return directBufferPooled.setByte(0, BYTE);]
[+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequest.java, + throw new IllegalArgumentException(, + "username: " + username + " or password: **** values should be in pure ascii");, + throw new IllegalArgumentException("username: " + username + " exceeds 255 char limit");, + throw new IllegalArgumentException("password: **** exceeds 255 char limit");]
[+++ b/codec/src/main/java/io/netty/handler/codec/CodecOutputList.java, + if (index != size) {, +++ b/codec/src/main/java/io/netty/handler/codec/CodecOutputList.java, + if (index != size) {, +++ b/codec/src/test/java/io/netty/handler/codec/CodecOutputListTest.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/ZlibEncoder.java, + * Compresses a {@link ByteBuf} using the deflate algorithm.]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import io.netty.tcnative.jni.Buffer;, +import io.netty.tcnative.jni.Library;, +import io.netty.tcnative.jni.SSL;, +import io.netty.tcnative.jni.SSLContext;, + Class.forName("io.netty.tcnative.jni.SSL", false, OpenSsl.class.getClassLoader());, + final long sslCtx = SSLContext.make(SSL.SSL_PROTOCOL_ALL, SSL.SSL_MODE_SERVER);, + if (doesSupportProtocol(SSL.SSL_PROTOCOL_SSLV2)) {, + if (doesSupportProtocol(SSL.SSL_PROTOCOL_SSLV3)) {, + if (doesSupportProtocol(SSL.SSL_PROTOCOL_TLSV1)) {, + if (doesSupportProtocol(SSL.SSL_PROTOCOL_TLSV1_1)) {, + if (doesSupportProtocol(SSL.SSL_PROTOCOL_TLSV1_2)) {, +, + private static boolean doesSupportProtocol(int protocol) {, + sslCtx = SSLContext.make(protocol, SSL.SSL_MODE_COMBINED);, + private static boolean initializeTcNative() throws Exception {, + return Library.initialize();, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import io.netty.tcnative.jni.Buffer;, +import io.netty.tcnative.jni.Library;, +import io.netty.tcnative.jni.SSL;, +import io.netty.tcnative.jni.SSLContext;, + Class.forName("io.netty.tcnative.jni.SSL", false, OpenSsl.class.getClassLoader());, + final long sslCtx = SSLContext.make(SSL.SSL_PROTOCOL_ALL, SSL.SSL_MODE_SERVER);, + if (doesSupportProtocol(SSL.SSL_PROTOCOL_SSLV2)) {, + if (doesSupportProtocol(SSL.SSL_PROTOCOL_SSLV3)) {, + if (doesSupportProtocol(SSL.SSL_PROTOCOL_TLSV1)) {, +
[+++ b/all/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.8.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java, +import static io.netty.handler.codec.http2.Http2Exception.connectionError;, +import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;, + return value < 'A' || value > 'Z';, + final int index;, + index = name.forEachByte(HTTP2_NAME_VALIDATOR_PROCESSOR);, + } catch (Http2Exception e) {, + return;, + } catch (Throwable t) {, + PlatformDependent.throwException(connectionError(PROTOCOL_ERROR, t,, + "unexpected error. invalid header name [%s]", name));, + return;, + }, +, + if (index != -1) {, + PlatformDependent.throwException(connectionError(PROTOCOL_ERROR, "invalid header name [%s]", name));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java, +import static io.netty.handler.codec.http2.Http2Exception.connectionError;, +import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;, + return value < 'A' || value > 'Z';, + final int index;, + index = name.forEachByte(HTTP2_NAME_VALIDATOR_PROCESSOR);, + } catch (Http2Exception e) {,
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelId.java, + final ClassLoader loader = ClassLoader.getSystemClassLoader();, + // Invoke java.lang.management.ManagementFactory.getRuntimeMXBean().getName(), + try {, + // Invoke android.os.Process.myPid(), + Class<?> processType = Class.forName("android.os.Process", true, loader);, + Method myPid = processType.getMethod("myPid", null);, + value = myPid.invoke(null, null).toString();, + } catch (Exception e2) {, + logger.debug("Could not invoke Process.myPid(); not Android?", e2);, + }]
[+++ b/example/src/main/java/io/netty/example/securechat/SecureChatServerHandler.java, + ctx.writeAndFlush(, + ctx.writeAndFlush(, + c.writeAndFlush("[" + ctx.channel().remoteAddress() + "] " +, + c.writeAndFlush("[you] " + msg + '\n');]
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + int nextIndex = cIndex > 0 ? components[cIndex - 1].endOffset : 0;, + lastAccessed = null;, + return toComponentIndex0(offset);, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + int nextIndex = cIndex > 0 ? components[cIndex - 1].endOffset : 0;, + lastAccessed = null;, + return toComponentIndex0(offset);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + public void testToComponentIndex() {, + CompositeByteBuf buf = (CompositeByteBuf) wrappedBuffer(new byte[]{1, 2, 3, 4, 5},, + new byte[]{4, 5, 6, 7, 8, 9, 26}, new byte[]{10, 9, 8, 7, 6, 5, 33});, +, + // spot checks, + assertEquals(0, buf.toComponentIndex(4));, + assertEquals(1, buf.toComponentIndex(5));, + assertEquals(2, buf.toComponentIndex(15));, +, + //Loop through each byte,
[+++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDetectPeerCloseWithoutReadTest.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawEncoder.java, + if (valueLength != 0) {]
[+++ b/all/pom.xml, + <version>4.1.9.Final</version>, +++ b/all/pom.xml, + <version>4.1.9.Final</version>, +++ b/bom/pom.xml, +<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">, + <version>4.1.9.Final</version>, +++ b/all/pom.xml, + <version>4.1.9.Final</version>, +++ b/bom/pom.xml, +<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">, + <version>4.1.9.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.9.Final</version>, +++ b/all/pom.xml, + <version>4.1.9.Final</version>, +++ b/bom/pom.xml, +<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">, + <version>4.1.9.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.9.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.9.Final</version>, +++ b/all/pom.xml, + <version>4.1.9.Final</version>, +++ b/bom/pom.xml, +<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">, + <version>4.1.9.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.9.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.9.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.9.Final</version>, +++ b/all/pom.xml, + <version>4.1.9.Final</version>, +++ b/bom/pom.xml, +<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">, + <version>4.1.9.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.9.Final</version>, +++ b/codec-dns/pom.xml,
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +import io.netty.util.concurrent.FutureListener;, +import io.netty.util.concurrent.Promise;, +import io.netty.util.internal.OneTimeTask;, + private Promise<Channel> handshakePromise = new LazyChannelPromise();, + * Returns a {@link Future} that will get notified once the current TLS handshake completes., + *, + * @return the {@link Future} for the iniital TLS handshake if {@link #renegotiate()} was not invoked., + * The {@link Future} for the most recent {@linkplain #renegotiate() TLS renegotiation} otherwise., + * Return the {@link Future} that will get notified if the inbound of the {@link SSLEngine} is closed., + * This method will return the same {@link Future} all the time., + * @see
[+++ b/pom.xml, + <jdk.min.version>1.6</jdk.min.version>, + <maven.min.version>2.2.1</maven.min.version>, + <!-- See org.jboss:jboss-parent -->, + <artifactId>maven-enforcer-plugin</artifactId>, + <version>1.0</version>, + </plugin>, + <plugin>]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + lifecycleManager.onError(ctx, true, failureCause);, + lifecycleManager.onError(ctx, true, t);, + lifecycleManager.onError(ctx, true, failureCause);, + lifecycleManager.onError(ctx, true, t);, + lifecycleManager.onError(ctx, true, cause);, + lifecycleManager.onError(ctx, true, cause);, + lifecycleManager.onError(ctx, true, failureCause);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + lifecycleManager.onError(ctx, true, failureCause);, + lifecycleManager.onError(ctx, true, t);, + lifecycleManager.onError(ctx, true, failureCause);, + lifecycleManager.onError(ctx, true, t);, + lifecycleManager.onError(ctx, true, cause);, + lifecycleManager.onError(ctx, true, cause);, + lifecycleManager.onError(ctx, true, failureCause);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + onError(ctx, true, e);, + onError(ctx, true, connectionError(INTERNAL_ERROR, cause, "Error flushing"));, + onError(ctx, false, e);, + onError(ctx, false, e);, + onError(ctx, false, cause);, + public void onError(ChannelHandlerContext ctx, boolean outbound, Throwable cause) {, + onStreamError(ctx, outbound, cause,
[+++ b/transport-native-kqueue/src/main/java/io/netty/channel/kqueue/KQueueEventLoop.java, + default:]
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +, + Collection<SNIMatcher> matchers = sslParameters.getSNIMatchers();, + if (matchers != null && !matchers.isEmpty()) {, + throw new IllegalArgumentException("SNIMatchers are not supported.");, + }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +, + Collection<SNIMatcher> matchers = sslParameters.getSNIMatchers();, + if (matchers != null && !matchers.isEmpty()) {, + throw new IllegalArgumentException("SNIMatchers are not supported.");, + }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslServerContext.java, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +, + Collection<SNIMatcher> matchers = sslParameters.getSNIMatchers();, + if (matchers != null && !matchers.isEmpty()) {, + throw new IllegalArgumentException("SNIMatchers are not supported.");, + }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslServerContext.java, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, + @Test(expected = IllegalArgumentException.class), + public void testSNIMatchersThrows() throws Exception {, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +, +
[+++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, + * Returns the absolute point in time (relative to {@link #nanoTime()}) at which the the next, + * closest scheduled task should run., + */, + @UnstableApi, + protected long deadlineNanos() {, + ScheduledFutureTask<?> scheduledTask = peekScheduledTask();, + if (scheduledTask == null) {, + return nanoTime() + SCHEDULE_PURGE_INTERVAL;, + }, + return scheduledTask.deadlineNanos();, + }, +, + /**, +++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, + * Returns the absolute point in time (relative to {@link #nanoTime()}) at which the the next, + * closest scheduled task should run., + */, + @UnstableApi, + protected long deadlineNanos() {, + ScheduledFutureTask<?> scheduledTask
[+++ b/src/docbook/module/start.xml, + &ChannelHandlerContext; ctx, &Channel; channel,, + &ChannelBuffer; buffer, &VoidEnum; state) {]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufHolder.java, + ByteBuf content();, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufHolder.java, + ByteBuf content();, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, + public ByteBuf content() {, + return getClass().getSimpleName() + '(' + content().toString() + ')';, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufHolder.java, + ByteBuf content();, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, + public ByteBuf content() {, + return getClass().getSimpleName() + '(' + content().toString() + ')';, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java, + public ByteBuf content() {, + getProtocolVersion(), getMethod(), getUri(), content().copy());, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufHolder.java, + ByteBuf content();, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, + public ByteBuf content() {, + return getClass().getSimpleName() + '(' + content().toString() + ')';, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java, + public ByteBuf content() {, + getProtocolVersion(), getMethod(), getUri(), content().copy());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java, + public ByteBuf content() {,
[+++ b/pom.xml, + <!--, + <allowTimestampedSnapshots>true</allowTimestampedSnapshots>]
[+++ b/example/src/main/java/io/netty/example/localecho/LocalEcho.java, +import io.netty.channel.DefaultEventLoopGroup;, + EventLoopGroup serverGroup = new DefaultEventLoopGroup();, +++ b/example/src/main/java/io/netty/example/localecho/LocalEcho.java, +import io.netty.channel.DefaultEventLoopGroup;, + EventLoopGroup serverGroup = new DefaultEventLoopGroup();, +++ b/transport/src/main/java/io/netty/channel/DefaultEventLoop.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannelConfig.java, + EpollChannelOption.SO_REUSEPORT, EpollChannelOption.IP_FREEBIND, EpollChannelOption.IP_TRANSPARENT,, + if (option == EpollChannelOption.IP_FREEBIND) {, + return (T) Boolean.valueOf(isFreeBind());, + }, + } else if (option == EpollChannelOption.IP_FREEBIND) {, + setFreeBind((Boolean) value);, + * Returns {@code true} if <a href="http://man7.org/linux/man-pages/man7/ip.7.html">IP_FREEBIND</a> is enabled,, + * {@code false} otherwise., + */, + public boolean isFreeBind() {, + try {, + return ((EpollDatagramChannel) channel).socket.isIpFreeBind();, + } catch (IOException e) {, + throw new ChannelException(e);, + }, + }, +, + /**, + * If {@code true} is used <a href="http://man7.org/linux/man-pages/man7/ip.7.html">IP_FREEBIND</a> is enabled,, + * {@code false} for disable it. Default is disabled., + */, +
[+++ b/handler/src/main/java/io/netty/handler/ipfilter/AbstractRemoteAddressFilter.java, + } else {]
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +, + protected final void reset(MessageList<Object> out) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +, + protected final void reset(MessageList<Object> out) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseDecoder.java, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.MessageList;, +, + @Override, + protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {, + super.decodeLast(ctx, in, out);, + MessageList<Object> msgs = MessageList.newInstance();, + reset(msgs);, + if (!msgs.isEmpty()) {, + // Handle the case where the server sends an empty 200 response and close the connection, + // https://github.com/netty/netty/issues/1410, + HttpResponse response = (HttpResponse) msgs.get(0);, + if (response.getStatus().code() == 200) {, + out.add(msgs);, + }, + }, + msgs.recycle();, + }]
[+++ b/codec/src/main/java/io/netty/handler/codec/CharSequenceValueConverter.java, + private static final AsciiString TRUE_ASCII = new AsciiString("true");, + return AsciiString.contentEqualsIgnoreCase(value, TRUE_ASCII);]
[+++ b/common/src/main/java/io/netty/util/concurrent/FastThreadLocal.java, + private final int cleanerFlagIndex;, +, + cleanerFlagIndex = InternalThreadLocalMap.nextVariableIndex();, + if (FastThreadLocalThread.willCleanupFastThreadLocals(current) ||, + threadLocalMap.indexedVariable(cleanerFlagIndex) != InternalThreadLocalMap.UNSET) {, + return;, + }, + // removeIndexedVariable(cleanerFlagIndex) isn't necessary because the finally cleanup is tied to the lifetime, + // of the thread, and this Object will be discarded if the associated thread is GCed., + threadLocalMap.setIndexedVariable(cleanerFlagIndex, Boolean.TRUE);, +, +++ b/common/src/main/java/io/netty/util/concurrent/FastThreadLocal.java, + private final int cleanerFlagIndex;, +, + cleanerFlagIndex = InternalThreadLocalMap.nextVariableIndex();, + if (FastThreadLocalThread.willCleanupFastThreadLocals(current) ||, + threadLocalMap.indexedVariable(cleanerFlagIndex) != InternalThreadLocalMap.UNSET) {, + return;, + }, + // removeIndexedVariable(cleanerFlagIndex) isn't necessary because the finally cleanup is tied to the lifetime,
[+++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java, + ctx.writeAndFlush(new HttpChunkedInput(new ChunkedFile(raf, 0, fileLength, 8192)),]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +import static io.netty.buffer.ByteBufUtil.hexDump;, +import static io.netty.handler.codec.http2.Http2FrameTypes.SETTINGS;, +import static java.lang.Math.min;, + if (readClientPrefaceString(in) && verifyFirstFrameIsSettings(in)) {, + byteDecoder = new FrameDecoder();, + byteDecoder.decode(ctx, in, out);, + int bytesRead = min(in.readableBytes(), prefaceRemaining);, + String receivedBytes = hexDump(in, in.readerIndex(),, + min(in.readableBytes(), clientPrefaceString.readableBytes()));, + throw connectionError(PROTOCOL_ERROR, "HTTP/2 client preface string missing or corrupt. " +, + "Hex dump for received bytes: %s", receivedBytes);, + * Peeks at that the next frame in the buffer and verifies that it is a {@code SETTINGS} frame., + *, + * @param in the inbound buffer., + * @return {@code} true if the next frame
[+++ b/.fbfilter.xml, + ~ Copyright 2012 The Netty Project, +++ b/.fbfilter.xml, + ~ Copyright 2012 The Netty Project, +++ b/all/assembly.xml, +<!--, + ~ Copyright 2012 The Netty Project, + ~, + ~ The Netty Project licenses this file to you under the Apache License,, + ~ version 2.0 (the "License"); you may not use this file except in compliance, + ~ with the License. You may obtain a copy of the License at:, + ~, + ~ http://www.apache.org/licenses/LICENSE-2.0, + ~, + ~ Unless required by applicable law or agreed to in writing, software, + ~ distributed under the License
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + private static final Pattern PATTERN = Pattern.compile(, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + private static final Pattern PATTERN = Pattern.compile(, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, + addCookie(new DefaultCookie(name, value));, + if (cookies.size() > 1) {, + throw new IllegalStateException(, + "encode() can encode only one cookie on server mode: " + cookies.size() + " cookies added");, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + private static final Pattern PATTERN = Pattern.compile(, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, + addCookie(new DefaultCookie(name, value));, + if (cookies.size() > 1) {, + throw new IllegalStateException(, + "encode() can encode only one cookie on server mode: " + cookies.size() + " cookies added");,
[+++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, +, + private final List<HAProxyTLV> tlvs;, + this(protocolVersion, command, proxiedProtocol,, + sourceAddress, destinationAddress, sourcePort, destinationPort, Collections.<HAProxyTLV>emptyList());, + }, +, + /**, + * Creates a new instance, + */, + private HAProxyMessage(, + HAProxyProtocolVersion protocolVersion, HAProxyCommand command, HAProxyProxiedProtocol proxiedProtocol,, + String sourceAddress, String destinationAddress, int sourcePort, int destinationPort,, + List<HAProxyTLV> tlvs) {, +, + this.tlvs = Collections.unmodifiableList(tlvs);, + final List<HAProxyTLV> tlvs = readTlvs(header);, +, + return new HAProxyMessage(ver, cmd, protAndFam, srcAddress, dstAddress, srcPort, dstPort, tlvs);, + }, +, + private static List<HAProxyTLV> readTlvs(final ByteBuf header) {, + HAProxyTLV haProxyTLV = readNextTLV(header);,
[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java, +import io.netty.util.internal.DefaultPriorityQueue;, +import io.netty.util.internal.PriorityQueue;, +import java.util.Comparator;, + private static final Comparator<ScheduledFutureTask<?>> SCHEDULED_FUTURE_TASK_COMPARATOR =, + new Comparator<ScheduledFutureTask<?>>() {, + @Override, + public int compare(ScheduledFutureTask<?> o1, ScheduledFutureTask<?> o2) {, + return o1.compareTo(o2);, + }, + };, +, + PriorityQueue<ScheduledFutureTask<?>> scheduledTaskQueue;, + PriorityQueue<ScheduledFutureTask<?>> scheduledTaskQueue() {, + scheduledTaskQueue = new DefaultPriorityQueue<ScheduledFutureTask<?>>(, + SCHEDULED_FUTURE_TASK_COMPARATOR,, + // Use same initial capacity as java.util.PriorityQueue, + 11);, + PriorityQueue<ScheduledFutureTask<?>> scheduledTaskQueue = this.scheduledTaskQueue;, + scheduledTaskQueue.clearIgnoringIndexes();, + scheduledTaskQueue().removeTyped(task);, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java, +import io.netty.util.internal.DefaultPriorityQueue;, +import io.netty.util.internal.PriorityQueue;, +import java.util.Comparator;, + private static final Comparator<ScheduledFutureTask<?>> SCHEDULED_FUTURE_TASK_COMPARATOR =, + new Comparator<ScheduledFutureTask<?>>() {, + @Override, + public int compare(ScheduledFutureTask<?> o1, ScheduledFutureTask<?> o2) {,
[+++ b/pom.xml, + <name>JBoss, by Red Hat, Inc.</name>]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java, + private volatile int maxMessagesPerRead = 1;, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java, + private volatile int maxMessagesPerRead = 1;, +++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java, +import io.netty.buffer.ByteBufAllocator;, + final ByteBufAllocator allocator = config.getAllocator();, + final int maxMessagesPerRead = config.getMaxMessagesPerRead();, + final MessageList<ByteBuf> messages = MessageList.newInstance();, +, + ByteBuf byteBuf = null;, + for (;;) {, + byteBuf = allocHandle.allocate(allocator);, + if (localReadAmount == 0) {, + byteBuf.release();, + byteBuf = null;, + break;, + }, + byteBuf.release();, + byteBuf = null;, + break;, + }, +, + messages.add(byteBuf);, + allocHandle.record(localReadAmount);, + byteBuf = null;, + if (messages.size() == maxMessagesPerRead) {, + break;, + },
[+++ b/pom.xml, + <compilerVersion>1.7</compilerVersion>, + <fork>true</fork>, + <Xlint:-options/>]
[+++ b/all/pom.xml, +++ b/all/pom.xml, +++ b/pom.xml, + <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>, + <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>]
[+++ /dev/null, +++ /dev/null, +++ b/all/pom.xml, + <id>clean-first</id>, + <includeGroupIds>${project.groupId}</includeGroupIds>, + <outputDirectory>${project.build.directory}/src</outputDirectory>, + <groupId>org.codehaus.mojo</groupId>, + <artifactId>build-helper-maven-plugin</artifactId>, + <version>1.7</version>, + <id>add-source</id>, + <phase>generate-sources</phase>, + <goal>add-source</goal>, + <sources>, + <source>target/src</source>, + </sources>, +, + <profiles>, + <profile>, + <id>full</id>, + <build>, + <plugins>, + <plugin>, + <artifactId>maven-jxr-plugin</artifactId>, + <version>2.2</version>, + <executions>, + <execution>, + <id>generate-xref</id>, + <phase>package</phase>, + <goals>, + <goal>jxr</goal>, + </goals>, + </execution>, + </executions>, + <configuration>, + <inputEncoding>UTF-8</inputEncoding>, + <outputEncoding>UTF-8</outputEncoding>, + <linkJavadoc>true</linkJavadoc>, + <destDir>${project.build.directory}/xref</destDir>, + <javadocDir>${project.build.directory}/api</javadocDir>, + <docTitle>Netty Source Xref (${project.version})</docTitle>, + <windowTitle>Netty Source Xref (${project.version})</windowTitle>, + </configuration>, + </plugin>, + <plugin>, + <artifactId>maven-javadoc-plugin</artifactId>, + <version>2.8.1</version>, + <executions>,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, + protected ZlibWrapper determineWrapper(String acceptEncoding) {, + float starQ = -1.0f;, + float gzipQ = -1.0f;, + float deflateQ = -1.0f;, + for (String encoding : acceptEncoding.split(",")) {, + float q = 1.0f;, + int equalsPos = encoding.indexOf('=');, + if (equalsPos != -1) {, + try {, + q = Float.valueOf(encoding.substring(equalsPos + 1));, + } catch (NumberFormatException e) {, + // Ignore encoding, + q = 0.0f;, + }, + }, + if (encoding.indexOf("*") >= 0) {, + starQ = q;, + } else if (encoding.indexOf("gzip") >= 0 && q > gzipQ) {, + gzipQ = q;,
[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, + private final Collection<EventExecutor> selfCollection = Collections.<EventExecutor>singleton(this);, + return selfCollection.iterator();, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, + private final Collection<EventExecutor> selfCollection = Collections.<EventExecutor>singleton(this);, + return selfCollection.iterator();, +++ b/common/src/main/java/io/netty/util/concurrent/EventExecutor.java, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, + private final Collection<EventExecutor> selfCollection = Collections.<EventExecutor>singleton(this);, + return selfCollection.iterator();, +++ b/common/src/main/java/io/netty/util/concurrent/EventExecutor.java, +++ b/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, + private final Collection<EventExecutor> selfCollection = Collections.<EventExecutor>singleton(this);, + return selfCollection.iterator();, +++ b/common/src/main/java/io/netty/util/concurrent/EventExecutor.java, +++ b/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java, +++ b/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java, + return readonlyChildren.iterator();, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, + private final Collection<EventExecutor> selfCollection = Collections.<EventExecutor>singleton(this);, + return selfCollection.iterator();, +++ b/common/src/main/java/io/netty/util/concurrent/EventExecutor.java, +++ b/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java, +++ b/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java, + return readonlyChildren.iterator();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoopGroup.java, + for (EventExecutor e: this) {, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, + private final Collection<EventExecutor> selfCollection
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, +import java.io.File;, + File file = new File("/proc/sys/net/core/somaxconn");, + if (file.exists()) {, + } else {, + logger.debug("/proc/sys/net/core/somaxconn not exists. Use default-value: {}", somaxconn);, + }]
[+++ b/common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java, + * //since 1.7, + * //author Doug Lea]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java, + if (byteBuf != null) {, + byteBuf.release();, + }, + if (byteBuf != null) {, + byteBuf.release();, + }, + if (byteBuf != null) {, + byteBuf.release();, + }]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterialManager.java, +import org.apache.tomcat.jni.CertificateRequestedCallback;, + CertificateRequestedCallback.KeyMaterial keyMaterial(ReferenceCountedOpenSslEngine engine, String[] keyTypes,, + String alias = chooseClientAlias(engine, keyTypes, issuer);, + long keyBio = 0;, + long keyCertChainBio = 0;, + long pkey = 0;, + long certChain = 0;, +, + try {, + // TODO: Should we cache these and so not need to do a memory copy all the time ?, + X509Certificate[] certificates = keyManager.getCertificateChain(alias);, + if (certificates == null || certificates.length == 0) {, + return null;, + }, +, + PrivateKey key = keyManager.getPrivateKey(alias);, + keyCertChainBio = toBIO(certificates);, + certChain = SSL.parseX509Chain(keyCertChainBio);, + if (key !=
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ClientUpgradeCodec.java, +, + // Reserve local stream 1 for the response., + connectionHandler.onHttpClientUpgrade();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ClientUpgradeCodec.java, +, + // Reserve local stream 1 for the response., + connectionHandler.onHttpClientUpgrade();, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ClientUpgradeCodecTest.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the, + * "License"); you may not use this file except in compliance with the License. You may obtain a, + * copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, + * @deprecated if you want to handle this event you should implement {@link ChannelInboundHandler} and, + * implement the method there., +++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, + * @deprecated if you want to handle this event you should implement {@link ChannelInboundHandler} and, + * implement the method there., +++ b/transport/src/main/java/io/netty/channel/ChannelInboundHandlerAdapter.java, + @SuppressWarnings("deprecation")]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + * Returns the name of this {@link Cookie}., + * Returns the value of this {@link Cookie}., + * Returns the domain of this {@link Cookie}., + * Returns the path of this {@link Cookie}., + * Returns the comment of this {@link Cookie}., + * Returns the maximum age of this {@link Cookie} in seconds., + * Returns the version of this {@link Cookie}., + * Returns the comment URL of this {@link Cookie}., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + * Returns the name of this {@link Cookie}., + * Returns the value of this {@link Cookie}., +
[+++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, + public static void load(String originalName, ClassLoader loader) {, + // Adjust expected name to support shading of native libraries., + String name = SystemPropertyUtil.get("io.netty.packagePrefix", "").replace('.', '-') + originalName;, +, +++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, + public static void load(String originalName, ClassLoader loader) {, + // Adjust expected name to support shading of native libraries., + String name = SystemPropertyUtil.get("io.netty.packagePrefix", "").replace('.', '-') + originalName;, +, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java, + NativeLibraryLoader.load("netty-transport-native-epoll", PlatformDependent.getClassLoader(Native.class));, +++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, + public static void load(String originalName, ClassLoader loader) {, + // Adjust expected name to support shading of native libraries., + String name = SystemPropertyUtil.get("io.netty.packagePrefix", "").replace('.', '-') +
[+++ b/example/src/main/java/io/netty/example/rxtx/RxtxClient.java, +import io.netty.channel.rxtx.RxtxChannel;, +import io.netty.channel.rxtx.RxtxDeviceAddress;, +++ b/example/src/main/java/io/netty/example/rxtx/RxtxClient.java, +import io.netty.channel.rxtx.RxtxChannel;, +import io.netty.channel.rxtx.RxtxDeviceAddress;, +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClient.java, +import io.netty.channel.udt.UdtChannel;, +import io.netty.channel.udt.nio.NioUdtProvider;, +++ b/example/src/main/java/io/netty/example/rxtx/RxtxClient.java, +import io.netty.channel.rxtx.RxtxChannel;, +import io.netty.channel.rxtx.RxtxDeviceAddress;, +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClient.java, +import io.netty.channel.udt.UdtChannel;, +import io.netty.channel.udt.nio.NioUdtProvider;, +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClientHandler.java, +import io.netty.channel.udt.nio.NioUdtProvider;, +++ b/example/src/main/java/io/netty/example/rxtx/RxtxClient.java, +import io.netty.channel.rxtx.RxtxChannel;, +import io.netty.channel.rxtx.RxtxDeviceAddress;, +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClient.java, +import io.netty.channel.udt.UdtChannel;, +import io.netty.channel.udt.nio.NioUdtProvider;, +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClientHandler.java, +import io.netty.channel.udt.nio.NioUdtProvider;, +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoServer.java, +import io.netty.channel.udt.UdtChannel;, +import io.netty.channel.udt.nio.NioUdtProvider;, +++ b/example/src/main/java/io/netty/example/rxtx/RxtxClient.java, +import io.netty.channel.rxtx.RxtxChannel;, +import io.netty.channel.rxtx.RxtxDeviceAddress;, +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClient.java, +import io.netty.channel.udt.UdtChannel;, +import io.netty.channel.udt.nio.NioUdtProvider;, +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClientHandler.java, +import io.netty.channel.udt.nio.NioUdtProvider;, +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoServer.java, +import io.netty.channel.udt.UdtChannel;, +import io.netty.channel.udt.nio.NioUdtProvider;, +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoServerHandler.java, +import io.netty.channel.udt.nio.NioUdtProvider;, +++ b/example/src/main/java/io/netty/example/rxtx/RxtxClient.java, +import io.netty.channel.rxtx.RxtxChannel;, +import io.netty.channel.rxtx.RxtxDeviceAddress;, +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClient.java, +import io.netty.channel.udt.UdtChannel;, +import io.netty.channel.udt.nio.NioUdtProvider;, +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClientHandler.java, +import io.netty.channel.udt.nio.NioUdtProvider;, +++
[+++ b/handler/src/main/java/io/netty/handler/ssl/ExtendedOpenSslSession.java, + public String getProtocol() {, +++ b/handler/src/main/java/io/netty/handler/ssl/ExtendedOpenSslSession.java, + public String getProtocol() {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import static io.netty.handler.ssl.SslUtils.*;, +, + addIfSupported(availableJavaCipherSuites, defaultCiphers, TLSV13_CIPHER_SUITES);, +, + if (tlsv13Supported && doesSupportProtocol(SSL.SSL_PROTOCOL_TLSV1_3, SSL.SSL_OP_NO_TLSv1_3)) {, +++ b/handler/src/main/java/io/netty/handler/ssl/ExtendedOpenSslSession.java, + public String getProtocol() {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import static io.netty.handler.ssl.SslUtils.*;, +, + addIfSupported(availableJavaCipherSuites, defaultCiphers, TLSV13_CIPHER_SUITES);, +, + if (tlsv13Supported && doesSupportProtocol(SSL.SSL_PROTOCOL_TLSV1_3, SSL.SSL_OP_NO_TLSv1_3)) {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslTlsv13X509ExtendedTrustManager.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, +
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/ZlibCodecFactory.java, + if (PlatformDependent.javaVersion() < 7 || noJdkZlibEncoder ||, + windowBits != DEFAULT_JDK_WINDOW_SIZE || memLevel != DEFAULT_JDK_MEM_LEVEL) {]
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, + , + , + // Check if we exceeded the maximum size of 2gb if this is the case then , + // newCapacity == 0, + //, + // https://github.com/netty/netty/issues/258, + if (newCapacity == 0) {, + throw new IllegalStateException("Maximum size of 2gb exceeded");, + }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + void forwardBufferContentAndFree(, + try {, + } finally {, + flags |= FLAG_REMOVED;, + freeAllIfRemoved();, + }, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + void forwardBufferContentAndFree(, + try {, + } finally {, + flags |= FLAG_REMOVED;, + freeAllIfRemoved();, + }, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, + ctx.forwardBufferContentAndFree(ctxPrev, ctxNext);]
[+++ b/pom.xml]
[+++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java, + return buffer.internalNioBuffer(index, length).duplicate();, +++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java, + return buffer.internalNioBuffer(index, length).duplicate();, +++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java, + return buffer.internalNioBuffer(index, length).duplicate();, +++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java, + return buffer.internalNioBuffer(index, length).duplicate();, +++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java, + return buffer.internalNioBuffer(index, length).duplicate();, +++ b/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java, + return buffer.internalNioBuffer(index + adjustment, length).duplicate();, +++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java, + return buffer.internalNioBuffer(index, length).duplicate();, +++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java, + return buffer.internalNioBuffer(index, length).duplicate();, +++ b/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java, + return buffer.internalNioBuffer(index + adjustment, length).duplicate();, +++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, + return buf.internalNioBuffer(index, length).duplicate().order(order);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, + if (c >= 'A' && c <= 'Z') {, + throw new IllegalArgumentException("name must be all lower case.");, + }]
[+++ b/example/.gitignore, +, +#, +# native udt library extract location, +#, +, +/lib, +, +++ b/example/.gitignore, +, +#, +# native udt library extract location, +#, +, +/lib, +, +++ b/example/pom.xml, + , + <!-- see https://github.com/netty/netty/issues/874 -->, + <dependency>, + <groupId>com.yammer.metrics</groupId>, + <artifactId>metrics-core</artifactId>, + <version>2.2.0</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport-udt</artifactId>, + <version>${project.version}</version>, + </dependency>, +</project>, +++ b/example/.gitignore, +, +#, +# native udt library extract location, +#, +, +/lib, +, +++ b/example/pom.xml, + , + <!-- see https://github.com/netty/netty/issues/874 -->, + <dependency>, + <groupId>com.yammer.metrics</groupId>, + <artifactId>metrics-core</artifactId>, + <version>2.2.0</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport-udt</artifactId>, + <version>${project.version}</version>,
[+++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + @Test(timeout = 10000), +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + @Test(timeout = 10000), +++ b/example/src/main/java/io/netty/example/sctp/SctpClientHandler.java, +import io.netty.channel.sctp.SctpFrame;, + stateEvent.getChannel().write(new SctpFrame(0, 0, ChannelBuffers.wrappedBuffer("SCTP ECHO".getBytes())));, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + @Test(timeout = 10000), +++ b/example/src/main/java/io/netty/example/sctp/SctpClientHandler.java, +import io.netty.channel.sctp.SctpFrame;, + stateEvent.getChannel().write(new SctpFrame(0, 0, ChannelBuffers.wrappedBuffer("SCTP ECHO".getBytes())));, +++ b/transport-sctp/pom.xml, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-codec</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-handler</artifactId>, + <version>${project.version}</version>, + </dependency>, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + @Test(timeout = 10000), +++ b/example/src/main/java/io/netty/example/sctp/SctpClientHandler.java, +import io.netty.channel.sctp.SctpFrame;, + stateEvent.getChannel().write(new SctpFrame(0, 0, ChannelBuffers.wrappedBuffer("SCTP ECHO".getBytes())));, +++ b/transport-sctp/pom.xml, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-codec</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-handler</artifactId>, + <version>${project.version}</version>, + </dependency>, +++
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java, +, + @Override, + public String toString() {, + return HttpMessageUtil.appendFullRequest(new StringBuilder(256), this).toString();, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java, +, + @Override, + public String toString() {, + return HttpMessageUtil.appendFullRequest(new StringBuilder(256), this).toString();, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java, +, + @Override, + public String toString() {, + return HttpMessageUtil.appendFullResponse(new StringBuilder(256), this).toString();, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java, +, + @Override, + public String toString() {, + return HttpMessageUtil.appendFullRequest(new StringBuilder(256), this).toString();, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java, +, + @Override, + public String toString() {, + return HttpMessageUtil.appendFullResponse(new StringBuilder(256), this).toString();, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java, +, + @Override, + public String toString() {, + return
[+++ b/microbench/pom.xml, + <version>1.14.1</version>, + <version>1.14.1</version>]
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslServerContext.java, +import java.io.IOException;, +import java.security.InvalidAlgorithmParameterException;, +import java.security.InvalidKeyException;, +import java.security.NoSuchAlgorithmException;, +import javax.crypto.Cipher;, +import javax.crypto.EncryptedPrivateKeyInfo;, +import javax.crypto.NoSuchPaddingException;, +import javax.crypto.SecretKey;, +import javax.crypto.SecretKeyFactory;, +import javax.crypto.spec.PBEKeySpec;, +import javax.net.ssl.KeyManagerFactory;, +import javax.net.ssl.SSLContext;, +import javax.net.ssl.SSLException;, +import javax.net.ssl.SSLSessionContext;, +, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.ByteBufInputStream;, +, + * @param keyPassword the password of the {@code keyFile}. {@code null} if it's not password-protected., + * @param keyPassword the password of the {@code keyFile}. {@code null} if it's not password-protected., + * @param ciphers the cipher suites to enable, in the order of preference. {@code null} to use the default cipher, + * suites., + * @param nextProtocols the application layer
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketAutoReadTest.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-memcache/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<!--, + ~ Copyright 2013 The Netty Project, + ~, + ~ The Netty Project licenses this file to you under the Apache License,, + ~ version 2.0 (the "License"); you may not use this file except in compliance, + ~ with the License. You may obtain a copy of the License at:, + ~, + ~ http://www.apache.org/licenses/LICENSE-2.0, + ~, + ~ Unless required by applicable law or agreed to in writing, software, + ~ distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + ~ WARRANTIES OR CONDITIONS OF ANY
[+++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java, +import java.nio.ByteOrder;, + public boolean release() {, + boolean deallocated = super.release();, + if (deallocated) {, + leak.close();, + } else {, + leak.record();, + }, + return deallocated;, + }, +, + @Override, + public boolean release(int decrement) {, + boolean deallocated = super.release(decrement);, + if (deallocated) {, + leak.close();, + } else {, + leak.record();, + }, + return deallocated;, + }, +, + @Override, + public ByteBuf order(ByteOrder endianness) {, + leak.record();, + if (order() == endianness) {, + return this;, + } else {, + return new AdvancedLeakAwareByteBuf(super.order(endianness), leak);, + }, + },
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibDecompressor.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/example/pom.xml, + <artifactId>${tcnative.artifactId}</artifactId>, +++ b/example/pom.xml, + <artifactId>${tcnative.artifactId}</artifactId>, +++ b/handler/pom.xml, + <artifactId>${tcnative.artifactId}</artifactId>, +++ b/example/pom.xml, + <artifactId>${tcnative.artifactId}</artifactId>, +++ b/handler/pom.xml, + <artifactId>${tcnative.artifactId}</artifactId>, +++ b/pom.xml, + <tcnative.artifactId>netty-tcnative</tcnative.artifactId>, + <tcnative.version>1.1.33.Fork11</tcnative.version>, + <artifactId>${tcnative.artifactId}</artifactId>, + <version>${tcnative.version}</version>, +++ b/example/pom.xml, + <artifactId>${tcnative.artifactId}</artifactId>, +++ b/handler/pom.xml, + <artifactId>${tcnative.artifactId}</artifactId>, +++ b/pom.xml, + <tcnative.artifactId>netty-tcnative</tcnative.artifactId>, + <tcnative.version>1.1.33.Fork11</tcnative.version>, + <artifactId>${tcnative.artifactId}</artifactId>, + <version>${tcnative.version}</version>, +++ b/testsuite/pom.xml, + <artifactId>${tcnative.artifactId}</artifactId>, +++ b/example/pom.xml, + <artifactId>${tcnative.artifactId}</artifactId>, +++ b/handler/pom.xml, + <artifactId>${tcnative.artifactId}</artifactId>, +++ b/pom.xml, + <tcnative.artifactId>netty-tcnative</tcnative.artifactId>, + <tcnative.version>1.1.33.Fork11</tcnative.version>, + <artifactId>${tcnative.artifactId}</artifactId>, + <version>${tcnative.version}</version>, +++ b/testsuite/pom.xml, + <artifactId>${tcnative.artifactId}</artifactId>, +++ b/transport-native-epoll/pom.xml, + <artifactId>${tcnative.artifactId}</artifactId>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, + private static final char SLASH = '/';, +, + // Add / as absolute path if no is present., + // See http://tools.ietf.org/html/rfc2616#section-5.1.2, + String uri = request.getUri();, + int start = uri.indexOf("://");, + if (start != -1) {, + int startIndex = start + 3;, + if (uri.lastIndexOf(SLASH) <= startIndex) {, + uri += SLASH;, + }, + }, + buf.writeBytes(uri.getBytes("UTF-8"));, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, + private static final char SLASH = '/';, +, + // Add / as absolute path if no is present., + // See http://tools.ietf.org/html/rfc2616#section-5.1.2, + String uri = request.getUri();, + int
[+++ b/all/pom.xml, + <artifactId>maven-jxr-plugin</artifactId>, + <version>2.2</version>, + <executions>, + <execution>, + <id>generate-xref</id>, + <phase>package</phase>, + <goals>, + <goal>jxr</goal>, + </goals>, + </execution>, + </executions>, + <configuration>, + <inputEncoding>UTF-8</inputEncoding>, + <outputEncoding>UTF-8</outputEncoding>, + <linkJavadoc>true</linkJavadoc>, + <destDir>${project.build.directory}/xref</destDir>, + <javadocDir>${project.build.directory}/api</javadocDir>, + <docTitle>Netty Source Xref (${project.version})</docTitle>, + <windowTitle>Netty Source Xref (${project.version})</windowTitle>, + </configuration>, + </plugin>, + <plugin>, + <excludePackageNames>*.internal,*.example</excludePackageNames>, + <doctitle>Netty API Reference (${project.version})</doctitle>, + <windowtitle>Netty API Reference (${project.version})</windowtitle>]
[+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java, +import io.netty.util.IPUtil;, + if (!IPUtil.isValidIPV4Address(host)) {, + if (!IPUtil.isValidIP6Address(host)) {, + byteBuf.writeBytes(IPUtil.createByteArrayFromIPAddressString(host));, + byteBuf.writeBytes(IPUtil.createByteArrayFromIPAddressString(host));, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java, +import io.netty.util.IPUtil;, + if (!IPUtil.isValidIPV4Address(host)) {, + if (!IPUtil.isValidIP6Address(host)) {, + byteBuf.writeBytes(IPUtil.createByteArrayFromIPAddressString(host));, + byteBuf.writeBytes(IPUtil.createByteArrayFromIPAddressString(host));, +++ b/common/src/main/java/io/netty/util/IPUtil.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by
[+++ b/src/main/java/org/jboss/netty/channel/xnio/AbstractXnioChannelHandler.java, +package org.jboss.netty.channel.xnio;, +, +import static org.jboss.netty.channel.Channels.*;, +, +import java.io.IOException;, +import java.net.SocketAddress;, +import java.nio.ByteBuffer;, +import java.nio.channels.AsynchronousCloseException;, +import java.nio.channels.GatheringByteChannel;, +import java.nio.channels.ScatteringByteChannel;, +import java.util.Queue;, +, +import org.jboss.netty.buffer.ChannelBuffer;, +import org.jboss.netty.buffer.ChannelBuffers;, +import org.jboss.netty.channel.MessageEvent;, +import org.jboss.xnio.IoHandler;, +import org.jboss.xnio.channels.MultipointReadResult;, +import org.jboss.xnio.channels.MultipointReadableMessageChannel;, +import org.jboss.xnio.channels.MultipointWritableMessageChannel;, +import org.jboss.xnio.channels.ReadableMessageChannel;, +import org.jboss.xnio.channels.SuspendableReadChannel;, +import org.jboss.xnio.channels.SuspendableWriteChannel;, +import org.jboss.xnio.channels.WritableMessageChannel;, +, +/**, + * @author The Netty Project (netty-dev@lists.jboss.org), + * @author Trustin Lee (tlee@redhat.com), + * @version $Rev$, $Date$, + */, +@SuppressWarnings("unchecked"), +public abstract class AbstractXnioChannelHandler implements IoHandler<java.nio.channels.Channel> {, +, + protected AbstractXnioChannelHandler() {, + super();, + }, +, + public void handleReadable(java.nio.channels.Channel channel) {, + XnioChannel c = XnioChannelRegistry.getChannel(channel);, +, +
[+++ b/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java, + // We could call buf.readSlice(..), and then call buf.release(). However this creates a leak in unit tests, + // because the release method on UnreleasableByteBuf will never allow the leak record to be cleaned up., + // So we just use readSlice(..) because the end result should be logically equivalent., + return readSlice(length);, + // We could call buf.retainedSlice(), and then call buf.release(). However this creates a leak in unit tests, + // because the release method on UnreleasableByteBuf will never allow the leak record to be cleaned up., + // So we just use slice()
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + final String header, final List<String> names, final List<String> values) {, + final int headerLen = header.length();, + loop: for (int i = 0;;) {, +, + // Skip spaces and separators., + for (;;) {, + if (i == headerLen) {, + break loop;, + switch (header.charAt(i)) {, + case '\t': case '\n': case 0x0b: case '\f': case '\r':, + case ' ': case ',': case ';':, + i ++;, + break;, + }, + // Skip '$'., + for (;;) {, + if (i == headerLen) {, + break loop;, + }, + if (header.charAt(i)
[+++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java, + ChannelPromise unvoid = promise.unvoid();, + unvoid.addListener(new ChannelFutureListener() {, + ctx.write(msg, unvoid);, +++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java, + ChannelPromise unvoid = promise.unvoid();, + unvoid.addListener(new ChannelFutureListener() {, + ctx.write(msg, unvoid);, +++ b/handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java, + if (timeoutNanos > 0) {, + promise = promise.unvoid();, + }, +++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java, + ChannelPromise unvoid = promise.unvoid();, + unvoid.addListener(new ChannelFutureListener() {, + ctx.write(msg, unvoid);, +++ b/handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java, + if (timeoutNanos > 0) {, + promise = promise.unvoid();, + }, +++ b/transport/src/main/java/io/netty/channel/ChannelFuture.java, +, + /**, + * Returns {@code true} if this {@link ChannelFuture} is a void future and so not allow to call any of the, + *
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + String targetContentEncoding = getTargetContentEncoding(contentEncoding);, + if (HttpHeaders.Values.IDENTITY.equals(targetContentEncoding)) {, + // Do NOT set the 'Content-Encoding' header if the target encoding is 'identity', + // as per: http://tools.ietf.org/html/rfc2616#section-14.11, + m.removeHeader(HttpHeaders.Names.CONTENT_ENCODING);, + } else {, + m.setHeader(HttpHeaders.Names.CONTENT_ENCODING, targetContentEncoding);, + }]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannelConfig.java, + EpollChannelOption.TCP_MD5SIG, EpollChannelOption.TCP_QUICKACK, EpollChannelOption.IP_TRANSPARENT);, + if (option == EpollChannelOption.IP_TRANSPARENT) {, + return (T) Boolean.valueOf(isIpTransparent());, + }, + } else if (option == EpollChannelOption.IP_TRANSPARENT) {, + setIpTransparent((Boolean) value);, + * Returns {@code true} if <a href="http://man7.org/linux/man-pages/man7/ip.7.html">IP_TRANSPARENT</a> is enabled,, + * {@code false} otherwise., + */, + public boolean isIpTransparent() {, + try {, + return channel.socket.isIpTransparent();, + } catch (IOException e) {, + throw new ChannelException(e);, + }, + }, +, + /**, + * If {@code true} is used <a href="http://man7.org/linux/man-pages/man7/ip.7.html">IP_TRANSPARENT</a> is enabled,, + * {@code false} for disable it. Default is disabled., + */, + public
[+++ b/all/pom.xml, + <profile>, + <id>coverage</id>, + <build>, + <plugins>, + <plugin>, + <groupId>org.jacoco</groupId>, + <artifactId>jacoco-maven-plugin</artifactId>, + <executions>, + <execution>, + <id>jacoco-merge</id>, + <phase>prepare-package</phase>, + <goals>, + <goal>merge</goal>, + </goals>, + <configuration>, + <fileSets>, + <fileSet>, + <directory>${project.parent.build.directory}/..</directory>, + <includes>, + <include>**/target/jacoco.exec</include>, + </includes>, + </fileSet>, + </fileSets>, + </configuration>, + </execution>, + <execution>, + <id>jacoco-report</id>, + <phase>prepare-package</phase>, + <goals>, + <goal>report</goal>, + </goals>, + <configuration>, + <outputDirectory>${project.build.directory}/jacoco-report</outputDirectory>, + </configuration>, + </execution>, + </executions>, + </plugin>, + </plugins>, + </build>, + </profile>, +++ b/all/pom.xml, + <profile>, + <id>coverage</id>, + <build>, + <plugins>, + <plugin>, + <groupId>org.jacoco</groupId>, + <artifactId>jacoco-maven-plugin</artifactId>, +
[+++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java, + private static final Properties props = new Properties();, + private static final InternalLogger logger;, + refresh();, + logger = InternalLoggerFactory.getInstance(SystemPropertyUtil.class);, + }, +, + /**, + * Re-retrieves all system properties so that any post-launch properties updates are retrieved., + */, + public static void refresh() {, + logger.warn("Unable to retrieve the system properties; default values will be used.", e);, + synchronized (props) {, + props.clear();, + props.putAll(newProps);, + }]
[+++ b/src/docbook/en-US/module/architecture.xml, + Switching from one transport to the other usually takes just a couple]
[+++ b/handler/src/main/java/io/netty/handler/ssl/ApplicationProtocolNegotiationHandler.java, + handshakeFailure(ctx, handshakeEvent.cause());, + /**, + * Invoked on failed initial SSL/TLS handshake., + */, + protected void handshakeFailure(ChannelHandlerContext ctx, Throwable cause) throws Exception {, + logger.warn("{} TLS handshake failed:", ctx.channel(), cause);, + ctx.close();, + }, +]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/Decoder.java, +import io.netty.handler.codec.http2.Http2Exception;, +import static io.netty.handler.codec.http2.Http2Error.COMPRESSION_ERROR;, +import static io.netty.handler.codec.http2.Http2Error.ENHANCE_YOUR_CALM;, +import static io.netty.handler.codec.http2.Http2Exception.connectionError;, +import static io.netty.util.internal.ThrowableUtil.unknownStackTrace;, + private static final Http2Exception DECODE_DECOMPRESSION_EXCEPTION = unknownStackTrace(, + connectionError(COMPRESSION_ERROR, "HPACK - decompression failure"), Decoder.class, "decode(...)");, + private static final Http2Exception DECODE_ULE_128_DECOMPRESSION_EXCEPTION = unknownStackTrace(, + connectionError(COMPRESSION_ERROR, "HPACK - decompression failure"), Decoder.class, "decodeULE128(...)");, + private static final Http2Exception DECODE_ILLEGAL_INDEX_VALUE = unknownStackTrace(, + connectionError(COMPRESSION_ERROR, "HPACK - illegal index value"), Decoder.class, "decode(...)");, + private static final Http2Exception INDEX_HEADER_ILLEGAL_INDEX_VALUE = unknownStackTrace(, + connectionError(COMPRESSION_ERROR, "HPACK - illegal index value"), Decoder.class, "indexHeader(...)");, + private static final Http2Exception READ_NAME_ILLEGAL_INDEX_VALUE = unknownStackTrace(, + connectionError(COMPRESSION_ERROR, "HPACK - illegal
[+++ b/pom.xml, + <version>3.1.5.GA-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java, + final BlockingQueue<byte[]> queue = new LinkedBlockingQueue<byte[]>();, + queue.add(random.generateSeed(8));, + "Failed to generate a seed from SecureRandom within {} seconds. " +, + byte[] seed = queue.poll(waitTime, TimeUnit.NANOSECONDS);, + if (seed != null) {, + initialSeedUniquifier =, + ((long) seed[0] & 0xff) << 56 |, + ((long) seed[1] & 0xff) << 48 |, + ((long) seed[2] & 0xff) << 40 |, + ((long) seed[3] & 0xff) << 32 |, + ((long) seed[4] & 0xff) << 24 |, + ((long) seed[5] & 0xff) << 16 |, + ((long) seed[6] & 0xff) << 8 |, + (long) seed[7] & 0xff;]
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + MembershipKey key;, + if (source == null) {, + key = getJdkChannel().getChannel().join(multicastAddress, networkInterface);, + } else {, + key = getJdkChannel().getChannel().join(multicastAddress, networkInterface, source);, + }, +, + System.out.println(key);]
[+++ b/all/pom.xml, + <version>4.0.0.CR6</version>, +++ b/all/pom.xml, + <version>4.0.0.CR6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR6</version>, +++ b/all/pom.xml, + <version>4.0.0.CR6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR6</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR6</version>, +++ b/all/pom.xml, + <version>4.0.0.CR6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR6</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR6</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR6</version>, +++ b/all/pom.xml, + <version>4.0.0.CR6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR6</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR6</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR6</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR6</version>, +++ b/all/pom.xml, + <version>4.0.0.CR6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR6</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR6</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR6</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR6</version>, +++ b/common/pom.xml, + <version>4.0.0.CR6</version>, +++ b/all/pom.xml, + <version>4.0.0.CR6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR6</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR6</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthResponseDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthResponseDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthResponseDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponseDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthResponseDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponseDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitRequestDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthResponseDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponseDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitRequestDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitResponseDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthResponseDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponseDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitRequestDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitResponseDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksMessageEncoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthResponseDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponseDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitRequestDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitResponseDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksMessageEncoder.java, +++ /dev/null, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthResponseDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponseDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitRequestDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksInitResponseDecoder.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksMessageEncoder.java, +++ /dev/null, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.channel.ChannelInitializer;, +import io.netty.channel.ChannelPipeline;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.handler.ssl.SslContext;, +import
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + this.uri = uri;, + this.uri = rawPath + '?' + uri.getRawQuery();, + // http://www.w3.org/TR/html401/appendix/notes.html#h-B.2.2, + } else if (c == '&' || c == ';') {]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + if (fileChannel != null) {, + try {, + fileChannel.force(false);, + fileChannel.close();, + } catch (IOException e) { //ignore, + }, + fileChannel = null;, + }]
[]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java, + final Http2Headers headers = newHeaders();, +, + /**, + * A weighted moving average estimating how many headers are expected during the decode process., + * @return an estimate of how many headers are expected during the decode process., + */, + protected final int numberOfHeadersGuess() {, + return (int) headerArraySizeAccumulator;, + }, +, + /**, + * Determines if the headers should be validated as a result of the decode operation., + * @return {@code true} if the headers should be validated as a result of the decode operation., + */, + protected final boolean
[+++ b/transport/src/test/java/io/netty/channel/CoalescingBufferQueueTest.java, + aggregatePromise.setSuccess();, + assertEquals(0, cat.refCnt());, + assertEquals(0, mouse.refCnt());, + assertEquals(0, cat.refCnt());, + assertEquals(0, mouse.refCnt());, + aggregatePromise.setSuccess();, + aggregatePromise.setSuccess();, + assertEquals(0, cat.refCnt());, + assertEquals(0, mouse.refCnt());, +, + aggregatePromise.setSuccess();, + assertEquals(1, cat.refCnt());, + cat.release();, + aggregatePromise.setSuccess();, + assertEquals(1, mouse.refCnt());, + mouse.release();, + // Not used in this test., + cat.release();, + mouse.release();, +, + aggregatePromise.setSuccess();, + aggregatePromise.setSuccess();, + assertEquals(0, cat.refCnt());, + assertEquals(0, mouse.refCnt());]
[+++ b/transport-sctp/pom.xml, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-handler</artifactId>, + <version>${project.version}</version>, + </dependency>, +++ b/transport-sctp/pom.xml, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-handler</artifactId>, + <version>${project.version}</version>, + </dependency>, +++ b/transport-sctp/src/main/java/com/sun/nio/sctp/MessageInfo.java, + public abstract boolean isUnordered();, + public abstract MessageInfo unordered(boolean b);, +++ b/transport-sctp/pom.xml, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-handler</artifactId>, + <version>${project.version}</version>, + </dependency>, +++ b/transport-sctp/src/main/java/com/sun/nio/sctp/MessageInfo.java, + public abstract boolean isUnordered();, + public abstract MessageInfo unordered(boolean b);, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java, +++ b/transport-sctp/pom.xml, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-handler</artifactId>, + <version>${project.version}</version>, + </dependency>, +++ b/transport-sctp/src/main/java/com/sun/nio/sctp/MessageInfo.java, + public abstract boolean isUnordered();, + public abstract MessageInfo unordered(boolean b);, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelConfig.java, +++ b/transport-sctp/pom.xml, + <dependency>, + <groupId>${project.groupId}</groupId>,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + if (msg instanceof HttpRequest && !done) {, + return super.decode(ctx, channel, buffer, state);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + if (msg instanceof HttpRequest && !done) {, + return super.decode(ctx, channel, buffer, state);, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + if (msg instanceof HttpRequest && !done) {, + return super.decode(ctx, channel, buffer, state);, +++ /dev/null, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + if (msg instanceof HttpRequest && !done) {, + return super.decode(ctx, channel, buffer, state);, +++ /dev/null, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/Attribute.java, +package io.netty.util;, +, +public interface Attribute<T> {, + T get();, + void set(T value);, + T getAndSet(T value);, + T setIfAbsent(T value);, +
[+++ b/handler/src/main/java/io/netty/handler/ipfilter/UniqueIpFilter.java, + if (!connected.add(remoteIp)) {, +++ b/handler/src/main/java/io/netty/handler/ipfilter/UniqueIpFilter.java, + if (!connected.add(remoteIp)) {, +++ b/handler/src/test/java/io/netty/handler/ipfilter/UniqueIpFilterTest.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS"
[+++ b/all/.gitignore, +src, +++ b/all/.gitignore, +src, +++ b/all/pom.xml, + <id>clean-src</id>, + <phase>clean</phase>, + <goals>, + <goal>clean</goal>, + </goals>, + <configuration>, + <filesets>, + <fileset>, + <directory>${project.basedir}/src</directory>, + <followSymlinks>false</followSymlinks>, + <useDefaultExcludes>false</useDefaultExcludes>, + </fileset>, + <fileset>, + <directory>${project.basedir}/target</directory>, + <followSymlinks>false</followSymlinks>, + </fileset>, + </filesets>, + </configuration>, + </execution>, + <execution>, + <id>clean-all</id>, + <configuration>, + <filesets>, + <fileset>, + <directory>${project.basedir}/src</directory>, + <followSymlinks>false</followSymlinks>, + <useDefaultExcludes>false</useDefaultExcludes>, + </fileset>, + <fileset>, + <directory>${project.basedir}/target</directory>, + <followSymlinks>false</followSymlinks>, + </fileset>, + </filesets>, + </configuration>, + <includeGroupIds>io.netty</includeGroupIds>, + <outputDirectory>${project.basedir}/src/main/java</outputDirectory>, + <overWriteReleases>false</overWriteReleases>, + <overWriteSnapshots>true</overWriteSnapshots>, + <overWriteReleases>false</overWriteReleases>, + <overWriteSnapshots>true</overWriteSnapshots>, + <artifactId>maven-jxr-plugin</artifactId>, + <version>2.2</version>, + <id>generate-xref</id>, + <phase>package</phase>, + <goal>jxr</goal>, +
[+++ b/example/src/main/java/io/netty/example/sctp/SctpEchoClient.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/handler/src/test/java/io/netty/handler/ssl/Java8SslUtils.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServer.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/NioSctpChannelConfig.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServer.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/NioSctpChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannel.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServer.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/NioSctpChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannel.java, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketClientBootstrapTest.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServer.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/NioSctpChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannel.java, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketClientBootstrapTest.java, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/sctp/SctpMultiStreamingEchoTest.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java, +++
[+++ b/all/pom.xml, + <artifactId>netty-handler-proxy</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/all/pom.xml, + <artifactId>netty-handler-proxy</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/codec-dns/pom.xml, +++ b/all/pom.xml, + <artifactId>netty-handler-proxy</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/codec-dns/pom.xml, +++ b/codec-http/pom.xml, + <optional>true</optional>, +++ b/all/pom.xml, + <artifactId>netty-handler-proxy</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/codec-dns/pom.xml, +++ b/codec-http/pom.xml, + <optional>true</optional>, +++ b/codec-memcache/pom.xml, +++ b/all/pom.xml, + <artifactId>netty-handler-proxy</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/codec-dns/pom.xml, +++
[+++ b/codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java, + private int lastReaderIndex;, +, + if (this.idx > in.readerIndex() && lastReaderIndex != in.readerIndex()) {, + this.idx = in.readerIndex();, + reset();, + }, +, + this.lastReaderIndex = in.readerIndex();, +++ b/codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java, + private int lastReaderIndex;, +, + if (this.idx > in.readerIndex() && lastReaderIndex != in.readerIndex()) {, + this.idx = in.readerIndex();, + reset();, + }, +, + this.lastReaderIndex = in.readerIndex();, +++ b/codec/src/test/java/io/netty/handler/codec/json/JsonObjectDecoderTest.java, +, + @Test, + public void testCorruptedFrameException() {, + final String part1 = "{\"a\":{\"b\":{\"c\":{ \"d\":\"27301\", \"med\":\"d\", \"path\":\"27310\"} }," +, + " \"status\":\"OK\" } }{\"";, + final String part2 = "a\":{\"b\":{\"c\":{\"ory\":[{\"competi\":[{\"event\":[{" + "\"externalI\":{\"external\"" +, + ":[{\"id\":\"O\"} ]";, +,
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractChannelBufferTest.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractChannelBufferTest.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + * Sub protocol request sent to the server., + expectedSubprotocol = subprotocol;, + * Returns the sub protocol request sent to the server as specified in the constructor, + * Returns the sub protocol response and sent by the server. Only available after end of handshake., +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractChannelBufferTest.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + * Sub protocol request sent to the server., + expectedSubprotocol = subprotocol;, + * Returns the sub protocol request sent to the server as specified in the constructor, + * Returns the sub
[+++ b/all/pom.xml, + <propertyselector property="versions" match="^(${project.groupId}:(?!netty-example)[^:]+:jar(?::[^:]+)?)$" select="\1" />]
[+++ b/all/pom.xml, + <profile>, + <id>linux-native</id>, + <activation>, + <os>, + <family>linux</family>, + </os>, + </activation>, + <dependencies>, + <!-- All release modules -->, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport-native-epoll</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + </dependencies>, + </profile>, + <includes>io/netty/**,META-INF/native/**</includes>, + <includes>io/netty/**,META-INF/native/**</includes>]
[+++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +abstract class AbstractBootstrap<B extends AbstractBootstrap<?, C>, C extends Channel> implements Cloneable {, + private ChannelFactory<? extends C> channelFactory;, + AbstractBootstrap(AbstractBootstrap<B, C> bootstrap) {, + public B channel(Class<? extends C> channelClass) {, + return channelFactory(new BootstrapChannelFactory<C>(channelClass));, + public B channelFactory(ChannelFactory<? extends C> channelFactory) {, + final ChannelFactory<? extends C> channelFactory() {, + private static final class BootstrapChannelFactory<T extends Channel> implements ChannelFactory<T> {, + private final Class<? extends T> clazz;, + BootstrapChannelFactory(Class<? extends T> clazz) {, + public T newChannel() {, +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +abstract class AbstractBootstrap<B extends AbstractBootstrap<?, C>, C extends Channel> implements Cloneable {, + private ChannelFactory<? extends
[+++ b/all/.gitignore, +src, +++ b/all/.gitignore, +src, +++ b/all/pom.xml, + <id>unpack-sources</id>, + <phase>generate-resources</phase>, + <goals>, + <goal>unpack-dependencies</goal>, + </goals>, + <configuration>, + <classifier>sources</classifier>, + <includes>io/netty/**</includes>, + <excludes>io/netty/example/**</excludes>, + <includeGroupIds>io.netty</includeGroupIds>, + <outputDirectory>${project.basedir}/src/main/java</outputDirectory>, + <overWriteReleases>false</overWriteReleases>, + <overWriteSnapshots>true</overWriteSnapshots>, + </configuration>, + </execution>, + <execution>, + <id>unpack-jars</id>, + <outputDirectory>${project.build.directory}/classes</outputDirectory>, +++ b/all/.gitignore, +src, +++ b/all/pom.xml, + <id>unpack-sources</id>, + <phase>generate-resources</phase>, + <goals>, + <goal>unpack-dependencies</goal>, + </goals>, + <configuration>, + <classifier>sources</classifier>, + <includes>io/netty/**</includes>, + <excludes>io/netty/example/**</excludes>, + <includeGroupIds>io.netty</includeGroupIds>, + <outputDirectory>${project.basedir}/src/main/java</outputDirectory>, + <overWriteReleases>false</overWriteReleases>, + <overWriteSnapshots>true</overWriteSnapshots>, + </configuration>, + </execution>, + <execution>, + <id>unpack-jars</id>, + <outputDirectory>${project.build.directory}/classes</outputDirectory>, +++ b/pom.xml, + <module>all</module>, + <plugin>, + <artifactId>maven-source-plugin</artifactId>, + <version>2.1.2</version>, + <executions>, + <execution>,
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + Runnable postRegisterTask = doRegister();, + if (postRegisterTask != null) {, + postRegisterTask.run();, + }, + protected abstract Runnable doRegister() throws Exception;, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + Runnable postRegisterTask = doRegister();, + if (postRegisterTask != null) {, + postRegisterTask.run();, + }, + protected abstract Runnable doRegister() throws Exception;, +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, + protected Runnable doRegister() throws Exception {, + final LocalChannel peer = this.peer;, + Runnable postRegisterTask;, +, +, + // Ensure the peer's channelActive event is triggered *after* this channel's, + // channelRegistered event is triggered, so that this channel's pipeline is fully, + // initialized by ChannelInitializer., +
[+++ b/buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketShutdownOutputBySelfTest.java, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelOption;, +import io.netty.channel.WriteBufferWaterMark;, +import io.netty.channel.socket.oio.OioSocketChannel;, +import java.util.concurrent.BlockingDeque;, +import java.util.concurrent.LinkedBlockingDeque;, +import java.util.concurrent.TimeUnit;, +import static org.junit.Assert.assertNull;, +import static org.junit.Assume.assumeFalse;, + @Test(timeout = 30000), + public void testWriteAfterShutdownOutputNoWritabilityChange() throws Throwable {, + run();, + }, +, + public void testWriteAfterShutdownOutputNoWritabilityChange(Bootstrap cb) throws Throwable {, + final TestHandler h = new TestHandler();, + ServerSocket ss = new ServerSocket();, + Socket s = null;, + SocketChannel ch = null;, + try {, + ss.bind(newSocketAddress());, + cb.option(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark(2, 4));, + ch = (SocketChannel) cb.handler(h).connect(ss.getLocalSocketAddress()).sync().channel();, + assumeFalse(ch instanceof OioSocketChannel);, + assertTrue(ch.isActive());, + assertFalse(ch.isOutputShutdown());, +, + s = ss.accept();, +, +
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java, + final int port = decodeInt(addr, offset + len - 4);, + int scopeId = decodeInt(addr, offset + len - 8);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java, + // check if the URI contained a port if not set the correct one depending on the schema., + // See https://github.com/netty/netty/pull/1558, + if (wsPort == -1) {, + if ("https".equals(wsURL.getScheme())) {, + wsPort = 443;, + } else {, + wsPort = 80;, + }, + }, +]
[+++ b/all/pom.xml, + <version>4.0.12.Final</version>, +++ b/all/pom.xml, + <version>4.0.12.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.12.Final</version>, +++ b/all/pom.xml, + <version>4.0.12.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.12.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.12.Final</version>, +++ b/all/pom.xml, + <version>4.0.12.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.12.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.12.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.12.Final</version>, +++ b/all/pom.xml, + <version>4.0.12.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.12.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.12.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.12.Final</version>, +++ b/codec/pom.xml, + <version>4.0.12.Final</version>, +++ b/all/pom.xml, + <version>4.0.12.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.12.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.12.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.12.Final</version>, +++ b/codec/pom.xml, + <version>4.0.12.Final</version>, +++ b/common/pom.xml, + <version>4.0.12.Final</version>, +++ b/all/pom.xml, + <version>4.0.12.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.12.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.12.Final</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpTransferEncoding.java, + HttpTransferEncoding(boolean single) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpTransferEncoding.java, + HttpTransferEncoding(boolean single) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/CaseIgnoringComparator.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpTransferEncoding.java, + HttpTransferEncoding(boolean single) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/CaseIgnoringComparator.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, + public enum SelectedProtocol {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpTransferEncoding.java, + HttpTransferEncoding(boolean single) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/CaseIgnoringComparator.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, + public enum SelectedProtocol {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketRequestBuilder.java, + version = WebSocketVersion.V13;, + version = WebSocketVersion.V08;, + version = null;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpTransferEncoding.java, + HttpTransferEncoding(boolean single) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/CaseIgnoringComparator.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, + public enum SelectedProtocol {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketRequestBuilder.java, + version = WebSocketVersion.V13;, + version = WebSocketVersion.V08;, + version = null;, +++ b/common/src/main/java/io/netty/monitor/MonitorName.java, + return new MonitorName(group, type, name, instance);, + return instance
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/InternalAttribute.java, +, + InternalAttribute(Charset charset) {, + old.release();]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + * Sets the security getStatus of this {@link Cookie}, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + * Sets the security getStatus of this {@link Cookie}, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java, + public FullHttpRequest setProtocolVersion(HttpVersion version) {, + super.setProtocolVersion(version);, + return this;, + }, +, + @Override, + public FullHttpRequest setMethod(HttpMethod method) {, + super.setMethod(method);, + return this;, + }, +, + @Override, + public FullHttpRequest setUri(String uri) {, + super.setUri(uri);, + return this;, + }, +, + @Override, + DefaultFullHttpRequest copy = new DefaultFullHttpRequest(, + getProtocolVersion(), getMethod(), getUri(), data().copy());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + * Sets the security getStatus of this {@link Cookie}, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java,
[+++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/MapUtil.java, +/*, + * Copyright 2009 Red Hat, Inc., + *, + * Red Hat licenses this file to you under the Apache License, version 2.0, + * (the "License"); you may not use this file except in compliance with the, + * License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + int count = nioBufferCount();, + if (count == 1) {, + return out.write(internalNioBuffer(index, length));, + } else {, + }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + int count = nioBufferCount();, + if (count == 1) {, + return out.write(internalNioBuffer(index, length));, + } else {, + }, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, +import java.io.ByteArrayOutputStream;, +import java.io.IOException;, +import java.nio.channels.Channels;, +import java.nio.channels.GatheringByteChannel;, +import java.nio.channels.WritableByteChannel;, + @Test, + public void testGatheringWritesHeap() throws Exception {, + testGatheringWrites(buffer().order(order), buffer().order(order));, + }, +, + @Test, + public void testGatheringWritesDirect() throws Exception {, + testGatheringWrites(directBuffer().order(order), directBuffer().order(order));, + }, +, + @Test, + public void testGatheringWritesMixes() throws Exception {, + testGatheringWrites(buffer().order(order),
[+++ b/pom.xml, + <taskdef resource="net/sf/antcontrib/antlib.xml" />, + <exec executable="git" outputproperty="gitOutput" resultproperty="gitExitCode" failonerror="false" failifexecutionfails="false">, + <if>, + <equals arg2="0" arg1="${gitExitCode}"/>, + <then>, + <property name="buildNumber" value="${gitOutput}"/>, + </then>, + <else>, + <property name="buildNumber" value="unknown"/>, + </else>, + </if>, + <echo>Build number: ${buildNumber}</echo>]
[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, +import java.util.Collections;, +import java.util.List;, + public void shutdownGracefully() {, + shutdownGracefully(2, 15, TimeUnit.SECONDS);, + }, +, + /**, + * @deprecated {@link #shutdownGracefully(long, long, TimeUnit)} or {@link #shutdownGracefully()} instead., + */, + @Override, + @Deprecated, + public abstract void shutdown();, +, + /**, + * @deprecated {@link #shutdownGracefully(long, long, TimeUnit)} or {@link #shutdownGracefully()} instead., + */, + @Override, + @Deprecated, + public List<Runnable> shutdownNow() {, + shutdown();, + return Collections.emptyList();, + }, +, + @Override, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, +import java.util.Collections;, +import java.util.List;, + public void shutdownGracefully() {, + shutdownGracefully(2, 15, TimeUnit.SECONDS);, + }, +, + /**, + *
[+++ b/codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompSubframeDecoderTest.java, +, +, + content.release();, +, +, +, + content.release();, +, +, +, + content.release();, +, +, +, + content.release();, + content.release();, + content.release();, + content.release();, +, + content.release();, +, + content2.release();, +]
[+++ b/pom.xml, + <url>http://fisheye.jboss.org/browse/Netty</url>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>, + <tagBase>https://svn.jboss.org/repos/netty/tags</tagBase>, +++ b/pom.xml, + <url>http://fisheye.jboss.org/browse/Netty</url>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>, + <tagBase>https://svn.jboss.org/repos/netty/tags</tagBase>, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioSocketChannelConfig.java, + * will start to return {@code false}., + * will start to return {@code false}., + * {@code true} again., + * {@code true} again.]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, +import io.netty.channel.socket.DuplexChannel;, +import java.util.concurrent.Executor;, +public abstract class AbstractEpollStreamChannel extends AbstractEpollChannel implements DuplexChannel {, + public boolean isInputShutdown() {, + return fd().isInputShutdown();, + }, +, + @Override, + public boolean isOutputShutdown() {, + return fd().isOutputShutdown();, + }, +, + @Override, + public ChannelFuture shutdownOutput() {, + return shutdownOutput(newPromise());, + }, +, + @Override, + public ChannelFuture shutdownOutput(final ChannelPromise promise) {, + Executor closeExecutor = ((EpollStreamUnsafe) unsafe()).prepareToClose();, + if (closeExecutor != null) {, + closeExecutor.execute(new OneTimeTask() {, + @Override, + public void run() {, + shutdownOutput0(promise);, + }, + });, + } else {, + EventLoop loop = eventLoop();,
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java, + // Simulate that all streams have become inactive by the time the future completes., + // Simulate the future being completed., + // Simulate another stream close call being made after the context should already be closed.]
[+++ b/transport/src/main/java/io/netty/channel/ChannelPromiseAggregator.java, +import java.util.LinkedHashSet;, + pendingPromises = new LinkedHashSet<ChannelPromise>(size);]
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + closeFuture.setClosed();, + closeFuture.setClosed();, + if (closeFuture.isSuccess()) {, + // Closed already., + promise.setSuccess();, + }, +, + closeFuture.setClosed();, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + closeFuture.setClosed();, + closeFuture.setClosed();, + if (closeFuture.isSuccess()) {, + // Closed already., + promise.setSuccess();, + }, +, + closeFuture.setClosed();, +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, + protected void doClose() throws Exception {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + closeFuture.setClosed();, + closeFuture.setClosed();, + if (closeFuture.isSuccess()) {, + // Closed already., + promise.setSuccess();, + }, +, + closeFuture.setClosed();, +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, + protected void doClose() throws Exception {, +++ b/transport/src/main/java/io/netty/channel/local/LocalServerChannel.java, + protected void doClose() throws Exception {]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, +import io.netty.handler.codec.http.HttpHeaders;, + * {@link ChannelInboundHandler#userEventTriggered(ChannelHandlerContext, Object)} and check if the event was instance, + * of {@link HandshakeComplete}, the event will contain extra information about the handshake such as the request and, + * selected subprotocol., + * The Handshake was completed successfully and the channel was upgraded to websockets., + *, + * @deprecated in favor of {@link HandshakeComplete} class,, + * it provides extra information about the handshake, + @Deprecated, + /**, + * The Handshake was completed successfully and the channel was upgraded to websockets., + */, + public static final class HandshakeComplete
[+++ b/all/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/resolver/src/main/java/io/netty/resolver/DefaultHostsFileEntriesResolver.java, +import java.util.Locale;, + return entries.get(inetHost.toLowerCase(Locale.ENGLISH));, +++ b/resolver/src/main/java/io/netty/resolver/DefaultHostsFileEntriesResolver.java, +import java.util.Locale;, + return entries.get(inetHost.toLowerCase(Locale.ENGLISH));, +++ b/resolver/src/main/java/io/netty/resolver/HostsFileParser.java, +import java.util.Locale;, + String hostnameLower = hostname.toLowerCase(Locale.ENGLISH);, + if (!entries.containsKey(hostnameLower)) {, + entries.put(hostnameLower, InetAddress.getByAddress(hostname, ipBytes));, +++ b/resolver/src/main/java/io/netty/resolver/DefaultHostsFileEntriesResolver.java, +import java.util.Locale;, + return entries.get(inetHost.toLowerCase(Locale.ENGLISH));, +++ b/resolver/src/main/java/io/netty/resolver/HostsFileParser.java, +import java.util.Locale;, + String hostnameLower = hostname.toLowerCase(Locale.ENGLISH);, + if (!entries.containsKey(hostnameLower)) {, + entries.put(hostnameLower, InetAddress.getByAddress(hostname, ipBytes));, +++ b/resolver/src/test/java/io/netty/resolver/DefaultHostsFileEntriesResolverTest.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with
[+++ b/pom.xml, + <version>3.1.0.BETA2</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.1.0.BETA2</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.1.0.BETA2</developerConnection>]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/.travis.yml, +install: 'mvn install -Pfull -DskipTests']
[+++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, + public ChannelBufferType bufferType() {, + return ChannelBufferType.MESSAGE;, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, + public ChannelBufferType bufferType() {, + return ChannelBufferType.MESSAGE;, +++ b/transport/src/main/java/io/netty/channel/Channel.java, + ChannelBufferType bufferType();, +, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, + public ChannelBufferType bufferType() {, + return ChannelBufferType.MESSAGE;, +++ b/transport/src/main/java/io/netty/channel/Channel.java, + ChannelBufferType bufferType();, +, +++ b/transport/src/main/java/io/netty/channel/ChannelBufferHolder.java, + private final ChannelBufferType type;, + type = ChannelBufferType.MESSAGE;, + type = ChannelBufferType.STREAM;, + public ChannelBufferType type() {, + return type;, + switch (type) {, + case MESSAGE:, + case STREAM:, + default:, + throw new Error();, + switch (type) {, + case MESSAGE:, + case STREAM:, + default:, + throw new Error();, + switch
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + message = null;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + message = null;, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java, +, +, + /**, + * Tests if the decoder produces one and only {@link LastHttpContent} when an invalid chunk is received and, + * the connection is closed., + */, + @Test, + public void testGarbageChunk() {, + EmbeddedChannel channel = new EmbeddedChannel(new HttpResponseDecoder());, + String responseWithIllegalChunk =, + "HTTP/1.1 200 OK\r\n" +, + "Transfer-Encoding: chunked\r\n\r\n" +, + "NOT_A_CHUNK_LENGTH\r\n";, +, + channel.writeInbound(Unpooled.copiedBuffer(responseWithIllegalChunk, CharsetUtil.US_ASCII));, + assertThat(channel.readInbound(), is(instanceOf(HttpResponse.class)));, +, + // Ensure that the decoder generates the last chunk with correct decoder result., + LastHttpContent invalidChunk
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +#include <linux/socket.h> // SOL_TCP definition, +, +#ifndef _KERNEL_FASTOPEN, +#define _KERNEL_FASTOPEN, +// conditional define for TCP_FASTOPEN mostly on ubuntu, +#ifndef TCP_FASTOPEN, +#define TCP_FASTOPEN 23, +#endif, +, +// conditional define for SOL_TCP mostly on ubuntu, +#ifndef SOL_TCP, +#define SOL_TCP 6, +#endif, +#endif, +, +static int getSysctlValue(const char * property, int* returnValue) {, + int rc = -1;, + FILE *fd=fopen(property, "r");, + if (fd != NULL) {, + char buf[32] = {0x0};, + if (fgets(buf, 32, fd) != NULL) {, + *returnValue = atoi(buf);, + rc = 0;, + }, + fclose(fd);, + }, + return rc;, +}, +,
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java, + " deflate ; q=0 , *;q=0.5", "gzip",, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java, + " deflate ; q=0 , *;q=0.5", "gzip",, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, + getWebSocketLocation(req), null, false);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, +import io.netty.util.VoidEnum;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, +import io.netty.util.VoidEnum;, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, + // Decoder consumed a message but returned null., + // Probably it needs more messages., + continue;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, +import io.netty.util.VoidEnum;, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, + // Decoder consumed a message but returned null., + // Probably it needs more messages., + continue;, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, +import io.netty.util.VoidEnum;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, +import io.netty.util.VoidEnum;, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, + // Decoder consumed a message but returned null., + // Probably it needs more messages., + continue;, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, +import io.netty.util.VoidEnum;, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, +import io.netty.util.VoidEnum;, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, + // Decoder consumed a message but
[+++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java, + * channel.pipeline().addLast("readTimeoutHandler", new {@link ReadTimeoutHandler}(30));]
[+++ b/transport/src/main/java/io/netty/channel/SimpleUserEventChannelHandler.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + throw shutdownWithError("SSL_write");, + private SSLException shutdownWithError(String operations) {, + return shutdownWithError(operations, err);, + private SSLException shutdownWithError(String operation, String err) {, + return new SSLException(err);, + return new SSLHandshakeException(err);, + return sslReadErrorResult(SSL.getLastErrorNumber(), bytesConsumed, bytesProduced);, + return sslReadErrorResult(err, bytesConsumed, bytesProduced);, + private SSLEngineResult sslReadErrorResult(int err, int bytesConsumed, int bytesProduced) throws SSLException {, + // Check if we have a pending handshakeException and if so see if we need to consume all pending data from the, + // BIO first or can just shutdown and throw it now., + // This is needed so we ensure close_notify etc is
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslSessionStats.java, +, + /**, + * Returns the number of times a client presented a ticket that did not match any key in the list., + */, + public long ticketKeyFail() {, + return SSLContext.sessionTicketKeyFail(context.ctx);, + }, +, + /**, + * Returns the number of times a client did not present a ticket and we issued a new one, + */, + public long ticketKeyNew() {, + return SSLContext.sessionTicketKeyNew(context.ctx);, + }, +, + /**, + * Returns the number of times a client presented a ticket derived from an older key,, + * and we upgraded to
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, + * Gets called if a {@link Throwable} was thrown., + */, + void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;, +, + /**, +++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, + * Gets called if a {@link Throwable} was thrown., + */, + void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;, +, + /**, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java, +, + /**, + * Calls {@link ChannelHandlerContext#fireExceptionCaught(Throwable)} to forward, + * to the next {@link ChannelHandler} in the {@link ChannelPipeline}., + *, + * Sub-classes may override this method to change behavior., + */, + @Override, + public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause), + throws Exception
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, + if (handshaker != null) {, + } else {, + ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);, + }, + ((FullHttpRequest) msg).release();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, + if (handshaker != null) {, + } else {, + ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);, + }, + ((FullHttpRequest) msg).release();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, + WebSocketServerProtocolHandshakeHandler(String websocketPath, String subprotocols,, + try {, + } finally {, + req.release();, + }]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java, +, + /**, + * Returns {@code true} if direct {@link ByteBuf}'s are pooled, + */, + boolean isDirectBufferPooled();, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java, +, + /**, + * Returns {@code true} if direct {@link ByteBuf}'s are pooled, + */, + boolean isDirectBufferPooled();, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, + @Override, + public boolean isDirectBufferPooled() {, + return directArenas != null;, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java, +, + /**, + * Returns {@code true} if direct {@link ByteBuf}'s are pooled, + */, + boolean isDirectBufferPooled();, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, + @Override, + public boolean isDirectBufferPooled() {, + return directArenas != null;, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledByteBufAllocator.java,
[+++ b/transport-native-epoll/pom.xml, + <manifestEntries>, + <Bundle-NativeCode>META-INF/native/libnetty-transport-native-epoll.so; osname=linux, processor=x86_64"</Bundle-NativeCode>, + </manifestEntries>]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + pipeline.remove0(this);, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + pipeline.remove0(this);, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, + remove0(ctx);, + remove0(ctx);, + void remove0(DefaultChannelHandlerContext ctx) {, + callHandlerRemoved(ctx);, + callHandlerRemoved(oldCtx);, + private void callHandlerRemoved(final DefaultChannelHandlerContext ctx) {, + callHandlerRemoved0(ctx);, + callHandlerRemoved0(ctx);, + private void callHandlerRemoved0(final DefaultChannelHandlerContext ctx) {]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + if (executor.inEventLoop()) {, + if (executor.inEventLoop()) {, + if (executor.inEventLoop()) {, + if (executor.inEventLoop()) {]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingClientSocketChannel.java, +import java.nio.channels.NotYetConnectedException;, +import org.jboss.netty.buffer.ChannelBuffers;, +import org.jboss.netty.channel.ChannelException;, +import org.jboss.netty.handler.codec.http.HttpResponseStatus;, + final HttpTunnelingSocketChannelConfig config;, + volatile boolean requestHeaderWritten;, + final SocketChannel realChannel;, + DefaultChannelPipeline channelPipeline = new DefaultChannelPipeline();, + channelPipeline.addLast("decoder", new HttpResponseDecoder());, + channelPipeline.addLast("encoder", new HttpRequestEncoder());, + channelPipeline.addLast("handler", handler);, + realChannel = clientSocketChannelFactory.newChannel(channelPipeline);, +, + return realChannel.getLocalAddress();, + return realChannel.getRemoteAddress();, + return realChannel.isBound();, + return realChannel.isConnected();, + return realChannel.getInterestOps();, + return realChannel.isWritable();, + void bindReal(final SocketAddress localAddress, final ChannelFuture future) {, + realChannel.bind(localAddress).addListener(new ChannelFutureListener() {, + future.setSuccess();, + } else {, + future.setFailure(f.getCause());, + }, + }, + });,
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + private void validatePromise(ChannelPromise promise, boolean allowUnsafe) {, +, + if (promise.isDone()) {, + throw new IllegalArgumentException("promise already done: " + promise);, + }, +, + // check if the promise is of type DefaultChannelPromise and if so check if its validated already., + DefaultChannelPromise p = null;, + if (promise instanceof DefaultChannelPromise) {, + p = (DefaultChannelPromise) promise;, + if (p.isValidated()) {, + return;, + }, + }, +, +, + if (p != null) {, + // mark as validated, + p.validated();, + }, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + private void validatePromise(ChannelPromise promise, boolean allowUnsafe) {, +,
[+++ b/pom.xml, + <tcnative.version>1.1.33.Fork20</tcnative.version>]
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpHeaders.java, + message.setHeader(Names.SCHEME, scheme);, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpHeaders.java, + message.setHeader(Names.SCHEME, scheme);, +++ b/pom.xml, + <version>1.6.6</version>, + <version>1.1</version>, + <version>1.8</version>, + <version>2.3.2</version>]
[+++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java, + * if the specified handler is {@code null}, + * if the specified handler is {@code null}, + * if the specified handler is {@code null}, + * if the specified handler is {@code null}, + * if the specified baseName or handler is {@code null}, + * if the specified baseName or handler is {@code null}, + * if the specified baseName or handler is {@code null}, + * if the specified baseName or handler is {@code null}, + * if the specified old handler or new handler is, + * if the specified old
[+++ b/src/main/java/org/jboss/netty/channel/timeout/ChannelReadTimeoutException.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2009, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version., + *, +
[+++ b/all/pom.xml, + <version>4.1.20.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.20.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.20.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.20.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.20.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, + <version>4.1.20.Final-SNAPSHOT</version>, +
[+++ b/pom.xml, + <version>3.1.0.ALPHA4</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.1.0.ALPHA4</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.1.0.ALPHA4</developerConnection>]
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + s.chunk.initBufWithSubpage(buf, null, handle, reqCapacity);, + boolean success = c.allocate(buf, reqCapacity, normCapacity);, + assert success;, + void free(PoolChunk<T> chunk, ByteBuffer nioBuffer, long handle, int normCapacity, PoolThreadCache cache) {, + if (cache != null && cache.add(this, chunk, nioBuffer, handle, normCapacity, sizeClass)) {, + freeChunk(chunk, handle, sizeClass, nioBuffer);, + void freeChunk(PoolChunk<T> chunk, long handle, SizeClass sizeClass, ByteBuffer nioBuffer) {, + destroyChunk = !chunk.parent.free(chunk, handle, nioBuffer);, + ByteBuffer oldNioBuffer = buf.tmpNioBuf;, + free(oldChunk, oldNioBuffer, oldHandle, oldMaxLength, buf.cache);, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + s.chunk.initBufWithSubpage(buf, null, handle, reqCapacity);, + boolean success = c.allocate(buf, reqCapacity, normCapacity);, + assert success;, + void free(PoolChunk<T> chunk, ByteBuffer nioBuffer,
[+++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, +import java.util.Arrays;, + * Loads the first available library in the collection with the specified, + * {@link ClassLoader}., + *, + * @throws IllegalArgumentException, + * if none of the given libraries load successfully., + */, + public static void loadFirstAvailable(ClassLoader loader, String... names) {, + for (String name : names) {, + try {, + NativeLibraryLoader.load(name, loader);, + return;, + } catch (Throwable t) {, + logger.debug("Unable to load the library: " + name + '.', t);, + }, + }, + throw new IllegalArgumentException("Failed to load any of the given libraries: ", + +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + private boolean tooLongFrameFound;, + tooLongFrameFound = false;, + if (tooLongFrameFound) {, + this.currentMessage = null;, + // already detect the too long frame so just discard the content, + return;, + }, +, + tooLongFrameFound = true;, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + private boolean tooLongFrameFound;, + tooLongFrameFound = false;, + if (tooLongFrameFound) {, + this.currentMessage = null;, + // already detect the too long frame so just discard the content, + return;, + }, +, + tooLongFrameFound = true;, +, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java, + @Test, + HttpContent chunk3 = new DefaultHttpContent(Unpooled.copiedBuffer("test3", CharsetUtil.US_ASCII));, +, + assertFalse(embedder.writeInbound(chunk1.copy()));, + try {,
[+++ b/handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java, + SslUtils.handleHandshakeFailure(ctx, e, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java, + SslUtils.handleHandshakeFailure(ctx, e, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + * {@link #setHandshakeFailure(ChannelHandlerContext, Throwable, boolean, boolean, boolean)} or, + setHandshakeFailure(ctx, CHANNEL_CLOSED, !outboundClosed, handshakeStarted, false);, + // ensure we always flush and close the channel., + setHandshakeFailure(ctx, cause, true, false, true);, + setHandshakeFailure(ctx, cause, true, true, false);, + private void setHandshakeFailure(ChannelHandlerContext ctx, Throwable cause, boolean closeInbound,, + boolean notify, boolean alwaysFlushAndClose) {, + if (handshakePromise.tryFailure(cause) || alwaysFlushAndClose) {, + SslUtils.handleHandshakeFailure(ctx, cause, notify);, + }, + if (handshakePromise.tryFailure(HANDSHAKE_TIMED_OUT)) {, + SslUtils.handleHandshakeFailure(ctx, HANDSHAKE_TIMED_OUT, true);, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java, + SslUtils.handleHandshakeFailure(ctx, e, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + * {@link
[+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java, + }, + if (mqttVersion == MqttVersion.MQTT_3_1_1) {, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java, + }, + if (mqttVersion == MqttVersion.MQTT_3_1_1) {, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java, +public final class MqttConnAckVariableHeader {, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java, + }, + if (mqttVersion == MqttVersion.MQTT_3_1_1) {, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java, +public final class MqttConnAckVariableHeader {, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java, +public final class MqttConnectPayload {, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java, + }, + if (mqttVersion == MqttVersion.MQTT_3_1_1) {, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java, +public final class MqttConnAckVariableHeader {, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java, +public final class MqttConnectPayload {, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectReturnCode.java, + * Return Code of {@link MqttConnAckMessage}, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java, + }, + if (mqttVersion == MqttVersion.MQTT_3_1_1) {, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java, +public final class
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + }, + notifyClosed(stream);, + removeStream(stream);, + }, + private void notifyClosed(DefaultStream stream) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + }, + notifyClosed(stream);, + removeStream(stream);, + }, + private void notifyClosed(DefaultStream stream) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java, +import io.netty.util.internal.PlatformDependent;, + private ChannelHandlerContext ctx;, +, + @Override, + public void onStreamClosed(Http2Stream stream) {, + try {, + // When a stream is closed, consume any remaining bytes so that they, + // are restored to the connection window., + DefaultFlowState state = state(stream);, + int unconsumedBytes = state.unconsumedBytes();, + if (ctx != null && unconsumedBytes > 0) {, + connectionState().consumeBytes(ctx, unconsumedBytes);, + state.consumeBytes(ctx,
[+++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, +import io.netty.util.internal.PlatformDependent;, +import java.util.concurrent.ConcurrentMap;, +, + // We use a ConcurrentMap as a ChannelInitializer is usually shared between all Channels in a Bootstrap /, + // ServerBootstrap. This way we can reduce the memory usage compared to use Attributes., + private final ConcurrentMap<ChannelHandlerContext, Boolean> initMap = PlatformDependent.newConcurrentHashMap();, + // Normally this method will never be called as handlerAdded(...) should call initChannel(...) and remove, + // the handler., + if (initChannel(ctx)) {, + // we called initChannel(...) so we need to call now pipeline.fireChannelRegistered() to ensure we not, + // miss an event., + } else {, +
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, + <version>1</version>]
[+++ b/codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayDecoder.java, + // copy the ByteBuf content to a byte array, + byte[] array = new byte[msg.readableBytes()];]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java, + public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {, + ctx.fireChannelRead(msg);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java, + public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {, + ctx.fireChannelRead(msg);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, +import static io.netty.handler.codec.http.HttpVersion.*;, +, + public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {, + ctx.fireChannelRead(msg);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java, + public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {, + ctx.fireChannelRead(msg);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, +import static io.netty.handler.codec.http.HttpVersion.*;, +, + public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {, + ctx.fireChannelRead(msg);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, + public void channelRead(final ChannelHandlerContext ctx, Object msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java, + public void channelRead(ChannelHandlerContext ctx, Object
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpCodecUtil.java, +/**, + * A utility class mainly for use with HTTP codec classes, + */, + /**, + * Validates the name of a header, + *, + * @param headerName The header name being validated, + */, + static void validateHeaderName(String headerName) {, + //Check to see if the name is null, + if (headerName == null) {, + throw new NullPointerException("Header names cannot be null");, + //Go through each of the characters in the name, + for (int index = 0; index < headerName.length(); index ++) {, + //Actually get the character, + char character
[+++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java, + public ByteBuf capacity(int newCapacity) {, + leak.record();, + return super.capacity(newCapacity);, + }, +, + @Override, + public boolean release() {, + boolean deallocated = super.release();, + if (deallocated) {, + leak.close();, + } else{, + }, + return deallocated;, + }, +, + @Override, + public boolean release(int decrement) {, + boolean deallocated = super.release(decrement);, + if (deallocated) {, + leak.close();, + } else {, + leak.record();, + }, + return deallocated;]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, + * This handler does all the heavy lifting for you to run a websocket server., + *, + * It takes care of websocket handshaking as well as processing of control frames (Close, Ping, Pong). Text and Binary, + * data frames are passed to the next handler in the pipeline (implemented by you) for processing., + *, + * See <tt>io.netty.example.http.websocketx.html5.WebSocketServer</tt> for usage., + *, + * The implementation of this handler assumes that you just want to run a websocket server and not process other types, + * HTTP requests (like GET and POST).
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + if (logger.isDebugEnabled()) {, + logger.debug(, + if (logger.isDebugEnabled()) {, + logger.debug(]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, +import java.nio.ByteBuffer;, +import java.nio.CharBuffer;, +import java.nio.charset.CharacterCodingException;, +import java.nio.charset.CharsetDecoder;, +import java.nio.charset.CoderResult;, +import static io.netty.util.internal.ObjectUtil.*;, +import static io.netty.util.internal.StringUtil.*;, + private int pathEndIdx;, + this.uri = checkNotNull(uri, "uri");, + this.charset = checkNotNull(charset, "charset");, + this.maxParams = checkPositive(maxParams, "maxParams");, + // `-1` means that path end index will be initialized lazily, + pathEndIdx = hasPath ? -1 : 0;, + if (rawPath == null) {, + String rawQuery = uri.getRawQuery();, + this.uri = rawQuery == null? rawPath : rawPath + '?' + rawQuery;, + this.charset = checkNotNull(charset, "charset");, + this.maxParams = checkPositive(maxParams, "maxParams");, + pathEndIdx = rawPath.length();, + }, + @Override,
[+++ b/transport/src/main/java/io/netty/channel/DefaultEventExecutor.java, +/**, + * Default {@link SingleThreadEventExecutor} implementation which just execute all submitted task in a, + * serial fashion, + *, + */, +++ b/transport/src/main/java/io/netty/channel/DefaultEventExecutor.java, +/**, + * Default {@link SingleThreadEventExecutor} implementation which just execute all submitted task in a, + * serial fashion, + *, + */, +++ b/transport/src/main/java/io/netty/channel/EventExecutor.java, +/**, + * The {@link EventExecutor} is a special {@link ScheduledExecutorService} which comes, + * with some handy methods to see if a {@link Thread} is executed in a event loop., + * Beside this it also extends the {@link EventExecutorGroup} to allow a generic way to,
[+++ b/example/src/main/java/io/netty/example/socksproxy/SocksServerConnectHandler.java, + Promise<Channel> promise = ctx.executor().newPromise();, +++ b/example/src/main/java/io/netty/example/socksproxy/SocksServerConnectHandler.java, + Promise<Channel> promise = ctx.executor().newPromise();, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java, + @SuppressWarnings("deprecation")]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + decodeStarted = false;, +, + if (decoder != null) {, + } else {, + return c;, + }, + return null;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + decodeStarted = false;, +, + if (decoder != null) {, + } else {, + return c;, + }, + return null;, +++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientInitializer.java, + //p.addLast("aggregator", new HttpObjectAggregator(1048576));]
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +import io.netty.util.internal.LongCounter;, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, +abstract class PoolArena<T> implements PoolArenaMetric {, + private final List<PoolChunkListMetric> chunkListMetrics;, +, + // Metrics for allocations and deallocations, + private long allocationsTiny;, + private long allocationsSmall;, + private long allocationsNormal;, + // We need to use the LongCounter here as this is not guarded via synchronized block., + private final LongCounter allocationsHuge = PlatformDependent.newLongCounter();, +, + private long deallocationsTiny;, + private long deallocationsSmall;, + private long deallocationsNormal;, + // We need to use the LongCounter here as this is not guarded via synchronized block., + private final LongCounter
[+++ b/common/src/test/java/io/netty/util/concurrent/NonStickyEventExecutorGroupTest.java, + futures.add(executor.submit(new Runnable() {, + }));]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + if (pipeline.isInboundShutdown()) {, + return;, + }, +, + if (findContextInbound() == next) {, + } else {, + // Pipeline changed since the task was submitted; try again., + fireInboundBufferUpdated0();, + if (findContextInbound() == next) {, + } else {, + // Pipeline changed since the task was submitted; try again., + fireChannelReadSuspended();, + }]
[+++ b/COPYRIGHT.txt, +trustin Trustin Heuiseung Lee]
[+++ b/common/src/main/java/io/netty/util/ThreadDeathWatcher.java, + // visible for testing, + static final ThreadFactory threadFactory;, + // because the ThreadDeathWatcher is a singleton, tasks submitted to it can come from arbitrary threads and, + // this can trigger the creation of a thread from arbitrary thread groups; for this reason, the thread factory, + // must not be sticky about its thread group, + threadFactory = new DefaultThreadFactory(poolName, true, Thread.MIN_PRIORITY, null);, +++ b/common/src/main/java/io/netty/util/ThreadDeathWatcher.java, + // visible for testing, + static final ThreadFactory threadFactory;, + // because the ThreadDeathWatcher is a singleton, tasks submitted to it can come from arbitrary threads and, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslSessionContext.java, +import org.apache.tomcat.jni.SessionTicketKey;, + * @deprecated use {@link #setTicketKeys(OpenSslSessionTicketKey...)}., + @Deprecated, + * Sets the SSL session ticket keys of this context., + */, + public void setTicketKeys(OpenSslSessionTicketKey... keys) {, + if (keys == null) {, + throw new NullPointerException("keys");, + }, + SessionTicketKey[] ticketKeys = new SessionTicketKey[keys.length];, + for (int i = 0; i < ticketKeys.length; i++) {, + ticketKeys[i] = keys[i].key;, + }, + SSLContext.setSessionTicketKeys(context, ticketKeys);, + }, +, + /**, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslSessionContext.java, +import org.apache.tomcat.jni.SessionTicketKey;, + * @deprecated use {@link #setTicketKeys(OpenSslSessionTicketKey...)}., + @Deprecated, + * Sets the SSL session ticket keys of this context., + */,
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, + final ChannelFuture bindFuture;, + bindFuture = newChannel(channelFactory, localAddress);, + ch = (DatagramChannel) bindFuture.channel();, + private ChannelFuture newChannel(, + ChannelFuture bindFuture = b.bind(localAddress);, + bindFuture.channel().closeFuture().addListener(new ChannelFutureListener() {, + return bindFuture;, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, + final ChannelFuture bindFuture;, + bindFuture = newChannel(channelFactory, localAddress);, + ch = (DatagramChannel) bindFuture.channel();, + private ChannelFuture newChannel(, + ChannelFuture bindFuture = b.bind(localAddress);, + bindFuture.channel().closeFuture().addListener(new ChannelFutureListener() {, + return bindFuture;, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java, + logger.debug("{} WRITE: [{}: {}], {}", parent.ch, id, nameServerAddr, question);, + sendQuery(query, nameServerAddr);, + }, +, + private void sendQuery(final DnsQuery query, final InetSocketAddress nameServerAddr) {, + if (parent.bindFuture.isDone()) {, + writeQuery(query, nameServerAddr);,
[+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java, +import java.util.List;, + List<Integer> minMax = (List<Integer>) value;, + setInitMaxStreams(SctpStandardSocketOptions.InitMaxStreams.create(minMax.get(0), minMax.get(1)));]
[+++ b/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java, + try {, + } catch (IOException e) {, + // If we receive an IOException here its because the Selector is messed up. Let's rebuild, + // the selector and retry. https://github.com/netty/netty/issues/8566, + rebuildSelector0();, + handleLoopException(e);, + continue;, + }, +++ b/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java, + try {, + } catch (IOException e) {, + // If we receive an IOException here its because the Selector is messed up. Let's rebuild, + // the selector and retry. https://github.com/netty/netty/issues/8566, + rebuildSelector0();, + handleLoopException(e);, + continue;, + }, +++ b/transport/src/test/java/io/netty/channel/nio/NioEventLoopTest.java, +import io.netty.channel.SelectStrategy;, +import io.netty.channel.SelectStrategyFactory;, +import io.netty.util.IntSupplier;, +import io.netty.util.concurrent.DefaultThreadFactory;, +import java.io.IOException;, +import
[+++ b/common/src/main/java/io/netty/util/internal/ThrowableUtil.java, +import java.io.ByteArrayOutputStream;, +import java.io.IOException;, +import java.io.PrintStream;, +, +, + /**, + * Gets the stack trace from a Throwable as a String., + *, + * @param cause the {@link Throwable} to be examined, + * @return the stack trace as generated by {@link Throwable#printStackTrace(java.io.PrintWriter)} method., + */, + public static String stackTraceToString(Throwable cause) {, + ByteArrayOutputStream out = new ByteArrayOutputStream();, + PrintStream pout = new PrintStream(out);, + cause.printStackTrace(pout);, + pout.flush();, + try {, + return new String(out.toByteArray());, + } finally {, + try {, + out.close();, + } catch (IOException ignore) {, + // ignore as
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, + private static boolean isValidIp4Word(String word) {]
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +++ b/codec/src/test/java/io/netty/handler/codec/ByteToMessageDecoderTest.java, +import io.netty.util.CharsetUtil;, +import java.util.concurrent.atomic.AtomicInteger;, +, + // See https://github.com/netty/netty/pull/3263, + @Test, + public void testFireChannelReadCompleteOnlyWhenDecoded() {, + final AtomicInteger readComplete = new AtomicInteger();, + EmbeddedChannel ch = new EmbeddedChannel(new ByteToMessageDecoder() {, + @Override, + protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {, + // Do nothing, + }, + }, new ChannelInboundHandlerAdapter() {, + @Override, + public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {, + readComplete.incrementAndGet();, + }, + });, + Assert.assertFalse(ch.writeInbound(Unpooled.copiedBuffer("test", CharsetUtil.US_ASCII)));, + Assert.assertFalse(ch.finish());, + Assert.assertEquals(0, readComplete.get());, + }, +, + // See https://github.com/netty/netty/pull/3263, + @Test, + public void testFireChannelReadCompleteWhenDecodeOnce()
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + return pipeline.newPromise();, + return pipeline.newProgressivePromise();, + return pipeline.newSucceededFuture();, + return pipeline.newFailedFuture(cause);, + return pipeline.voidPromise();, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + return pipeline.newPromise();, + return pipeline.newProgressivePromise();, + return pipeline.newSucceededFuture();, + return pipeline.newFailedFuture(cause);, + return pipeline.voidPromise();, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +public interface Channel extends AttributeMap, ChannelOutboundInvoker, Comparable<Channel> {, + @Override, + @Override, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + return pipeline.newPromise();, + return pipeline.newProgressivePromise();, + return pipeline.newSucceededFuture();, + return pipeline.newFailedFuture(cause);, + return pipeline.voidPromise();, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +public interface Channel extends AttributeMap, ChannelOutboundInvoker, Comparable<Channel> {, + @Override, + @Override, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, +public interface ChannelHandlerContext extends AttributeMap, ChannelInboundInvoker, ChannelOutboundInvoker {, + @Override, + @Override, + @Override, + @Override, + @Override,
[+++ b/all/pom.xml, + <version>4.0.11.Final</version>, +++ b/all/pom.xml, + <version>4.0.11.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.11.Final</version>, +++ b/all/pom.xml, + <version>4.0.11.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.11.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.11.Final</version>, +++ b/all/pom.xml, + <version>4.0.11.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.11.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.11.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.11.Final</version>, +++ b/all/pom.xml, + <version>4.0.11.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.11.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.11.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.11.Final</version>, +++ b/codec/pom.xml, + <version>4.0.11.Final</version>, +++ b/all/pom.xml, + <version>4.0.11.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.11.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.11.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.11.Final</version>, +++ b/codec/pom.xml, + <version>4.0.11.Final</version>, +++ b/common/pom.xml, + <version>4.0.11.Final</version>, +++ b/all/pom.xml, + <version>4.0.11.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.11.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.11.Final</version>, +++ b/codec-socks/pom.xml, +
[+++ b/pom.xml, + <version>[3.0.4,)</version>]
[+++ /dev/null, +++ /dev/null, +++ b/common/src/test/templates/io/netty/util/collection/KObjectHashMapTest.template, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the, + * "License"); you may not use this file except in compliance with the License. You may obtain a, + * copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + if (applicationProtocol != null) {, + } else {, + this.applicationProtocol = null;, + }]
[+++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, + checkIndex(index);, + int bytesToCopy = Math.min(capacity() - index, dst.remaining());, + if (bytesToCopy == 0) {, + if (dst.isDirect()) {, + // Copy to direct memory, + long dstAddress = PlatformDependent.directBufferAddress(dst);, + PlatformDependent.copyMemory(addr(index), dstAddress + dst.position(), bytesToCopy);, + // Copy to array, + PlatformDependent.copyMemory(addr(index), dst.array(), dst.arrayOffset() + dst.position(), bytesToCopy);, +, + dst.position(dst.position() + bytesToCopy);, + return this;, + getBytes(readerIndex, dst);, +, + int length = src.remaining();, + if (length == 0) {, + return this;, + if (src.isDirect()) {, + // Copy from direct memory, + long srcAddress = PlatformDependent.directBufferAddress(src);, + PlatformDependent.copyMemory(srcAddress + src.position(), addr(index), src.remaining());, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, + if (!line.isEmpty()) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, + if (!line.isEmpty()) {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpInvalidMessageTest.java, +import java.util.Random;, +]
[+++ b/pom.xml, + <!-- always produce osgi bundles -->, + <plugin>, + <groupId>org.apache.felix</groupId>, + <artifactId>maven-bundle-plugin</artifactId>, + <version>2.3.7</version>, + <extensions>true</extensions>, + </plugin> , +++ b/pom.xml, + <!-- always produce osgi bundles -->, + <plugin>, + <groupId>org.apache.felix</groupId>, + <artifactId>maven-bundle-plugin</artifactId>, + <version>2.3.7</version>, + <extensions>true</extensions>, + </plugin> , +++ b/testsuite-osgi/testsuite-osgi-deps/pom.xml, + * DO NOT install netty-transport-rxtx bundle due to rxtx depencency:, + * , + <!--, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport-rxtx</artifactId>, + <version>${project.version}</version>, + </dependency>, + -->, +++ b/pom.xml, + <!-- always produce osgi bundles -->, + <plugin>, + <groupId>org.apache.felix</groupId>, + <artifactId>maven-bundle-plugin</artifactId>, + <version>2.3.7</version>, + <extensions>true</extensions>, + </plugin> , +++ b/testsuite-osgi/testsuite-osgi-deps/pom.xml, +
[+++ b/pom.xml, +++ b/pom.xml, +++ b/src/main/java/org/jboss/netty/channel/socket/sctp/DefaultNioSctpChannelConfig.java, +/*, + * Copyright 2011 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF
[+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompSubframeDecoder.java, + String commandStr = readLine(in, 16);, + AppendableCharSequence buf = new AppendableCharSequence(128);, + boolean headerRead = readHeader(headers, buf, buffer);, + if (!headerRead) {, + private String readLine(ByteBuf buffer, int initialBufferSize) {, + AppendableCharSequence buf = new AppendableCharSequence(initialBufferSize);, + //do nothing, + invalidLineLength();, + private boolean readHeader(StompHeaders headers, AppendableCharSequence buf, ByteBuf buffer) {, + buf.reset();, + int lineLength = 0;, + String key = null;, + boolean valid = false;, + for (;;) {, + byte nextByte = buffer.readByte();, +, + if (nextByte == StompConstants.COLON && key == null) {, + key = buf.toString();, + valid = true;,
[+++ b/all/pom.xml, +++ b/all/pom.xml, +++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E> {, +, + public ObjectArray(E[] array, int offset, int length) {, + super(array, offset, length);, + }, +, + @Override, + public E[] array() {, + return (E[]) super.array();, + }, +}, +++ b/all/pom.xml, +++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E> {, +, + public ObjectArray(E[] array, int offset, int length) {, + super(array, offset, length);, + }, +, + @Override, + public E[] array() {, + return (E[]) super.array();, + }, +}, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return writerIndex > readerIndex;,
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + String engine = SystemPropertyUtil.get("io.netty.handler.ssl.openssl.engine", null);, + if (engine == null) {, + logger.debug("Initialize netty-tcnative using engine: 'default'");, + } else {, + logger.debug("Initialize netty-tcnative using engine: '{}'", engine);, + }, + initializeTcNative(engine);, + private static boolean initializeTcNative(String engine) throws Exception {, + return Library.initialize("provided", engine);]
[+++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, +/**, + * {@link Bootstrap} is a helper class that makes it easy to bootstrap a {@link Channel}. It support, + * method-chaining to provide an easy way to configure the {@link Bootstrap}., + *, + */, + /**, + * The {@link EventLoopGroup} which is used to handle all the events for the to-be-creates, + * {@link Channel}, + */, + /**, + * The {@link Class} which is used to create {@link Channel} instances from., + * You either use this or {@link #channelFactory(ChannelFactory)} if your, + * {@link Channel} implementation has no no-args constructor.,
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + public ByteBuffer nioBuffer(int index, int length) {, + return internalNioBuffer(index, length).slice();, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + public ByteBuffer nioBuffer(int index, int length) {, + return internalNioBuffer(index, length).slice();, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * Internal use only: Exposes the internal NIO buffer., + */, + ByteBuffer internalNioBuffer(int index, int length);, +, + /**, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + public ByteBuffer nioBuffer(int index, int length) {, + return internalNioBuffer(index, length).slice();, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * Internal use only: Exposes the internal NIO buffer., + */, + ByteBuffer internalNioBuffer(int index, int
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2ConnectionDecoder.java, + public Http2FrameListener frameListener() {, + return delegate.frameListener();, + }, +, + @Override, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2ConnectionDecoder.java, + public Http2FrameListener frameListener() {, + return delegate.frameListener();, + }, +, + @Override, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + public Http2FrameListener frameListener() {, + return listener;, + }, +, + @Override, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2ConnectionDecoder.java, + public Http2FrameListener frameListener() {, + return delegate.frameListener();, + }, +, + @Override, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + public Http2FrameListener frameListener() {, + return listener;, + }, +, + @Override, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionDecoder.java, + * Get the {@link Http2FrameListener} which will be notified when frames are decoded., + */, + Http2FrameListener frameListener();, +, + /**,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, + StringBuilder buf = buffer.get();, + StringBuilder buf = buffer.get();, + StringBuilder buf = buffer.get();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, + StringBuilder buf = buffer.get();, + StringBuilder buf = buffer.get();, + StringBuilder buf = buffer.get();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoderUtil.java, + static final ThreadLocal<StringBuilder> buffer = new ThreadLocal<StringBuilder>() {, + @Override, + public StringBuilder get() {, + StringBuilder buf = super.get();, + buf.setLength(0);, + return buf;, + }, +, + @Override, + protected StringBuilder initialValue() {, + return new StringBuilder(512);, + }, + };, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, + StringBuilder buf = buffer.get();, + StringBuilder buf = buffer.get();, + StringBuilder buf = buffer.get();, +++
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java, + RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java, + RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, + RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java, + RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, + RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpChannel.java, + RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java, + RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, + RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpChannel.java, + RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpChannel.java, + RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java, + RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, + RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpChannel.java, + RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpChannel.java, + RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();, +++
[+++ b/all/pom.xml, + <version>4.0.15.Final</version>, +++ b/all/pom.xml, + <version>4.0.15.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.15.Final</version>, +++ b/all/pom.xml, + <version>4.0.15.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.15.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.15.Final</version>, +++ b/all/pom.xml, + <version>4.0.15.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.15.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.15.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.15.Final</version>, +++ b/all/pom.xml, + <version>4.0.15.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.15.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.15.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.15.Final</version>, +++ b/codec/pom.xml, + <version>4.0.15.Final</version>, +++ b/all/pom.xml, + <version>4.0.15.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.15.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.15.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.15.Final</version>, +++ b/codec/pom.xml, + <version>4.0.15.Final</version>, +++ b/common/pom.xml, + <version>4.0.15.Final</version>, +++ b/all/pom.xml, + <version>4.0.15.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.15.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.15.Final</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayEncoder.java, +import io.netty.channel.ChannelHandler.Sharable;, +@Sharable]
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java, + ByteBuf[] certs = PemReader.readCertificates(certChainFile);, + try {, + for (ByteBuf buf: certs) {, + } finally {, + for (ByteBuf buf: certs) {, + buf.release();, + }, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java, + ByteBuf[] certs = PemReader.readCertificates(certChainFile);, + try {, + for (ByteBuf buf: certs) {, + } finally {, + for (ByteBuf buf: certs) {, + buf.release();, + }, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslServerContext.java, + encodedKeyBuf.readBytes(encodedKey).release();, + ByteBuf[] certs = PemReader.readCertificates(certChainFile);, + try {, + for (ByteBuf buf: certs) {, + } finally {, + for (ByteBuf buf: certs) {, + buf.release();, + }, + }, +++
[+++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +import io.netty.channel.ChannelConfig;, + private boolean decodeWasNull;, + public void channelReadSuspended(ChannelHandlerContext ctx) throws Exception {, + if (decodeWasNull) {, + decodeWasNull = false;, + if (!ctx.channel().config().isAutoRead()) {, + ctx.read();, + }, + }, + super.channelReadSuspended(ctx);, + }, +, + @Override, + boolean wasNull = false;, +, + wasNull = true;, + wasNull = false;, + decodeWasNull = false;, + } else {, + if (wasNull) {, + decodeWasNull = true;, + }, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +import io.netty.channel.ChannelConfig;, + private boolean decodeWasNull;, + public void channelReadSuspended(ChannelHandlerContext ctx) throws Exception {, + if (decodeWasNull) {, + decodeWasNull = false;, + if
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, + * public class DataServerHandler extends {@link ChannelInboundMessageHandlerAdapter}&lt;Message&gt; {, + * public class DataServerHandler extends {@link ChannelInboundMessageHandlerAdapter}&lt;Message&gt; {]
[+++ b/handler/src/main/java/io/netty/handler/ssl/Conscrypt.java, + private static final Class<?> CONSCRYPT_CLASS = getConscryptClass();, + return CONSCRYPT_CLASS != null && PlatformDependent.javaVersion() >= 8;, + return isAvailable() && isConscryptEngine(engine, CONSCRYPT_CLASS);, + private static Class<?> getConscryptClass() {, + Class<?> conscryptClass = Class.forName("org.conscrypt.Conscrypt", true,, + getIsConscryptMethod(conscryptClass);, + return conscryptClass;, + private static boolean isConscryptEngine(SSLEngine engine, Class<?> conscryptClass) {, + Method method = getIsConscryptMethod(conscryptClass);, + private static Method getIsConscryptMethod(Class<?> conscryptClass) throws NoSuchMethodException {, + return conscryptClass.getMethod("isConscrypt", SSLEngine.class);]
[+++ b/example/src/main/java/io/netty/example/http2/client/Http2Client.java, +import io.netty.handler.ssl.SslContextBuilder;, + sslCtx = SslContextBuilder.forClient(), + .sslProvider(provider), + /* NOTE: the cipher filter may not include all ciphers required by the HTTP/2 specification., + .ciphers(Http2SecurityUtil.CIPHERS, SupportedCipherSuiteFilter.INSTANCE), + .trustManager(InsecureTrustManagerFactory.INSTANCE), + .applicationProtocolConfig(new ApplicationProtocolConfig(, + SelectedProtocol.HTTP_1_1.protocolName())), + .build();, +++ b/example/src/main/java/io/netty/example/http2/client/Http2Client.java, +import io.netty.handler.ssl.SslContextBuilder;, + sslCtx = SslContextBuilder.forClient(), + .sslProvider(provider), + /* NOTE: the cipher filter may not include all ciphers required by the HTTP/2 specification., + .ciphers(Http2SecurityUtil.CIPHERS, SupportedCipherSuiteFilter.INSTANCE), + .trustManager(InsecureTrustManagerFactory.INSTANCE), + .applicationProtocolConfig(new ApplicationProtocolConfig(, + SelectedProtocol.HTTP_1_1.protocolName())), + .build();, +++ b/example/src/main/java/io/netty/example/http2/server/Http2Server.java, +import io.netty.handler.ssl.SslContextBuilder;, + sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()), + .sslProvider(provider), + /* NOTE: the cipher filter may not include all ciphers required
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/testsuite/pom.xml, + <plugin>, + <groupId>me.normanmaurer.maven.autobahntestsuite</groupId>, + <artifactId>autobahntestsuite-maven-plugin</artifactId>, + <version>0.1.1</version>, + <configuration>, + <mainClass>io.netty.testsuite.websockets.autobahn.AutobahnServer</mainClass>, + <cases>, + <case>*</case>, + </cases>, + <excludeCases></excludeCases>, + <failOnNonStrict>false</failOnNonStrict>, + </configuration>, + <executions>, + <execution>, + <phase>test</phase>, + <goals>, + <goal>fuzzingclient</goal>, + </goals>, + </execution>, + </executions>, + </plugin>, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/testsuite/pom.xml, + <plugin>, + <groupId>me.normanmaurer.maven.autobahntestsuite</groupId>, + <artifactId>autobahntestsuite-maven-plugin</artifactId>, + <version>0.1.1</version>, + <configuration>, + <mainClass>io.netty.testsuite.websockets.autobahn.AutobahnServer</mainClass>, + <cases>, + <case>*</case>, +
[+++ b/pom.xml, + <tcnative.version>1.1.33.Fork15</tcnative.version>]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +import io.netty.util.collection.IntCollections;, + private IntObjectMap<DefaultStream> children = IntCollections.emptyMap();, + if (children == IntCollections.<DefaultStream>emptyMap()) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +import io.netty.util.collection.IntCollections;, + private IntObjectMap<DefaultStream> children = IntCollections.emptyMap();, + if (children == IntCollections.<DefaultStream>emptyMap()) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, + for (Http2Settings.PrimitiveEntry<Long> entry : settings.entries()) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +import io.netty.util.collection.IntCollections;, + private IntObjectMap<DefaultStream> children = IntCollections.emptyMap();, + if (children == IntCollections.<DefaultStream>emptyMap()) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, + for (Http2Settings.PrimitiveEntry<Long> entry : settings.entries()) {, +++ /dev/null, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +import io.netty.util.collection.IntCollections;, + private IntObjectMap<DefaultStream> children = IntCollections.emptyMap();, + if (children == IntCollections.<DefaultStream>emptyMap()) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, + for (Http2Settings.PrimitiveEntry<Long> entry : settings.entries()) {, +++ /dev/null, +++ /dev/null, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java,
[+++ b/all/pom.xml, +++ b/all/pom.xml, +++ b/pom.xml, + <id>restricted-release</id>, + <arguments>-P restricted-release,sonatype-oss-release,full</arguments>, +++ b/all/pom.xml, +++ b/pom.xml, + <id>restricted-release</id>, + <arguments>-P restricted-release,sonatype-oss-release,full</arguments>, +++ b/transport-native-epoll/pom.xml, + <executions>, + <!-- Generate the fallback JAR that does not contain the native library. -->, + <execution>, + <id>default-jar</id>, + <configuration>, + <excludes>, + <exclude>META-INF/native/**</exclude>, + </excludes>, + </configuration>, + </execution>, + <!-- Generate the JAR that contains the native library in it. -->, + <execution>, + <id>native-jar</id>, + <goals>, + <goal>jar</goal>, + </goals>, + </execution>, + </executions>]
[+++ b/testsuite-osgi/testsuite-osgi-deps/pom.xml, + <phase>test</phase>, +++ b/testsuite-osgi/testsuite-osgi-deps/pom.xml, + <phase>test</phase>, +++ b/testsuite-osgi/testsuite-osgi-exam/pom.xml, + <executions>, + <execution>, + <phase>generate-test-sources</phase>, + <goals>, + <goal>manifest</goal>, + </goals>, + </execution>, + </executions>, + <phase>test</phase>]
[+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, + private volatile Runnable fireChannelWritabilityChangedTask;, +, + incrementPendingOutboundBytes(size, false);, + decrementPendingOutboundBytes(pending, false);, + incrementPendingOutboundBytes(size, true);, + }, +, + private void incrementPendingOutboundBytes(long size, boolean invokeLater) {, + setUnwritable(invokeLater);, + decrementPendingOutboundBytes(size, true);, + }, +, + private void decrementPendingOutboundBytes(long size, boolean invokeLater) {, + setWritable(invokeLater);, + decrementPendingOutboundBytes(size, false);, + decrementPendingOutboundBytes(size, false);, + fireChannelWritabilityChanged(true);, + fireChannelWritabilityChanged(true);, + private void setWritable(boolean invokeLater) {, + fireChannelWritabilityChanged(invokeLater);, + private void setUnwritable(boolean invokeLater) {, + fireChannelWritabilityChanged(invokeLater);, + private void fireChannelWritabilityChanged(boolean invokeLater) {, + final ChannelPipeline pipeline = channel.pipeline();, + if (invokeLater) {, + Runnable task = fireChannelWritabilityChangedTask;, + if (task == null) {,
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + cbuf.addComponent(true, EMPTY_BUFFER);, + assertEquals(1, composite.refCnt());, + assertEquals(5, buffer.refCnt());, + assertEquals(0, composite.refCnt());, + assertEquals(1, buffer.refCnt());, + assertEquals(0, buffer.refCnt());, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + cbuf.addComponent(true, EMPTY_BUFFER);, + assertEquals(1, composite.refCnt());, + assertEquals(5, buffer.refCnt());, + assertEquals(0, composite.refCnt());, + assertEquals(1, buffer.refCnt());, + assertEquals(0, buffer.refCnt());, +++ b/buffer/src/test/java/io/netty/buffer/UnsafeByteBufUtilTest.java, + byte[] testData = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};, + byte[] testData = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};, + assertEquals(pageSize, b1.array().length);, + assertArrayEquals(b1.array(), b2.array());, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + cbuf.addComponent(true, EMPTY_BUFFER);, + assertEquals(1, composite.refCnt());, + assertEquals(5, buffer.refCnt());, + assertEquals(0, composite.refCnt());, + assertEquals(1, buffer.refCnt());, + assertEquals(0, buffer.refCnt());, +++ b/buffer/src/test/java/io/netty/buffer/UnsafeByteBufUtilTest.java, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + return ((java.security.cert.X509Certificate) peer[0]).getSubjectX500Principal();, + return ((java.security.cert.X509Certificate) local[0]).getIssuerX500Principal();]
[+++ b/pom.xml, + <version>3.0.0.CR5</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.0.0.CR5</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.0.0.CR5</developerConnection>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + @Override, + protected void freeInboundMessage(Object msg) throws Exception {, + if (decoder == null) {, + // if the decoder was null we returned the original message so we are not allowed to free it, + return;, + }, + super.freeInboundMessage(msg);, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + @Override, + protected void freeInboundMessage(Object msg) throws Exception {, + if (decoder == null) {, + // if the decoder was null we returned the original message so we are not allowed to free it, + return;, + }, + super.freeInboundMessage(msg);, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + @Override, +
[+++ b/pom.xml, + <version>6</version>]
[+++ b/pom.xml, + <mkdir dir="${basedir}/target" />]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, + || statusCode >= 1012 && statusCode <= 2999) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, + || statusCode >= 1012 && statusCode <= 2999) {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoderTest.java]
[+++ b/pom.xml, + -nopackagediagram, +++ b/pom.xml, + -nopackagediagram, +++ b/src/javadoc/overview.html, +<div style="text-align: center;"><img src="http://www.jboss.org/file-access/default/members/netty/freezone/guide/3.1/html/images/architecture.png"></div>]
[+++ b/pom.xml, + <groupId>com.twitter</groupId>, + <artifactId>hpack</artifactId>, + <version>0.10.1</version>, + </dependency>, + <dependency>]
[+++ b/common/src/main/java/io/netty/util/concurrent/OrderedEventExecutor.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBuf.java, + public ByteBuf asReadOnly() {, + recordLeakNonRefCountingOperation(leak);, + return new AdvancedLeakAwareByteBuf(super.asReadOnly(), leak);, + }, +, + @Override, + public boolean isReadOnly() {, + recordLeakNonRefCountingOperation(leak);, + return super.isReadOnly();, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBuf.java, + public ByteBuf asReadOnly() {, + recordLeakNonRefCountingOperation(leak);, + return new AdvancedLeakAwareByteBuf(super.asReadOnly(), leak);, + }, +, + @Override, + public boolean isReadOnly() {, + recordLeakNonRefCountingOperation(leak);, + return super.isReadOnly();, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/SimpleLeakAwareByteBuf.java, +, + @Override, + public ByteBuf asReadOnly() {, + return new SimpleLeakAwareByteBuf(super.asReadOnly(), leak);, + }, +++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBuf.java, + public ByteBuf asReadOnly() {, + recordLeakNonRefCountingOperation(leak);, + return new AdvancedLeakAwareByteBuf(super.asReadOnly(), leak);,
[+++ b/transport-native-epoll/src/main/c/netty_epoll_linuxsocket.c, +// SO_BUSY_POLL is defined in linux 3.11. We define this here so older kernels can compile., +#ifndef SO_BUSY_POLL, +#define SO_BUSY_POLL 46, +#endif, +, +static void netty_epoll_linuxsocket_setSoBusyPoll(JNIEnv* env, jclass clazz, jint fd, jint optval) {, + netty_unix_socket_setOption(env, fd, SOL_SOCKET, SO_BUSY_POLL, &optval, sizeof(optval));, +}, +, +static jint netty_epoll_linuxsocket_getSoBusyPoll(JNIEnv* env, jclass clazz, jint fd) {, + int optval;, + if (netty_unix_socket_getOption(env, fd, SOL_SOCKET, SO_BUSY_POLL, &optval, sizeof(optval)) == -1) {, + return -1;, + }, + return optval;, +}, +, + { "setSoBusyPoll", "(II)V", (void *) netty_epoll_linuxsocket_setSoBusyPoll },, + { "getSoBusyPoll", "(I)I", (void *) netty_epoll_linuxsocket_getSoBusyPoll },, +++ b/transport-native-epoll/src/main/c/netty_epoll_linuxsocket.c, +// SO_BUSY_POLL is
[+++ b/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java, +import io.netty.util.internal.StringUtil;, +, + * A {@link ByteBuf} implementation that wraps another buffer to prevent a user from increasing or decreasing the, + * wrapped buffer's reference count., +, + private SwappedByteBuf swappedBuf;, + buf.capacity(newCapacity);, + return this;, + if (endianness == null) {, + throw new NullPointerException("endianness");, + }, + if (endianness == order()) {, + return this;, + }, +, + SwappedByteBuf swappedBuf = this.swappedBuf;, + if (swappedBuf == null) {, + this.swappedBuf = swappedBuf = new SwappedByteBuf(this);, + }, + return swappedBuf;, + buf.readerIndex(readerIndex);, + return this;, + buf.writerIndex(writerIndex);, + return this;, + buf.setIndex(readerIndex,
[+++ b/transport/src/main/java/io/netty/channel/ChannelFlushPromiseNotifier.java, + cp.promise().tryFailure(cause);, + cp.promise().setFailure(cause);, + cp.promise().tryFailure(cause2);, + cp.promise().setFailure(cause2);, + cp.promise().trySuccess();, + cp.promise().setSuccess();, + cp.promise().tryFailure(cause);, + cp.promise().setFailure(cause);, + ChannelPromise promise();, + public ChannelPromise promise() {, +++ b/transport/src/main/java/io/netty/channel/ChannelFlushPromiseNotifier.java, + cp.promise().tryFailure(cause);, + cp.promise().setFailure(cause);, + cp.promise().tryFailure(cause2);, + cp.promise().setFailure(cause2);, + cp.promise().trySuccess();, + cp.promise().setSuccess();, + cp.promise().tryFailure(cause);, + cp.promise().setFailure(cause);, + ChannelPromise promise();, + public ChannelPromise promise() {, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPromise.java, + public ChannelPromise promise() {]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/UniformStreamByteDistributor.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the, + * "License"); you may not use this file except in compliance with the License. You may obtain a, + * copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express, + *
[+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +import io.netty.util.internal.FastThreadLocal;, + final class PoolThreadLocalCache extends FastThreadLocal<PoolThreadCache> {, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +import io.netty.util.internal.FastThreadLocal;, + final class PoolThreadLocalCache extends FastThreadLocal<PoolThreadCache> {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoderUtil.java, +import io.netty.util.internal.FastThreadLocal;, +, + static final ThreadLocal<StringBuilder> buffer = new FastThreadLocal<StringBuilder>() {, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +import io.netty.util.internal.FastThreadLocal;, + final class PoolThreadLocalCache extends FastThreadLocal<PoolThreadCache> {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoderUtil.java, +import io.netty.util.internal.FastThreadLocal;, +, + static final ThreadLocal<StringBuilder> buffer = new FastThreadLocal<StringBuilder>() {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderDateFormat.java, +import io.netty.util.internal.FastThreadLocal;, +, + new FastThreadLocal<HttpHeaderDateFormat>() {, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +import io.netty.util.internal.FastThreadLocal;, + final class PoolThreadLocalCache extends FastThreadLocal<PoolThreadCache> {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoderUtil.java, +import io.netty.util.internal.FastThreadLocal;, +, + static final ThreadLocal<StringBuilder> buffer = new FastThreadLocal<StringBuilder>() {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderDateFormat.java, +import io.netty.util.internal.FastThreadLocal;,
[+++ b/pom.xml, + <version>1.2.1.Final</version>]
[+++ b/all/pom.xml, + <version>4.1.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.14.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.14.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.14.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.14.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, + <version>4.1.14.Final-SNAPSHOT</version>, +
[+++ b/common/src/main/java/io/netty/util/concurrent/FastThreadLocal.java, + * A special variant of {@link ThreadLocal} that yields higher access performance when accessed from a]
[+++ b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32LengthFieldPrepender.java, + CodedOutputStream.newInstance(new ByteBufOutputStream(out), headerLen);]
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java, +import java.util.regex.Pattern;, + private static final Pattern SEARCH_DOMAIN_PATTERN = Pattern.compile("\\s+");, + // May contain more then one entry, either seperated by whitespace or tab., + // See https://linux.die.net/man/5/resolver, + String[] domains = SEARCH_DOMAIN_PATTERN.split(line.substring(i));, + Collections.addAll(searchDomains, domains);, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java, +import java.util.regex.Pattern;, + private static final Pattern SEARCH_DOMAIN_PATTERN = Pattern.compile("\\s+");, + // May contain more then one entry, either seperated by whitespace or tab., + // See https://linux.die.net/man/5/resolver, + String[] domains = SEARCH_DOMAIN_PATTERN.split(line.substring(i));, + Collections.addAll(searchDomains, domains);, +++ b/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java, + public void searchDomainsWithMultipleSearchSeperatedByWhitespace() throws IOException {, + File f = buildFile("search linecorp.local squarecorp.local\n" +, + "nameserver 127.0.0.2\n");, + List<String> domains
[+++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, + //new LoggingHandler(LogLevel.INFO),, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, + //new LoggingHandler(LogLevel.INFO),, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + //new LoggingHandler(LogLevel.INFO),, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, + //new LoggingHandler(LogLevel.INFO),, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + //new LoggingHandler(LogLevel.INFO),, +++ b/example/src/main/java/io/netty/example/echo/EchoServerHandler.java, +import io.netty.channel.ChannelInboundStreamHandlerAdapter;, +public class EchoServerHandler extends ChannelInboundStreamHandlerAdapter {, + public void inboundBufferUpdated(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in) {, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, + //new LoggingHandler(LogLevel.INFO),, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + //new LoggingHandler(LogLevel.INFO),, +++ b/example/src/main/java/io/netty/example/echo/EchoServerHandler.java, +import io.netty.channel.ChannelInboundStreamHandlerAdapter;, +public class EchoServerHandler extends ChannelInboundStreamHandlerAdapter {, + public void inboundBufferUpdated(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in) {, +++ b/transport/src/main/java/io/netty/channel/ChannelInboundStreamHandlerAdapter.java, +import io.netty.buffer.ChannelBuffer;, +, +, + @Override, + public void inboundBufferUpdated(ChannelInboundHandlerContext<Byte> ctx), + throws Exception {, + inboundBufferUpdated(ctx, ctx.inbound().byteBuffer());, + }, +, + public void inboundBufferUpdated(ChannelInboundHandlerContext<Byte> ctx,
[+++ b/NOTICE.txt, +This product contains a modified portion of 'Apache Commons Lang', a Java library, +provides utilities for the java.lang API, which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.commons-lang.txt (Apache License 2.0), + * HOMEPAGE:, + * https://commons.apache.org/proper/commons-lang/, +, +++ b/NOTICE.txt, +This product contains a modified portion of 'Apache Commons Lang', a Java library, +provides utilities for the java.lang API, which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.commons-lang.txt (Apache License 2.0), + * HOMEPAGE:, + * https://commons.apache.org/proper/commons-lang/, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java, +import io.netty.util.AsciiString;, +import io.netty.util.CharsetUtil;, +import java.nio.charset.Charset;, +import java.nio.charset.UnsupportedCharsetException;, + private static
[+++ b/NOTICE.txt, +This product contains a modified version of Roland Kuhn's ASL2, +AbstractNodeQueue, which is based on Dmitriy Vyukov's non-intrusive MPSC queue., +It can be obtained at:, +, + * LICENSE:, + * license/LICENSE.abstractnodequeue.txt (Public Domain), + * HOMEPAGE:, + * https://github.com/akka/akka/blob/wip-2.2.3-for-scala-2.11/akka-actor/src/main/java/akka/dispatch/AbstractNodeQueue.java, +, +This product optionally depends on 'Bouncy Castle Crypto APIs' to generate, +a temporary self-signed X.509 certificate when the JVM does not provide the, +equivalent functionality. It can be obtained at:, +, + * LICENSE:, + * license/LICENSE.bouncycastle.txt (MIT License), + * HOMEPAGE:, + * http://www.bouncycastle.org/, +, +This product optionally depends on 'Snappy', a compression library produced,
[+++ b/pom.xml, + <module>testsuite-autobahn</module>, +++ b/pom.xml, + <module>testsuite-autobahn</module>, +++ b/testsuite-autobahn/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<!--, + ~ Copyright 2017 The Netty Project, + ~, + ~ The Netty Project licenses this file to you under the Apache License,, + ~ version 2.0 (the "License"); you may not use this file except in compliance, + ~ with the License. You may obtain a copy of the License at:, + ~, + ~ http://www.apache.org/licenses/LICENSE-2.0, + ~, + ~ Unless required by applicable law or agreed to in writing, software, + ~ distributed under the License is distributed on an "AS IS" BASIS,
[+++ b/lib/apiviz-1.3.1.GA.jar, +++ b/lib/apiviz-1.3.1.GA.jar, +++ b/pom.xml, + <docletPath>${basedir}/lib/apiviz-1.3.1.GA.jar</docletPath>]
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandshakeCompletionEvent.java, + public SslHandshakeCompletionEvent(Throwable cause) {]
[+++ b/transport/src/main/java/io/netty/channel/pool/SimpleChannelPool.java, + * This implementation uses LIFO order for {@link Channel}s in the {@link ChannelPool}.]
[+++ b/all/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR1-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java, + * The size thsreshold for gathering writes. Non-Masked messages bigger than this size will be be sent fragmented as, + private static final int GATHERING_WRITE_THRESHOLD = 1024;, + if (maskPayload || length <= GATHERING_WRITE_THRESHOLD) {, + if (maskPayload || length <= GATHERING_WRITE_THRESHOLD) {, + if (maskPayload || length <= GATHERING_WRITE_THRESHOLD) {]
[+++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, + if (channel.isRegistered()) {, + } else {, + channel.unsafe().closeForcibly();, + }, +++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, + if (channel.isRegistered()) {, + } else {, + channel.unsafe().closeForcibly();, + }, +++ b/transport/src/test/java/io/netty/bootstrap/BootstrapTest.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed
[+++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutException.java, + private static final long serialVersionUID = 169287984113283421L;, + public static final ReadTimeoutException INSTANCE = new ReadTimeoutException();, + private ReadTimeoutException() {}, +++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutException.java, + private static final long serialVersionUID = 169287984113283421L;, + public static final ReadTimeoutException INSTANCE = new ReadTimeoutException();, + private ReadTimeoutException() {}, +++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java, +, + private boolean closed;, +, + if (!closed) {, + ctx.fireExceptionCaught(ReadTimeoutException.INSTANCE);, + ctx.close();, + closed = true;, + }, +++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutException.java, + private static final long serialVersionUID = 169287984113283421L;, + public static final ReadTimeoutException INSTANCE = new ReadTimeoutException();, + private ReadTimeoutException() {}, +++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java, +, + private boolean closed;, +,
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + HEXDUMP_TABLE[ i << 1 ] = DIGITS[i >>> 4 & 0x0F];, + HEXDUMP_TABLE[(i << 1) + 1] = DIGITS[i & 0x0F];, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + HEXDUMP_TABLE[ i << 1 ] = DIGITS[i >>> 4 & 0x0F];, + HEXDUMP_TABLE[(i << 1) + 1] = DIGITS[i & 0x0F];, +++ b/buffer/src/main/java/io/netty/buffer/DirectByteBuf.java, +import sun.misc.Cleaner;, +, + return (getByte(index) & 0xff) << 16 | (getByte(index + 1) & 0xff) << 8 | getByte(index + 2) & 0xff;, + setByte(index + 2, (byte) value);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + HEXDUMP_TABLE[ i << 1 ] = DIGITS[i >>> 4 & 0x0F];, + HEXDUMP_TABLE[(i << 1) +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java, +import java.net.InetSocketAddress;, +import java.net.URI;, +import java.nio.charset.Charset;, +import java.nio.charset.UnsupportedCharsetException;, +import java.util.ArrayList;, +import java.util.Iterator;, +import java.util.List;, +, + *, + if (HttpHeaderValues.CLOSE.contentEqualsIgnoreCase(connection)) {, + *, + *, +, + if (indexOfCharset == AsciiString.INDEX_NOT_FOUND) {, + return null;, + }, +, + CharSequence charsetCandidate = contentTypeValue.subSequence(indexOfEncoding, contentTypeValue.length());, + int indexOfSemicolon = AsciiString.indexOfIgnoreCaseAscii(charsetCandidate, SEMICOLON, 0);, + if (indexOfSemicolon == AsciiString.INDEX_NOT_FOUND) {, + return charsetCandidate;, +, + return charsetCandidate.subSequence(0, indexOfSemicolon);, +, + *, + return '[' + hostString + ']';, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java, +import java.net.InetSocketAddress;, +import java.net.URI;, +import java.nio.charset.Charset;, +import java.nio.charset.UnsupportedCharsetException;, +import java.util.ArrayList;, +import java.util.Iterator;, +import java.util.List;, +, + *, + if (HttpHeaderValues.CLOSE.contentEqualsIgnoreCase(connection))
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, +import io.netty.handler.codec.http.FullHttpRequest;, + // Do not free; other handlers will., + return new ChannelInboundMessageHandlerAdapter<FullHttpRequest>() {, + public void messageReceived(ChannelHandlerContext ctx, FullHttpRequest msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, +import io.netty.handler.codec.http.FullHttpRequest;, + // Do not free; other handlers will., + return new ChannelInboundMessageHandlerAdapter<FullHttpRequest>() {, + public void messageReceived(ChannelHandlerContext ctx, FullHttpRequest msg) throws Exception {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java, +import io.netty.handler.codec.http.DefaultFullHttpRequest;, + ch.writeInbound(new DefaultFullHttpRequest(HTTP_1_1, HttpMethod.GET, "/test"));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, +import io.netty.handler.codec.http.FullHttpRequest;, + // Do not free; other handlers will., + return new ChannelInboundMessageHandlerAdapter<FullHttpRequest>() {, + public void messageReceived(ChannelHandlerContext ctx, FullHttpRequest msg) throws Exception {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java, +import io.netty.handler.codec.http.DefaultFullHttpRequest;, + ch.writeInbound(new DefaultFullHttpRequest(HTTP_1_1, HttpMethod.GET, "/test"));,
[+++ b/handler/src/test/java/io/netty/handler/ssl/ParameterizedSslHandlerTest.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + int numBytes;, + boolean done;, + do {, + numBytes = headerBlockDecompressor.decode(decompressed);, + done = decompressed.readableBytes() >= bytes;, + } while (!done && numBytes > 0);, + return done;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + int numBytes;, + boolean done;, + do {, + numBytes = headerBlockDecompressor.decode(decompressed);, + done = decompressed.readableBytes() >= bytes;, + } while (!done && numBytes > 0);, + return done;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockDecompressor.java, + abstract int decode(ByteBuf decompressed) throws Exception;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + int numBytes;, + boolean done;, + do {, + numBytes = headerBlockDecompressor.decode(decompressed);, + done = decompressed.readableBytes() >= bytes;, + } while (!done &&
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, + protected static void encodeAscii(String s, ByteBuf buf) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, + protected static void encodeAscii(String s, ByteBuf buf) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java, + encodeAscii(response.getProtocolVersion().toString(), buf);, + encodeAscii(String.valueOf(response.getStatus().code()), buf);, + encodeAscii(String.valueOf(response.getStatus().reasonPhrase()), buf);]
[+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompSubframeDecoder.java, +import static io.netty.buffer.ByteBufUtil.indexOf;, +import static io.netty.buffer.ByteBufUtil.readBytes;, + private long contentLength = -1;, + if (this.contentLength >= 0) {, + out.add(new DefaultStompContentSubframe(chunkBuffer));, + } else {, + int nulIndex = indexOf(in, in.readerIndex(), in.writerIndex(), StompConstants.NUL);, + if (nulIndex == in.readerIndex()) {, + checkpoint(State.FINALIZE_FRAME_READ);, + } else {, + if (nulIndex > 0) {, + toRead = nulIndex - in.readerIndex();, + } else {, + toRead = in.writerIndex() - in.readerIndex();, + }, + ByteBuf chunkBuffer = readBytes(ctx.alloc(), in, toRead);, + alreadyReadChunkSize += toRead;, + if (nulIndex > 0) {, + lastContent = new DefaultLastStompContentSubframe(chunkBuffer);, + checkpoint(State.FINALIZE_FRAME_READ);, + } else {,
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + private final LongCounter activeBytesHuge = PlatformDependent.newLongCounter();, + PoolChunk<T> chunk = newUnpooledChunk(reqCapacity);, + activeBytesHuge.add(chunk.chunkSize());, + buf.initUnpooled(chunk, reqCapacity);, + int size = chunk.chunkSize();, + activeBytesHuge.add(-size);, + @Override, + public long numActiveBytes() {, + long val = activeBytesHuge.value();, + synchronized (this) {, + for (int i = 0; i < chunkListMetrics.size(); i++) {, + for (PoolChunkMetric m: chunkListMetrics.get(i)) {, + val += m.chunkSize();, + }, + }, + }, + return max(0, val);, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + private final LongCounter activeBytesHuge = PlatformDependent.newLongCounter();, + PoolChunk<T> chunk = newUnpooledChunk(reqCapacity);, + activeBytesHuge.add(chunk.chunkSize());, + buf.initUnpooled(chunk, reqCapacity);, + int size =
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return ByteBufUtil.decodeString(this, index, length, charset);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return ByteBufUtil.decodeString(this, index, length, charset);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import io.netty.util.concurrent.FastThreadLocal;, + private static final FastThreadLocal<CharBuffer> CHAR_BUFFERS = new FastThreadLocal<CharBuffer>() {, + @Override, + protected CharBuffer initialValue() throws Exception {, + return CharBuffer.allocate(1024);, + }, + };, + private static final int MAX_CHAR_BUFFER_SIZE;, +, + MAX_CHAR_BUFFER_SIZE = SystemPropertyUtil.getInt("io.netty.maxThreadLocalCharBufferSize", 16 * 1024);, + logger.debug("-Dio.netty.maxThreadLocalCharBufferSize: {}", MAX_CHAR_BUFFER_SIZE);, + static String decodeString(ByteBuf src, int readerIndex, int len, Charset charset) {, + if (len == 0) {, + return StringUtil.EMPTY_STRING;, + }, + final int maxLength = (int) ((double) len * decoder.maxCharsPerByte());, + CharBuffer
[+++ b/bom/pom.xml, + <artifactId>netty-dev-tools</artifactId>, + <version>4.1.13.Final-SNAPSHOT</version>, + </dependency>, + <dependency>, + <groupId>io.netty</groupId>, + <artifactId>netty-transport-unix-common</artifactId>, + <version>4.1.13.Final-SNAPSHOT</version>, + <classifier>linux-x86_64</classifier>, + </dependency>, + <dependency>, + <groupId>io.netty</groupId>, + <artifactId>netty-transport-unix-common</artifactId>, + <version>4.1.13.Final-SNAPSHOT</version>, + <classifier>osx-x86_64</classifier>, + </dependency>, + <dependency>, + <groupId>io.netty</groupId>, + <artifactId>netty-transport-native-epoll</artifactId>, + <version>4.1.13.Final-SNAPSHOT</version>, + </dependency>, + <dependency>, + <groupId>io.netty</groupId>, + </dependency>, + <dependency>, + <groupId>io.netty</groupId>, + <artifactId>netty-transport-native-kqueue</artifactId>, + <version>4.1.13.Final-SNAPSHOT</version>]
[+++ b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java, + static final class ImmediateEventExecutor extends AbstractEventExecutorWithoutScheduler {, +++ b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java, + static final class ImmediateEventExecutor extends AbstractEventExecutorWithoutScheduler {, +++ b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroupFuture.java, +import io.netty.util.concurrent.BlockingOperationException;, + @Override, + protected void checkDeadLock() {, + EventExecutor e = executor();, + if (e != null && !(e instanceof DefaultChannelGroup.ImmediateEventExecutor) && e.inEventLoop()) {, + throw new BlockingOperationException();, + }, + }, +, +++ b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java, + static final class ImmediateEventExecutor extends AbstractEventExecutorWithoutScheduler {, +++ b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroupFuture.java, +import io.netty.util.concurrent.BlockingOperationException;, + @Override, + protected void checkDeadLock() {, + EventExecutor e = executor();, + if (e != null && !(e instanceof DefaultChannelGroup.ImmediateEventExecutor) && e.inEventLoop()) {, + throw new BlockingOperationException();,
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpServerCodecTest.java, + continueResponse.release();, + // Send the actual response., + FullHttpResponse res = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CREATED);, + res.content().writeBytes("OK".getBytes(CharsetUtil.UTF_8));, + res.headers().set(CONTENT_LENGTH, 2);, + ch.writeOutbound(res);, +, + // Ensure the encoder handles the response after handling 100 Continue., + ByteBuf encodedRes = (ByteBuf) ch.readOutbound();, + assertThat(encodedRes.toString(CharsetUtil.UTF_8), is("HTTP/1.1 201 Created\r\nContent-Length: 2\r\n\r\nOK"));, + encodedRes.release();, +]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, + destroy();, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, + destroy();, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + /** The OpenSSL SSL_CTX object */, + protected volatile long ctx;, + private long aprPool;, + destroy();, + * Returns the pointer to the {@code SSL_CTX} object for this {@link OpenSslContext}., + * Be aware that it is freed as soon as the {@link #finalize()} method is called., + * At this point {@code 0} will be returned., + *, + * @deprecated use {@link #sslCtxPointer()}, + @Deprecated, + destroy();, + /**, + * Returns the pointer to the {@code SSL_CTX} object for this {@link OpenSslContext}., + *
[+++ b/src/main/java/org/jboss/netty/example/http/HttpClient.java, +/*, + * JBoss, Home of Professional Open Source, + * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors, + * by the @authors tag. See the copyright.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version., + *, + * This
[+++ b/handler/src/test/java/io/netty/handler/ssl/SniClientTest.java, + private static void testSniClient(SslProvider sslServerProvider, SslProvider sslClientProvider) throws Exception {, + final SslContext sslServerContext;, + if ((sslServerProvider == SslProvider.OPENSSL || sslServerProvider == SslProvider.OPENSSL_REFCNT), + && !OpenSsl.useKeyManagerFactory()) {, + sslServerContext = SslContextBuilder.forServer(cert.certificate(), cert.privateKey()), + .sslProvider(sslServerProvider), + .build();, + } else {, + // The used OpenSSL version does support a KeyManagerFactory, so use it., + sslServerContext = SslContextBuilder.forServer(kmf), + .sslProvider(sslServerProvider), + .build();, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, +import io.netty.util.internal.ThreadLocalRandom;, + return Long.toHexString(ThreadLocalRandom.current().nextLong()).toLowerCase();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, +import io.netty.util.internal.ThreadLocalRandom;, + return Long.toHexString(ThreadLocalRandom.current().nextLong()).toLowerCase();, +++ b/transport-udt/src/test/java/io/netty/test/udt/util/UnitHelp.java, +import io.netty.util.internal.ThreadLocalRandom;, + final Random generator = ThreadLocalRandom.current();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, +import io.netty.util.internal.ThreadLocalRandom;, + return Long.toHexString(ThreadLocalRandom.current().nextLong()).toLowerCase();, +++ b/transport-udt/src/test/java/io/netty/test/udt/util/UnitHelp.java, +import io.netty.util.internal.ThreadLocalRandom;, + final Random generator = ThreadLocalRandom.current();, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +import io.netty.util.internal.ThreadLocalRandom;, + int idVal = ThreadLocalRandom.current().nextInt();]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + private void shutdownOutput0(final ChannelPromise promise) {, + private void shutdownInput0(final ChannelPromise promise) {, + try {, + fd().shutdown(true, false);, + promise.setSuccess();, + } catch (Throwable cause) {, + promise.setFailure(cause);, + }, + }, +, + private void shutdown0(final ChannelPromise promise) {, + try {, + fd().shutdown(true, true);, + promise.setSuccess();, + } catch (Throwable cause) {, + promise.setFailure(cause);, + }, + }, +, + @Override, + public boolean isOutputShutdown() {, + return fd().isOutputShutdown();, + }, +, + public boolean isShutdown() {, + return fd().isShutdown();, + public ChannelFuture shutdownInput() {, + return shutdownInput(newPromise());, + }, +, + @Override,
[+++ b/common/src/main/java/io/netty/util/internal/PendingWrite.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DefaultHttpDataFactory.java, +import io.netty.handler.codec.http.DefaultHttpRequest;, +import java.util.Collections;, +import java.util.IdentityHashMap;, + * Default factory giving {@link Attribute} and {@link FileUpload} according to constructor., + * <p>According to the constructor, {@link Attribute} and {@link FileUpload} can be:</p>, + * <ul>, + * <li>MemoryAttribute, DiskAttribute or MixedAttribute</li>, + * <li>MemoryFileUpload, DiskFileUpload or MixedFileUpload</li>, + * </ul>, + * Keep all {@link HttpData}s until cleaning methods are called., + * We need to use {@link IdentityHashMap} because different requests may be equal., + * See {@link DefaultHttpRequest#hashCode} and {@link DefaultHttpRequest#equals}., + * Similarly, when removing data items, we need to check their identities because,
[+++ b/.mvn/settings.xml, +<settings>, + <servers>, + <server>, + <id>sonatype-nexus-snapshots</id>, + <username>${env.SANOTYPE_USER}</username>, + <password>${env.SANOTYPE_PASSWORD}</password>, + </server>, + </servers>, +</settings>, +++ b/.mvn/settings.xml, +<settings>, + <servers>, + <server>, + <id>sonatype-nexus-snapshots</id>, + <username>${env.SANOTYPE_USER}</username>, + <password>${env.SANOTYPE_PASSWORD}</password>, + </server>, + </servers>, +</settings>, +++ b/docker/docker-compose.yaml, + environment:, + - SANOTYPE_USER, + - SANOTYPE_PASSWORD]
[+++ b/src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelClientSocketChannel.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2008, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version., + *, +
[+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, +import io.netty.util.Recycler.Handle;, + private final Recycler.Handle<PooledByteBuf<T>> recyclerHandle;, + @SuppressWarnings("unchecked"), + protected PooledByteBuf(Recycler.Handle<? extends PooledByteBuf<T>> recyclerHandle, int maxCapacity) {, + this.recyclerHandle = (Handle<PooledByteBuf<T>>) recyclerHandle;, + recyclerHandle.recycle(this);, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, +import io.netty.util.Recycler.Handle;, + private final Recycler.Handle<PooledByteBuf<T>> recyclerHandle;, + @SuppressWarnings("unchecked"), + protected PooledByteBuf(Recycler.Handle<? extends PooledByteBuf<T>> recyclerHandle, int maxCapacity) {, + this.recyclerHandle = (Handle<PooledByteBuf<T>>) recyclerHandle;, + recyclerHandle.recycle(this);, +++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, + protected PooledDirectByteBuf newObject(Handle<PooledDirectByteBuf> handle) {, + private PooledDirectByteBuf(Recycler.Handle<PooledDirectByteBuf> recyclerHandle, int maxCapacity) {, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, +import io.netty.util.Recycler.Handle;, + private final Recycler.Handle<PooledByteBuf<T>> recyclerHandle;, + @SuppressWarnings("unchecked"), + protected PooledByteBuf(Recycler.Handle<? extends PooledByteBuf<T>> recyclerHandle, int maxCapacity) {, + this.recyclerHandle = (Handle<PooledByteBuf<T>>) recyclerHandle;, + recyclerHandle.recycle(this);, +++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, +
[+++ b/all/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.10.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, +
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + int size = components.size();, + if (size == 0) {, + for (int i = 0; i < size; i++) {, + if (!components.get(i).buf.isDirect()) {, + return false;, + }, + }, + return true;, + }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + int size = components.size();, + if (size == 0) {, + for (int i = 0; i < size; i++) {, + if (!components.get(i).buf.isDirect()) {, + return false;, + }, + }, + return true;, + }, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, +, + @Test, + public void testisDirectMultipleBufs() {, + CompositeByteBuf buf = freeLater(compositeBuffer());, + assertFalse(buf.isDirect());, +, +
[+++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, +import io.netty.util.CharsetUtil;, + private static final boolean TRY_TO_PATCH_SHADED_ID;, +, + // Just use a-Z and numbers as valid ID bytes., + private static final byte[] UNIQUE_ID_BYTES =, + "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".getBytes(CharsetUtil.US_ASCII);, + logger.debug("-Dio.netty.native.deleteLibAfterLoading: {}", DELETE_NATIVE_LIB_AFTER_LOADING);, +, + TRY_TO_PATCH_SHADED_ID = SystemPropertyUtil.getBoolean(, + "io.netty.native.tryPatchShadedId", true);, + logger.debug("-Dio.netty.native.tryPatchShadedId: {}", TRY_TO_PATCH_SHADED_ID);, + String packagePrefix = calculatePackagePrefix().replace('.', '_');, + String name = packagePrefix + originalName;, + if (TRY_TO_PATCH_SHADED_ID && PlatformDependent.isOsx() && !packagePrefix.isEmpty()) {, + // We read the whole native lib into memory to make it easier to monkey-patch the id., + ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(in.available());, +, + while ((length = in.read(buffer)) >
[+++ b/src/docbook/module/start.xml, +import java.util.Date;, +, + System.out.println(new Date(currentTimeMillis));, +import java.util.Date;, +, + System.out.println(new Date(currentTimeMillis));, +import java.util.Date;, +]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + static boolean isInvalid(int index, int length, int capacity) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + static boolean isInvalid(int index, int length, int capacity) {, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, + UnsafeByteBufUtil.getBytes(this, addr(index), index, dst, dstIndex, length);, + UnsafeByteBufUtil.getBytes(this, addr(index), index, dst, dstIndex, length);, + UnsafeByteBufUtil.getBytes(this, addr(index), index, dst);, + UnsafeByteBufUtil.getBytes(this, addr(index), index, out, length);, + UnsafeByteBufUtil.setBytes(this, addr(index), index, src, srcIndex, length);, + UnsafeByteBufUtil.setBytes(this, addr(index), index, src, srcIndex, length);, + UnsafeByteBufUtil.setBytes(this, addr(index), index, src);, + return UnsafeByteBufUtil.setBytes(this, addr(index), index, in, length);, + return UnsafeByteBufUtil.copy(this, addr(index), index, length);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + static boolean isInvalid(int index, int length, int capacity) {, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, + UnsafeByteBufUtil.getBytes(this,
[+++ b/handler/src/main/java/io/netty/handler/ssl/DelegatingSslContext.java, + protected final SslHandler newHandler(ByteBufAllocator alloc, boolean startTls) {, + SslHandler handler = ctx.newHandler(alloc, startTls);, + initHandler(handler);, + return handler;, + }, +, + @Override, + protected final SslHandler newHandler(ByteBufAllocator alloc, String peerHost, int peerPort, boolean startTls) {, + SslHandler handler = ctx.newHandler(alloc, peerHost, peerPort, startTls);, + initHandler(handler);, + return handler;, + }, +, + @Override, +, + /**, + * Init the {@link SslHandler}. This will by default call {@link #initEngine(SSLEngine)}, sub-classes may override, + * this., + */, + protected void initHandler(SslHandler handler) {, + initEngine(handler.engine());, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/DelegatingSslContext.java, + protected final SslHandler newHandler(ByteBufAllocator
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyRstStreamFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyRstStreamFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyRstStreamFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyStreamFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyRstStreamFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyStreamFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySynStreamFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyRstStreamFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyStreamFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySynStreamFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyWindowUpdateFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyRstStreamFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyStreamFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySynStreamFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyWindowUpdateFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyGoAwayFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyRstStreamFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyStreamFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySynStreamFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyWindowUpdateFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyGoAwayFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyPingFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyRstStreamFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java, +++
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioChannelOption.java, +import java.nio.channels.Channel;, + * Provides {@link ChannelOption} over a given {@link java.net.SocketOption} which is then passed through the underlying, + * {@link java.nio.channels.NetworkChannel}., + private final java.net.SocketOption<T> option;, + private NioChannelOption(java.net.SocketOption<T> option) {, + * Returns a {@link ChannelOption} for the given {@link java.net.SocketOption}., + public static <T> ChannelOption<T> of(java.net.SocketOption<T> option) {, + // It's important to not use java.nio.channels.NetworkChannel as otherwise the classes that sometimes call this, + // method may not be used on Java 6, as method linking can happen eagerly even if this method was not actually, + // called at runtime., +
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketChannelNotYetConnectedTest.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelOption.java, + public static final ChannelOption<Boolean> TCP_QUICKACK = ChannelOption.valueOf(T, "TCP_QUICKACK");]
[+++ b/testsuite/pom.xml, + <groupId>org.apache.maven.plugins</groupId>, + <artifactId>maven-jar-plugin</artifactId>, + <version>2.4</version>, + <executions>, + <execution>, + <goals>, + <goal>test-jar</goal>, + </goals>, + </execution>, + </executions>, +++ b/testsuite/pom.xml, + <groupId>org.apache.maven.plugins</groupId>, + <artifactId>maven-jar-plugin</artifactId>, + <version>2.4</version>, + <executions>, + <execution>, + <goals>, + <goal>test-jar</goal>, + </goals>, + </execution>, + </executions>, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/AbstractComboTestsuiteTest.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:,
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +, + // Test if netty-tcnative is in the classpath first., + try {, + Class.forName("org.apache.tomcat.jni.SSL", false, OpenSsl.class.getClassLoader());, + } catch (ClassNotFoundException t) {, + cause = t;, + logger.debug(, + "netty-tcnative not in the classpath; " +, + OpenSslEngine.class.getSimpleName() + " will be unavailable.");, + }, +, + // If in the classpath, try to load the native library and initialize netty-tcnative., + if (cause == null) {, + }, +]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + // Release the message in case it is a full one., +, + if (msg instanceof HttpRequest) {, + // If an oversized request was handled properly and the connection is still alive, + // (i.e. rejected 100-continue). the decoder should prepare to handle a new message., + HttpObjectDecoder decoder = ctx.pipeline().get(HttpObjectDecoder.class);, + if (decoder != null) {, + decoder.reset();, + }, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + // Release the message in case it is a full one., +, + if (msg instanceof HttpRequest) {, + // If an oversized request was handled properly and the
[+++ b/codec/src/test/java/io/netty/handler/codec/compression/LzmaFrameEncoderTest.java, + }, + // LzmaInputStream does not close the stream it wraps, so we should always close., + // The close operation should be safe to call multiple times anyways so lets just call it and be safe., + // https://github.com/jponge/lzma-java/issues/14, + if (is != null) {]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + if (handler instanceof ChannelInboundByteHandler && !inboundByteBuffer().isFreed()) {]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamFrameToHttpObjectCodec.java, + Http2FrameStream stream = headersFrame.stream();, + int id = stream == null ? 0 : stream.id();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamFrameToHttpObjectCodec.java, + Http2FrameStream stream = headersFrame.stream();, + int id = stream == null ? 0 : stream.id();, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2StreamFrameToHttpObjectCodecTest.java, + testDecodeFullResponseHeaders(false);, + }, +, + @Test, + public void testDecodeFullResponseHeadersWithStreamID() throws Exception {, + testDecodeFullResponseHeaders(true);, + }, +, + private void testDecodeFullResponseHeaders(boolean withStreamId) throws Exception {, + Http2HeadersFrame frame = new DefaultHttp2HeadersFrame(headers, true);, + if (withStreamId) {, + frame.stream(new Http2FrameStream() {, + @Override, + public int id() {, + return 1;, + }, +, + @Override, + public Http2Stream.State state()
[+++ b/testsuite/pom.xml, +, + <build>, + <plugins>, + <plugin>, + <artifactId>maven-deploy-plugin</artifactId>, + <configuration>, + <skip>true</skip>, + </configuration>, + </plugin>, + </plugins>, + </build>]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java, + X509KeyManager keyManager = chooseX509KeyManager(keyManagerFactory.getKeyManagers());]
[+++ b/pom.xml, + <parent>, + <groupId>org.jboss</groupId>, + <artifactId>jboss-parent</artifactId>, + <version>5</version>, + </parent>, +, + <version>1.2.16</version>, + <version>2.3</version>, + <artifactId>maven-resources-plugin</artifactId>, + <version>2.4.2</version>, + <configuration>, + <encoding>UTF-8</encoding>, + </configuration>, + <executions>, + <execution>, + <id>copy-legal-info</id>, + <phase>validate</phase>, + <goals>, + <goal>copy-resources</goal>, + </goals>, + <configuration>, + <outputDirectory>${basedir}/src/main/resources/META-INF</outputDirectory>, + <resources>, + <resource>, + <directory>${basedir}</directory>, + <filtering>false</filtering>, + <includes>, + <include>COPYRIGHT.txt</include>, + <include>LICENSE.txt</include>, + <include>NOTICE.txt</include>, + <include>license/*.txt</include>, + </includes>, + </resource>, + </resources>, + </configuration>, + </execution>, + </executions>, + </plugin>, + <plugin>, + <artifactId>maven-surefire-plugin</artifactId>, + <version>2.5</version>, + <configuration>, + <forkMode>never</forkMode>, + <excludes>, + <exclude>**/Abstract*</exclude>, + <exclude>**/TestUtil*</exclude>, + </excludes>, + </configuration>, + </plugin>,
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + final ByteBuffer dstBuf = dst.internalNioBuffer(dst.readerIndex(), length);, + decodeString(decoder, buffer.internalNioBuffer(buffer.readerIndex(), len), dst);, + decoder.decode(heapBuffer.internalNioBuffer(heapBuffer.readerIndex(), length));, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + final ByteBuffer dstBuf = dst.internalNioBuffer(dst.readerIndex(), length);, + decodeString(decoder, buffer.internalNioBuffer(buffer.readerIndex(), len), dst);, + decoder.decode(heapBuffer.internalNioBuffer(heapBuffer.readerIndex(), length));, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, + ByteBuffer buf = buffer.internalNioBuffer(buffer.readerIndex(), 1);, + buf = buffer.internalNioBuffer(buffer.readerIndex(), a);, + ByteBuf releasedBuffer = releasedBuffer();, + releasedBuffer.internalNioBuffer(releasedBuffer.readerIndex(), 1);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + final ByteBuffer dstBuf = dst.internalNioBuffer(dst.readerIndex(), length);, + decodeString(decoder, buffer.internalNioBuffer(buffer.readerIndex(), len), dst);, + decoder.decode(heapBuffer.internalNioBuffer(heapBuffer.readerIndex(), length));, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, + ByteBuffer buf = buffer.internalNioBuffer(buffer.readerIndex(), 1);, + buf = buffer.internalNioBuffer(buffer.readerIndex(), a);, + ByteBuf releasedBuffer = releasedBuffer();, + releasedBuffer.internalNioBuffer(releasedBuffer.readerIndex(), 1);, +++ b/buffer/src/test/java/io/netty/buffer/EmptyByteBufTest.java, + assertThat(empty.nioBuffer(), is(sameInstance(empty.internalNioBuffer(empty.readerIndex(), 0))));,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java, + private static final int HASH_CODE_PRIME = 31;, + public DefaultFullHttpRequest(HttpVersion httpVersion, HttpMethod method, String uri, boolean validateHeaders) {, + this(httpVersion, method, uri, Unpooled.buffer(0), validateHeaders);, + }, +, + /**, + * Copy this object, + *, + * @param copyContent, + * <ul>, + * <li>{@code true} if this object's {@link #content()} should be used to copy.</li>, + * <li>{@code false} if {@code newContent} should be used instead.</li>, + * </ul>, + * @param newContent, + * <ul>, + * <li>if {@code copyContent} is false then this will be used in the copy's content.</li>, + *
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + if (path == null || path.isEmpty()) {, + path = "/";, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + if (path == null || path.isEmpty()) {, + path = "/";, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + if (path == null || path.isEmpty()) {, + path = "/";, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + if (path == null || path.isEmpty()) {, + path = "/";, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + if (path == null || path.isEmpty()) {, + path = "/";, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java, + if (path == null || path.isEmpty()) {, + path = "/";,
[+++ b/codec/src/main/java/io/netty/handler/codec/xml/XmlFrameDecoder.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + private int maxCapacity;, + protected final void maxCapacity(int maxCapacity) {, + this.maxCapacity = maxCapacity;, + }, +, + protected final void adjustMarkers(int decrement) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + private int maxCapacity;, + protected final void maxCapacity(int maxCapacity) {, + this.maxCapacity = maxCapacity;, + }, +, + protected final void adjustMarkers(int decrement) {, +++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, + return new PooledDirectByteBuf(handle, 0);, + PooledDirectByteBuf buf = RECYCLER.get();, + buf.maxCapacity(maxCapacity);, + return buf;, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + private int maxCapacity;, + protected final void maxCapacity(int maxCapacity) {, + this.maxCapacity = maxCapacity;, + }, +, + protected final void adjustMarkers(int decrement) {, +++
[+++ b/all/pom.xml, + <version>4.1.31.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.31.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.31.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.31.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.31.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, + <version>4.1.31.Final-SNAPSHOT</version>, +
[+++ b/common/src/main/java/io/netty/util/AttributeMap.java, +, + /**, + * Returns {@code} true if and only if the given {@link Attribute} exists in this {@link AttributeMap}., + */, + <T> boolean hasAttr(AttributeKey<T> key);, +++ b/common/src/main/java/io/netty/util/AttributeMap.java, +, + /**, + * Returns {@code} true if and only if the given {@link Attribute} exists in this {@link AttributeMap}., + */, + <T> boolean hasAttr(AttributeKey<T> key);, +++ b/common/src/main/java/io/netty/util/DefaultAttributeMap.java, +import java.util.concurrent.atomic.AtomicReferenceArray;, + * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead, + private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater;, + AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> referenceFieldUpdater =, + PlatformDependent.newAtomicReferenceFieldUpdater(DefaultAttributeMap.class, "attributes");, + referenceFieldUpdater =
[+++ b/handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java, + CharsetUtil.US_ASCII);, + select(ctx, hostname.toLowerCase(Locale.US));, +++ b/handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java, + CharsetUtil.US_ASCII);, + select(ctx, hostname.toLowerCase(Locale.US));, +++ b/handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java, + try {, + // hex dump of a client hello packet, which contains hostname "CHAT4.LEANCLOUD.CN", + String tlsHandshakeMessageHex1 = "16030100";, + // part 2, + String tlsHandshakeMessageHex = "c6010000c20303bb0855d66532c05a0ef784f7c384feeafa68b3" +, + "b655ac7288650d5eed4aa3fb52000038c02cc030009fcca9cca8ccaac02b" +, + "c02f009ec024c028006bc023c0270067c00ac0140039c009c0130033009d" +, + "009c003d003c0035002f00ff010000610000001700150000124348415434" +, + "2e4c45414e434c4f55442e434e000b000403000102000a000a0008001d00" +, + "170019001800230000000d0020001e060106020603050105020503040104" +, + "0204030301030203030201020202030016000000170000";, +, + ch.writeInbound(Unpooled.wrappedBuffer(DatatypeConverter.parseHexBinary(tlsHandshakeMessageHex1)));, + ch.writeInbound(Unpooled.wrappedBuffer(DatatypeConverter.parseHexBinary(tlsHandshakeMessageHex)));, +, + // This should produce an alert, + assertTrue(ch.finish());, +, + assertThat(handler.hostname(), is("chat4.leancloud.cn"));, + assertThat(handler.sslContext(), is(leanContext));, + } finally {, + ch.finishAndReleaseAll();, + }, + } finally {, +
[+++ b/example/src/main/java/io/netty/example/http2/client/Http2Client.java, + // NO_ADVERTISE is currently the only mode supported by both OpenSsl and JDK providers., + SelectorFailureBehavior.NO_ADVERTISE,, + // ACCEPT is currently the only mode supported by both OpenSsl and JDK providers., + SelectedListenerFailureBehavior.ACCEPT,, +++ b/example/src/main/java/io/netty/example/http2/client/Http2Client.java, + // NO_ADVERTISE is currently the only mode supported by both OpenSsl and JDK providers., + SelectorFailureBehavior.NO_ADVERTISE,, + // ACCEPT is currently the only mode supported by both OpenSsl and JDK providers., + SelectedListenerFailureBehavior.ACCEPT,, +++ b/example/src/main/java/io/netty/example/http2/server/Http2Server.java, + // NO_ADVERTISE is currently the only mode supported by both OpenSsl and JDK providers., + SelectorFailureBehavior.NO_ADVERTISE,, + // ACCEPT is currently the only mode
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, +import static io.netty.buffer.Unpooled.directBuffer;, +import static io.netty.buffer.Unpooled.unmodifiableBuffer;, +import static io.netty.buffer.Unpooled.unreleasableBuffer;, + private static final ByteBuf ZERO_BUFFER = unmodifiableBuffer(, + unreleasableBuffer(directBuffer(MAX_UNSIGNED_BYTE).writeZero(MAX_UNSIGNED_BYTE)));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, +import static io.netty.buffer.Unpooled.directBuffer;, +import static io.netty.buffer.Unpooled.unmodifiableBuffer;, +import static io.netty.buffer.Unpooled.unreleasableBuffer;, + private static final ByteBuf ZERO_BUFFER = unmodifiableBuffer(, + unreleasableBuffer(directBuffer(MAX_UNSIGNED_BYTE).writeZero(MAX_UNSIGNED_BYTE)));, +++ b/microbench/pom.xml, + <epoll.arch>x86_64</epoll.arch>, + <profiles>, + <profile>, + <id>linux</id>, + <activation>, + <os>, + <family>linux</family>, + </os>, + </activation>, + <properties>, + <epoll.arch>${os.detected.arch}</epoll.arch>, + </properties>, + </profile>, + </profiles>, +, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-codec-http2</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport-native-epoll</artifactId>, + <version>${project.version}</version>, + <classifier>linux-${epoll.arch}</classifier>, + </dependency>, + <dependency>, + <extensions>, + <extension>,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, +import io.netty.channel.Channel;, + WebSocketServerHandshaker handshaker = getHandshaker(ctx.channel());, + static WebSocketServerHandshaker getHandshaker(Channel channel) {, + return channel.attr(HANDSHAKER_ATTR_KEY).get();, + static void setHandshaker(Channel channel, WebSocketServerHandshaker handshaker) {, + channel.attr(HANDSHAKER_ATTR_KEY).set(handshaker);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, +import io.netty.channel.Channel;, + WebSocketServerHandshaker handshaker = getHandshaker(ctx.channel());, + static WebSocketServerHandshaker getHandshaker(Channel channel) {, + return channel.attr(HANDSHAKER_ATTR_KEY).get();, + static void setHandshaker(Channel channel, WebSocketServerHandshaker handshaker) {, + channel.attr(HANDSHAKER_ATTR_KEY).set(handshaker);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, + WebSocketServerProtocolHandler.setHandshaker(ctx.channel(), handshaker);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, +import io.netty.channel.Channel;, + WebSocketServerHandshaker handshaker = getHandshaker(ctx.channel());, + static WebSocketServerHandshaker getHandshaker(Channel channel) {, + return channel.attr(HANDSHAKER_ATTR_KEY).get();, + static void setHandshaker(Channel channel, WebSocketServerHandshaker handshaker) {, + channel.attr(HANDSHAKER_ATTR_KEY).set(handshaker);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, + WebSocketServerProtocolHandler.setHandshaker(ctx.channel(), handshaker);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java, + assertNotNull(WebSocketServerProtocolHandler.getHandshaker(handshakerCtx.channel()));]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java, +import io.netty.buffer.UnpooledByteBufAllocator;, + private static final ByteBufAllocator DEFAULT_ALLOCATOR = UnpooledByteBufAllocator.DEFAULT;]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerDomainSocketChannel.java, + active = true;]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkedInput.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/handler/src/test/java/io/netty/handler/ssl/JdkOpenSslEngineInteroptTest.java, + return super.mySetupMutualAuthServerIsValidClientException(cause) || causedBySSLException(cause);, +++ b/handler/src/test/java/io/netty/handler/ssl/JdkOpenSslEngineInteroptTest.java, + return super.mySetupMutualAuthServerIsValidClientException(cause) || causedBySSLException(cause);, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslJdkSslEngineInteroptTest.java, + return super.mySetupMutualAuthServerIsValidServerException(cause) || causedBySSLException(cause);, +++ b/handler/src/test/java/io/netty/handler/ssl/JdkOpenSslEngineInteroptTest.java, + return super.mySetupMutualAuthServerIsValidClientException(cause) || causedBySSLException(cause);, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslJdkSslEngineInteroptTest.java, + return super.mySetupMutualAuthServerIsValidServerException(cause) || causedBySSLException(cause);, +++ b/handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java, + protected static boolean causedBySSLException(Throwable cause) {, + Throwable next = cause;, + do {, + if (next instanceof SSLException) {, + return true;, + }, + next = next.getCause();, + } while (next != null);, + return false;, + }, +]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java, + spdySynStreamFrame.headers().remove(PATH);, + req.headers().set(HttpHeaders.Names.HOST, host);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import java.security.MessageDigest;, +import java.security.NoSuchAlgorithmException;, +import io.netty.buffer.ChannelBuffer;, +import io.netty.buffer.ChannelBuffers;, +import io.netty.handler.codec.base64.Base64;, +import io.netty.util.CharsetUtil;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import java.security.MessageDigest;, +import java.security.NoSuchAlgorithmException;, +import io.netty.buffer.ChannelBuffer;, +import io.netty.buffer.ChannelBuffers;, +import io.netty.handler.codec.base64.Base64;, +import io.netty.util.CharsetUtil;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +import java.security.MessageDigest;, +import java.security.NoSuchAlgorithmException;, +import io.netty.buffer.ChannelBuffer;, +import io.netty.buffer.ChannelBuffers;, +import io.netty.handler.codec.base64.Base64;, +import io.netty.util.CharsetUtil;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import java.security.MessageDigest;, +import java.security.NoSuchAlgorithmException;, +import io.netty.buffer.ChannelBuffer;, +import io.netty.buffer.ChannelBuffers;, +import io.netty.handler.codec.base64.Base64;, +import io.netty.util.CharsetUtil;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +import java.security.MessageDigest;, +import java.security.NoSuchAlgorithmException;, +import io.netty.buffer.ChannelBuffer;, +import io.netty.buffer.ChannelBuffers;, +import io.netty.handler.codec.base64.Base64;, +import io.netty.util.CharsetUtil;, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServer.java, +import java.util.logging.ConsoleHandler;, +import java.util.logging.Level;, +import java.util.logging.Logger;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import java.security.MessageDigest;, +import java.security.NoSuchAlgorithmException;, +import io.netty.buffer.ChannelBuffer;, +import io.netty.buffer.ChannelBuffers;, +import io.netty.handler.codec.base64.Base64;, +import io.netty.util.CharsetUtil;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +import java.security.MessageDigest;, +import java.security.NoSuchAlgorithmException;, +import
[+++ b/all/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufEncoder.java, +import io.netty.handler.codec.MessageToMessageEncoder;, +, +import static io.netty.buffer.Unpooled.*;, +public class ProtobufEncoder extends MessageToMessageEncoder<MessageLiteOrBuilder> {, + protected Object encode(ChannelHandlerContext ctx, MessageLiteOrBuilder msg) throws Exception {, + return wrappedBuffer(((MessageLite) msg).toByteArray());, + return wrappedBuffer(((MessageLite.Builder) msg).build().toByteArray());, + return null;]
[+++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, + /**, + * Appends the prettifies multi-line hexadecimal dump of the specified {@link ByteBuf} to the specified, + * {@link StringBuilder}., + */, + protected static void appendHexDump(StringBuilder dump, ByteBuf buf) {]
[+++ b/pom.xml, + <!-- Ensure the whole stacktrace is preserved when an exception is thrown. See https://issues.apache.org/jira/browse/SUREFIRE-1457 --> , + <trimStackTrace>false</trimStackTrace>]
[+++ b/LICENSE.protobuf.txt, +Copyright 2008, Google Inc., +All rights reserved., +, +Redistribution and use in source and binary forms, with or without, +modification, are permitted provided that the following conditions are, +met:, +, + * Redistributions of source code must retain the above copyright, +notice, this list of conditions and the following disclaimer., + * Redistributions in binary form must reproduce the above, +copyright notice, this list of conditions and the following disclaimer, +in the documentation and/or other materials provided with the, +distribution., + * Neither the name of Google Inc. nor the names of its, +contributors may be used
[+++ b/src/docbook/module/architecture.xml, + <title>Advanced Components for More Rapid Development</title>, + On top of the core components mentioned above, that already enable the, + implementation of all types of network applications, Netty provides a set, + of advanced features to accelerate the development pace even more., + </para>, + , + <section>, + <title>Codec framework</title>, + <para>, + As demonstrated in <xref linkend="start.pojo"/>, it is always a good, + idea to separate a protocol codec from a business logic. However, there, + are some complications when implementing this idea from scratch. You, + have to deal with the fragmentation of
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpCodecUtil.java, + * @param headerValue The value being validated, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpCodecUtil.java, + * @param headerValue The value being validated, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + * {@link EmbeddedByteChannel}, which is created by {@link #newContentDecoder(String)}., + * Returns a new {@link EmbeddedByteChannel} that decodes the HTTP message, + * @return a new {@link EmbeddedByteChannel} if the specified encoding is supported., + @SuppressWarnings("unused"), +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpCodecUtil.java, + * @param headerValue The value being validated, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + * {@link EmbeddedByteChannel}, which is created by {@link #newContentDecoder(String)}., + * Returns a new {@link EmbeddedByteChannel} that decodes the HTTP message, + * @return a new {@link
[+++ b/all/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta6</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/pom.xml, +, + <plugin>, + <groupId>org.codehaus.mojo</groupId>, + <artifactId>build-helper-maven-plugin</artifactId>, + <version>1.8</version>, + <executions>, + <execution>, + <id>parse-version</id>, + <goals>, + <goal>parse-version</goal>, + </goals>, + </execution>, + </executions>, + </plugin>, +, + <!-- Eclipse-related OSGi manifests, + See https://github.com/netty/netty/issues/3886, + More information: http://rajakannappan.blogspot.ie/2010/03/automating-eclipse-source-bundle.html -->, + <archive>, + <manifestEntries>, + <Bundle-ManifestVersion>2</Bundle-ManifestVersion>, + <Bundle-Name>${name}</Bundle-Name>, + <Bundle-SymbolicName>${groupId}.${artifactId}.source</Bundle-SymbolicName>, + <Bundle-Vendor>${organization.name}</Bundle-Vendor>, + <Bundle-Version>${parsedVersion.osgiVersion}</Bundle-Version>, + <Eclipse-SourceBundle>${groupId}.${artifactId};version="${parsedVersion.osgiVersion}";roots:="."</Eclipse-SourceBundle>, + </manifestEntries>, + </archive>, +]
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, + while (buffer.isWritable()) {, + assertTrue(buffer.isWritable());, + assertFalse(buffer.isWritable());, + assertTrue(buffer.isReadable());, + assertFalse(buffer.isReadable());, + assertFalse(buffer.isWritable());, + assertTrue(buffer.isWritable());, + assertFalse(buffer.isWritable());, + assertTrue(buffer.isReadable());, + assertFalse(buffer.isReadable());, + assertFalse(buffer.isWritable());, + assertTrue(buffer.isWritable());, + assertFalse(buffer.isWritable());, + assertTrue(buffer.isReadable());, + assertFalse(buffer.isReadable());, + assertFalse(buffer.isWritable());, + assertTrue(buffer.isWritable());, + assertFalse(buffer.isWritable());, + assertTrue(buffer.isReadable());, + assertFalse(buffer.isReadable());, + assertFalse(buffer.isWritable());, + assertTrue(buffer.isWritable());, + assertTrue(buffer.isReadable());, + assertTrue(buffer.isWritable());, + assertTrue(buffer.isReadable());, + assertTrue(buffer.isWritable());, + assertFalse(buffer.isWritable());, + assertTrue(buffer.isReadable());, + assertFalse(buffer.isReadable());, + assertFalse(buffer.isWritable());, + assertTrue(buffer.isWritable());, + assertFalse(buffer.isWritable());, + assertTrue(buffer.isReadable());, + assertFalse(buffer.isReadable());, + assertFalse(buffer.isWritable());, + assertTrue(buffer.isWritable());, + assertFalse(buffer.isWritable());, + assertTrue(buffer.isReadable());, + assertFalse(buffer.isReadable());, + assertFalse(buffer.isWritable());, + while (buffer.isWritable()) {, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, + while (buffer.isWritable()) {, + assertTrue(buffer.isWritable());, + assertFalse(buffer.isWritable());, +
[+++ b/all/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR1-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/pom.xml, + <conscrypt.version>1.0.0.RC13</conscrypt.version>]
[+++ b/pom.xml, + <configuration>, + <detectOfflineLinks>false</detectOfflineLinks>, + </configuration>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java, + if (config.isCredentialsAllowed()) {, + echoRequestOrigin(response);, + setVaryHeader(response);, + } else {, + }, + setOrigin(response, origin);, + setVaryHeader(response);, + private void echoRequestOrigin(final HttpResponse response) {, + setOrigin(response, request.headers().get(ORIGIN));, + }, +, + private void setVaryHeader(final HttpResponse response) {, + response.headers().set(VARY, ORIGIN);, + }, +, + private void setAnyOrigin(final HttpResponse response) {, + setOrigin(response, "*");, + }, +, + private void setOrigin(final HttpResponse response, final String origin) {, + response.headers().set(ACCESS_CONTROL_ALLOW_ORIGIN, origin);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java, + if (config.isCredentialsAllowed()) {, + echoRequestOrigin(response);, + setVaryHeader(response);, + } else {, + }, + setOrigin(response, origin);, + setVaryHeader(response);, + private void echoRequestOrigin(final HttpResponse
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + final HttpContent c = (HttpContent) msg;, +, + c.retain();, + c.retain();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + final HttpContent c = (HttpContent) msg;, +, + c.retain();, + c.retain();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +, +, + c.retain();, + return c;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + final HttpContent c = (HttpContent) msg;, +, + c.retain();, + c.retain();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +, +, + c.retain();, + return c;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, +import io.netty.buffer.BufUtil;, + BufUtil.retain(m);, + chunk.retain();, + last = chunk instanceof LastHttpContent;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + final HttpContent c = (HttpContent) msg;, +, + c.retain();, + c.retain();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +, +, + c.retain();, + return c;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java,
[+++ b/COPYRIGHT.txt, +contributors, and is licensed under the GNU LGPL (Lesser General Public License), +as published by the Free Software Foundation; either version 2.1 of the License,, +or (at your option) any later version.]
[+++ b/pom.xml, + <plugin>, + <artifactId>maven-surefire-plugin</artifactId>, + <version>2.12</version>, + <configuration>, + <forkMode>never</forkMode>, + <excludes>, + <exclude>**/Abstract*</exclude>, + <exclude>**/TestUtil*</exclude>, + </excludes>, + <runOrder>random</runOrder>, + </configuration>, + </plugin>]
[+++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxy.java, +import io.netty.channel.ChannelOption;, + .childHandler(new HexDumpProxyInitializer(remoteHost, remotePort)), + .childOption(ChannelOption.AUTO_READ, false);, +++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxy.java, +import io.netty.channel.ChannelOption;, + .childHandler(new HexDumpProxyInitializer(remoteHost, remotePort)), + .childOption(ChannelOption.AUTO_READ, false);, +++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxyFrontendHandler.java, + // connection complete start to auto read data, + inboundChannel.config().setAutoRead(true);]
[+++ b/src/docbook/en-US/module/start.xml, +public class DiscardServerHandler extends &SimpleChannelHandler; {<co id="example.discard.co1"/>, + public void messageReceived(&ChannelHandlerContext; ctx, &MessageEvent; e) {<co id="example.discard.co2"/>, + public void exceptionCaught(&ChannelHandlerContext; ctx, &ExceptionEvent; e) {<co id="example.discard.co3"/>, + <callout arearefs="example.discard.co2">, + <callout arearefs="example.discard.co3">, + return &Channels;.pipeline(new DiscardServerHandler());, + bootstrap.setOption("child.tcpNoDelay", true);<co id="example.discard2.co4" />, + bootstrap.bind(new InetSocketAddress(8080));<co id="example.discard2.co5" />, + <callout arearefs="example.discard2.co5">, + System.out.flush();, + also might not close the connection immediately, and it returns a, + private final &ChannelBuffer; buf = dynamicBuffer();<co id="example.time3.co1"/>, + buf.writeBytes(m);<co id="example.time3.co2"/>, + if (buf.readableBytes() &gt;= 4) {<co id="example.time3.co3"/>, + <callout arearefs="example.time3.co2">, + <callout arearefs="example.time3.co3">, + &ChannelHandlerContext; ctx, &Channel; channel, &ChannelBuffer; buffer)<co id="example.time4.co1"/> {, + return
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2HeadersTest.java, +import static io.netty.util.AsciiString.of;, + public void testPseudoHeadersMustComeFirstWhenIterating() {, + public void testPseudoHeadersWithRemovePreservesPseudoIterationOrder() {, + @Test, + public void testPseudoHeadersWithClearDoesNotLeak() {, + Http2Headers headers = newHeaders();, +, + assertFalse(headers.isEmpty());, + headers.clear();, + assertTrue(headers.isEmpty());, +, + // Combine 2 headers together, make sure pseudo headers stay up front., + headers.add("name1", "value1").scheme("nothing");, + verifyPseudoHeadersFirst(headers);, +, + Http2Headers other = new DefaultHttp2Headers().add("name2", "value2").authority("foo");, + verifyPseudoHeadersFirst(other);, +, + headers.add(other);, + verifyPseudoHeadersFirst(headers);, +, + // Make sure the headers are what we expect them to be, and no leaking behind the scenes., + assertEquals(4, headers.size());, + assertEquals("value1", headers.get("name1"));, + assertEquals("value2", headers.get("name2"));, + assertEquals("nothing",
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java, + private static final int ERRNO_ENOTCONN_NEGATIVE = -errnoENOTCONN();, + private static native int errnoENOTCONN();]
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java, + if (nextProtocols != null && nextProtocols.iterator().hasNext()) {, + if (!JettyNpnSslEngine.isAvailable()) {, + } else {, + this.nextProtocols = Collections.emptyList();, + }]
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketCloseForciblyTest.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/NOTICE.txt, +"License"); you may not use this product except in compliance with the License.]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelId.java, +public final class DefaultChannelId implements ChannelId {, + /**, + * Returns a new {@link DefaultChannelId} instance., + */, + public static DefaultChannelId newInstance() {, + private DefaultChannelId() { }, +]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_HEADER_LIST_SIZE;, + private Http2Settings initialSettings = new Http2Settings().maxHeaderListSize(DEFAULT_HEADER_LIST_SIZE);, + Long maxHeaderListSize = initialSettings.maxHeaderListSize();, + Http2FrameReader reader = new DefaultHttp2FrameReader(maxHeaderListSize == null ?, + new DefaultHttp2HeadersDecoder(isValidateHeaders()) :, + new DefaultHttp2HeadersDecoder(isValidateHeaders(), maxHeaderListSize));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_HEADER_LIST_SIZE;, + private Http2Settings initialSettings = new Http2Settings().maxHeaderListSize(DEFAULT_HEADER_LIST_SIZE);, + Long maxHeaderListSize = initialSettings.maxHeaderListSize();, + Http2FrameReader reader = new DefaultHttp2FrameReader(maxHeaderListSize == null ?, + new DefaultHttp2HeadersDecoder(isValidateHeaders()) :, + new DefaultHttp2HeadersDecoder(isValidateHeaders(), maxHeaderListSize));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2FrameWriter.java, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +, + boolean endStream, ChannelPromise promise) throws Http2Exception {, + boolean endStream, ChannelPromise promise) throws Http2Exception {, + Http2Headers headers, int padding, ChannelPromise promise), + throws
[+++ b/all/pom.xml, + <classifier>${os.detected.classifier}</classifier>]
[+++ b/all/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta8-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +import io.netty.util.internal.SystemPropertyUtil;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(PooledByteBufAllocator.class);, +, + private static final int DEFAULT_NUM_HEAP_ARENA = Math.max(1, SystemPropertyUtil.getInt(, + "io.netty.allocator.numHeapArenas", Runtime.getRuntime().availableProcessors()));, + private static final int DEFAULT_NUM_DIRECT_ARENA = Math.max(1, SystemPropertyUtil.getInt(, + "io.netty.allocator.numDirectArenas", Runtime.getRuntime().availableProcessors()));, + private static final int DEFAULT_PAGE_SIZE;, + private static final int DEFAULT_MAX_ORDER; // 8192 << 11 = 16 MiB per chunk, + static {, + int defaultPageSize = SystemPropertyUtil.getInt("io.netty.allocator.pageSize", 8192);, + Throwable pageSizeFallbackCause = null;, + try {, + validateAndCalculatePageShifts(defaultPageSize);, + } catch (Throwable t) {, + pageSizeFallbackCause = t;, + defaultPageSize = 8192;, + }, + DEFAULT_PAGE_SIZE
[+++ b/transport-native-epoll/pom.xml, + <replacement>CFLAGS=-O3 -DIO_NETTY_SENDMMSG_NOT_FOUND -Werror</replacement>, + <replacement>CFLAGS=-O3 -Werror</replacement>, +++ b/transport-native-epoll/pom.xml, + <replacement>CFLAGS=-O3 -DIO_NETTY_SENDMMSG_NOT_FOUND -Werror</replacement>, + <replacement>CFLAGS=-O3 -Werror</replacement>, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +#include <inttypes.h>, + } else {, + return -EINVAL;, + return 0;, + return 0;, +#define _UNIX_ADDR_LENGTH(path_len) (uintptr_t) (((struct sockaddr_un *) 0)->sun_path) + path_len, + jbyte* socket_path = (*env)->GetByteArrayElements(env, socketPath, 0);, + jbyte* socket_path = (*env)->GetByteArrayElements(env, socketPath, 0);, + ssize_t res;, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_splice0(JNIEnv* env, jclass clazz, jint fd, jlong offIn, jint fdOut, jlong offOut, jlong len) {, + loff_t off_in = (loff_t) offIn;, + loff_t off_out = (loff_t) offOut;, +, + loff_t* p_off_in = off_in >= 0
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/transport/src/main/java/io/netty/channel/iostream/IoStreamAddress.java, +/*, + * Copyright 2011 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, + * ctx.writeAndFlush(fetchSecret((GetDataMessage) message));, + * ctx.writeAndFlush(fetchSecret((GetDataMessage) o));]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, + || statusCode >= 1015 && statusCode <= 2999) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, + || statusCode >= 1015 && statusCode <= 2999) {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoderTest.java, +import io.netty.buffer.ByteBuf;, +import io.netty.channel.embedded.EmbeddedChannel;, +, +import java.util.HashSet;, +import java.util.Set;, +, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertNull;, +import static org.junit.Assert.assertTrue;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.verify;, + final ChannelHandlerContext ctx = mock(ChannelHandlerContext.class);, + verify(ctx).fireChannelInactive();, + }, +, + @Test, + public void supportIanaStatusCodes() throws Exception {, + Set<Integer> forbiddenIanaCodes = new HashSet<Integer>();, + forbiddenIanaCodes.add(1004);, + forbiddenIanaCodes.add(1005);, + forbiddenIanaCodes.add(1006);, + Set<Integer> validIanaCodes = new HashSet<Integer>();, + for (int i = 1000; i < 1015; i++)
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_recvFd0(JNIEnv* env, jclass clazz, jint fd) {, + int socketFd;, + struct msghdr descriptorMessage = { 0 };, + struct iovec iov[1] = { 0 };, + char control[CMSG_SPACE(sizeof(int))] = { 0 };, + char iovecData[1];, + descriptorMessage.msg_control = control;, + descriptorMessage.msg_controllen = sizeof(control);, + descriptorMessage.msg_iov = iov;, + descriptorMessage.msg_iovlen = 1;, + iov[0].iov_base = iovecData;, + iov[0].iov_len = sizeof(iovecData);, + ssize_t res;, + int err;, + for (;;) {, + do {, + res = recvmsg(fd, &descriptorMessage, 0);, + // Keep on reading if we was interrupted, + } while (res == -1
[+++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffer.java, + *, + *, + *, + *, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffer.java, + *, + *, + *, + *, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CaseIgnoringComparator.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffer.java, + *, + *, + *, + *, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CaseIgnoringComparator.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieHeaderNames.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffer.java, + *, + *, + *, + *, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CaseIgnoringComparator.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieHeaderNames.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkTrailer.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffer.java, + *, + *, + *, + *, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CaseIgnoringComparator.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieHeaderNames.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkTrailer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpCodecUtil.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffer.java, + *, + *, + *, + *, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CaseIgnoringComparator.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieHeaderNames.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkTrailer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessage.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffer.java, + *, + *, + *, +
[+++ b/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java, + } else if (dst.hasArray()) {]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + protected Object decodeLast(, + ChannelHandlerContext ctx, Channel channel, ChannelBuffer buffer), + throws Exception {, + Object frame = decode(ctx, channel, buffer);, + headerBlockDecompressor.end();, + return frame;, + }, +, +, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + protected Object decodeLast(, + ChannelHandlerContext ctx, Channel channel, ChannelBuffer buffer), + throws Exception {, + Object frame = decode(ctx, channel, buffer);, + headerBlockDecompressor.end();, + return frame;, + }, +, +, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockDecompressor.java, + return new SpdyHeaderBlockZlibDecompressor();, + abstract void decode(ChannelBuffer decompressed) throws Exception;, + abstract void end();, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + protected Object decodeLast(, + ChannelHandlerContext ctx, Channel channel, ChannelBuffer
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + private static final boolean HAS_UNSAFE = PlatformDependent.hasUnsafe();, + if (HAS_UNSAFE) {, + if (HAS_UNSAFE) {, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + private static final boolean HAS_UNSAFE = PlatformDependent.hasUnsafe();, + if (HAS_UNSAFE) {, + if (HAS_UNSAFE) {, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledByteBufAllocator.java, + if (PlatformDependent.hasUnsafe()) {, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + private static final boolean HAS_UNSAFE = PlatformDependent.hasUnsafe();, + if (HAS_UNSAFE) {, + if (HAS_UNSAFE) {, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledByteBufAllocator.java, + if (PlatformDependent.hasUnsafe()) {, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + * Return {@code true} if {@code sun.misc.Unsafe} was found on the classpath and can be used for acclerated, + * direct memory access., + /**, + * Try to allocate
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameLogger.java, + public boolean isEnabled() {, + return logger.isEnabled(level);, + }, +, + if (isEnabled()) {, + }, + if (isEnabled()) {, + }, + if (isEnabled()) {, + }, + if (isEnabled()) {, + }, + if (isEnabled()) {, + }, + if (isEnabled()) {, + }, + if (isEnabled()) {, + }, + if (isEnabled()) {, + }, + if (isEnabled()) {, + logger.log(level, "{} {} PUSH_PROMISE: streamId={} promisedStreamId={} headers={} padding={}",, + ctx.channel(), direction.name(), streamId, promisedStreamId, headers, padding);, + }, + if (isEnabled()) {, + }, + if (isEnabled()) {, + }, + if (isEnabled()) {,
[+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java, + if (option == SCTP_INIT_MAXSTREAMS) {, + return (T) getInitMaxStreams();, + }, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java, + if (option == SCTP_INIT_MAXSTREAMS) {, + return (T) getInitMaxStreams();, + }, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpServerChannelConfig.java, + if (option == SctpChannelOption.SCTP_INIT_MAXSTREAMS) {, + return (T) getInitMaxStreams();, + }, + setInitMaxStreams((SctpStandardSocketOptions.InitMaxStreams) value);, + public SctpStandardSocketOptions.InitMaxStreams getInitMaxStreams() {, + public SctpServerChannelConfig setInitMaxStreams(SctpStandardSocketOptions.InitMaxStreams initMaxStreams) {, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java, + if (option == SCTP_INIT_MAXSTREAMS) {, + return (T) getInitMaxStreams();, + }, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpServerChannelConfig.java, + if (option == SctpChannelOption.SCTP_INIT_MAXSTREAMS) {, + return (T) getInitMaxStreams();, + }, + setInitMaxStreams((SctpStandardSocketOptions.InitMaxStreams) value);, + public SctpStandardSocketOptions.InitMaxStreams getInitMaxStreams() {, + public SctpServerChannelConfig setInitMaxStreams(SctpStandardSocketOptions.InitMaxStreams initMaxStreams) {, +++
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_tcpMd5SigMaxKeyLen(JNIEnv* env, jclass clazz) {, + struct tcp_md5sig md5sig;, +, + // Defensive size check, + if (sizeof(md5sig.tcpm_key) < TCP_MD5SIG_MAXKEYLEN) {, + return sizeof(md5sig.tcpm_key);, + }, +, + return TCP_MD5SIG_MAXKEYLEN;, +}, +, +JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_setTcpMd5Sig0(JNIEnv* env, jclass clazz, jint fd, jbyteArray address, jint scopeId, jbyteArray key) {, + struct sockaddr_storage addr;, + if (init_sockaddr(env, address, scopeId, 0, &addr) == -1) {, + return;, + }, +, + struct tcp_md5sig md5sig;, + memset(&md5sig, 0, sizeof(md5sig));, + md5sig.tcpm_addr.ss_family = addr.ss_family;, +, + struct sockaddr_in* ipaddr;, + struct sockaddr_in6* ip6addr;, +, + switch (addr.ss_family) {,
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, + super(ciphers, cipherFilter, apn, sessionCacheSize, sessionTimeout, SSL.SSL_MODE_CLIENT, null);, + super(ciphers, cipherFilter, apn, sessionCacheSize, sessionTimeout, SSL.SSL_MODE_CLIENT, keyCertChain);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, + super(ciphers, cipherFilter, apn, sessionCacheSize, sessionTimeout, SSL.SSL_MODE_CLIENT, null);, + super(ciphers, cipherFilter, apn, sessionCacheSize, sessionTimeout, SSL.SSL_MODE_CLIENT, keyCertChain);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +import java.security.cert.Certificate;, + private final Certificate[] keyCertChain;, + long sessionCacheSize, long sessionTimeout, int mode, Certificate[] keyCertChain), + throws SSLException {, + this(ciphers, cipherFilter, toNegotiator(apnCfg), sessionCacheSize, sessionTimeout, mode, keyCertChain);, + long sessionTimeout, int mode, Certificate[] keyCertChain) throws SSLException {, + this.keyCertChain = keyCertChain == null ? null : keyCertChain.clone();, + rejectRemoteInitiatedRenegotiation, peerHost, peerPort, keyCertChain);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, + super(ciphers, cipherFilter, apn, sessionCacheSize, sessionTimeout,
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + inMsgBuf = null;, + inByteBuf = null;, + outByteBuf = null;, + outMsgBuf = null;]
[+++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, + buf = null;, + if (buf != null && buf.isReadable()) {]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +, + for (;;) {, + return writeUtf8((AbstractByteBuf) buf, seq, len);, + } else if (buf instanceof WrappedByteBuf) {, + // Unwrap as the wrapped buffer may be an AbstractByteBuf and so we can use fast-path., + buf = buf.unwrap();, + } else {, + byte[] bytes = seq.toString().getBytes(CharsetUtil.UTF_8);, + buf.writeBytes(bytes);, + return bytes.length;, + }, + }, + }, +, + // Fast-Path implementation, + private static int writeUtf8(AbstractByteBuf buffer, CharSequence seq, int len) {, + } else {, + for (;;) {, + if (buf instanceof AbstractByteBuf) {, + writeAscii((AbstractByteBuf) buf, seq, len);, + break;,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java, + if (request instanceof HttpContent) {, + // Offer automatically if the given request is als type of HttpContent, + // See #1089, + offer((HttpContent) request);, + } else {, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java, + if (request instanceof HttpContent) {, + // Offer automatically if the given request is als type of HttpContent, + // See #1089, + offer((HttpContent) request);, + } else {, + }, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java, +import io.netty.handler.codec.http.DefaultFullHttpRequest;, +import static org.junit.Assert.assertEquals;, +, + // See https://github.com/netty/netty/issues/1089, + @Test, + public void testFullHttpRequestUpload() throws Exception {, + final String boundary = "dLV9Wyq26L_-JQxk6ferf-RT153LhOO";, +, + final DefaultFullHttpRequest
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + protected Object decodeLast(, + ChannelHandlerContext ctx, Channel channel, ChannelBuffer buffer), + throws Exception {, + try {, + Object frame = decode(ctx, channel, buffer);, + return frame;, + } finally {, + headerBlockDecompressor.end();, + }, + }, +, +, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + protected Object decodeLast(, + ChannelHandlerContext ctx, Channel channel, ChannelBuffer buffer), + throws Exception {, + try {, + Object frame = decode(ctx, channel, buffer);, + return frame;, + } finally {, + headerBlockDecompressor.end();, + }, + }, +, +, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockCompressor.java, +import io.netty.util.internal.DetectionUtil;, + if (DetectionUtil.javaVersion() >= 7) {, +++
[+++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor, executor);, + return new NioServerSocketChannelFactory(executor, executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor, executor);, + return new NioServerSocketChannelFactory(executor, executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioOioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor, executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor, executor);, + return new NioServerSocketChannelFactory(executor, executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioOioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor, executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/OioNioSocketSpdyEchoTest.java, + return new NioServerSocketChannelFactory(executor, executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor, executor);, + return new NioServerSocketChannelFactory(executor, executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioOioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor, executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/OioNioSocketSpdyEchoTest.java, + return new NioServerSocketChannelFactory(executor, executor);, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, + Executors.newCachedThreadPool(),, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor, executor);, + return new NioServerSocketChannelFactory(executor, executor);,
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +import static io.netty.util.internal.ObjectUtil.checkPositive;, +, + return retain0(1);, + return retain0(checkPositive(increment, "increment"));, + private ByteBuf retain0(int increment) {, + return release0(1);, + return release0(checkPositive(decrement, "decrement"));, + private boolean release0(int decrement) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +import static io.netty.util.internal.ObjectUtil.checkPositive;, +, + return retain0(1);, + return retain0(checkPositive(increment, "increment"));, + private ByteBuf retain0(int increment) {, + return release0(1);, + return release0(checkPositive(decrement, "decrement"));, + private boolean release0(int decrement) {, +++ b/common/src/main/java/io/netty/util/AbstractReferenceCounted.java, +import static io.netty.util.internal.ObjectUtil.checkPositive;, +, + return retain0(1);, + return retain0(checkPositive(increment, "increment"));, + private ReferenceCounted retain0(int increment) {, + return release0(1);, + return release0(checkPositive(decrement, "decrement"));, + private boolean release0(int decrement) {]
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCacheEntry.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelBuilder;, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelInitializer;, +import io.netty.channel.ChannelOption;, +import io.netty.channel.ChannelPipeline;, + // Create the required event loop., + try {, + // Configure the client., + ChannelBuilder b = new ChannelBuilder();, + b.eventLoop(loop), + .channel(new NioSocketChannel()), + .option(ChannelOption.TCP_NODELAY, true), + .remoteAddress(new InetSocketAddress(host, port)), + .initializer(new ChannelInitializer() {, + @Override, + public void initChannel(Channel ch) throws Exception {, + ChannelPipeline p = ch.pipeline();, + p.addLast("logger", new LoggingHandler(InternalLogLevel.INFO));, + p.addLast("echoer", new EchoClientHandler(firstMessageSize));, + }, + });, +, + // Start the client., + ChannelFuture f = b.connect().sync();, + f.channel().closeFuture().sync();, + } finally {, + // Shut down
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +import io.netty.util.collection.IntObjectHashMap;, +import io.netty.util.collection.IntObjectMap;, + private final IntObjectMap<AbstractEpollChannel> ids = new IntObjectHashMap<AbstractEpollChannel>();, + for (IntObjectMap.Entry<AbstractEpollChannel> entry: ids.entries()) {, + channels.add(entry.value());]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + if (!Values.WEBSOCKET.equalsIgnoreCase(upgrade)) {, + if (!Values.UPGRADE.equalsIgnoreCase(connection)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + if (!Values.WEBSOCKET.equalsIgnoreCase(upgrade)) {, + if (!Values.UPGRADE.equalsIgnoreCase(connection)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java, + if (!Values.WEBSOCKET.equalsIgnoreCase(upgrade)) {, + if (!Values.UPGRADE.equalsIgnoreCase(connection)) {]
[+++ b/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java, + * @param nThreads the number of threads that will be used by this instance., + if (nThreads <= 0) {, + throw new IllegalArgumentException(String.format("nThreads: %d (expected: > 0)", nThreads));, +++ b/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java, + * @param nThreads the number of threads that will be used by this instance., + if (nThreads <= 0) {, + throw new IllegalArgumentException(String.format("nThreads: %d (expected: > 0)", nThreads));, +++ b/transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java, + protected MultithreadEventLoopGroup(int nThreads, ThreadFactory threadFactory, Object... args) {]
[+++ b/all/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/example/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha8-SNAPSHOT</version>, +++ b/codec/pom.xml, +
[+++ b/codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java, + ByteBuf frame = extractFrame(ctx, in, readerIndex, actualFrameLength);, + protected ByteBuf extractFrame(ChannelHandlerContext ctx, ByteBuf buffer, int index, int length) {, + ByteBuf frame = ctx.alloc().buffer(length);, +++ b/codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java, + ByteBuf frame = extractFrame(ctx, in, readerIndex, actualFrameLength);, + protected ByteBuf extractFrame(ChannelHandlerContext ctx, ByteBuf buffer, int index, int length) {, + ByteBuf frame = ctx.alloc().buffer(length);, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java, + ByteBuf footer = ctx.alloc().buffer();, +++ b/codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java, + ByteBuf frame = extractFrame(ctx, in, readerIndex, actualFrameLength);, + protected ByteBuf extractFrame(ChannelHandlerContext ctx, ByteBuf buffer, int index, int length) {, + ByteBuf frame = ctx.alloc().buffer(length);, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java, + ByteBuf footer = ctx.alloc().buffer();, +++ b/codec/src/main/java/io/netty/handler/codec/marshalling/MarshallingDecoder.java, + protected
[+++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, + private volatile int waitTime;, + return getOptions(super.getOptions(), BAUD_RATE, DTR, RTS, STOP_BITS, DATA_BITS, PARITY_BIT, WAIT_TIME);, + if (option == WAIT_TIME) {, + return (T) Integer.valueOf(getWaitTimeMillis());, + }, + } else if (option == WAIT_TIME) {, + setWaitTimeMillis((Integer) value);, + public int getWaitTimeMillis() {, + return waitTime;, + }, +, + @Override, + public RxtxChannelConfig setWaitTimeMillis(final int waitTimeMillis) {, + if (waitTimeMillis < 0) {, + throw new IllegalArgumentException("Wait time must be >= 0");, + }, + waitTime = waitTimeMillis;, + return this;, + }, +, + @Override, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, + private volatile int waitTime;, + return getOptions(super.getOptions(),
[+++ b/pom.xml, + <version>3.1.0.GA-SNAPSHOT</version>]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, + for (int i = 0;; i ++) {, + int b = length >>> i * 7;, + if ((b & 0xFFFFFF80) != 0) {, + out.writeByte(b & 0x7f | 0x80);, + out.writeByte(b);, + break;, + while (in.isReadable()) {, + int current = in.readUnsignedByte();, + length |= (current & 0x7f) << byteIndex++ * 7;, + if ((current & 0x80) == 0) {, + | in.readUnsignedByte() << 8;, + | in.readUnsignedByte() << 8, + | in.readUnsignedByte() << 16;, + | in.readUnsignedByte() << 8, + | in.readUnsignedByte() << 16, + | in.readUnsignedByte() << 24;, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, + for
[+++ b/pom.xml, + <repositories>, + <repository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </repository>, + </repositories>, +, + <pluginRepositories>, + <pluginRepository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </pluginRepository>, + </pluginRepositories>, +, + <version>4.8.2</version>, +++ b/pom.xml, + <repositories>, + <repository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </repository>, + </repositories>, +, + <pluginRepositories>, + <pluginRepository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </pluginRepository>, + </pluginRepositories>, +, + <version>4.8.2</version>, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, + super();, +++ b/pom.xml, + <repositories>, + <repository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </repository>, + </repositories>, +, + <pluginRepositories>, + <pluginRepository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </pluginRepository>, + </pluginRepositories>, +, + <version>4.8.2</version>, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, + super();, +++
[+++ b/pom.xml, + <groupId>org.codehaus.mojo</groupId>, + <artifactId>buildnumber-maven-plugin</artifactId>, + <version>1.0-beta-3</version>, + <executions>, + <execution>, + <phase>validate</phase>, + <goals>, + <goal>create</goal>, + </goals>, + </execution>, + </executions>, + <configuration>, + <doCheck>false</doCheck>, + <doUpdate>true</doUpdate>, + </configuration>, + </plugin>, + <plugin>, + <SCM-Revision>${buildNumber}</SCM-Revision>, + <echo message="${project.version}, r${buildNumber}", + file="${project.build.directory}/version.txt" />, + <doctitle>${project.name} API Reference (${project.version}, r${buildNumber})</doctitle>, + <windowtitle>${project.name} API Reference (${project.version}, r${buildNumber})</windowtitle>, + <docTitle>${project.name} Source Xref (${project.version}, r${buildNumber})</docTitle>, + <windowTitle>${project.name} Source Xref (${project.version}, r${buildNumber})</windowTitle>]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Crc32c.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ /dev/null]
[+++ b/common/src/main/java/io/netty/util/internal/logging/InternalLoggerFactory.java, + * Creates an {@link InternalLogger} or changes the default factory, + * implementation. This factory allows you to choose what logging framework, + * Netty should use. The default factory is {@link Slf4JLoggerFactory}. If SLF4J, + * is not available, {@link Log4JLoggerFactory} is used. If Log4J is not available,, + * {@link JdkLoggerFactory} is used. You can change it to your preferred, + * logging framework before other Netty classes are loaded:, + * <pre>, + * {@link InternalLoggerFactory}.setDefaultFactory({@link Log4JLoggerFactory}.INSTANCE);, + * </pre>, + * Please note that the new default factory is effective only for
[+++ b/testsuite-osgi/testsuite-osgi-exam/pom.xml, + <!-- This test is guaranteed to fail during the release phase; skip'em all -->, + <profiles>, + <profile>, + <id>release</id>, + <properties>, + <skipITs>true</skipITs>, + <skipTests>true</skipTests>, + </properties>, + </profile>, + </profiles>, +, +]
[+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpChannel.java, + *, + * @deprecated use {@link io.netty.channel.sctp.nio.NioSctpChannel}., +@Deprecated, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpChannel.java, + *, + * @deprecated use {@link io.netty.channel.sctp.nio.NioSctpChannel}., +@Deprecated, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpServerChannel.java, + *, + * @deprecated use {@link io.netty.channel.sctp.nio.NioSctpServerChannel}., +@Deprecated, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpChannel.java, + *, + * @deprecated use {@link io.netty.channel.sctp.nio.NioSctpChannel}., +@Deprecated, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpServerChannel.java, + *, + * @deprecated use {@link io.netty.channel.sctp.nio.NioSctpServerChannel}., +@Deprecated, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/oio/package-info.java, + *, + * @deprecated use NIO based SCTP implementation., +@Deprecated, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpChannel.java, + *, + * @deprecated use {@link io.netty.channel.sctp.nio.NioSctpChannel}., +@Deprecated, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpServerChannel.java, + *, + * @deprecated use {@link io.netty.channel.sctp.nio.NioSctpServerChannel}., +@Deprecated, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/oio/package-info.java, + *, + * @deprecated use NIO
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, +import io.netty.handler.codec.compression.ZlibCodecFactory;, + new EmbeddedByteChannel(ZlibCodecFactory.newZlibEncoder(, + wrapper, compressionLevel, windowBits, memLevel)));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, +import io.netty.handler.codec.compression.ZlibCodecFactory;, + new EmbeddedByteChannel(ZlibCodecFactory.newZlibEncoder(, + wrapper, compressionLevel, windowBits, memLevel)));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecompressor.java, +import io.netty.handler.codec.compression.ZlibCodecFactory;, + return new EmbeddedByteChannel(ZlibCodecFactory.newZlibDecoder(ZlibWrapper.GZIP));, + return new EmbeddedByteChannel(ZlibCodecFactory.newZlibDecoder(ZlibWrapper.ZLIB_OR_NONE));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, +import io.netty.handler.codec.compression.ZlibCodecFactory;, + new EmbeddedByteChannel(ZlibCodecFactory.newZlibEncoder(, + wrapper, compressionLevel, windowBits, memLevel)));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecompressor.java, +import io.netty.handler.codec.compression.ZlibCodecFactory;, + return new EmbeddedByteChannel(ZlibCodecFactory.newZlibDecoder(ZlibWrapper.GZIP));, + return new EmbeddedByteChannel(ZlibCodecFactory.newZlibDecoder(ZlibWrapper.ZLIB_OR_NONE));, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_errnoENOTCONN(JNIEnv* env, jclass clazz) {, + return ENOTCONN;, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_errnoENOTCONN(JNIEnv* env, jclass clazz) {, + return ENOTCONN;, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +jint Java_io_netty_channel_epoll_Native_errnoENOTCONN(JNIEnv* env, jclass clazz);, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_errnoENOTCONN(JNIEnv* env, jclass clazz) {, + return ENOTCONN;, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +jint Java_io_netty_channel_epoll_Native_errnoENOTCONN(JNIEnv* env, jclass clazz);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + // This must happen before we attempt to read. This will ensure reading continues until an error occurs., + recvBufAllocHandle().receivedRdHup();, +, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_errnoENOTCONN(JNIEnv* env, jclass clazz) {, + return ENOTCONN;, +}, +,
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/HpackDecoderTest.java, + public final ExpectedException expectedException = ExpectedException.none();, + public void setUp() {]
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, + case NONE:, + break; // exhaustive cases, + default:, + throw new Error("Unknown auth " + clientAuth);]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2EventAdapter.java, + ByteBuf payload) throws Http2Exception {]
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java, +import io.netty.util.AsciiString;, +import io.netty.util.ReferenceCountUtil;, +, +import static org.junit.Assert.assertSame;, +, + @Test, + public void testSelectiveRequestAggregation() {, + HttpObjectAggregator myPostAggregator = new HttpObjectAggregator(1024 * 1024) {, + @Override, + protected boolean isStartMessage(HttpObject msg) throws Exception {, + if (msg instanceof HttpRequest) {, + HttpRequest request = (HttpRequest) msg;, + HttpMethod method = request.method();, +, + if (method.equals(HttpMethod.POST)) {, + return true;, + }, + }, +, + return false;, + }, + };, +, + EmbeddedChannel channel = new EmbeddedChannel(myPostAggregator);, +, + try {, + // Aggregate: POST, + HttpRequest request1 = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, "/");, + HttpContent
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import java.security.AlgorithmConstraints;, +import java.util.Collection;, +import javax.net.ssl.SNIMatcher;, + if (sslParameters.getAlgorithmConstraints() != null) {, + throw new IllegalArgumentException("AlgorithmConstraints are not supported.");, + if (version >= 8) {, + Collection<SNIMatcher> matchers = sslParameters.getSNIMatchers();, + if (matchers != null && !matchers.isEmpty()) {, + throw new IllegalArgumentException("SNIMatchers are not supported.");, + }, +, + if (!isDestroyed()) {, +, + final String endPointIdentificationAlgorithm = sslParameters.getEndpointIdentificationAlgorithm();, + final boolean endPointVerificationEnabled = endPointIdentificationAlgorithm != null &&, + !endPointIdentificationAlgorithm.isEmpty();, + SSL.setHostNameValidation(ssl, DEFAULT_HOSTNAME_VALIDATION_FLAGS,, + endPointVerificationEnabled ? getPeerHost() : null);, + // If the user asks for hostname verification we must ensure we verify the peer., + //
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java, + // TODO: Optimize me., + snappy.decode(in.readSlice(chunkLength - 4), uncompressed, chunkLength);, + out.writeBytes(uncompressed);, + snappy.decode(in.readSlice(chunkLength - 4), out, chunkLength);, +++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java, + // TODO: Optimize me., + snappy.decode(in.readSlice(chunkLength - 4), uncompressed, chunkLength);, + out.writeBytes(uncompressed);, + snappy.decode(in.readSlice(chunkLength - 4), out, chunkLength);, +++ b/codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedDecoderTest.java, +import org.junit.Before;, + private EmbeddedByteChannel channel;, +, + @Before, + public void initChannel() {, + channel = new EmbeddedByteChannel(new SnappyFramedDecoder());, + }, + 0x03, 0x01, 0x00, 0x00, 0x00, + -0x80, 0x05, 0x00, 0x00, 'n', 'e', 't', 't', 'y', + -0x80, 0x06, 0x00, 0x00, 's', 'n', 'e', 't', 't', 'y', + -0x7f, 0x06, 0x00, 0x00, 's',
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrameAggregator.java, + private boolean tooLongFrameFound;, + tooLongFrameFound = false;, + if (tooLongFrameFound) {, + if (msg.isFinalFragment()) {, + currentFrame = null;, + }, + return;, + }, + tooLongFrameFound = true;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrameAggregator.java, + private boolean tooLongFrameFound;, + tooLongFrameFound = false;, + if (tooLongFrameFound) {, + if (msg.isFinalFragment()) {, + currentFrame = null;, + }, + return;, + }, + tooLongFrameFound = true;, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketFrameAggregatorTest.java, + @Test, + try {, + Assert.fail();, + } catch (TooLongFrameException e) {, + // expected, + }, + channel.writeInbound(new ContinuationWebSocketFrame(false, 0, content2.copy()));, + channel.writeInbound(new ContinuationWebSocketFrame(true, 0, content2.copy()));, +, + channel.writeInbound(new BinaryWebSocketFrame(true, 1,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, + } finally {, + headerBlock.release();]
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoder.java, + private static byte padWithZeros(byte b, int lowOrderBitsToPreserve) {, + return (byte) (0x80 & b);, + return (byte) (0xC0 & b);, + return (byte) (0xE0 & b);, + return (byte) (0xF0 & b);, + return (byte) (0xF8 & b);, + return (byte) (0xFC & b);, + return (byte) (0xFE & b);, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoder.java, + private static byte padWithZeros(byte b, int lowOrderBitsToPreserve) {, + return (byte) (0x80 & b);, + return (byte) (0xC0 & b);, + return (byte) (0xE0 & b);, + return (byte) (0xF0 & b);, + return (byte) (0xF8 & b);, + return (byte) (0xFC &
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + consumeBytes(frame.streamId(), frame.windowSizeIncrement(), promise);, + private void consumeBytes(int streamId, int bytes, ChannelPromise promise) {, + promise.setSuccess();, + promise.setFailure(t);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + consumeBytes(frame.streamId(), frame.windowSizeIncrement(), promise);, + private void consumeBytes(int streamId, int bytes, ChannelPromise promise) {, + promise.setSuccess();, + promise.setFailure(t);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameCodecTest.java, + ChannelFuture f = channel.write(new DefaultHttp2WindowUpdateFrame(100).setStreamId(stream.id()));, + assertTrue(f.isSuccess());, + }, +, + @Test, + public void windowUpdateMayFail() throws Exception {, + frameListener.onHeadersRead(http2HandlerCtx, 3, request, 31, false);, + Http2Connection connection = framingCodec.connectionHandler().connection();, + Http2Stream stream = connection.stream(3);, + assertNotNull(stream);, +, + // Fails, cause trying to return too many bytes to the flow controller, + ChannelFuture f =
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.ResourceLeakDetectorFactory;, + static final ResourceLeakDetector<ByteBuf> leakDetector =, + ResourceLeakDetectorFactory.instance().newResourceLeakDetector(ByteBuf.class);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.ResourceLeakDetectorFactory;, + static final ResourceLeakDetector<ByteBuf> leakDetector =, + ResourceLeakDetectorFactory.instance().newResourceLeakDetector(ByteBuf.class);, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsMessage.java, +import io.netty.util.ResourceLeakDetectorFactory;, + ResourceLeakDetectorFactory.instance().newResourceLeakDetector(DnsMessage.class);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.ResourceLeakDetectorFactory;, + static final ResourceLeakDetector<ByteBuf> leakDetector =, + ResourceLeakDetectorFactory.instance().newResourceLeakDetector(ByteBuf.class);, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsMessage.java, +import io.netty.util.ResourceLeakDetectorFactory;, + ResourceLeakDetectorFactory.instance().newResourceLeakDetector(DnsMessage.class);, +++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java, +public class ResourceLeakDetector<T> {, + reportInstancesLeak(resourceType);, + reportUntracedLeak(resourceType);, + } else {, + reportTracedLeak(resourceType, records);, + }, + }, + }, + }, +, + /**, + * This method is called when a traced leak is detected. It can be overridden for tracking how many times leaks, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + * Performs the opening handshake. When call this method you <strong>MUST NOT</strong> retain the, + * {@link FullHttpRequest} which is passed in., + * @return future, + * The {@link ChannelFuture} which is notified once the opening handshake completes, + * When call this method you <strong>MUST NOT</strong> retain the {@link FullHttpRequest} which is passed in., + *, + * @return future, + * the {@link ChannelFuture} which is notified when the opening handshake is done]
[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractFuture.java, +import java.util.concurrent.CancellationException;, + if (cause instanceof CancellationException) {, + throw (CancellationException) cause;, + }, + if (cause instanceof CancellationException) {, + throw (CancellationException) cause;, + }, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractFuture.java, +import java.util.concurrent.CancellationException;, + if (cause instanceof CancellationException) {, + throw (CancellationException) cause;, + }, + if (cause instanceof CancellationException) {, + throw (CancellationException) cause;, + }, +++ b/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java, +import java.util.concurrent.CancellationException;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.TimeoutException;, + @Test(expected = CancellationException.class), + public void testCancellationExceptionIsThrownWhenBlockingGet() throws InterruptedException, ExecutionException {, + final Promise<Void> promise = new DefaultPromise<Void>(ImmediateEventExecutor.INSTANCE);, + promise.cancel(false);, + promise.get();, + }, +, + @Test(expected = CancellationException.class), + public void testCancellationExceptionIsThrownWhenBlockingGetWithTimeout() throws
[+++ b/all/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/example/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/codec/pom.xml, +
[+++ b/pom.xml, + <version>3.2.0.ALPHA1</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.2.0.ALPHA1</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.2.0.ALPHA1</developerConnection>]
[+++ b/pom.xml, + <jetty.alpnAgent.version>2.0.4</jetty.alpnAgent.version>]
[+++ b/common/src/main/java/io/netty/util/Attribute.java, + * An attribute which allows to store a value reference. It may be updated atomically and so is thread-safe., +, + /**, + * Returns the key of this attribute., + */, + AttributeKey<T> key();, +, + * Removes this attribute from the {@link AttributeMap} and returns the old value.. Subsequent {@link #get()}, + * calls will return @{code null}., + */, + T getAndRemove();, +, + /**, + * Removes this attribute from the {@link AttributeMap}. Subsequent {@link #get()} calls will return @{code null}., +++ b/common/src/main/java/io/netty/util/Attribute.java, + * An attribute which allows to store a
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java, + aEnd = sb.indexOf(';');, + if (aEnd == -1) {, + if (sb.charAt(aEnd - 1) == ' ') {, + bStart = HttpPostBodyUtil.findNonWhitespace(sb, aEnd + 1);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java, + aEnd = sb.indexOf(';');, + if (aEnd == -1) {, + if (sb.charAt(aEnd - 1) == ' ') {, + bStart = HttpPostBodyUtil.findNonWhitespace(sb, aEnd + 1);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java, + @Test, + public void testBinaryStreamUploadWithSpace() throws Exception {, + testBinaryStreamUpload(true);, + }, +, + // https://github.com/netty/netty/issues/1575, + @Test, + public void testBinaryStreamUploadWithoutSpace() throws Exception {, + testBinaryStreamUpload(false);, + }, +, + private static void testBinaryStreamUpload(boolean withSpace) throws Exception {, +
[+++ b/.gitignore, +, +# exclude docker-sync stuff, +.docker-sync, +*/.docker-sync]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerSocketChannel.java, + local = Native.localAddress(fd);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerSocketChannel.java, + local = Native.localAddress(fd);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, + private volatile InetSocketAddress local;, + private volatile InetSocketAddress remote;, + return local;, + return remote;, + this.local = Native.localAddress(fd);, + remote = remoteAddress;, + local = Native.localAddress(fd);]
[+++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxy.java, + new HexDumpProxy(localPort, remoteHost, remotePort).run();]
[+++ b/transport/src/main/java/io/netty/channel/ChannelFuture.java, + * <b>b.option({@link ChannelOption}.CONNECT_TIMEOUT_MILLIS, 10000);</b>]
[+++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java, +import java.util.Map.Entry;, +public interface ChannelPipeline extends ChannelInboundInvoker, ChannelOutboundInvoker,, + Iterable<Entry<String, ChannelHandler>> {, +++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java, +import java.util.Map.Entry;, +public interface ChannelPipeline extends ChannelInboundInvoker, ChannelOutboundInvoker,, + Iterable<Entry<String, ChannelHandler>> {, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, +import java.util.Iterator;, +, + @Override, + public Iterator<Map.Entry<String, ChannelHandler>> iterator() {, + return toMap().entrySet().iterator();, + }]
[+++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioSocketChannel.java, +import org.jboss.netty.channel.socket.nio.SocketSendBufferPool.SendBuffer;, + SendBuffer currentWriteBuffer;, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioSocketChannel.java, +import org.jboss.netty.channel.socket.nio.SocketSendBufferPool.SendBuffer;, + SendBuffer currentWriteBuffer;, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java, +import org.jboss.netty.channel.socket.nio.SocketSendBufferPool.SendBuffer;, + private final SocketReceiveBufferPool recvBufferPool = new SocketReceiveBufferPool();, + private final SocketSendBufferPool sendBufferPool = new SocketSendBufferPool();, + ByteBuffer bb = recvBufferPool.acquire(buffer.writableBytes());, + recvBufferPool.release(bb);, + final SocketSendBufferPool sendBufferPool = this.sendBufferPool;, + SendBuffer buf;, + ByteBuffer bb;, + channel.currentWriteBuffer = buf = sendBufferPool.acquire(origBuf);, + bb = buf.buffer;, + bb = buf.buffer;, + int localWrittenBytes = ch.write(bb);, + if (!bb.hasRemaining()) {, + buf.release();, + bb = null;, + buf.release();, + bb = null;, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioSocketChannel.java, +import org.jboss.netty.channel.socket.nio.SocketSendBufferPool.SendBuffer;, + SendBuffer currentWriteBuffer;, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java, +import org.jboss.netty.channel.socket.nio.SocketSendBufferPool.SendBuffer;,
[+++ b/handler/src/main/java/io/netty/handler/ssl/Conscrypt.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +public class DefaultCompositeByteBuf extends AbstractReferenceCountedByteBuf implements CompositeByteBuf {, + if (buffers instanceof ByteBuf) {, + // If buffers also implements ByteBuf (e.g. CompositeByteBuf), it has to go to addComponent(ByteBuf)., + return addComponent0(cIndex, (ByteBuf) buffers);, + if (!(buffers instanceof Collection)) {, + buffers = list;, + }, +, + Collection<ByteBuf> col = (Collection<ByteBuf>) buffers;, + return addComponents0(cIndex, col.toArray(new ByteBuf[col.size()]));, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +public class DefaultCompositeByteBuf extends AbstractReferenceCountedByteBuf implements CompositeByteBuf {, + if (buffers instanceof ByteBuf) {, + // If buffers also implements ByteBuf (e.g. CompositeByteBuf), it has to go to addComponent(ByteBuf)., + return addComponent0(cIndex, (ByteBuf) buffers);, + if (!(buffers
[+++ b/handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java, +import java.security.PrivateKey;, +import javax.net.ssl.ExtendedSSLSession;, +import javax.net.ssl.KeyManager;, +import javax.net.ssl.KeyManagerFactorySpi;, +import javax.net.ssl.X509ExtendedKeyManager;, + public void testSupportedSignatureAlgorithms() throws Exception {, + final SelfSignedCertificate ssc = new SelfSignedCertificate();, +, + final class TestKeyManagerFactory extends KeyManagerFactory {, + TestKeyManagerFactory(final KeyManagerFactory factory) {, + super(new KeyManagerFactorySpi() {, +, + private final KeyManager[] managers = factory.getKeyManagers();, +, + @Override, + protected void engineInit(KeyStore keyStore, char[] chars) {, + throw new UnsupportedOperationException();, + }, +, + @Override, + protected void engineInit(ManagerFactoryParameters managerFactoryParameters) {, + throw new UnsupportedOperationException();, + }, +, + @Override, + protected KeyManager[] engineGetKeyManagers() {, + KeyManager[] array = new KeyManager[managers.length];, +, +
[+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + assert memory != null;, +]
[+++ b/microbench/pom.xml, + <version>0.3.2</version>, +++ b/microbench/pom.xml, + <version>0.3.2</version>, +++ b/microbench/src/test/java/io/netty/microbench/util/AbstractMicrobenchmark.java, +import org.openjdk.jmh.runner.options.VerboseMode;, + protected static final String[] JVM_ARGS = new String[] {, + "-server", "-dsa", "-da", "-ea:io.netty...", "-Xms768m", "-Xmx768m",, + "-XX:MaxDirectMemorySize=768m", "-XX:+AggressiveOpts", "-XX:+UseBiasedLocking",, + "-XX:+UseFastAccessorMethods", "-XX:+UseStringCache", "-XX:+OptimizeStringConcat",, + "-XX:+HeapDumpOnOutOfMemoryError", "-Dio.netty.noResourceLeakDetection", + };]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CombinedHttpHeaders.java, +import java.util.List;, + public List<CharSequence> getAll(CharSequence name) {, + List<CharSequence> values = super.getAll(name);, + if (values.isEmpty()) {, + return values;, + }, + if (values.size() != 1) {, + throw new IllegalStateException("CombinedHttpHeaders should only have one value");, + }, + return StringUtil.unescapeCsvFields(values.get(0));, + }, +, + @Override, + public CombinedHttpHeadersImpl setObject(CharSequence name, Object value) {, + super.set(name, commaSeparate(objectEscaper(), value));, + return this;, + }, +, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CombinedHttpHeaders.java, +import java.util.List;, + public List<CharSequence> getAll(CharSequence name) {, + List<CharSequence> values = super.getAll(name);, + if (values.isEmpty()) {, + return values;, + }, + if (values.size() != 1) {,
[+++ b/codec-dns/src/test/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoderTest.java, +import io.netty.util.internal.SocketUtils;, + testOptEcsRecordIp(SocketUtils.addressByName("1.2.3.4"));, + testOptEcsRecordIp(SocketUtils.addressByName("::0"));, +++ b/codec-dns/src/test/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoderTest.java, +import io.netty.util.internal.SocketUtils;, + testOptEcsRecordIp(SocketUtils.addressByName("1.2.3.4"));, + testOptEcsRecordIp(SocketUtils.addressByName("::0"));, +++ b/codec-dns/src/test/java/io/netty/handler/codec/dns/DnsQueryTest.java, +import io.netty.util.internal.SocketUtils;, + InetSocketAddress addr = SocketUtils.socketAddress("8.8.8.8", 53);, +++ b/codec-dns/src/test/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoderTest.java, +import io.netty.util.internal.SocketUtils;, + testOptEcsRecordIp(SocketUtils.addressByName("1.2.3.4"));, + testOptEcsRecordIp(SocketUtils.addressByName("::0"));, +++ b/codec-dns/src/test/java/io/netty/handler/codec/dns/DnsQueryTest.java, +import io.netty.util.internal.SocketUtils;, + InetSocketAddress addr = SocketUtils.socketAddress("8.8.8.8", 53);, +++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdRequestDecoderTest.java, +import io.netty.util.internal.SocketUtils;, + String[] hosts = {SocksCommonUtils.ipv6toStr(SocketUtils.addressByName("::1").getAddress())};, +++ b/codec-dns/src/test/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoderTest.java, +import io.netty.util.internal.SocketUtils;, + testOptEcsRecordIp(SocketUtils.addressByName("1.2.3.4"));, + testOptEcsRecordIp(SocketUtils.addressByName("::0"));, +++ b/codec-dns/src/test/java/io/netty/handler/codec/dns/DnsQueryTest.java, +import io.netty.util.internal.SocketUtils;, + InetSocketAddress addr = SocketUtils.socketAddress("8.8.8.8", 53);, +++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdRequestDecoderTest.java, +import io.netty.util.internal.SocketUtils;, + String[] hosts = {SocksCommonUtils.ipv6toStr(SocketUtils.addressByName("::1").getAddress())};, +++ b/codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/Socks5CommandRequestDecoderTest.java, +import io.netty.util.internal.SocketUtils;, + NetUtil.bytesToIpAddress(SocketUtils.addressByName("::1").getAddress()) };, +++ b/codec-dns/src/test/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoderTest.java, +import io.netty.util.internal.SocketUtils;, + testOptEcsRecordIp(SocketUtils.addressByName("1.2.3.4"));, + testOptEcsRecordIp(SocketUtils.addressByName("::0"));, +++ b/codec-dns/src/test/java/io/netty/handler/codec/dns/DnsQueryTest.java, +import io.netty.util.internal.SocketUtils;,
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelPromise.java, +import java.util.Arrays;, + notifyListeners0(this, (DefaultChannelPromiseListeners) listeners);, + notifyListeners0(DefaultChannelPromise.this, (DefaultChannelPromiseListeners) listeners);, + private static void notifyListeners0(ChannelFuture f, DefaultChannelPromiseListeners listeners) {, + final ChannelFutureListener[] a = listeners.listeners();, + final int size = listeners.size();, + for (int i = 0; i < size; i ++) {, + notifyListener0(f, a[i]);, + }, + }, +, + private static final class DefaultChannelPromiseListeners {, + private ChannelFutureListener[] listeners;, + private int size;, + listeners = new ChannelFutureListener[] { firstListener, secondListener };, + size = 2;, + }, +, + void add(ChannelFutureListener l) {, + ChannelFutureListener[] listeners = this.listeners;, + final int size =
[+++ b/common/pom.xml, + <properties>, + <collection.template.dir>${project.basedir}/src/main/templates</collection.template.dir>, + <collection.template.test.dir>${project.basedir}/src/test/templates</collection.template.test.dir>, + <collection.src.dir>${project.build.directory}/generated-sources/collections/java</collection.src.dir>, + <collection.testsrc.dir>${project.build.directory}/generated-test-sources/collections/java</collection.testsrc.dir>, + </properties>, +, +, + <build>, + <plugins>, + <!-- Add generated collection sources. -->, + <plugin>, + <groupId>org.codehaus.mojo</groupId>, + <artifactId>build-helper-maven-plugin</artifactId>, + <version>1.9.1</version>, + <executions>, + <execution>, + <id>add-source</id>, + <phase>generate-sources</phase>, + <goals>, + <goal>add-source</goal>, + </goals>, + <configuration>, + <sources>, + <source>${collection.src.dir}</source>, + </sources>, + </configuration>, + </execution>, + <execution>, + <id>add-test-source</id>, + <phase>generate-test-sources</phase>, + <goals>, + <goal>add-test-source</goal>, + </goals>, + <configuration>, + <sources>, + <source>${collection.testsrc.dir}</source>, + </sources>, + </configuration>, + </execution>, + </executions>, + </plugin>, +, + <!-- Generate the primitive collections from the template
[+++ b/COPYRIGHT.txt, +amit.bhayani@jboss.com Amit Bhayani, +++ b/COPYRIGHT.txt, +amit.bhayani@jboss.com Amit Bhayani, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, + * @author <a href="http://www.jboss.org/netty/">The Netty Project</a>, + * @author <a href="http://gleamynode.net/">Trustin Lee</a>, +++ b/COPYRIGHT.txt, +amit.bhayani@jboss.com Amit Bhayani, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, + * @author <a href="http://www.jboss.org/netty/">The Netty Project</a>, + * @author <a href="http://gleamynode.net/">Trustin Lee</a>, +++ b/src/main/java/org/jboss/netty/bootstrap/ClientBootstrap.java, + * @author <a href="http://www.jboss.org/netty/">The Netty Project</a>, + * @author <a href="http://gleamynode.net/">Trustin Lee</a>, +++ b/COPYRIGHT.txt, +amit.bhayani@jboss.com Amit Bhayani, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, + * @author <a href="http://www.jboss.org/netty/">The Netty Project</a>, + * @author <a href="http://gleamynode.net/">Trustin Lee</a>, +++ b/src/main/java/org/jboss/netty/bootstrap/ClientBootstrap.java, + * @author <a href="http://www.jboss.org/netty/">The Netty Project</a>, + * @author <a href="http://gleamynode.net/">Trustin Lee</a>, +++ b/src/main/java/org/jboss/netty/bootstrap/ConnectionlessBootstrap.java, + *
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * either share or contains the copied content of this buffer, while changing the position, + * and limit of the returned NIO buffer does not affect the indexes and marks of this buffer., + * This method is identical to {@code buf.nioBuffer(buf.readerIndex(), buf.readableBytes())}., + * This method does not modify {@code readerIndex} or {@code writerIndex} of this buffer., + * Please note that the returned NIO buffer will not see the changes of this buffer if this buffer, + * is a dynamic buffer and it adjusted its capacity., + * either share or contains
[+++ b/.gitignore, +++ b/.gitignore, +++ b/pom.xml, + <repositories>, + <repository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </repository>, + </repositories>, +, + <pluginRepositories>, + <pluginRepository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </pluginRepository>, + </pluginRepositories>, +, + <version>2.3.0</version>, + <version>1.6.1</version>, + <version>4.8.2</version>, + <version>2.5.2</version>, + <version>2.5.2</version>, + <version>1.6.1</version>, + <version>1.0</version>, + <version>2.4.3</version>, + <version>2.7.2</version>, + <version>1.6</version>, + <version>2.7</version>, + <groupId>org.jboss.maven.plugins</groupId>, + <artifactId>maven-jdocbook-plugin</artifactId>, + <id>generate-docbook</id>, + <phase>package</phase>, + <goals>, + <goal>resources</goal>, + <goal>generate</goal>, + </goals>, + </execution>, + </executions>, + <dependencies>, + <dependency>, + <groupId>org.jboss</groupId>, + <artifactId>jbossorg-docbook-xslt</artifactId>, + <version>1.1.0</version>, + <exclusions>, + <exclusion>, + <groupId>org.eclipse.wst.css</groupId>, + <artifactId>core</artifactId>, + </exclusion>, + <exclusion>, + <groupId>org.eclipse.wst.sse</groupId>, +
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.ResourceLeakDetector;, +, + static final ResourceLeakDetector<ByteBuf> leakDetector = new ResourceLeakDetector<ByteBuf>(ByteBuf.class);, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.ResourceLeakDetector;, +, + static final ResourceLeakDetector<ByteBuf> leakDetector = new ResourceLeakDetector<ByteBuf>(ByteBuf.class);, +, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +import io.netty.util.ResourceLeak;, + private final ResourceLeak leak = leakDetector.open(this);, +, + leak.close();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.ResourceLeakDetector;, +, + static final ResourceLeakDetector<ByteBuf> leakDetector = new ResourceLeakDetector<ByteBuf>(ByteBuf.class);, +, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +import io.netty.util.ResourceLeak;, + private final ResourceLeak leak = leakDetector.open(this);, +, + leak.close();, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, +import io.netty.util.ResourceLeak;, +, + private final ResourceLeak leak = leakDetector.open(this);, +, + leak.close();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.ResourceLeakDetector;, +, + static final ResourceLeakDetector<ByteBuf> leakDetector = new ResourceLeakDetector<ByteBuf>(ByteBuf.class);, +,
[+++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java, + ChannelFuture lastContentFuture;, + // Write the end marker., + lastContentFuture = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);, + // HttpChunkedInput will write the end marker (LastHttpContent) for us., + lastContentFuture = sendFileFuture;]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + try {, + } catch (Throwable t) {, + if (logger.isWarnEnabled()) {, + logger.warn("Failed to submit an exceptionCaught() event.", t);, + logger.warn("The exceptionCaught() event that was failed to submit was:", cause);, + }, + }, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + try {, + } catch (Throwable t) {, + if (logger.isWarnEnabled()) {, + logger.warn("Failed to submit an exceptionCaught() event.", t);, + logger.warn("The exceptionCaught() event that was failed to submit was:", cause);, + }, + }, +++ b/transport/src/main/java/io/netty/channel/MultithreadEventExecutor.java, + throw new UnsupportedOperationException();]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, +import io.netty.util.internal.StringUtil;, + protected SelectedProtocol getProtocol(SSLEngine engine) {, + String[] protocol = StringUtil.split(engine.getSession().getProtocol(), ':');, + if (protocol.length < 2) {, + // Use HTTP/1.1 as default, + return SelectedProtocol.HTTP_1_1;, + }, + SelectedProtocol selectedProtocol = SelectedProtocol.protocol(protocol[1]);, + return selectedProtocol;, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, +import io.netty.util.internal.StringUtil;, + protected SelectedProtocol getProtocol(SSLEngine engine) {, + String[] protocol = StringUtil.split(engine.getSession().getProtocol(), ':');, + if (protocol.length < 2) {, + // Use HTTP/1.1 as default, + return SelectedProtocol.HTTP_1_1;, + }, + SelectedProtocol selectedProtocol = SelectedProtocol.protocol(protocol[1]);, + return selectedProtocol;, + }, +++ b/example/src/main/java/io/netty/example/spdy/server/SpdyOrHttpHandler.java]
[+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java, + if (currentMessage != null) {, + currentMessage.release();]
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, + NetworkInterface iface = NetworkInterface.getByInetAddress(InetAddress.getLoopbackAddress());, +, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, + NetworkInterface iface = NetworkInterface.getByInetAddress(InetAddress.getLoopbackAddress());, +, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/nio/oio/NioOioDatagramMulticastTest.java, + return new NioDatagramChannelFactory(executor);, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, + NetworkInterface iface = NetworkInterface.getByInetAddress(InetAddress.getLoopbackAddress());, +, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/nio/oio/NioOioDatagramMulticastTest.java, + return new NioDatagramChannelFactory(executor);, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Exception e) {, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, + NetworkInterface iface = NetworkInterface.getByInetAddress(InetAddress.getLoopbackAddress());, +, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/nio/oio/NioOioDatagramMulticastTest.java, + return new NioDatagramChannelFactory(executor);, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Exception e) {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +import java.io.IOException;, +import java.net.InetSocketAddress;, +import java.net.SocketAddress;, +import java.nio.channels.NotYetConnectedException;, +import java.nio.channels.SelectionKey;, +, + EventLoop eventLoop();, +, +, + ChannelFuture deregister();, + void deregister(ChannelFuture future);, +, + Unsafe unsafe();, +, + public interface
[+++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostBodyUtil.java, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostBodyUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostBodyUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, +++
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + region.release();, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + region.release();, +++ b/transport/src/main/java/io/netty/channel/DefaultFileRegion.java, +import io.netty.buffer.AbstractReferenceCounted;, +public class DefaultFileRegion extends AbstractReferenceCounted implements FileRegion {, + protected void deallocate() {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + region.release();, +++ b/transport/src/main/java/io/netty/channel/DefaultFileRegion.java, +import io.netty.buffer.AbstractReferenceCounted;, +public class DefaultFileRegion extends AbstractReferenceCounted implements FileRegion {, + protected void deallocate() {, +++ b/transport/src/main/java/io/netty/channel/FileRegion.java, +import io.netty.buffer.ReferenceCounted;, +, +public interface FileRegion extends ReferenceCounted {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + region.release();, +++ b/transport/src/main/java/io/netty/channel/DefaultFileRegion.java, +import io.netty.buffer.AbstractReferenceCounted;, +public class DefaultFileRegion extends AbstractReferenceCounted implements FileRegion {, + protected void deallocate() {, +++ b/transport/src/main/java/io/netty/channel/FileRegion.java, +import io.netty.buffer.ReferenceCounted;, +, +public interface FileRegion extends ReferenceCounted {, +++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, + * Copyright 2013 The Netty Project, +import
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/CompositeBufferGatheringWriteTest.java, +import io.netty.channel.ChannelConfig;, +import io.netty.channel.ChannelOption;, +import io.netty.channel.socket.nio.NioSocketChannel;, +import java.util.Random;, + @Test(timeout = 10000), + public void testCompositeBufferPartialWriteDoesNotCorruptData() throws Throwable {, + run();, + }, +, + protected void compositeBufferPartialWriteDoesNotCorruptDataInitServerConfig(ChannelConfig config,, + int soSndBuf) {, + }, +, + public void testCompositeBufferPartialWriteDoesNotCorruptData(ServerBootstrap sb, Bootstrap cb) throws Throwable {, + // The scenario is the following:, + // Limit SO_SNDBUF so that a single buffer can be written, and part of a CompositeByteBuf at the same time., + // We then write the single buffer, the CompositeByteBuf, and another single buffer and verify the data is not, + // corrupted
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * The reader and writer marks will not be duplicated.]
[+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java, + return;]
[+++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, + return copy;, +++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, + return copy;, +++ b/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java, + return copy;]
[+++ b/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayDecoderTest.java, +import io.netty.channel.embedded.EmbeddedMessageChannel;, + private EmbeddedMessageChannel ch;, + ch = new EmbeddedMessageChannel(new ByteArrayDecoder());, + ch.writeInbound(wrappedBuffer(b));, + assertThat((byte[]) ch.readInbound(), is(b));, + ch.writeInbound(wrappedBuffer(b));, + assertThat((byte[]) ch.readInbound(), is(b));, + ch.writeInbound(str);, + assertThat(ch.readInbound(), is((Object) str));, +++ b/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayDecoderTest.java, +import io.netty.channel.embedded.EmbeddedMessageChannel;, + private EmbeddedMessageChannel ch;, + ch = new EmbeddedMessageChannel(new ByteArrayDecoder());, + ch.writeInbound(wrappedBuffer(b));, + assertThat((byte[]) ch.readInbound(), is(b));, + ch.writeInbound(wrappedBuffer(b));, + assertThat((byte[]) ch.readInbound(), is(b));, + ch.writeInbound(str);, + assertThat(ch.readInbound(), is((Object) str));, +++ b/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayEncoderTest.java, +import io.netty.channel.embedded.EmbeddedMessageChannel;, + private EmbeddedMessageChannel ch;, + ch = new EmbeddedMessageChannel(new ByteArrayEncoder());, + ch.writeOutbound(b);, + assertThat((ChannelBuffer) ch.readOutbound(), is(wrappedBuffer(b)));, + ch.writeOutbound(b);, + assertThat(ch.readOutbound(), nullValue());, + ch.writeOutbound(str);, + assertThat(ch.readOutbound(), is((Object) str));, +++ b/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayDecoderTest.java, +import io.netty.channel.embedded.EmbeddedMessageChannel;,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelFutureListener;, +import static io.netty.handler.codec.http.HttpHeaders.*;, +, + private static final FullHttpResponse CONTINUE =, + new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE, Unpooled.EMPTY_BUFFER);, + protected void decode(final ChannelHandlerContext ctx, HttpObject msg, List<Object> out) throws Exception {, + ctx.writeAndFlush(CONTINUE).addListener(new ChannelFutureListener() {, + @Override, + public void operationComplete(ChannelFuture future) throws Exception {, + if (!future.isSuccess()) {, + ctx.fireExceptionCaught(future.cause());, + }, + }, + });, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelFutureListener;, +import static io.netty.handler.codec.http.HttpHeaders.*;, +, + private static final FullHttpResponse CONTINUE =, + new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE, Unpooled.EMPTY_BUFFER);, + protected void decode(final ChannelHandlerContext ctx, HttpObject msg, List<Object> out) throws Exception {, + ctx.writeAndFlush(CONTINUE).addListener(new ChannelFutureListener()
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/DefaultCookie.java, + if (!name().equals(that.name())) {, + int v = name().compareTo(c.name());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/DefaultCookie.java, + if (!name().equals(that.name())) {, + int v = name().compareTo(c.name());, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/cookie/ServerCookieDecoderTest.java, + assertEquals("ARPT", c.name());, + assertEquals("LWUKQPSWRTUN04CKKJI", c.value());, +, + c = it.next();, +, + @Test, + public void testCaseSensitiveNames() {, + Set<Cookie> cookies = ServerCookieDecoder.STRICT.decode("session_id=a; Session_id=b;");, + Iterator<Cookie> it = cookies.iterator();, + Cookie c;, +, + c = it.next();, + assertEquals("Session_id", c.name());, + assertEquals("b", c.value());, +, + c = it.next();, + assertEquals("session_id", c.name());, + assertEquals("a", c.value());, +, + assertFalse(it.hasNext());, + }]
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java, + if (!promise.trySuccess(castResponse)) {, + // We failed to notify the promise as it was failed before, thus we need to release the envelope, + envelope.release();, + }]
[+++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, + // fall through]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (isFreed()) {, + return getClass().getSimpleName() + "(freed)";, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (isFreed()) {, + return getClass().getSimpleName() + "(freed)";, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, + return getClass().getSimpleName() + '(' + data().toString() + ')';, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (isFreed()) {, + return getClass().getSimpleName() + "(freed)";, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, + return getClass().getSimpleName() + '(' + data().toString() + ')';, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, + * {@link HttpRequest} req = ...;, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (isFreed()) {, + return getClass().getSimpleName() + "(freed)";, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, + return getClass().getSimpleName() + '(' + data().toString() + ')';, +++
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_MAX_RESERVED_STREAMS;, +import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;, + private Integer maxReservedStreams;, + * Get the maximum number of streams which can be in the reserved state at any given time., + * <p>, + * By default this value will be ignored on the server for local endpoint. This is because the RFC provides, + * no way to explicitly communicate a limit to how many states can be in the reserved state, and instead relies, + * on the peer to send RST_STREAM frames when they will be rejected., + */, + protected int maxReservedStreams() {, +
[+++ b/pom.xml, + <resources>, + <resource>, + <directory>${basedir}/src/main/resources</directory>, + </resource>, + <resource>, + <directory>${basedir}/target/license</directory>, + </resource>, + </resources>, +, + <outputDirectory>${basedir}/target/license/META-INF</outputDirectory>]
[+++ b/handler/src/main/java/io/netty/handler/ssl/ExtendedOpenSslSession.java, +import java.util.Collections;, + // Do not mark as override so we can compile on java8., + public List<byte[]> getStatusResponses() {, + // Just return an empty list for now until we support it as otherwise we will fail in java9, + // because of their sun.security.ssl.X509TrustManagerImpl class., + return Collections.emptyList();, + }, +]
[+++ b/all/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta7-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, + public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {, + if (logger.isEnabled(internalLevel)) {, + logger.log(internalLevel, format(ctx, "READ COMPLETE"));, + }, + ctx.fireChannelReadComplete();, + }, +, + @Override, + logger.log(internalLevel, format(ctx, "READ", msg));, + public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {, + if (logger.isEnabled(internalLevel)) {, + logger.log(internalLevel, format(ctx, "WRITABILITY CHANGED"));, + }, + ctx.fireChannelWritabilityChanged();, + }, +, + @Override, +++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, + public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {, + if (logger.isEnabled(internalLevel)) {, + logger.log(internalLevel, format(ctx, "READ COMPLETE"));, + }, + ctx.fireChannelReadComplete();, + }, +, + @Override, + logger.log(internalLevel, format(ctx, "READ", msg));, + public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception
[+++ b/codec/src/main/java/io/netty/handler/codec/marshalling/ChannelBufferByteInput.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java, + // Only try if not empty as otherwise we will produce an exception, + if (dnsUrls != null && !dnsUrls.isEmpty()) {, + String host = new URI(server).getHost();, +, + if (host == null || host.isEmpty()) {, + logger.debug(, + "Skipping a nameserver URI as host portion could not be extracted: {}", server);, + // If the host portion can not be parsed we should just skip this entry., + continue;, + }, + }]
[+++ b/codec/src/main/java/io/netty/handler/codec/base64/Base64.java, + ByteBuf dest = allocator.buffer(encodedBufferSize(len, breakLines)).order(src.order());, + // package-private for testing, + static int encodedBufferSize(int len, boolean breakLines) {, + // Cast len to long to prevent overflow, + long len43 = ((long) len << 2) / 3;, +, + // Account for padding, + long ret = (len43 + 3) & ~3;, +, + if (breakLines) {, + ret += len43 / MAX_LINE_LENGTH;, + }, +, + return ret < Integer.MAX_VALUE ? (int) ret : Integer.MAX_VALUE;, + }, +, + // package-private for testing, + static int decodedBufferSize(int len) {, + return len - (len >>>
[+++ b/buffer/src/main/java/io/netty/buffer/UnpooledByteBufAllocator.java, + protected byte[] allocateArray(int initialCapacity) {, + protected void freeArray(byte[] array) {, + protected byte[] allocateArray(int initialCapacity) {, + protected void freeArray(byte[] array) {, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledByteBufAllocator.java, + protected byte[] allocateArray(int initialCapacity) {, + protected void freeArray(byte[] array) {, + protected byte[] allocateArray(int initialCapacity) {, + protected void freeArray(byte[] array) {, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java, + protected byte[] allocateArray(int initialCapacity) {, + protected void freeArray(byte[] array) {, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledByteBufAllocator.java, + protected byte[] allocateArray(int initialCapacity) {, + protected void freeArray(byte[] array) {, + protected byte[] allocateArray(int initialCapacity) {, + protected void freeArray(byte[] array) {, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java, + protected byte[] allocateArray(int initialCapacity)
[+++ b/src/docbook/en-US/master.xml, +<?xml version="1.0" encoding="ISO-8859-1"?>]
[+++ b/handler/src/main/java/io/netty/handler/ssl/NotSslRecordException.java, + public NotSslRecordException() {, + super("");, +, + public NotSslRecordException(String message) {, + super(message);, + }, +, + public NotSslRecordException(Throwable cause) {, + super(cause);, + }, +, + public NotSslRecordException(String message, Throwable cause) {, + super(message, cause);, + }, +]
[+++ b/testsuite-shading/src/test/java/io/netty/testsuite/shading/ShadingIT.java]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, +import io.netty.buffer.Unpooled;, +, + // IllegalStateException will be thrown as we did not write anything, + // Its ok to just write an EMPTY_BUFFER as if there are reference count issues these will be, + // propagated as the caller of the encode(...) method will release the original, + // buffer., + // Writing an empty buffer will not actually write anything on the wire, so if there is a user, + // error with msg it will not be visible externally, + out.add(Unpooled.EMPTY_BUFFER);, + out.add(encodeAndRetain(msg));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, +import io.netty.buffer.Unpooled;, +, + // IllegalStateException will be thrown
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java, +, + @Test, + public void testSimpleSendWithoutBind() throws Throwable {, + //run();, + }, +, + public void testSimpleSendWithoutBind(Bootstrap sb, Bootstrap cb) throws Throwable {, + final CountDownLatch latch = new CountDownLatch(1);, +, + sb.handler(new SimpleChannelInboundHandler<DatagramPacket>() {, + @Override, + public void channelRead0(ChannelHandlerContext ctx, DatagramPacket msg) throws Exception {, + assertEquals(1, msg.content().readInt());, + latch.countDown();, + }, + });, +, + cb.handler(new SimpleChannelInboundHandler<Object>() {, + @Override, + public void channelRead0(ChannelHandlerContext ctx, Object msgs) throws Exception {, + // Nothing will be sent., + }, + });, +, + Channel sc = sb.bind().sync().channel();, + Channel cc = cb.register().sync().channel();, +,
[+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + if (ResourceLeakDetector.isEnabled()) {]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + if (SystemPropertyUtil.getBoolean("io.netty.handler.ssl.noOpenSsl", false)) {, + cause = new UnsupportedOperationException(, + "OpenSSL was explicit disabled with -Dio.netty.handler.ssl.noOpenSsl=true");, +, + logger.debug(, + "netty-tcnative explicit disabled; " +, + OpenSslEngine.class.getSimpleName() + " will be unavailable.", cause);, + } else {, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + if (SystemPropertyUtil.getBoolean("io.netty.handler.ssl.noOpenSsl", false)) {, + cause = new UnsupportedOperationException(, + "OpenSSL was explicit disabled with -Dio.netty.handler.ssl.noOpenSsl=true");, +, + logger.debug(, + "netty-tcnative explicit disabled; " +, + OpenSslEngine.class.getSimpleName() + " will be unavailable.", cause);, + } else {, + }, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Epoll.java, +import io.netty.util.internal.SystemPropertyUtil;, +, + if (SystemPropertyUtil.getBoolean("io.netty.transport.noNative", false)) {, + cause = new UnsupportedOperationException(,
[+++ b/example/src/main/java/io/netty/example/echo/EchoClientHandler.java, +import io.netty.channel.ChannelInboundStreamHandlerAdapter;, +public class EchoClientHandler extends ChannelInboundStreamHandlerAdapter {, + public void inboundBufferUpdated(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in) {]
[+++ b/pom.xml, + <version>2.22.1</version>, + <version>2.22.1</version>]
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java, +import io.netty.util.NetUtil;, +import java.net.Inet6Address;, + // Depending if IPv6 or IPv4 is used choose the correct DNS servers provided by google:, + // https://developers.google.com/speed/public-dns/docs/using, + // https://docs.oracle.com/javase/7/docs/api/java/net/doc-files/net-properties.html, + if (NetUtil.isIpV6AddressesPreferred() ||, + (NetUtil.LOCALHOST instanceof Inet6Address && !NetUtil.isIpV4StackPreferred())) {, + Collections.addAll(, + defaultNameServers,, + SocketUtils.socketAddress("2001:4860:4860::8888", DNS_PORT),, + SocketUtils.socketAddress("2001:4860:4860::8844", DNS_PORT));, + } else {, + }]
[+++ b/README.md, +- __3.2__ branch contains code for Netty 3.x, +++ b/README.md, +- __3.2__ branch contains code for Netty 3.x, +++ b/transport/pom.xml, +, + <build>, + <plugins>, + <plugin>, + <artifactId>maven-jar-plugin</artifactId>, + <configuration>, + <excludes>, + <!-- Exclude the com.sun.nio stuff as this is included in the jdk if its supported by the running os -->, + <exclude>**/com/**</exclude>, + </excludes>, + </configuration>, + </plugin>, + </plugins>, + </build>, +++ b/README.md, +- __3.2__ branch contains code for Netty 3.x, +++ b/transport/pom.xml, +, + <build>, + <plugins>, + <plugin>, + <artifactId>maven-jar-plugin</artifactId>, + <configuration>, + <excludes>, + <!-- Exclude the com.sun.nio stuff
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + // and it is not end of stream yet. Just complete their promises by getting the buffer corresponding, + // to 0 bytes and writing it to the channel (to preserve notification order)., + ctx.write(queue.remove(0, writePromise), writePromise);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + // and it is not end of stream yet. Just complete their promises by getting the buffer corresponding, + // to 0 bytes and writing it to the channel (to preserve notification order)., + ctx.write(queue.remove(0, writePromise), writePromise);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, + try {, + } finally {, + promiseAggregator.doneAllocatingPromises();, + }, + return promiseAggregator;, + public ChannelFuture
[+++ b/pom.xml, + <netty.build.version>24</netty.build.version>]
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + PooledByteBuf<T> allocate(PoolThreadCache cache, int reqCapacity, int maxCapacity) {, + allocate(cache, buf, reqCapacity);, + private void allocate(PoolThreadCache cache, PooledByteBuf<T> buf, final int reqCapacity) {, + final int normCapacity = normalizeCapacity(reqCapacity);, + if ((normCapacity & subpageOverflowMask) == 0) { // capacity < pageSize, + if ((normCapacity & 0xFFFFFE00) == 0) { // < 512, + tableIdx = normCapacity >>> 4;, + int i = normCapacity >>> 10;, + if (!s.doNotDestroy || s.elemSize != normCapacity) {, + s.chunk.initBufWithSubpage(buf, handle, reqCapacity);, + allocateNormal(buf, reqCapacity, normCapacity);, + private synchronized void allocateNormal(PooledByteBuf<T> buf, int reqCapacity, int normCapacity) {, + if (q050.allocate(buf, reqCapacity,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + p.addBefore(encoderName, "wsencoder", newWebSocketEncoder());]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + StringBuilder buf = new StringBuilder(), + .append(StringUtil.simpleClassName(this)), + .append("(ridx: ").append(readerIndex), + .append(", widx: ").append(writerIndex), + .append(", cap: ").append(capacity());, + buf.append('/').append(maxCapacity);, + buf.append(", unwrapped: ").append(unwrapped);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + StringBuilder buf = new StringBuilder(), + .append(StringUtil.simpleClassName(this)), + .append("(ridx: ").append(readerIndex), + .append(", widx: ").append(writerIndex), + .append(", cap: ").append(capacity());, + buf.append('/').append(maxCapacity);, + buf.append(", unwrapped: ").append(unwrapped);, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + StringBuilder buf = new StringBuilder(), + .append("Chunk(s) at 0~25%:"), + .append(StringUtil.NEWLINE), + .append(qInit), + .append(StringUtil.NEWLINE), + .append("Chunk(s) at 0~50%:"), + .append(StringUtil.NEWLINE), + .append(q000), + .append(StringUtil.NEWLINE), + .append("Chunk(s) at 25~75%:"), + .append(StringUtil.NEWLINE), + .append(q025), + .append(StringUtil.NEWLINE), + .append("Chunk(s) at 50~100%:"), + .append(StringUtil.NEWLINE), +
[+++ b/testsuite-autobahn/pom.xml, + <dependencies>, + <dependency>, + <groupId>org.python</groupId>, + <artifactId>jython-standalone</artifactId>, + <version>2.7.1</version>, + </dependency>, + </dependencies>]
[+++ b/all/pom.xml, + <version>4.1.6.Final</version>, +++ b/all/pom.xml, + <version>4.1.6.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.6.Final</version>, +++ b/all/pom.xml, + <version>4.1.6.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.6.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.6.Final</version>, +++ b/all/pom.xml, + <version>4.1.6.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.6.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.6.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.6.Final</version>, +++ b/all/pom.xml, + <version>4.1.6.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.6.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.6.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.6.Final</version>, +++ b/codec-http/pom.xml, + <version>4.1.6.Final</version>, +++ b/all/pom.xml, + <version>4.1.6.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.6.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.6.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.6.Final</version>, +++ b/codec-http/pom.xml, + <version>4.1.6.Final</version>, +++ b/codec-http2/pom.xml, + <version>4.1.6.Final</version>, +++ b/all/pom.xml, + <version>4.1.6.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.6.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.6.Final</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamFrame.java, +import io.netty.util.internal.ObjectUtil;, +, + private int streamId = -1;, + public AbstractHttp2StreamFrame setStreamId(int streamId) {, + if (this.streamId != -1) {, + throw new IllegalStateException("Stream identifier may only be set once.");, + }, + this.streamId = ObjectUtil.checkPositiveOrZero(streamId, "streamId");, + public int streamId() {, + return streamId;, + return streamId == other.streamId();, + return streamId;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamFrame.java, +import io.netty.util.internal.ObjectUtil;, +, + private int streamId = -1;, + public AbstractHttp2StreamFrame setStreamId(int streamId) {, + if (this.streamId != -1) {, + throw new IllegalStateException("Stream identifier may only be set once.");, + }, + this.streamId = ObjectUtil.checkPositiveOrZero(streamId, "streamId");, + public int
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelId.java, +import io.netty.util.internal.PlatformDependent;, +import java.net.UnknownHostException;, +import java.util.LinkedHashMap;, +import java.util.Map;, +import java.util.Map.Entry;, + InetAddress bestInetAddr = null;, + try {, + bestInetAddr = InetAddress.getByAddress(new byte[] { 127, 0, 0, 1 });, + } catch (UnknownHostException e) {, + // Never happens., + PlatformDependent.throwException(e);, + }, + Map<NetworkInterface, InetAddress> ifaces = new LinkedHashMap<NetworkInterface, InetAddress>();, + if (addrs.hasMoreElements()) {, + InetAddress a = addrs.nextElement();, + if (!a.isLoopbackAddress()) {, + ifaces.put(iface, a);, + }, + for (Entry<NetworkInterface, InetAddress> entry: ifaces.entrySet()) {, + NetworkInterface iface = entry.getKey();, + InetAddress inetAddr = entry.getValue();, + int res = compareAddresses(bestMacAddr, macAddr);, + if (res < 0)
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_unix_Socket.c, +static const unsigned char wildcardAddress[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };, +static const unsigned char ipv4MappedWildcardAddress[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00 };, +, + // check if this is an any address and if so we need to handle it like this., + if (memcmp(addressBytes, wildcardAddress, 16) == 0 || memcmp(addressBytes, ipv4MappedWildcardAddress, 16) == 0) {, + ip6addr->sin6_addr = in6addr_any;, + } else {, + }, +++ b/transport-native-epoll/src/main/c/io_netty_channel_unix_Socket.c, +static const unsigned
[+++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadServerInitializer.java]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyConstants.java, +package io.netty.handler.codec.spdy;, +, +public final class SpdyConstants {, +, + public static final int SPDY_MIN_VERSION = 2;, + public static final int SPDY_MAX_VERSION = 3;, +, + private SpdyConstants() {}, +}, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyConstants.java, +package io.netty.handler.codec.spdy;, +, +public final class SpdyConstants {, +, + public static final int SPDY_MIN_VERSION = 2;, + public static final int SPDY_MAX_VERSION = 3;, +, + private SpdyConstants() {}, +}, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + if (version < SpdyConstants.SPDY_MIN_VERSION || version > SpdyConstants.SPDY_MAX_VERSION) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyConstants.java, +package io.netty.handler.codec.spdy;, +, +public final class SpdyConstants {, +, + public
[+++ b/transport/src/main/java/io/netty/channel/VoidChannelPromise.java, + // Will be null if we should not propagate exceptions through the pipeline on failure case., + private final ChannelFutureListener fireExceptionListener;, + public VoidChannelPromise(final Channel channel, boolean fireException) {, + if (fireException) {, + fireExceptionListener = new ChannelFutureListener() {, + @Override, + public void operationComplete(ChannelFuture future) throws Exception {, + Throwable cause = future.cause();, + if (cause != null) {, + fireException0(cause);, + }, + }, + };, + } else {, + fireExceptionListener = null;, + }, + fireException0(cause);, + fireException0(cause);, + if (fireExceptionListener != null) {, + promise.addListener(fireExceptionListener);, + private void fireException0(Throwable cause) {,
[+++ b/all/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.9.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E> {, +, + public ObjectArray(E[] array, int offset, int length) {, + super(array, offset, length);, + }, +, + @Override, + public E[] array() {, + return (E[]) super.array();, + }, +}, +++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E> {, +, + public ObjectArray(E[] array, int offset, int length) {, + super(array, offset, length);, + }, +, + @Override, + public E[] array() {, + return (E[]) super.array();, + }, +}, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return writerIndex > readerIndex;, +, + if (readerIndex == writerIndex)
[+++ b/handler/src/main/java/io/netty/handler/ssl/ApplicationProtocolConfig.java, +import javax.net.ssl.SSLEngine;, +, +import static io.netty.handler.ssl.ApplicationProtocolUtil.toList;, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, + /**, + * If the peer who selects the application protocol doesn't find a match this will result in the failing the, + * handshake with a fatal alert., + * <p>, + * For example in the case of ALPN this will result in a, + * <a herf="https://tools.ietf.org/html/rfc7301#section-3.2">no_application_protocol(120)</a> alert., + */, + FATAL_ALERT,, + /**, + * If the peer who selects the application protocol doesn't find a match it will pretend no to support, + * the TLS extension by not advertising support for
[+++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, +import java.io.InputStream;, +import java.io.OutputStream;, +import java.nio.ReadOnlyBufferException;, +import java.nio.channels.GatheringByteChannel;, +import java.nio.channels.ScatteringByteChannel;, + public static final ByteBuf EMPTY_BUFFER = new AbstractByteBuf(0) {, + @Override, + public int capacity() {, + return 0;, + }, +, + @Override, + public ByteBuf capacity(int newCapacity) {, + throw new ReadOnlyBufferException();, + }, +, + @Override, + public ByteBufAllocator alloc() {, + return ALLOC;, + }, +, + @Override, + public ByteOrder order() {, + return BIG_ENDIAN;, + }, +, + @Override, + public ByteBuf unwrap() {, + return null;, + }, +, + @Override, + public boolean isDirect() {, + return false;,
[+++ b/example/pom.xml]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + request.addHeader(Names.ORIGIN, originValue);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + request.addHeader(Names.ORIGIN, originValue);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + request.addHeader(Names.ORIGIN, originValue);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + request.addHeader(Names.ORIGIN, originValue);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + request.addHeader(Names.ORIGIN, originValue);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java, + request.addHeader(Names.ORIGIN, originValue);]
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractDiskHttpData.java, + localfileChannel.force(false);, + fileChannel.force(false);, + localfileChannel.force(false);, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractDiskHttpData.java, + localfileChannel.force(false);, + fileChannel.force(false);, + localfileChannel.force(false);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractMemoryHttpData.java, + }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractDiskHttpData.java, + localfileChannel.force(false);, + fileChannel.force(false);, + localfileChannel.force(false);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractMemoryHttpData.java, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractDiskHttpData.java, + localfileChannel.force(false);, + fileChannel.force(false);, + localfileChannel.force(false);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractMemoryHttpData.java, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, + write(ctx, succeededFuture(ctx.channel()), CONTINUE.duplicate());, + m.setContent(ChannelBuffers.dynamicBuffer(e.channel().getConfig().getBufferFactory()));, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractDiskHttpData.java, + localfileChannel.force(false);, + fileChannel.force(false);, + localfileChannel.force(false);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractMemoryHttpData.java, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, +
[+++ b/src/main/java/org/jboss/netty/channel/AdaptiveReceiveBufferSizePredictor.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2008, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version., + *, +
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsRecordResolveContext.java, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsRecordResolveContext.java, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java, + public void operationComplete(Future<List<T>> future) {, + if (!query(hostname, expectedTypes[i], nameServerAddressStream.duplicate(), promise)) {, + query(hostname, expectedTypes[end], nameServerAddressStream, promise);, + private void onResponse(final DnsServerAddressStream nameServerAddrStream, final int nameServerAddrStreamIndex,, + onResponseCNAME(question, buildAliasMap(envelope.content()), queryLifecycleObserver, promise);, + if (cnames.isEmpty()) {, + queryLifecycleObserver.querySucceed();, + // We also got a CNAME so we need to ensure we also query it., + onResponseCNAME(question, cnames,, + parent.dnsQueryLifecycleObserverFactory().newDnsQueryLifecycleObserver(question), promise);, + private void tryToFinishResolve(final DnsServerAddressStream nameServerAddrStream,, +, + // There are still some queries in process, we will try to notify once the next one finishes until,
[+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java, + currentMessage.setExtras(in.readSlice(extrasLength).retain());, + currentMessage.setKey(in.readSlice(keyLength).retain());, + ByteBuf chunkBuffer = in.readSlice(toRead).retain();, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java, + currentMessage.setExtras(in.readSlice(extrasLength).retain());, + currentMessage.setKey(in.readSlice(keyLength).retain());, + ByteBuf chunkBuffer = in.readSlice(toRead).retain();, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java, + private static void encodeKey(ByteBuf buf, ByteBuf key) {, + if (key == null || !key.isReadable()) {, + buf.writeBytes(key);, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java, + currentMessage.setExtras(in.readSlice(extrasLength).retain());, + currentMessage.setKey(in.readSlice(keyLength).retain());, + ByteBuf chunkBuffer = in.readSlice(toRead).retain();, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java, + private static void encodeKey(ByteBuf buf, ByteBuf key) {, + if (key == null || !key.isReadable()) {, + buf.writeBytes(key);, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java, + private ByteBuf key;, + protected AbstractBinaryMemcacheMessage(ByteBuf key, ByteBuf extras) {, + public ByteBuf key() {, + public BinaryMemcacheMessage setKey(ByteBuf key) {,
[+++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + // Always add b to the end of the component list because we are appending buffers, + addComponent(components.size(), b);, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + // Always add b to the end of the component list because we are appending buffers, + addComponent(components.size(), b);, +++ b/buffer/src/test/java/io/netty/buffer/ConsolidationTest.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:,
[+++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, + * Returns {@code true} if a scheduled task is ready for processing by {@link #runAllTasks()} or, + * {@link #runAllTasks(long)}., + */, + protected boolean hasScheduledTasks() {, + assert inEventLoop();, + ScheduledFutureTask<?> delayedTask = delayedTaskQueue.peek();, + return delayedTask != null && delayedTask.deadlineNanos() <= ScheduledFutureTask.nanoTime();, + }, +, + /**, +++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, + * Returns {@code true} if a scheduled task is ready for processing by {@link #runAllTasks()} or, + * {@link #runAllTasks(long)}., + */, + protected boolean hasScheduledTasks() {, + assert inEventLoop();, + ScheduledFutureTask<?> delayedTask = delayedTaskQueue.peek();, + return delayedTask != null && delayedTask.deadlineNanos() <= ScheduledFutureTask.nanoTime();,
[+++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, + * by this decoder.]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, + buf.writeInt(exclusive ? (int) (0x80000000L | streamDependency) : streamDependency);, + buf.writeInt((int) errorCode);, + buf.writeChar(entry.key());, + buf.writeInt(entry.value().intValue());, + buf.writeInt((int) errorCode);, + buf.writeInt(exclusive ? (int) (0x80000000L | streamDependency) : streamDependency);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, + buf.writeInt(exclusive ? (int) (0x80000000L | streamDependency) : streamDependency);, + buf.writeInt((int) errorCode);, + buf.writeChar(entry.key());, + buf.writeInt(entry.value().intValue());, + buf.writeInt((int) errorCode);, + buf.writeInt(exclusive ? (int) (0x80000000L | streamDependency) : streamDependency);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ClientUpgradeCodec.java, +import static io.netty.handler.codec.base64.Base64Dialect.URL_SAFE;, +import static io.netty.handler.codec.http2.Http2CodecUtil.HTTP_UPGRADE_PROTOCOL_NAME;, +import static io.netty.handler.codec.http2.Http2CodecUtil.HTTP_UPGRADE_SETTINGS_HEADER;, +import static io.netty.handler.codec.http2.Http2CodecUtil.SETTING_ENTRY_LENGTH;, +import static io.netty.util.CharsetUtil.UTF_8;, +import static io.netty.util.ReferenceCountUtil.release;, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +, + buf.writeChar(entry.key());, + buf.writeInt(entry.value().intValue());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, + buf.writeInt(exclusive ? (int) (0x80000000L | streamDependency) : streamDependency);,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import io.netty.handler.codec.http.HttpContentDecompressor;, +, + // Remove decompressor from pipeline if its in use, + HttpContentDecompressor decompressor = p.get(HttpContentDecompressor.class);, + if (decompressor != null) {, + p.remove(decompressor);, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import io.netty.handler.codec.http.HttpContentDecompressor;, +, + // Remove decompressor from pipeline if its in use, + HttpContentDecompressor decompressor = p.get(HttpContentDecompressor.class);, + if (decompressor != null) {, + p.remove(decompressor);, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +import io.netty.handler.codec.http.HttpContentCompressor;, + if (p.get(HttpContentCompressor.class) != null) {, + p.remove(HttpContentCompressor.class);, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, + private final HeaderEntry[] entries = new HeaderEntry[BUCKET_SIZE];, + private final HeaderEntry head = new HeaderEntry(-1, null, null);, + HeaderEntry e = entries[i];, + HeaderEntry newEntry;, + entries[i] = newEntry = new HeaderEntry(h, name, value);, + HeaderEntry e = entries[i];, + HeaderEntry next = e.next;, + HeaderEntry next = e.next;, + HeaderEntry e = entries[i];, + HeaderEntry e = entries[i];, + HeaderEntry e = head.after;, + HeaderEntry e = head.after;, + private static final class HeaderEntry implements Map.Entry<String, String> {, + HeaderEntry next;, + HeaderEntry before, after;, + HeaderEntry(int hash, String key, String value) {, + void
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java, + private boolean corrupted;, + if (corrupted) {, + in.skipBytes(in.readableBytes());, + return;, + }, +, + try {, + | in.readUnsignedByte() << 8, + | in.readUnsignedByte() << 16, + | in.readUnsignedByte() << 24;, + | in.readUnsignedByte() << 8, + | in.readUnsignedByte() << 16, + | in.readUnsignedByte() << 24;, + } catch (Exception e) {, + corrupted = true;, + throw e;, + }]
[+++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java, +, + @Override, + public ByteBuf asReadOnly() {, + return this;, + }, +++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java, +, + @Override, + public ByteBuf asReadOnly() {, + return this;, + }, +++ b/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java, + super(buf instanceof UnreleasableByteBuf ? buf.unwrap() : buf);, + return buf.isReadOnly() ? this : new UnreleasableByteBuf(buf.asReadOnly());, +++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java, +, + @Override, + public ByteBuf asReadOnly() {, + return this;, + }, +++ b/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java, + super(buf instanceof UnreleasableByteBuf ? buf.unwrap() : buf);, + return buf.isReadOnly() ? this : new UnreleasableByteBuf(buf.asReadOnly());, +++ b/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java, +, + @Test, + public void asReadOnly() {, + ByteBuf buf = buffer(1);, + ByteBuf readOnly
[+++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, + return new UnsafeDirectSwappedByteBuf(this);, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, + return new UnsafeDirectSwappedByteBuf(this);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java, + return new UnsafeDirectSwappedByteBuf(this);, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, + return new UnsafeDirectSwappedByteBuf(this);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java, + return new UnsafeDirectSwappedByteBuf(this);, +++ b/buffer/src/main/java/io/netty/buffer/UnsafeDirectSwappedByteBuf.java, + UnsafeDirectSwappedByteBuf(AbstractByteBuf buf) {, + // We need to call wrapped.memoryAddress() everytime and NOT cache it as it may change if the buffer expand., + // See:, + // - https://github.com/netty/netty/issues/2587, + // - https://github.com/netty/netty/issues/2580, + return wrapped.memoryAddress() + index;, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, + return new UnsafeDirectSwappedByteBuf(this);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java, + return new UnsafeDirectSwappedByteBuf(this);, +++ b/buffer/src/main/java/io/netty/buffer/UnsafeDirectSwappedByteBuf.java, + UnsafeDirectSwappedByteBuf(AbstractByteBuf buf) {, + // We need to call wrapped.memoryAddress() everytime and
[+++ b/pom.xml, + <dependencies>, + <dependency>, + <groupId>org.apache.maven.scm</groupId>, + <artifactId>maven-scm-api</artifactId>, + <version>1.8.1</version>, + </dependency>, + <dependency>, + <groupId>org.apache.maven.scm</groupId>, + <artifactId>maven-scm-provider-gitexe</artifactId>, + <version>1.8.1</version>, + </dependency>, + </dependencies>]
[+++ b/codec/src/main/java/io/netty/handler/codec/redis/Command.java, + static final byte[] ARGS_PREFIX = "*".getBytes();, + static final byte[] CRLF = "\r\n".getBytes();, + static final byte[] BYTES_PREFIX = "$".getBytes();, + static final byte[] EMPTY_BYTES = new byte[0];, + static final byte[] NEG_ONE_AND_CRLF = convertWithCRLF(-1);, +++ b/codec/src/main/java/io/netty/handler/codec/redis/Command.java, + static final byte[] ARGS_PREFIX = "*".getBytes();, + static final byte[] CRLF = "\r\n".getBytes();, + static final byte[] BYTES_PREFIX = "$".getBytes();, + static final byte[] EMPTY_BYTES = new byte[0];, + static final byte[] NEG_ONE_AND_CRLF = convertWithCRLF(-1);, +++ b/codec/src/main/java/io/netty/handler/codec/redis/RedisDecoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/redis/Command.java, + static final byte[] ARGS_PREFIX = "*".getBytes();, + static final byte[] CRLF = "\r\n".getBytes();, + static final byte[] BYTES_PREFIX
[+++ b/all/pom.xml, + <version>4.1.33.Final</version>, +++ b/all/pom.xml, + <version>4.1.33.Final</version>, +++ b/bom/pom.xml, + <version>4.1.33.Final</version>, + <tag>netty-4.1.33.Final</tag>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, +++ b/all/pom.xml, + <version>4.1.33.Final</version>, +++ b/bom/pom.xml, + <version>4.1.33.Final</version>, + <tag>netty-4.1.33.Final</tag>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, + <version>4.1.33.Final</version>, +
[+++ b/src/docbook/master.xml, + <!-- The version.txt file is generated by maven-antrun-plugin. -->]
[+++ b/NOTICE.txt, +This product contains a modified portion of and optionally depends on 'Protocol Buffers', Google's data, +++ b/NOTICE.txt, +This product contains a modified portion of and optionally depends on 'Protocol Buffers', Google's data, +++ b/codec/pom.xml, + <groupId>com.google.protobuf.nano</groupId>, + <artifactId>protobuf-javanano</artifactId>, + <optional>true</optional>, + </dependency>, + <dependency>, +++ b/NOTICE.txt, +This product contains a modified portion of and optionally depends on 'Protocol Buffers', Google's data, +++ b/codec/pom.xml, + <groupId>com.google.protobuf.nano</groupId>, + <artifactId>protobuf-javanano</artifactId>, + <optional>true</optional>, + </dependency>, + <dependency>, +++ b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufDecoder.java, + * Copyright 2015 The Netty Project, + * void channelRead({@link ChannelHandlerContext} ctx, Object msg) {, + * MyMessage req = (MyMessage)
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + * Returns the name of this {@link Cookie}., + * Returns the value of this {@link Cookie}., + * Returns the domain of this {@link Cookie}., + * Returns the path of this {@link Cookie}., + * Returns the comment of this {@link Cookie}., + * Returns the maximum age of this {@link Cookie} in seconds., + * Returns the version of this {@link Cookie}., + * Returns the comment URL of this {@link Cookie}., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + * Returns the name of this {@link Cookie}., + * Returns the value of this {@link Cookie}., +
[+++ b/all/pom.xml, + <configuration combine.self="override">, +++ b/all/pom.xml, + <configuration combine.self="override">, +++ b/example/pom.xml, + <artifactId>maven-antrun-plugin</artifactId>, + <target>, + <taskdef resource="net/sf/antcontrib/antlib.xml" />, + <propertyregex, + property="mergedArgs" regexp="[\r\n\s]+" replace=" " global="true", + input="${argLine.common} ${argLine.bootcp} ${argLine.leak} ${argLine.coverage} ${argLine.example}" />, + <java classname="${exampleClass}" classpathref="maven.runtime.classpath" fork="true">, + <jvmarg line="${mergedArgs}"/>, + </java>, + </target>, +++ b/all/pom.xml, + <configuration combine.self="override">, +++ b/example/pom.xml, + <artifactId>maven-antrun-plugin</artifactId>, + <target>, + <taskdef resource="net/sf/antcontrib/antlib.xml" />, + <propertyregex, + property="mergedArgs" regexp="[\r\n\s]+" replace=" " global="true", + input="${argLine.common} ${argLine.bootcp} ${argLine.leak} ${argLine.coverage} ${argLine.example}" />, + <java classname="${exampleClass}" classpathref="maven.runtime.classpath" fork="true">, + <jvmarg line="${mergedArgs}"/>, + </java>, + </target>, +++ b/pom.xml, + <configuration combine.self="override">, +++ b/all/pom.xml, + <configuration combine.self="override">,
[+++ b/microbench/pom.xml, + <!-- This only be set when run on linux as on other platforms we just want to include the jar without native, + code -->, + <epoll.classifier/>, + <properties>, + <epoll.classifier>${jni.classifier}</epoll.classifier>, + </properties>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport-native-epoll</artifactId>, + <version>${project.version}</version>, + <classifier>${epoll.classifier}</classifier>, + </dependency>, + <dependency>, +++ b/microbench/pom.xml, + <!-- This only be set when run on linux as on other platforms we just want to include the jar without native, + code -->, + <epoll.classifier/>, + <properties>, + <epoll.classifier>${jni.classifier}</epoll.classifier>, + </properties>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport-native-epoll</artifactId>, + <version>${project.version}</version>, + <classifier>${epoll.classifier}</classifier>, + </dependency>, + <dependency>, +++ b/microbench/src/main/java/io/netty/microbench/channel/epoll/EpollSocketChannelBenchmark.java, +/*,
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + ctx, connection(), decoder().frameListener(), upgrade.upgradeRequest().retain());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + ctx, connection(), decoder().frameListener(), upgrade.upgradeRequest().retain());, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameCodecTest.java, +import io.netty.handler.codec.http.DefaultFullHttpRequest;, +import io.netty.handler.codec.http.FullHttpRequest;, +import io.netty.handler.codec.http.HttpServerUpgradeHandler;, +import io.netty.handler.codec.http.HttpVersion;, +import org.mockito.invocation.InvocationOnMock;, +import org.mockito.stubbing.Answer;, + @Test, + public void upgradeEventNoRefCntError() throws Http2Exception {, + frameListener.onHeadersRead(http2HandlerCtx, Http2CodecUtil.HTTP_UPGRADE_STREAM_ID, request, 31, false);, +, + final FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/");, + final HttpServerUpgradeHandler.UpgradeEvent upgradeEvent = mock(HttpServerUpgradeHandler.UpgradeEvent.class);, + when(upgradeEvent.retain()).thenAnswer(new Answer<HttpServerUpgradeHandler.UpgradeEvent>() {, + @Override, + public HttpServerUpgradeHandler.UpgradeEvent answer(InvocationOnMock invocationOnMock) throws Throwable {, + request.retain();, + return upgradeEvent;, + }, + });, + when(upgradeEvent.release()).thenAnswer(new Answer<Boolean>() {, + @Override, + public Boolean answer(InvocationOnMock invocationOnMock) throws Throwable {, + return request.release();,
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + // The JNI library was not already loaded. Load it now., + loadTcNative();, + OpenSslEngine.class.getSimpleName() + " will be unavailable, unless the " +, + "application has already loaded the symbols by some other means. " +, + "See http://netty.io/wiki/forked-tomcat-native.html for more information.", t);, + }, +, + try {, + initializeTcNative();, +, + // The library was initialized successfully. If loading the library failed above,, + // reset the cause now since it appears that the library was loaded by some other, + // means., + cause = null;, + } catch (Throwable t) {,
[+++ b/buffer/src/main/java/io/netty/buffer/Buf.java, +public interface Buf extends Freeable {, +++ b/buffer/src/main/java/io/netty/buffer/Buf.java, +public interface Buf extends Freeable {, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +, + /**, + * Deallocates the internal memory block of this buffer or returns it to the allocator or pool it came from., + * The result of accessing a released buffer is unspecified and can even cause JVM crash., + *, + * @throws UnsupportedOperationException if this buffer is derived, + */, + @Override, + void free();, +, + /**, + * Returns {@code true} if and only if this buffer has been deallocated by {@link #free()}., + */,
[+++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, + private static final int ST_UNUSED = 0;, + private static final int ST_BRANCH = 1;, + private static final int ST_ALLOCATED = 2;, + private static final int ST_ALLOCATED_SUBPAGE = 3;, + private final int[] memoryMap;, +, + int chunkSizeInPages = chunkSize >>> pageShifts;, + memoryMap = new int[maxSubpageAllocs << 1];, + for (int i = 0; i <= maxOrder; i ++) {, + int runSizeInPages = chunkSizeInPages >>> i;, + for (int j = 0; j < chunkSizeInPages; j += runSizeInPages) {, + //noinspection PointlessBitwiseExpression, + memoryMap[memoryMapIndex ++] = j << 17 | runSizeInPages <<
[+++ b/src/docbook/en-US/module/start.xml, + The protocol to implement in this section is the, + <ulink url="http://tools.ietf.org/html/rfc868">TIME</ulink> protocol., + It is different from the previous examples in that it sends a message,, + which contains a 32-bit integer, without receiving any requests and , + loses the connection once the message is sent. In this example, you]
[+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java, +public abstract class AbstractBinaryMemcacheDecoder<M extends BinaryMemcacheMessage>, + private M currentMessage;, + currentMessage = decodeHeader(in);, + byte extrasLength = currentMessage.getExtrasLength();, + currentMessage.setExtras(readBytes(ctx.alloc(), in, extrasLength));, + short keyLength = currentMessage.getKeyLength();, + currentMessage.setKey(in.toString(in.readerIndex(), keyLength, CharsetUtil.UTF_8));, + out.add(currentMessage);, + int valueLength = currentMessage.getTotalBodyLength(), + - currentMessage.getKeyLength(), + - currentMessage.getExtrasLength();, + if (currentMessage.getExtras() != null) {, + currentMessage.getExtras().release();, + currentMessage = null;, + * Decode and return the parsed {@link BinaryMemcacheMessage}., + protected abstract M decodeHeader(ByteBuf in);, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java, +public abstract class AbstractBinaryMemcacheDecoder<M extends BinaryMemcacheMessage>, + private M currentMessage;, + currentMessage = decodeHeader(in);, + byte extrasLength = currentMessage.getExtrasLength();, + currentMessage.setExtras(readBytes(ctx.alloc(), in, extrasLength));,
[+++ b/transport/src/main/java/io/netty/channel/socket/aio/AioEventLoopGroup.java, + finder = new ReflectiveAioChannelFinder();, + AioChannelFinder.class.getSimpleName(), ReflectiveAioChannelFinder.class.getSimpleName()), t);, + finder = new ReflectiveAioChannelFinder();, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioEventLoopGroup.java, + finder = new ReflectiveAioChannelFinder();, + AioChannelFinder.class.getSimpleName(), ReflectiveAioChannelFinder.class.getSimpleName()), t);, + finder = new ReflectiveAioChannelFinder();, +++ /dev/null, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioEventLoopGroup.java, + finder = new ReflectiveAioChannelFinder();, + AioChannelFinder.class.getSimpleName(), ReflectiveAioChannelFinder.class.getSimpleName()), t);, + finder = new ReflectiveAioChannelFinder();, +++ /dev/null, +++ b/transport/src/main/java/io/netty/channel/socket/aio/ReflectiveAioChannelFinder.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You
[+++ b/pom.xml, + <id>attach-javadoc</id>, + <goal>jar</goal>]
[+++ b/pom.xml, + <outputDirectory>${basedir}/target/classes/META-INF</outputDirectory>]
[+++ b/pom.xml, + <Import-Package>sun.misc.*;resolution:=optional,sun.nio.ch;resolution:=optional,sun.security.*;resolution:=optional,org.eclipse.jetty.npn;version="[1,2)";resolution:=optional,org.eclipse.jetty.alpn;version="[1,2)";resolution:=optional,*</Import-Package>]
[+++ b/all/pom.xml, + <version>4.0.0.CR4</version>, +++ b/all/pom.xml, + <version>4.0.0.CR4</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR4</version>, +++ b/all/pom.xml, + <version>4.0.0.CR4</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR4</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR4</version>, +++ b/all/pom.xml, + <version>4.0.0.CR4</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR4</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR4</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR4</version>, +++ b/all/pom.xml, + <version>4.0.0.CR4</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR4</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR4</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR4</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR4</version>, +++ b/all/pom.xml, + <version>4.0.0.CR4</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR4</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR4</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR4</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR4</version>, +++ b/common/pom.xml, + <version>4.0.0.CR4</version>, +++ b/all/pom.xml, + <version>4.0.0.CR4</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR4</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR4</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java, + if (byteBuf != null) {, + byteBuf.release();, + byteBuf = null;, + }]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java, + private byte[] dictionary;, + this.dictionary = dictionary;, + case JZlib.Z_NEED_DICT:, + if (dictionary == null) {, + ZlibUtil.fail(z, "decompression failure", resultCode);, + } else {, + resultCode = z.inflateSetDictionary(dictionary, dictionary.length);, + if (resultCode != JZlib.Z_OK) {, + ZlibUtil.fail(z, "failed to set the dictionary", resultCode);, + }, + }, + break;]
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + return PooledHeapByteBuf.newInstance(maxCapacity);, + return PooledUnsafeDirectByteBuf.newInstance(maxCapacity);, + return PooledDirectByteBuf.newInstance(maxCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + return PooledHeapByteBuf.newInstance(maxCapacity);, + return PooledUnsafeDirectByteBuf.newInstance(maxCapacity);, + return PooledDirectByteBuf.newInstance(maxCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, +import io.netty.util.Recycler;, +import io.netty.util.ResourceLeakDetector;, + private final Recycler.Handle recyclerHandle;, + protected PooledByteBuf(Recycler.Handle recyclerHandle, int maxCapacity) {, + this.recyclerHandle = recyclerHandle;, + if (ResourceLeakDetector.ENABLED) {, + } else {, + recycle();, + }, +, + @SuppressWarnings("unchecked"), + private void recycle() {, + Recycler.Handle recyclerHandle = this.recyclerHandle;, + if (recyclerHandle != null) {, + setRefCnt(1);, + ((Recycler<Object>) recycler()).recycle(this, recyclerHandle);, + }, + }, +, + protected abstract Recycler<?> recycler();, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + return PooledHeapByteBuf.newInstance(maxCapacity);, + return PooledUnsafeDirectByteBuf.newInstance(maxCapacity);,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, + public SpdyDataFrame setStreamId(int streamId) {, + return this;, + public SpdyDataFrame setLast(boolean last) {, + return this;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, + public SpdyDataFrame setStreamId(int streamId) {, + return this;, + public SpdyDataFrame setLast(boolean last) {, + return this;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, + public SpdyGoAwayFrame setLastGoodStreamId(int lastGoodStreamId) {, + return this;, + public SpdyGoAwayFrame setStatus(SpdySessionStatus status) {, + return this;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, + public SpdyDataFrame setStreamId(int streamId) {, + return this;, + public SpdyDataFrame setLast(boolean last) {, + return this;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, + public SpdyGoAwayFrame setLastGoodStreamId(int lastGoodStreamId) {, + return this;, + public SpdyGoAwayFrame setStatus(SpdySessionStatus status) {, + return
[+++ b/example/src/main/java/io/netty/example/http2/helloworld/multiplex/server/HelloWorldHttp2Handler.java, + sendResponse(ctx, data.content());, + } else {, + // We do not send back the response to the remote-peer, so we need to release it., + data.release();]
[+++ b/pom.xml, + <tcnative.version>2.0.0.Beta4</tcnative.version>]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + return version() >= 0x10002000L;, + }, +, + /**, + * Returns the version of the used available OpenSSL library or {@code -1} if {@link #isAvailable()}, + * returns {@code false}., + */, + public static int version() {, + if (isAvailable()) {, + return SSL.version();, + }, + return -1;, + }, +, + /**, + * Returns the version string of the used available OpenSSL library or {@code null} if {@link #isAvailable()}, + * returns {@code false}., + */, + public static String versionString() {, + if (isAvailable()) {, + return SSL.versionString();, + },
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketFileRegionTest.java, + return region.transferred();, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketFileRegionTest.java, + return region.transferred();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + if (region.transferred() >= regionCount) {, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketFileRegionTest.java, + return region.transferred();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + if (region.transferred() >= regionCount) {, +++ b/transport/src/main/java/io/netty/channel/FileRegion.java]
[+++ b/handler/src/main/java/io/netty/handler/ipfilter/AbstractIpFilterHandler.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpWorker.java, + if (!server) {, + if (!((SctpClientChannel) channel).boundManually) {, + fireChannelBound(channel, localAddress);, + }, + fireChannelConnected(channel, remoteAddress);, + }, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpWorker.java, + if (!server) {, + if (!((SctpClientChannel) channel).boundManually) {, + fireChannelBound(channel, localAddress);, + }, + fireChannelConnected(channel, remoteAddress);, + }, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +import io.netty.channel.socket.DatagramChannel;, +import io.netty.channel.socket.ServerSocketChannel;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.channel.socket.nio.NioSocketChannelConfig;, +, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpWorker.java, + if (!server) {, + if (!((SctpClientChannel) channel).boundManually) {, + fireChannelBound(channel, localAddress);, + }, + fireChannelConnected(channel, remoteAddress);, + }, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +import io.netty.channel.socket.DatagramChannel;, +import io.netty.channel.socket.ServerSocketChannel;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.channel.socket.nio.NioSocketChannelConfig;, +, +++ /dev/null, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpWorker.java, + if (!server) {, + if (!((SctpClientChannel) channel).boundManually) {, +
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + final ByteBuf buffer;, + || cumulation.refCnt() > 1 || cumulation.isReadOnly()) {, + // duplicate().retain() or if its read-only., +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + final ByteBuf buffer;, + || cumulation.refCnt() > 1 || cumulation.isReadOnly()) {, + // duplicate().retain() or if its read-only., +++ b/codec/src/test/java/io/netty/handler/codec/ByteToMessageDecoderTest.java, +, + @Test, + public void testReadOnlyBuffer() {, + EmbeddedChannel channel = new EmbeddedChannel(new ByteToMessageDecoder() {, + @Override, + protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {, + }, + });, + assertFalse(channel.writeInbound(Unpooled.buffer(8).writeByte(1).asReadOnly()));, + assertFalse(channel.writeInbound(Unpooled.wrappedBuffer(new byte[] { (byte) 2 })));, + assertFalse(channel.finish());, + }]
[+++ b/pom.xml, + -d ${project.build.directory}/api, + <executions>, + <execution>, + <id>generate-xref</id>, + <phase>package</phase>, + <goals>, + <goal>jxr</goal>, + </goals>, + </execution>, + </executions>, + <linkJavadoc>true</linkJavadoc>, + <destDir>${project.build.directory}/xref</destDir>, + <javadocDir>${project.build.directory}/api</javadocDir>, + <id>generate-distribution</id>, + <attach>false</attach>, +++ b/pom.xml, + -d ${project.build.directory}/api, + <executions>, + <execution>, + <id>generate-xref</id>, + <phase>package</phase>, + <goals>, + <goal>jxr</goal>, + </goals>, + </execution>, + </executions>, + <linkJavadoc>true</linkJavadoc>, + <destDir>${project.build.directory}/xref</destDir>, + <javadocDir>${project.build.directory}/api</javadocDir>, + <id>generate-distribution</id>, + <attach>false</attach>, +++ b/src/assembly/default.xml, + <directory>target/api</directory>, + <!-- Documentation (XRef) -->, + <fileSet>, + <directory>target/xref</directory>, + <outputDirectory>doc/xref</outputDirectory>, + <includes>, + <include>**/**</include>, + </includes>, + </fileSet>, +]
[+++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClient.java, +import io.netty.handler.codec.http.DefaultFullHttpRequest;, + HttpRequest request = new DefaultFullHttpRequest(]
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameRoundtripTest.java, +import static io.netty.buffer.Unpooled.EMPTY_BUFFER;, +import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_MAX_HEADER_SIZE;, +import static io.netty.handler.codec.http2.Http2TestUtil.randomString;, +import static io.netty.util.CharsetUtil.UTF_8;, +import static java.lang.Math.min;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.fail;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyBoolean;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.anyShort;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Matchers.isA;, +import static org.mockito.Mockito.atLeastOnce;, +import static org.mockito.Mockito.doAnswer;, +import static org.mockito.Mockito.never;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +]
[+++ /dev/null]
[+++ b/pom.xml, + <version>3.1.2.GA-SNAPSHOT</version>]
[+++ b/transport/src/main/java/io/netty/channel/group/ChannelGroupFuture.java, + ChannelGroupFuture addListener(ChannelGroupFutureListener listener);, + ChannelGroupFuture removeListener(ChannelGroupFutureListener listener);, +++ b/transport/src/main/java/io/netty/channel/group/ChannelGroupFuture.java, + ChannelGroupFuture addListener(ChannelGroupFutureListener listener);, + ChannelGroupFuture removeListener(ChannelGroupFutureListener listener);, +++ b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroupFuture.java, + public ChannelGroupFuture addListener(ChannelGroupFutureListener listener) {, + return this;, + public ChannelGroupFuture removeListener(ChannelGroupFutureListener listener) {, + return this;]
[+++ b/common/src/main/java/io/netty/util/internal/CleanerJava6.java, +import java.security.AccessController;, +import java.security.PrivilegedAction;, + private static final Field CLEANER_FIELD;, + long fieldOffset;, + Method clean;, + Field cleanerField;, + final ByteBuffer direct = ByteBuffer.allocateDirect(1);, + try {, + Object mayBeCleanerField = AccessController.doPrivileged(new PrivilegedAction<Object>() {, + @Override, + public Object run() {, + if (!PlatformDependent.hasUnsafe()) {, + // We need to make it accessible if we do not use Unsafe as we will access it via, + // reflection., + cleanerField.setAccessible(true);, + }, + return cleanerField;, + } catch (Throwable cause) {, + return cause;, + }, + }, + });, + if (mayBeCleanerField instanceof Throwable) {,
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + String errStr = SSL.getErrorString(err);, +, + handshakeException = new SSLHandshakeException(errStr);, + throw shutdownWithError("SSL_read", errStr);]
[+++ b/codec-haproxy/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyCommand.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + *
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java, + private DnsServerAddresses nameServerAddresses = DefaultDnsServerAddresses.defaultAddresses();]
[+++ b/src/main/java/org/jboss/netty/example/discard/DiscardClient.java, + ClientBootstrap bootstrap = new ClientBootstrap(, + Executors.newCachedThreadPool()));, + // Set up the default event pipeline., + bootstrap.releaseExternalResources();, +++ b/src/main/java/org/jboss/netty/example/discard/DiscardClient.java, + ClientBootstrap bootstrap = new ClientBootstrap(, + Executors.newCachedThreadPool()));, + // Set up the default event pipeline., + bootstrap.releaseExternalResources();, +++ b/src/main/java/org/jboss/netty/example/discard/DiscardServer.java, + ServerBootstrap bootstrap = new ServerBootstrap(, + Executors.newCachedThreadPool()));, + // Set up the default event pipeline., +++ b/src/main/java/org/jboss/netty/example/discard/DiscardClient.java, + ClientBootstrap bootstrap = new ClientBootstrap(, + Executors.newCachedThreadPool()));, + // Set up the default event pipeline., + bootstrap.releaseExternalResources();, +++ b/src/main/java/org/jboss/netty/example/discard/DiscardServer.java, + ServerBootstrap bootstrap = new ServerBootstrap(, + Executors.newCachedThreadPool()));, + // Set up the default event pipeline., +++ b/src/main/java/org/jboss/netty/example/echo/EchoClient.java, +
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelWorker.java, + private final HttpTunnelingClientSocketChannel channel;, + HttpTunnelWorker(HttpTunnelingClientSocketChannel channel) {, + HttpTunnelingClientSocketChannel channel, ChannelFuture future,, + HttpTunnelingClientSocketChannel channel, ChannelFuture future, int interestOps) {, + static void close(HttpTunnelingClientSocketChannel channel, ChannelFuture future) {, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelWorker.java, + private final HttpTunnelingClientSocketChannel channel;, + HttpTunnelWorker(HttpTunnelingClientSocketChannel channel) {, + HttpTunnelingClientSocketChannel channel, ChannelFuture future,, + HttpTunnelingClientSocketChannel channel, ChannelFuture future, int interestOps) {, + static void close(HttpTunnelingClientSocketChannel channel, ChannelFuture future)
[+++ b/transport/src/main/java/io/netty/channel/Channel.java, + * use {@link io.netty.channel.socket.DatagramPacket#remoteAddress()} to determine, + /**, + * Send a {@link FileRegion} to the remote peer and notify the {@link ChannelFuture} once it completes, + * or an error was detected. Once the {@link FileRegion} was transfered or an error was thrown it will, + * automaticly closed via {@link io.netty.channel.FileRegion#close()}., + */, +++ b/transport/src/main/java/io/netty/channel/Channel.java, + * use {@link io.netty.channel.socket.DatagramPacket#remoteAddress()} to determine, + /**, + * Send a {@link FileRegion} to the remote peer and notify the {@link ChannelFuture} once it completes, + * or an error was detected. Once the {@link FileRegion} was
[+++ b/transport/src/main/java/io/netty/channel/socket/oio/AbstractOioMessageChannel.java, + protected ChannelBufferHolder<?> newOutboundBuffer() {, + return ChannelBufferHolders.messageBuffer();, +++ b/transport/src/main/java/io/netty/channel/socket/oio/AbstractOioMessageChannel.java, + protected ChannelBufferHolder<?> newOutboundBuffer() {, + return ChannelBufferHolders.messageBuffer();, +++ b/transport/src/main/java/io/netty/channel/socket/oio/AbstractOioStreamChannel.java, + protected ChannelBufferHolder<?> newOutboundBuffer() {, + return ChannelBufferHolders.byteBuffer();, +++ b/transport/src/main/java/io/netty/channel/socket/oio/AbstractOioMessageChannel.java, + protected ChannelBufferHolder<?> newOutboundBuffer() {, + return ChannelBufferHolders.messageBuffer();, +++ b/transport/src/main/java/io/netty/channel/socket/oio/AbstractOioStreamChannel.java, + protected ChannelBufferHolder<?> newOutboundBuffer() {, + return ChannelBufferHolders.byteBuffer();, +++ b/transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java, + protected ChannelBufferHolder<?> newOutboundBuffer() {, + return ChannelBufferHolders.messageBuffer();, +++ b/transport/src/main/java/io/netty/channel/socket/oio/AbstractOioMessageChannel.java, + protected ChannelBufferHolder<?> newOutboundBuffer() {, + return ChannelBufferHolders.messageBuffer();, +++ b/transport/src/main/java/io/netty/channel/socket/oio/AbstractOioStreamChannel.java, + protected ChannelBufferHolder<?> newOutboundBuffer() {, + return ChannelBufferHolders.byteBuffer();, +++ b/transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java, + protected ChannelBufferHolder<?> newOutboundBuffer() {, + return ChannelBufferHolders.messageBuffer();, +++ b/transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannel.java, + protected ChannelBufferHolder<?> newOutboundBuffer() {, +++ b/transport/src/main/java/io/netty/channel/socket/oio/AbstractOioMessageChannel.java,
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + private static final boolean CAN_ENABLE_TCP_NODELAY_BY_DEFAULT = !isAndroid();, +, + * Returns {@code true} if and only if it is fine to enable TCP_NODELAY socket option by default., + */, + public static boolean canEnableTcpNoDelayByDefault() {, + return CAN_ENABLE_TCP_NODELAY_BY_DEFAULT;, + }, +, + /**, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + private static final boolean CAN_ENABLE_TCP_NODELAY_BY_DEFAULT = !isAndroid();, +, + * Returns {@code true} if and only if it is fine to enable TCP_NODELAY socket option by default., + */, + public static boolean canEnableTcpNoDelayByDefault() {, + return CAN_ENABLE_TCP_NODELAY_BY_DEFAULT;, + }, +, + /**, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + private static
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslServerContext.java, +, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslServerContext.java, +, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.ByteBufInputStream;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +import org.apache.tomcat.jni.CertificateVerifier;, +import javax.security.auth.x500.X500Principal;, +import java.io.IOException;, +import java.security.KeyStoreException;, +import java.security.NoSuchAlgorithmException;, +import java.security.cert.CertificateException;, +import java.security.cert.X509Certificate;, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(OpenSslClientContext.class);, + // Set up trust manager factory to use our key store., + if (trustManagerFactory == null) {, + trustManagerFactory = TrustManagerFactory.getInstance(, + TrustManagerFactory.getDefaultAlgorithm());, + }, + final X509TrustManager manager = chooseTrustManager(trustManagerFactory.getTrustManagers());, +, + SSLContext.setCertVerifyCallback(ctx, new CertificateVerifier() {, + @Override, + public boolean verify(long ssl, byte[][] chain, String auth) {, + X509Certificate[] peerCerts = certificates(chain);,
[+++ b/tarball/pom.xml, + <excludeArtifactIds>netty-all</excludeArtifactIds>, + <excludeArtifactIds>netty-all</excludeArtifactIds>, + <includeArtifactIds>netty-all</includeArtifactIds>, + <includeArtifactIds>netty-all</includeArtifactIds>]
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/QueryStringDecoderTest.java, +, + // See https://github.com/netty/netty/issues/1833, + @Test, + public void testURI2() {, + URI uri = URI.create("http://foo.com/images;num=10?query=name;value=123");, + QueryStringDecoder decoder = new QueryStringDecoder(uri);, + Assert.assertEquals("/images;num=10", decoder.path());, + Map<String, List<String>> params = decoder.parameters();, + Assert.assertEquals(2, params.size());, + Iterator<Entry<String, List<String>>> entries = params.entrySet().iterator();, +, + Entry<String, List<String>> entry = entries.next();, + Assert.assertEquals("query", entry.getKey());, + Assert.assertEquals(1, entry.getValue().size());, + Assert.assertEquals("name", entry.getValue().get(0));, +, + entry = entries.next();, + Assert.assertEquals("value", entry.getKey());, + Assert.assertEquals(1, entry.getValue().size());, + Assert.assertEquals("123", entry.getValue().get(0));, +, + Assert.assertFalse(entries.hasNext());, + }]
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpInvalidMessageTest.java, + LastHttpContent chunk = ch.readInbound();]
[+++ b/src/docbook/module/architecture.xml, + Also, you are even able to take advantage of a new transport which is]
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, +import io.netty.channel.IncompleteFlushException;, + cause = new IncompleteFlushException("Unable to encoded all bytes", cause);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, +import io.netty.channel.IncompleteFlushException;, + cause = new IncompleteFlushException("Unable to encoded all bytes", cause);, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerUtil.java, + if (!handler.beginFlush(ctx)) {, + throw new IncompleteFlushException(, + "beginFlush(..) rejected the flush request by returning false. " +, + "none of " + inSize + " message(s) fulshed.");, + }, + IncompleteFlushException pfe;, + if (t instanceof IncompleteFlushException) {, + pfe = (IncompleteFlushException) t;, + } else {, + pfe = new IncompleteFlushException("aborted: " + msg);, + pfe = new IncompleteFlushException(msg, t);, + }, + *, + *
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostStandardRequestDecoder.java, + undecodedChunk.readerIndex(firstpos);, + // end of line or end of block so keep index to last valid position, + undecodedChunk.readerIndex(firstpos);, + undecodedChunk.readerIndex(firstpos);, + // end of line or end of block so keep index to last valid position, + undecodedChunk.readerIndex(firstpos);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostStandardRequestDecoder.java, + undecodedChunk.readerIndex(firstpos);, + // end of line or end of block so keep index to last valid position, + undecodedChunk.readerIndex(firstpos);, + undecodedChunk.readerIndex(firstpos);, + // end of line or end of block so keep index to last valid position, + undecodedChunk.readerIndex(firstpos);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java, +import io.netty.handler.codec.http.HttpContent;, +, + // See https://github.com/netty/netty/issues/2305, + @Test, + public void testChunkCorrect()
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +import io.netty.handler.codec.PrematureChannelClosureException;, + resetNow();, +, + if (currentState == State.READ_HEADER) {, + // If we are still in the state of reading headers we need to create a new invalid message that, + // signals that the connection was closed before we received the headers., + out.add(invalidMessage(Unpooled.EMPTY_BUFFER,, + new PrematureChannelClosureException("Connection closed before received headers")));, + resetNow();, + return;, + }, +, + resetNow();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +import io.netty.handler.codec.PrematureChannelClosureException;, + resetNow();, +, + if (currentState == State.READ_HEADER) {, + // If we are still in the state of reading headers we need to create a new invalid message that,
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, + static final int SPDY_SESSION_STREAM_ID = 0;, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, + static final int SPDY_SESSION_STREAM_ID = 0;, +, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, + static final int SPDY_SESSION_STREAM_ID = 0;, +, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, + public SpdyFrameCodec(SpdyVersion version) {, + SpdyVersion version, int maxChunkSize, int maxHeaderSize,, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, + static final int SPDY_SESSION_STREAM_ID = 0;, +, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, + public SpdyFrameCodec(SpdyVersion version) {, + SpdyVersion version, int maxChunkSize, int maxHeaderSize,, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + public SpdyFrameDecoder(SpdyVersion version) {, + public SpdyFrameDecoder(SpdyVersion version, int maxChunkSize, int maxHeaderSize) {, + SpdyVersion version, int maxChunkSize, SpdyHeaderBlockDecoder headerBlockDecoder) {, +
[+++ b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java, + channel.finishAndReleaseAll();, + incoming.release();, + for (;;) {, + ByteBuf buffer = channel.readOutbound();, + if (buffer == null) {, + break;, + }, + channel.writeInbound(buffer);, + }, +++ b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java, + channel.finishAndReleaseAll();, + incoming.release();, + for (;;) {, + ByteBuf buffer = channel.readOutbound();, + if (buffer == null) {, + break;, + }, + channel.writeInbound(buffer);, + }, +++ b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java, + channel.finishAndReleaseAll();, + written.skipBytes(DEFAULT_HEADER_SIZE);, + assertThat(written.readSlice(extrasLength).toString(CharsetUtil.UTF_8), equalTo(extrasContent));, + written.skipBytes(DEFAULT_HEADER_SIZE);, + assertThat(written.readSlice(keyLength).toString(CharsetUtil.UTF_8), equalTo("netty"));, + written.readSlice(content1.content().readableBytes()).toString(CharsetUtil.UTF_8),, + written.readSlice(content2.content().readableBytes()).toString(CharsetUtil.UTF_8),, +++ b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java, + channel.finishAndReleaseAll();, + incoming.release();, + for (;;) {, + ByteBuf buffer = channel.readOutbound();, + if (buffer == null) {, + break;,
[+++ b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java, + futures.put(c.id(), c.close());]
[+++ b/transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java, + return isOpen(), + && ((config.getOption(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION) && isRegistered()), + || socket.isBound());]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, + logger.log(internalLevel, format(ctx, formatMessage(eventName, i + 1, size, msgs.get(i))));]
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, + private static final boolean USE_TASKS =, + SystemPropertyUtil.getBoolean("io.netty.handler.ssl.openssl.useTasks", false);, +, + SSLContext.setUseTasks(ctx, USE_TASKS);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, + private static final boolean USE_TASKS =, + SystemPropertyUtil.getBoolean("io.netty.handler.ssl.openssl.useTasks", false);, +, + SSLContext.setUseTasks(ctx, USE_TASKS);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import static javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_TASK;, + private volatile boolean needTask;, + if (status == NEED_TASK) {, + return newResult(status, 0, bytesProduced);, + }, +, + } else if (sslError == SSL.SSL_ERROR_WANT_X509_LOOKUP) {, + return newResult(NEED_TASK, bytesConsumed, bytesProduced);, + if (hs == NEED_TASK) {, + // Set needTask to true so getHandshakeStatus() will return the correct value., + needTask = true;, + }, +, + if (status ==
[+++ b/testsuite-osgi/testsuite-osgi-deps/pom.xml, + <!-- feature doesn't invoke maven-compile-plugin unless specified explicitly. -->, + <plugin>, + <artifactId>maven-compiler-plugin</artifactId>, + <executions>, + <execution>, + <id>compile</id>, + <phase>compile</phase>, + <goals>, + <goal>compile</goal>, + </goals>, + </execution>, + <execution>, + <id>test-compile</id>, + <phase>test-compile</phase>, + <goals>, + <goal>testCompile</goal>, + </goals>, + </execution>, + </executions>, + </plugin>, +++ b/testsuite-osgi/testsuite-osgi-deps/pom.xml, + <!-- feature doesn't invoke maven-compile-plugin unless specified explicitly. -->, + <plugin>, + <artifactId>maven-compiler-plugin</artifactId>, + <executions>, + <execution>, + <id>compile</id>, + <phase>compile</phase>, + <goals>, + <goal>compile</goal>, + </goals>, + </execution>, + <execution>, + <id>test-compile</id>, + <phase>test-compile</phase>, + <goals>, + <goal>testCompile</goal>, + </goals>, + </execution>, + </executions>, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, +import io.netty.channel.ChannelPromiseNotifier;, +import io.netty.handler.codec.http2.Http2Stream.State;, + * the {@link Http2FrameCodec} can be build with {@link Http2FrameCodecBuilder#bufferOutboundStreams} enabled, in which, + return new Http2Stream2Impl(ctx0.channel());, + // TODO(buchgr): Remove once Http2Stream2 and Http2Stream are merged., + return true;, + // Ensure that the listener gets executed before any listeners a user might have attached., + // TODO(buchgr): Once Http2Stream2 and Http2Stream are merged this is no longer necessary., + ChannelPromiseNotifier promiseNotifier = new ChannelPromiseNotifier(promise);, + promise = ctx.newPromise();, + stream.legacyStream = connectionStream;, + promise.addListener(promiseNotifier);, + Http2Stream2Impl stream2 = new Http2Stream2Impl(ctx.channel()).id(stream.id());, + stream2.legacyStream = stream;, + stream.setProperty(streamKey, stream2);, + * Exceptions
[+++ b/common/src/main/java/io/netty/util/internal/Cleaner0.java, + Object cleaner = cleanerField.get(direct);, + try {, + // Cleaner implements Runnable from JDK9 onwards., + Runnable runnable = (Runnable) cleaner;, + clean = Runnable.class.getDeclaredMethod("run");, + } catch (ClassCastException ignored) {, + }, +++ b/common/src/main/java/io/netty/util/internal/Cleaner0.java, + Object cleaner = cleanerField.get(direct);, + try {, + // Cleaner implements Runnable from JDK9 onwards., + Runnable runnable = (Runnable) cleaner;, + clean = Runnable.class.getDeclaredMethod("run");, + } catch (ClassCastException ignored) {, + }, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, +, + freeDirectBuffer(direct);]
[+++ b/docker/docker-compose.yaml, + command: /bin/bash -cl "./mvnw clean install -Dio.netty.testsuite.badHost=netty.io -Dxml.skip=true -Dtcnative.artifactId=netty-tcnative-boringssl-static -Dtcnative.classifier=", +++ b/docker/docker-compose.yaml, + command: /bin/bash -cl "./mvnw clean install -Dio.netty.testsuite.badHost=netty.io -Dxml.skip=true -Dtcnative.artifactId=netty-tcnative-boringssl-static -Dtcnative.classifier=", +++ b/testsuite-shading/pom.xml, + <condition property="nativeTcnativeLib" value="netty_tcnative_osx_${os.detected.arch}.jnilib" else="netty_tcnative.jnilib">, + <equals arg1="${tcnative.classifier}" arg2="" />, + </condition>, +, + <condition property="nativeTcnativeLib" value="netty_tcnative_linux_${os.detected.arch}.so" else="netty_tcnative.so">, + <equals arg1="${tcnative.classifier}" arg2="" />, + </condition>, +]
[+++ b/common/src/main/java/io/netty/util/internal/RecyclableArrayList.java, + * A simple list which is reyclable. This implementation does not allow {@code null} elements to be added., + private static void checkNullElements(Collection<?> c) {, + @Override, + public Object set(int index, Object element) {, + if (element == null) {, + throw new NullPointerException("element");, + }, + return super.set(index, element);, + }, +]
[+++ b/example/src/main/java/io/netty/example/socksproxy/SocksServerConnectHandler.java, + Socks5CommandStatus.SUCCESS,, + request.dstAddrType(),, + request.dstAddr(),, + request.dstPort()));]
[+++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, +, + /**, + * Returns the {@link ChannelGroupFuture} which will be notified when all {@link Channel}s that are part of this, + * {@link ChannelGroup}, at the time of calling, are closed., + */, + ChannelGroupFuture newCloseFuture();, +, + /**, + * Returns the {@link ChannelGroupFuture} which will be notified when all {@link Channel}s that are part of this, + * {@link ChannelGroup}, at the time of calling, are closed., + */, + ChannelGroupFuture newCloseFuture(ChannelMatcher matcher);, +++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, +, + /**, + * Returns the {@link ChannelGroupFuture} which will be notified when all {@link Channel}s that
[+++ b/NOTICE.txt, +This product optionally depends on 'SLF4J', a simple logging facade for Java., +The monitor registries implementation is based on the approach used by SLF4J., +, +Slf4j can be obtained at:, +++ b/NOTICE.txt, +This product optionally depends on 'SLF4J', a simple logging facade for Java., +The monitor registries implementation is based on the approach used by SLF4J., +, +Slf4j can be obtained at:, +++ b/common/src/main/java/io/netty/monitor/MonitorRegistries.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(MonitorRegistries.class);, + //set of initialization states, + private static final int UNINITIALIZED = 0;, + private static final int ONGOING_INITIALIZATION = 1;,
[+++ b/codec/src/main/java/io/netty/handler/codec/LengthFieldPrepender.java, + private final int lengthAdjustment;, + this(lengthFieldLength, 0, lengthIncludesLengthFieldLength);, + }, +, + /**, + * Creates a new instance., + *, + * @param lengthFieldLength the length of the prepended length field., + * Only 1, 2, 3, 4, and 8 are allowed., + * @param lengthAdjustment the compensation value to add to the value, + * of the length field, + *, + * @throws IllegalArgumentException, + * if {@code lengthFieldLength} is not 1, 2, 3, 4, or 8, + */, + public LengthFieldPrepender(int lengthFieldLength, int lengthAdjustment) {, + this(lengthFieldLength, lengthAdjustment, false);, + }, +,
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +import java.security.AccessController;, +import java.security.PrivilegedAction;, + private static final Integer DH_KEY_LENGTH;, +, + Integer dhLen = null;, +, + try {, + String dhKeySize = AccessController.doPrivileged(new PrivilegedAction<String>() {, + @Override, + public String run() {, + return SystemPropertyUtil.get("jdk.tls.ephemeralDHKeySize");, + }, + });, + if (dhKeySize != null) {, + try {, + dhLen = Integer.parseInt(dhKeySize);, + } catch (NumberFormatException e) {, + logger.debug("OpenSslContext only support -Djdk.tls.ephemeralDHKeySize={int}, but got: ", + + dhKeySize);, + }, + }, + } catch (Throwable ignore) {, + // ignore, + }, + DH_KEY_LENGTH = dhLen;, + if (DH_KEY_LENGTH != null) {, +
[+++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java, + ByteBuffer buffer;, + setByteBuffer(allocateDirect(initialCapacity), false);, + setByteBuffer(initialBuffer.slice().order(ByteOrder.BIG_ENDIAN), false);, + final void setByteBuffer(ByteBuffer buffer, boolean tryFree) {, + if (tryFree) {, + }, + setByteBuffer(newBuffer, true);, + setByteBuffer(newBuffer, true);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java, + ByteBuffer buffer;, + setByteBuffer(allocateDirect(initialCapacity), false);, + setByteBuffer(initialBuffer.slice().order(ByteOrder.BIG_ENDIAN), false);, + final void setByteBuffer(ByteBuffer buffer, boolean tryFree) {, + if (tryFree) {, + }, + setByteBuffer(newBuffer, true);, + setByteBuffer(newBuffer, true);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeNoCleanerDirectByteBuf.java, +, + @Override, + public ByteBuf capacity(int newCapacity) {, + ensureAccessible();, + if (newCapacity < 0 || newCapacity > maxCapacity()) {, + throw new IllegalArgumentException("newCapacity: " + newCapacity);, + }, +, + int readerIndex =
[+++ b/handler/src/main/java/io/netty/handler/flush/FlushConsolidationHandler.java, +, +import java.util.concurrent.Future;, + * {@link ChannelDuplexHandler} which consolidates {@link Channel#flush()} / {@link ChannelHandlerContext#flush()}, + * operations (which also includes, + * {@link Channel#writeAndFlush(Object)} / {@link Channel#writeAndFlush(Object, ChannelPromise)} and, + * {@link ChannelOutboundInvoker#writeAndFlush(Object)} /, + * Flush operations are generally speaking expensive as these may trigger a syscall on the transport level. Thus it is, + * If a read loop is currently ongoing, {@link #flush(ChannelHandlerContext)} will not be passed on to the next, + * {@link ChannelOutboundHandler} in the {@link ChannelPipeline}, as it will pick up any pending flushes when, + * {@link #channelReadComplete(ChannelHandlerContext)} is triggered.,
[+++ b/transport-native-epoll/src/main/c/netty_epoll_native.c, +static inline void cpu_relax() {, +#if defined(__x86_64__), + asm volatile("pause\n": : :"memory");, +#endif, +}, +, +static jint netty_epoll_native_epollBusyWait0(JNIEnv* env, jclass clazz, jint efd, jlong address, jint len) {, + struct epoll_event *ev = (struct epoll_event*) (intptr_t) address;, + int result, err;, +, + // Zeros = poll (aka return immediately)., + do {, + result = epoll_wait(efd, ev, len, 0);, + if (result == 0) {, + // Since we're always polling epoll_wait with no timeout,, + // signal CPU that we're in a busy loop, + cpu_relax();, + }, +, + if (result >= 0) {,
[+++ b/pom.xml, + <version>1.2.3.GA</version>]
[+++ b/all/pom.xml, + <version>4.1.30.Final</version>, +++ b/all/pom.xml, + <version>4.1.30.Final</version>, +++ b/bom/pom.xml, + <version>4.1.30.Final</version>, + <tag>netty-4.1.30.Final</tag>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, +++ b/all/pom.xml, + <version>4.1.30.Final</version>, +++ b/bom/pom.xml, + <version>4.1.30.Final</version>, + <tag>netty-4.1.30.Final</tag>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, + <version>4.1.30.Final</version>, +
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + public ByteBuf readRetainedSlice(int length) {, + ByteBuf slice = retainedSlice(readerIndex, length);, + readerIndex += length;, + return slice;, + }, +, + @Override, + public ByteBuf retainedDuplicate() {, + return duplicate().retain();, + }, +, + @Override, + public ByteBuf retainedSlice() {, + return slice().retain();, + }, +, + @Override, + public ByteBuf retainedSlice(int index, int length) {, + return slice(index, length).retain();, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + public ByteBuf readRetainedSlice(int length) {, + ByteBuf slice = retainedSlice(readerIndex, length);, + readerIndex += length;, + return slice;, + }, +, + @Override, + public ByteBuf retainedDuplicate()
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + if (hasUnsafe()) {, + PlatformDependent0.freeDirectBufferUnsafe(buffer);, + } else {, + }, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + if (hasUnsafe()) {, + PlatformDependent0.freeDirectBufferUnsafe(buffer);, + } else {, + }, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + private static final Field CLEANER_FIELD;, + CLEANER_FIELD = cleanerField;, + static void freeDirectBufferUnsafe(ByteBuffer buffer) {, + static void freeDirectBuffer(ByteBuffer buffer) {, + if (CLEANER_FIELD == null) {, + return;, + }, + try {, + Cleaner cleaner = (Cleaner) CLEANER_FIELD.get(buffer);, + if (cleaner == null) {, + throw new IllegalArgumentException(, + "attempted to deallocate the buffer which was allocated via JNIEnv->NewDirectByteBuffer()");, + }, + cleaner.clean();, + } catch
[+++ b/testsuite-shading/src/test/java/io/netty/testsuite/shading/ShadingIT.java, +import org.junit.Ignore;, + @Ignore("Figure out why this sometimes fail on the CI")]
[+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java, + * Request to bind to the given {@link SocketAddress} and notify the {@link ChannelFuture} once the operation, + * completes, either because the operation was successful or because of an error., + * <p>, + * This will result in having the, + * {@link ChannelOperationHandler#bind(ChannelHandlerContext, SocketAddress, ChannelPromise)} method, + * called of the next {@link ChannelOperationHandler} contained in the {@link ChannelPipeline} of the, + * {@link Channel}., + * Request to connect to the given {@link SocketAddress} and notify the {@link ChannelFuture} once the operation, + * completes, either because the operation was successful or
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + return ctx.outboundByteBuffer().isWritable();, + return ctx.outboundMessageBuffer().isWritable();]
[+++ b/all/pom.xml, + <version>4.1.12.Final</version>, +++ b/all/pom.xml, + <version>4.1.12.Final</version>, +++ b/bom/pom.xml, + <version>4.1.12.Final</version>, + <tag>netty-4.1.12.Final</tag>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, +++ b/all/pom.xml, + <version>4.1.12.Final</version>, +++ b/bom/pom.xml, + <version>4.1.12.Final</version>, + <tag>netty-4.1.12.Final</tag>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, + <version>4.1.12.Final</version>, +
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocatorMetric.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/common/src/main/java/io/netty/util/internal/InternalThreadLocalMap.java, + return ((FastThreadLocalThread) thread).threadLocalMap();, + return slowThreadLocalMap.get();, + slowThreadLocalMap.remove();, +++ b/common/src/main/java/io/netty/util/internal/InternalThreadLocalMap.java, + return ((FastThreadLocalThread) thread).threadLocalMap();, + return slowThreadLocalMap.get();, + slowThreadLocalMap.remove();, +++ b/common/src/main/java/io/netty/util/internal/UnpaddedInternalThreadLocalMap.java, + static final ThreadLocal<InternalThreadLocalMap> slowThreadLocalMap = new ThreadLocal<InternalThreadLocalMap>();, +++ b/common/src/main/java/io/netty/util/internal/InternalThreadLocalMap.java, + return ((FastThreadLocalThread) thread).threadLocalMap();, + return slowThreadLocalMap.get();, + slowThreadLocalMap.remove();, +++ b/common/src/main/java/io/netty/util/internal/UnpaddedInternalThreadLocalMap.java, + static final ThreadLocal<InternalThreadLocalMap> slowThreadLocalMap = new ThreadLocal<InternalThreadLocalMap>();, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/internal/InternalThreadLocalMap.java, + return ((FastThreadLocalThread) thread).threadLocalMap();, + return slowThreadLocalMap.get();, + slowThreadLocalMap.remove();, +++ b/common/src/main/java/io/netty/util/internal/UnpaddedInternalThreadLocalMap.java, + static final ThreadLocal<InternalThreadLocalMap> slowThreadLocalMap = new ThreadLocal<InternalThreadLocalMap>();, +++ /dev/null, +++ b/microbench/src/main/java/io/netty/microbench/concurrent/FastThreadLocalFastPathBenchmark.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + private int callDepth;, + boolean isRunning() {, + return callDepth != 0;, + }, +, + callDepth ++;, + try {, + ((ChannelInboundHandler) handler).channelRegistered(this);, + } finally {, + callDepth --;, + }, + callDepth ++;, + try {, + ((ChannelInboundHandler) handler).channelUnregistered(this);, + } finally {, + callDepth --;, + }, + callDepth ++;, + try {, + ((ChannelInboundHandler) handler).channelActive(this);, + } finally {, + callDepth --;, + }, + callDepth ++;, + try {, + ((ChannelInboundHandler) handler).channelInactive(this);, + } finally {, + callDepth --;, + }, + try {, + callDepth ++;, + } finally
[+++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + sb.childHandler(new ChannelInitializer<SocketChannel>() {, + cb.handler(ch);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + sb.childHandler(new ChannelInitializer<SocketChannel>() {, + cb.handler(ch);, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, + .handler(new DiscardClientHandler(firstMessageSize));, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + sb.childHandler(new ChannelInitializer<SocketChannel>() {, + cb.handler(ch);, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, + .handler(new DiscardClientHandler(firstMessageSize));, +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, + .childHandler(new ChannelInitializer<SocketChannel>() {, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + sb.childHandler(new ChannelInitializer<SocketChannel>() {, + cb.handler(ch);, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, + .handler(new DiscardClientHandler(firstMessageSize));, +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, + .childHandler(new ChannelInitializer<SocketChannel>() {, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, + .handler(new ChannelInitializer<SocketChannel>() {, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + sb.childHandler(new ChannelInitializer<SocketChannel>() {, + cb.handler(ch);, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, + .handler(new DiscardClientHandler(firstMessageSize));, +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, + .childHandler(new ChannelInitializer<SocketChannel>() {, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, + .handler(new ChannelInitializer<SocketChannel>() {, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + .handler(new ChannelInitializer<ServerSocketChannel>() {, + .childHandler(new ChannelInitializer<SocketChannel>()
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/UTF8Exception.java, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + public ChannelBufType type() {, + return ChannelBufType.BYTE;, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + public ChannelBufType type() {, + return ChannelBufType.BYTE;, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuf.java, + ChannelBufType type();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + public ChannelBufType type() {, + return ChannelBufType.BYTE;, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuf.java, + ChannelBufType type();, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBufType.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderNames.java, + public static final AsciiString CONTENT_SECURITY_POLICY = new AsciiString("content-security-policy");, + public static final AsciiString X_FRAME_OPTIONS = new AsciiString("x-frame-options");]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + final ChannelFuture handshakeFuture = channel.newFuture();, +, + if (future.isSuccess()) {, + handshakeFuture.setSuccess();, + } else {, + handshakeFuture.setFailure(future.cause());, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + final ChannelFuture handshakeFuture = channel.newFuture();, +, + if (future.isSuccess()) {, + handshakeFuture.setSuccess();, + } else {, + handshakeFuture.setFailure(future.cause());, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + final ChannelFuture handshakeFuture = channel.newFuture();, +, + if (future.isSuccess()) {, + handshakeFuture.setSuccess();, + } else {, + handshakeFuture.setFailure(future.cause());, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + final ChannelFuture handshakeFuture = channel.newFuture();, +, + if (future.isSuccess()) {, + handshakeFuture.setSuccess();, + } else {, + handshakeFuture.setFailure(future.cause());, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + final ChannelFuture handshakeFuture =
[+++ b/all/pom.xml, + <includeScope>runtime</includeScope>, + <includeScope>runtime</includeScope>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java, + for (Map.Entry<String, String> e: headers()) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java, + for (Map.Entry<String, String> e: headers()) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + private HttpMessage message;, + assert message == null;, + message = (HttpMessage) msg;, + HttpMessage message = this.message;, + HttpHeaders headers = message.headers();, + this.message = null;, + String contentEncoding = headers.get(HttpHeaders.Names.CONTENT_ENCODING);, + headers.remove(HttpHeaders.Names.CONTENT_ENCODING);, + headers.set(HttpHeaders.Names.CONTENT_ENCODING, targetContentEncoding);, + Object[] decoded = decodeContent(message, c);, + if (headers.contains(HttpHeaders.Names.CONTENT_LENGTH)) {, + headers.set(, + return new Object[] { message, c };, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java, + for (Map.Entry<String, String> e: headers()) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + private HttpMessage message;, + assert message == null;, +
[+++ b/pom.xml]
[+++ b/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java, + return buffer.nioBuffers(index + adjustment, length);]
[+++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, +import io.netty.channel.socket.ServerSocketChannel;, + .initializer(new ChannelInitializer<ServerSocketChannel>() {, + @Override, + public void initChannel(ServerSocketChannel ch) throws Exception {, + ch.pipeline().addLast(new LoggingHandler(LogLevel.INFO));, + }, + })]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, + String value = null;, + // loop until the first header was found, + value = e.value;, + return value;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, + String value = null;, + // loop until the first header was found, + value = e.value;, + return value;, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpHeadersTest.java, +import java.util.List;, +, +, + // Test for https://github.com/netty/netty/issues/1690, + @Test, + public void testGetOperations() {, + HttpHeaders headers = new DefaultHttpHeaders();, + headers.add("Foo", "1");, + headers.add("Foo", "2");, +, + Assert.assertEquals("1", headers.get("Foo"));, +, + List<String> values = headers.getAll("Foo");, + Assert.assertEquals(2, values.size());, + Assert.assertEquals("1", values.get(0));, + Assert.assertEquals("2", values.get(1));, + }]
[+++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java]
[+++ b/handler/pom.xml, + <optional>true</optional>]
[+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponse.java, + if (port < 0 || port > 65535) {, + throw new IllegalArgumentException(port + " is not in bounds 0 <= x <= 65535");]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelOption.java, + public static final ChannelOption<Boolean> TCP_CORK = valueOf(EpollChannelOption.class, "TCP_CORK");, + public static final ChannelOption<Boolean> SO_REUSEPORT = valueOf(EpollChannelOption.class, "SO_REUSEPORT");, + public static final ChannelOption<Long> TCP_NOTSENT_LOWAT = valueOf(EpollChannelOption.class, "TCP_NOTSENT_LOWAT");, + public static final ChannelOption<Integer> TCP_KEEPIDLE = valueOf(EpollChannelOption.class, "TCP_KEEPIDLE");, + public static final ChannelOption<Integer> TCP_KEEPINTVL = valueOf(EpollChannelOption.class, "TCP_KEEPINTVL");, + public static final ChannelOption<Integer> TCP_KEEPCNT = valueOf(EpollChannelOption.class, "TCP_KEEPCNT");, + public static final ChannelOption<Integer> TCP_USER_TIMEOUT =, + valueOf(EpollChannelOption.class, "TCP_USER_TIMEOUT");, + public static final ChannelOption<Boolean> IP_FREEBIND = valueOf("IP_FREEBIND");, + public static final ChannelOption<Integer> TCP_FASTOPEN = valueOf(EpollChannelOption.class, "TCP_FASTOPEN");, + public static final ChannelOption<Integer> TCP_DEFER_ACCEPT =, + ChannelOption.valueOf(EpollChannelOption.class, "TCP_DEFER_ACCEPT");, + public static final ChannelOption<Boolean> TCP_QUICKACK
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + if (ctx.isRemoved()) {, + if (ctx.isRemoved()) {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + if (ctx.isRemoved()) {, + if (ctx.isRemoved()) {, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, + if (!ctx.isRemoved() && acceptOutboundMessage(m)) {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + if (ctx.isRemoved()) {, + if (ctx.isRemoved()) {, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, + if (!ctx.isRemoved() && acceptOutboundMessage(m)) {, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, + if (!ctx.isRemoved() && acceptInboundMessage(m)) {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + if (ctx.isRemoved()) {, + if (ctx.isRemoved()) {, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, + if (!ctx.isRemoved() && acceptOutboundMessage(m)) {, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, + if (!ctx.isRemoved() && acceptInboundMessage(m)) {, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, + if (!ctx.isRemoved() && acceptOutboundMessage(m)) {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + if (ctx.isRemoved()) {, + if (ctx.isRemoved()) {, +++
[+++ b/pom.xml, + <version>3.2.0.ALPHA2</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.2.0.ALPHA2</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.2.0.ALPHA2</developerConnection>]
[+++ b/src/docbook/custom.dtd, +<!ENTITY home "http://www.jboss.org/netty">, +<!ENTITY doc "http://www.jboss.org/file-access/default/members/netty/freezone">, +<!ENTITY api "&doc;/api/3.0">, +<!ENTITY xref "&doc;/xref/3.0">, +++ b/src/docbook/custom.dtd, +<!ENTITY home "http://www.jboss.org/netty">, +<!ENTITY doc "http://www.jboss.org/file-access/default/members/netty/freezone">, +<!ENTITY api "&doc;/api/3.0">, +<!ENTITY xref "&doc;/xref/3.0">, +++ b/src/docbook/master.xml, +<!ENTITY % CustomDTD SYSTEM "custom.dtd">, +%CustomDTD; , +++ b/src/docbook/custom.dtd, +<!ENTITY home "http://www.jboss.org/netty">, +<!ENTITY doc "http://www.jboss.org/file-access/default/members/netty/freezone">, +<!ENTITY api "&doc;/api/3.0">, +<!ENTITY xref "&doc;/xref/3.0">, +++ b/src/docbook/master.xml, +<!ENTITY % CustomDTD SYSTEM "custom.dtd">, +%CustomDTD; , +++ b/src/docbook/module/appendix.xml, +<!ENTITY % CustomDTD SYSTEM "../custom.dtd">, +%CustomDTD; , +++ b/src/docbook/custom.dtd, +<!ENTITY home "http://www.jboss.org/netty">, +<!ENTITY doc "http://www.jboss.org/file-access/default/members/netty/freezone">, +<!ENTITY api "&doc;/api/3.0">, +<!ENTITY xref "&doc;/xref/3.0">, +++ b/src/docbook/master.xml, +<!ENTITY % CustomDTD SYSTEM "custom.dtd">, +%CustomDTD; , +++ b/src/docbook/module/appendix.xml, +<!ENTITY % CustomDTD SYSTEM "../custom.dtd">,
[+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java, + super.retain();, + super.retain(increment);, + super.touch();, + super.touch(hint);, + super.release();, + super.release(decrement);, + ByteBuf extras = getExtras();, + if (extras != null) {, + extras = extras.copy();, + }, + return new DefaultFullBinaryMemcacheRequest(getKey(), extras, content().copy());, + ByteBuf extras = getExtras();, + if (extras != null) {, + extras = extras.duplicate();, + }, + return new DefaultFullBinaryMemcacheRequest(getKey(), extras, content().duplicate());, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultFullBinaryMemcacheRequest.java, + super.retain();, + super.retain(increment);, + super.touch();, + super.touch(hint);, + super.release();, + super.release(decrement);, + ByteBuf extras = getExtras();, + if (extras != null) {, + extras = extras.copy();, + }, + return new DefaultFullBinaryMemcacheRequest(getKey(), extras, content().copy());, + ByteBuf
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +import java.lang.reflect.Field;, + public static void putObject(Object o, long offset, Object x) {, + PlatformDependent0.putObject(o, offset, x);, + }, +, + public static long objectFieldOffset(Field field) {, + return PlatformDependent0.objectFieldOffset(field);, + }, +, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +import java.lang.reflect.Field;, + public static void putObject(Object o, long offset, Object x) {, + PlatformDependent0.putObject(o, offset, x);, + }, +, + public static long objectFieldOffset(Field field) {, + return PlatformDependent0.objectFieldOffset(field);, + }, +, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + static void putObject(Object o, long offset, Object x) {, + UNSAFE.putObject(o, offset, x);, + }, +, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +import java.lang.reflect.Field;, + public static void putObject(Object o,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + * As a workaround to the <a href="http://netty.io/s/hashdos">HashDOS</a> vulnerability, the decoder, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + * As a workaround to the <a href="http://netty.io/s/hashdos">HashDOS</a> vulnerability, the decoder, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java, + * Performs server side opening and closing handshakes for <a href="http://netty.io/s/rfc6455">RFC 6455</a>, + * (originally web socket specification <a href="http://netty.io/s/ws-17">draft-ietf-hybi-thewebsocketprotocol-17</a>)., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + * As a workaround to the <a href="http://netty.io/s/hashdos">HashDOS</a> vulnerability, the decoder, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java, + * Performs server side opening and closing handshakes for <a href="http://netty.io/s/rfc6455">RFC 6455</a>, + * (originally web socket specification <a href="http://netty.io/s/ws-17">draft-ietf-hybi-thewebsocketprotocol-17</a>)., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/package-info.java, + * <li><a href="http://netty.io/s/ws-00">draft-ietf-hybi-thewebsocketprotocol-00</a></li>, + * <li><a href="http://netty.io/s/ws-07">draft-ietf-hybi-thewebsocketprotocol-07</a></li>, +
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java, + private enum WrapType {, + NONE, DUP, SLICE,, + }, +, + testSimpleSend(sb, cb, Unpooled.directBuffer().writeBytes(BYTES), true, BYTES, 1);, + testSimpleSend(sb, cb, Unpooled.directBuffer().writeBytes(BYTES), true, BYTES, 4);, + testSimpleSend(sb, cb, Unpooled.buffer().writeBytes(BYTES), true, BYTES, 1);, + testSimpleSend(sb, cb, Unpooled.buffer().writeBytes(BYTES), true, BYTES, 4);, + testSimpleSend(sb, cb, buf, true, BYTES, 1);, + testSimpleSend(sb, cb, buf2, true, BYTES, 4);, + testSimpleSend(sb, cb, buf, true, BYTES, 1);, + testSimpleSend(sb, cb, buf2, true, BYTES, 4);, + testSimpleSend(sb, cb, buf, true, BYTES, 1);, + testSimpleSend(sb, cb, buf2, true, BYTES, 4);, + testSimpleSend(sb, cb, Unpooled.directBuffer().writeBytes(BYTES), false, BYTES, 1);, + testSimpleSend(sb, cb, Unpooled.directBuffer().writeBytes(BYTES), false, BYTES, 4);, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/SniHandler.java, + // Maximal number of ssl records to inspect before fallback to the default SslContext., + private static final int MAX_SSL_RECORDS = 4;, +, + private static final Selection EMPTY_SELECTION = new Selection(null, null);, + private boolean handshakeFailed;, +, + private volatile Selection selection = EMPTY_SELECTION;, + return selection.hostname;, + return selection.context;, + if (!handshakeFailed && in.readableBytes() >= SslUtils.SSL_RECORD_HEADER_LENGTH) {, + int writerIndex = in.writerIndex();, + loop: for (int i = 0; i < MAX_SSL_RECORDS; i++) {, + case SslUtils.SSL_CONTENT_TYPE_CHANGE_CIPHER_SPEC:, + case SslUtils.SSL_CONTENT_TYPE_ALERT:, + int len = SslUtils.getEncryptedPacketLength(in, readerIndex);, + // Not an SSL/TLS packet, + if
[+++ b/NOTICE.txt, +This product optionally depends on 'Compress-LZF', a Java library for encoding and, +decoding data in LZF format, written by Tatu Saloranta. It can be obtained at:, +, + * LICENSE:, + * license/LICENSE.compress-lzf.txt (Apache License 2.0), + * HOMEPAGE:, + * https://github.com/ning/compress, +, +++ b/NOTICE.txt, +This product optionally depends on 'Compress-LZF', a Java library for encoding and, +decoding data in LZF format, written by Tatu Saloranta. It can be obtained at:, +, + * LICENSE:, + * license/LICENSE.compress-lzf.txt (Apache License 2.0), + * HOMEPAGE:, + * https://github.com/ning/compress, +, +++ b/codec/pom.xml, + <dependency>, + <groupId>com.ning</groupId>, + <artifactId>compress-lzf</artifactId>, +
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, + // First check if EPOLLRDHUP was set, this will notify us for connection-reset in which case, + // we may close the channel directly or try to read more data depending on the state of the, + // Channel and als depending on the AbstractEpollChannel subtype., + if ((ev & Native.EPOLLRDHUP) != 0) {, + if ((ev & Native.EPOLLIN) != 0 && ch.isOpen()) {, + // The Channel is still open and there is something to read. Do it now., + unsafe.epollInReady();, + }, + // Force flush of data as the epoll is writable again]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java, +import static org.junit.Assert.assertNull;, + assertEquals(0, data.refCnt());]
[+++ b/common/src/main/java/io/netty/util/internal/logging/InternalLoggerFactory.java, + private static volatile InternalLoggerFactory defaultFactory =, + newDefaultFactory(InternalLoggerFactory.class.getName());]
[+++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java, +import java.util.HashSet;, +import java.util.Set;, + private static final String PROP_MAX_SAMPLED_RECORDS = "io.netty.leakDetection.maxSampledRecords";, +, + private static final int MAX_SAMPLED_RECORDS;, + long maxRecordsSampled = SystemPropertyUtil.getLong(PROP_MAX_SAMPLED_RECORDS, MAX_RECORDS * 10L);, + MAX_SAMPLED_RECORDS = Math.max((int) Math.min(Integer.MAX_VALUE, maxRecordsSampled), MAX_RECORDS);, + logger.debug("-D{}: {}", PROP_MAX_SAMPLED_RECORDS, MAX_SAMPLED_RECORDS);, + reportLeak();, + }, + reportLeak();, + private void clearRefQueue() {, + }, +, + private void reportLeak() {, + if (!logger.isErrorEnabled()) {, + clearRefQueue();, + private final Record head;, + // This will be updated once a new Record will be created and added, + private Record tail;, +, + private final int trackedHash;, + private int
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + addIfSupported(availableJavaCipherSuites, defaultCiphers, DEFAULT_CIPHER_SUITES);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + addIfSupported(availableJavaCipherSuites, defaultCiphers, DEFAULT_CIPHER_SUITES);, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslTest.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS"
[+++ b/common/src/main/java/io/netty/util/internal/logging/InternalLoggerFactory.java, +import java.util.concurrent.atomic.AtomicReference;, +, + * Creates {@link InternalLogger}s. This factory allows you to choose what logging framework Netty should use. The, + * default factory is {@link Slf4JLoggerFactory}. If SLF4J is not available, {@link Log4JLoggerFactory} is used. If, + * Log4J is not available, {@link JdkLoggerFactory} is used. You can change it to your preferred logging framework, + * before other Netty classes are loaded via {@link #setDefaultFactory(InternalLoggerFactory)}. If you want to change, + * the logger factory, {@link #setDefaultFactory(InternalLoggerFactory)} must be invoked before any other Netty classes, + * are loaded. Note that {@link #setDefaultFactory(InternalLoggerFactory)}} can
[+++ b/transport-sctp/src/main/java/io/netty/channel/socket/sctp/SctpChannel.java, +import java.net.InetSocketAddress;, + @Override, + SctpServerChannel parent();, +, + InetSocketAddress localAddress();, + Set<InetSocketAddress> allLocalAddresses();, + InetSocketAddress remoteAddress();, + Set<InetSocketAddress> allRemoteAddresses();, +++ b/transport-sctp/src/main/java/io/netty/channel/socket/sctp/SctpChannel.java, +import java.net.InetSocketAddress;, + @Override, + SctpServerChannel parent();, +, + InetSocketAddress localAddress();, + Set<InetSocketAddress> allLocalAddresses();, + InetSocketAddress remoteAddress();, + Set<InetSocketAddress> allRemoteAddresses();, +++ b/transport-sctp/src/main/java/io/netty/channel/socket/sctp/SctpServerChannel.java, +import java.net.InetSocketAddress;, + InetSocketAddress localAddress();, + Set<InetSocketAddress> allLocalAddresses();, +++ b/transport-sctp/src/main/java/io/netty/channel/socket/sctp/SctpChannel.java, +import java.net.InetSocketAddress;, + @Override, + SctpServerChannel parent();, +, + InetSocketAddress localAddress();, + Set<InetSocketAddress> allLocalAddresses();, + InetSocketAddress remoteAddress();, + Set<InetSocketAddress> allRemoteAddresses();, +++ b/transport-sctp/src/main/java/io/netty/channel/socket/sctp/SctpServerChannel.java, +import java.net.InetSocketAddress;, + InetSocketAddress localAddress();, + Set<InetSocketAddress> allLocalAddresses();, +++ b/transport-sctp/src/main/java/io/netty/channel/socket/sctp/nio/NioSctpChannel.java, +import io.netty.channel.socket.sctp.SctpServerChannel;, +import java.net.InetSocketAddress;, +import java.util.LinkedHashSet;, + public SctpServerChannel parent() {,
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +, + // If the list is empty we need to assign a new one because, + // we get a List that is immutable. , + //, + // See https://github.com/netty/netty/issues/325, + if (list.isEmpty()) {, + list = new ArrayList<ChannelBuffer>(1);, + }, + , +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +, + // If the list is empty we need to assign a new one because, + // we get a List that is immutable. , + //, + // See https://github.com/netty/netty/issues/325, + if (list.isEmpty()) {, + list = new ArrayList<ChannelBuffer>(1);, + }, + , +++ b/buffer/src/test/java/io/netty/buffer/AbstractChannelBufferTest.java, + , +
[+++ b/all/pom.xml, + <activation>, + <property>, + <name>uber</name>, + </property>, + </activation>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport-native-epoll</artifactId>, + <version>${project.version}</version>, + <classifier>linux-x86_64</classifier>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport-native-kqueue</artifactId>, + <version>${project.version}</version>, + <classifier>osx-x86_64</classifier>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <excludes>io/netty/example/**,META-INF/native/libnetty-tcnative*,META-INF/native/include/**,META-INF/native/**/*.a</excludes>, +++ b/all/pom.xml, + <activation>, + <property>, + <name>uber</name>, + </property>, + </activation>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport-native-epoll</artifactId>, + <version>${project.version}</version>, + <classifier>linux-x86_64</classifier>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport-native-kqueue</artifactId>, + <version>${project.version}</version>, + <classifier>osx-x86_64</classifier>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <excludes>io/netty/example/**,META-INF/native/libnetty-tcnative*,META-INF/native/include/**,META-INF/native/**/*.a</excludes>, +++ b/common/src/main/java/io/netty/util/NetUtil.java, +import java.io.IOException;, +import java.io.InputStream;, +import
[+++ b/pom.xml, + <version>2.1.1</version>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + long maxAge = -1;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + long maxAge = -1;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java, + if (maxAge < -1) {, + throw new IllegalArgumentException(, + "maxAge must be either -1, 0, or a positive integer: " +, + maxAge);, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + long maxAge = -1;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java, + if (maxAge < -1) {, + throw new IllegalArgumentException(, + "maxAge must be either -1, 0, or a positive integer: " +, + maxAge);, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java, + private boolean chunked;, + public boolean isChunked() {, + if (chunked) {, + return true;, + }
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/sctp/AbstractSctpTest.java, + serverBootstrap.localAddress(new InetSocketAddress(NetUtil.LOCALHOST, 0));, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/sctp/AbstractSctpTest.java, + serverBootstrap.localAddress(new InetSocketAddress(NetUtil.LOCALHOST, 0));, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/sctp/SctpEchoTest.java, + Channel cc = cb.connect(sc.localAddress()).sync().channel();, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/sctp/AbstractSctpTest.java, + serverBootstrap.localAddress(new InetSocketAddress(NetUtil.LOCALHOST, 0));, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/sctp/SctpEchoTest.java, + Channel cc = cb.connect(sc.localAddress()).sync().channel();, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/AbstractClientSocketTest.java, + return new InetSocketAddress(NetUtil.LOCALHOST, 0);, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/sctp/AbstractSctpTest.java, + serverBootstrap.localAddress(new InetSocketAddress(NetUtil.LOCALHOST, 0));, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/sctp/SctpEchoTest.java, + Channel cc = cb.connect(sc.localAddress()).sync().channel();, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/AbstractClientSocketTest.java, + return new InetSocketAddress(NetUtil.LOCALHOST, 0);, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java, +import java.net.SocketAddress;, + protected SocketAddress newSocketAddress() {, + // We use LOCALHOST4 as we use InternetProtocolFamily.IPv4 when creating the DatagramChannel and its, + // not supported to bind to and IPV6 address in this case., + //, +
[+++ b/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java, +import java.lang.reflect.Field;, + private static final boolean DISABLE_KEYSET_OPTIMIZATION =, + SystemPropertyUtil.getBoolean("io.netty.noKeySetOptimization", false);, + logger.debug("io.netty.noKeySetOptimization: {}", DISABLE_KEYSET_OPTIMIZATION);, + private SelectedSelectionKeySet selectedKeys;, + final Selector selector;, + selector = provider.openSelector();, +, + if (DISABLE_KEYSET_OPTIMIZATION) {, + return selector;, + }, +, + try {, + SelectedSelectionKeySet selectedKeySet = new SelectedSelectionKeySet();, +, + Class<?> selectorImplClass =, + Class.forName("sun.nio.ch.SelectorImpl", false, ClassLoader.getSystemClassLoader());, + selectorImplClass.isAssignableFrom(selector.getClass());, + Field selectedKeysField = selectorImplClass.getDeclaredField("selectedKeys");, + Field publicSelectedKeysField = selectorImplClass.getDeclaredField("publicSelectedKeys");, +, + selectedKeysField.setAccessible(true);, + publicSelectedKeysField.setAccessible(true);, +, + selectedKeysField.set(selector, selectedKeySet);, + publicSelectedKeysField.set(selector, selectedKeySet);, +, + selectedKeys = selectedKeySet;, + logger.trace("Instrumented an optimized java.util.Set into: {}", selector);, + } catch
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/container/guice/NettyModule.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2009, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License,
[+++ b/common/src/main/java/io/netty/util/internal/MacAddressUtil.java, +import io.netty.util.NetUtil;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +import static io.netty.util.internal.EmptyArrays.EMPTY_BYTES;, + private static final int EUI64_MAC_ADDRESS_LENGTH = 8;, + private static final int EUI48_MAC_ADDRESS_LENGTH = 6;, +, + byte[] bestMacAddr = EMPTY_BYTES;, + if (bestMacAddr == EMPTY_BYTES) {, + case EUI48_MAC_ADDRESS_LENGTH: // EUI-48 - convert to EUI-64, + byte[] newAddr = new byte[EUI64_MAC_ADDRESS_LENGTH];, + bestMacAddr = Arrays.copyOf(bestMacAddr, EUI64_MAC_ADDRESS_LENGTH);, + * Returns the result of {@link #bestAvailableMac()} if non-{@code null} otherwise returns a random EUI-64 MAC, + * address., + */, + public static byte[] defaultMachineId() {, + byte[] bestMacAddr = MacAddressUtil.bestAvailableMac();, + if (bestMacAddr == null) {,
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsMessageUtil.java, + .append(message.<DnsRecord>recordAt(section, i));]
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + this, allocateDirect(chunkSize),, + pageSize, maxOrder, pageShifts, chunkSize);, + return new PoolChunk<ByteBuffer>(this, allocateDirect(capacity), capacity);, + }, +, + private static ByteBuffer allocateDirect(int capacity) {, + return PlatformDependent.useDirectBufferNoCleaner() ?, + PlatformDependent.allocateDirectNoCleaner(capacity) : ByteBuffer.allocateDirect(capacity);, + if (PlatformDependent.useDirectBufferNoCleaner()) {, + PlatformDependent.freeDirectNoCleaner(chunk.memory);, + } else {, + }, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + this, allocateDirect(chunkSize),, + pageSize, maxOrder, pageShifts, chunkSize);, + return new PoolChunk<ByteBuffer>(this, allocateDirect(capacity), capacity);, + }, +, + private static ByteBuffer allocateDirect(int capacity) {, + return PlatformDependent.useDirectBufferNoCleaner() ?, + PlatformDependent.allocateDirectNoCleaner(capacity) : ByteBuffer.allocateDirect(capacity);, + if (PlatformDependent.useDirectBufferNoCleaner()) {, + PlatformDependent.freeDirectNoCleaner(chunk.memory);, + } else {, + }, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, + buf = UnsafeByteBufUtil.newUnsafeDirectByteBuf(this, initialCapacity,
[+++ b/.gitignore, +, +*/.unison.*]
[+++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketFrameHandler.java]
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +, + // If the list is empty we need to assign a new one because, + // we get a List that is immutable. , + //, + // See https://github.com/netty/netty/issues/325, + if (list.isEmpty()) {, + list = new ArrayList<ChannelBuffer>(1);, + }, + , +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +, + // If the list is empty we need to assign a new one because, + // we get a List that is immutable. , + //, + // See https://github.com/netty/netty/issues/325, + if (list.isEmpty()) {, + list = new ArrayList<ChannelBuffer>(1);, + }, + , +++ b/buffer/src/test/java/io/netty/buffer/AbstractChannelBufferTest.java, + , +
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + } else {, + buf.release();, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + } else {, + buf.release();, +++ b/codec/src/test/java/io/netty/handler/codec/ByteToMessageDecoderTest.java, +import io.netty.util.ReferenceCountUtil;, +, + /**, + * Verifies that internal buffer of the ByteToMessageDecoder is released once decoder is removed from pipeline. In, + * this case input is read fully., + */, + @Test, + public void testInternalBufferClearReadAll() {, + final ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer().writeBytes(new byte[]{'a'}));, + EmbeddedChannel channel = new EmbeddedChannel(new ByteToMessageDecoder() {, + @Override, + protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {, + ByteBuf byteBuf = internalBuffer();, + Assert.assertEquals(1, byteBuf.refCnt());, + in.readByte();, + //
[+++ b/pom.xml, + !${project.groupId}.util.internal.*,, + ${project.groupId}.util.internal.*,]
[+++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java, + UnpooledUnsafeDirectByteBuf copy =, + (UnpooledUnsafeDirectByteBuf) alloc().directBuffer(capacity(), maxCapacity());]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, +import io.netty.channel.ChannelMetadata;, + private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16);, + @Override, + public ChannelMetadata metadata() {, + return METADATA;, + }, +, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, +import io.netty.channel.ChannelMetadata;, + private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16);, + @Override, + public ChannelMetadata metadata() {, + return METADATA;, + }, +, +++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteConnectorChannel.java, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, +import io.netty.channel.ChannelMetadata;, + private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16);, + @Override, + public ChannelMetadata metadata() {, + return METADATA;, + }, +, +++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteConnectorChannel.java, +++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java, +import io.netty.channel.ChannelMetadata;, + private static final ChannelMetadata METADATA = new ChannelMetadata(false, 16);,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, +import java.nio.charset.UnsupportedCharsetException;, + } catch (UnsupportedCharsetException e) {, + throw new ErrorDataDecoderException(e);, + } catch (UnsupportedCharsetException e) {, + throw new ErrorDataDecoderException(e);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, +import java.nio.charset.UnsupportedCharsetException;, + } catch (UnsupportedCharsetException e) {, + throw new ErrorDataDecoderException(e);, + } catch (UnsupportedCharsetException e) {, + throw new ErrorDataDecoderException(e);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java, +import java.nio.charset.UnsupportedCharsetException;, +import static org.junit.Assert.fail;, +, + @Test, + public void testMultipartRequestWithFileInvalidCharset() throws Exception {, + final String boundary = "dLV9Wyq26L_-JQxk6ferf-RT153LhOO";, + final DefaultFullHttpRequest req = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST,, + "http://localhost");, + req.headers().add(HttpHeaderNames.CONTENT_TYPE, "multipart/form-data; boundary=" + boundary);, + // Force to use memory-based data., + final DefaultHttpDataFactory inMemoryFactory =
[+++ b/src/docbook/module/preface.xml, + This guide provides an introduction to <ulink url="&Home;">Netty</ulink>, + and what it is about., + Nowadays we use general purpose applications or libraries to communicate, + with each other. For example, we often use an open source HTTP client, + library to retrieve information from an open source web server and to, + invoke a remote procedure call via web services., + does not scale very well. It is like we don't use a general purpose, + 'Quick and easy' does not mean that a resulting application will suffer, + Some users might already have found
[+++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, + * Formats an event and returns the formatted message. This method is currently only used for formatting, + * {@link ChannelHandler#connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)}.]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, + ByteBuf buf = null;, + buf = ctx.alloc().buffer();, + if (buf != null && buf.writableBytes() >= contentLength && msg instanceof HttpContent) {, + // merge into other buffer for performance reasons, + buf.writeBytes(((HttpContent) msg).content());, + out.add(buf);, + } else {, + if (buf != null) {, + out.add(buf);, + }, + }, + } else {, + if (buf != null) {, + out.add(buf);, + }, + if (buf != null) {, + out.add(buf);, + }, + } else {, + if (buf != null) {, + out.add(buf);, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java, + if ("wss".equals(wsURL.getScheme())) {]
[+++ b/codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java, + assertEquals("Expected one object but got " + out.size(), 1, out.size());, + assertEquals("Expected one object but got " + out.size(), 1, out.size());, + assertEquals("Expected one object but got " + out.size(), 1, out.size());, + assertEquals("Expected one object but got " + out.size(), 1, out.size());, + assertEquals("Expected one object but got " + out.size(), 1, out.size());, + assertEquals("Expected one object but got " + out.size(), 1, out.size());, + assertEquals("Expected one object but got " + out.size(), 1, out.size());, + assertEquals("Expected one object but got " + out.size(), 1, out.size());, + assertEquals("Expected one object but got " + out.size(),
[+++ b/transport/src/main/java/io/netty/channel/oio/AbstractOioMessageChannel.java, + int totalRead = 0;, + // Perform a read., + // Notify with the received messages and clear the buffer., + int size = readBuf.size();, + for (int i = 0; i < size; i ++) {, + pipeline.fireChannelRead(readBuf.get(i));, + }, + readBuf.clear();, +, + // Do not read beyond maxMessagesPerRead., + // Do not continue reading if autoRead has been turned off., + totalRead += localRead;, + if (totalRead >= maxMessagesPerRead || !config.isAutoRead()) {]
[+++ b/pom.xml, + <outputDirectory>${basedir}/src/target/classes/META-INF</outputDirectory>]
[+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageHeader.java, + * @see BinaryMemcacheOpcodes for typesafe opcodes., +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessageHeader.java, + * @see BinaryMemcacheOpcodes for typesafe opcodes., +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheOpcodes.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License
[+++ b/transport-sctp/pom.xml, + <plugin>, + <artifactId>maven-jar-plugin</artifactId>, + <configuration>, + <excludes>, + <!-- Exclude the com.sun.nio stuff as this is included in the jdk if its supported by the running os -->, + <exclude>**/com/**</exclude>, + </excludes>, + , + </configuration>, + </plugin>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyConstants.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyConstants.java, +++ b/example/src/main/java/io/netty/example/objectecho/ObjectEchoClientHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyConstants.java, +++ b/example/src/main/java/io/netty/example/objectecho/ObjectEchoClientHandler.java, +++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxyBackendHandler.java]
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, + * {@code true} if ipv4 should be used on a system that supports ipv4 and ipv6., + */, + private static final boolean IPV4_PREFERRED = Boolean.getBoolean("java.net.preferIPv4Stack");, +, + /**, + * Returns {@code true} if ipv4 should be prefered on a system that supports ipv4 and ipv6., + */, + public static boolean isIpV4StackPreferred() {, + return IPV4_PREFERRED;, + }, +, + /**, +++ b/common/src/main/java/io/netty/util/NetUtil.java, + * {@code true} if ipv4 should be used on a system that supports ipv4 and ipv6., + */, + private static final boolean IPV4_PREFERRED = Boolean.getBoolean("java.net.preferIPv4Stack");, +, + /**, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, + Certificate[] localCerts = ReferenceCountedOpenSslEngine.this.localCertificateChain;, + Certificate[] local = ReferenceCountedOpenSslEngine.this.localCertificateChain;, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, + Certificate[] localCerts = ReferenceCountedOpenSslEngine.this.localCertificateChain;, + Certificate[] local = ReferenceCountedOpenSslEngine.this.localCertificateChain;, +++ b/handler/src/test/java/io/netty/handler/ssl/ConscryptJdkSslEngineInteropTest.java, +, + @Ignore("Ignore due bug in Conscrypt"), + @Override, + public void testHandshakeSession() throws Exception {, + // Ignore as Conscrypt does not correctly return the local certificates while the TrustManager is invoked., + // See https://github.com/google/conscrypt/issues/634, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, + Certificate[] localCerts = ReferenceCountedOpenSslEngine.this.localCertificateChain;, + Certificate[] local = ReferenceCountedOpenSslEngine.this.localCertificateChain;, +++ b/handler/src/test/java/io/netty/handler/ssl/ConscryptJdkSslEngineInteropTest.java, +, + @Ignore("Ignore due bug in Conscrypt"), + @Override, + public void testHandshakeSession() throws Exception {, + // Ignore as
[+++ b/all/.gitignore, +src, +++ b/all/.gitignore, +src, +++ b/all/pom.xml, + <id>clean-src</id>, + <phase>clean</phase>, + <goals>, + <goal>clean</goal>, + </goals>, + <configuration>, + <filesets>, + <fileset>, + <directory>${project.basedir}/src</directory>, + <followSymlinks>false</followSymlinks>, + <useDefaultExcludes>false</useDefaultExcludes>, + </fileset>, + <fileset>, + <directory>${project.basedir}/target</directory>, + <followSymlinks>false</followSymlinks>, + </fileset>, + </filesets>, + </configuration>, + </execution>, + <execution>, + <id>clean-all</id>, + <configuration>, + <filesets>, + <fileset>, + <directory>${project.basedir}/src</directory>, + <followSymlinks>false</followSymlinks>, + <useDefaultExcludes>false</useDefaultExcludes>, + </fileset>, + <fileset>, + <directory>${project.basedir}/target</directory>, + <followSymlinks>false</followSymlinks>, + </fileset>, + </filesets>, + </configuration>, + <includeGroupIds>io.netty</includeGroupIds>, + <outputDirectory>${project.basedir}/src/main/java</outputDirectory>, + <overWriteReleases>false</overWriteReleases>, + <overWriteSnapshots>true</overWriteSnapshots>, + <overWriteReleases>false</overWriteReleases>, + <overWriteSnapshots>true</overWriteSnapshots>, + <artifactId>maven-jxr-plugin</artifactId>, + <version>2.2</version>, + <id>generate-xref</id>, + <phase>package</phase>, + <goal>jxr</goal>, +
[+++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, + * @see {@link #localAddress(SocketAddress)}, + * @see {@link #localAddress(SocketAddress)}, + * @see {@link #localAddress(SocketAddress)}, + @Override, + @Override, +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, + * @see {@link #localAddress(SocketAddress)}, + * @see {@link #localAddress(SocketAddress)}, + * @see {@link #localAddress(SocketAddress)}, + @Override, + @Override, +++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, + * @see {@link #remoteAddress(SocketAddress)}, + * @see {@link #remoteAddress(SocketAddress)}, + * @see {@link #connect()}, + *, + * Be aware that if you call {@link #shutdown()} on one of them it will shutdown shared resources., +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, + * @see {@link #localAddress(SocketAddress)}, + * @see {@link #localAddress(SocketAddress)}, + * @see {@link #localAddress(SocketAddress)}, + @Override,
[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, + if (logger.isErrorEnabled()) {, + }, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, + if (logger.isErrorEnabled()) {, + }, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, + if (logger.isWarnEnabled()) {, + }, + if (logger.isWarnEnabled()) {, + }, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, + if (logger.isErrorEnabled()) {, + }, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, + if (logger.isWarnEnabled()) {, + }, + if (logger.isWarnEnabled()) {, + }, +++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, + if (logger.isErrorEnabled()) {, + SingleThreadEventExecutor.class.getSimpleName() + ".confirmShutdown() must " +, + "be called before run() implementation terminates.");, + }, + if (logger.isWarnEnabled()) {, + logger.warn("An event executor terminated with " +, + }, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, + if (logger.isErrorEnabled()) {, + }, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, +
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelConfig.java, +import io.netty.channel.WriteBufferWaterMark;, + @Deprecated, + @Deprecated, + public EpollChannelConfig setWriteBufferWaterMark(WriteBufferWaterMark writeBufferWaterMark) {, + super.setWriteBufferWaterMark(writeBufferWaterMark);, + return this;, + }, +, + @Override, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelConfig.java, +import io.netty.channel.WriteBufferWaterMark;, + @Deprecated, + @Deprecated, + public EpollChannelConfig setWriteBufferWaterMark(WriteBufferWaterMark writeBufferWaterMark) {, + super.setWriteBufferWaterMark(writeBufferWaterMark);, + return this;, + }, +, + @Override, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannelConfig.java, +import io.netty.channel.WriteBufferWaterMark;, + @Deprecated, + @Deprecated, + public EpollDatagramChannelConfig setWriteBufferWaterMark(WriteBufferWaterMark writeBufferWaterMark) {, + super.setWriteBufferWaterMark(writeBufferWaterMark);, + return this;, + }, +, + @Override, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelConfig.java, +import io.netty.channel.WriteBufferWaterMark;, + @Deprecated, + @Deprecated, + public EpollChannelConfig setWriteBufferWaterMark(WriteBufferWaterMark writeBufferWaterMark) {, + super.setWriteBufferWaterMark(writeBufferWaterMark);, + return this;, + }, +, + @Override, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannelConfig.java, +import
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java, +import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;, +import static io.netty.handler.codec.http2.Http2Exception.connectionError;, +import static io.netty.handler.codec.http2.Http2Headers.PseudoHeaderName.hasPseudoHeaderFormat;, +import static io.netty.util.AsciiString.CASE_INSENSITIVE_HASHER;, +import static io.netty.util.AsciiString.CASE_SENSITIVE_HASHER;, +import static io.netty.util.AsciiString.isUpperCase;, + public boolean process(byte value) {, + if (hasPseudoHeaderFormat(key)) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java, +import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;, +import static io.netty.handler.codec.http2.Http2Exception.connectionError;, +import static io.netty.handler.codec.http2.Http2Headers.PseudoHeaderName.hasPseudoHeaderFormat;, +import static io.netty.util.AsciiString.CASE_INSENSITIVE_HASHER;, +import static io.netty.util.AsciiString.CASE_SENSITIVE_HASHER;, +import static io.netty.util.AsciiString.isUpperCase;, + public boolean process(byte value) {, + if (hasPseudoHeaderFormat(key)) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java, + hpackDecoder.decode(streamId, headerBlock, headers, validateHeaders);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java, +import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;, +import static io.netty.handler.codec.http2.Http2Exception.connectionError;, +import static io.netty.handler.codec.http2.Http2Headers.PseudoHeaderName.hasPseudoHeaderFormat;, +import static io.netty.util.AsciiString.CASE_INSENSITIVE_HASHER;, +import static io.netty.util.AsciiString.CASE_SENSITIVE_HASHER;, +import static io.netty.util.AsciiString.isUpperCase;, + public boolean process(byte value) {, + if (hasPseudoHeaderFormat(key)) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java,
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + byteBuf.readBytes(data, dataLen);, + while (out.writable()) {, + ByteBuf data = exchangeBuf.peek();, + if (out.writerIndex() > out.maxCapacity() - data.readableBytes()) {, + // The target buffer is not going to be able to accept all data in the bridge., + out.ensureWritableBytes(out.maxCapacity() - out.writerIndex());, + out.writeBytes(data, out.writableBytes());, + } else {, + exchangeBuf.remove();, + }]
[+++ b/all/pom.xml, + <version>4.1.32.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.32.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.32.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.32.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.32.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, + <version>4.1.32.Final-SNAPSHOT</version>, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, + } catch (NumberFormatException ignored) {, + if (!loadDataMultipart(undecodedChunk, multipartDataBoundary, currentAttribute)) {, + // Delimiter is not found. Need more chunks., + if (!loadDataMultipart(undecodedChunk, delimiter, currentFileUpload)) {, + // Delimiter is not found. Need more chunks., + * Load the field value or file data from a Multipart request, + * @return {@code true} if the last chunk is loaded (boundary delimiter found), {@code false} if need more chunks, + private static boolean loadDataMultipartStandard(ByteBuf undecodedChunk, String delimiter, HttpData httpData) {, + final int startReaderIndex = undecodedChunk.readerIndex();, + final int delimeterLength = delimiter.length();, + int lastPosition = startReaderIndex;,
[+++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +, + protected boolean isPreferDirect() {, + return preferDirect;, + }, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +, + protected boolean isPreferDirect() {, + return preferDirect;, + }, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Lz4FrameEncoder.java, +import io.netty.handler.codec.EncoderException;, +import io.netty.util.internal.ObjectUtil;, + static final int DEFAULT_MAX_ENCODE_SIZE = Integer.MAX_VALUE;, +, + private ByteBufChecksum checksum;, + * Compression level of current LZ4 encoder (depends on {@link #blockSize})., + * Inner byte buffer for outgoing data. It's capacity will be {@link #blockSize}., + * Maximum size for any buffer to write encoded (compressed) data into., + private final int maxEncodeSize;, + this(factory, highCompressor, blockSize, checksum, DEFAULT_MAX_ENCODE_SIZE);, + }, +, + /**,
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpHeadersTest.java, + @Test, + public void testSetSelfIsNoOp() {, + headers.add("name", "value");, + assertEquals(1, headers.size());, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpHeadersTest.java, + @Test, + public void testSetSelfIsNoOp() {, + headers.add("name", "value");, + assertEquals(1, headers.size());, +++ b/codec/src/main/java/io/netty/handler/codec/DefaultHeaders.java, + return thisT();, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpHeadersTest.java, + @Test, + public void testSetSelfIsNoOp() {, + headers.add("name", "value");, + assertEquals(1, headers.size());, +++ b/codec/src/main/java/io/netty/handler/codec/DefaultHeaders.java, + return thisT();, +++ b/codec/src/test/java/io/netty/handler/codec/DefaultHeadersTest.java, + @Test, + public void testSetSelfIsNoOp() {, + headers.add("name", "value");, + assertEquals(1, headers.size());]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java, + private final ByteBufChecksum crc;, + crc = ByteBufChecksum.wrapChecksum(new CRC32());, + crc.update(in, in.readerIndex(), 4);, + in.skipBytes(4);, + crc.update(in, in.readerIndex(), xlen);, + in.skipBytes(xlen);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseStatus.java, +import io.netty.handler.codec.AsciiString;, + public static final HttpResponseStatus CONTINUE = httpResponseStatus(100, "Continue");, + public static final HttpResponseStatus SWITCHING_PROTOCOLS = httpResponseStatus(101, "Switching Protocols");, + public static final HttpResponseStatus PROCESSING = httpResponseStatus(102, "Processing");, + public static final HttpResponseStatus OK = httpResponseStatus(200, "OK");, + public static final HttpResponseStatus CREATED = httpResponseStatus(201, "Created");, + public static final HttpResponseStatus ACCEPTED = httpResponseStatus(202, "Accepted");, + httpResponseStatus(203, "Non-Authoritative Information");, + public static final HttpResponseStatus NO_CONTENT = httpResponseStatus(204, "No Content");, + public static final HttpResponseStatus RESET_CONTENT = httpResponseStatus(205, "Reset Content");, + public static final HttpResponseStatus PARTIAL_CONTENT = httpResponseStatus(206, "Partial Content");, + public static final HttpResponseStatus MULTI_STATUS
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2Decoder.java, +, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2Decoder.java, +, +++ b/codec/src/main/java/io/netty/handler/codec/compression/FastLzFrameDecoder.java, +import io.netty.util.internal.EmptyArrays;, + break;, + break;, + break;, + final ByteBuf uncompressed;, + final byte[] output;, + final int outputPtr;, +, + if (originalLength != 0) {, + uncompressed = ctx.alloc().heapBuffer(originalLength, originalLength);, + output = uncompressed.array();, + outputPtr = uncompressed.arrayOffset() + uncompressed.writerIndex();, + } else {, + uncompressed = null;, + output = EmptyArrays.EMPTY_BYTES;, + outputPtr = 0;, + }, +, + if (uncompressed != null) {, + }, + break;, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2Decoder.java, +, +++ b/codec/src/main/java/io/netty/handler/codec/compression/FastLzFrameDecoder.java, +import io.netty.util.internal.EmptyArrays;, + break;, + break;, + break;, + final ByteBuf uncompressed;, + final byte[]
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java]
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, + , + , + // Check if we exceeded the maximum size of 2gb if this is the case then , + // newCapacity == 0, + //, + // https://github.com/netty/netty/issues/258, + if (newCapacity == 0) {, + throw new IllegalStateException("Maximum size of 2gb exceeded");, + }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return
[+++ b/all/pom.xml, + <classifier>${epoll.classifier}</classifier>, +++ b/all/pom.xml, + <classifier>${epoll.classifier}</classifier>, +++ b/example/pom.xml, + <classifier>${tcnative.classifier}</classifier>, +++ b/all/pom.xml, + <classifier>${epoll.classifier}</classifier>, +++ b/example/pom.xml, + <classifier>${tcnative.classifier}</classifier>, +++ b/handler/pom.xml, + <classifier>${tcnative.classifier}</classifier>, +++ b/all/pom.xml, + <classifier>${epoll.classifier}</classifier>, +++ b/example/pom.xml, + <classifier>${tcnative.classifier}</classifier>, +++ b/handler/pom.xml, + <classifier>${tcnative.classifier}</classifier>, +++ b/microbench/pom.xml, + <classifier>${epoll.classifier}</classifier>, +++ b/all/pom.xml, + <classifier>${epoll.classifier}</classifier>, +++ b/example/pom.xml, + <classifier>${tcnative.classifier}</classifier>, +++ b/handler/pom.xml, + <classifier>${tcnative.classifier}</classifier>, +++ b/microbench/pom.xml, + <classifier>${epoll.classifier}</classifier>, +++ b/pom.xml, + <regex>^linux-x86_64(\\-fedora)?$</regex>, + <!-- Configure the os-maven-plugin extension to expand the classifier on -->, + <!-- Fedora-"like" systems. This is currently only used for the netty-tcnative dependency -->, + <os.detection.classifierWithLikes>fedora</os.detection.classifierWithLikes>, + <tcnative.classifier>${os.detected.classifier}</tcnative.classifier>, + <epoll.classifier>${os.detected.name}-${os.detected.arch}</epoll.classifier>, + <version>1.1.33.Fork7</version>, + <classifier>${tcnative.classifier}</classifier>, + <version>1.4.0.Final</version>, +++
[+++ b/common/src/main/java/io/netty/util/internal/logging/Log4J2Logger.java, +import java.security.AccessController;, +import java.security.PrivilegedAction;, +, + private static final boolean VARARGS_ONLY;, +, + static {, + // Older Log4J2 versions have only log methods that takes the format + varargs. So we should not use, + // Log4J2 if the version is too old., + // See https://github.com/netty/netty/issues/8217, + VARARGS_ONLY = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {, + @Override, + public Boolean run() {, + try {, + Logger.class.getMethod("debug", String.class, Object.class);, + return false;, + } catch (NoSuchMethodException ignore) {, + // Log4J2 version too old., + return true;, + } catch (SecurityException ignore) {, + // We could not
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java, +import io.netty.channel.unix.Socket;, + Socket.initialize();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java, +import io.netty.channel.unix.Socket;, + Socket.initialize();, +++ b/transport-native-kqueue/src/main/java/io/netty/channel/kqueue/Native.java, +import io.netty.channel.unix.Socket;, + Socket.initialize();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java, +import io.netty.channel.unix.Socket;, + Socket.initialize();, +++ b/transport-native-kqueue/src/main/java/io/netty/channel/kqueue/Native.java, +import io.netty.channel.unix.Socket;, + Socket.initialize();, +++ b/transport-native-unix-common/src/main/c/netty_unix_socket.c, +static int socketType = AF_INET;, +static void netty_unix_socket_initialize(JNIEnv* env, jclass clazz, jboolean ipv4Preferred) {, + socketType = AF_INET;, + } else {, + socketType = errno == EAFNOSUPPORT ? AF_INET : AF_INET6;, + socketType = res == 0 ? AF_INET6 : AF_INET;, + }, +, +, + { "getSoError", "(I)I", (void *) netty_unix_socket_getSoError },, + { "initialize", "(Z)V", (void *) netty_unix_socket_initialize }, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java, +import io.netty.channel.unix.Socket;, +
[+++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadClient.java, +import java.util.logging.Level;, +import java.util.logging.Logger;, + private static final Logger logger = Logger.getLogger(HttpUploadClient.class.getName());, + logger.log(Level.WARNING, "Invalid URI syntax", e);, + logger.log(Level.WARNING, "Only HTTP(S) is supported.");, + logger.log(Level.WARNING, "Error: ", e);, + logger.log(Level.WARNING, "A correct path is needed");, + logger.log(Level.WARNING, "Error: ", e);, +++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadClient.java, +import java.util.logging.Level;, +import java.util.logging.Logger;, + private static final Logger logger = Logger.getLogger(HttpUploadClient.class.getName());, + logger.log(Level.WARNING, "Invalid URI syntax", e);, + logger.log(Level.WARNING, "Only HTTP(S) is supported.");, + logger.log(Level.WARNING, "Error: ", e);, + logger.log(Level.WARNING, "A correct path is needed");, + logger.log(Level.WARNING, "Error: ", e);, +++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadClientHandler.java, +, +import java.util.logging.Logger;, + private static final Logger logger = Logger.getLogger(HttpUploadClientHandler.class.getName());,
[+++ b/all/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.7.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +import java.util.concurrent.RejectedExecutionException;, +import java.util.concurrent.atomic.AtomicLong;, + private final AtomicLong pendingTimeouts = new AtomicLong(0);, + private final long maxPendingTimeouts;, + * @param leakDetection {@code true} if leak detection should be enabled always,, + * if false it will only be enabled if the worker thread is not, + * a daemon thread., + this(threadFactory, tickDuration, unit, ticksPerWheel, leakDetection, -1);, + }, +, + /**, + * Creates a new timer., + *, + * @param threadFactory a {@link ThreadFactory} that creates a, + * background {@link Thread} which is dedicated to, + * {@link TimerTask} execution., + * @param
[+++ b/common/src/main/java/io/netty/util/AsciiString.java, + final int len = offset + length - subCount;, + for (int i = offset + length - subCount; i >= end; --i) {, +++ b/common/src/main/java/io/netty/util/AsciiString.java, + final int len = offset + length - subCount;, + for (int i = offset + length - subCount; i >= end; --i) {, +++ b/common/src/test/java/io/netty/util/AsciiStringCharacterTest.java, + assertEquals(string, ascii.toString());, + assertEquals(3, new AsciiString("012345").indexOf("345", 3));, + assertEquals(3, new AsciiString("012345").indexOf("345", 0));, + assertEquals(-1, new AsciiString("012345").indexOf("345", 4));, + assertEquals(-1, new AsciiString("012345").indexOf("abc", 3));, + assertEquals(-1, new AsciiString("012345").indexOf("abc", 0));, + assertEquals(-1, new AsciiString("012345").indexOf("abcdefghi", 0));, + assertEquals(-1, new AsciiString("012345").indexOf("abcdefghi", 4));, + assertEquals(3, new AsciiString("012345").lastIndexOf("345", 3));,
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, + final String tlsPrefixedCipherName = "TLS_" + supportedCipher.substring("SSL_".length());, + try {, + engine.setEnabledCipherSuites(new String[]{tlsPrefixedCipherName});, + SUPPORTED_CIPHERS.add(tlsPrefixedCipherName);, + } catch (IllegalArgumentException ignored) {, + // The cipher is not supported ... move on to the next cipher., + }, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, + final String tlsPrefixedCipherName = "TLS_" + supportedCipher.substring("SSL_".length());, + try {, + engine.setEnabledCipherSuites(new String[]{tlsPrefixedCipherName});, + SUPPORTED_CIPHERS.add(tlsPrefixedCipherName);, + } catch (IllegalArgumentException ignored) {, + // The cipher is not supported ... move on to the next cipher., + }, +++ b/handler/src/test/java/io/netty/handler/ssl/SslContextTest.java, +import java.security.KeyManagementException;, +import java.security.NoSuchAlgorithmException;, +import javax.net.ssl.SSLContext;, +import javax.net.ssl.SSLEngine;, +import javax.net.ssl.SSLException;, +, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assume.assumeNotNull;,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DefaultHttpDataFactory.java, +import io.netty.handler.codec.http.HttpRequest;, +, + public static final long MINSIZE = 0x4000;]
[+++ b/all/pom.xml, + <version>4.0.6.Final</version>, +++ b/all/pom.xml, + <version>4.0.6.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.6.Final</version>, +++ b/all/pom.xml, + <version>4.0.6.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.6.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.6.Final</version>, +++ b/all/pom.xml, + <version>4.0.6.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.6.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.6.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.6.Final</version>, +++ b/all/pom.xml, + <version>4.0.6.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.6.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.6.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.6.Final</version>, +++ b/codec/pom.xml, + <version>4.0.6.Final</version>, +++ b/all/pom.xml, + <version>4.0.6.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.6.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.6.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.6.Final</version>, +++ b/codec/pom.xml, + <version>4.0.6.Final</version>, +++ b/common/pom.xml, + <version>4.0.6.Final</version>, +++ b/all/pom.xml, + <version>4.0.6.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.6.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.6.Final</version>, +++ b/codec-socks/pom.xml, +
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + boolean removed;, + if (!removed && handler instanceof ChannelInboundByteHandler && !isInboundBufferFreed()) {, + if (!removed && handler instanceof ChannelOutboundByteHandler && !isOutboundBufferFreed()) {, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + boolean removed;, + if (!removed && handler instanceof ChannelInboundByteHandler && !isInboundBufferFreed()) {, + if (!removed && handler instanceof ChannelOutboundByteHandler && !isOutboundBufferFreed()) {, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, + private void callAfterRemove(final DefaultChannelHandlerContext ctx) {, + ctx.removed = true;]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java, +import com.jcraft.jzlib.Inflater;, +import com.jcraft.jzlib.JZlib;, + if (finished) {, + // Skip data received after finished., + in.skipBytes(in.readableBytes());, + return;, + }, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java, +import com.jcraft.jzlib.Inflater;, +import com.jcraft.jzlib.JZlib;, + if (finished) {, + // Skip data received after finished., + in.skipBytes(in.readableBytes());, + return;, + }, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java, + private final int wrapperOverhead;, +, + wrapperOverhead = ZlibUtil.wrapperOverhead(wrapper);, +, + wrapperOverhead = ZlibUtil.wrapperOverhead(ZlibWrapper.ZLIB);, + int maxOutputLength = (int) Math.ceil(inputLength * 1.001) + 12 + wrapperOverhead;, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java, +import com.jcraft.jzlib.Inflater;, +import com.jcraft.jzlib.JZlib;, + if (finished) {, + // Skip data received after finished., + in.skipBytes(in.readableBytes());, + return;, + }, +++
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpRequestDecoderTest.java, +import io.netty.util.AsciiString;, +import static io.netty.handler.codec.http.HttpHeaderNames.*;, +, + @Test, + public void testMessagesSplitBetweenMultipleBuffers() {, + EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder());, + String crlf = "\r\n";, + String str1 = "GET /some/path HTTP/1.1" + crlf +, + "Host: localhost1" + crlf + crlf +, + "GET /some/other/path HTTP/1.0" + crlf +, + "Hos";, + String str2 = "t: localhost2" + crlf +, + "content-length: 0" + crlf + crlf;, + channel.writeInbound(Unpooled.copiedBuffer(str1, CharsetUtil.US_ASCII));, + HttpRequest req = channel.readInbound();, + assertEquals(HttpVersion.HTTP_1_1, req.protocolVersion());, + assertEquals("/some/path", req.uri());, + assertEquals(1, req.headers().size());, + assertTrue(AsciiString.contentEqualsIgnoreCase("localhost1", req.headers().get(HOST)));, + LastHttpContent cnt = channel.readInbound();, + cnt.release();, +, +
[+++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, + * If {@code true} then the {@link Channel} is closed automatically and immediately on write failure., + * The default value is {@code true}.]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + if (refCnt == 0 || refCnt == Integer.MAX_VALUE) {, + throw new IllegalReferenceCountException(refCnt, 1);, + final int nextCnt;, + if (refCnt == 0 || (nextCnt = refCnt + increment) < 0) {, + if (refCntUpdater.compareAndSet(this, refCnt, nextCnt)) {]
[+++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, + if (e.getMessage().contains("unsupported protocol") ||, + e.getMessage().contains("no protocols available")) {]
[+++ b/all/pom.xml, + <version>4.1.29.Final</version>, +++ b/all/pom.xml, + <version>4.1.29.Final</version>, +++ b/bom/pom.xml, + <version>4.1.29.Final</version>, + <tag>netty-4.1.29.Final</tag>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, +++ b/all/pom.xml, + <version>4.1.29.Final</version>, +++ b/bom/pom.xml, + <version>4.1.29.Final</version>, + <tag>netty-4.1.29.Final</tag>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, + <version>4.1.29.Final</version>, +
[+++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageDecoder.java, + private void fail(final ChannelHandlerContext ctx, String errMsg, Exception e) {, + if (errMsg != null && e != null) {, + ppex = new HAProxyProtocolException(errMsg, e);, + } else if (e != null) {, + ppex = new HAProxyProtocolException(e);, +++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageDecoder.java, + private void fail(final ChannelHandlerContext ctx, String errMsg, Exception e) {, + if (errMsg != null && e != null) {, + ppex = new HAProxyProtocolException(errMsg, e);, + } else if (e != null) {, + ppex = new HAProxyProtocolException(e);, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v4/Socks4ClientDecoder.java, + private void fail(List<Object> out, Exception cause) {, +++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageDecoder.java, + private void
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + * Returns a <a href="http://en.wikipedia.org/wiki/Hex_dump">hex dump</a>, + * of the specified byte array., + */, + public static String hexDump(byte[] array) {, + return hexDump(array, 0, array.length);, + }, +, + /**, + * Returns a <a href="http://en.wikipedia.org/wiki/Hex_dump">hex dump</a>, + * of the specified byte array's sub-region., + */, + public static String hexDump(byte[] array, int fromIndex, int length) {, + if (length < 0) {, + throw new IllegalArgumentException("length: " + length);, + }, + if (length == 0) {, + return "";, + }, +, + int endIndex = fromIndex + length;, + char[]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + protected final PropertyKey streamKey;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + protected final PropertyKey streamKey;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.HTTP_UPGRADE_STREAM_ID;, +import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;, +import static io.netty.handler.codec.http2.Http2Exception.connectionError;, +, + private final ChannelHandler upgradeStreamHandler;, + ChannelHandler inboundStreamHandler,, + ChannelHandler upgradeStreamHandler) {, + this.upgradeStreamHandler = upgradeStreamHandler;, + }, +, + @Override, + public void onHttpClientUpgrade() throws Http2Exception {, + // We must have an upgrade handler or else we can't handle the stream, + if (upgradeStreamHandler == null) {, + throw connectionError(INTERNAL_ERROR, "Client is misconfigured for upgrade requests");, + }, + // Creates the Http2Stream in the Connection., + super.onHttpClientUpgrade();, + // Now
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + if (message == null) {, + message.setDecoderResult(DecoderResult.failure(cause));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + if (message == null) {, + message.setDecoderResult(DecoderResult.failure(cause));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, + @SuppressWarnings("rawtypes"), + if (!isMultipart) {, + iterator = multipartHttpDatas.listIterator();, +, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + if (message == null) {, + message.setDecoderResult(DecoderResult.failure(cause));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, + @SuppressWarnings("rawtypes"), + if (!isMultipart) {, + iterator = multipartHttpDatas.listIterator();, +, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostStandardRequestDecoder.java, + } else if (contRead && currentAttribute != null && currentStatus == MultiPartStatus.FIELD) {, + } else if (contRead && currentAttribute != null && currentStatus == MultiPartStatus.FIELD) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + if (message == null) {, +
[+++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java, +import io.netty.handler.codec.http.HttpChunkedInput;, + ctx.write(new HttpChunkedInput(new ChunkedFile(raf, 0, fileLength, 8192)),, + ctx.newProgressivePromise());]
[+++ b/codec/src/main/java/io/netty/handler/codec/marshalling/CompatibleMarshallingDecoder.java, + }]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + private static final String INVALID_CIPHER = "SSL_NULL_WITH_NULL_NULL";, +, + private volatile String cipher;, + if (!handshakeFinished) {, + return INVALID_CIPHER;, + }, + if (cipher == null) {, + String c = toJavaCipherSuite(SSL.getCipherForSSL(ssl));, + if (c != null) {, + cipher = c;, + }, + }, + applicationProtocol = SSL.getNextProtoNegotiated(ssl);, + if (applicationProtocol == null) {, + applicationProtocol = fallbackApplicationProtocol;, + }, + if (applicationProtocol != null) {, + OpenSslEngine.this.applicationProtocol = applicationProtocol.replace(':', '_');, + } else {, + OpenSslEngine.this.applicationProtocol = "";, + }, + }, + String version = SSL.getVersion(ssl);, + if (applicationProtocol.isEmpty()) {, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslPrivateKeyMethod.java, +/*, + * Copyright 2019 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/handler/src/main/java/io/netty/handler/ipfilter/IpFilterRule.java, + * @return This method should return {@link IpFilterRuleType#ACCEPT} if all, + * {@link IpFilterRuleType#REJECT} should be returned., +++ b/handler/src/main/java/io/netty/handler/ipfilter/IpFilterRule.java, + * @return This method should return {@link IpFilterRuleType#ACCEPT} if all, + * {@link IpFilterRuleType#REJECT} should be returned., +++ b/handler/src/main/java/io/netty/handler/ipfilter/IpFilterRuleType.java, + ACCEPT,, + REJECT, +++ b/handler/src/main/java/io/netty/handler/ipfilter/IpFilterRule.java, + * @return This method should return {@link IpFilterRuleType#ACCEPT} if all, + * {@link IpFilterRuleType#REJECT} should be returned., +++ b/handler/src/main/java/io/netty/handler/ipfilter/IpFilterRuleType.java, + ACCEPT,, + REJECT, +++ b/handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java, + return rule.ruleType() == IpFilterRuleType.ACCEPT;, +++ b/handler/src/main/java/io/netty/handler/ipfilter/IpFilterRule.java, + * @return This method should return {@link IpFilterRuleType#ACCEPT} if all, + * {@link IpFilterRuleType#REJECT} should be returned.,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, + if (logger.isDebugEnabled()) {, + logger.debug(String.format("Requested subprotocol(s) not supported: %s.", subprotocols));, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, + if (logger.isDebugEnabled()) {, + logger.debug(String.format("Requested subprotocol(s) not supported: %s.", subprotocols));, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java, + if (logger.isDebugEnabled()) {, + logger.debug(String.format("Requested subprotocol(s) not supported: %s.", subprotocols));, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, + if (logger.isDebugEnabled()) {, + logger.debug(String.format("Requested subprotocol(s) not supported: %s.", subprotocols));, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java, + if (logger.isDebugEnabled()) {, + logger.debug(String.format("Requested subprotocol(s) not supported: %s.", subprotocols));, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java, + if (logger.isDebugEnabled()) {, + logger.debug(String.format("Requested subprotocol(s) not supported: %s.", subprotocols));, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, + if (logger.isDebugEnabled()) {, + logger.debug(String.format("Requested subprotocol(s)
[+++ b/.gitignore, +++ b/.gitignore, +++ b/all/pom.xml, + <generatedSourceDir>${project.build.directory}/src</generatedSourceDir>, + <dependencyVersionDir>${project.build.directory}/versions</dependencyVersionDir>, + <!-- Populate the properties whose key is groupId:artifactId:type, + and whose value is the path to the artifact -->, + <execution>, + <id>locate-dependencies</id>, + <phase>initialize</phase>, + <goals>, + <goal>properties</goal>, + </goals>, + </execution>, +, + <!-- Unpack all source files -->, + <outputDirectory>${generatedSourceDir}</outputDirectory>, +, + <!-- Unpack all class files -->, +, + <plugin>, + <artifactId>maven-antrun-plugin</artifactId>, + <executions>, + <!-- Instead of generating a new version property file, merge others' version property files into one. -->, + <execution>, + <id>write-version-properties</id>, + <phase>none</phase>, + </execution>, + <execution>, + <id>merge-version-properties</id>,
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslContext.java, + * p.addLast("ssl", {@link #newHandler(ByteBufAllocator) sslCtx.newHandler(channel.alloc())});, + * p.addLast("ssl", {@link #newHandler(ByteBufAllocator, String, int) sslCtx.newHandler(channel.alloc(), host, port)});, +++ b/handler/src/main/java/io/netty/handler/ssl/SslContext.java, + * p.addLast("ssl", {@link #newHandler(ByteBufAllocator) sslCtx.newHandler(channel.alloc())});, + * p.addLast("ssl", {@link #newHandler(ByteBufAllocator, String, int) sslCtx.newHandler(channel.alloc(), host, port)});, +++ b/handler/src/main/java/io/netty/handler/ssl/SslContextBuilder.java, + * @param keyInputStream an input stream for a PKCS#8 private key in PEM format]
[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java, + DefaultEventExecutor(DefaultEventExecutorGroup parent, ThreadFactory threadFactory) {, + super(parent, threadFactory);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java, + DefaultEventExecutor(DefaultEventExecutorGroup parent, ThreadFactory threadFactory) {, + super(parent, threadFactory);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorGroup.java, + ThreadFactory threadFactory, Object... args) throws Exception {, + return new DefaultEventExecutor(this, threadFactory);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java, + DefaultEventExecutor(DefaultEventExecutorGroup parent, ThreadFactory threadFactory) {, + super(parent, threadFactory);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorGroup.java, + ThreadFactory threadFactory, Object... args) throws Exception {, + return new DefaultEventExecutor(this, threadFactory);, +++ b/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java, + * @param args arguments which will passed to each {@link #newChild(ThreadFactory, Object...)} call, + children[i] = newChild(threadFactory, args);, + ThreadFactory threadFactory, Object... args) throws Exception;, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java, + DefaultEventExecutor(DefaultEventExecutorGroup parent, ThreadFactory threadFactory) {,
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return ByteBufUtil.decodeString(nioBuffer, charset);, + return ByteBufUtil.indexOf(this, fromIndex, toIndex, value);, + return ByteBufUtil.indexOf(this, fromIndex, toIndex, indexFinder);, + return ByteBufUtil.hashCode(this);, + return ByteBufUtil.equals(this, (ByteBuf) o);, + return ByteBufUtil.compare(this, that);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return ByteBufUtil.decodeString(nioBuffer, charset);, + return ByteBufUtil.indexOf(this, fromIndex, toIndex, value);, + return ByteBufUtil.indexOf(this, fromIndex, toIndex, indexFinder);, + return ByteBufUtil.hashCode(this);, + return ByteBufUtil.equals(this, (ByteBuf) o);, + return ByteBufUtil.compare(this, that);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except
[+++ b/handler/src/main/java/io/netty/handler/ssl/IdentityCipherSuiteFilter.java, + /**, + * Defaults to default ciphers when provided ciphers are null, + */, + public static final IdentityCipherSuiteFilter INSTANCE = new IdentityCipherSuiteFilter(true);, +, + /**, + * Defaults to supported ciphers when provided ciphers are null, + */, + public static final IdentityCipherSuiteFilter INSTANCE_DEFAULTING_TO_SUPPORTED_CIPHERS =, + new IdentityCipherSuiteFilter(false);, +, + private final boolean defaultToDefaultCiphers;, +, + private IdentityCipherSuiteFilter(boolean defaultToDefaultCiphers) {, + this.defaultToDefaultCiphers = defaultToDefaultCiphers;, + }, + return defaultToDefaultCiphers ?, + defaultCiphers.toArray(new String[defaultCiphers.size()]) :, + supportedCiphers.toArray(new String[supportedCiphers.size()]);, +++ b/handler/src/main/java/io/netty/handler/ssl/IdentityCipherSuiteFilter.java, + /**, + * Defaults to default ciphers when provided ciphers are null, + */, +
[+++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, + private static boolean isNpnSupported(String versionString) {, + String[] versionStringParts = versionString.split(" ", -1);, + if (versionStringParts.length == 2 && "LibreSSL".equals(versionStringParts[0])) {, + String[] versionParts = versionStringParts[1].split("\\.", -1);, + if (versionParts.length == 3) {, + int major = Integer.parseInt(versionParts[0]);, + if (major < 2) {, + return true;, + }, + if (major > 2) {, + return false;, + }, + int minor = Integer.parseInt(versionParts[1]);, + if (minor < 6) {, + return true;, + }, + if (minor > 6) {, + return false;, + }, + int bugfix = Integer.parseInt(versionParts[2]);, + if (bugfix >
[+++ b/transport-udt/src/main/java/io/netty/channel/udt/UdtMessage.java, + public UdtMessage duplicate() {, + return new UdtMessage(content().duplicate());, + }, +, + @Override]
[+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelOption.java, +import com.sun.nio.sctp.SctpStandardSocketOptions;, + public static final SctpChannelOption<SctpStandardSocketOptions.InitMaxStreams> SCTP_INIT_MAXSTREAMS =, + new SctpChannelOption<SctpStandardSocketOptions.InitMaxStreams>("SCTP_INIT_MAXSTREAMS");]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexCodecTest.java]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, + StringBuilder buf = new StringBuilder(estimateClientLength(cookie));, + int initialCapacity = 0;, + for (Cookie c: cookies) {, + if (c == null) {, + break;, + }, +, + initialCapacity += estimateClientLength(c);, + }, +, + StringBuilder buf = new StringBuilder(initialCapacity);, + int initialCapacity = 0;, + for (Cookie c: cookies) {, + if (c == null) {, + break;, + }, +, + initialCapacity += estimateClientLength(c);, + }, +, + StringBuilder buf = new StringBuilder(initialCapacity);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, + StringBuilder buf = new StringBuilder(estimateClientLength(cookie));, + int initialCapacity = 0;, + for (Cookie c: cookies) {, + if
[+++ b/pom.xml, + <repositories>, + <repository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </repository>, + </repositories>, +, + <pluginRepositories>, + <pluginRepository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </pluginRepository>, + </pluginRepositories>, +, + <groupId>org.jboss.maven.plugins</groupId>, + <artifactId>maven-jdocbook-plugin</artifactId>, + <version>2.2.1</version>, + <executions>, + <execution>, + <id>generate-docbook</id>, + <phase>package</phase>, + <goals>, + <goal>resources</goal>, + <goal>generate</goal>, + </goals>, + </execution>, + </executions>, + <dependencies>, + <dependency>, + <groupId>org.eclipse.wst.css</groupId>, + <artifactId>core</artifactId>, + <version>1.1.101-v200705302225</version>, + <exclusions>, + <exclusion>, + <groupId>org.apache</groupId>, + <artifactId>xerces</artifactId>, + </exclusion>, + <exclusion>, + <groupId>com.ibm</groupId>, + <artifactId>icu</artifactId>, + </exclusion>, + </exclusions>, + </dependency>, + <dependency>, + <groupId>org.eclipse.wst.sse</groupId>, + <artifactId>core</artifactId>, + <version>1.1.202-v200709061102</version>, + <exclusions>, + <exclusion>, +
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannelSink.java, +++ b/transport/src/main/java/io/netty/channel/AbstractChannelSink.java, +++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java, + * Schedules the specified task to be executed in the I/O thread associated, + * with this pipeline's {@link Channel}., + */, + ChannelFuture execute(Runnable task);, +, + /**, +++ b/transport/src/main/java/io/netty/channel/AbstractChannelSink.java, +++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java, + * Schedules the specified task to be executed in the I/O thread associated, + * with this pipeline's {@link Channel}., + */, + ChannelFuture execute(Runnable task);, +, + /**, +++ b/transport/src/main/java/io/netty/channel/ChannelSink.java, + * Execute the given {@link Runnable} later in the io-thread., + * Some implementation may not support this and just execute it directly., +++ b/transport/src/main/java/io/netty/channel/AbstractChannelSink.java, +++
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, + private final long maxFrameSize;, + /**, + * Creates a new instance of {@code WebSocketFrameDecoder} with the specified {@code maxFrameSize}. If the client, + * sends a frame size larger than {@code maxFrameSize}, the channel will be closed., + * , + * @param maxFrameSize, + * the maximum frame size to decode, + */, + public WebSocket00FrameDecoder(long maxFrameSize) {, + this.maxFrameSize = maxFrameSize;, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, + private final long maxFrameSize;, + /**, + * Creates a new instance of {@code WebSocketFrameDecoder} with the specified {@code maxFrameSize}. If the client, + * sends
[+++ b/example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java, + Channel ch = null;, + , + try {, + future.awaitUninterruptibly().rethrowIfFailed();, + ch = future.getChannel();, + handshaker.handshake(ch).awaitUninterruptibly().rethrowIfFailed();, + } finally {, + if (ch != null) {, + ch.close();, + }, + }, +++ b/example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java, + Channel ch = null;, + , + try {, + future.awaitUninterruptibly().rethrowIfFailed();, + ch = future.getChannel();, + handshaker.handshake(ch).awaitUninterruptibly().rethrowIfFailed();, + } finally {, + if (ch != null) {, + ch.close();, + }, + }, +++ b/transport/src/main/java/io/netty/channel/ChannelFuture.java, + * Rethrows the exception that caused this future fail if this future is, + * complete and failed., + */, + ChannelFuture rethrowIfFailed() throws
[+++ b/common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java, + * Copyright 2014 The Netty Project, + } catch (InterruptedException e) {, + // restore interrupt status because we don't know how to/don't need to handle it here, + Thread.currentThread().interrupt();, +++ b/common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java, + * Copyright 2014 The Netty Project, + } catch (InterruptedException e) {, + // restore interrupt status because we don't know how to/don't need to handle it here, + Thread.currentThread().interrupt();, +++ b/common/src/test/java/io/netty/util/internal/ThreadLocalRandomTest.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you
[+++ b/testsuite-osgi/src/test/java/io/netty/osgitests/OsgiBundleTest.java]
[+++ b/all/pom.xml, + !io.netty.*,, + !io.netty.*.internal.*, , + <Private-Package>, + io.netty.*.internal.*, + </Private-Package>, +++ b/all/pom.xml, + !io.netty.*,, + !io.netty.*.internal.*, , + <Private-Package>, + io.netty.*.internal.*, + </Private-Package>, +++ b/buffer/pom.xml, + <packaging>jar</packaging>, +++ b/all/pom.xml, + !io.netty.*,, + !io.netty.*.internal.*, , + <Private-Package>, + io.netty.*.internal.*, + </Private-Package>, +++ b/buffer/pom.xml, + <packaging>jar</packaging>, +++ b/codec-http/pom.xml, + <packaging>jar</packaging>, +++ b/all/pom.xml, + !io.netty.*,, + !io.netty.*.internal.*, , + <Private-Package>, + io.netty.*.internal.*, + </Private-Package>, +++ b/buffer/pom.xml, + <packaging>jar</packaging>, +++ b/codec-http/pom.xml, + <packaging>jar</packaging>, +++ b/codec/pom.xml, + <packaging>jar</packaging>, +++ b/all/pom.xml, + !io.netty.*,, + !io.netty.*.internal.*, , + <Private-Package>, + io.netty.*.internal.*, + </Private-Package>, +++ b/buffer/pom.xml, + <packaging>jar</packaging>, +++ b/codec-http/pom.xml, + <packaging>jar</packaging>, +++ b/codec/pom.xml,
[+++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, + @SuppressWarnings("unchecked"), + public final void channelRegistered(ChannelHandlerContext ctx) throws Exception {, + ChannelPipeline pipeline = ctx.pipeline();, + pipeline.remove(this);, + if (pipeline.context(this) != null) {, + pipeline.remove(this);]
[+++ b/pom.xml, +<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">, + <version>3.1.0.ALPHA3</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.1.0.ALPHA3</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.1.0.ALPHA3</developerConnection>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfig.java, + private final boolean shortCircuit;, + CorsConfig(final CorsConfigBuilder builder) {, + shortCircuit = builder.shortCircuit;, + public boolean isShortCircuit() {, + return shortCircuit;, + }, +, + /**, + * @deprecated Use {@link #isShortCircuit()} instead., + */, + @Deprecated, + return isShortCircuit();, + * @deprecated Use {@link CorsConfigBuilder#forAnyOrigin()} instead., + @Deprecated, + * @deprecated Use {@link CorsConfigBuilder#forOrigin(String)} instead., + @Deprecated, + * @deprecated Use {@link CorsConfigBuilder#forOrigins(String...)} instead., + @Deprecated, + * @deprecated Use {@link CorsConfigBuilder} instead., + @Deprecated, + private final CorsConfigBuilder builder;, + * @deprecated Use {@link CorsConfigBuilder} instead., + @Deprecated, + builder = new CorsConfigBuilder(origins);, +
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + readPending = false;, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + readPending = false;, +++ b/transport-native-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueStreamChannel.java, + readPending = false;, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + readPending = false;, +++ b/transport-native-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueStreamChannel.java, + readPending = false;, +++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java, + if (close) {, + // Based upon the Javadocs it is possible that NIO may have spurious wake ups [1]. In this, + // case we should be more cautious and only set readPending to false if data was actually, + // read., + // [1] https://docs.oracle.com/javase/7/docs/api/java/nio/channels/SelectionKey.html, + // That a selection key's ready set indicates that its channel is ready for some operation, + //
[+++ b/pom.xml, + , + <!-- RXTX - completely optional -->, + <!-- Used for serial port communication transport -->, + <dependency>, + <groupId>org.rxtx</groupId>, + <artifactId>rxtx</artifactId>, + <version>2.1.7</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, +++ b/pom.xml, + , + <!-- RXTX - completely optional -->, + <!-- Used for serial port communication transport -->, + <dependency>, + <groupId>org.rxtx</groupId>, + <artifactId>rxtx</artifactId>, + <version>2.1.7</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, +++ b/src/main/java/org/jboss/netty/channel/rxtx/RXTXChannel.java, +/*, + * Copyright 2011 Red Hat, Inc., + *, + * Red Hat licenses this file to you under the Apache License, version 2.0, + * (the "License");
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, +import io.netty.util.collection.IntObjectHashMap;, +import io.netty.util.collection.IntObjectMap;, + private final IntObjectMap<DefaultHttp2FrameStream> frameStreamToInitializeMap =, + new IntObjectHashMap<DefaultHttp2FrameStream>(8);, + // Use a Map to store all pending streams as we may have multiple. This is needed as if we would store the, + // stream in a field directly we may override the stored field before onStreamAdded(...) was called, + // and so not correctly set the property for the buffered stream., + //, + // See https://github.com/netty/netty/issues/8692, + Object old = frameStreamToInitializeMap.put(streamId, stream);, + // We should not re-use ids., + assert old == null;, +, + // TODO(buchgr): Once Http2FrameStream
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, +import io.netty.channel.ChannelFutureListener;, +import io.netty.channel.ChannelPipeline;, + future.addListener(new ChannelFutureListener() {, + @Override, + public void operationComplete(ChannelFuture future) {, + ChannelPipeline p = future.channel().pipeline();, + p.replace(HttpRequestEncoder.class, "ws-encoder", new WebSocket00FrameEncoder());, + }, + });, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, +import io.netty.channel.ChannelFutureListener;, +import io.netty.channel.ChannelPipeline;, + future.addListener(new ChannelFutureListener() {, + @Override, + public void operationComplete(ChannelFuture future) {, + ChannelPipeline p = future.channel().pipeline();, + p.replace(HttpRequestEncoder.class, "ws-encoder", new WebSocket00FrameEncoder());, + }, + });, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, +import io.netty.channel.ChannelFutureListener;, +import io.netty.channel.ChannelPipeline;, + future.addListener(new ChannelFutureListener() {, + @Override, + public void operationComplete(ChannelFuture future) {, + ChannelPipeline p = future.channel().pipeline();, + p.replace(HttpRequestEncoder.class, "ws-encoder", new WebSocket08FrameEncoder(true));, + }, + });, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, +import
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/example/src/main/java/io/netty/example/spdy/client/HttpResponseClientHandler.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *
[+++ b/NOTICE.txt, +, +This product optionally depends on 'Webbit', a Java event based , +WebSocket and HTTP server:, +, + * LICENSE:, + * license/LICENSE.webbit.txt (BSD License), + * HOMEPAGE:, + * https://github.com/joewalnes/webbit, +, + , +++ b/NOTICE.txt, +, +This product optionally depends on 'Webbit', a Java event based , +WebSocket and HTTP server:, +, + * LICENSE:, + * license/LICENSE.webbit.txt (BSD License), + * HOMEPAGE:, + * https://github.com/joewalnes/webbit, +, + , +++ b/src/docbook/en-US/module/architecture.xml, + to represent a sequence of bytes. This approach has significant advantage, + &ChannelBuffer; has been designed from ground up to address the problems, +
[+++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannel.java, +import io.netty.channel.socket.oio.OioByteStreamChannel;, +public class RxtxChannel extends OioByteStreamChannel {, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannel.java, +import io.netty.channel.socket.oio.OioByteStreamChannel;, +public class RxtxChannel extends OioByteStreamChannel {, +++ b/transport/src/main/java/io/netty/channel/socket/oio/OioByteStreamChannel.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under
[+++ b/all/pom.xml, + <id>full</id>, +++ b/all/pom.xml, + <id>full</id>, +++ b/pom.xml, + <id>full</id>, + <releaseProfiles>release,full</releaseProfiles>]
[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractFuture.java, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractFuture.java, +++ b/common/src/main/java/io/netty/util/concurrent/CompleteFuture.java, +, + @Override, + public boolean isCancellable() {, + return false;, + }, +, + @Override, + public boolean isCancelled() {, + return false;, + }, +, + @Override, + public boolean cancel(boolean mayInterruptIfRunning) {, + return false;, + }, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractFuture.java, +++ b/common/src/main/java/io/netty/util/concurrent/CompleteFuture.java, +, + @Override, + public boolean isCancellable() {, + return false;, + }, +, + @Override, + public boolean isCancelled() {, + return false;, + }, +, + @Override, + public boolean cancel(boolean mayInterruptIfRunning) {, + return false;, + }, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, +import java.util.concurrent.CancellationException;, + private static final Signal
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java, +import io.netty.buffer.ByteBufAllocator;, +import io.netty.util.ReferenceCountUtil;, + @Override, + public void channelInactive(ChannelHandlerContext ctx) throws Exception {, + // Release any outstanding messages from the map, + for (Map.Entry<Integer, FullHttpMessage> entry : messageMap.entrySet()) {, + ReferenceCountUtil.safeRelease(entry.getValue());, + }, + messageMap.clear();, + super.channelInactive(ctx);, + }, +, + FullHttpRequest httpRequestWithEntity = createHttpRequest(spdySynStreamFrame, ctx.alloc());, + } catch (Throwable ignored) {, + FullHttpRequest httpRequestWithEntity = createHttpRequest(spdySynStreamFrame, ctx.alloc());, + } catch (Throwable t) {, + FullHttpResponse httpResponseWithEntity =, + createHttpResponse(spdySynReplyFrame, ctx.alloc(), validateHeaders);, + } catch (Throwable t) {, + fullHttpMessage = createHttpResponse(spdyHeadersFrame, ctx.alloc(), validateHeaders);, + } catch (Throwable t) {, + private static FullHttpRequest createHttpRequest(SpdyHeadersFrame
[+++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +import org.junit.Test;, +import static org.junit.Assert.*;, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +import org.junit.Test;, +import static org.junit.Assert.*;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, + if (c.version() >= 1) {, + add(buf, c.name(), c.value());, + if (c.path() != null) {, + add(buf, '$' + CookieHeaderNames.PATH, c.path());, + if (c.domain() != null) {, + add(buf, '$' + CookieHeaderNames.DOMAIN, c.domain());, + if (c.version() >= 1) {, + if (!c.ports().isEmpty()) {, + for (int port: c.ports()) {, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +import org.junit.Test;, +import static org.junit.Assert.*;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, + if (c.version() >= 1) {, + add(buf, c.name(), c.value());, + if (c.path() != null) {, + add(buf, '$' + CookieHeaderNames.PATH, c.path());, + if
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, + *, + * @deprecated is part of {@link ChannelInboundHandler}, + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, + *, + * @deprecated is part of {@link ChannelInboundHandler}, + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/ChannelInboundHandler.java, + @SuppressWarnings("deprecated")]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpChunk.java, +, + @Override, + public String toString() {, + StringBuilder buf = new StringBuilder();, + buf.append(getClass().getSimpleName());, +, + final boolean last = isLast();, + buf.append("(last: ");, + buf.append(last);, + if (!last) {, + buf.append(", size: ");, + buf.append(getContent().readableBytes());, + }, +, + buf.append(", decodeResult: ");, + buf.append(getDecodeResult());, + buf.append(')');, +, + return buf.toString();, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpChunk.java, +, + @Override, + public String toString() {, + StringBuilder buf = new StringBuilder();, + buf.append(getClass().getSimpleName());, +, + final boolean last = isLast();, + buf.append("(last: ");, + buf.append(last);, + if (!last) {, + buf.append(", size: ");, + buf.append(getContent().readableBytes());, + },
[+++ b/all/pom.xml, + <version>4.1.21.Final</version>, +++ b/all/pom.xml, + <version>4.1.21.Final</version>, +++ b/bom/pom.xml, + <version>4.1.21.Final</version>, + <tag>netty-4.1.21.Final</tag>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, +++ b/all/pom.xml, + <version>4.1.21.Final</version>, +++ b/bom/pom.xml, + <version>4.1.21.Final</version>, + <tag>netty-4.1.21.Final</tag>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, + <version>4.1.21.Final</version>, +
[+++ b/pom.xml, + <version>3.1</version>, +++ b/pom.xml, + <version>3.1</version>, +++ b/tarball/assembly.xml, + <fileSet>, + <directory>target/apidocs-all</directory>, + <outputDirectory>javadoc</outputDirectory>, + <includes>, + <include>**/*.jar</include>, + </includes>, + </fileSet>, +++ b/pom.xml, + <version>3.1</version>, +++ b/tarball/assembly.xml, + <fileSet>, + <directory>target/apidocs-all</directory>, + <outputDirectory>javadoc</outputDirectory>, + <includes>, + <include>**/*.jar</include>, + </includes>, + </fileSet>, +++ b/tarball/pom.xml, + <execution>, + <id>copy-apidocs-all-in-one</id>, + <phase>prepare-package</phase>, + <goals>, + <goal>copy-dependencies</goal>, + </goals>, + <configuration>, + <classifier>javadoc</classifier>, + <outputDirectory>${project.build.directory}/apidocs-all</outputDirectory>, + <includeGroupIds>${project.groupId}</includeGroupIds>, + <includeArtifactIds>netty-all</includeArtifactIds>, + </configuration>, + </execution>]
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + if (readableBytes != 0) {, + }, + Component comp = components.remove(cIndex);, + comp.freeIfNecessary();, + if (comp.length > 0) {, + // Only need to call updateComponentOffsets if the length was > 0, + }, + if (numComponents == 0) {, + return this;, + }, + boolean needsUpdate = false;, + if (c.length > 0) {, + needsUpdate = true;, + }, + if (needsUpdate) {, + // Only need to call updateComponentOffsets if the length was > 0, + }, + assert c.length != 0;, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + if (readableBytes != 0) {, +
[+++ b/transport/src/main/java/io/netty/channel/DefaultEventExecutor.java, + DefaultEventExecutor(, + DefaultEventExecutorGroup parent, ThreadFactory threadFactory, TaskScheduler scheduler) {, + super(parent, threadFactory, scheduler);, +++ b/transport/src/main/java/io/netty/channel/DefaultEventExecutor.java, + DefaultEventExecutor(, + DefaultEventExecutorGroup parent, ThreadFactory threadFactory, TaskScheduler scheduler) {, + super(parent, threadFactory, scheduler);, +++ b/transport/src/main/java/io/netty/channel/DefaultEventExecutorGroup.java, + protected EventExecutor newChild(, + ThreadFactory threadFactory, TaskScheduler scheduler, Object... args) throws Exception {, + return new DefaultEventExecutor(this, threadFactory, scheduler);, +++ b/transport/src/main/java/io/netty/channel/DefaultEventExecutor.java, + DefaultEventExecutor(, + DefaultEventExecutorGroup parent, ThreadFactory threadFactory, TaskScheduler scheduler) {, + super(parent, threadFactory, scheduler);, +++ b/transport/src/main/java/io/netty/channel/DefaultEventExecutorGroup.java, + protected EventExecutor newChild(, + ThreadFactory threadFactory, TaskScheduler scheduler, Object... args) throws Exception {, + return new DefaultEventExecutor(this, threadFactory, scheduler);, +++ b/transport/src/main/java/io/netty/channel/MultithreadEventExecutorGroup.java, + final TaskScheduler scheduler;, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockJZlibEncoder.java, + public ByteBuf encode(ChannelHandlerContext ctx, SpdyHeadersFrame frame) throws Exception {, + public void end() {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockJZlibEncoder.java, + public ByteBuf encode(ChannelHandlerContext ctx, SpdyHeadersFrame frame) throws Exception {, + public void end() {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibEncoder.java, + public ByteBuf encode(ChannelHandlerContext ctx, SpdyHeadersFrame frame) throws Exception {]
[]
[+++ b/buffer/src/main/java/io/netty/buffer/UnsafeByteBufUtil.java, + PlatformDependent.copyMemory(tmp, tmpBuf.arrayOffset(), addr, length);, +++ b/buffer/src/main/java/io/netty/buffer/UnsafeByteBufUtil.java, + PlatformDependent.copyMemory(tmp, tmpBuf.arrayOffset(), addr, length);, +++ b/buffer/src/test/java/io/netty/buffer/UnsafeByteBufUtilTest.java, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertNotEquals;, +, + @Test, + public void testSetBytesOnReadOnlyByteBufferWithPooledAlloc() throws Exception {, + byte[] testData = new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};, + int length = testData.length;, +, + ByteBuffer readOnlyBuffer = ByteBuffer.wrap(testData).asReadOnlyBuffer();, +, + int pageSize = 4096;, +, + // create memory pool with one page, + ByteBufAllocator alloc = new PooledByteBufAllocator(true, 1, 1, pageSize, 0);, + UnpooledDirectByteBuf targetBuffer = new UnpooledDirectByteBuf(alloc, length, length);, +, + ByteBuf b1 = alloc.heapBuffer(16);, + ByteBuf
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamFrameToHttpObjectCodec.java, +import io.netty.channel.ChannelHandler.Sharable;, +import io.netty.handler.codec.EncoderException;, +import io.netty.handler.codec.http.FullHttpResponse;, +import io.netty.handler.codec.http.HttpResponse;, +import io.netty.handler.codec.http.HttpResponseStatus;, +@Sharable, + final CharSequence status = headers.status();, +, + // 100-continue response is a special case where Http2HeadersFrame#isEndStream=false, + // but we need to decode it as a FullHttpResponse to play nice with HttpObjectAggregator., + if (null != status && HttpResponseStatus.CONTINUE.codeAsText().contentEquals(status)) {, + final FullHttpMessage fullMsg = newFullMessage(id, headers, ctx.alloc());, + out.add(fullMsg);, + return;, + }, +, + if (headers.method() == null && status == null) {, + /**, + * Encode from an {@link HttpObject} to an {@link Http2StreamFrame}. This method will, + * be called
[+++ b/all/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/example/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha4</version>, +++ b/codec/pom.xml, +
[+++ b/transport-native-epoll/pom.xml, + <Bundle-NativeCode>META-INF/native/libnetty_transport_native_epoll_${os.detected.arch}.so; osname=Linux; processor=${os.detected.arch},*</Bundle-NativeCode>, +++ b/transport-native-epoll/pom.xml, + <Bundle-NativeCode>META-INF/native/libnetty_transport_native_epoll_${os.detected.arch}.so; osname=Linux; processor=${os.detected.arch},*</Bundle-NativeCode>, +++ b/transport-native-kqueue/pom.xml, + <Bundle-NativeCode>META-INF/native/libnetty_transport_native_kqueue_${os.detected.arch}.jnilib; osname=MacOSX, processor=${os.detected.arch}"</Bundle-NativeCode>, + <Bundle-NativeCode>META-INF/native/libnetty_transport_native_kqueue_${os.detected.arch}.jnilib; osname=OpenBSD, processor=${os.detected.arch}"</Bundle-NativeCode>, + <Bundle-NativeCode>META-INF/native/libnetty_transport_native_kqueue_${os.detected.arch}.jnilib; osname=FreeBSD, processor=${os.detected.arch}"</Bundle-NativeCode>]
[+++ b/pom.xml, + <tcnative.version>2.0.5.Final</tcnative.version>]
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, + int startOffset = 0; // offset for [] ip addresses, + int endOffset = ipAddress.length();, + if (endOffset < 2) {, + // Strip [], + if (ipAddress.charAt(0) == '[') {, + if (ipAddress.charAt(endOffset - 1) != ']') {, + return false; // must have a close ], + }, +, + startOffset = 1;, + endOffset --;, + }, +, + // Strip the interface name/index after the percent sign., + int percentIdx = ipAddress.indexOf('%', startOffset);, + if (percentIdx >= 0) {, + endOffset = percentIdx;, + }, +, + for (int i = startOffset;
[+++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, + private final boolean preferDirect;, + this(true);, + this(outboundMessageType, true);, + }, +, + protected MessageToByteEncoder(boolean preferDirect) {, + matcher = TypeParameterMatcher.find(this, MessageToByteEncoder.class, "I");, + this.preferDirect = preferDirect;, + }, +, + protected MessageToByteEncoder(Class<? extends I> outboundMessageType, boolean preferDirect) {, + this.preferDirect = preferDirect;, + try {, + if (preferDirect) {, + buf = ctx.alloc().ioBuffer();, + } else {, + buf = ctx.alloc().heapBuffer();, + }, + buf = null;, + if (buf != null) {, + buf.release();, + }, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, + private final boolean preferDirect;, + this(true);, + this(outboundMessageType, true);, + }, +, + protected MessageToByteEncoder(boolean
[+++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java, + * public class MyChannelInitializer extends {@link ChannelInitializer}&lt{@link Channel}&gt {, + * {@code @Override}, + * channel.pipeline().addLast("idleStateHandler", new {@link IdleStateHandler}(60, 30, 0);, + * channel.pipeline().addLast("myHandler", new MyHandler());, +++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java, + * public class MyChannelInitializer extends {@link ChannelInitializer}&lt{@link Channel}&gt {, + * {@code @Override}, + * channel.pipeline().addLast("idleStateHandler", new {@link IdleStateHandler}(60, 30, 0);, + * channel.pipeline().addLast("myHandler", new MyHandler());, +++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java, + * public class MyChannelInitializer extends {@link ChannelInitializer}&lt{@link Channel}&gt {, +++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java, + * public class MyChannelInitializer extends {@link ChannelInitializer}&lt{@link Channel}&gt {, + * {@code @Override}, + * channel.pipeline().addLast("idleStateHandler", new {@link IdleStateHandler}(60, 30, 0);, + * channel.pipeline().addLast("myHandler", new MyHandler());,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +import io.netty.handler.codec.http.HttpHeaders;, + return handshake(channel, req, null, channel.newPromise());, + * @param responseHeaders, + * Extra headers to add to the handshake response or {@code null} if no extra headers should be added, + public abstract ChannelFuture handshake(Channel channel, FullHttpRequest req,, + HttpHeaders responseHeaders, ChannelPromise promise);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +import io.netty.handler.codec.http.HttpHeaders;, + return handshake(channel, req, null, channel.newPromise());, + * @param responseHeaders, + * Extra headers to add to the handshake response or {@code null} if no extra headers should be added, + public abstract ChannelFuture handshake(Channel channel, FullHttpRequest req,, + HttpHeaders responseHeaders, ChannelPromise promise);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, +import io.netty.handler.codec.http.HttpHeaders;, +
[+++ b/common/src/main/java/io/netty/util/internal/MacAddressUtil.java, + // visible for testing, + static int compareAddresses(byte[] current, byte[] candidate) {, + if (current.length != 0 && (current[0] & 2) == 0) {, + } else {, + if (current.length != 0 && (current[0] & 2) == 0) {, + // Only current is globally unique., + return 1;, + } else {, + }, + }, +++ b/common/src/main/java/io/netty/util/internal/MacAddressUtil.java, + // visible for testing, + static int compareAddresses(byte[] current, byte[] candidate) {, + if (current.length != 0 && (current[0] & 2) == 0) {, + } else {, + if (current.length != 0 && (current[0]
[+++ b/NOTICE.txt, +, +This product contains a modified portion of 'ArrayDeque', written by Josh, +Bloch of Google, Inc:, +, + * LICENSE:, + * license/LICENSE.deque.txt (Public Domain), +++ b/NOTICE.txt, +, +This product contains a modified portion of 'ArrayDeque', written by Josh, +Bloch of Google, Inc:, +, + * LICENSE:, + * license/LICENSE.deque.txt (Public Domain), +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + public boolean isReadable() {, + @Deprecated, + public final boolean readable() {, + return isReadable();, + }, +, + @Override, + public boolean isReadable(int numBytes) {, + return writerIndex - readerIndex >= numBytes;, + }, +, + @Override, + public boolean isWritable()
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteDecoder.java, + callDecode(ctx, in, ctx.nextInboundByteBuffer());, + ByteBuf out = ctx.nextInboundByteBuffer();, + callDecode(ctx, in, out);, + private void callDecode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteDecoder.java, + callDecode(ctx, in, ctx.nextInboundByteBuffer());, + ByteBuf out = ctx.nextInboundByteBuffer();, + callDecode(ctx, in, out);, + private void callDecode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, + ByteBuf out = ctx.nextOutboundByteBuffer();, + encode(ctx, in, out);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteDecoder.java, + callDecode(ctx, in, ctx.nextInboundByteBuffer());, + ByteBuf out = ctx.nextInboundByteBuffer();, + callDecode(ctx, in, out);, + private void callDecode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, + ByteBuf out = ctx.nextOutboundByteBuffer();, + encode(ctx, in, out);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java,
[+++ b/pom.xml, +, + <!-- Test dependency for resolver-dns -->, + <dependency>, + <groupId>org.apache.directory.server</groupId>, + <artifactId>apacheds-protocol-dns</artifactId>, + <version>1.5.7</version>, + <scope>test</scope>, + </dependency>, +++ b/pom.xml, +, + <!-- Test dependency for resolver-dns -->, + <dependency>, + <groupId>org.apache.directory.server</groupId>, + <artifactId>apacheds-protocol-dns</artifactId>, + <version>1.5.7</version>, + <scope>test</scope>, + </dependency>, +++ b/resolver-dns/pom.xml, + <dependency>, + <groupId>org.apache.directory.server</groupId>, + <artifactId>apacheds-protocol-dns</artifactId>, + <scope>test</scope>, + </dependency>, +++ b/pom.xml, +, + <!-- Test dependency for resolver-dns -->, + <dependency>, + <groupId>org.apache.directory.server</groupId>, + <artifactId>apacheds-protocol-dns</artifactId>, + <version>1.5.7</version>, + <scope>test</scope>, + </dependency>, +++ b/resolver-dns/pom.xml, + <dependency>, + <groupId>org.apache.directory.server</groupId>, + <artifactId>apacheds-protocol-dns</artifactId>, + <scope>test</scope>, + </dependency>, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, + private volatile boolean optResourceEnabled = true;,
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + , + /**, + * Gets the {@link ByteBuf} used at the specified index., + * <p>, + * Please note that since a {@link CompositeByteBuf} is made up of, + * multiple {@link ByteBuf}s, this does <em>not</em> return the full buffer., + * Instead, it only returns a portion of the composite buffer where the, + * index is located, + * </p>, + * , + * <p>, + * This is a method meant for use by <em>experts</em> - Please be careful, + * when using it., + * </p>, + * ,
[+++ b/pom.xml, + <ignore>java.net.StandardSocketOptions</ignore>, + <ignore>java.net.SocketOption</ignore>, +++ b/pom.xml, + <ignore>java.net.StandardSocketOptions</ignore>, + <ignore>java.net.SocketOption</ignore>, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannel.java, + config.active(channel);, +++ b/pom.xml, + <ignore>java.net.StandardSocketOptions</ignore>, + <ignore>java.net.SocketOption</ignore>, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannel.java, + config.active(channel);, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannelConfig.java, +import java.net.SocketOption;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.atomic.AtomicReference;, + private final AtomicReference<AsynchronousServerSocketChannel> channel, + = new AtomicReference<AsynchronousServerSocketChannel>();, + private Map<SocketOption<?>, Object> options = new ConcurrentHashMap<SocketOption<?>, Object>();, + private static final int DEFAULT_SND_BUF_SIZE = 32 * 1024;, + private static final boolean DEFAULT_SO_REUSEADDR = false;, + AioServerSocketChannelConfig(AsynchronousServerSocketChannel channel) {, + this.channel.set(channel);, + }, +, + return (Boolean) getOption(StandardSocketOptions.SO_REUSEADDR, DEFAULT_SO_REUSEADDR);, + setOption(StandardSocketOptions.SO_REUSEADDR, reuseAddress);, + return (Integer) getOption(StandardSocketOptions.SO_RCVBUF, DEFAULT_SND_BUF_SIZE);, + setOption(StandardSocketOptions.SO_RCVBUF, receiveBufferSize);, +, + private Object
[+++ b/pom.xml, + <argLine.javaProperties>-D_</argLine.javaProperties>, + <argLine>${argLine.common} ${argLine.alpnAgent} ${argLine.leak} ${argLine.coverage} ${argLine.noUnsafe} ${argLine.java9} ${argLine.javaProperties}</argLine>]
[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, + static final long DEFAULT_SHUTDOWN_QUIET_PERIOD = 2;, + static final long DEFAULT_SHUTDOWN_TIMEOUT = 15;, +, + return shutdownGracefully(DEFAULT_SHUTDOWN_QUIET_PERIOD, DEFAULT_SHUTDOWN_TIMEOUT, TimeUnit.SECONDS);, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, + static final long DEFAULT_SHUTDOWN_QUIET_PERIOD = 2;, + static final long DEFAULT_SHUTDOWN_TIMEOUT = 15;, +, + return shutdownGracefully(DEFAULT_SHUTDOWN_QUIET_PERIOD, DEFAULT_SHUTDOWN_TIMEOUT, TimeUnit.SECONDS);, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutorGroup.java, +import static io.netty.util.concurrent.AbstractEventExecutor.*;, +, + return shutdownGracefully(DEFAULT_SHUTDOWN_QUIET_PERIOD, DEFAULT_SHUTDOWN_TIMEOUT, TimeUnit.SECONDS);]
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java, + if (!query(hostname, recordTypes[i], nameServerAddressStream.duplicate(), promise)) {, + query(hostname, recordTypes[end], nameServerAddressStream, promise);, + final Promise<T> promise) {, + parent.dnsQueryLifecycleObserverFactory().newDnsQueryLifecycleObserver(question), promise);, + final Promise<T> promise) {, + promise);, + if (future.isSuccess()) {, + queryLifecycleObserver.queryFailed(future.cause());, + query(nameServerAddrStream, nameServerAddrStreamIndex + 1, question, promise);, + promise);, + queryLifecycleObserver.queryNoAnswer(code), promise);, + queryLifecycleObserver.queryRedirected(unmodifiableList(nameServers)), promise);, + final Promise<T> promise) {, + finishResolve(promise);, + query(nameServerAddrStream, nameServerAddrStreamIndex + 1, question, promise);, + promise);, + if (!triedCNAME) {, + query(hostname, DnsRecordType.CNAME, getNameServers(hostname), promise);, + finishResolve(promise);, + private void finishResolve(Promise<T> promise) {, + final UnknownHostException cause = new
[+++ b/all/pom.xml, + com.sun.nio.sctp;resolution:=optional,, + sun.net.util;resolution:=optional,]
[+++ b/codec-http/pom.xml, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-handler</artifactId>, + <version>${project.version}</version>, + </dependency>, +++ b/codec-http/pom.xml, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-handler</artifactId>, + <version>${project.version}</version>, + </dependency>, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshakeHandler.java, +import io.netty.channel.ChannelPipeline;, +import io.netty.handler.ssl.SslHandler;, + getWebSocketLocation(ctx.pipeline(), req, websocketPath), subprotocols, allowExtensions);, + private static String getWebSocketLocation(ChannelPipeline cp, HttpRequest req, String path) {, + String protocol = "ws";, + if (cp.get(SslHandler.class) != null) {, + // SSL in use so use Secure WebSockets, + protocol = "wss";, + }, + return protocol + "://" + req.getHeader(HttpHeaders.Names.HOST) + path;]
[+++ b/pom.xml, + <!-- Used for NIO -->, + <ignore>java.nio.channels.ServerSocketChannel</ignore>, + <ignore>java.nio.channels.SocketChannel</ignore>, +++ b/pom.xml, + <!-- Used for NIO -->, + <ignore>java.nio.channels.ServerSocketChannel</ignore>, + <ignore>java.nio.channels.SocketChannel</ignore>, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + doBind0(localAddress);, + }, +, + private void doBind0(SocketAddress localAddress) throws Exception {, + if (PlatformDependent.javaVersion() >= 7) {, + javaChannel().bind(localAddress);, + } else {, + }, + doBind0(localAddress);, +++ b/pom.xml, + <!-- Used for NIO -->, + <ignore>java.nio.channels.ServerSocketChannel</ignore>, + <ignore>java.nio.channels.SocketChannel</ignore>, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + doBind0(localAddress);, + }, +, + private void doBind0(SocketAddress localAddress) throws Exception {, + if (PlatformDependent.javaVersion() >= 7) {, + javaChannel().bind(localAddress);, + } else {, + }, + doBind0(localAddress);, +++
[+++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java, + * An inbound event is handled by the inbound handlers in the bottom-up, + * direction as shown on the left side of the diagram. An inbound handler, + * If an inbound event goes beyond the top inbound handler, it is discarded, + * A outbound event is handled by the outbound handler in the top-down, + * direction as shown on the right side of the diagram. A outbound handler, + * If a outbound event goes beyond the bottom outbound handler, it is, + * In the example above, the class whose name
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java, + /**, + * The size treshold for gathering writes. Non-Masked messages bigger than this size will be be sent fragmented as, + * a header and a content ByteBuf whereas messages smaller than the size will be merged into a single buffer and, + * sent at once.<br>, + * Masked messages will always be sent at once., + */, + private static final int GATHERING_WRITE_TRESHOLD = 1024;, +, + if (maskPayload || length <= GATHERING_WRITE_TRESHOLD) {, + if (maskPayload || length <= GATHERING_WRITE_TRESHOLD) {, + if (maskPayload || length <= GATHERING_WRITE_TRESHOLD) {]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import io.netty.util.CharsetUtil;, + // self-signed certificate for netty.io and the matching private-key, + private static final String CERT = "-----BEGIN CERTIFICATE-----\n" +, + "MIICrjCCAZagAwIBAgIIdSvQPv1QAZQwDQYJKoZIhvcNAQELBQAwFjEUMBIGA1UEAxMLZXhhbXBs\n" +, + "ZS5jb20wIBcNMTgwNDA2MjIwNjU5WhgPOTk5OTEyMzEyMzU5NTlaMBYxFDASBgNVBAMTC2V4YW1w\n" +, + "bGUuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAggbWsmDQ6zNzRZ5AW8E3eoGl\n" +, + "qWvOBDb5Fs1oBRrVQHuYmVAoaqwDzXYJ0LOwa293AgWEQ1jpcbZ2hpoYQzqEZBTLnFhMrhRFlH6K\n" +, + "bJND8Y33kZ/iSVBBDuGbdSbJShlM+4WwQ9IAso4MZ4vW3S1iv5fGGpLgbtXRmBf/RU8omN0Gijlv\n" +, + "WlLWHWijLN8xQtySFuBQ7ssW8RcKAary3pUm6UUQB+Co6lnfti0Tzag8PgjhAJq2Z3wbsGRnP2YS\n" +, + "vYoaK6qzmHXRYlp/PxrjBAZAmkLJs4YTm/XFF+fkeYx4i9zqHbyone5yerRibsHaXZWLnUL+rFoe\n" +, + "MdKvr0VS3sGmhQIDAQABMA0GCSqGSIb3DQEBCwUAA4IBAQADQi441pKmXf9FvUV5EHU4v8nJT9Iq\n" +, + "yqwsKwXnr7AsUlDGHBD7jGrjAXnG5rGxuNKBQ35wRxJATKrUtyaquFUL6H8O6aGQehiFTk6zmPbe\n" +, + "12Gu44vqqTgIUxnv3JQJiox8S2hMxsSddpeCmSdvmalvD6WG4NthH6B9ZaBEiep1+0s0RUaBYn73\n" +, + "I7CCUaAtbjfR6pcJjrFk5ei7uwdQZFSJtkP2z8r7zfeANJddAKFlkaMWn7u+OIVuB4XPooWicObk\n" +, + "NAHFtP65bocUYnDpTVdiyvn8DdqyZ/EO8n1bBKBzuSLplk2msW4pdgaFgY7Vw/0wzcFXfUXmL1uy\n" +, + "G8sQD/wx\n" +, + "-----END CERTIFICATE-----";, +, + private static final String KEY = "-----BEGIN PRIVATE KEY-----\n" +, + "MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCCBtayYNDrM3NFnkBbwTd6gaWp\n" +, + "a84ENvkWzWgFGtVAe5iZUChqrAPNdgnQs7Brb3cCBYRDWOlxtnaGmhhDOoRkFMucWEyuFEWUfops\n" +, + "k0PxjfeRn+JJUEEO4Zt1JslKGUz7hbBD0gCyjgxni9bdLWK/l8YakuBu1dGYF/9FTyiY3QaKOW9a\n" +, + "UtYdaKMs3zFC3JIW4FDuyxbxFwoBqvLelSbpRRAH4KjqWd+2LRPNqDw+COEAmrZnfBuwZGc/ZhK9\n" +, + "ihorqrOYddFiWn8/GuMEBkCaQsmzhhOb9cUX5+R5jHiL3OodvKid7nJ6tGJuwdpdlYudQv6sWh4x\n" +, + "0q+vRVLewaaFAgMBAAECggEAP8tPJvFtTxhNJAkCloHz0D0vpDHqQBMgntlkgayqmBqLwhyb18pR\n" +, + "i0qwgh7HHc7wWqOOQuSqlEnrWRrdcI6TSe8R/sErzfTQNoznKWIPYcI/hskk4sdnQ//Yn9/Jvnsv\n" +,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + * An interface defining an, + * <a href="http://en.wikipedia.org/wiki/HTTP_cookie">HTTP cookie</a>., + * Gets the name of this {@link Cookie}., + *, + * @return The name of this {@link Cookie}, + * Gets the value of this {@link Cookie}., + *, + * @return The value of this {@link Cookie}, + * Sets the value of this {@link Cookie}., + *, + * @param value The value to set, + * Gets the domain of this {@link Cookie}., + *, + * @return The domain of this {@link Cookie}, + * Sets the domain of this
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkedInput.java, + private final ChunkedInput<ByteBuf> input;, + private final LastHttpContent lastHttpContent;, + lastHttpContent = LastHttpContent.EMPTY_LAST_CONTENT;]
[+++ b/handler/src/test/java/io/netty/handler/ssl/JdkOpenSslEngineInteroptTest.java, +import org.junit.Test;, + @Test, + public void testMutualAuthInvalidIntermediateCASucceedWithOptionalClientAuth() throws Exception {, + assumeTrue(OpenSsl.supportsKeyManagerFactory());, + super.testMutualAuthInvalidIntermediateCASucceedWithOptionalClientAuth();, + }, +, + @Override, + @Test, + public void testMutualAuthInvalidIntermediateCAFailWithOptionalClientAuth() throws Exception {, + assumeTrue(OpenSsl.supportsKeyManagerFactory());, + super.testMutualAuthInvalidIntermediateCAFailWithOptionalClientAuth();, + }, +, + @Override, + @Test, + public void testMutualAuthInvalidIntermediateCAFailWithRequiredClientAuth() throws Exception {, + assumeTrue(OpenSsl.supportsKeyManagerFactory());, + super.testMutualAuthInvalidIntermediateCAFailWithRequiredClientAuth();, + }, +, + @Override, + @Test, + public void testMutualAuthValidClientCertChainTooLongFailOptionalClientAuth() throws Exception {, + assumeTrue(OpenSsl.supportsKeyManagerFactory());, + super.testMutualAuthValidClientCertChainTooLongFailOptionalClientAuth();, + }, +, + @Override, + @Test, + public void testMutualAuthValidClientCertChainTooLongFailRequireClientAuth() throws Exception {, + assumeTrue(OpenSsl.supportsKeyManagerFactory());, + super.testMutualAuthValidClientCertChainTooLongFailRequireClientAuth();, + }, +, + @Override, +++ b/handler/src/test/java/io/netty/handler/ssl/JdkOpenSslEngineInteroptTest.java, +import org.junit.Test;, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, +import javax.crypto.NoSuchPaddingException;, +import javax.net.ssl.KeyManagerFactory;, +import javax.net.ssl.SSLContext;, +import javax.net.ssl.SSLEngine;, +import javax.net.ssl.SSLSessionContext;, +, +import static io.netty.handler.ssl.SslUtils.DEFAULT_CIPHER_SUITES;, +import static io.netty.handler.ssl.SslUtils.addIfSupported;, +import static io.netty.handler.ssl.SslUtils.useFallbackCiphersIfDefaultIsEmpty;, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, + private static final String[] DEFAULT_PROTOCOLS;, + private static final List<String> DEFAULT_CIPHERS;, + private static final Set<String> SUPPORTED_CIPHERS;, + addIfSupported(SUPPORTED_CIPHERS, ciphers, DEFAULT_CIPHER_SUITES);, + useFallbackCiphersIfDefaultIsEmpty(ciphers, engine.getEnabledCipherSuites());, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, +import javax.crypto.NoSuchPaddingException;, +import javax.net.ssl.KeyManagerFactory;, +import javax.net.ssl.SSLContext;, +import javax.net.ssl.SSLEngine;, +import javax.net.ssl.SSLSessionContext;, +, +import static io.netty.handler.ssl.SslUtils.DEFAULT_CIPHER_SUITES;, +import static io.netty.handler.ssl.SslUtils.addIfSupported;, +import static io.netty.handler.ssl.SslUtils.useFallbackCiphersIfDefaultIsEmpty;, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, + private static final String[] DEFAULT_PROTOCOLS;, + private static final List<String> DEFAULT_CIPHERS;, + private static final Set<String> SUPPORTED_CIPHERS;, + addIfSupported(SUPPORTED_CIPHERS, ciphers, DEFAULT_CIPHER_SUITES);, + useFallbackCiphersIfDefaultIsEmpty(ciphers,
[+++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, + if (length != 0) {, + }, + if (length != 0) {, + PlatformDependent.copyMemory(addr(index), dst, dstIndex, length);, + }, + if (length != 0) {, + PlatformDependent.copyMemory(addr(index), tmp, 0, length);, + }, + if (length != 0) {, + }, + if (length != 0) {, + PlatformDependent.copyMemory(src, srcIndex, addr(index), length);, + }, + if (readBytes > 0) {, + PlatformDependent.copyMemory(tmp, 0, addr(index), readBytes);, + if (length != 0) {, + }]
[+++ b/pom.xml, + , + <profiles>, + <profile>, + <id>unix</id>, + <activation>, + <os>, + <family>unix</family>, + </os>, + </activation>, + <properties>, + <!--, + Note: Java SCTP only available for Linux and Solaris, + -->, + <sctp.test.skip>false</sctp.test.skip>, + </properties>, + </profile>, + , + <profile>, + <id>default</id>, + <activation>, + <activeByDefault>true</activeByDefault>, + </activation>, + <properties>, + <sctp.test.skip>true</sctp.test.skip>, + </properties>, + </profile>, + </profiles>, +++ b/pom.xml, + , + <profiles>, + <profile>, + <id>unix</id>, + <activation>, + <os>, + <family>unix</family>, + </os>, + </activation>, + <properties>, + <!--, + Note: Java SCTP only available for Linux and Solaris, +
[+++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelException;, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelHandler;, +import io.netty.channel.ChannelOption;, +import io.netty.channel.EventLoopGroup;, +import io.netty.util.AttributeKey;, +, + private final Map<AttributeKey<?>, Object> attrs = new LinkedHashMap<AttributeKey<?>, Object>();, + * Allow to specify an initial attribute of the newly created {@link Channel}. If the {@code value} is, + * {@code null}, the attribute of the specified {@code key} is removed., + */, + public <T> B attr(AttributeKey<T> key, T value) {, + if (key == null) {, + throw new NullPointerException("key");, + }, + if (value == null) {, + attrs.remove(key);, + } else {, + attrs.put(key, value);, + },
[+++ b/NOTICE.txt, +This product optionally depends on 'Snappy', a compression library produced, +by Google Inc, which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.snappy.txt (New BSD License), + * HOMEPAGE:, + * http://code.google.com/p/snappy/, +++ b/NOTICE.txt, +This product optionally depends on 'Snappy', a compression library produced, +by Google Inc, which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.snappy.txt (New BSD License), + * HOMEPAGE:, + * http://code.google.com/p/snappy/, +++ b/codec-snappy/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<!--, + ~ Copyright 2012 The Netty Project, + ~, + ~ The Netty Project licenses this file to you under the
[+++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, +, + @Override, + public boolean equals(Object o) {, + if (this == o) {, + return true;, + }, + if (o instanceof ByteBufHolder) {, + return data.equals(((ByteBufHolder) o).content());, + }, + return false;, + }, +, + @Override, + public int hashCode() {, + return data.hashCode();, + }, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, +, + @Override, + public boolean equals(Object o) {, + if (this == o) {, + return true;, + }, + if (o instanceof ByteBufHolder) {, + return data.equals(((ByteBufHolder) o).content());, + }, + return false;, + }, +, + @Override, + public int hashCode() {,
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + private Runnable invokeFlush0Task;, + Runnable task = invokeFlush0Task;, + if (task == null) {, + invokeFlush0Task = task = new Runnable() {, + };, + }, + executor.execute(task);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, +import io.netty.buffer.ReferenceCounted;, + if (msg instanceof ReferenceCounted) {, + // need to call retain to not free it, + ((ReferenceCounted) msg).retain();, + }, + return new Object[] { message, c.retain() };, + return c.retain();]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + final AbstractEpollUnsafe unsafe = (AbstractEpollUnsafe) unsafe();, + // Run epollInReady later because this is consistent with declaring interest with the polling mechanism., + // We also set maybeMoreDataToRead to false to prevent executing multiple of these runnables., + unsafe.maybeMoreDataToRead = false;, + unsafe.executeEpollInReadyRunnable();, + } else {, + setFlag(readFlag);, + if (!unsafe.readPending && !config().isAutoRead()) {, + boolean readPending;, + boolean maybeMoreDataToRead;, + private Runnable epollInReadyRunnable;, + maybeMoreDataToRead = allocHandle.maybeMoreDataToRead();, + } else if (readPending && maybeMoreDataToRead && !fd().isInputShutdown()) {, + // trigger a read again as there may be something left to read and because of
[+++ b/example/pom.xml, + ${argLine.example}, +++ b/example/pom.xml, + ${argLine.example}, +++ b/run-example.sh, +declare -A EXAMPLE_MAP=(, + ['spdy-server']='io.netty.example.spdy.server.SpdyServer', + ['spdy-client']='io.netty.example.spdy.client.SpdyClient', +), +, +EXAMPLE='', +EXAMPLE_CLASS='', +EXAMPLE_ARGS='', +I=0, +, +while [[ $# -gt 0 ]]; do, + ARG="$1", + shift, + if [[ "$ARG" =~ (^-.+) ]]; then, + if [[ -z "$EXAMPLE_ARGS" ]]; then, + EXAMPLE_ARGS="$ARG", + else, + EXAMPLE_ARGS="$EXAMPLE_ARGS $ARG", + fi, + else, + EXAMPLE="$ARG", + EXAMPLE_CLASS="${EXAMPLE_MAP["$EXAMPLE"]}", + break, + fi, +done, +, +if [[ -z "$EXAMPLE" ]] || [[ -z "$EXAMPLE_CLASS" ]] || [[ $# -ne 0 ]]; then, + echo " Usage: $0 [-D<name>[=<value>] ...] <example-name>" >&2, + echo
[+++ b/pom.xml, + <tcnative.version>2.0.1.Final</tcnative.version>]
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +import java.net.InetAddress;, + NetworkInterface iface = NetworkInterface.getByInetAddress(InetAddress.getLocalHost());, + , + // check if the NetworkInterface is null, this is the case on my ubuntu dev machine but not on osx and windows., + // if so fail back the the first interface, + if (iface == null) {, + iface = NetworkInterface.getByIndex(0);, + }, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +import java.net.InetAddress;, + NetworkInterface iface = NetworkInterface.getByInetAddress(InetAddress.getLocalHost());, + , + // check if the NetworkInterface is null, this is the case on my ubuntu dev machine but not on osx and windows., + // if so fail back the the first
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + private final ChannelPipeline pipeline;, +, + pipeline = new DefaultChannelPipeline(this);, + EventLoop eventLoop = this.eventLoop;, + if (!inFlushNow) { // Avoid re-entrance, + if (!isFlushPending()) {, + } else {, + // Event loop will call flushNow() later by itself., +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + private final ChannelPipeline pipeline;, +, + pipeline = new DefaultChannelPipeline(this);, + EventLoop eventLoop = this.eventLoop;, + if (!inFlushNow) { // Avoid re-entrance, + if (!isFlushPending()) {, + } else {, + // Event loop will call flushNow() later by itself., +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + private final Channel channel;, + channel = pipeline.channel;, + return
[+++ b/handler/src/main/java/io/netty/handler/ssl/ConscryptAlpnSslEngine.java, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.ByteBufAllocator;, +import io.netty.util.internal.SystemPropertyUtil;, +import org.conscrypt.AllocatedBuffer;, +import org.conscrypt.BufferAllocator;, + private static final boolean USE_BUFFER_ALLOCATOR = SystemPropertyUtil.getBoolean(, + "io.netty.handler.ssl.conscrypt.useBufferAllocator", true);, + static ConscryptAlpnSslEngine newClientEngine(SSLEngine engine, ByteBufAllocator alloc,, + return new ClientEngine(engine, alloc, applicationNegotiator);, + static ConscryptAlpnSslEngine newServerEngine(SSLEngine engine, ByteBufAllocator alloc,, + return new ServerEngine(engine, alloc, applicationNegotiator);, + private ConscryptAlpnSslEngine(SSLEngine engine, ByteBufAllocator alloc, List<String> protocols) {, + // Configure the Conscrypt engine to use Netty's buffer allocator. This is a trade-off of memory vs, + // performance., + //, + // If no allocator is provided, the engine will internally allocate a direct buffer of max packet
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameLogger.java, + private static final int BUFFER_LENGTH_THRESHOLD = 64;, + if (enabled()) {, + streamId, padding, endStream, data.readableBytes(), toString(data));, + }, + if (enabled()) {, + }, + if (enabled()) {, + }, + if (enabled()) {, + }, + if (enabled()) {, + }, + if (enabled()) {, + }, + if (enabled()) {, + }, + if (enabled()) {, + log(direction, "PING: ack=false, length=%d, bytes=%s", data.readableBytes(), toString(data));, + }, + if (enabled()) {, + log(direction, "PING: ack=true, length=%d, bytes=%s", data.readableBytes(), toString(data));, + }, + if (enabled()) {, + }, + if (enabled()) {, + errorCode, debugData.readableBytes(),
[+++ b/all/pom.xml, + <version>4.1.0.Final</version>, +++ b/all/pom.xml, + <version>4.1.0.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final</version>, +++ b/all/pom.xml, + <version>4.1.0.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final</version>, +++ b/all/pom.xml, + <version>4.1.0.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Final</version>, +++ b/all/pom.xml, + <version>4.1.0.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Final</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Final</version>, +++ b/all/pom.xml, + <version>4.1.0.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Final</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Final</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.Final</version>, +++ b/all/pom.xml, + <version>4.1.0.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + private final URI uri;, + * @param uri, + protected WebSocketClientHandshaker(URI uri, WebSocketVersion version, String subprotocol,, + this.uri = uri;, + public URI uri() {, + return uri;, + public WebSocketVersion version() {, + public int maxFramePayloadLength() {, + public String expectedSubprotocol() {, + public String actualSubprotocol() {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + private final URI uri;, + * @param uri, + protected WebSocketClientHandshaker(URI uri, WebSocketVersion version, String subprotocol,, + this.uri = uri;, + public URI uri() {, + return uri;, + public WebSocketVersion version() {, + public int maxFramePayloadLength() {, + public String expectedSubprotocol() {, + public
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java]
[+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java, + version = SocksProtocolVersion.valueOf(byteBuf.readByte());, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java, + version = SocksProtocolVersion.valueOf(byteBuf.readByte());, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksMessage.java, + * @deprecated Do not use; this method was intended for an internal use only., + @Deprecated, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java, + version = SocksProtocolVersion.valueOf(byteBuf.readByte());, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksMessage.java, + * @deprecated Do not use; this method was intended for an internal use only., + @Deprecated, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksMessageEncoder.java, + @SuppressWarnings("deprecation")]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2SecurityUtil.java, + "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2SecurityUtil.java, + "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, + String supportedCipher = supportedCiphers[i];, + SUPPORTED_CIPHERS.add(supportedCipher);, + // IBM's J9 JVM utilizes a custom naming scheme for ciphers and only returns ciphers with the "SSL_", + // prefix instead of the "TLS_" prefix (as defined in the JSSE cipher suite names [1]). According to IBM's, + // documentation [2] the "SSL_" prefix is "interchangeable" with the "TLS_" prefix., + // See the IBM forum discussion [3] and issue on IBM's JVM [4] for more details., + //[1] http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#ciphersuites, + //[2] https://www.ibm.com/support/knowledgecenter/en/SSYKE2_8.0.0/com.ibm.java.security.component.80.doc/, + // security-component/jsse2Docs/ciphersuites.html, + //[3] https://www.ibm.com/developerworks/community/forums/html/topic?id=9b5a56a9-fa46-4031-b33b-df91e28d77c2, +
[+++ b/transport/src/main/java/io/netty/channel/ChannelOption.java]
[+++ /dev/null]
[+++ b/transport/src/main/java/io/netty/channel/ChannelDuplexHandler.java, + ChannelPromise promise) throws Exception {, + ctx.bind(localAddress, promise);, + SocketAddress localAddress, ChannelPromise promise) throws Exception {, + ctx.connect(remoteAddress, localAddress, promise);, + public void disconnect(ChannelHandlerContext ctx, ChannelPromise promise), + ctx.disconnect(promise);, + public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {, + ctx.close(promise);, + public void deregister(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {, + ctx.deregister(promise);]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Headers.java, + * Equivalent to {@link #getAll(Object)} but no intermediate list is generated., + * @param name the name of the header to retrieve, + * @return an {@link Iterator} of header values corresponding to {@code name}., + */, + Iterator<CharSequence> valueIterator(CharSequence name);, +, + /**, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Headers.java, + * Equivalent to {@link #getAll(Object)} but no intermediate list is generated., + * @param name the name of the header to retrieve, + * @return an {@link Iterator} of header values corresponding to {@code name}., + */, + Iterator<CharSequence> valueIterator(CharSequence name);, +, + /**, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/ReadOnlyHttp2Headers.java, + public Iterator<CharSequence>
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + private CompositeByteBuf(ByteBufAllocator alloc, boolean direct, int maxNumComponents, int initSize) {, + if (maxNumComponents < 2) {, + throw new IllegalArgumentException(, + "maxNumComponents: " + maxNumComponents + " (expected: >= 2)");, + }, + components = newList(initSize, maxNumComponents);, + }, +, + public CompositeByteBuf(ByteBufAllocator alloc, boolean direct, int maxNumComponents) {, + this(alloc, direct, maxNumComponents, 0);, + CompositeByteBuf(ByteBufAllocator alloc, boolean direct, int maxNumComponents,, + ByteBuf[] buffers, int offset, int endOffset) {, + this(alloc, direct, maxNumComponents, endOffset - offset);, + addComponents0(false, 0, buffers, offset, endOffset);, + this(alloc, direct, maxNumComponents,, + buffers instanceof Collection ? ((Collection<ByteBuf>) buffers).size() : 0);, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, +, + OpenSslSessionContext context = sessionContext();, + if (context != null) {, + context.destroy();, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, +, + OpenSslSessionContext context = sessionContext();, + if (context != null) {, + context.destroy();, + }, +++ b/handler/src/test/java/io/netty/handler/ssl/SslContextBuilderTest.java, +import javax.net.ssl.SSLException;, +import java.util.Collections;, + @Test(expected = IllegalArgumentException.class), + public void testInvalidCipherJdk() throws Exception {, + Assume.assumeTrue(OpenSsl.isAvailable());, + testInvalidCipher(SslProvider.JDK);, + }, +, + @Test(expected = SSLException.class), + public void testInvalidCipherOpenSSL() throws Exception {, + Assume.assumeTrue(OpenSsl.isAvailable());, + testInvalidCipher(SslProvider.OPENSSL);, + }, +, + private static void testInvalidCipher(SslProvider provider) throws Exception {, + SelfSignedCertificate cert = new SelfSignedCertificate();, + SslContextBuilder builder = SslContextBuilder.forClient(), +
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractMessageBuf.java, + @SuppressWarnings("unchecked"), + public boolean unfoldAndAdd(Object o) {, + if (o == null) {, + return false;, + }, +, + if (o instanceof Object[]) {, + Object[] a = (Object[]) o;, + int i;, + for (i = 0; i < a.length; i ++) {, + Object m = a[i];, + if (m == null) {, + break;, + }, + add((T) m);, + }, + return i != 0;, + }, +, + return add((T) o);, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractMessageBuf.java, + @SuppressWarnings("unchecked"), + public boolean unfoldAndAdd(Object o) {, + if (o ==
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + * A collection of utility methods that is related with handling {@link ByteBuf},, + * such as the generation of hex dump and swapping an integer's byte order., +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + * A collection of utility methods that is related with handling {@link ByteBuf},, + * such as the generation of hex dump and swapping an integer's byte order., +++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java]
[+++ b/src/assembly/default.xml, +<!--, + JBoss, Home of Professional Open Source, + , + Copyright 2008, Red Hat Middleware LLC, and individual contributors, + by the @author tags. See the COPYRIGHT.txt in the distribution for a, + full listing of individual contributors., + , + This is free software; you can redistribute it and/or modify it, + under the terms of the GNU Lesser General Public License as, + published by the Free Software Foundation; either version 2.1 of, + the License, or (at your option) any later version., + , + This software is distributed in the hope that
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + int size = components.size();, + if (size <= cIndex) {, + for (int i = cIndex; i < size; i ++) {, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + int size = components.size();, + if (size <= cIndex) {, + for (int i = cIndex; i < size; i ++) {, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + @Test, + public void testRemoveLastComponentWithOthersLeft() {, + CompositeByteBuf buf = freeLater(compositeBuffer());, + buf.addComponent(wrappedBuffer(new byte[]{1, 2}));, + buf.addComponent(wrappedBuffer(new byte[]{1, 2}));, + assertEquals(2, buf.numComponents());, + buf.removeComponent(1);, + assertEquals(1, buf.numComponents());, + }, +]
[+++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, + if (shouldShadedLibraryIdBePatched(packagePrefix)) {, + patchShadedLibraryId(in, out, originalName, name);, + } else {, +, + // Package-private for testing., + static boolean patchShadedLibraryId(InputStream in, OutputStream out, String originalName, String name), + throws IOException {, + byte[] buffer = new byte[8192];, + int length;, + // We read the whole native lib into memory to make it easier to monkey-patch the id., + ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(in.available());, +, + while ((length = in.read(buffer)) > 0) {, + byteArrayOutputStream.write(buffer, 0, length);, + }, + byteArrayOutputStream.flush();, + byte[] bytes = byteArrayOutputStream.toByteArray();, + byteArrayOutputStream.close();, +, + final boolean patched;, +
[+++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java, + public int ensureWritable(int minWritableBytes, boolean force) {, + return 1;, + }, +, + @Override, + public ByteBuf ensureWritable(int minWritableBytes) {, + throw new ReadOnlyBufferException();, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java, + public int ensureWritable(int minWritableBytes, boolean force) {, + return 1;, + }, +, + @Override, + public ByteBuf ensureWritable(int minWritableBytes) {, + throw new ReadOnlyBufferException();, + }, +, + @Override, +++ b/buffer/src/test/java/io/netty/buffer/AbstractPooledByteBufTest.java, +import org.junit.Test;, +, +import static org.hamcrest.MatcherAssert.assertThat;, +import static org.hamcrest.Matchers.greaterThanOrEqualTo;, +import static org.hamcrest.Matchers.is;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.fail;, +, + @Test, + public void ensureWritableWithEnoughSpaceShouldNotThrow() {, + ByteBuf buf = newBuffer(1,
[+++ b/pom.xml, + <skipHttp2Testsuite>false</skipHttp2Testsuite>, + <module>testsuite-http2</module>, +++ b/pom.xml, + <skipHttp2Testsuite>false</skipHttp2Testsuite>, + <module>testsuite-http2</module>, +++ b/testsuite-http2/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<!--, + ~ Copyright 2017 The Netty Project, + ~, + ~ The Netty Project licenses this file to you under the Apache License,, + ~ version 2.0 (the "License"); you may not use this file except in compliance, + ~ with the License. You may obtain a copy of the License at:, + ~, + ~ http://www.apache.org/licenses/LICENSE-2.0, + ~, + ~ Unless required by applicable law or agreed to in writing, software, + ~ distributed under the License is distributed on
[+++ b/README.md, +- __3.2__ branch contains code for Netty 3.x, +++ b/README.md, +- __3.2__ branch contains code for Netty 3.x, +++ b/all/pom.xml, + <version>4.0.0.Alpha1-SNAPSHOT</version>, + <phase>generate-resources</phase>, + <phase>generate-resources</phase>, + <phase>generate-sources</phase>, + <version>2.8.1</version>, + <id>javadoc</id>, +++ b/README.md, +- __3.2__ branch contains code for Netty 3.x, +++ b/all/pom.xml, + <version>4.0.0.Alpha1-SNAPSHOT</version>, + <phase>generate-resources</phase>, + <phase>generate-resources</phase>, + <phase>generate-sources</phase>, + <version>2.8.1</version>, + <id>javadoc</id>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha1-SNAPSHOT</version>, +++ b/README.md, +- __3.2__ branch contains code for Netty 3.x, +++ b/all/pom.xml, + <version>4.0.0.Alpha1-SNAPSHOT</version>, + <phase>generate-resources</phase>, + <phase>generate-resources</phase>, + <phase>generate-sources</phase>, + <version>2.8.1</version>, + <id>javadoc</id>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha1-SNAPSHOT</version>, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + protected AbstractByteBuf(ByteOrder endianness) {, + if
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + ChannelPipeline p = channel.pipeline();, + final String encoderName;, + return promise;, + p.addBefore(ctx.name(), "wsencoder", newWebSocketEncoder());, + encoderName = ctx.name();, + encoderName = p.context(HttpResponseEncoder.class).name();, + p.addAfter(encoderName, "wsencoder", newWebSocketEncoder());, + channel.writeAndFlush(response).addListener(new ChannelFutureListener() {, + @Override, + public void operationComplete(ChannelFuture future) throws Exception {, + if (future.isSuccess()) {, + ChannelPipeline p = future.channel().pipeline();, + p.remove(encoderName);]
[+++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java, + public short getShortLE(int index) {, + recordLeakNonRefCountingOperation();, + return super.getShortLE(index);, + }, +, + @Override, + public int getUnsignedShortLE(int index) {, + recordLeakNonRefCountingOperation();, + return super.getUnsignedShortLE(index);, + }, +, + @Override, + public int getMediumLE(int index) {, + recordLeakNonRefCountingOperation();, + return super.getMediumLE(index);, + }, +, + @Override, + public int getUnsignedMediumLE(int index) {, + recordLeakNonRefCountingOperation();, + return super.getUnsignedMediumLE(index);, + }, +, + @Override, + public int getIntLE(int index) {, + recordLeakNonRefCountingOperation();, + return super.getIntLE(index);, + }, +, + @Override, + public long getUnsignedIntLE(int index) {, + recordLeakNonRefCountingOperation();, + return super.getUnsignedIntLE(index);, + }, +, + @Override, +
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + if (!force && isFlushPending()) {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + if (!force && isFlushPending()) {, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + *abstract]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import io.netty.util.internal.StringUtil;, + private static final String NEWLINE = StringUtil.NEWLINE;, + private static final String[] BYTE2HEX = new String[256];, + private static final String[] HEXPADDING = new String[16];, + private static final String[] BYTEPADDING = new String[16];, + private static final char[] BYTE2CHAR = new char[256];, + private static final String[] HEXDUMP_ROWPREFIXES = new String[65536 >>> 4];, + int i;, +, + // Generate the lookup table for byte-to-hex-dump conversion, + for (i = 0; i < BYTE2HEX.length; i ++) {, + BYTE2HEX[i] = ' ' + StringUtil.byteToHexStringPadded(i);, + }, +, + // Generate the lookup table
[+++ b/codec/src/test/java/io/netty/handler/codec/xml/XmlFrameDecoderTest.java, + buf.release();]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/CompressorHttp2ConnectionEncoder.java, +import io.netty.util.concurrent.PromiseCombiner;, + PromiseCombiner combiner = new PromiseCombiner();, + ChannelPromise bufPromise = ctx.newPromise();, + combiner.add(bufPromise);, + combiner.finish(promise);, + } catch (Throwable cause) {, + promise.tryFailure(cause);, + return promise;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/CompressorHttp2ConnectionEncoder.java, +import io.netty.util.concurrent.PromiseCombiner;, + PromiseCombiner combiner = new PromiseCombiner();, + ChannelPromise bufPromise = ctx.newPromise();, + combiner.add(bufPromise);, + combiner.finish(promise);, + } catch (Throwable cause) {, + promise.tryFailure(cause);, + return promise;, +++ b/common/src/main/java/io/netty/util/concurrent/PromiseAggregator.java, + * @deprecated Use {@link PromiseCombiner}, + *, +@Deprecated, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/CompressorHttp2ConnectionEncoder.java, +import io.netty.util.concurrent.PromiseCombiner;, + PromiseCombiner combiner = new PromiseCombiner();, + ChannelPromise bufPromise = ctx.newPromise();, + combiner.add(bufPromise);, + combiner.finish(promise);, + } catch (Throwable cause) {, + promise.tryFailure(cause);, +
[+++ b/pom.xml, + <version>1.3.1.GA</version>]
[+++ b/src/docbook/module/start.xml, + convenience. Also, please don't hesitate to, + <ulink url="&Community;">contact the Netty project community</ulink> and, + let us know if there's any incorrect information, errors in grammar and, + typo, and if you have a good idea to improve the documentation. ]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + try {, + } finally {, + // Release the buffer as it was retained before and we not need a reference to it at all, + // See https://github.com/netty/netty/issues/1516, + buffer.release();, + }, + try {, + } finally {, + // Release the buffer as it was retained before and we not need a reference to it at all, + // See https://github.com/netty/netty/issues/1516, + buffer.release();, + }]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + public final ByteBuf touch() {, + unwrap().touch();, + return this;, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + public final ByteBuf touch() {, + unwrap().touch();, + return this;, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + public final ByteBuf touch() {, + return this;, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + public final ByteBuf touch() {, + unwrap().touch();, + return this;, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + public final ByteBuf touch() {, + return this;, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java, + public ByteBuf touch() {, + leak.record();, + return this;, +
[+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAddressType.java, + /**, + * @deprecated Use {@link #valueOf(byte)} instead., + */, + @Deprecated, + return valueOf(b);, + }, +, + public static SocksAddressType valueOf(byte b) {, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAddressType.java, + /**, + * @deprecated Use {@link #valueOf(byte)} instead., + */, + @Deprecated, + return valueOf(b);, + }, +, + public static SocksAddressType valueOf(byte b) {, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java, + version = SocksSubnegotiationVersion.valueOf(byteBuf.readByte());, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAddressType.java, + /**, + * @deprecated Use {@link #valueOf(byte)} instead., + */, + @Deprecated, + return valueOf(b);, + }, +, + public static SocksAddressType valueOf(byte b) {, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java, + version = SocksSubnegotiationVersion.valueOf(byteBuf.readByte());, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthResponseDecoder.java, +
[+++ b/.gitignore, +++ b/.gitignore, +++ b/pom.xml, + <repositories>, + <repository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </repository>, + </repositories>, +, + <pluginRepositories>, + <pluginRepository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </pluginRepository>, + </pluginRepositories>, +, + <version>2.3.0</version>, + <version>1.6.1</version>, + <version>4.8.2</version>, + <version>2.5.2</version>, + <version>2.5.2</version>, + <version>1.6.1</version>, + <version>1.0</version>, + <version>2.4.3</version>, + <version>2.7.2</version>, + <version>1.6</version>, + <version>2.7</version>, + <version>2.2</version>, + <version>2.1</version>, + <plugin>, + <groupId>org.codehaus.mojo</groupId>, + <artifactId>exec-maven-plugin</artifactId>, + <version>1.2.1</version>, + </plugin>, +++ b/.gitignore, +++ b/pom.xml, + <repositories>, + <repository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </repository>, + </repositories>, +, + <pluginRepositories>, + <pluginRepository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </pluginRepository>, + </pluginRepositories>, +, +
[+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java, + resetDecoder();, + resetDecoder();, + out.add(currentMessage.retain());, + resetDecoder();, + resetDecoder();, + resetDecoder();, + if (currentMessage != null) {, + currentMessage.release();, + }, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java, + resetDecoder();, + resetDecoder();, + out.add(currentMessage.retain());, + resetDecoder();, + resetDecoder();, + resetDecoder();, + if (currentMessage != null) {, + currentMessage.release();, + }, +++ b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java, +import static org.junit.Assert.assertTrue;, +, + @Test, + public void shouldRetainCurrentMessageWhenSendingItOut() {, + channel = new EmbeddedChannel(, + new BinaryMemcacheRequestEncoder(),, + new BinaryMemcacheRequestDecoder());, +, + String key = "Netty";, + ByteBuf extras = Unpooled.copiedBuffer("extras", CharsetUtil.UTF_8);, + BinaryMemcacheRequest request = new DefaultBinaryMemcacheRequest(key, extras);, + request.setKeyLength((short) key.length());, + request.setExtrasLength((byte) extras.readableBytes());, +, +
[+++ b/testsuite-osgi/src/test/java/io/netty/osgitests/OsgiBundleTest.java, +import static org.ops4j.pax.exam.CoreOptions.frameworkProperty;, +import static org.osgi.framework.Constants.FRAMEWORK_BOOTDELEGATION;, +import java.util.Arrays;, +import io.netty.util.internal.PlatformDependent;, + // Avoid boot delegating sun.misc which would fail testCanLoadPlatformDependent(), + options.add(frameworkProperty(FRAMEWORK_BOOTDELEGATION).value("com.sun.*"));, +, + @Test, + public void testCanLoadPlatformDependent() {, + assertFalse(PlatformDependent.hasUnsafe());, + }]
[+++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffers.java, + * Create a {@link ChannelBuffer} that holds all the given values as int's, + * , + */, + public static ChannelBuffer wrapInt(int... values) {, + if (values == null || values.length == 0) {, + return EMPTY_BUFFER;, + }, + ChannelBuffer buffer = buffer(values.length * 4);, + for (int v: values) {, + buffer.writeInt(v);, + }, + return buffer;, + }, + , + /**, + * Create a {@link ChannelBuffer} that holds all the given values as short's, + * , + */, + public static ChannelBuffer wrapShort(int... values) {, + if (values ==
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + int endOffset = offset + length;, + for (int i = offset; i < endOffset; ++ i) {]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + ret.setDecoderResult(start.decoderResult());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + ret.setDecoderResult(start.decoderResult());, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java, + Object inbound = ch.readInbound();, + assertThat(inbound, is(instanceOf(FullHttpRequest.class)));, + assertTrue(((FullHttpRequest) inbound).getDecoderResult().isFailure());, + Object inbound = ch.readInbound();, + assertThat(inbound, is(instanceOf(FullHttpResponse.class)));, + assertTrue(((FullHttpResponse) inbound).getDecoderResult().isFailure());]
[+++ b/buffer/src/main/java/io/netty/buffer/InstrumentedByteBufAllocator.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, + * Returns {@code true} if ID is for a server initiated stream or ping., + */, + static boolean isServerID(int ID) {, + // Server initiated streams and pings have even IDs, + return ID % 2 == 0;, + }, +, + /**, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, + * Returns {@code true} if ID is for a server initiated stream or ping., + */, + static boolean isServerID(int ID) {, + // Server initiated streams and pings have even IDs, + return ID % 2 == 0;, + }, +, + /**, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, + private final
[+++ b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java, + final ChannelPipeline pipeline = ch.pipeline();, +, + // We add this handler via the EventLoop as the user may have used a ChannelInitializer as handler., + // In this case the initChannel(...) method will only be called after this method returns. Because, + // of this we need to ensure we add our handler in a delayed fashion so all the users handler are, + // placed in front of the ServerBootstrapAcceptor., + ch.eventLoop().execute(new Runnable() {, + @Override, + public void run() {, + });, + }, +++ b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java, + final ChannelPipeline pipeline = ch.pipeline();, +,
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandlerTest.java, + assertTrue(serverChannelLatch.await(WAIT_TIME_SECONDS, TimeUnit.SECONDS));]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return forEachByteDesc0(writerIndex - 1, readerIndex, processor);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return forEachByteDesc0(writerIndex - 1, readerIndex, processor);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, + @Test, + public void testForEachByteDesc2() {, + byte[] expected = {1, 2, 3, 4};, + ByteBuf buf = newBuffer(expected.length);, + try {, + buf.writeBytes(expected);, + final byte[] bytes = new byte[expected.length];, + int i = buf.forEachByteDesc(new ByteProcessor() {, + private int index = bytes.length - 1;, +, + @Override, + public boolean process(byte value) throws Exception {, + bytes[index--] = value;, + return true;, + }, + });, + assertEquals(-1, i);, + assertArrayEquals(expected, bytes);, + } finally {,
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import java.security.cert.CertificateException;, + X509Certificate certificate = selfSignedCertificate();, + /**, + * Returns a self-signed {@link X509Certificate} for {@code netty.io}., + */, + static X509Certificate selfSignedCertificate() throws CertificateException {, + // Bytes of self-signed certificate for netty.io, + byte[] certBytes = {, + 48, -126, 1, -92, 48, -126, 1, 13, -96, 3, 2, 1, 2, 2, 9, 0, -9, 61,, + 44, 121, -118, -4, -45, -120, 48, 13, 6, 9, 42, -122, 72, -122,, + -9, 13, 1, 1, 5, 5, 0, 48, 19, 49, 17, 48, 15, 6, 3, 85, 4, 3, 19,, + 8,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java, + * @param message entity to fetch Content-Type header from, + * Fetch charset from Content-Type header value., + *, + * @param contentTypeValue Content-Type header value to parse, + * @return the charset from message's Content-Type header or {@link io.netty.util.CharsetUtil#ISO_8859_1}, + * if charset is not presented or unparsable, + */, + public static Charset getCharset(CharSequence contentTypeValue) {, + if (contentTypeValue != null) {, + return getCharset(contentTypeValue, CharsetUtil.ISO_8859_1);, + } else {, + return CharsetUtil.ISO_8859_1;, + }, + }, +, + /**, + * @param message entity to fetch Content-Type header from, + * @param defaultCharset
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpRequestDecoderTest.java, + c.content().readSlice(CONTENT_LENGTH));]
[+++ b/all/pom.xml, + <version>4.1.0.CR4</version>, +++ b/all/pom.xml, + <version>4.1.0.CR4</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR4</version>, +++ b/all/pom.xml, + <version>4.1.0.CR4</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR4</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR4</version>, +++ b/all/pom.xml, + <version>4.1.0.CR4</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR4</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR4</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR4</version>, +++ b/all/pom.xml, + <version>4.1.0.CR4</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR4</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR4</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR4</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR4</version>, +++ b/all/pom.xml, + <version>4.1.0.CR4</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR4</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR4</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR4</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR4</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.CR4</version>, +++ b/all/pom.xml, + <version>4.1.0.CR4</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR4</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR4</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/all/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/codec-http2/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.3.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + logger.info("%s ignoring PRIORITY frame for stream %d. Stream doesn't exist but may " +, + logger.info("%s ignoring PRIORITY frame for stream %d. Stream created after GOAWAY sent. " +, + throw connectionError(PROTOCOL_ERROR, "Stream %d does not exist", streamId);, + logger.info("%s ignoring %s frame for stream %d. Stream sent after GOAWAY sent",, + throw streamError(streamId, STREAM_CLOSED, "Received %s frame for an unknown stream %d",, + frameName, streamId);, + logger.info("%s ignoring %s frame for stream %d. %s", ctx.channel(), frameName,, + throw connectionError(PROTOCOL_ERROR, "Stream %d does not exist", streamId);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + logger.info("%s ignoring PRIORITY frame for stream %d.
[+++ b/codec/src/main/java/io/netty/handler/codec/marshalling/ContextBoundUnmarshallerProvider.java, + ContextBoundUnmarshallerProvider.class.getName() + ".unmarshaller");, +++ b/codec/src/main/java/io/netty/handler/codec/marshalling/ContextBoundUnmarshallerProvider.java, + ContextBoundUnmarshallerProvider.class.getName() + ".unmarshaller");, +++ b/codec/src/main/java/io/netty/handler/codec/serialization/CompatibleObjectEncoder.java, + new AttributeKey<ObjectOutputStream>(CompatibleObjectEncoder.class.getName() + ".oos");, +++ b/codec/src/main/java/io/netty/handler/codec/marshalling/ContextBoundUnmarshallerProvider.java, + ContextBoundUnmarshallerProvider.class.getName() + ".unmarshaller");, +++ b/codec/src/main/java/io/netty/handler/codec/serialization/CompatibleObjectEncoder.java, + new AttributeKey<ObjectOutputStream>(CompatibleObjectEncoder.class.getName() + ".oos");, +++ b/common/src/main/java/io/netty/util/AttributeKey.java, +public final class AttributeKey<T> extends UniqueName {, + public AttributeKey(String name) {, + super(names, name);, +++ b/codec/src/main/java/io/netty/handler/codec/marshalling/ContextBoundUnmarshallerProvider.java, + ContextBoundUnmarshallerProvider.class.getName() + ".unmarshaller");, +++ b/codec/src/main/java/io/netty/handler/codec/serialization/CompatibleObjectEncoder.java, + new AttributeKey<ObjectOutputStream>(CompatibleObjectEncoder.class.getName() + ".oos");, +++ b/common/src/main/java/io/netty/util/AttributeKey.java, +public final class AttributeKey<T> extends UniqueName {, + public AttributeKey(String name) {, + super(names, name);, +++ /dev/null, +++ b/codec/src/main/java/io/netty/handler/codec/marshalling/ContextBoundUnmarshallerProvider.java, + ContextBoundUnmarshallerProvider.class.getName() + ".unmarshaller");, +++ b/codec/src/main/java/io/netty/handler/codec/serialization/CompatibleObjectEncoder.java, + new AttributeKey<ObjectOutputStream>(CompatibleObjectEncoder.class.getName() + ".oos");, +++ b/common/src/main/java/io/netty/util/AttributeKey.java, +public final class
[+++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffer.java, + * <a href="http://en.wikipedia.org/wiki/Zero-based_numbering">zero-based indexing</a>., + * It means the index of the first byte is always {@code 0} and the index of the last byte is, + * always {@link #capacity() capacity - 1}. For example, to iterate all bytes of a buffer, you, + * can do the following, regardless of its internal implementation:, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffer.java, + * <a href="http://en.wikipedia.org/wiki/Zero-based_numbering">zero-based indexing</a>., + * It means the index of the first byte is always {@code 0} and the index of the last byte is, + * always {@link #capacity() capacity - 1}. For example, to iterate
[+++ b/pom.xml, + -group "Client &amp; Server bootstrapping utilities" ${project.groupId}.bootstrap*:${project.groupId}.group*, + -group "Miscellaneous" ${project.groupId}.logging*]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java, +import io.netty.handler.codec.http.HttpMessage;, + MessageToMessageCodec<HttpRequest, HttpRequest, Object, Object> {, + super(new Class<?>[] { HttpRequest.class, SpdyRstStreamFrame.class }, new Class<?>[] { HttpResponse.class });, + public Object encode(ChannelHandlerContext ctx, Object msg) throws Exception {, + if (msg instanceof HttpMessage) {, + boolean contains = ((HttpMessage)msg).containsHeader(SpdyHttpHeaders.Names.STREAM_ID);, + ids.add(SpdyHttpHeaders.getStreamId((HttpMessage) msg));, + } else if (msg instanceof SpdyRstStreamFrame) {, + ids.remove(((SpdyRstStreamFrame)msg).getStreamId());, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java, +import io.netty.handler.codec.http.HttpMessage;, + MessageToMessageCodec<HttpRequest, HttpRequest, Object, Object> {, + super(new Class<?>[] { HttpRequest.class, SpdyRstStreamFrame.class }, new Class<?>[] { HttpResponse.class });, + public Object encode(ChannelHandlerContext ctx, Object msg) throws Exception {, + if (msg instanceof HttpMessage) {, + boolean
[+++ b/codec/src/test/java/io/netty/handler/codec/compression/SnappyIntegrationTest.java, +import java.util.Random;, +, +import static io.netty.buffer.Unpooled.*;, + public void testText() throws Exception {, + testIdentity(copiedBuffer(, + CharsetUtil.US_ASCII));, + public void test1002() throws Exception {, + testIdentity(wrappedBuffer(new byte[] {, + }));, + @Test, + @Ignore // FIXME: Make it pass., + public void testRandom() throws Exception {, + byte[] data = new byte[16 * 1048576];, + new Random().nextBytes(data);, + testIdentity(wrappedBuffer(data));, + }, +, + private static void testIdentity(ByteBuf in) {, + assertThat(compressed, is(notNullValue()));]
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, + * {@link UnsupportedOperationException}., + * <p/>, + * This method can only be called from within the event-loop, otherwise it will throw an, + * {@link IllegalStateException}., + * <p/>, + * This method can only be called from within the event-loop, otherwise it will throw an, + * {@link IllegalStateException}., + * <p/>, + * This method can only be called from within the event-loop, otherwise it will throw an, + * {@link IllegalStateException}., + * {@link UnsupportedOperationException}., + * <p/>, + * This method can only be called from within the event-loop, otherwise it
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + // Set Content-Length to workaround some known defect., + // See also: http://www.ietf.org/mail-archive/web/hybi/current/msg02149.html, + request.setHeader(Names.CONTENT_LENGTH, key3.length);]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + // The LocalFlowController is responsible for detecting over/under flow., + connection().local().flowController().incrementWindowSize(connection().connectionStream(), deltaBytes);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + // The LocalFlowController is responsible for detecting over/under flow., + connection().local().flowController().incrementWindowSize(connection().connectionStream(), deltaBytes);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameCodecTest.java, + public void streamZeroWindowUpdateIncrementsConnectionWindow() throws Http2Exception {, + Http2Stream connectionStream = connection.connectionStream();, + int connectionWindowSizeBefore = localFlow.windowSize(connectionStream);, + // We only replenish the flow control window after the amount consumed drops below the following threshold., + // We make the threshold very "high" so that window updates will be sent when the delta is relatively small., + ((DefaultHttp2LocalFlowController) localFlow).windowUpdateRatio(connectionStream, .999f);, + // The initial window size is
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, + tail = new DefaultChannelHandlerContext(this, null, generateName(TAIL_HANDLER), TAIL_HANDLER);, + head = new DefaultChannelHandlerContext(this, null, generateName(headHandler), headHandler);, +, + head.next = tail;, + newCtx = new DefaultChannelHandlerContext(this, group, name, handler);, + newCtx = new DefaultChannelHandlerContext(this, group, name, handler);, + newCtx = new DefaultChannelHandlerContext(this, group, name, handler);, + newCtx = new DefaultChannelHandlerContext(this, group, name, handler);, + new DefaultChannelHandlerContext(this, ctx.executor, newName, newHandler);]
[+++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, + resolver = bootstrap.resolver;]
[+++ b/docker/docker-compose.centos-6.113.yaml, +version: "3", +, +services:, +, + runtime-setup:, + image: netty:centos-6-1.13, + build:, + args:, + centos_version : "6", + java_version : "openjdk@1.13.0-3", +, + test:, + image: netty:centos-6-1.13, +, + test-leak:, + image: netty:centos-6-1.13, +, + test-boringssl-static:, + image: netty:centos-6-1.13, +, + shell:, + image: netty:centos-6-1.13, +++ b/docker/docker-compose.centos-6.113.yaml, +version: "3", +, +services:, +, + runtime-setup:, + image: netty:centos-6-1.13, + build:, + args:, + centos_version : "6", + java_version : "openjdk@1.13.0-3", +, + test:, + image: netty:centos-6-1.13, +, + test-leak:, + image: netty:centos-6-1.13, +, + test-boringssl-static:, + image: netty:centos-6-1.13, +, + shell:, + image: netty:centos-6-1.13, +++ b/docker/docker-compose.centos-7.113.yaml, +version:
[+++ b/transport/src/main/java/io/netty/channel/socket/SocketChannelConfig.java]
[+++ b/transport/src/main/java/io/netty/channel/EventLoop.java, + EventLoop register(Channel channel, ChannelFuture future);, +++ b/transport/src/main/java/io/netty/channel/EventLoop.java, + EventLoop register(Channel channel, ChannelFuture future);, +++ b/transport/src/main/java/io/netty/channel/EventLoopException.java, +package io.netty.channel;, +, +public class EventLoopException extends ChannelException {, +, + private static final long serialVersionUID = -8969100344583703616L;, +, + public EventLoopException() {, + }, +, + public EventLoopException(String message, Throwable cause) {, + super(message, cause);, + }, +, + public EventLoopException(String message) {, + super(message);, + }, +, + public EventLoopException(Throwable cause) {, + super(cause);, + }, +, +}, +++ b/transport/src/main/java/io/netty/channel/EventLoop.java, + EventLoop register(Channel channel, ChannelFuture future);, +++ b/transport/src/main/java/io/netty/channel/EventLoopException.java, +package io.netty.channel;, +, +public class EventLoopException extends ChannelException {, +, +
[+++ b/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtChannelConfig.java, + *, + * @deprecated The UDT transport is no longer maintained and will be removed., +@Deprecated, +++ b/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtChannelConfig.java, + *, + * @deprecated The UDT transport is no longer maintained and will be removed., +@Deprecated, +++ b/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtServerChannelConfig.java, + *, + * @deprecated The UDT transport is no longer maintained and will be removed., +@Deprecated, +++ b/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtChannelConfig.java, + *, + * @deprecated The UDT transport is no longer maintained and will be removed., +@Deprecated, +++ b/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtServerChannelConfig.java, + *, + * @deprecated The UDT transport is no longer maintained and will be removed., +@Deprecated, +++ b/transport-udt/src/main/java/io/netty/channel/udt/UdtChannel.java, + *,
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + enum ClientAuthMode {, + NONE,, + OPTIONAL,, + REQUIRE,, + }, +, + private volatile ClientAuthMode clientAuth = ClientAuthMode.NONE;, + setClientAuth(b ? ClientAuthMode.REQUIRE : ClientAuthMode.NONE);, + return clientAuth == ClientAuthMode.REQUIRE;, + setClientAuth(b ? ClientAuthMode.OPTIONAL : ClientAuthMode.NONE);, + return clientAuth == ClientAuthMode.OPTIONAL;, + }, +, + private void setClientAuth(ClientAuthMode mode) {, + if (clientMode) {, + return;, + }, + synchronized (this) {, + if (clientAuth == mode) {, + // No need to issue any JNI calls if the mode is the same, + return;, + }, + switch (mode) {, + case NONE:, + SSL.setVerify(ssl,
[+++ b/src/main/java/org/jboss/netty/util/HashedWheelTimer.java, + public Timeout newTimeout(TimerTask task, long initialDelay, TimeUnit unit) {, + if (task == null) {, + throw new NullPointerException("task");, + }, + if (unit == null) {, + throw new NullPointerException("unit");, + }, +, + task, wheelCursor, System.nanoTime(), initialDelay);, + "delay must be greater than " +, + private final TimerTask task;, +, + private volatile boolean cancelled;, + HashedWheelTimeout(TimerTask task, int startIndex, long startTime, long initialDelay) {, + this.task = task;, + public TimerTask getTask() {, + return task;, + }, +, + public void cancel() {, + if (cancelled) {, + return;, + },
[+++ b/transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpMessageCompletionHandler.java, +, + @Override, + public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {, + for (ByteBuf buffer: fragments.values()) {, + buffer.release();, + }, + fragments.clear();, + super.handlerRemoved(ctx);, + }, +++ b/transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpMessageCompletionHandler.java, +, + @Override, + public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {, + for (ByteBuf buffer: fragments.values()) {, + buffer.release();, + }, + fragments.clear();, + super.handlerRemoved(ctx);, + }, +++ b/transport-sctp/src/main/test/io/netty/handler/codec/sctp/SctpMessageCompletionHandlerTest.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance,
[+++ b/pom.xml, + <tcnative.version>2.0.2.Final</tcnative.version>]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * if {@link #writerIndex()} + {@code minWritableBytes} &gt; {@link #maxCapacity()}, + * When {@link #writerIndex()} + {@code minWritableBytes} &gt; {@link #maxCapacity()}:, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * if {@link #writerIndex()} + {@code minWritableBytes} &gt; {@link #maxCapacity()}, + * When {@link #writerIndex()} + {@code minWritableBytes} &gt; {@link #maxCapacity()}:, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequest.java, + * and {@link io.netty.handler.codec.http.cookie.ClientCookieEncoder}., +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * if {@link #writerIndex()} + {@code minWritableBytes} &gt; {@link #maxCapacity()}, + * When {@link #writerIndex()} + {@code minWritableBytes} &gt; {@link #maxCapacity()}:, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequest.java, + * and {@link io.netty.handler.codec.http.cookie.ClientCookieEncoder}., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponse.java, + * and {@link io.netty.handler.codec.http.cookie.ClientCookieEncoder}., +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * if {@link
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslContext.java, + for (int i = 0; i < certs.length; i++) {, + InputStream is = new ByteBufInputStream(certs[i], false);, + for (ByteBuf buf: certs) {, + buf.release();, +++ b/handler/src/main/java/io/netty/handler/ssl/SslContext.java, + for (int i = 0; i < certs.length; i++) {, + InputStream is = new ByteBufInputStream(certs[i], false);, + for (ByteBuf buf: certs) {, + buf.release();, +++ b/handler/src/test/java/io/netty/handler/ssl/SslContextTest.java, +import java.security.cert.CertificateException;, + @Test(expected = CertificateException.class), + public void test() throws CertificateException {, + SslContext.toX509Certificates(new File(getClass().getResource("ec_params_unsupported.pem").getFile()));, + }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/SslContext.java, + for (int i = 0; i < certs.length; i++) {, + InputStream is = new ByteBufInputStream(certs[i], false);, + for
[+++ b/codec/src/test/java/io/netty/handler/codec/xml/XmlFrameDecoderTest.java, + public void testFraming() {, + testDecodeWithXml(Arrays.asList("<abc", ">123</a", "bc>"), "<abc>123</abc>");, + }, +, + @Test, + private static void testDecodeWithXml(List<String> xmlFrames, Object... expected) {, + for (String xmlFrame : xmlFrames) {, + ch.writeInbound(Unpooled.copiedBuffer(xmlFrame, CharsetUtil.UTF_8));, + }, + private static void testDecodeWithXml(String xml, Object... expected) {, + testDecodeWithXml(Collections.singletonList(xml), expected);, + }, +]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, + /**, + * Create a new instance., + * <p>, + * Header names will be validated., + */, + this(true);, + }, +, + /**, + * Create a new instance., + * @param validateHeaders {@code true} to validate headers. {@code false} to not validate headers., + * @see #DefaultHttp2HeadersDecoder(boolean), + */, + public DefaultHttp2FrameReader(boolean validateHeaders) {, + this(new DefaultHttp2HeadersDecoder(validateHeaders));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, + /**, + * Create a new instance., + * <p>, + * Header names will be validated., + */, + this(true);, + }, +, + /**, + * Create a new instance.,
[+++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslErrorStackAssertSSLEngine.java, + return getWrappedEngine().release(decrement);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + String rawPath = uri.getRawPath();, + if (rawPath != null) {, + hasPath = true;, + } else {, + rawPath ="";, + hasPath = false;, + }, + // Also take care of cut of things like "http://localhost" , + String newUri = rawPath + "?" + uri.getRawQuery();, +, + this.uri = newUri.replace(';', '&');, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + String rawPath = uri.getRawPath();, + if (rawPath != null) {, + hasPath = true;, + } else {, + rawPath ="";, + hasPath = false;, + }, + // Also take care of cut of things like "http://localhost"
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java, + content.release();]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import org.apache.tomcat.Apr;, +import java.io.IOException;, +import java.io.InputStream;, +import java.util.Properties;, + if (cause == null && !isNettyTcnative()) {, + logger.debug("incompatible tcnative in the classpath; ", + + OpenSslEngine.class.getSimpleName() + " will be unavailable.");, + cause = new ClassNotFoundException("incompatible tcnative in the classpath");, + }, +, + private static boolean isNettyTcnative() {, + return AccessController.doPrivileged(new PrivilegedAction<Boolean>() {, + @Override, + public Boolean run() {, + InputStream is = null;, + try {, + is = Apr.class.getResourceAsStream("/org/apache/tomcat/apr.properties");, + Properties props = new Properties();, + props.load(is);, + String info = props.getProperty("tcn.info");, + return info != null && info.startsWith("netty-tcnative");, + } catch (Throwable
[+++ b/README.md, +- __3.2__ branch contains code for Netty 3.x, +++ b/README.md, +- __3.2__ branch contains code for Netty 3.x, +++ b/all/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/README.md, +- __3.2__ branch contains code for Netty 3.x, +++ b/all/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/README.md, +- __3.2__ branch contains code for Netty 3.x, +++ b/all/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/README.md, +- __3.2__ branch contains code for Netty 3.x, +++ b/all/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + channel.pipeline().replace(HttpRequestEncoder.class, "ws-encoder", new WebSocket00FrameEncoder());, +++ b/README.md, +- __3.2__ branch contains
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +jfieldID readerIndexFieldId = NULL;, +jfieldID writerIndexFieldId = NULL;, +jfieldID memoryAddressFieldId = NULL;, +, + jclass addressEntryClass = (*env)->FindClass(env, "io/netty/channel/epoll/EpollChannelOutboundBuffer$AddressEntry");, + if (addressEntryClass == NULL) {, + // pending exception..., + return JNI_ERR;, + }, + readerIndexFieldId = (*env)->GetFieldID(env, addressEntryClass, "readerIndex", "I");, + if (readerIndexFieldId == NULL) {, + // pending exception..., + return JNI_ERR;, + }, + writerIndexFieldId = (*env)->GetFieldID(env, addressEntryClass, "writerIndex", "I");, + if (writerIndexFieldId == NULL) {, + // pending exception..., + return JNI_ERR;, + }, + memoryAddressFieldId = (*env)->GetFieldID(env, addressEntryClass, "memoryAddress", "J");, + if (memoryAddressFieldId == NULL) {, + // pending exception..., + return
[+++ b/codec/src/test/java/io/netty/handler/codec/compression/Bzip2DecoderTest.java, +import java.util.Arrays;, + private static final byte[] DATA = { 0x42, 0x5A, 0x68, 0x37, 0x31, 0x41, 0x59, 0x26, 0x53,, + 0x59, 0x77, 0x7B, (byte) 0xCA, (byte) 0xC0, 0x00, 0x00,, + 0x00, 0x05, (byte) 0x80, 0x00, 0x01, 0x02, 0x00, 0x04,, + 0x20, 0x20, 0x00, 0x30, (byte) 0xCD, 0x34, 0x19, (byte) 0xA6,, + (byte) 0x89, (byte) 0x99, (byte) 0xC5, (byte) 0xDC, (byte) 0x91,, + 0x4E, 0x14, 0x24, 0x1D, (byte) 0xDE, (byte) 0xF2, (byte) 0xB0, 0x00 };, +, + private static final byte[] BYTES_LARGE = new byte[MAX_BLOCK_SIZE * BASE_BLOCK_SIZE + 256];, + final byte[] data = Arrays.copyOf(DATA, DATA.length);, + data[41]
[+++ b/pom.xml, + <version>1.2.1.GA</version>]
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsRecord.java, + this.name = appendTrailingDot(IDN.toASCII(checkNotNull(name, "name")));, + private static String appendTrailingDot(String name) {, + if (name.length() > 0 && name.charAt(name.length() - 1) != '.') {, + return name + '.';, + }, + return name;, + }, +, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsRecord.java, + this.name = appendTrailingDot(IDN.toASCII(checkNotNull(name, "name")));, + private static String appendTrailingDot(String name) {, + if (name.length() > 0 && name.charAt(name.length() - 1) != '.') {, + return name + '.';, + }, + return name;, + }, +, +++ b/codec-dns/src/test/java/io/netty/handler/codec/dns/AbstractDnsRecordTest.java, + Assert.assertEquals(name + '.', record.name());, + Assert.assertEquals("xn--4ca.", record.name());, + }, +, + @Test, + public void testValidDomainNameTrailingDot() {, +
[+++ b/pom.xml, + <id>alpn-7latest</id>, + <jdk>[1.7,1.8)</jdk>, + <jetty.alpn.version>7.1.3.v20150130</jetty.alpn.version>, + <id>npn-latest</id>, + <!--Even though npn is only supported on 1.7, allow it to still be included so dependencies can be resolved-->, + <jdk>[1.7,)</jdk>, + <jetty.npn.version>1.1.11.v20150415</jetty.npn.version>, + </properties>, + </profile>, + <profile>, + <id>alpn-8latest</id>, + <activation>, + <jdk>[1.8,)</jdk>, + </activation>, + <properties>, + <jetty.alpn.version>8.1.4.v20150727</jetty.alpn.version>]
[+++ b/codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompSubframeAggregatorTest.java, + StompFrame frame = channel.readInbound();, + frame.release();]
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java, + URI uri = new URI(server);, + int port = uri.getPort();, + defaultNameServers.add(SocketUtils.socketAddress(uri.getHost(), port == -1 ? DNS_PORT : port));]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderNames.java, + public static final AsciiString ACCEPT = AsciiString.cached("accept");, + public static final AsciiString ACCEPT_CHARSET = AsciiString.cached("accept-charset");, + public static final AsciiString ACCEPT_ENCODING = AsciiString.cached("accept-encoding");, + public static final AsciiString ACCEPT_LANGUAGE = AsciiString.cached("accept-language");, + public static final AsciiString ACCEPT_RANGES = AsciiString.cached("accept-ranges");, + public static final AsciiString ACCEPT_PATCH = AsciiString.cached("accept-patch");, + AsciiString.cached("access-control-allow-credentials");, + AsciiString.cached("access-control-allow-headers");, + AsciiString.cached("access-control-allow-methods");, + AsciiString.cached("access-control-allow-origin");, + AsciiString.cached("access-control-expose-headers");, + public static final AsciiString ACCESS_CONTROL_MAX_AGE = AsciiString.cached("access-control-max-age");, + AsciiString.cached("access-control-request-headers");, + AsciiString.cached("access-control-request-method");, + public static final AsciiString AGE = AsciiString.cached("age");, + public static final AsciiString ALLOW = AsciiString.cached("allow");, + public static final AsciiString AUTHORIZATION = AsciiString.cached("authorization");, + public static
[+++ b/example/src/main/java/io/netty/example/sctp/multihoming/SctpMultiHomingEchoClient.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, + // GCM (Galois/Counter Mode) requires JDK 8., + "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",, + // AES256 requires JCE unlimited strength jurisdiction policy files., + // GCM (Galois/Counter Mode) requires JDK 8., + "TLS_RSA_WITH_AES_128_GCM_SHA256",, + // AES256 requires JCE unlimited strength jurisdiction policy files., +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, + // GCM (Galois/Counter Mode) requires JDK 8., + "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",, + // AES256 requires JCE unlimited strength jurisdiction policy files., + // GCM (Galois/Counter Mode) requires JDK 8., + "TLS_RSA_WITH_AES_128_GCM_SHA256",, + // AES256 requires JCE unlimited strength jurisdiction policy files., +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +, + // BEGIN Platform-dependent flags, +, + /**, + * {@code trus}
[+++ b/common/src/main/java/io/netty/util/internal/RecyclableArrayList.java, + * A simple list which is recyclable. This implementation does not allow {@code null} elements to be added.]
[+++ b/all/pom.xml, + , + <!-- All release modules -->, + <artifactId>netty-buffer</artifactId>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-codec</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-codec-http</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-codec-socks</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-common</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-handler</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, +
[+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java, + setInitMaxStreams((SctpStandardSocketOptions.InitMaxStreams) value);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + headers.set(HttpHeaderNames.UPGRADE, WEBSOCKET), + .set(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE), + .set(HttpHeaderNames.HOST, websocketHostValue(wsURL)), + .set(HttpHeaderNames.ORIGIN, websocketOriginValue(wsURL)), + .set(HttpHeaderNames.SEC_WEBSOCKET_KEY1, key1), + .set(HttpHeaderNames.SEC_WEBSOCKET_KEY2, key2);, +, + String expectedSubprotocol = expectedSubprotocol();, + if (expectedSubprotocol != null && !expectedSubprotocol.isEmpty()) {, + headers.set(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL, expectedSubprotocol);, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + headers.set(HttpHeaderNames.UPGRADE, WEBSOCKET), + .set(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE), + .set(HttpHeaderNames.HOST, websocketHostValue(wsURL)), + .set(HttpHeaderNames.ORIGIN, websocketOriginValue(wsURL)), + .set(HttpHeaderNames.SEC_WEBSOCKET_KEY1, key1), + .set(HttpHeaderNames.SEC_WEBSOCKET_KEY2, key2);, +, + String expectedSubprotocol = expectedSubprotocol();, + if (expectedSubprotocol != null && !expectedSubprotocol.isEmpty()) {, + headers.set(HttpHeaderNames.SEC_WEBSOCKET_PROTOCOL, expectedSubprotocol);, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java, +, + headers.set(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET), + .set(HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE), + .set(HttpHeaderNames.SEC_WEBSOCKET_KEY, key), + .set(HttpHeaderNames.HOST, websocketHostValue(wsURL)), + .set(HttpHeaderNames.SEC_WEBSOCKET_ORIGIN, websocketOriginValue(wsURL));, +,
[+++ b/pom.xml, + <name>Apache License, Version 2.0</name>, + <url>http://www.apache.org/licenses/LICENSE-2.0</url>]
[+++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, +import io.netty.channel.MessageSizeEstimator;, +, + @Override, + public RxtxChannelConfig setMessageSizeEstimator(MessageSizeEstimator estimator) {, + super.setMessageSizeEstimator(estimator);, + return this;, + }, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, +import io.netty.channel.MessageSizeEstimator;, +, + @Override, + public RxtxChannelConfig setMessageSizeEstimator(MessageSizeEstimator estimator) {, + super.setMessageSizeEstimator(estimator);, + return this;, + }, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java, +import io.netty.channel.MessageSizeEstimator;, +, + @Override, + RxtxChannelConfig setWriteBufferHighWaterMark(int writeBufferHighWaterMark);, +, + @Override, + RxtxChannelConfig setWriteBufferLowWaterMark(int writeBufferLowWaterMark);, +, + @Override, + RxtxChannelConfig setMessageSizeEstimator(MessageSizeEstimator estimator);, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, +import io.netty.channel.MessageSizeEstimator;, +, + @Override, + public RxtxChannelConfig setMessageSizeEstimator(MessageSizeEstimator estimator) {, + super.setMessageSizeEstimator(estimator);, + return this;, + }, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java, +import io.netty.channel.MessageSizeEstimator;, +, + @Override, + RxtxChannelConfig setWriteBufferHighWaterMark(int writeBufferHighWaterMark);, +, + @Override,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/EmptyHttpHeaders.java, + * @see InstanceInitializer#EMPTY_HEADERS, + * This is needed to break a cyclic static initialization loop between {@link HttpHeaders} and {@link, + * EmptyHttpHeaders}., + return InstanceInitializer.EMPTY_HEADERS;, +, + /**, + * This class is needed to break a cyclic static initialization loop between {@link HttpHeaders} and, + * {@link EmptyHttpHeaders}., + */, + @Deprecated, + private static final class InstanceInitializer {, + /**, + * The instance is instantiated here to break the cyclic static initialization between {@link EmptyHttpHeaders}, + * and {@link HttpHeaders}. The issue is that if someone accesses {@link EmptyHttpHeaders#INSTANCE} before, + *
[+++ b/src/docbook/module/preface.xml, + event-driven network application framework and tooling for the rapid, + development of maintainable high-performance &middot; high-scalability, + protocol servers and clients., + In other words, Netty is a NIO client server framework which enables, + quick and easy development of network applications such as protocol, + servers and clients. It greatly simplifies and streamlines network, + programming such as TCP/IP socket server development., + </para>, + <para>, + 'Quick and easy' doesn't mean that a resulting application will suffer, + from a maintainability or a performance issue. Netty has been designed, + carefully with the experiences
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + if (readableBytes > 0 && cIndex < components.size() - 1) {, + } else if (cIndex == 0) {, + c.endOffset = readableBytes;, + } else {, + c.offset = components.get(cIndex - 1).endOffset;, + c.endOffset = c.offset + readableBytes;, + writerIndex(writerIndex() + readableBytes);, + c.freeIfNecessary();, + c.freeIfNecessary();, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + if (readableBytes > 0 && cIndex < components.size() - 1) {, + } else if (cIndex == 0) {, + c.endOffset = readableBytes;, + } else {, + c.offset = components.get(cIndex - 1).endOffset;, + c.endOffset = c.offset + readableBytes;, + writerIndex(writerIndex() + readableBytes);, + c.freeIfNecessary();, +
[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +, + // Guard against overflow., + if (delay > 0 && deadline < 0) {, + deadline = Long.MAX_VALUE;, + }, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +, + // Guard against overflow., + if (delay > 0 && deadline < 0) {, + deadline = Long.MAX_VALUE;, + }, +++ b/common/src/test/java/io/netty/util/HashedWheelTimerTest.java, + @Test, + public void testOverflow() throws InterruptedException {, + final HashedWheelTimer timer = new HashedWheelTimer();, + final CountDownLatch latch = new CountDownLatch(1);, + Timeout timeout = timer.newTimeout(new TimerTask() {, + @Override, + public void run(Timeout timeout) {, + latch.countDown();, + }, + }, Long.MAX_VALUE, TimeUnit.MILLISECONDS);, + assertFalse(latch.await(1, TimeUnit.SECONDS));,
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + void free(PoolChunk<T> chunk, long handle, int normCapacity, boolean sameThreads) {, + if (sameThreads) {, + }, +, + free(oldChunk, oldHandle, oldMaxLength, buf.initThread == Thread.currentThread());, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + void free(PoolChunk<T> chunk, long handle, int normCapacity, boolean sameThreads) {, + if (sameThreads) {, + }, +, + free(oldChunk, oldHandle, oldMaxLength, buf.initThread == Thread.currentThread());, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + Thread initThread;, + initThread = Thread.currentThread();, + initThread = Thread.currentThread();, + boolean sameThread = initThread == Thread.currentThread();, + initThread = null;, + chunk.arena.free(chunk, handle, maxLength, sameThread);]
[+++ b/src/main/java/org/jboss/netty/example/discard/DiscardClient.java, +import org.jboss.netty.channel.ChannelPipeline;, +import org.jboss.netty.channel.ChannelPipelineFactory;, +import org.jboss.netty.channel.Channels;, + final String host = args[0];, + final int port = Integer.parseInt(args[1]);, + final int firstMessageSize;, + // Set up the pipeline factory., + bootstrap.setPipelineFactory(new ChannelPipelineFactory() {, + public ChannelPipeline getPipeline() throws Exception {, + return Channels.pipeline(, + new DiscardClientHandler(firstMessageSize));, + }, + });, +++ b/src/main/java/org/jboss/netty/example/discard/DiscardClient.java, +import org.jboss.netty.channel.ChannelPipeline;, +import org.jboss.netty.channel.ChannelPipelineFactory;, +import org.jboss.netty.channel.Channels;, + final String host = args[0];, + final int port = Integer.parseInt(args[1]);, + final int firstMessageSize;, + // Set up the pipeline factory., + bootstrap.setPipelineFactory(new ChannelPipelineFactory() {, + public ChannelPipeline getPipeline() throws Exception {, + return Channels.pipeline(, + new
[+++ b/pom.xml, + <version>1.6.0</version>]
[+++ b/src/docbook/en-US/module/architecture.xml, + A well-defined and extensible event model is a must for an event-driven, + application. Netty has a well-defined event model focused on I/O. It, + also allows you to implement your own event type without breaking the, + existing code because each event type is distinguished from another by, + a strict type hierarchy. This is another differentiator against other, + frameworks. Many NIO frameworks have no or a very limited notion of an, + event model. If they offer extension at all, they often break the, + existing code when you try to add custom
[+++ b/buffer/src/test/java/io/netty/buffer/ByteProcessorTest.java, + assertEquals(24, buf.forEachByte(19, length - 19, ByteProcessor.FIND_ASCII_SPACE));, + assertEquals(25, buf.forEachByteDesc(0, length, ByteProcessor.FIND_ASCII_SPACE));, +++ b/buffer/src/test/java/io/netty/buffer/ByteProcessorTest.java, + assertEquals(24, buf.forEachByte(19, length - 19, ByteProcessor.FIND_ASCII_SPACE));, + assertEquals(25, buf.forEachByteDesc(0, length, ByteProcessor.FIND_ASCII_SPACE));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseDecoder.java, + HttpResponseStatus.valueOf(Integer.parseInt(initialLine[1]), initialLine[2]), validateHeaders);, +++ b/buffer/src/test/java/io/netty/buffer/ByteProcessorTest.java, + assertEquals(24, buf.forEachByte(19, length - 19, ByteProcessor.FIND_ASCII_SPACE));, + assertEquals(25, buf.forEachByteDesc(0, length, ByteProcessor.FIND_ASCII_SPACE));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseDecoder.java, + HttpResponseStatus.valueOf(Integer.parseInt(initialLine[1]), initialLine[2]), validateHeaders);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseStatus.java, +import static io.netty.handler.codec.http.HttpConstants.SP;, +import static io.netty.util.ByteProcessor.FIND_ASCII_SPACE;, +import static java.lang.Integer.parseInt;, +, + * If the specified code is a standard HTTP status code, a cached instance, + HttpResponseStatus status = valueOf0(code);, + return status != null ? status : new HttpResponseStatus(code);, + }, +,
[+++ b/common/src/test/java/io/netty/util/internal/PlatformDependent0Test.java, + assumeTrue(PlatformDependent0.hasDirectBufferNoCleanerConstructor());]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, +, + if (fd().isInputShutdown()) {, + // We need to do this for two reasons:, + //, + // - If the input was shutdown in between (which may be the case when the user did it in the, + // fireChannelRead(...) method we should not try to read again to not produce any, + // miss-leading exceptions., + //, + // - If the user closes the channel we need to ensure we not try to read from it again as, + // the filedescriptor may be re-used already by the OS if the system is
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_epollerr(JNIEnv* env, jclass clazz) {, + return EPOLLERR;, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_epollerr(JNIEnv* env, jclass clazz) {, + return EPOLLERR;, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +jint Java_io_netty_channel_epoll_Native_epollerr(JNIEnv* env, jclass clazz);, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_epollerr(JNIEnv* env, jclass clazz) {, + return EPOLLERR;, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +jint Java_io_netty_channel_epoll_Native_epollerr(JNIEnv* env, jclass clazz);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, + // Check if an error was the cause of the wakeup., + boolean err = (ev & Native.EPOLLERR) != 0;, +, + //, + // It is possible for an EPOLLOUT or EPOLLERR to be generated when
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/ClientCookieEncoder.java, +import static io.netty.handler.codec.http.cookie.CookieUtil.add;, +import static io.netty.handler.codec.http.cookie.CookieUtil.addQuoted;, +import static io.netty.handler.codec.http.cookie.CookieUtil.stringBuilder;, +import static io.netty.handler.codec.http.cookie.CookieUtil.stripTrailingSeparator;, +import static io.netty.handler.codec.http.cookie.CookieUtil.stripTrailingSeparatorOrNull;, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.Collection;, +import java.util.Comparator;, +import java.util.Iterator;, +import java.util.List;, +, + * A <a href="http://tools.ietf.org/html/rfc6265">RFC6265</a> compliant cookie encoder to be used client side, so, + * only name=value pairs are sent., + * Strict encoder that validates that name and value chars are in the valid scope and (for methods that accept, + * multiple cookies) sorts cookies into order of decreasing path length, as specified in RFC6265., + * Lax instance that doesn't validate name and value, and
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, + AttributeKey.valueOf(WebSocketServerHandshaker.class, "HANDSHAKER");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, + AttributeKey.valueOf(WebSocketServerHandshaker.class, "HANDSHAKER");, +++ b/codec/src/main/java/io/netty/handler/codec/DecoderResult.java, + protected static final Signal SIGNAL_UNFINISHED = Signal.valueOf(DecoderResult.class, "UNFINISHED");, + protected static final Signal SIGNAL_SUCCESS = Signal.valueOf(DecoderResult.class, "SUCCESS");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, + AttributeKey.valueOf(WebSocketServerHandshaker.class, "HANDSHAKER");, +++ b/codec/src/main/java/io/netty/handler/codec/DecoderResult.java, + protected static final Signal SIGNAL_UNFINISHED = Signal.valueOf(DecoderResult.class, "UNFINISHED");, + protected static final Signal SIGNAL_SUCCESS = Signal.valueOf(DecoderResult.class, "SUCCESS");, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, + static final Signal REPLAY = Signal.valueOf(ReplayingDecoder.class, "REPLAY");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, + AttributeKey.valueOf(WebSocketServerHandshaker.class, "HANDSHAKER");, +++ b/codec/src/main/java/io/netty/handler/codec/DecoderResult.java, + protected static final Signal SIGNAL_UNFINISHED = Signal.valueOf(DecoderResult.class, "UNFINISHED");, + protected static final Signal SIGNAL_SUCCESS = Signal.valueOf(DecoderResult.class, "SUCCESS");, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, + static final Signal REPLAY = Signal.valueOf(ReplayingDecoder.class,
[+++ b/all/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta3-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/transport-sctp/src/main/java/io/netty/channel/socket/sctp/SctpChannel.java, + * A SCTP/IP {@link Channel} interface for single SCTP association., + *, + * <p>, + * The SctpChannel is a message-oriented, connected transport which supports multi-streaming and multi-homing., + * </p>, + * Will notify the given {@link ChannelPromise} and return a {@link ChannelFuture}, + ChannelFuture bindAddress(InetAddress localAddress, ChannelPromise promise);, + * Will notify the given {@link ChannelPromise} and return a {@link ChannelFuture}, + ChannelFuture unbindAddress(InetAddress localAddress, ChannelPromise promise);, +++ b/transport-sctp/src/main/java/io/netty/channel/socket/sctp/SctpChannel.java, + * A SCTP/IP {@link Channel} interface for single SCTP association., + *, + * <p>, + * The SctpChannel is a message-oriented, connected
[+++ b/pom.xml, +++ b/pom.xml, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + // The promise should be notified before we call fireChannelInactive()., + promise.setSuccess();, + closePromise.setSuccess();, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + // The promise should be notified before we call fireChannelInactive()., + promise.setSuccess();, + closePromise.setSuccess();, +, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexCodecTest.java, +import java.util.concurrent.atomic.AtomicBoolean;, + @Test, + public void channelClosedWhenInactiveFired() {, + LastInboundHandler inboundHandler = streamActiveAndWriteHeaders(inboundStream);, + Http2StreamChannel childChannel = (Http2StreamChannel) inboundHandler.channel();, +, + final AtomicBoolean channelOpen = new AtomicBoolean(false);, + final AtomicBoolean channelActive = new AtomicBoolean(false);, + assertTrue(childChannel.isOpen());, + assertTrue(childChannel.isActive());, +, + childChannel.pipeline().addLast(new ChannelInboundHandlerAdapter() {, + @Override, + public void channelInactive(ChannelHandlerContext ctx) throws Exception {, + channelOpen.set(ctx.channel().isOpen());, + channelActive.set(ctx.channel().isActive());, +, + super.channelInactive(ctx);,
[+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java, +import io.netty.channel.ChannelHandler;, +@ChannelHandler.Sharable]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, +++ b/handler/src/main/java/io/netty/handler/logging/MessageLoggingHandler.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT,
[+++ b/.gitignore, +, +# exclude mainframer files, +mainframer, +.mainframer]
[+++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, + public static final ChannelOption<Integer> UDP_RECEIVE_PACKET_SIZE =, + new ChannelOption<Integer>("UDP_RECEIVE_PACKET_SIZE", Integer.class);, +, +++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, + public static final ChannelOption<Integer> UDP_RECEIVE_PACKET_SIZE =, + new ChannelOption<Integer>("UDP_RECEIVE_PACKET_SIZE", Integer.class);, +, +++ b/transport/src/main/java/io/netty/channel/socket/DatagramChannelConfig.java, + int getReceivePacketSize();, +, + void setReceivePacketSize(int receivePacketSize);, +, +++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, + public static final ChannelOption<Integer> UDP_RECEIVE_PACKET_SIZE =, + new ChannelOption<Integer>("UDP_RECEIVE_PACKET_SIZE", Integer.class);, +, +++ b/transport/src/main/java/io/netty/channel/socket/DatagramChannelConfig.java, + int getReceivePacketSize();, +, + void setReceivePacketSize(int receivePacketSize);, +, +++ b/transport/src/main/java/io/netty/channel/socket/DefaultDatagramChannelConfig.java, + private static int DEFAULT_RECEIVE_PACKET_SIZE = 2048;, +, + private volatile int receivePacketSize = DEFAULT_RECEIVE_PACKET_SIZE;, + IP_MULTICAST_ADDR, IP_MULTICAST_IF, IP_MULTICAST_TTL, IP_TOS, UDP_RECEIVE_PACKET_SIZE);, + if (option == UDP_RECEIVE_PACKET_SIZE) {, + return (T) Integer.valueOf(getReceivePacketSize());, + },
[+++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java, +, + @Override, + protected void freeOutboundMessage(OUTBOUND_IN msg) throws Exception {, + MessageToMessageCodec.this.freeOutboundMessage(msg);, + }, +, + @Override, + protected void freeInboundMessage(INBOUND_IN msg) throws Exception {, + MessageToMessageCodec.this.freeInboundMessage(msg);, + }, +, + protected void freeInboundMessage(INBOUND_IN msg) throws Exception {, + ChannelHandlerUtil.freeMessage(msg);, + }, +, + protected void freeOutboundMessage(OUTBOUND_IN msg) throws Exception {, + ChannelHandlerUtil.freeMessage(msg);, + }]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/example/src/main/java/io/netty/example/http2/helloworld/multiplex/server/HelloWorldHttp2Handler.java, + content.writeBytes(RESPONSE_BYTES.duplicate());]
[+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundHandler.java, + @Deprecated]
[+++ b/codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java, + private int discardedBytes;, + if (!discarding) {, + if (eol >= 0) {, + final int delimLength = buffer.getByte(eol) == '\r'? 2 : 1;, +, + if (length > maxLength) {, + buffer.readerIndex(eol + delimLength);, + fail(ctx, length);, + return null;, +, + return frame;, + } else {, + final int length = buffer.readableBytes();, + if (length > maxLength) {, + discardedBytes = length;, + buffer.readerIndex(buffer.writerIndex());, + fail(ctx, "over " + discardedBytes);, + } else {, + if (eol >= 0) {, + final int length = discardedBytes + eol - buffer.readerIndex();, + final int
[+++ b/all/pom.xml, +++ b/all/pom.xml, +++ b/microbench/pom.xml, +++ b/all/pom.xml, +++ b/microbench/pom.xml, +++ b/pom.xml, + <plugin>, + <groupId>org.codehaus.mojo</groupId>, + <artifactId>xml-maven-plugin</artifactId>, + <version>1.0.1</version>, + <executions>, + <execution>, + <id>check-style</id>, + <goals>, + <goal>check-format</goal>, + </goals>, + <phase>validate</phase>, + </execution>, + </executions>, + <configuration>, + <formatFileSets>, + <formatFileSet>, + <directory>${project.basedir}</directory>, + <includes>, + <include>**/pom.xml</include>, + </includes>, + </formatFileSet>, + </formatFileSets>, + <useDefaultFormatFileSet>false</useDefaultFormatFileSet>, + </configuration>, + </plugin>, +++ b/all/pom.xml, +++ b/microbench/pom.xml, +++ b/pom.xml, + <plugin>, + <groupId>org.codehaus.mojo</groupId>, + <artifactId>xml-maven-plugin</artifactId>, + <version>1.0.1</version>, + <executions>, + <execution>, + <id>check-style</id>, + <goals>, + <goal>check-format</goal>, + </goals>, + <phase>validate</phase>, + </execution>, + </executions>, + <configuration>, + <formatFileSets>, +
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + private volatile Queue<Object> inBridge;, + private volatile Queue<Object> outBridge;, + private volatile NextBridgeFeeder nextInBridgeFeeder;, + private volatile NextBridgeFeeder nextOutBridgeFeeder;, + @SuppressWarnings("rawtypes"), + private static final AtomicReferenceFieldUpdater<DefaultChannelHandlerContext, Queue> IN_BRIDGE_UPDATER =, + AtomicReferenceFieldUpdater.newUpdater(DefaultChannelHandlerContext.class, Queue.class, "inBridge");, + @SuppressWarnings("rawtypes"), + private static final AtomicReferenceFieldUpdater<DefaultChannelHandlerContext, Queue> OUT_BRIDGE_UPDATER =, + AtomicReferenceFieldUpdater.newUpdater(DefaultChannelHandlerContext.class, Queue.class, "outBridge");, + private static final AtomicReferenceFieldUpdater<DefaultChannelHandlerContext, NextBridgeFeeder>, + NEXT_IN_BRIDGE_FEEDER = AtomicReferenceFieldUpdater.newUpdater(, + DefaultChannelHandlerContext.class, NextBridgeFeeder.class, "nextInBridgeFeeder");, + private static final AtomicReferenceFieldUpdater<DefaultChannelHandlerContext, NextBridgeFeeder>, + NEXT_OUT_BRIDGE_FEEDER = AtomicReferenceFieldUpdater.newUpdater(, + DefaultChannelHandlerContext.class, NextBridgeFeeder.class, "nextOutBridgeFeeder");, + Queue<Object> inBridge = this.inBridge;, + if (inBridge == null) {, + return flushBridge(inBridge, inMsgBuf, inByteBuf);, + }, + Queue<Object> outBridge
[+++ b/pom.xml, + <version>3.1.0.Alpha1-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/microbench/src/main/java/io/netty/handler/codec/CodecOutputListBenchmark.java, + codecOutputList = CodecOutputList.newInstance();, + recycleableArrayList = RecyclableArrayList.newInstance(16);, + arrayList = new ArrayList<Object>(16);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketFrameAggregator.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + synchronized (OpenSslEngine.this) {, + if (!isDestroyed()) {, + SSL.setTimeout(ssl, 0);, + }, + }, + synchronized (OpenSslEngine.this) {, + if (!isDestroyed()) {, + return System.currentTimeMillis() - (SSL.getTimeout(ssl) * 1000L) < (SSL.getTime(ssl) * 1000L);, + }, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + synchronized (OpenSslEngine.this) {, + if (!isDestroyed()) {, + SSL.setTimeout(ssl, 0);, + }, + }, + synchronized (OpenSslEngine.this) {, + if (!isDestroyed()) {, + return System.currentTimeMillis() - (SSL.getTimeout(ssl) * 1000L) < (SSL.getTime(ssl) * 1000L);, + }, + }, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, + public void testSessionInvalidate() throws Exception {, + assumeTrue(OpenSsl.isAvailable());, + super.testSessionInvalidate();, + }, +, + @Override, +++
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + *, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + *, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java, +/**, + * @apiviz.has io.netty.buffer.ByteBuf oneway - - creates, + */, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + *, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java, +/**, + * @apiviz.has io.netty.buffer.ByteBuf oneway - - creates, + */, +++ b/buffer/src/main/java/io/netty/buffer/MessageBuf.java, + *, + * @apiviz.landmark, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + *, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java, +/**, + * @apiviz.has io.netty.buffer.ByteBuf oneway - - creates, + */, +++ b/buffer/src/main/java/io/netty/buffer/MessageBuf.java, + *, + * @apiviz.landmark, +++ b/buffer/src/main/java/io/netty/buffer/package-info.java, + * @apiviz.exclude netty\.((?!buffer).)+$, + * @apiviz.exclude (In|Out)putStream$, + * @apiviz.exclude \.(Abstract|Default)((?!ByteBufAllocator).)*$, + * @apiviz.exclude \.(BufType|BufUtil)$, + * @apiviz.exclude \.[^\.]+Exception$, + * @apiviz.exclude \.(Empty|Swapped|Default|Sliced|Duplicated|ReadOnly)[^\.]*ByteBuf$, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + *,
[+++ b/COPYRIGHT.txt, +ataylor Andy Taylor, +++ b/COPYRIGHT.txt, +ataylor Andy Taylor, +++ b/src/main/java/org/jboss/netty/example/http/HttpClient.java, +/*, + * JBoss, Home of Professional Open Source, + * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors, + * by the @authors tag. See the copyright.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at
[+++ b/common/src/main/java/io/netty/util/AsciiString.java, + for (int i = 0; i < a.length(); ++i) {, + if (!equalsIgnoreCase(a.charAt(i), b.charAt(i))) {, +++ b/common/src/main/java/io/netty/util/AsciiString.java, + for (int i = 0; i < a.length(); ++i) {, + if (!equalsIgnoreCase(a.charAt(i), b.charAt(i))) {, +++ b/common/src/test/java/io/netty/util/AsciiStringCharacterTest.java, + assertThat(AsciiString.contentEqualsIgnoreCase("FoO", "bar"), is(false));, + assertThat(AsciiString.contentEqualsIgnoreCase("Foo", "foobar"), is(false));, + assertThat(AsciiString.contentEqualsIgnoreCase("foobar", "Foo"), is(false));]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + return localEndpoint.lastStreamKnownByPeer >= 0;, + localEndpoint.lastStreamKnownByPeer(lastKnownStream);, + return remoteEndpoint.lastStreamKnownByPeer >= 0;, + remoteEndpoint.lastStreamKnownByPeer(lastKnownStream);, + private int lastStreamKnownByPeer = -1;, + public int lastStreamKnownByPeer() {, + return lastStreamKnownByPeer;, + private void lastStreamKnownByPeer(int lastKnownStream) {, + this.lastStreamKnownByPeer = lastKnownStream;, + if (goAwayReceived() && streamId > localEndpoint.lastStreamKnownByPeer()) {, + localEndpoint.lastStreamKnownByPeer());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + return localEndpoint.lastStreamKnownByPeer >= 0;, + localEndpoint.lastStreamKnownByPeer(lastKnownStream);, + return remoteEndpoint.lastStreamKnownByPeer >= 0;, + remoteEndpoint.lastStreamKnownByPeer(lastKnownStream);, + private int lastStreamKnownByPeer = -1;, + public int lastStreamKnownByPeer() {, + return lastStreamKnownByPeer;, + private void lastStreamKnownByPeer(int lastKnownStream) {, + this.lastStreamKnownByPeer = lastKnownStream;, + if (goAwayReceived() && streamId > localEndpoint.lastStreamKnownByPeer()) {, +
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return setCharSequence0(index, sequence, charset, false);, + }, +, + private int setCharSequence0(int index, CharSequence sequence, Charset charset, boolean expand) {, + int length = ByteBufUtil.utf8MaxBytes(sequence);, + if (expand) {, + ensureWritable0(length);, + checkIndex0(index, length);, + } else {, + checkIndex(index, length);, + }, + int length = sequence.length();, + if (expand) {, + ensureWritable0(length);, + checkIndex0(index, length);, + } else {, + checkIndex(index, length);, + }, + return ByteBufUtil.writeAscii(this, index, sequence, length);, + if (expand) {, + // setBytes(...) will take care of checking the indices., + }, + int written = setCharSequence0(writerIndex, sequence, charset, true);,
[+++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpServerChannelConfig.java, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpServerChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelConfig.java, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpServerChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpServerChannelConfig.java, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpServerChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpServerChannelConfig.java, +++ b/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtChannelConfig.java, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpServerChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpServerChannelConfig.java, +++ b/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtChannelConfig.java, +++ b/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtServerChannelConfig.java, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpServerChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpServerChannelConfig.java, +++ b/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtChannelConfig.java, +++ b/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtServerChannelConfig.java, +++ b/transport-udt/src/main/java/io/netty/channel/udt/UdtChannelConfig.java, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpServerChannelConfig.java, +++
[+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompFrame.java, + this(command, content, null);, + }, +, + DefaultStompFrame(StompCommand command, ByteBuf content, DefaultStompHeaders headers) {, + super(command, headers);, +, +, + return new DefaultStompFrame(command, content, headers.copy());, +++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompFrame.java, + this(command, content, null);, + }, +, + DefaultStompFrame(StompCommand command, ByteBuf content, DefaultStompHeaders headers) {, + super(command, headers);, +, +, + return new DefaultStompFrame(command, content, headers.copy());, +++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompHeaders.java, +import io.netty.handler.codec.CharSequenceValueConverter;, +import io.netty.handler.codec.DefaultHeaders;, +import io.netty.handler.codec.HeadersUtils;, +, +, + @Override, + public DefaultStompHeaders copy() {, + DefaultStompHeaders copyHeaders = new DefaultStompHeaders();, + copyHeaders.addImpl(this);, + return copyHeaders;, + }, +++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompFrame.java, + this(command, content, null);, + }, +, + DefaultStompFrame(StompCommand command, ByteBuf
[+++ b/codec/src/main/java/io/netty/handler/codec/redis/Command.java, + static final byte[] ARGS_PREFIX = "*".getBytes();, + static final byte[] CRLF = "\r\n".getBytes();, + static final byte[] BYTES_PREFIX = "$".getBytes();, + static final byte[] EMPTY_BYTES = new byte[0];, + static final byte[] NEG_ONE_AND_CRLF = convertWithCRLF(-1);, +++ b/codec/src/main/java/io/netty/handler/codec/redis/Command.java, + static final byte[] ARGS_PREFIX = "*".getBytes();, + static final byte[] CRLF = "\r\n".getBytes();, + static final byte[] BYTES_PREFIX = "$".getBytes();, + static final byte[] EMPTY_BYTES = new byte[0];, + static final byte[] NEG_ONE_AND_CRLF = convertWithCRLF(-1);, +++ b/codec/src/main/java/io/netty/handler/codec/redis/RedisDecoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/redis/Command.java, + static final byte[] ARGS_PREFIX = "*".getBytes();, + static final byte[] CRLF = "\r\n".getBytes();, + static final byte[] BYTES_PREFIX
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DefaultHttpDataFactory.java, +, + @Override, + public void cleanRequestHttpDatas(HttpRequest request) {, + cleanRequestHttpData(request);, + }, +, + @Override, + public void cleanAllHttpDatas() {, + cleanAllHttpData();, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DefaultHttpDataFactory.java, +, + @Override, + public void cleanRequestHttpDatas(HttpRequest request) {, + cleanRequestHttpData(request);, + }, +, + @Override, + public void cleanAllHttpDatas() {, + cleanAllHttpData();, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpDataFactory.java, +, + /**, + * @deprecated Use {@link #cleanRequestHttpData(HttpRequest)} instead., + */, + @Deprecated, + void cleanRequestHttpDatas(HttpRequest request);, +, + /**, + * @deprecated Use {@link #cleanAllHttpData()} instead., + */, + @Deprecated, + void cleanAllHttpDatas();]
[+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, + logger.debug("-Dio.netty.allocator.numHeapArenas: {}", DEFAULT_NUM_HEAP_ARENA);, + logger.debug("-Dio.netty.allocator.numDirectArenas: {}", DEFAULT_NUM_DIRECT_ARENA);, + logger.debug("-Dio.netty.allocator.pageSize: {}", DEFAULT_PAGE_SIZE);, + logger.debug("-Dio.netty.allocator.pageSize: {}", DEFAULT_PAGE_SIZE, pageSizeFallbackCause);, + logger.debug("-Dio.netty.allocator.maxOrder: {}", DEFAULT_MAX_ORDER);, + logger.debug("-Dio.netty.allocator.maxOrder: {}", DEFAULT_MAX_ORDER, maxOrderFallbackCause);, + logger.debug("-Dio.netty.allocator.chunkSize: {}", DEFAULT_PAGE_SIZE << DEFAULT_MAX_ORDER);, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, + logger.debug("-Dio.netty.allocator.numHeapArenas: {}", DEFAULT_NUM_HEAP_ARENA);, + logger.debug("-Dio.netty.allocator.numDirectArenas: {}", DEFAULT_NUM_DIRECT_ARENA);, + logger.debug("-Dio.netty.allocator.pageSize: {}", DEFAULT_PAGE_SIZE);, + logger.debug("-Dio.netty.allocator.pageSize: {}", DEFAULT_PAGE_SIZE, pageSizeFallbackCause);, + logger.debug("-Dio.netty.allocator.maxOrder: {}", DEFAULT_MAX_ORDER);, + logger.debug("-Dio.netty.allocator.maxOrder: {}", DEFAULT_MAX_ORDER, maxOrderFallbackCause);, + logger.debug("-Dio.netty.allocator.chunkSize: {}", DEFAULT_PAGE_SIZE << DEFAULT_MAX_ORDER);, +++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java, + logger.debug("-Dio.netty.noResourceLeakDetection: {}", DISABLED);, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, + logger.debug("-Dio.netty.allocator.numHeapArenas: {}", DEFAULT_NUM_HEAP_ARENA);, + logger.debug("-Dio.netty.allocator.numDirectArenas: {}", DEFAULT_NUM_DIRECT_ARENA);, + logger.debug("-Dio.netty.allocator.pageSize: {}", DEFAULT_PAGE_SIZE);, + logger.debug("-Dio.netty.allocator.pageSize: {}", DEFAULT_PAGE_SIZE, pageSizeFallbackCause);, + logger.debug("-Dio.netty.allocator.maxOrder: {}", DEFAULT_MAX_ORDER);, + logger.debug("-Dio.netty.allocator.maxOrder:
[+++ b/all/pom.xml, + <properties>, + <quickbuild>true</quickbuild>, + </properties>, +, + <profiles>, + <profile>, + <id>full</id>, + <properties>, + <quickbuild>false</quickbuild>, + </properties>, + </profile>, + <profile>, + <id>sonatype-oss-release</id>, + <properties>, + <quickbuild>false</quickbuild>, + </properties>, + </profile>, + <profile>, + <id>release</id>, + <properties>, + <quickbuild>false</quickbuild>, + </properties>, + </profile>, + </profiles>, +, + <skip>${quickbuild}</skip>, + </execution>, + </executions>, + <skip>${quickbuild}</skip>, +++ b/all/pom.xml, + <properties>, + <quickbuild>true</quickbuild>, + </properties>, +, + <profiles>, + <profile>, + <id>full</id>, + <properties>, + <quickbuild>false</quickbuild>, + </properties>, + </profile>, + <profile>, + <id>sonatype-oss-release</id>, + <properties>, + <quickbuild>false</quickbuild>, + </properties>, + </profile>, + <profile>, + <id>release</id>, + <properties>,
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java, + static final String ROOT = ".";, +, + return ROOT;, +, + while (in.isReadable()) {, + final int len = in.readUnsignedByte();, + final boolean pointer = (len & 0xc0) == 0xc0;, + if (!in.isReadable()) {, + throw new CorruptedFrameException("truncated pointer in a name");, + }, +, + } else if (len != 0) {, + if (!in.isReadable(len)) {, + throw new CorruptedFrameException("truncated label in a name");, + }, + } else { // len == 0, + break;, +, +, + return ROOT;, + if (name.charAt(name.length() - 1) != '.') {, + name.append('.');, + }, +,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, + final long contentLength = contentLength(msg);, + private void encodeChunkedContent(ChannelHandlerContext ctx, Object msg, long contentLength, List<Object> out) {, + byte[] length = Long.toHexString(contentLength).getBytes(CharsetUtil.US_ASCII);, + private static long contentLength(Object msg) {, + return ((FileRegion) msg).count();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, + final long contentLength = contentLength(msg);, + private void encodeChunkedContent(ChannelHandlerContext ctx, Object msg, long contentLength, List<Object> out) {, + byte[] length = Long.toHexString(contentLength).getBytes(CharsetUtil.US_ASCII);, + private static long contentLength(Object msg) {, + return ((FileRegion) msg).count();, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseEncoderTest.java, +/*, +* Copyright 2014 The Netty Project, +*, +* The Netty Project licenses this file to you under the Apache License,, +* version 2.0 (the
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java, + private static final float HEADERS_COUNT_WEIGHT_NEW = 1 / 5f;]
[+++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.buffer.ChannelBuffer;, +import io.netty.buffer.ChannelBuffers;, +import io.netty.channel.ChannelBufferHolder;, +import io.netty.channel.ChannelBufferHolders;, +import io.netty.channel.ChannelInboundHandlerAdapter;, +import io.netty.channel.ChannelInboundHandlerContext;, +import io.netty.channel.EventLoop;, +import io.netty.channel.MultithreadEventLoop;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.channel.socket.nio.NioSocketChannel;, +import io.netty.channel.socket.nio.SelectorEventLoop;, +import io.netty.handler.logging.LoggingHandler;, +import io.netty.logging.InternalLogLevel;, +import java.net.InetSocketAddress;, +import java.util.concurrent.atomic.AtomicLong;, + private final AtomicLong transferredBytes = new AtomicLong();, + public void run() throws Exception {, + EventLoop loop = new MultithreadEventLoop(SelectorEventLoop.class);, + SocketChannel s = new NioSocketChannel();, + s.config().setTcpNoDelay(true);, + s.pipeline().addLast("logger", new LoggingHandler(InternalLogLevel.INFO));, + s.pipeline().addLast("echoer", new ChannelInboundHandlerAdapter<Byte>() {, + private final ChannelBuffer firstMessage;, + {, + if (firstMessageSize <= 0) {, + throw new IllegalArgumentException(, + "firstMessageSize: " + firstMessageSize);, + }, + firstMessage = ChannelBuffers.buffer(firstMessageSize);, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, + OpenSslKeyMaterialProvider.validateKeyMaterialSupported(keyCertChain, key, keyPassword);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, + OpenSslKeyMaterialProvider.validateKeyMaterialSupported(keyCertChain, key, keyPassword);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterialProvider.java, +import io.netty.buffer.UnpooledByteBufAllocator;, +import javax.net.ssl.SSLException;, + static void validateKeyMaterialSupported(X509Certificate[] keyCertChain, PrivateKey key, String keyPassword), + throws SSLException {, + validateSupported(keyCertChain);, + validateSupported(key, keyPassword);, + }, +, + private static void validateSupported(PrivateKey key, String password) throws SSLException {, + if (key == null) {, + return;, + }, +, + long pkeyBio = 0;, + long pkey = 0;, +, + try {, + pkeyBio = toBIO(UnpooledByteBufAllocator.DEFAULT, key);, + pkey = SSL.parsePrivateKey(pkeyBio, password);, + } catch (Exception e) {, + throw new SSLException("PrivateKey type not supported "
[+++ b/example/src/main/java/io/netty/example/memcache/binary/MemcacheClientHandler.java, + res.release();]
[+++ b/transport-sctp/src/main/java/com/sun/nio/sctp/SctpChannel.java, +import java.net.InetAddress;, +, + public abstract SctpChannel bindAddress(InetAddress inetAddress) throws IOException;, + public abstract SctpChannel unbindAddress(InetAddress inetAddress) throws IOException;, +, +++ b/transport-sctp/src/main/java/com/sun/nio/sctp/SctpChannel.java, +import java.net.InetAddress;, +, + public abstract SctpChannel bindAddress(InetAddress inetAddress) throws IOException;, + public abstract SctpChannel unbindAddress(InetAddress inetAddress) throws IOException;, +, +++ b/transport-sctp/src/main/java/com/sun/nio/sctp/SctpServerChannel.java, +import java.net.InetAddress;, +, + public abstract SctpServerChannel bindAddress(InetAddress inetAddress) throws IOException;, + public abstract SctpServerChannel unbindAddress(InetAddress inetAddress) throws IOException;, +, +++ b/transport-sctp/src/main/java/com/sun/nio/sctp/SctpChannel.java, +import java.net.InetAddress;, +, + public abstract SctpChannel bindAddress(InetAddress inetAddress) throws IOException;, + public abstract SctpChannel unbindAddress(InetAddress inetAddress) throws IOException;, +, +++ b/transport-sctp/src/main/java/com/sun/nio/sctp/SctpServerChannel.java, +import java.net.InetAddress;, +, + public abstract SctpServerChannel bindAddress(InetAddress inetAddress)
[+++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +import java.util.ArrayList;, +import java.util.Iterator;, +import java.util.List;, + if (!isOrderedMap(pipelineMap)) {, +, + /**, + * Returns {@code true} if and only if the specified {@code map} is an, + * ordered map, like {@link LinkedHashMap} is., + */, + @SuppressWarnings("unchecked"), + static boolean isOrderedMap(Map<?, ?> map) {, + Class<?> mapType = map.getClass();, + if (LinkedHashMap.class.isAssignableFrom(mapType)) {, + // LinkedHashMap is an ordered map., + return true;, + }, +, + // Not a LinkedHashMap - start autodetection., +, + // Detect Apache Commons Collections OrderedMap implementations., + Class<?> type = mapType;, + while (type != null) {,
[+++ b/pom.xml, + <version>2.2.6</version>]
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java, +import io.netty.util.concurrent.ImmediateEventExecutor;, + promise = new DefaultChannelPromise(channel, ImmediateEventExecutor.INSTANCE);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java, +import io.netty.util.concurrent.ImmediateEventExecutor;, + promise = new DefaultChannelPromise(channel, ImmediateEventExecutor.INSTANCE);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, + private Object listeners;, + * The logic in this method should be identical to {@link #notifyListeners()} but]
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramConnectNotExistsTest.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + return refCnt0();, + }, +, + int refCnt0() {, + return retain0();, + }, +, + ByteBuf retain0() {, + return retain0(increment);, + }, +, + ByteBuf retain0(int increment) {, + return touch0();, + }, +, + ByteBuf touch0() {, + return touch0(hint);, + }, +, + ByteBuf touch0(Object hint) {, + return release0();, + }, +, + boolean release0() {, + boolean release0(int decrement) {, + return unwrap().release(decrement);, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + return refCnt0();, + }, +, + int refCnt0() {, + return retain0();, + }, +, + ByteBuf retain0() {, + return
[+++ b/resolver/src/main/java/io/netty/resolver/RoundRobinInetAddressResolver.java, +import io.netty.util.internal.ThreadLocalRandom;, + promise.setSuccess(inetAddresses.get(randomIndex(numAddresses)));, + Collections.rotate(result, randomIndex(inetAddresses.size()));, +, + private static int randomIndex(int numAddresses) {, + return numAddresses == 1 ? 0 : ThreadLocalRandom.current().nextInt(numAddresses);, + }]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslCertificateException.java, + * SSL Record. This only work when {@link SslProvider#OPENSSL} or {@link SslProvider#OPENSSL_REFCNT} is used., + * Return the <a href="https://www.openssl.org/docs/man1.0.2/apps/verify.html">error code</a> to use., + if (!CertificateVerifier.isValid(errorCode)) {, + throw new IllegalArgumentException("errorCode '" + errorCode +, + "' invalid, see https://www.openssl.org/docs/man1.0.2/apps/verify.html.");, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslCertificateException.java, + * SSL Record. This only work when {@link SslProvider#OPENSSL} or {@link SslProvider#OPENSSL_REFCNT} is used., + * Return the <a href="https://www.openssl.org/docs/man1.0.2/apps/verify.html">error code</a> to use., + if (!CertificateVerifier.isValid(errorCode)) {, + throw new IllegalArgumentException("errorCode '" + errorCode +, + "' invalid, see https://www.openssl.org/docs/man1.0.2/apps/verify.html.");, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, + abstract static class AbstractCertificateVerifier extends CertificateVerifier {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslCertificateException.java, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandler.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java, + markReaderIndex();, + markWriterIndex();, +++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java, + markReaderIndex();, + markWriterIndex();, +++ b/buffer/src/test/java/io/netty/buffer/DuplicateByteBufTest.java, +import static org.junit.Assert.assertEquals;, + ByteBuf wrapped = Unpooled.buffer(length);, + buffer = new DuplicatedByteBuf(wrapped);, + assertEquals(wrapped.writerIndex(), buffer.writerIndex());, + assertEquals(wrapped.readerIndex(), buffer.readerIndex());, +, + @Test, + public void testMarksInitialized() {, + ByteBuf wrapped = Unpooled.buffer(8);, + try {, + wrapped.writerIndex(6);, + wrapped.readerIndex(1);, + ByteBuf duplicate = new DuplicatedByteBuf(wrapped);, +, + // Test writer mark, + duplicate.writerIndex(duplicate.writerIndex() + 1);, + duplicate.resetWriterIndex();, + assertEquals(wrapped.writerIndex(), duplicate.writerIndex());, +, + // Test reader mark, + duplicate.readerIndex(duplicate.readerIndex() + 1);, + duplicate.resetReaderIndex();, + assertEquals(wrapped.readerIndex(), duplicate.readerIndex());, + } finally {, + wrapped.release();, + }, + },
[+++ b/pom.xml, + <version>3.1.0.BETA3</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.1.0.BETA3</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.1.0.BETA3</developerConnection>]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + boolean release = false;, + release = true;, + if (release) {, + }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + boolean release = false;, + release = true;, + if (release) {, + }, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java, + try {, + assertEquals(1, data.refCnt());, + } finally {, + data.release();, + }]
[+++ b/transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannel.java]
[+++ b/all/pom.xml, + <version>4.0.14.Final</version>, +++ b/all/pom.xml, + <version>4.0.14.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final</version>, +++ b/all/pom.xml, + <version>4.0.14.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final</version>, +++ b/all/pom.xml, + <version>4.0.14.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Final</version>, +++ b/all/pom.xml, + <version>4.0.14.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec/pom.xml, + <version>4.0.14.Final</version>, +++ b/all/pom.xml, + <version>4.0.14.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec/pom.xml, + <version>4.0.14.Final</version>, +++ b/common/pom.xml, + <version>4.0.14.Final</version>, +++ b/all/pom.xml, + <version>4.0.14.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/ZlibEncoder.java, + * Compresses a {@link ByteBuf} using the deflate algorithm.]
[+++ b/common/src/main/java/io/netty/util/internal/jzlib/InfBlocks.java, +, +, + , +, +, + , +, +, +, +, +++ b/common/src/main/java/io/netty/util/internal/jzlib/InfBlocks.java, +, +, + , +, +, + , +, +, +, +, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +, +++ b/common/src/main/java/io/netty/util/internal/jzlib/InfBlocks.java, +, +, + , +, +, + , +, +, +, +, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Exception e) {, +++ b/common/src/main/java/io/netty/util/internal/jzlib/InfBlocks.java, +, +, + , +, +, + , +, +, +, +, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Exception e) {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +import java.io.IOException;, +import java.net.InetSocketAddress;, +import java.net.SocketAddress;, +import java.nio.channels.NotYetConnectedException;, +import java.nio.channels.SelectionKey;, +, + EventLoop eventLoop();, +, +,
[+++ b/transport/src/test/java/io/netty/channel/nio/NioEventLoopTest.java, +import io.netty.channel.Channel;, +import org.junit.Test;, +, +import java.nio.channels.Selector;, +, +import static org.junit.Assert.*;, +, + @Test, + public void testRebuildSelector() throws Exception {, + EventLoopGroup group = new NioEventLoopGroup(1);, + final NioEventLoop loop = (NioEventLoop) group.next();, + try {, + Channel channel = new NioServerSocketChannel();, + loop.register(channel).syncUninterruptibly();, +, + Selector selector = loop.unwrappedSelector();, + assertSame(selector, ((NioEventLoop) channel.eventLoop()).unwrappedSelector());, + assertTrue(selector.isOpen());, +, + // Submit to the EventLoop so we are sure its really executed in a non-async manner., + loop.submit(new Runnable() {, + @Override, + public void run() {, + loop.rebuildSelector();, + }, + }).syncUninterruptibly();, +, + Selector newSelector =
[+++ b/common/pom.xml, + <plugin>, + <groupId>org.apache.felix</groupId>, + <artifactId>maven-bundle-plugin</artifactId>, + <version>2.4.0</version>, + <executions>, + <execution>, + <id>generate-manifest</id>, + <phase>process-classes</phase>, + <goals>, + <goal>manifest</goal>, + </goals>, + <configuration>, + <instructions>, + <!-- NativeLibraryLoader can be used to manually load native libraries from other bundles that this bundle does not depend on,, + hence use DynamicImport-Package instruction to ensure the loading is successful -->, + <DynamicImport-Package>*</DynamicImport-Package>, + </instructions>, + </configuration>, + </execution>, + </executions>, + </plugin>, +++ b/common/pom.xml, + <plugin>, + <groupId>org.apache.felix</groupId>, + <artifactId>maven-bundle-plugin</artifactId>, + <version>2.4.0</version>, + <executions>, + <execution>, + <id>generate-manifest</id>, + <phase>process-classes</phase>, + <goals>, + <goal>manifest</goal>, + </goals>, + <configuration>,
[+++ b/codec/src/main/java/io/netty/handler/codec/CodecOutputList.java, +import io.netty.util.concurrent.FastThreadLocal;, +import io.netty.util.internal.MathUtil;, + private static final CodecOutputListRecycler NOOP_RECYCLER = new CodecOutputListRecycler() {, + public void recycle(CodecOutputList object) {, + // drop on the floor and let the GC handle it., + private static final FastThreadLocal<CodecOutputLists> CODEC_OUTPUT_LISTS_POOL =, + new FastThreadLocal<CodecOutputLists>() {, + @Override, + protected CodecOutputLists initialValue() throws Exception {, + // 16 CodecOutputList per Thread are cached., + return new CodecOutputLists(16);, + }, + };, +, + private interface CodecOutputListRecycler {, + void recycle(CodecOutputList codecOutputList);, + private static final class CodecOutputLists implements CodecOutputListRecycler {, + private final CodecOutputList[] elements;, + private final int mask;,
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return new SlicedAbstractByteBuf(this, index, length);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return new SlicedAbstractByteBuf(this, index, length);, +++ b/buffer/src/main/java/io/netty/buffer/SlicedAbstractByteBuf.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed
[+++ b/all/pom.xml, + <includeGroupIds>${project.groupId}</includeGroupIds>, +++ b/all/pom.xml, + <includeGroupIds>${project.groupId}</includeGroupIds>, +++ b/pom.xml, +++ b/all/pom.xml, + <includeGroupIds>${project.groupId}</includeGroupIds>, +++ b/pom.xml, +++ b/tarball/assembly.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<assembly, + xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2", + xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance", + xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2 http://maven.apache.org/xsd/assembly-1.1.2.xsd">, + <id>tarball</id>, + <formats>, + <format>tar.bz2</format>, + </formats>, + <includeBaseDirectory>false</includeBaseDirectory>, + <fileSets>, + <fileSet>, + <directory>${project.basedir}/..</directory>, + <outputDirectory/>, + <includes>, + <include>*.txt</include>, + <include>*.md</include>, + </includes>, + </fileSet>, + <fileSet>, + <directory>${project.basedir}/..</directory>, + <outputDirectory/>, + <includes>, + <include>license/**/*.txt</include>, + <include>license/**/*.md</include>, + </includes>, + </fileSet>, + <fileSet>, + <directory>target/jars</directory>, + <outputDirectory>jar</outputDirectory>, + <includes>, + <include>**/*.jar</include>, + </includes>, + </fileSet>, + <fileSet>, + <directory>target/jars-all</directory>, + <outputDirectory>jar/all-in-one</outputDirectory>, + <includes>, + <include>**/*.jar</include>, + </includes>,
[+++ b/pom.xml, + <echo message="${project.version}, r${buildNumber}" file="${basedir}/target/version.txt" />]
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsRecord.java, +import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;, + checkPositiveOrZero(timeToLive, "timeToLive");, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsRecord.java, +import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;, + checkPositiveOrZero(timeToLive, "timeToLive");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, + throw new IllegalArgumentException("a header name cannot contain non-ASCII character: " + value);, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsRecord.java, +import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;, + checkPositiveOrZero(timeToLive, "timeToLive");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, + throw new IllegalArgumentException("a header name cannot contain non-ASCII character: " + value);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +import static io.netty.util.internal.ObjectUtil.checkPositive;, +, + checkPositive(maxInitialLineLength, "maxInitialLineLength");, + checkPositive(maxHeaderSize, "maxHeaderSize");, + checkPositive(maxChunkSize, "maxChunkSize");, +, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsRecord.java, +import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;, + checkPositiveOrZero(timeToLive, "timeToLive");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, + throw new IllegalArgumentException("a header name cannot contain non-ASCII character: " + value);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +import static io.netty.util.internal.ObjectUtil.checkPositive;, +,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeaderBlock.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeaderBlock.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeadersFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeaderBlock.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeadersFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyNoOpFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeaderBlock.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeadersFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyNoOpFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeaderBlock.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeadersFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyNoOpFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyRstStreamFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeaderBlock.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeadersFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyNoOpFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyRstStreamFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeaderBlock.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeadersFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyNoOpFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyRstStreamFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySynReplyFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeaderBlock.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeadersFrame.java, +++
[+++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketTest.java, +import org.junit.BeforeClass;, +import static org.junit.Assume.assumeTrue;, + @BeforeClass, + public static void loadJNI() {, + assumeTrue(Epoll.isAvailable());, + }, +, +++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketTest.java, +import org.junit.BeforeClass;, +import static org.junit.Assume.assumeTrue;, + @BeforeClass, + public static void loadJNI() {, + assumeTrue(Epoll.isAvailable());, + }, +, +++ b/transport-native-kqueue/src/test/java/io/netty/channel/kqueue/KQueueSocketTest.java, +import static org.junit.Assume.assumeTrue;, + assumeTrue(KQueue.isAvailable());, +++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketTest.java, +import org.junit.BeforeClass;, +import static org.junit.Assume.assumeTrue;, + @BeforeClass, + public static void loadJNI() {, + assumeTrue(Epoll.isAvailable());, + }, +, +++ b/transport-native-kqueue/src/test/java/io/netty/channel/kqueue/KQueueSocketTest.java, +import static org.junit.Assume.assumeTrue;, + assumeTrue(KQueue.isAvailable());, +++ b/transport-native-unix-common-tests/src/main/java/io/netty/channel/unix/tests/SocketTest.java, +, + @Test, + public void testTrafficClass() throws IOException {, + final int value = 0x1;, + socket.setTrafficClass(value);, + assertEquals(value, socket.getTrafficClass());, + },
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/CookieEncoder.java, + throw new IllegalArgumentException("Cookie value contains an invalid char: " +, + unwrappedValue.charAt(pos));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/CookieEncoder.java, + throw new IllegalArgumentException("Cookie value contains an invalid char: " +, + unwrappedValue.charAt(pos));, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/cookie/ServerCookieEncoderTest.java, +import static org.junit.Assert.assertThat;, +import static org.junit.matchers.JUnitMatchers.containsString;, + public void illegalCharInWrappedValueAppearsInException() {, + try {, + ServerCookieEncoder.STRICT.encode(new DefaultCookie("name", "\"value,\""));, + } catch (IllegalArgumentException e) {, + assertThat(e.getMessage().toLowerCase(), containsString("cookie value contains an invalid char: ,"));, + }, + }, +, + @Test]
[+++ b/codec/src/main/java/io/netty/handler/codec/MessageAggregator.java, + public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {, + // We might need keep reading the channel until the full message is aggregated., + //, + // See https://github.com/netty/netty/issues/6583, + if (currentMessage != null && !ctx.channel().config().isAutoRead()) {, + ctx.read();, + }, + ctx.fireChannelReadComplete();, + }, +, + @Override, +++ b/codec/src/main/java/io/netty/handler/codec/MessageAggregator.java, + public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {, + // We might need keep reading the channel until the full message is aggregated., + //, + // See https://github.com/netty/netty/issues/6583, + if (currentMessage != null && !ctx.channel().config().isAutoRead()) {, + ctx.read();, + }, + ctx.fireChannelReadComplete();, + }, +, +
[+++ b/src/docbook/module/start.xml, + Dealing with a Stream-based Transport, + One Small Caveat of Socket Buffer, + In a stream-based transport such as TCP/IP, received data is stored, + into a socket receive buffer. Unfortunately, the buffer of a, + stream-based transport is not a queue of packets but a queue of bytes., + It means, even if you sent two messages as two independent packets, an, + operating system will not treat them as two messages but as just a, + bunch of bytes. Therefore, there is no guarantee that what you read, + is exactly what your remote
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + public ByteBuf ioBuffer(int initialCapacity) {, + if (PlatformDependent.hasUnsafe()) {, + return directBuffer(initialCapacity);, + }, + return heapBuffer(initialCapacity);, + }, +, + @Override, + public ByteBuf ioBuffer(int initialCapacity, int maxCapacity) {, + if (PlatformDependent.hasUnsafe()) {, + return directBuffer(initialCapacity, maxCapacity);, + }, + return heapBuffer(initialCapacity, maxCapacity);, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + public ByteBuf ioBuffer(int initialCapacity) {, + if (PlatformDependent.hasUnsafe()) {, + return directBuffer(initialCapacity);, + }, + return heapBuffer(initialCapacity);, + }, +, + @Override, + public ByteBuf ioBuffer(int initialCapacity, int maxCapacity) {, + if (PlatformDependent.hasUnsafe()) {, + return directBuffer(initialCapacity, maxCapacity);, + }, + return heapBuffer(initialCapacity, maxCapacity);,
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolveContext.java, +import java.util.ArrayList;, + List<InetAddress> filterResults(List<InetAddress> unfiltered) {, + final Class<? extends InetAddress> inetAddressType = parent.preferredAddressType().addressType();, + final int size = unfiltered.size();, + int numExpected = 0;, + for (int i = 0; i < size; i++) {, + InetAddress address = unfiltered.get(i);, + if (inetAddressType.isInstance(address)) {, + numExpected++;, + }, + }, + if (numExpected == size || numExpected == 0) {, + // If all the results are the preferred type, or none of them are, then we don't need to do any filtering., + return unfiltered;, + }, + List<InetAddress> filtered = new ArrayList<InetAddress>(numExpected);, +
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +, + // Check if this handler was removed before continuing with decoding., + // If it was removed, it is not safe to continue to operate on the buffer., + //, + // See:, + // - https://github.com/netty/netty/issues/4635, + if (ctx.isRemoved()) {, + break;, + }, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +, + // Check if this handler was removed before continuing with decoding., + // If it was removed, it is not safe to continue to operate on the buffer., + //, + // See:, + // - https://github.com/netty/netty/issues/4635, + if (ctx.isRemoved()) {, + break;, + }, +++
[+++ b/all/pom.xml, + <version>4.1.0.CR7</version>, +++ b/all/pom.xml, + <version>4.1.0.CR7</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR7</version>, +++ b/all/pom.xml, + <version>4.1.0.CR7</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR7</version>, +++ b/all/pom.xml, + <version>4.1.0.CR7</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR7</version>, +++ b/all/pom.xml, + <version>4.1.0.CR7</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR7</version>, +++ b/all/pom.xml, + <version>4.1.0.CR7</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.CR7</version>, +++ b/all/pom.xml, + <version>4.1.0.CR7</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, + int readable = buffer.readableBytes();, + if (readable > 0) {, + ByteBuf copy;, + if (buffer.isDirect()) {, + copy = directBuffer(readable);, + } else {, + copy = buffer(readable);, + }, + copy.writeBytes(buffer, buffer.readerIndex(), readable);, + return copy;]
[+++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, +package io.netty.bootstrap;, +import io.netty.channel.Channel;, +import io.netty.channel.EventLoopGroup;, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelOption;, +import io.netty.channel.ChannelHandler;, +import io.netty.channel.ChannelException;, +public abstract class Bootstrap<B extends Bootstrap<?>> {, + private ChannelFactory factory;, + private final Map<ChannelOption<?>, Object> options = new LinkedHashMap<ChannelOption<?>, Object>();, + private ChannelHandler handler;, + @SuppressWarnings("unchecked"), + public B group(EventLoopGroup group) {, + return (B) this;, + public B channel(Class<? extends Channel> channelClass) {, + if (channelClass == null) {, + throw new NullPointerException("channelClass");, + return channelFactory(new BootstrapChannelFactory(channelClass));, + @SuppressWarnings("unchecked"), + public B channelFactory(ChannelFactory factory) {, + if (factory == null) {, + throw new NullPointerException("factory");, + }, + if (this.factory !=
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, +import java.text.ParseException;, + public HttpHeaders addInt(CharSequence name, int value) {, + headers.addInt(name, value);, + return this;, + }, +, + @Override, + public HttpHeaders setInt(CharSequence name, int value) {, + headers.setInt(name, value);, + return this;, + }, +, + @Override, + public Integer getInt(CharSequence name) {, + return headers.getInt(name);, + }, +, + @Override, + public int getInt(CharSequence name, int defaultValue) {, + return headers.getInt(name, defaultValue);, + }, +, + @Override, + public Date getDate(CharSequence name) {, + return getDate(name, null);, + }, +, + @Override, + public Date getDate(CharSequence name, Date defaultValue) {, + String value
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadClient.java, +/*, + * Copyright 2011 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the
[+++ b/codec/src/test/java/io/netty/handler/codec/ByteToMessageDecoderTest.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/handler/src/test/java/io/netty/handler/ssl/SniClientTest.java, +import io.netty.util.ReferenceCountUtil;, +import io.netty.util.ReferenceCounted;, + SelfSignedCertificate cert = new SelfSignedCertificate();, + SslContext sslServerContext = null;, + SslContext sslClientContext = null;, +, + final SslContext finalContext = sslServerContext;, + return finalContext;, + sslClientContext = SslContextBuilder.forClient().trustManager(tmf), + sslClientContext.newEngine(ByteBufAllocator.DEFAULT, sniHostName, -1));, + ReferenceCountUtil.release(sslServerContext);, + ReferenceCountUtil.release(sslClientContext);, +, + cert.delete();, +]
[+++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, + bossExecutor.execute(new ThreadRenamingRunnable(, + this, "New I/O client boss #" + id));, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, + bossExecutor.execute(new ThreadRenamingRunnable(, + this, "New I/O client boss #" + id));, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, + bossExecutor.execute(new ThreadRenamingRunnable(, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, + bossExecutor.execute(new ThreadRenamingRunnable(, + this, "New I/O client boss #" + id));, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, + bossExecutor.execute(new ThreadRenamingRunnable(, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, + executor.execute(new ThreadRenamingRunnable(this, threadName));, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, + bossExecutor.execute(new ThreadRenamingRunnable(, + this, "New I/O client boss #" + id));, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, + bossExecutor.execute(new ThreadRenamingRunnable(, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, + executor.execute(new
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java, + if (wrapper == ZlibWrapper.GZIP) {, + protected final ByteBuf allocateBuffer(ChannelHandlerContext ctx, ByteBuf msg,, + boolean preferDirect) throws Exception {, + int sizeEstimate = (int) Math.ceil(msg.readableBytes() * 1.001) + 12;, + if (writeHeader) {, + switch (wrapper) {, + case GZIP:, + sizeEstimate += gzipHeader.length;, + break;, + case ZLIB:, + sizeEstimate += 2; // first two magic bytes, + break;, + }, + }, + return ctx.alloc().heapBuffer(sizeEstimate);, + }, +, + @Override, + ByteBuf footer = ctx.alloc().heapBuffer();, +, + if (!footer.isWritable()) {, + // no more space so write it to the channel and continue, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponse.java, + * <h3>Accessing Cookies</h3>, + * Gets the status of this {@link HttpResponse}., + *, + * @return The {@link HttpResponseStatus} of this {@link HttpResponse}, + * Sets the status of this {@link HttpResponse}, + *, + * @param status The {@link HttpResponseStatus} to use]
[+++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, +import java.io.FileNotFoundException;, + InputStream in = null;, + OutputStream out = null;, + File tmpFile = null;, + try {, + if (url == null) {, + if (PlatformDependent.isOsx()) {, + String fileName = path.endsWith(".jnilib") ? NATIVE_RESOURCE_HOME + "lib" + name + ".dynlib" :, + NATIVE_RESOURCE_HOME + "lib" + name + ".jnilib";, + url = loader.getResource(fileName);, + if (url == null) {, + throw new FileNotFoundException(fileName);, + }, + throw new FileNotFoundException(path);, +, +++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, +import java.io.FileNotFoundException;, + InputStream in = null;, + OutputStream out = null;, + File tmpFile = null;, + try {, + if
[+++ b/src/docbook/en-US/module/start.xml, +public class TimeDecoder extends &FrameDecoder;<co id="example.time4.co1"/> {, + &ChannelHandlerContext; ctx, &Channel; channel, &ChannelBuffer; buffer)<co id="example.time4.co2"/> {, + return null; <co id="example.time4.co3"/>, + return buffer.readBytes(4);<co id="example.time4.co4"/>, + &FrameDecoder; is an implementation of &ChannelHandler; which, + makes it easy to which deals with the fragmentation issue., + </para>, + </callout>, + <callout arearefs="example.time4.co2">, + <para>, + <callout arearefs="example.time4.co3">, + <callout arearefs="example.time4.co4">, + Now, the only missing piece is an encoder, which is an implementation of, + &ChannelHandler; that translates a <classname>UnixTime</classname> back, + into a &ChannelBuffer;. It's much simpler than writing a decoder because, + there's no need to
[+++ b/transport/src/main/java/io/netty/channel/ChannelConfig.java, + * Returns the maximum number of messages to read per read loop., + * If this value is greater than 1, an event loop might attempt to read multiple times to procude multiple messages., + * Sets the maximum number of messages to read per read loop., + * If this value is greater than 1, an event loop might attempt to read multiple times toprocude multiple messages.]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpResponse.java, +, + @Override, + public int hashCode() {, + int result = 1;, + result = 31 * result + status.hashCode();, + result = 31 * result + super.hashCode();, + return result;, + }, +, + @Override, + public boolean equals(Object o) {, + if (!(o instanceof DefaultHttpResponse)) {, + return false;, + }, +, + DefaultHttpResponse other = (DefaultHttpResponse) o;, +, + return status.equals(other.status()) && super.equals(o);, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpResponse.java, +, + @Override, + public int hashCode() {, + int result = 1;, + result = 31 * result + status.hashCode();, + result = 31 *
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java, +, + protected void refreshLocalAddress(Bootstrap bootstrap) {, + addr = new InetSocketAddress(NetUtil.LOCALHOST4, TestUtils.getFreePort());, + bootstrap.localAddress(addr);, + }, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java, +, + protected void refreshLocalAddress(Bootstrap bootstrap) {, + addr = new InetSocketAddress(NetUtil.LOCALHOST4, TestUtils.getFreePort());, + bootstrap.localAddress(addr);, + }, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java, +import io.netty.channel.ChannelInitializer;, +import java.net.BindException;, + sb.handler(new ChannelInitializer<Channel>() {, + @Override, + protected void initChannel(Channel ch) throws Exception {, + ch.pipeline().addLast(new SimpleChannelInboundHandler<DatagramPacket>() {, + for (byte b: bytes) {, + assertEquals(b, buf.readByte());, + }, + });, + Channel sc = null;, + BindException bindFailureCause = null;, + for (int i = 0; i < 3; i ++) {, + try
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + return new MpscChunkedArrayQueue<T>(MPSC_CHUNK_SIZE, capacity);, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + return new MpscChunkedArrayQueue<T>(MPSC_CHUNK_SIZE, capacity);, +++ b/pom.xml, + <version>2.0.1</version>]
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java, +import io.netty.util.concurrent.ImmediateEventExecutor;, + promise = new DefaultChannelPromise(channel, ImmediateEventExecutor.INSTANCE);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java, +import io.netty.util.concurrent.ImmediateEventExecutor;, + promise = new DefaultChannelPromise(channel, ImmediateEventExecutor.INSTANCE);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, + private Object listeners;, + * The logic in this method should be identical to {@link #notifyListeners()} but]
[+++ b/pom.xml, + <artifactId>maven-resources-plugin</artifactId>, + <version>2.3</version>, + <configuration>, + <encoding>UTF-8</encoding>, + </configuration>, + </plugin>, + <plugin>, + <version>2.0.0</version>, + <version>2.1</version>, + <version>2.0-beta-9</version>]
[+++ b/transport/src/main/java/io/netty/channel/ChannelMetadata.java, +++ b/transport/src/main/java/io/netty/channel/ChannelMetadata.java, +++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java, +import io.netty.util.internal.ObjectUtil;, + private static final ChannelMetadata METADATA_NO_DISCONNECT = new ChannelMetadata(false);, + private static final ChannelMetadata METADATA_DISCONNECT = new ChannelMetadata(true);, + private final ChannelMetadata metadata;, + private final ChannelConfig config;, + public EmbeddedChannel(ChannelHandler... handlers) {, + * Create a new instance with the pipeline initialized with the specified handlers., + *, + * @param hasDisconnect {@code false} if this {@link Channel} will delegate {@link #disconnect()}, + * to {@link #close()}, {@link false} otherwise., + * @param handlers the {@link ChannelHandler}s which will be add in the {@link ChannelPipeline}, + */, + public EmbeddedChannel(boolean
[+++ b/src/main/java/org/jboss/netty/container/guice/NettyModule.java, +import org.jboss.netty.channel.local.DefaultLocalClientChannelFactory;, +import org.jboss.netty.channel.local.DefaultLocalServerChannelFactory;, +import org.jboss.netty.channel.local.LocalClientChannelFactory;, +import org.jboss.netty.channel.local.LocalServerChannelFactory;, +, + // Local transports, + bind(LocalClientChannelFactory.class)., + to(DefaultLocalClientChannelFactory.class)., + in(Scopes.SINGLETON);, +, + bind(LocalServerChannelFactory.class)., + to(DefaultLocalServerChannelFactory.class)., + in(Scopes.SINGLETON);, +++ b/src/main/java/org/jboss/netty/container/guice/NettyModule.java, +import org.jboss.netty.channel.local.DefaultLocalClientChannelFactory;, +import org.jboss.netty.channel.local.DefaultLocalServerChannelFactory;, +import org.jboss.netty.channel.local.LocalClientChannelFactory;, +import org.jboss.netty.channel.local.LocalServerChannelFactory;, +, + // Local transports, + bind(LocalClientChannelFactory.class)., + to(DefaultLocalClientChannelFactory.class)., + in(Scopes.SINGLETON);, +, + bind(LocalServerChannelFactory.class)., + to(DefaultLocalServerChannelFactory.class)., + in(Scopes.SINGLETON);, +++ b/src/main/java/org/jboss/netty/container/osgi/NettyBundleActivator.java, +import org.jboss.netty.channel.local.DefaultLocalClientChannelFactory;, +import org.jboss.netty.channel.local.DefaultLocalServerChannelFactory;, +import org.jboss.netty.channel.local.LocalClientChannelFactory;, +import org.jboss.netty.channel.local.LocalServerChannelFactory;, + // Local transports, + register(ctx,, + new DefaultLocalClientChannelFactory(),, + LocalClientChannelFactory.class);, + register(ctx,, + new DefaultLocalServerChannelFactory(),, + LocalServerChannelFactory.class);, +, + // Miscellaneous transports, +++ b/src/main/java/org/jboss/netty/container/guice/NettyModule.java, +import org.jboss.netty.channel.local.DefaultLocalClientChannelFactory;, +import org.jboss.netty.channel.local.DefaultLocalServerChannelFactory;, +import org.jboss.netty.channel.local.LocalClientChannelFactory;, +import org.jboss.netty.channel.local.LocalServerChannelFactory;,
[+++ b/.fbfilter.xml, + <Match>, + <Class name="~.*Channel"/>, + <Or>, + <Method name="setClosed"/>, + <Method name="setInterestOpsNow"/>, + </Or>, + <Bug pattern="USM_USELESS_SUBCLASS_METHOD"/>, + </Match>, +++ b/.fbfilter.xml, + <Match>, + <Class name="~.*Channel"/>, + <Or>, + <Method name="setClosed"/>, + <Method name="setInterestOpsNow"/>, + </Or>, + <Bug pattern="USM_USELESS_SUBCLASS_METHOD"/>, + </Match>, +++ b/src/main/java/org/jboss/netty/handler/execution/MemoryAwareThreadPoolExecutor.java]
[+++ b/example/src/main/java/io/netty/example/socksproxy/SocksServerHandler.java, + ctx.fireInboundBufferUpdated();]
[+++ b/src/main/java/org/jboss/netty/handler/ssl/ImmediateExecutor.java, +/*, + * Copyright 2009 Red Hat, Inc., + *, + * Red Hat licenses this file to you under the Apache License, version 2.0, + * (the "License"); you may not use this file except in compliance with the, + * License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or
[+++ b/codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java, + failIfNecessary(false);, + failIfNecessary(true);, + private void failIfNecessary(boolean firstDetectionOfTooLongFrame) {]
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, + struct iovec iov[length];, + int i;, + int num = offset + length;, + return writev0(env, clazz, fd, iov, length);, + struct iovec iov[length];, + int i;, + int num = offset + length;, + return writev0(env, clazz, fd, iov, length);, +, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_iovMax(JNIEnv *env, jclass clazz) {, + return IOV_MAX;, +}, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, + struct iovec iov[length];, + int i;, + int num = offset + length;, + return writev0(env, clazz, fd, iov, length);, + struct iovec iov[length];, + int i;, + int num = offset + length;, + return writev0(env, clazz, fd,
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return threshold;, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return threshold;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java, + sb.append('-');, + sb.append('-');, + sb.append('-');, + sb.append('-');, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return threshold;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java, + sb.append('-');, + sb.append('-');, + sb.append('-');, + sb.append('-');, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshakerFactory.java, +import static io.netty.handler.codec.http.websocketx.WebSocketVersion.*;, +, + if (version == V13) {, + webSocketURL, V13, subprotocol, allowExtensions, customHeaders, maxFramePayloadLength);, + if (version == V08) {, + webSocketURL, V08, subprotocol, allowExtensions, customHeaders, maxFramePayloadLength);, + if (version == V00) {, + webSocketURL, V00, subprotocol, customHeaders, maxFramePayloadLength);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return threshold;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java, + sb.append('-');, + sb.append('-');, + sb.append('-');, + sb.append('-');, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshakerFactory.java, +import static io.netty.handler.codec.http.websocketx.WebSocketVersion.*;,
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + if (handler instanceof ChannelInboundByteHandler && !isInboundBufferFreed()) {, + if (handler instanceof ChannelOutboundByteHandler && !isOutboundBufferFreed()) {, + pipeline.inboundBufferFreed = true;, + pipeline.outboundBufferFreed = true;, + return pipeline.inboundBufferFreed;, + return pipeline.outboundBufferFreed;, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + if (handler instanceof ChannelInboundByteHandler && !isInboundBufferFreed()) {, + if (handler instanceof ChannelOutboundByteHandler && !isOutboundBufferFreed()) {, + pipeline.inboundBufferFreed = true;, + pipeline.outboundBufferFreed = true;, + return pipeline.inboundBufferFreed;, + return pipeline.outboundBufferFreed;, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, + volatile boolean inboundBufferFreed;, + volatile boolean outboundBufferFreed;]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.Signal;, +import io.netty.util.internal.PlatformDependent;, + public int forEachByte(ByteBufProcessor processor) {, + int index = readerIndex;, + int length = writerIndex - index;, + return forEach0(index, length, processor);, + }, +, + @Override, + public int forEachByte(int index, int length, ByteBufProcessor processor) {, + checkIndex(index, length);, + return forEach0(index, length, processor);, + }, +, + private int forEach0(int index, int length, ByteBufProcessor processor) {, + if (processor == null) {, + throw new NullPointerException("processor");, + }, +, + if (length == 0) {, + return -1;, + }, +, + final int end = index + length;, +
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return newSwappedByteBuf();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return newSwappedByteBuf();, +++ b/buffer/src/test/java/io/netty/buffer/AbstractPooledByteBufTest.java, + assertEquals(unwrapIfNeeded(buf), unwrapIfNeeded(buf2));]
[+++ b/all/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/codec-http2/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.2.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffers.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffers.java, +++ b/buffer/src/test/java/io/netty/buffer/ChannelBuffersTest.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffers.java, +++ b/buffer/src/test/java/io/netty/buffer/ChannelBuffersTest.java, +++ b/codec/src/main/java/io/netty/handler/codec/embedder/AbstractCodecEmbedder.java, +import io.netty.channel.Channels;, +import io.netty.channel.ChannelFuture;, +, + @Override, + public ChannelFuture execute(ChannelPipeline pipeline, Runnable task) {, + try {, + task.run();, + return Channels.succeededFuture(pipeline.getChannel());, + } catch (Throwable t) {, + return Channels.failedFuture(pipeline.getChannel(), t);, + }, + }, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffers.java, +++ b/buffer/src/test/java/io/netty/buffer/ChannelBuffersTest.java, +++ b/codec/src/main/java/io/netty/handler/codec/embedder/AbstractCodecEmbedder.java, +import io.netty.channel.Channels;, +import io.netty.channel.ChannelFuture;, +, + @Override, + public ChannelFuture execute(ChannelPipeline pipeline, Runnable task) {, + try {, + task.run();, + return Channels.succeededFuture(pipeline.getChannel());, + } catch (Throwable t) {, + return Channels.failedFuture(pipeline.getChannel(), t);, + }, + }, +++ b/codec/src/main/java/io/netty/handler/codec/frame/FixedLengthFrameDecoder.java, + protected ChannelBuffer createCumulationDynamicBuffer(ChannelHandlerContext ctx)
[+++ b/pom.xml, + <version>3.0.2.GA</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.0.2.GA</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.0.2.GA</developerConnection>]
[+++ b/pom.xml, + <tcnative.version>1.1.33.Fork26</tcnative.version>]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractWrappedByteBuf.java, + throw new UnsupportedOperationException();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractWrappedByteBuf.java, + throw new UnsupportedOperationException();, +++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractWrappedByteBuf.java, + throw new UnsupportedOperationException();, +++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + protected AbstractDiskHttpData(String name, Charset charset, long size) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractWrappedByteBuf.java, + throw new UnsupportedOperationException();, +++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + protected AbstractDiskHttpData(String name, Charset charset, long size) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java, + protected AbstractHttpData(String name, Charset charset, long size) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractWrappedByteBuf.java, + throw new UnsupportedOperationException();, +++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + protected AbstractDiskHttpData(String name, Charset charset, long size) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java, + protected AbstractHttpData(String name, Charset charset, long size) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java, + protected AbstractMemoryHttpData(String name,
[+++ b/resolver/src/main/java/io/netty/resolver/DefaultHostsFileEntriesResolver.java, + return entries.get(normalize(inetHost));, + }, +, + // package-private for testing purposes, + String normalize(String inetHost) {, + return inetHost.toLowerCase(Locale.ENGLISH);, +++ b/resolver/src/main/java/io/netty/resolver/DefaultHostsFileEntriesResolver.java, + return entries.get(normalize(inetHost));, + }, +, + // package-private for testing purposes, + String normalize(String inetHost) {, + return inetHost.toLowerCase(Locale.ENGLISH);, +++ b/resolver/src/test/java/io/netty/resolver/DefaultHostsFileEntriesResolverTest.java, +import org.junit.Assert;, + public void testCaseInsensitivity() throws Exception {, + //normalized somehow, + Assert.assertEquals(resolver.normalize("localhost"), resolver.normalize("LOCALHOST"));]
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + public boolean isWritable() {, + return pipeline.isWritable();, + }, +, + @Override, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + public boolean isWritable() {, + return pipeline.isWritable();, + }, +, + @Override, +++ b/transport/src/main/java/io/netty/channel/Channel.java, + * Return {@code true} if the outbound buffer of the {@link Channel} is writable., + */, + boolean isWritable();, +, + /**, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + public boolean isWritable() {, + return pipeline.isWritable();, + }, +, + @Override, +++ b/transport/src/main/java/io/netty/channel/Channel.java, + * Return {@code true} if the outbound buffer of the {@link Channel} is writable., + */, + boolean isWritable();, +, + /**, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, + *
[+++ b/all/pom.xml, + <phase>prepare-package</phase>, + <phase>prepare-package</phase>, + <phase>prepare-package</phase>]
[+++ b/buffer/src/main/java/io/netty/buffer/UnsafeByteBufUtil.java, +import java.nio.ReadOnlyBufferException;, + if (dst.isReadOnly()) {, + // We need to check if dst is ready-only so we not write something in it by using Unsafe., + throw new ReadOnlyBufferException();, + }, + dst.position(dst.position() + bytesToCopy);, + } else if (dst.hasArray()) {, + } else {, + dst.put(buf.nioBuffer());, + }, +++ b/buffer/src/main/java/io/netty/buffer/UnsafeByteBufUtil.java, +import java.nio.ReadOnlyBufferException;, + if (dst.isReadOnly()) {, + // We need to check if dst is ready-only so we not write something in it by using Unsafe., + throw new ReadOnlyBufferException();, + }, + dst.position(dst.position() + bytesToCopy);, + } else if (dst.hasArray()) {, + } else
[+++ b/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServerInitializer.java, + // Uncomment the following line if you want HTTPS, + //SSLEngine engine = SecureChatSslContextFactory.getServerContext().createSSLEngine();, + //engine.setUseClientMode(false);, + //p.addLast("ssl", new SslHandler(engine));, +]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import io.netty.channel.ChannelPromise;, + return handshake(channel, channel.newPromise());, + * @param promise, + * the {@link ChannelPromise} to be notified when the opening handshake is sent, + public abstract ChannelFuture handshake(Channel channel, ChannelPromise promise);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import io.netty.channel.ChannelPromise;, + return handshake(channel, channel.newPromise());, + * @param promise, + * the {@link ChannelPromise} to be notified when the opening handshake is sent, + public abstract ChannelFuture handshake(Channel channel, ChannelPromise promise);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, +import io.netty.channel.ChannelPromise;, + public ChannelFuture handshake(Channel channel, final ChannelPromise promise) {, + promise.setSuccess();, + promise.setFailure(future.cause());, + return promise;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import io.netty.channel.ChannelPromise;, + return handshake(channel, channel.newPromise());, + * @param
[+++ b/src/docbook/en-US/module/architecture.xml, + Traditional I/O APIs in Java provide different types and methods for, + another tedious and difficult. The lack of portability between, + transports becomes a problem when you need to support additional, + transports, as this often entails rewriting the network layer of the, + application. Logically, many protocols can run on more than one, + transport such as TCP/IP, UDP/IP, SCTP, and serial port communication., + To make matters worse, Java's New I/O (NIO) API introduced, + incompatibilities with the old blocking I/O (OIO) API and will continue, + to do so in the next
[+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpMessage.java, + // values 1231 and 1237 are referenced in the javadocs of Boolean#hashCode(), + result = 31 * result + (unordered ? 1231 : 1237);]
[+++ b/codec/src/main/java/io/netty/handler/codec/redis/Command.java, + static final byte[] ARGS_PREFIX = "*".getBytes();, + static final byte[] CRLF = "\r\n".getBytes();, + static final byte[] BYTES_PREFIX = "$".getBytes();, + static final byte[] EMPTY_BYTES = new byte[0];, + static final byte[] NEG_ONE_AND_CRLF = convertWithCRLF(-1);, +++ b/codec/src/main/java/io/netty/handler/codec/redis/Command.java, + static final byte[] ARGS_PREFIX = "*".getBytes();, + static final byte[] CRLF = "\r\n".getBytes();, + static final byte[] BYTES_PREFIX = "$".getBytes();, + static final byte[] EMPTY_BYTES = new byte[0];, + static final byte[] NEG_ONE_AND_CRLF = convertWithCRLF(-1);, +++ b/codec/src/main/java/io/netty/handler/codec/redis/RedisDecoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/redis/Command.java, + static final byte[] ARGS_PREFIX = "*".getBytes();, + static final byte[] CRLF = "\r\n".getBytes();, + static final byte[] BYTES_PREFIX
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +import java.nio.ByteOrder;, + int i = frame.readerIndex();, + int end = frame.writerIndex();, +, + ByteOrder order = frame.order();, +, + // Remark: & 0xFF is necessary because Java will do signed expansion from, + // byte to int which we don't want., + int intMask = ((maskingKey[0] & 0xFF) << 24), + | ((maskingKey[1] & 0xFF) << 16), + | ((maskingKey[2] & 0xFF) << 8), + | (maskingKey[3] & 0xFF);, +, + // If the byte order of our buffers it little endian we have to bring our mask, + // into the same format, because getInt()
[+++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + addComponent0(components.size(), padding);, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + addComponent0(components.size(), padding);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, +, + // Test for https://github.com/netty/netty/issues/1060, + @Test, + public void testReadWithEmptyCompositeBuffer() {, + ByteBuf buf = compositeBuffer();, + int n = 65;, + for (int i=0; i<n; ++i) {, + buf.writeByte(1);, + assertEquals(1, buf.readByte());, + }, + }, +]
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + // Idea: Sometimes java binaries include Android classes on the classpath, even if it isn't actually Android., + // Rather than check if certain classes are present, just check the VM, which is tied to the JDK., + // Optional improvement: check if `android.os.Build.VERSION` is >= 24. On later versions of Android, the, + // OpenJDK is used, which means `Unsafe` will actually work as expected., +, + // Android sets this property to Dalvik, regardless of whether it actually is., + String vmName = SystemPropertyUtil.get("java.vm.name");, + boolean isAndroid = vmName.equals("Dalvik");, + if (isAndroid) {, +
[+++ /dev/null, +++ /dev/null, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjecctAggregatorTest.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + promise.setFailure(new ClosedChannelException());, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + promise.setFailure(new ClosedChannelException());, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPromise.java, + if (this.cause != null) {]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java, + if (param.value != null) {, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java, + if (param.value != null) {, + }, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/QueryStringEncoderTest.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under
[+++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketTcpMd5Test.java, +import io.netty.util.NetUtil;, + server.config().setOption(EpollChannelOption.TCP_MD5SIG,, + Collections.<InetAddress, byte[]>singletonMap(NetUtil.LOCALHOST4, SERVER_KEY));, + ch.config().setOption(EpollChannelOption.TCP_MD5SIG,, + Collections.<InetAddress, byte[]>singletonMap(NetUtil.LOCALHOST4, SERVER_KEY));, + server.config().setOption(EpollChannelOption.TCP_MD5SIG,, + Collections.<InetAddress, byte[]>singletonMap(NetUtil.LOCALHOST4, SERVER_KEY));, + Collections.<InetAddress, byte[]>singletonMap(NetUtil.LOCALHOST4, BAD_KEY)), + server.config().setOption(EpollChannelOption.TCP_MD5SIG,, + Collections.<InetAddress, byte[]>singletonMap(NetUtil.LOCALHOST4, SERVER_KEY));, + Collections.<InetAddress, byte[]>singletonMap(NetUtil.LOCALHOST4, SERVER_KEY))]
[+++ b/codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java, + long frameLength = getUnadjustedFrameLength(in, actualLengthFieldOffset, lengthFieldLength, byteOrder);, + /**, + * Decodes the specified region of the buffer into an unadjusted frame length. The default implementation is, + * capable of decoding the specified region into an unsigned 8/16/24/32/64 bit integer. Override this method to, + * decode the length field encoded differently. Note that this method must not modify the state of the specified, + * buffer (e.g. {@code readerIndex}, {@code writerIndex}, and the content of the buffer.), + *, + * @throws DecoderException if failed to decode the specified region, + */, + protected
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +import java.net.UnknownHostException;, + protected static void checkResolvable(InetSocketAddress addr) throws UnknownHostException {, + if (addr.isUnresolved()) {, + throw new UnknownHostException("Unable to resolve addr " + addr);, + }, + }, +, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +import java.net.UnknownHostException;, + protected static void checkResolvable(InetSocketAddress addr) throws UnknownHostException {, + if (addr.isUnresolved()) {, + throw new UnknownHostException("Unable to resolve addr " + addr);, + }, + }, +, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerSocketChannel.java, + checkResolvable(addr);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +import java.net.UnknownHostException;, + protected static void checkResolvable(InetSocketAddress addr) throws UnknownHostException {, + if (addr.isUnresolved()) {, + throw new UnknownHostException("Unable to resolve addr " + addr);, + }, + },
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (refCnt() == 0) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (refCnt() == 0) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCounted.java, + for (;;) {, + if (refCnt == 0) {, + if (refCntUpdater.compareAndSet(this, refCnt, refCnt + 1)) {, + break;, + }, + }, + for (;;) {, + if (refCnt == 0) {, + if (refCntUpdater.compareAndSet(this, refCnt, refCnt + increment)) {, + break;, + }, + }, + if (refCnt == 0) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (refCnt() == 0) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCounted.java, + for (;;) {, + if (refCnt == 0) {, + if (refCntUpdater.compareAndSet(this, refCnt, refCnt + 1))
[+++ b/codec/src/main/java/io/netty/handler/codec/DatagramPacketDecoder.java, +, + @Override, + public boolean isSharable() {, + return decoder.isSharable();, + }, +++ b/codec/src/main/java/io/netty/handler/codec/DatagramPacketDecoder.java, +, + @Override, + public boolean isSharable() {, + return decoder.isSharable();, + }, +++ b/codec/src/main/java/io/netty/handler/codec/DatagramPacketEncoder.java, +, + @Override, + public boolean isSharable() {, + return encoder.isSharable();, + }, +++ b/codec/src/main/java/io/netty/handler/codec/DatagramPacketDecoder.java, +, + @Override, + public boolean isSharable() {, + return decoder.isSharable();, + }, +++ b/codec/src/main/java/io/netty/handler/codec/DatagramPacketEncoder.java, +, + @Override, + public boolean isSharable() {, + return encoder.isSharable();, + }, +++ b/codec/src/test/java/io/netty/handler/codec/DatagramPacketDecoderTest.java, +import io.netty.channel.ChannelHandlerContext;, +import java.util.List;, +, + @Test, + public void testIsNotSharable() {, + testIsSharable(false);, + }, +, + @Test, + public void
[+++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, + ChannelFuture doBind(final SocketAddress localAddress) {, + final Channel channel = channelFactory().newChannel();, + final ChannelPromise promise = channel.newPromise();, + if (initPromise.isDone()) {, + doBind0(initPromise, channel, localAddress, promise);, + } else {, + initPromise.addListener(new ChannelFutureListener() {, + @Override, + public void operationComplete(ChannelFuture future) throws Exception {, + doBind0(future, channel, localAddress, promise);, + }, + });, + }, +, + return promise;, + }, +, + private static void doBind0(ChannelFuture initFuture, Channel channel, SocketAddress localAddress, ChannelPromise promise) {, + if (initFuture.isSuccess()) {, + channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);, + } else {, + promise.setFailure(initFuture.cause());, + }, + private ChannelFuture doConnect(final SocketAddress remoteAddress,
[+++ b/pom.xml, + <module>codec-smtp</module>]
[+++ b/codec/src/main/java/io/netty/handler/codec/DatagramPacketDecoder.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + * Returns the CSV of requested subprotocol(s) sent to the server as specified in the constructor, + * Returns the subprotocol response sent by the server. Only available after end of handshake., + * Null if no subprotocol was requested or confirmed by the server., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + * Returns the CSV of requested subprotocol(s) sent to the server as specified in the constructor, + * Returns the subprotocol response sent by the server. Only available after end of handshake., + * Null if no subprotocol was requested or confirmed by the server., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, +
[+++ b/pom.xml, + <version>3.2.0.Final-SNAPSHOT</version>, + <url>http://fisheye.jboss.org/browse/Netty</url>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfig.java, +import java.util.LinkedHashSet;, + private final Set<String> origins;, + private final boolean anyOrigin;, + origins = new LinkedHashSet<String>(builder.origins);, + anyOrigin = builder.anyOrigin;, + * Determines whether a wildcard origin, '*', is supported., + *, + * @return {@code boolean} true if any origin is allowed., + */, + public boolean isAnyOriginSupported() {, + return anyOrigin;, + }, +, + /**, + return origins.isEmpty() ? "*" : origins.iterator().next();, + }, +, + /**, + * Returns the set of allowed origins., + *, + * @return {@code Set} the allowed origins., + */, + public Set<String> origins() {, +
[+++ b/handler/src/main/java/io/netty/handler/ipfilter/IpFilterRule.java, + * @return This method should return {@link IpFilterRuleType#Accept} if all, + * {@link IpFilterRuleType#Reject} should be returned., +++ b/handler/src/main/java/io/netty/handler/ipfilter/IpFilterRule.java, + * @return This method should return {@link IpFilterRuleType#Accept} if all, + * {@link IpFilterRuleType#Reject} should be returned., +++ b/handler/src/main/java/io/netty/handler/ipfilter/IpFilterRuleType.java, + Accept,, + Reject, +++ b/handler/src/main/java/io/netty/handler/ipfilter/IpFilterRule.java, + * @return This method should return {@link IpFilterRuleType#Accept} if all, + * {@link IpFilterRuleType#Reject} should be returned., +++ b/handler/src/main/java/io/netty/handler/ipfilter/IpFilterRuleType.java, + Accept,, + Reject, +++ b/handler/src/main/java/io/netty/handler/ipfilter/RuleBasedIpFilter.java, + return rule.ruleType() == IpFilterRuleType.Accept;, +++ b/handler/src/main/java/io/netty/handler/ipfilter/IpFilterRule.java, + * @return This method should return {@link IpFilterRuleType#Accept} if all, + * {@link IpFilterRuleType#Reject} should be returned.,
[+++ b/codec/src/main/java/io/netty/handler/codec/PrematureChannelClosureException.java, +package io.netty.handler.codec;, +, +import io.netty.channel.Channel;, +, +/**, + * A {@link CodecException} which is thrown when a {@link Channel} is closed unexpectedly before, + * the codec finishes handling the current message, such as missing response while waiting for a, + * request., + */, +public class PrematureChannelClosureException extends CodecException {, +, + private static final long serialVersionUID = 4907642202594703094L;, +, + /**, + * Creates a new instance., + */, + public PrematureChannelClosureException() {, + super();, + }, +, + /**, + * Creates a new instance., + */, + public PrematureChannelClosureException(String message, Throwable cause) {,
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2FrameWriter.java, + public ChannelFuture writePing(ChannelHandlerContext ctx, boolean ack, long data, ChannelPromise promise) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2FrameWriter.java, + public ChannelFuture writePing(ChannelHandlerContext ctx, boolean ack, long data, ChannelPromise promise) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + public void onPingRead(ChannelHandlerContext ctx, long data) throws Http2Exception {, + encoder.writePing(ctx, true, data, ctx.newPromise());, + public void onPingAckRead(ChannelHandlerContext ctx, long data) throws Http2Exception {, + public void onPingRead(ChannelHandlerContext ctx, long data) throws Http2Exception {, + public void onPingAckRead(ChannelHandlerContext ctx, long data) throws Http2Exception {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2FrameWriter.java, + public ChannelFuture writePing(ChannelHandlerContext ctx, boolean ack, long data, ChannelPromise promise) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + public void onPingRead(ChannelHandlerContext ctx, long data) throws
[+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java, + ByteBuf extras = request.extras() == null ? null : request.extras().retain();, + new DefaultFullBinaryMemcacheRequest(request.key(), extras, content);, + ByteBuf extras = response.extras() == null ? null : response.extras().retain();, + new DefaultFullBinaryMemcacheResponse(response.key(), extras, content);, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregator.java, + ByteBuf extras = request.extras() == null ? null : request.extras().retain();, + new DefaultFullBinaryMemcacheRequest(request.key(), extras, content);, + ByteBuf extras = response.extras() == null ? null : response.extras().retain();, + new DefaultFullBinaryMemcacheResponse(response.key(), extras, content);, +++ b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java, +import io.netty.handler.codec.memcache.DefaultLastMemcacheContent;, +import io.netty.handler.codec.memcache.DefaultMemcacheContent;, +import io.netty.util.CharsetUtil;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertTrue;, +, + @Test, + public void shouldRetainByteBufWhenAggregating() {, + channel = new EmbeddedChannel(, + new BinaryMemcacheRequestEncoder(),, +
[+++ b/all/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/codec/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/codec/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/common/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta2</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec/src/test/java/io/netty/handler/codec/xml/XmlFrameDecoderTest.java, +import static org.hamcrest.CoreMatchers.*;, + String path = "io/netty/handler/codec/xml/sample-" + number + ".xml";, + throw new IllegalArgumentException("file not found: " + path);]
[+++ b/pom.xml, + <version>[3.1.1,)</version>]
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + ctx.fireUserEventTriggered(SslHandshakeCompletionEvent.SUCCESS);, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + ctx.fireUserEventTriggered(SslHandshakeCompletionEvent.SUCCESS);, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandshakeCompletionEvent.java, + public static final SslHandshakeCompletionEvent SUCCESS = new SslHandshakeCompletionEvent();, +, + /**, + * Creates a new event that indicates a successful handshake., + */, + private SslHandshakeCompletionEvent() {, + cause = null;, + }, +, + /**, + * Creates a new event that indicates an unsuccessful handshake., + * Use {@link #SUCCESS} to indicate a successful handshake., + */, + if (cause == null) {, + throw new NullPointerException("cause");, + }]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (minWritableBytes < 0) {, + "minWritableBytes: %d (expected: 0+)", minWritableBytes));, + if (minWritableBytes > maxCapacity - writerIndex) {, + int newCapacity = calculateNewCapacity(writerIndex + minWritableBytes);, + final int maxCapacity = this.maxCapacity;, +, + return Math.min(newCapacity, maxCapacity);]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +import java.nio.channels.ClosedChannelException;, + private boolean needsLazyBufInit;, + private AtomicReference<MessageBridge> outMsgBridge;, + private AtomicReference<ByteBridge> outByteBridge;, + // Lazily instantiated tasks used to trigger events to a handler with different executor., + private Runnable invokeChannelRegisteredTask;, + private Runnable invokeChannelUnregisteredTask;, + private Runnable invokeChannelActiveTask;, + private Runnable invokeChannelInactiveTask;, + private Runnable invokeInboundBufferUpdatedTask;, + private Runnable fireInboundBufferUpdated0Task;, + private Runnable invokeInboundBufferSuspendedTask;, + private Runnable invokeFreeInboundBuffer0Task;, + private Runnable invokeFreeOutboundBuffer0Task;, + private Runnable invokeRead0Task;, + DefaultChannelHandlerContext(, + DefaultChannelPipeline pipeline, EventExecutorGroup group,, + String name, ChannelHandler handler) {, + this(pipeline, group, name, handler, false);, + String name, ChannelHandler handler, boolean needsLazyBufInit) {, +
[+++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5AddressDecoder.java, + return NetUtil.bytesToIpAddress(tmp);, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5AddressDecoder.java, + return NetUtil.bytesToIpAddress(tmp);, +++ b/codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/Socks5CommandRequestDecoderTest.java, + NetUtil.bytesToIpAddress(IPAddressUtil.textToNumericFormatV6("::1")) };, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5AddressDecoder.java, + return NetUtil.bytesToIpAddress(tmp);, +++ b/codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/Socks5CommandRequestDecoderTest.java, + NetUtil.bytesToIpAddress(IPAddressUtil.textToNumericFormatV6("::1")) };, +++ b/codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/Socks5CommandResponseDecoderTest.java, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertNull;, + "1111:111:11:1::1", 80);, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5AddressDecoder.java, + return NetUtil.bytesToIpAddress(tmp);, +++ b/codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/Socks5CommandRequestDecoderTest.java, + NetUtil.bytesToIpAddress(IPAddressUtil.textToNumericFormatV6("::1")) };, +++ b/codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/Socks5CommandResponseDecoderTest.java, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertNull;, + "1111:111:11:1::1", 80);, +++ b/common/src/main/java/io/netty/util/NetUtil.java, + public static String bytesToIpAddress(byte[] bytes) {, + return bytesToIpAddress(bytes, 0, bytes.length);, + }, +, + /**, + * Converts 4-byte or 16-byte data into an IPv4 or IPv6 string respectively., + *, + * @throws IllegalArgumentException, + * if
[+++ b/src/test/java/org/jboss/netty/handler/codec/frame/AbstractSocketFixedLengthEchoTest.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2008, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version., + *, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + String trimmedLine = line.toString().trim();, + StringBuilder buf = new StringBuilder(value.length() + trimmedLine.length() + 1);, + .append(trimmedLine);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + String trimmedLine = line.toString().trim();, + StringBuilder buf = new StringBuilder(value.length() + trimmedLine.length() + 1);, + .append(trimmedLine);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, + if (uri.isEmpty()) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + String trimmedLine = line.toString().trim();, + StringBuilder buf = new StringBuilder(value.length() + trimmedLine.length() + 1);, + .append(trimmedLine);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, + if (uri.isEmpty()) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateDecoder.java, + return (msg.rsv() & WebSocketExtension.RSV1) > 0 ?, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + String trimmedLine = line.toString().trim();, + StringBuilder buf = new StringBuilder(value.length() + trimmedLine.length() + 1);, + .append(trimmedLine);, +++
[+++ b/handler/src/main/java/io/netty/handler/ssl/util/SelfSignedCertificate.java, + FileInputStream certificateInput = null;, + certificateInput = new FileInputStream(certificate);, + cert = (X509Certificate) CertificateFactory.getInstance("X509").generateCertificate(certificateInput);, + } finally {, + if (certificateInput != null) {, + try {, + certificateInput.close();, + } catch (IOException e) {, + logger.warn("Failed to close a file: " + certificate, e);, + }, + }]
[+++ b/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java, + private static void ensureWritableIntStatusShouldFailButNotThrow(boolean force) {, +++ b/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java, + private static void ensureWritableIntStatusShouldFailButNotThrow(boolean force) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + private static Object continueResponse(HttpMessage start, int maxContentLength, ChannelPipeline pipeline) {, +++ b/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java, + private static void ensureWritableIntStatusShouldFailButNotThrow(boolean force) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + private static Object continueResponse(HttpMessage start, int maxContentLength, ChannelPipeline pipeline) {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpUtilTest.java, + private static void run100ContinueTest(final HttpVersion version, final String expectations, boolean expect) {, + private static void run100ContinueTest(final HttpMessage message, final boolean expected) {, + private static void runUnsupportedExpectationTest(final HttpVersion version,, + final String expectations, boolean expect) {, + private static void runUnsupportedExpectationTest(final HttpMessage
[+++ b/handler/src/main/java/io/netty/handler/ssl/CipherSuiteConverter.java, + /**, + * Convert from OpenSSL cipher suite name convention to java cipher suite name convention., + * @param openSslCipherSuite An OpenSSL cipher suite name., + * @param protocol The cryptographic protocol (i.e. SSL, TLS, ...)., + * @return The translated cipher suite name according to java conventions. This will not be {@code null}., + */, +++ b/handler/src/main/java/io/netty/handler/ssl/CipherSuiteConverter.java, + /**, + * Convert from OpenSSL cipher suite name convention to java cipher suite name convention., + * @param openSslCipherSuite An OpenSSL cipher suite name., + * @param protocol The cryptographic protocol (i.e. SSL, TLS, ...)., +
[+++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientHandler.java, +import io.netty.channel.ChannelInboundMessageHandlerAdapter;, +public class HttpSnoopClientHandler extends ChannelInboundMessageHandlerAdapter<Object> {, + public void messageReceived(ChannelInboundHandlerContext<Object> ctx, Object msg) throws Exception {, +++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientHandler.java, +import io.netty.channel.ChannelInboundMessageHandlerAdapter;, +public class HttpSnoopClientHandler extends ChannelInboundMessageHandlerAdapter<Object> {, + public void messageReceived(ChannelInboundHandlerContext<Object> ctx, Object msg) throws Exception {, +++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java, +import io.netty.channel.ChannelInboundMessageHandlerAdapter;, +public class HttpSnoopServerHandler extends ChannelInboundMessageHandlerAdapter<Object> {, + public void messageReceived(ChannelInboundHandlerContext<Object> ctx, Object msg) throws Exception {]
[+++ b/pom.xml, + <properties>, + <test.jvm.argLine.coverage>${jacoco.argLine}</test.jvm.argLine.coverage>, + </properties>, + <configuration>, + <propertyName>jacoco.argLine</propertyName>, + </configuration>, + <test.jvm.argLine.coverage></test.jvm.argLine.coverage> <!-- Set when 'coverage' profile is active -->, + <argLine>${test.jvm.argLine.coverage} ${test.jvm.argLine}</argLine>]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Headers.java, + * Returns an iterator over all HTTP/2 headers. The iteration order is as follows:, + * 1. All pseudo headers (order not specified)., + * 2. All non-pseudo headers (in insertion order).]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, +import io.netty.handler.codec.DefaultHeaders.NameConverter;, +import io.netty.handler.codec.DefaultTextHeaders.DefaultTextValueTypeConverter;, +/**, + * Default implementation of {@link HttpHeaders}., + */, + private static final int HIGHEST_INVALID_NAME_CHAR_MASK = ~63;, + private static final int HIGHEST_INVALID_VALUE_CHAR_MASK = ~15;, +, + /**, + * A look-up table used for checking if a character in a header name is prohibited., + */, + private static final byte[] LOOKUP_TABLE = new byte[~HIGHEST_INVALID_NAME_CHAR_MASK + 1];, +, + static {, + LOOKUP_TABLE['\t'] = -1;, + LOOKUP_TABLE['\n'] = -1;, + LOOKUP_TABLE[0x0b] = -1;, + LOOKUP_TABLE['\f'] = -1;, + LOOKUP_TABLE[' '] = -1;, + LOOKUP_TABLE[','] = -1;, + LOOKUP_TABLE[':'] = -1;, +
[+++ b/example/src/main/java/io/netty/example/securechat/SecureChatClientHandler.java, +++ b/example/src/main/java/io/netty/example/securechat/SecureChatClientHandler.java, +++ b/example/src/main/java/io/netty/example/securechat/SecureChatServerHandler.java, + // Once session is secured, send a greeting., + ctx.write(, + "Welcome to " + InetAddress.getLocalHost().getHostName() +, + " secure chat service!\n");, + ctx.write(, + "Your session is protected by " +, + ctx.pipeline().get(SslHandler.class).getEngine().getSession().getCipherSuite() +, + " cipher suite.\n");, + // Register the channel to the global channel list, + // so the channel received the messages from others., + channels.add(ctx.channel());, +++ b/example/src/main/java/io/netty/example/securechat/SecureChatClientHandler.java, +++ b/example/src/main/java/io/netty/example/securechat/SecureChatServerHandler.java, + // Once session is secured, send a greeting., + ctx.write(, + "Welcome to " + InetAddress.getLocalHost().getHostName() +, + " secure chat service!\n");, + ctx.write(, + "Your
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +#include <linux/tcp.h> // TCP_NOTSENT_LOWAT is a linux specific define, + setOption(env, fd, IPPROTO_TCP, TCP_CORK, &optval, sizeof(optval));, +}, +, +JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_setTcpNotSentLowAt(JNIEnv* env, jclass clazz, jint fd, jint optval) {, + setOption(env, fd, IPPROTO_TCP, TCP_NOTSENT_LOWAT, &optval, sizeof(optval));, + setOption(env, fd, IPPROTO_TCP, TCP_KEEPIDLE, &optval, sizeof(optval));, + setOption(env, fd, IPPROTO_TCP, TCP_KEEPINTVL, &optval, sizeof(optval));, + setOption(env, fd, IPPROTO_TCP, TCP_KEEPCNT, &optval, sizeof(optval));, + if (getOption(env, fd, IPPROTO_TCP, TCP_CORK, &optval, sizeof(optval)) == -1) {, + return -1;, + }, + return optval;, +}, +, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_getTcpNotSentLowAt(JNIEnv* env, jclass clazz, jint fd) {, + int optval;, + if (getOption(env, fd, IPPROTO_TCP,
[+++ b/.fbfilter.xml, + <Class name="~.*\.util\.internal\.Concurrent[A-Za-z]*HashMap(\$[^\$]+)*"/>, + <Class name="~.*\.util\.internal\..*TransferQueue(\$[^\$]+)*"/>, + <Class name="~.*\.util\.internal\.MapBackedSet"/>]
[+++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, + @SuppressWarnings("unchecked"), + public final void channelRegistered(ChannelHandlerContext ctx) throws Exception {, + if (!ctx.isRemoved()) {]
[+++ b/pom.xml, + <version>1.0</version>]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + // A client cannot push., + if (connection().isServer()) {, + throw connectionError(PROTOCOL_ERROR, "A client cannot push.");, + }, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + // A client cannot push., + if (connection().isServer()) {, + throw connectionError(PROTOCOL_ERROR, "A client cannot push.");, + }, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, + throw connectionError(FRAME_SIZE_ERROR, "Frame length: %d exceeds maximum: %d", payloadLength,, + maxFrameSize);, + verifyAssociatedWithAStream();, + verifyAssociatedWithAStream();, + verifyAssociatedWithAStream();, + verifyAssociatedWithAStream();, + throw connectionError(FRAME_SIZE_ERROR, "Invalid frame length %d.", payloadLength);, + throw connectionError(FRAME_SIZE_ERROR, "Ack settings frame must have an empty payload.");, + throw connectionError(FRAME_SIZE_ERROR, "Invalid frame length %d.", payloadLength);, + verifyAssociatedWithAStream();, + verifyPadding(padding);, + verifyPadding(padding);,
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + ctx.fireChannelRead(new DefaultHttp2GoAwayFrame(lastStreamId, errorCode, debugData.retain()));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + ctx.fireChannelRead(new DefaultHttp2GoAwayFrame(lastStreamId, errorCode, debugData.retain()));, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameCodecTest.java, + private final Http2Headers request = new DefaultHttp2Headers(), + private final Http2Headers response = new DefaultHttp2Headers(), + ByteBuf debugData = bb("foo");, + frameListener.onGoAwayRead(http2HandlerCtx, 2, Http2Error.NO_ERROR.code(), debugData);, + // Release debugData to emulate ByteToMessageDecoder, + debugData.release();]
[+++ b/codec/src/test/java/io/netty/handler/codec/DelimiterBasedFrameDecoderTest.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/handler/src/test/java/io/netty/handler/ssl/ConscryptJdkSslEngineInteropTest.java, + return Java8SslUtils.conscryptProvider();, +++ b/handler/src/test/java/io/netty/handler/ssl/ConscryptJdkSslEngineInteropTest.java, + return Java8SslUtils.conscryptProvider();, +++ b/handler/src/test/java/io/netty/handler/ssl/Java8SslUtils.java, +import org.conscrypt.OpenSSLProvider;, +, +import java.security.Provider;, +, + static Provider conscryptProvider() {, + return new OpenSSLProvider();, + }, +++ b/handler/src/test/java/io/netty/handler/ssl/ConscryptJdkSslEngineInteropTest.java, + return Java8SslUtils.conscryptProvider();, +++ b/handler/src/test/java/io/netty/handler/ssl/Java8SslUtils.java, +import org.conscrypt.OpenSSLProvider;, +, +import java.security.Provider;, +, + static Provider conscryptProvider() {, + return new OpenSSLProvider();, + }, +++ b/handler/src/test/java/io/netty/handler/ssl/JdkConscryptSslEngineInteropTest.java, + return Java8SslUtils.conscryptProvider();]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/common/src/main/java/io/netty/util/internal/logging/AbstractInternalLogger.java, + private static final String EXCEPTION_MESSAGE = "Unexpected exception:";, +, + public void trace(Throwable t) {, + trace(EXCEPTION_MESSAGE, t);, + }, +, + @Override, + public void debug(Throwable t) {, + debug(EXCEPTION_MESSAGE, t);, + }, +, + @Override, + public void info(Throwable t) {, + info(EXCEPTION_MESSAGE, t);, +, + }, +, + @Override, + public void warn(Throwable t) {, + warn(EXCEPTION_MESSAGE, t);, + }, +, + @Override, + public void error(Throwable t) {, + error(EXCEPTION_MESSAGE, t);, + }, +, + @Override, + public void log(InternalLogLevel level, Throwable cause) {, + switch (level) {, + case TRACE:, +
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java]
[+++ b/codec/src/test/java/io/netty/handler/codec/compression/JZlibTest.java, +++ b/codec/src/test/java/io/netty/handler/codec/compression/JZlibTest.java, +++ b/codec/src/test/java/io/netty/handler/codec/compression/JdkZlibTest.java, + @Override, +, + @Override, + @Test(expected = IllegalArgumentException.class), + public void testZLIB_OR_NONE2() throws Exception {, + new JdkZlibDecoder(ZlibWrapper.ZLIB_OR_NONE);, + }, +, + @Override, + @Test(expected = IllegalArgumentException.class), + public void testZLIB_OR_NONE3() throws Exception {, + new JdkZlibDecoder(ZlibWrapper.ZLIB_OR_NONE);, + }, +++ b/codec/src/test/java/io/netty/handler/codec/compression/JZlibTest.java, +++ b/codec/src/test/java/io/netty/handler/codec/compression/JdkZlibTest.java, + @Override, +, + @Override, + @Test(expected = IllegalArgumentException.class), + public void testZLIB_OR_NONE2() throws Exception {, + new JdkZlibDecoder(ZlibWrapper.ZLIB_OR_NONE);, + }, +, + @Override, + @Test(expected = IllegalArgumentException.class), + public void testZLIB_OR_NONE3() throws Exception {, + new JdkZlibDecoder(ZlibWrapper.ZLIB_OR_NONE);, + }, +++ b/codec/src/test/java/io/netty/handler/codec/compression/ZlibTest.java, +import static org.junit.Assert.assertNull;, + ByteBuf buf =
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +public abstract class AbstractByteBuf implements ByteBuf {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +public abstract class AbstractByteBuf implements ByteBuf {, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * Return the underlying buffer instance if this buffer is a wrapper of another buffer., + *, + * @return {@code null} if this buffer is not a wrapper, + */, + ByteBuf unwrap();, +, + /**, +, + /**, + * Provides access to potentially unsafe operations of this buffer., + */, + @Override, + Unsafe unsafe();, +, + /**, + * Provides the potentially unsafe operations of {@link ByteBuf}., + */, + interface Unsafe extends ChannelBuf.Unsafe
[+++ b/pom.xml, + <version>3.2.0.ALPHA4</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.2.0.ALPHA4</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.2.0.ALPHA4</developerConnection>]
[+++ b/transport/src/test/java/io/netty/channel/ReentrantChannelTest.java, + clientChannel.close().sync();]
[+++ b/pom.xml, + <argLine.leak>-verbose:gc</argLine.leak> <!-- Overridden when 'leak' profile is active -->, + <argLine.coverage>-D_</argLine.coverage> <!-- Overridden when 'coverage' profile is active -->]
[+++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseDecoderTest.java, +import io.netty.util.internal.InternalLogger;, +import io.netty.util.internal.InternalLoggerFactory;, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(SocksAuthResponseDecoderTest.class);, +, +++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseDecoderTest.java, +import io.netty.util.internal.InternalLogger;, +import io.netty.util.internal.InternalLoggerFactory;, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(SocksAuthResponseDecoderTest.class);, +, +++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdRequestDecoderTest.java, +import io.netty.util.internal.InternalLogger;, +import io.netty.util.internal.InternalLoggerFactory;, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(SocksCmdRequestDecoderTest.class);, +++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseDecoderTest.java, +import io.netty.util.internal.InternalLogger;, +import io.netty.util.internal.InternalLoggerFactory;, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(SocksAuthResponseDecoderTest.class);, +, +++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdRequestDecoderTest.java, +import io.netty.util.internal.InternalLogger;, +import io.netty.util.internal.InternalLoggerFactory;, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(SocksCmdRequestDecoderTest.class);, +++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdResponseDecoderTest.java, +import io.netty.util.internal.InternalLogger;, +import io.netty.util.internal.InternalLoggerFactory;, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(SocksCmdResponseDecoderTest.class);, +++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseDecoderTest.java, +import io.netty.util.internal.InternalLogger;, +import io.netty.util.internal.InternalLoggerFactory;, + private static final InternalLogger logger
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + * assert decoder.getParameters().get("recipient").get(0).equals("world");, + * assert decoder.getParameters().get("x").get(0).equals("1");, + * assert decoder.getParameters().get("y").get(0).equals("2");, + *, + * This decoder can also decode the content of an HTTP POST request whose, + * content type is <tt>application/x-www-form-urlencoded</tt>:, + * <pre>, + * {@link QueryStringDecoder} decoder = new {@link QueryStringDecoder}("recipient=world&x=1;y=2", false);, + * ..., + * </pre>, + *, + * <h3>HashDOS vulnerability fix</h3>, + *, + * As a workaround to the <a href="http://events.ccc.de/congress/2011/Fahrplan/attachments/2007_28C3_Effective_DoS_on_web_application_platforms.pdf">HashDOS</a>, + * vulnerability, the decoder limits the maximum number of decoded key-value, + * parameter pairs, up to {@literal 1024} by default, and you can
[+++ b/pom.xml, + <forkMode>never</forkMode>, + <exclude>**/TestOption*</exclude>]
[+++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java, + private FullHttpRequest request;, +, + this.request = request;, + this.sendError(ctx, METHOD_NOT_ALLOWED);, + this.sendError(ctx, FORBIDDEN);, + this.sendError(ctx, NOT_FOUND);, + this.sendListing(ctx, file, uri);, + this.sendRedirect(ctx, uri + '/');, + this.sendNotModified(ctx);, + } else if (request.protocolVersion().equals(HTTP_1_0)) {, + response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);, + private void sendListing(ChannelHandlerContext ctx, File dir, String dirPath) {, + this.sendAndCleanupConnection(ctx, response);, + private void sendRedirect(ChannelHandlerContext ctx, String newUri) {, + this.sendAndCleanupConnection(ctx, response);, + private void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {, + this.sendAndCleanupConnection(ctx, response);, + private void sendNotModified(ChannelHandlerContext ctx) {, + this.sendAndCleanupConnection(ctx, response);, + private void sendAndCleanupConnection(ChannelHandlerContext ctx, FullHttpResponse response) {, + final FullHttpRequest request = this.request;, +
[+++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, +import io.netty.channel.ChannelHandler.Sharable;, +@Sharable]
[+++ b/pom.xml, + <yammer.metrics.version>2.1.4</yammer.metrics.version>]
[+++ b/pom.xml, +++ b/pom.xml, +++ b/testsuite-osgi/pom.xml, + <argLine.java9.extras>--add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/jdk.internal.loader=ALL-UNNAMED --add-opens=java.base/java.net=ALL-UNNAMED --add-opens=java.base/java.security=ALL-UNNAMED</argLine.java9.extras>, + <version>5.6.10</version>]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufProcessor.java, + * return {@code 1} to advance the index by {@code 1}. Note that returning a non-positive value is, + * allowed where a negative value advances the index in the opposite direction and zero leaves the index, + * as-is., +++ b/buffer/src/main/java/io/netty/buffer/ByteBufProcessor.java, + * return {@code 1} to advance the index by {@code 1}. Note that returning a non-positive value is, + * allowed where a negative value advances the index in the opposite direction and zero leaves the index, + * as-is., +++ b/transport/src/main/java/io/netty/channel/MessageListProcessor.java, + * return {@code 1} to advance the index by {@code
[+++ b/pom.xml, + <version>3.2.0.ALPHA5-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/all/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/example/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha1</version>, +++ b/codec/pom.xml, +
[+++ b/example/pom.xml, + <artifactId>netty-transport</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/example/pom.xml, + <artifactId>netty-transport</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/handler/pom.xml, +++ b/example/pom.xml, + <artifactId>netty-transport</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/handler/pom.xml, +++ b/pom.xml, +++ b/example/pom.xml, + <artifactId>netty-transport</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/handler/pom.xml, +++ b/pom.xml, +++ /dev/null, +++ b/example/pom.xml, + <artifactId>netty-transport</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/handler/pom.xml, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ b/example/pom.xml, + <artifactId>netty-transport</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/handler/pom.xml, +++ b/pom.xml, +++ /dev/null, +++
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java, + private static final byte[] ID = new byte[] {'n', 'e', 't', 't', 'y'};, + sessionContext.setSessionIdContext(ID);]
[+++ b/transport/src/main/java/io/netty/channel/pool/FixedChannelPool.java, + this(bootstrap, handler, healthCheck, action, acquireTimeoutMillis, maxConnections, maxPendingAcquires,, + releaseHealthCheck, true);, + }, +, + /**, + * Creates a new instance., + *, + * @param bootstrap the{@link Bootstrap} that is used for connections, + * @param handler the {@link ChannelPoolHandler} that will be notified for the different pool actions, + * @param healthCheck the {@link ChannelHealthChecker} that will be used to check if a {@link Channel} is, + * still healthy when obtain from the {@link ChannelPool}, + * @param action the {@link AcquireTimeoutAction} to use or {@code null} if non should be used., +
[+++ b/all/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ /dev/null, +++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +, + // If the list is empty we need to assign a new one because, + // we get a List that is immutable. , + //, + // See https://github.com/netty/netty/issues/325, + if (list.isEmpty()) {, + list = new ArrayList<ChannelBuffer>(1);, + }, + ,
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, +, + if (msg instanceof Http2StreamFrame) {, + throw new IllegalArgumentException("Stream id must not be set on the frame. Was: ", + + frame.streamId());, + ReferenceCountUtil.release(frame);, + throw new IllegalArgumentException("The first frame must be a headers frame. Was: ", + + frame.name());, + } else if (msg instanceof Http2GoAwayFrame) {, + ChannelPromise promise = ctx.newPromise();, + promise.addListener(this);, + writeFromStreamChannel(msg, promise, false);, + } else {, + ReferenceCountUtil.release(msg);, + throw new IllegalArgumentException("Message must be an Http2GoAwayFrame or Http2StreamFrame: " + msg);, + }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, +, + if (msg instanceof Http2StreamFrame) {, + throw new IllegalArgumentException("Stream id must
[+++ b/transport-native-epoll/pom.xml, + <properties>, + <jni.compiler.args.ldflags>LDFLAGS=-Wl,--no-as-needed -lrt</jni.compiler.args.ldflags>, + </properties>, +, + <arg>${jni.compiler.args.ldflags}</arg>, + <arg>${jni.compiler.args.cflags}</arg>, + <name>jni.compiler.args.cflags</name>, + <name>jni.compiler.args.cflags</name>, + <value>${jni.compiler.args.cflags}</value>, +++ b/transport-native-epoll/pom.xml, + <properties>, + <jni.compiler.args.ldflags>LDFLAGS=-Wl,--no-as-needed -lrt</jni.compiler.args.ldflags>, + </properties>, +, + <arg>${jni.compiler.args.ldflags}</arg>, + <arg>${jni.compiler.args.cflags}</arg>, + <name>jni.compiler.args.cflags</name>, + <name>jni.compiler.args.cflags</name>, + <value>${jni.compiler.args.cflags}</value>, +++ b/transport-native-epoll/src/main/c/netty_epoll_native.c, +#include <time.h>, +clockid_t epollWaitClock = 0; // initialized in initializeEpollWaitClock, +, +static jboolean initializeEpollWaitClock() {, + struct timespec ts;, + // First try to get a monotonic clock, as we effectively measure execution time and don't want the underlying clock, + // moving unexpectedly/abruptly., + #ifdef CLOCK_MONOTONIC_COARSE, + epollWaitClock = CLOCK_MONOTONIC_COARSE;, + if (clock_gettime(epollWaitClock, &ts) != EINVAL)
[+++ b/transport-native-epoll/src/main/c/netty_epoll_native.c, + if (netty_unix_socket_getOption(env, fd, IPPROTO_IP, IP_FREEBIND, &optval, sizeof(optval)) == -1) {, +++ b/transport-native-epoll/src/main/c/netty_epoll_native.c, + if (netty_unix_socket_getOption(env, fd, IPPROTO_IP, IP_FREEBIND, &optval, sizeof(optval)) == -1) {, +++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollServerSocketChannelConfigTest.java, +, + @Test, + public void testFreeBind() {, + ch.config().setFreeBind(false);, + assertFalse(ch.config().isFreeBind());, + ch.config().setFreeBind(true);, + assertTrue(ch.config().isFreeBind());, + }]
[+++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyDirectByteBuf.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, +import static io.netty.handler.codec.http.HttpHeaderNames.EXPECT;, + private Object continueResponse(HttpMessage start, int maxContentLength, ChannelPipeline pipeline) {, + protected Object newContinueResponse(HttpMessage start, int maxContentLength, ChannelPipeline pipeline) {, + Object response = continueResponse(start, maxContentLength, pipeline);, + // we're going to respond based on the request expectation so there's no, + // need to propagate the expectation further., + if (response != null) {, + start.headers().remove(EXPECT);, + }, + return response;, + }, +, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, +import static io.netty.handler.codec.http.HttpHeaderNames.EXPECT;, + private Object continueResponse(HttpMessage start, int maxContentLength, ChannelPipeline pipeline) {, + protected Object newContinueResponse(HttpMessage start, int maxContentLength, ChannelPipeline pipeline) {, + Object
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, +import javax.net.ssl.KeyManagerFactory;, + this(null, null, null, null, null, null, null, IdentityCipherSuiteFilter.INSTANCE, null, 0, 0);, + this(certChainFile, trustManagerFactory, null, null, null, null, null,, + IdentityCipherSuiteFilter.INSTANCE, null, 0, 0);, + this(certChainFile, trustManagerFactory, null, null, null, null, ciphers, IdentityCipherSuiteFilter.INSTANCE,, + * @deprecated use {@link #OpenSslClientContext(File, TrustManagerFactory, File, File, String,, + * KeyManagerFactory, Iterable, CipherSuiteFilter, ApplicationProtocolConfig,long, long)}, + *, + @Deprecated, + long sessionCacheSize, long sessionTimeout) throws SSLException {, + this(certChainFile, trustManagerFactory, null, null, null, null,, + ciphers, cipherFilter, apn, sessionCacheSize, sessionTimeout);, + }, +, + /**, + * Creates a new instance., + * @param trustCertChainFile
[+++ b/all/pom.xml, + <version>4.1.15.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.15.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.15.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.15.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.15.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, + <version>4.1.15.Final-SNAPSHOT</version>, +
[+++ b/.classpath, +<?xml version="1.0" encoding="UTF-8"?>, +<classpath>, + <classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.7"/>, + <classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>, + <classpathentry kind="src" path="buffer/src/main/java"/>, + <classpathentry kind="src" path="codec/src/main/java"/>, + <classpathentry kind="src" path="codec-http/src/main/java"/>, + <classpathentry kind="src" path="common/src/main/java"/>, + <classpathentry kind="src" path="handler/src/main/java"/>, + <classpathentry kind="src" path="transport/src/main/java"/>, + <classpathentry combineaccessrules="false" kind="src" path="/ch.finnova.pe.jdk.build.time.dependencies"/>, + <classpathentry kind="output" path="bin"/>, +</classpath>, +++ b/.classpath, +<?xml version="1.0" encoding="UTF-8"?>, +<classpath>, + <classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.7"/>, + <classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>, + <classpathentry kind="src" path="buffer/src/main/java"/>, + <classpathentry kind="src" path="codec/src/main/java"/>, + <classpathentry kind="src" path="codec-http/src/main/java"/>, + <classpathentry kind="src" path="common/src/main/java"/>, + <classpathentry kind="src" path="handler/src/main/java"/>, + <classpathentry kind="src" path="transport/src/main/java"/>, + <classpathentry combineaccessrules="false" kind="src" path="/ch.finnova.pe.jdk.build.time.dependencies"/>, + <classpathentry kind="output" path="bin"/>, +</classpath>, +++ b/.gitignore, +bin/,
[+++ b/pom.xml, + <version>7</version>]
[+++ b/codec/src/test/java/io/netty/handler/codec/compression/Bzip2EncoderTest.java, + assertTrue(channel.finish());, + out = channel.readOutbound();, + out.release();, + assertNull(channel.readOutbound());]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpRequest.java, + throw new NullPointerException("method");, + throw new NullPointerException("uri");, + throw new NullPointerException("uri");]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return writerIndex > readerIndex;, +, + if (readerIndex == writerIndex) {, + clear();, + return;, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return writerIndex > readerIndex;, +, + if (readerIndex == writerIndex) {, + clear();, + return;, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return writerIndex > readerIndex;, +, + if (readerIndex == writerIndex) {, + clear();, + return;, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return writerIndex > readerIndex;, +, + if (readerIndex == writerIndex) {, + clear();, + return;, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractDiskHttpData.java, + localfileChannel.force(false);, +
[+++ b/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java, +public class DelimiterBasedFrameDecoder extends StreamToMessageDecoder<Object> {, + public Object decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer buffer) throws Exception {, +++ b/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java, +public class DelimiterBasedFrameDecoder extends StreamToMessageDecoder<Object> {, + public Object decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer buffer) throws Exception {, +++ b/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java, +public class FixedLengthFrameDecoder extends StreamToMessageDecoder<Object> {, + public Object decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in) throws Exception {, +++ b/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java, +public class DelimiterBasedFrameDecoder extends StreamToMessageDecoder<Object> {, + public Object decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer buffer) throws Exception {, +++ b/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java, +public class FixedLengthFrameDecoder extends StreamToMessageDecoder<Object> {, + public Object decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in) throws Exception {, +++ b/codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java, +public class LengthFieldBasedFrameDecoder extends StreamToMessageDecoder<Object> {, +
[+++ b/pom.xml, + <ignore>java.net.StandardSocketOptions</ignore> , +++ b/pom.xml, + <ignore>java.net.StandardSocketOptions</ignore> , +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioChannelOption.java, +import java.nio.channels.ServerSocketChannel;, +import java.util.ArrayList;, +import java.util.List;, + if (channel instanceof ServerSocketChannel && option.option == java.net.StandardSocketOptions.IP_TOS) {, + // Skip IP_TOS as a workaround for a JDK bug:, + // See http://mail.openjdk.java.net/pipermail/nio-dev/2018-August/005365.html, + return false;, + }, + if (channel instanceof ServerSocketChannel && option.option == java.net.StandardSocketOptions.IP_TOS) {, + // Skip IP_TOS as a workaround for a JDK bug:, + // See http://mail.openjdk.java.net/pipermail/nio-dev/2018-August/005365.html, + return null;, + }, +, + if (channel instanceof ServerSocketChannel) {, + List<ChannelOption<?>> extraOpts = new ArrayList<ChannelOption<?>>(supportedOpts.size());, + for (java.net.SocketOption<?> opt : supportedOpts) {, +
[+++ b/pom.xml, + <developers>, + <developer>, + <id>netty.io</id>, + <name>The Netty Project Contributors</name>, + <email>netty@googlegroups.com</email>, + <url>http://netty.io/</url>, + <organization>The Netty Project</organization>, + <organizationUrl>http://netty.io/</organizationUrl>, + </developer>, + </developers>, +]
[+++ b/example/pom.xml, + ${argLine.bootcp}, +++ b/example/pom.xml, + ${argLine.bootcp}, +++ b/pom.xml, + <!-- Our Javadoc has poor enough quality to fail the build thanks to JDK8 javadoc which got more strict. -->, + <!-- npn-boot does not work with JDK 8 -->, + <argLine.bootcp>-D_</argLine.bootcp>, + <argLine.bootcp>-Xbootclasspath/p:${jetty.npn.path}</argLine.bootcp>, + <argLine>${argLine.common} ${argLine.bootcp} ${argLine.leak} ${argLine.coverage}</argLine>]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + public final ByteBuf retain() {, + return this;, + }, + public final ByteBuf retain(int increment) {, + return this;, + }, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + public final ByteBuf retain() {, + return this;, + }, + public final ByteBuf retain(int increment) {, + return this;, + }, +++ b/buffer/src/main/java/io/netty/buffer/AbstractMessageBuf.java, + public final MessageBuf<T> retain() {, + return this;, + public final MessageBuf<T> retain(int increment) {, + return this;, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + public final ByteBuf retain() {, + return this;, + }, + public final ByteBuf retain(int increment) {, + return this;, + }, +++ b/buffer/src/main/java/io/netty/buffer/AbstractMessageBuf.java, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java, + private long gracefulShutdownTimeoutMillis = Http2CodecUtil.DEFAULT_GRACEFUL_SHUTDOWN_TIMEOUT_MILLIS;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java, + private long gracefulShutdownTimeoutMillis = Http2CodecUtil.DEFAULT_GRACEFUL_SHUTDOWN_TIMEOUT_MILLIS;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamChannel.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.isStreamIdValid;, +import static java.lang.Math.max;, +import static java.lang.Math.min;, +import io.netty.buffer.Unpooled;, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelFutureListener;, +import io.netty.channel.MessageSizeEstimator;, +import io.netty.channel.WriteBufferWaterMark;, +import java.util.concurrent.atomic.AtomicLongFieldUpdater;, +, + @SuppressWarnings("rawtypes"), + private static final AtomicLongFieldUpdater<AbstractHttp2StreamChannel> OUTBOUND_FLOW_CONTROL_WINDOW_UPDATER;, +, + /**, + * Used to add a message to the {@link ChannelOutboundBuffer}, so as to have it re-evaluate its writability state., + */, + private static final Object REEVALUATE_WRITABILITY_MESSAGE = new Object();, + private final Http2StreamChannelConfig config = new Http2StreamChannelConfig(this);, + private final Http2Stream2 stream;, + /**, + *
[+++ b/.gitignore, +/common/src/main/java/io/netty/util/Version.java, +, +++ b/.gitignore, +/common/src/main/java/io/netty/util/Version.java, +, +++ b/common/pom.xml, + <plugin>, + <artifactId>maven-antrun-plugin</artifactId>, + <executions>, + <execution>, + <id>write-version</id>, + <phase>validate</phase>, + <goals>, + <goal>run</goal>, + </goals>, + <configuration>, + <tasks>, + <taskdef resource="net/sf/antcontrib/antlib.xml" />, + <exec executable="git" outputproperty="gitOutput" resultproperty="gitExitCode" failonerror="false" failifexecutionfails="false">, + <arg value="log" />, + <arg value="-1" />, + <arg value="--format=format:%h" />, + </exec>, + <if>, + <equals arg2="0" arg1="${gitExitCode}" />, + <then>, + <property name="buildNumber" value="${gitOutput}" />, + </then>, + <else>, + <property name="buildNumber" value="unknown" />, + </else>, + </if>, + <echo>Build number: ${buildNumber}</echo>, + <mkdir dir="${project.build.directory}" />, + <echo message="${project.version}" file="${project.build.directory}/version.txt" />, + <echo
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +io.netty.channel.DefaultChannelPromise.setFailure/*, + public ChannelPromise setSuccess() {, + public ChannelPromise setFailure(Throwable cause) {, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +io.netty.channel.DefaultChannelPromise.setFailure/*, + public ChannelPromise setSuccess() {, + public ChannelPromise setFailure(Throwable cause) {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + public ChannelPromise setSuccess() {, + public ChannelPromise setFailure(Throwable cause) {, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +io.netty.channel.DefaultChannelPromise.setFailure/*, + public ChannelPromise setSuccess() {, + public ChannelPromise setFailure(Throwable cause) {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + public ChannelPromise setSuccess() {, + public ChannelPromise setFailure(Throwable cause) {, +++ b/transport/src/main/java/io/netty/channel/ChannelPromise.java, + ChannelPromise setSuccess();, + ChannelPromise setFailure(Throwable cause);, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +io.netty.channel.DefaultChannelPromise.setFailure/*, + public ChannelPromise setSuccess() {, + public ChannelPromise setFailure(Throwable cause) {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + public ChannelPromise setSuccess() {, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, +import io.netty.channel.RecvByteBufAllocator.Handle;, + public void operationComplete(ChannelFuture future) {, + curr.next = curr.previous = null;, + ((Http2MultiplexCodecStream) streamFrame.stream()).channel.fireChildRead(streamFrame);, + private boolean isChildChannelInReadPendingQueue(DefaultHttp2StreamChannel childChannel) {, + return childChannel.previous != null || childChannel.next != null || head == childChannel;, + }, +, + final void tryAddChildChannelToReadPendingQueue(DefaultHttp2StreamChannel childChannel) {, + if (!isChildChannelInReadPendingQueue(childChannel)) {, + childChannel.previous = tail;, +, + private void tryRemoveChildChannelFromReadPendingQueue(DefaultHttp2StreamChannel childChannel) {, + if (isChildChannelInReadPendingQueue(childChannel)) {, + removeChildChannelFromReadPendingQueue(childChannel);, + }, + }, +, + private void removeChildChannelFromReadPendingQueue(DefaultHttp2StreamChannel childChannel) {, + DefaultHttp2StreamChannel previous = childChannel.previous;, + if (childChannel.next != null) {, + childChannel.next.previous = previous;, + } else {, +
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, + outboundMsgMatcher = TypeParameterMatcher.find(this, ByteToMessageCodec.class, "I");, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, + outboundMsgMatcher = TypeParameterMatcher.find(this, ByteToMessageCodec.class, "I");, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, + outboundMsgMatcher = TypeParameterMatcher.find(this, ByteToMessageCodec.class, "I");, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java, + inboundMsgMatcher = TypeParameterMatcher.find(this, MessageToMessageCodec.class, "INBOUND_IN");, + outboundMsgMatcher = TypeParameterMatcher.find(this, MessageToMessageCodec.class, "OUTBOUND_IN");, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, + outboundMsgMatcher = TypeParameterMatcher.find(this, ByteToMessageCodec.class, "I");, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java, + inboundMsgMatcher = TypeParameterMatcher.find(this, MessageToMessageCodec.class, "INBOUND_IN");, + outboundMsgMatcher = TypeParameterMatcher.find(this, MessageToMessageCodec.class, "OUTBOUND_IN");, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, + outboundMsgMatcher = TypeParameterMatcher.find(this, ByteToMessageCodec.class, "I");, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java, + inboundMsgMatcher = TypeParameterMatcher.find(this, MessageToMessageCodec.class, "INBOUND_IN");, + outboundMsgMatcher = TypeParameterMatcher.find(this, MessageToMessageCodec.class, "OUTBOUND_IN");, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, +
[+++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, +import java.net.InetAddress;, + public Bootstrap localAddress(InetAddress host, int port) {, + localAddress = new InetSocketAddress(host, port);, + return this;, + }, +, + public Bootstrap remoteAddress(InetAddress host, int port) {, + remoteAddress = new InetSocketAddress(host, port);, + return this;, + }, +, +++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, +import java.net.InetAddress;, + public Bootstrap localAddress(InetAddress host, int port) {, + localAddress = new InetSocketAddress(host, port);, + return this;, + }, +, + public Bootstrap remoteAddress(InetAddress host, int port) {, + remoteAddress = new InetSocketAddress(host, port);, + return this;, + }, +, +++ b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java, +import java.net.InetAddress;, + public ServerBootstrap localAddress(InetAddress host, int port)
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import static io.netty.handler.ssl.SslUtils.SSL_RECORD_HEADER_LENGTH;, + * TLS Header (5) + 16 (IV) + 48 (MAC) + 1 (Padding_length field) + 15 (Padding) + 1 (ContentType) +, + * 2 (ProtocolVersion) + 2 (Length), + static final int MAX_TLS_RECORD_OVERHEAD_LENGTH = SSL_RECORD_HEADER_LENGTH + 16 + 48 + 1 + 15 + 1 + 2 + 2;, + static final int MAX_ENCRYPTED_PACKET_LENGTH = MAX_PLAINTEXT_LENGTH + MAX_TLS_RECORD_OVERHEAD_LENGTH;, + if (dst.remaining() < calculateOutNetBufSize(srcsLen, endOffset - offset)) {, + if (len < SSL_RECORD_HEADER_LENGTH) {, + if (packetLength - SSL_RECORD_HEADER_LENGTH > capacity) {, + static int calculateOutNetBufSize(int pendingBytes, int numComponents) {, + return (int) min(Integer.MAX_VALUE,
[+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpChannel.java, + ByteBuffer data = buffer.internalNioBuffer(buffer.writerIndex(), buffer.writableBytes());, + int pos = data.position();, +, + buf.add(new SctpMessage(messageInfo, buffer.writerIndex(buffer.writerIndex() + (data.position() - pos))));, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpChannel.java, + ByteBuffer data = buffer.internalNioBuffer(buffer.writerIndex(), buffer.writableBytes());, + int pos = data.position();, +, + buf.add(new SctpMessage(messageInfo, buffer.writerIndex(buffer.writerIndex() + (data.position() - pos))));, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + ByteBuffer nioData = data.internalNioBuffer(data.writerIndex(), data.writableBytes());, + int pos = nioData.position();, + int readBytes = nioData.position() - pos;]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java, + * <li>{@link #encoderIgnoreMaxHeaderListSize(boolean)}</li>, + private Boolean encoderIgnoreMaxHeaderListSize;, + * Sets if the <a href="https://tools.ietf.org/html/rfc7540#section-6.5.2">SETTINGS_MAX_HEADER_LIST_SIZE</a>, + * should be ignored when encoding headers., + * @param ignoreMaxHeaderListSize {@code true} to ignore, + * <a href="https://tools.ietf.org/html/rfc7540#section-6.5.2">SETTINGS_MAX_HEADER_LIST_SIZE</a>., + * @return this., + */, + protected B encoderIgnoreMaxHeaderListSize(boolean ignoreMaxHeaderListSize) {, + enforceNonCodecConstraints("encoderIgnoreMaxHeaderListSize");, + this.encoderIgnoreMaxHeaderListSize = ignoreMaxHeaderListSize;, + return self();, + }, +, + /**, + Http2FrameWriter writer = encoderIgnoreMaxHeaderListSize == null ?, + new DefaultHttp2FrameWriter(headerSensitivityDetector()) :, + new DefaultHttp2FrameWriter(headerSensitivityDetector(), encoderIgnoreMaxHeaderListSize);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java, + * <li>{@link #encoderIgnoreMaxHeaderListSize(boolean)}</li>, + private Boolean encoderIgnoreMaxHeaderListSize;, + * Sets if the <a href="https://tools.ietf.org/html/rfc7540#section-6.5.2">SETTINGS_MAX_HEADER_LIST_SIZE</a>, + * should
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + private FlowControlState localFlowState;, + private FlowControlState remoteFlowState;, + public FlowControlState localFlowState() {, + return localFlowState;, + }, +, + @Override, + public void localFlowState(FlowControlState state) {, + localFlowState = state;, + }, +, + @Override, + public FlowControlState remoteFlowState() {, + return remoteFlowState;, + }, +, + @Override, + public void remoteFlowState(FlowControlState state) {, + remoteFlowState = state;, + }, +, + @Override, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + private FlowControlState localFlowState;, + private FlowControlState remoteFlowState;, + public FlowControlState localFlowState() {, + return localFlowState;, + }, +, + @Override, + public void localFlowState(FlowControlState state) {, + localFlowState =
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, +import java.nio.ByteBuffer;, +, +, + @Override, + public ByteBuffer internalNioBuffer(int index, int length) {, + return nioBuffer(index, length);, + }, +, + @Override, + public ByteBuffer nioBuffer(int index, int length) {, + return unwrap().nioBuffer(index, length);, + }, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, +import java.nio.ByteBuffer;, +, +, + @Override, + public ByteBuffer internalNioBuffer(int index, int length) {, + return nioBuffer(index, length);, + }, +, + @Override, + public ByteBuffer nioBuffer(int index, int length) {, + return unwrap().nioBuffer(index, length);, + }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + public ByteBuffer nioBuffer(int index, int length) {, + if (components.size() == 1)
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Exception e) {, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Exception e) {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +import java.io.IOException;, +import java.net.InetSocketAddress;, +import java.net.SocketAddress;, +import java.nio.channels.NotYetConnectedException;, +import java.nio.channels.SelectionKey;, +, + EventLoop eventLoop();, +, +, + ChannelFuture deregister();, + void deregister(ChannelFuture future);, +, + Unsafe unsafe();, +, + public interface Unsafe {, + void setEventLoop(EventLoop eventLoop);, + void clearEventLoop();, + java.nio.channels.Channel ch();, +, + void bind(SocketAddress local) throws IOException;, + void connect(SocketAddress remote) throws IOException;, + boolean finishConnect() throws IOException;, + boolean read() throws IOException;, + boolean write() throws IOException;, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/InternalAttribute.java, +final class InternalAttribute implements InterfaceHttpData {, + private final List<String> value = new ArrayList<String>();]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelId.java, + if (o instanceof DefaultChannelId) {, + final byte[] otherData = ((DefaultChannelId) o).data;, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelId.java, + if (o instanceof DefaultChannelId) {, + final byte[] otherData = ((DefaultChannelId) o).data;, +++ b/transport/src/test/java/io/netty/channel/embedded/CustomChannelId.java]
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, + // Explicitly use outboundClosed as we want to drain any bytes that are still present., + // If the outbound was closed we want to ensure we can produce the alert to the destination buffer., + // This is true even if we not using jdkCompatibilityMode., + //, + // We use a plaintextLength of 2 as we at least want to have an alert fit into it., + // https://tools.ietf.org/html/rfc5246#section-7.2, + if (!isBytesAvailableEnoughForWrap(dst.remaining(), 2, 1)) {, + return new SSLEngineResult(BUFFER_OVERFLOW, getHandshakeStatus(), 0, 0);, + }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, + // Explicitly use outboundClosed as we
[+++ b/example/src/main/java/io/netty/example/http/websocketx/benchmarkserver/WebSocketServer.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java, + * thus 'kept alive'. This methods respects the value of the., + /**, + * Set the {@link HttpHeaderNames#TRANSFER_ENCODING} to either include {@link HttpHeaderValues#CHUNKED} if, + * {@code chunked} is {@code true}, or remove {@link HttpHeaderValues#CHUNKED} if {@code chunked} is {@code false}., + * @param m The message which contains the headers to modify., + * @param chunked if {@code true} then include {@link HttpHeaderValues#CHUNKED} in the headers. otherwise remove, + * {@link HttpHeaderValues#CHUNKED} from the headers., + */]
[+++ b/example/src/main/java/io/netty/example/memcache/binary/MemcacheClientHandler.java, + extras.writeZero(8);]
[+++ b/microbench/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, + <properties>, + <!-- Skip tests by default; run only if -DskipTests=false is specified -->, + <skipTests>true</skipTests>, + </properties>, +]
[+++ b/all/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/codec-http2/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.6.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ /dev/null, +++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +, + // If the list is empty we need to assign a new one because, + // we get a List that is immutable. , + //, + // See https://github.com/netty/netty/issues/325, + if (list.isEmpty()) {, + list = new ArrayList<ChannelBuffer>(1);, + }, + ,
[+++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, + * Find the index of the first non-white space character in {@code s} starting at {@code offset}., + * @param seq The string to search., + * @param offset The offset to start searching at., + * @return the index of the first non-white space character or &lt;{@code 0} if none was found., + */, + public static int indexOfNonWhiteSpace(CharSequence seq, int offset) {, + for (; offset < seq.length(); ++offset) {, + if (!Character.isWhitespace(seq.charAt(offset))) {, + return offset;, + }, + }, + return -1;, + }, +, + /**, +++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, + * Find
[+++ b/common/src/main/java/io/netty/util/internal/JavassistTypeParameterMatcherGenerator.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.internal.StringUtil;, + return StringUtil.simpleClassName(this) + "(freed)";, + buf.append(StringUtil.simpleClassName(this));, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.internal.StringUtil;, + return StringUtil.simpleClassName(this) + "(freed)";, + buf.append(StringUtil.simpleClassName(this));, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, +import io.netty.util.internal.StringUtil;, + return StringUtil.simpleClassName(this) + '(' + content().toString() + ')';, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.internal.StringUtil;, + return StringUtil.simpleClassName(this) + "(freed)";, + buf.append(StringUtil.simpleClassName(this));, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, +import io.netty.util.internal.StringUtil;, + return StringUtil.simpleClassName(this) + '(' + content().toString() + ')';, +++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, +import io.netty.util.internal.StringUtil;, + str = StringUtil.simpleClassName(this) + (order == ByteOrder.BIG_ENDIAN? "BE" : "LE");, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.internal.StringUtil;, + return StringUtil.simpleClassName(this) + "(freed)";, + buf.append(StringUtil.simpleClassName(this));, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, +import io.netty.util.internal.StringUtil;, + return StringUtil.simpleClassName(this) + '(' + content().toString() + ')';, +++
[+++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + setByteBuffer(allocateDirect(initialCapacity));, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + setByteBuffer(allocateDirect(initialCapacity));, +++ b/buffer/src/test/java/io/netty/buffer/FixedCompositeByteBufTest.java, + @Test, + } catch (UnsupportedOperationException expected) {, + // expected, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + setByteBuffer(allocateDirect(initialCapacity));, +++ b/buffer/src/test/java/io/netty/buffer/FixedCompositeByteBufTest.java, + @Test, + } catch (UnsupportedOperationException expected) {, + // expected, +++ b/pom.xml, + <argLine.noUnsafe>-Dio.netty.noUnsafe=true</argLine.noUnsafe>, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + setByteBuffer(allocateDirect(initialCapacity));, +++ b/buffer/src/test/java/io/netty/buffer/FixedCompositeByteBufTest.java, + @Test, + } catch (UnsupportedOperationException expected) {, + // expected, +++ b/pom.xml, + <argLine.noUnsafe>-Dio.netty.noUnsafe=true</argLine.noUnsafe>, +++ b/transport-native-epoll/src/main/c/netty_epoll_native.c, +#include "netty_unix_buffer.h", + if (netty_unix_buffer_JNI_OnLoad(env, packagePrefix) == JNI_ERR) {, + return JNI_ERR;, + }, + netty_unix_buffer_JNI_OnUnLoad(env);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + setByteBuffer(allocateDirect(initialCapacity));, +++ b/buffer/src/test/java/io/netty/buffer/FixedCompositeByteBufTest.java, + @Test, + } catch (UnsupportedOperationException expected) {, + // expected, +++
[+++ b/pom.xml, + <version>3.1.0.ALPHA2</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.1.0.ALPHA2</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.1.0.ALPHA2</developerConnection>]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + if (SSL.writeToBIO(bio, OpenSsl.memoryAddress(buffer) + buffer.readerIndex(), readable) != readable) {]
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, +import io.netty.channel.PartialFlushException;, + boolean encoded = false;, + encoded = true;, + Throwable cause;, + cause = t;, + cause = new EncoderException(t);, + if (encoded) {, + cause = new PartialFlushException("Unable to encoded all bytes", cause);, + }, + in.discardSomeReadBytes();, + promise.setFailure(cause);, + return;, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, +import io.netty.channel.PartialFlushException;, + boolean encoded = false;, + encoded = true;, + Throwable cause;, + cause = t;, + cause = new EncoderException(t);, + if (encoded) {, + cause = new PartialFlushException("Unable to encoded all bytes", cause);, + }, + in.discardSomeReadBytes();, + promise.setFailure(cause);, + return;, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, +import io.netty.channel.PartialFlushException;, +
[+++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ /dev/null, +++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + throw new IndexOutOfBoundsException("Invalid readerIndex: " , + + readerIndex + " - Maximum is " + writerIndex);, + throw new IndexOutOfBoundsException("Invalid writerIndex: " , + + writerIndex + " - Maximum is " + readerIndex + " or " + capacity());, + throw new IndexOutOfBoundsException("Invalid indexes: readerIndex is ", + + readerIndex + ", writerIndex is ", + + writerIndex + ", capacity is " + capacity());, + return readableBytes() > 0;, + throw new IndexOutOfBoundsException("Writable bytes exceeded: Got "
[+++ b/all/pom.xml, + <artifactId>netty-codec-memcache</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Exception.java, + private static final long serialVersionUID = -8807603212183882637L;, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Exception.java, + private static final long serialVersionUID = -8807603212183882637L;, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamChannelId.java, + private static final long serialVersionUID = -6642338822166867585L;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Exception.java, + private static final long serialVersionUID = -8807603212183882637L;, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamChannelId.java, + private static final long serialVersionUID = -6642338822166867585L;, +++ b/codec/src/test/java/io/netty/handler/codec/serialization/CompatibleObjectEncoderTest.java, + private static final long serialVersionUID = 2235771472534930360L;, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Exception.java, + private static final long serialVersionUID = -8807603212183882637L;, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamChannelId.java, + private static final long serialVersionUID = -6642338822166867585L;, +++ b/codec/src/test/java/io/netty/handler/codec/serialization/CompatibleObjectEncoderTest.java, + private static final long serialVersionUID = 2235771472534930360L;, +, +++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java, +
[+++ b/pom.xml, + <pluginManagement>, + <plugins>, + <!--This plugin's configuration is used to store Eclipse m2e settings only. , + It has no influence on the Maven build itself. -->, + <plugin>, + <groupId>org.eclipse.m2e</groupId>, + <artifactId>lifecycle-mapping</artifactId>, + <version>1.0.0</version>, + <configuration>, + <lifecycleMappingMetadata>, + <pluginExecutions>, + <pluginExecution>, + <pluginExecutionFilter>, + <groupId>org.apache.maven.plugins</groupId>, + <artifactId>maven-antrun-plugin</artifactId>, + <versionRange>[1.7,)</versionRange>, + <goals>, + <goal>run</goal>, + </goals>, + </pluginExecutionFilter>, + <action>, + <ignore />, + </action>, + </pluginExecution>, + </pluginExecutions>, + </lifecycleMappingMetadata>, + </configuration>, + </plugin>, + </plugins>, + </pluginManagement>, +, +++ b/pom.xml, + <pluginManagement>, + <plugins>, + <!--This plugin's configuration is used to store Eclipse
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpScheme.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/example/pom.xml, + ${argLine.alpnAgent}, +++ b/example/pom.xml, + ${argLine.alpnAgent}, +++ b/handler/pom.xml, +++ b/example/pom.xml, + ${argLine.alpnAgent}, +++ b/handler/pom.xml, +++ b/pom.xml, + <jetty.alpnAgent.option>forceNpn=true</jetty.alpnAgent.option>, + <jetty.alpnAgent.version>1.0.0.Final</jetty.alpnAgent.version>, + <jetty.alpnAgent.path>${settings.localRepository}/kr/motd/javaagent/jetty-alpn-agent/${jetty.alpnAgent.version}/jetty-alpn-agent-${jetty.alpnAgent.version}.jar</jetty.alpnAgent.path>, + <!-- Default to ALPN. See forcenpn profile to force NPN -->, + <argLine.alpnAgent>-javaagent:${jetty.alpnAgent.path}=${jetty.alpnAgent.option}</argLine.alpnAgent>, + <scope>provided</scope> <!-- Provided by npn-boot -->, + <id>get-jetty-alpn-agent</id>, + <groupId>kr.motd.javaagent</groupId>, + <artifactId>jetty-alpn-agent</artifactId>, + <version>${jetty.alpnAgent.version}</version>, + <argLine>${argLine.common} ${argLine.alpnAgent} ${argLine.leak} ${argLine.coverage}</argLine>]
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoderTest.java, +import io.netty.channel.ChannelConfig;, +import io.netty.channel.ChannelMetadata;, +import io.netty.channel.DefaultChannelConfig;, + private Channel.Unsafe unsafe;, +, + @Mock, + ChannelMetadata metadata = new ChannelMetadata(false, 16);, + when(channel.metadata()).thenReturn(metadata);, + when(channel.unsafe()).thenReturn(unsafe);, + ChannelConfig config = new DefaultChannelConfig(channel);, + when(channel.config()).thenReturn(config);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoderTest.java, +import io.netty.channel.ChannelConfig;, +import io.netty.channel.ChannelMetadata;, +import io.netty.channel.DefaultChannelConfig;, + private Channel.Unsafe unsafe;, +, + @Mock, + ChannelMetadata metadata = new ChannelMetadata(false, 16);, + when(channel.metadata()).thenReturn(metadata);, + when(channel.unsafe()).thenReturn(unsafe);, + ChannelConfig config = new DefaultChannelConfig(channel);, + when(channel.config()).thenReturn(config);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/StreamBufferingEncoderTest.java, +import io.netty.channel.ChannelMetadata;, +import io.netty.channel.DefaultMessageSizeEstimator;, + private Channel.Unsafe unsafe;, +, + @Mock, + when(config.getMessageSizeEstimator()).thenReturn(DefaultMessageSizeEstimator.DEFAULT);, + ChannelMetadata metadata = new ChannelMetadata(false, 16);, + when(channel.metadata()).thenReturn(metadata);, + when(channel.unsafe()).thenReturn(unsafe);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoderTest.java, +import io.netty.channel.ChannelConfig;, +import
[+++ b/src/docbook/module/architecture.xml, + the other tedious and difficult. The lack of portability between, + transports becomes a problem when you need to support more transports not, + rewriting the network layer of the application. Logically, many protocols, + can run on more than one transport such as TCP/IP, UDP/IP, SCTP, and, + serial port communication., +++ b/src/docbook/module/architecture.xml, + the other tedious and difficult. The lack of portability between, + transports becomes a problem when you need to support more transports not, + rewriting the network layer of the application. Logically, many protocols, + can run on more than one
[+++ b/microbench/src/main/java/io/netty/microbench/http/HttpObjectEncoderBenchmark.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/all/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/example/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec/pom.xml, +
[+++ b/codec-smtp/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<!--, + ~ Copyright 2016 The Netty Project, + ~, + ~ The Netty Project licenses this file to you under the Apache License,, + ~ version 2.0 (the "License"); you may not use this file except in compliance, + ~ with the License. You may obtain a copy of the License at:, + ~, + ~ http://www.apache.org/licenses/LICENSE-2.0, + ~, + ~ Unless required by applicable law or agreed to in writing, software, + ~ distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + ~ WARRANTIES OR CONDITIONS OF ANY
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, + if ((numberOfColons != 6 && !doubleColon) || numberOfColons > 7 ||, + if (i == startOffset && (endOffset <= i || ipAddress.charAt(i + 1) != ':')) {, + if (numberOfColons > 8) {, + if (word.length() == 0) {, + if (ipAddress.charAt(endOffset - 1) == ':' &&, + ipAddress.charAt(endOffset - 2) != ':') {, + return false;, + }, + } else if (numberOfColons == 8 && ipAddress.charAt(startOffset) != ':') {, + currentIndex + 1 >= bytes.length ||, + begin < 0 && ip.charAt(tmp - 1) != ':' ||, + compressBegin > 2 && ip.charAt(0) ==
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCnameCache.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/common/src/main/java/io/netty/util/NetworkConstants.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java]
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java, +import io.netty.util.concurrent.ScheduledFuture;, + private final ConcurrentMap<String, List<DefaultDnsCacheEntry>> resolveCache =, + PlatformDependent.newConcurrentHashMap();, + for (Iterator<Map.Entry<String, List<DefaultDnsCacheEntry>>> i = resolveCache.entrySet().iterator();, + i.hasNext();) {, + final Map.Entry<String, List<DefaultDnsCacheEntry>> e = i.next();, + for (Iterator<Map.Entry<String, List<DefaultDnsCacheEntry>>> i = resolveCache.entrySet().iterator();, + i.hasNext();) {, + final Map.Entry<String, List<DefaultDnsCacheEntry>> e = i.next();, + public List<? extends DnsCacheEntry> get(String hostname, DnsRecord[] additionals) {, + private List<DefaultDnsCacheEntry> cachedEntries(String hostname) {, + List<DefaultDnsCacheEntry> oldEntries = resolveCache.get(hostname);, + final List<DefaultDnsCacheEntry> entries;, + List<DefaultDnsCacheEntry> newEntries = new ArrayList<DefaultDnsCacheEntry>(8);, + public DnsCacheEntry cache(String hostname, DnsRecord[] additionals,, + final DefaultDnsCacheEntry e = new DefaultDnsCacheEntry(hostname, address);, + return e;, + final List<DefaultDnsCacheEntry>
[+++ b/handler/src/main/java/io/netty/handler/ssl/util/ThreadLocalInsecureRandom.java, + * Insecure {@link SecureRandom} which relies on {@link PlatformDependent#threadLocalRandom()} for random number generation.]
[+++ b/transport-native-unix-common-tests/pom.xml]
[+++ b/common/src/main/java/io/netty/util/concurrent/Future.java, + * Removes the first occurrence of the specified listener from this future., + * Removes the first occurrence for each of the listeners from this future.]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java, + header.writeBytes(mask);]
[+++ b/pom.xml, + <version>2.2.1</version>]
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +import java.util.Deque;, +import java.util.concurrent.ConcurrentLinkedDeque;, +import java.util.concurrent.LinkedBlockingDeque;, + /**, + * Returns a new concurrent {@link Deque}., + */, + public static <C> Deque<C> newConcurrentDeque() {, + if (javaVersion() < 7) {, + return new LinkedBlockingDeque<C>();, + } else {, + return new ConcurrentLinkedDeque<C>();, + }, + }, +, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +import java.util.Deque;, +import java.util.concurrent.ConcurrentLinkedDeque;, +import java.util.concurrent.LinkedBlockingDeque;, + /**, + * Returns a new concurrent {@link Deque}., + */, + public static <C> Deque<C> newConcurrentDeque() {, + if (javaVersion() < 7) {, + return new LinkedBlockingDeque<C>();, + } else {, + return new ConcurrentLinkedDeque<C>();, + }, + },
[+++ b/codec/src/test/java/io/netty/handler/codec/compression/Bzip2DecoderTest.java, + msg.release();, + uncompressed.release();]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, + *, + * <P>According to RFC 7231, POST, PUT and OPTIONS allow to have a body., + * This encoder will support widely all methods except TRACE since the RFC notes, + * for GET, DELETE, HEAD and CONNECT: (replaces XXX by one of these methods)</P>, + * <P>"A payload within a XXX request message has no defined semantics;, + * sending a payload body on a XXX request might cause some existing, + * implementations to reject the request."</P>, + * <P>On the contrary, for TRACE method, RFC says:</P>, + * <P>"A client MUST NOT
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + if (stream.state() == IDLE) {, + // We cannot write RST_STREAM frames on IDLE streams https://tools.ietf.org/html/rfc7540#section-6.4., + if (future.isDone()) {, + processRstStreamWriteResult(ctx, stream, future);, + } else {, + processRstStreamWriteResult(ctx, stream, future);, + }, + ChannelFutureListener closeListener = this.closeListener;, + this.closeListener = null;, + private void processRstStreamWriteResult(ChannelHandlerContext ctx, Http2Stream stream, ChannelFuture future) {, + if (future.isSuccess()) {, + closeStream(stream, future);, + } else {, + // The connection will be closed and so no need to change the resetSent flag to false., + onConnectionError(ctx, future.cause(), null);, + }, + }, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + if (stream.state()
[+++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, + * If the {@link SingleThreadEventExecutor} is not started yet, this operation will start it and block until, +++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, + * If the {@link SingleThreadEventExecutor} is not started yet, this operation will start it and block until, +++ b/common/src/test/java/io/netty/util/concurrent/SingleThreadEventExecutorTest.java, + public void testWrappedExecutorIsShutdown() {]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + *, + * @deprecated Do not use., +@Deprecated, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + *, + * @deprecated Do not use., +@Deprecated, +++ b/buffer/src/main/java/io/netty/buffer/DuplicatedAbstractByteBuf.java, + DuplicatedAbstractByteBuf(AbstractByteBuf buffer) {, + public AbstractByteBuf unwrap() {, + return (AbstractByteBuf) super.unwrap();, + }, +, + @Override, + return unwrap()._getByte(index);, + return unwrap()._getShort(index);, + }, +, + @Override, + protected short _getShortLE(int index) {, + return unwrap()._getShortLE(index);, + return unwrap()._getUnsignedMedium(index);, + }, +, + @Override, + protected int _getUnsignedMediumLE(int index) {, + return unwrap()._getUnsignedMediumLE(index);, + return unwrap()._getInt(index);, + }, +, + @Override, + protected int _getIntLE(int index) {, + return unwrap()._getIntLE(index);, + return unwrap()._getLong(index);,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java, + SpdyHeaders.setVersion(spdyVersion, spdySynStreamFrame, httpMessage.getProtocolVersion());]
[+++ b/handler/pom.xml, + <properties> , + <!-- Needed for SelfSignedCertificate -->, + <argLine.java9.extras>--add-exports java.base/sun.security.x509=ALL-UNNAMED</argLine.java9.extras>, + </properties>, +, +++ b/handler/pom.xml, + <properties> , + <!-- Needed for SelfSignedCertificate -->, + <argLine.java9.extras>--add-exports java.base/sun.security.x509=ALL-UNNAMED</argLine.java9.extras>, + </properties>, +, +++ b/pom.xml, + <argLine.java9.extras></argLine.java9.extras>, + <argLine.java9>--add-modules java.xml.bind ${argLine.java9.extras}</argLine.java9>, +++ b/handler/pom.xml, + <properties> , + <!-- Needed for SelfSignedCertificate -->, + <argLine.java9.extras>--add-exports java.base/sun.security.x509=ALL-UNNAMED</argLine.java9.extras>, + </properties>, +, +++ b/pom.xml, + <argLine.java9.extras></argLine.java9.extras>, + <argLine.java9>--add-modules java.xml.bind ${argLine.java9.extras}</argLine.java9>, +++ b/testsuite/pom.xml, + <!-- Needed for SSL tests as these use the SelfSignedCertificate --> , + <argLine.java9.extras>--add-exports java.base/sun.security.x509=ALL-UNNAMED</argLine.java9.extras>, +++ b/handler/pom.xml, + <properties> , + <!-- Needed for SelfSignedCertificate -->, + <argLine.java9.extras>--add-exports java.base/sun.security.x509=ALL-UNNAMED</argLine.java9.extras>,
[+++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/codec/src/main/java/io/netty/handler/codec/LengthFieldPrepender.java, +import java.util.List;, +, +public class LengthFieldPrepender extends MessageToMessageEncoder<ByteBuf> {, + protected void encode(ChannelHandlerContext ctx, ByteBuf msg, List<Object> out) throws Exception {, + out.add(ctx.alloc().buffer(1).writeByte((byte) length));, + out.add(ctx.alloc().buffer(2).writeShort((short) length));, + out.add(ctx.alloc().buffer(3).writeMedium(length));, + out.add(ctx.alloc().buffer(4).writeInt(length));, + out.add(ctx.alloc().buffer(8).writeLong(length));, + out.add(msg.retain());, +++ b/codec/src/main/java/io/netty/handler/codec/LengthFieldPrepender.java, +import java.util.List;, +, +public class LengthFieldPrepender extends MessageToMessageEncoder<ByteBuf> {, + protected void encode(ChannelHandlerContext ctx, ByteBuf msg, List<Object> out) throws Exception {, + out.add(ctx.alloc().buffer(1).writeByte((byte) length));, + out.add(ctx.alloc().buffer(2).writeShort((short) length));, + out.add(ctx.alloc().buffer(3).writeMedium(length));, + out.add(ctx.alloc().buffer(4).writeInt(length));, + out.add(ctx.alloc().buffer(8).writeLong(length));, + out.add(msg.retain());, +++ b/codec/src/test/java/io/netty/handler/codec/frame/LengthFieldPrependerTest.java, + ByteBuf buf = (ByteBuf) ch.readOutbound();, + assertEquals(4, buf.readableBytes());, + assertEquals(msg.readableBytes(), buf.readInt());, + buf.release();, +, + buf = (ByteBuf) ch.readOutbound();, + assertSame(buf, msg);,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DefaultHttpDataFactory.java, +, + * Keep all HttpDatas until cleanAllHttpData() is called., + public void cleanRequestHttpData(HttpRequest request) {, + public void cleanAllHttpData() {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DefaultHttpDataFactory.java, +, + * Keep all HttpDatas until cleanAllHttpData() is called., + public void cleanRequestHttpData(HttpRequest request) {, + public void cleanAllHttpData() {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpDataFactory.java, +, + void cleanRequestHttpData(HttpRequest request);, + void cleanAllHttpData();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DefaultHttpDataFactory.java, +, + * Keep all HttpDatas until cleanAllHttpData() is called., + public void cleanRequestHttpData(HttpRequest request) {, + public void cleanAllHttpData() {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpDataFactory.java, +, + void cleanRequestHttpData(HttpRequest request);, + void cleanAllHttpData();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, + factory.cleanRequestHttpData(request);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DefaultHttpDataFactory.java, +, + * Keep
[+++ b/buffer/src/main/java/io/netty/buffer/MessageBufs.java, + public static <T> MessageBuf<T> buffer() {, + public static <T> MessageBuf<T> buffer(int initialCapacity) {, + public static <T> MessageBuf<T> wrappedBuffer(Queue<T> queue) {, +++ b/buffer/src/main/java/io/netty/buffer/MessageBufs.java, + public static <T> MessageBuf<T> buffer() {, + public static <T> MessageBuf<T> buffer(int initialCapacity) {, + public static <T> MessageBuf<T> wrappedBuffer(Queue<T> queue) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +import io.netty.buffer.MessageBuf;, +import io.netty.buffer.MessageBufs;, +import io.netty.channel.ChannelInboundMessageHandler;, +import io.netty.channel.ChannelOutboundMessageHandler;, + implements ChannelInboundMessageHandler<Object>, ChannelOutboundMessageHandler<Object> {, + public MessageBuf<Object> newInboundBuffer(ChannelHandlerContext ctx) throws Exception {, + return MessageBufs.buffer();, + public MessageBuf<Object> newOutboundBuffer(ChannelHandlerContext ctx) throws Exception {, + return MessageBufs.buffer();, +++ b/buffer/src/main/java/io/netty/buffer/MessageBufs.java, + public static <T> MessageBuf<T> buffer() {, + public static
[+++ b/pom.xml, +++ b/pom.xml, +++ b/testsuite/pom.xml, + <version>0.1.4</version>]
[+++ b/pom.xml, + <version>2.3.0-SNAPSHOT</version>, +++ b/pom.xml, + <version>2.3.0-SNAPSHOT</version>, +++ b/testsuite/.gitignore, +, +#, +# UDT native libraries extract location., +#, +, +/lib, +++ b/pom.xml, + <version>2.3.0-SNAPSHOT</version>, +++ b/testsuite/.gitignore, +, +#, +# UDT native libraries extract location., +#, +, +/lib, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/udt/UDTClientServerConnectionTest.java, +import static org.junit.Assert.*;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +/**, + * Verify UDT connect/disconnect life cycle., + */, + static class Client implements Runnable {, + static final Logger log = LoggerFactory.getLogger(Client.class);, + final String host;, + final int port;, + volatile Channel channel;, + volatile boolean isRunning;, + volatile boolean isShutdown;, + Client(final String host, final int port) {,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, + if (values.isEmpty()) {, + return;, + }, + Iterator<String> valuesIt = values.iterator();, + while(valuesIt.hasNext()) {, + String value = valuesIt.next();, + if (value.equalsIgnoreCase(Values.CHUNKED)) {, + valuesIt.remove();, + }, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, + if (values.isEmpty()) {, + return;, + }, + Iterator<String> valuesIt = values.iterator();, + while(valuesIt.hasNext()) {, + String value = valuesIt.next();, + if (value.equalsIgnoreCase(Values.CHUNKED)) {, + valuesIt.remove();, + }, + }, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpHeadersTest.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you
[+++ b/pom.xml, + <groupId>org.sonatype.oss</groupId>, + <artifactId>oss-parent</artifactId>, + <version>7</version>, + <groupId>io.netty</groupId>]
[+++ b/pom.xml, + <version>1.2.2.GA</version>]
[+++ b/pom.xml, + <version>3.0.0.CR4-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandler.java, +import io.netty.buffer.ByteBuf;, +import io.netty.handler.codec.http.HttpContent;, +import io.netty.handler.codec.http.HttpMessage;, +import io.netty.handler.codec.http.LastHttpContent;, +import io.netty.util.ReferenceCountUtil;, +, + private int currentStreamId;, +, + * Handles conversion of {@link HttpMessage} and {@link HttpContent} to HTTP/2 frames., +, + if (!(msg instanceof HttpMessage || msg instanceof HttpContent)) {, + ctx.write(msg, promise);, + return;, + }, +, + boolean release = true;, + SimpleChannelPromiseAggregator promiseAggregator =, + new SimpleChannelPromiseAggregator(promise, ctx.channel(), ctx.executor());, + Http2ConnectionEncoder encoder = encoder();, + boolean endStream = false;, + if (msg instanceof HttpMessage) {, + final HttpMessage httpMsg = (HttpMessage) msg;, +, + currentStreamId = getStreamId(httpMsg.headers());, + endStream = msg instanceof FullHttpMessage &&
[+++ b/handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/all/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/example/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/codec/pom.xml, +
[+++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java, +import io.netty.channel.ChannelConfig;, + *, + * <h3>Available options</h3>, + *, + * In addition to the options provided by {@link ChannelConfig},, + * {@link RxtxChannelConfig} allows the following options in the option map:, + *, + * <table border="1" cellspacing="0" cellpadding="6">, + * <tr>, + * <th>Name</th><th>Associated setter method</th>, + * </tr><tr>, + * <td>{@link io.netty.channel.rxtx.RxtxChannelOption#BAUD_RATE}</td><td>{@link #setBaudrate(int)}</td>, + * </tr><tr>, + * <td>{@link io.netty.channel.rxtx.RxtxChannelOption#DTR}</td><td>{@link #setDtr(boolean)}</td>, + * </tr><tr>, + * <td>{@link io.netty.channel.rxtx.RxtxChannelOption#RTS}</td><td>{@link #setRts(boolean)}</td>, + * </tr><tr>, + * <td>{@link io.netty.channel.rxtx.RxtxChannelOption#STOP_BITS}</td><td>{@link #setStopbits(Stopbits)}</td>, + * </tr><tr>, + * <td>{@link io.netty.channel.rxtx.RxtxChannelOption#DATA_BITS}</td><td>{@link #setDatabits(Databits)}</td>, + * </tr><tr>, + * <td>{@link io.netty.channel.rxtx.RxtxChannelOption#PARITY_BIT}</td><td>{@link #setParitybit(Paritybit)}</td>,
[+++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, + protected abstract class DefaultServerUnsafe extends AbstractUnsafe {, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, + protected abstract class DefaultServerUnsafe extends AbstractUnsafe {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, + void suspendRead();, + void resumeRead();, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, + protected abstract class DefaultServerUnsafe extends AbstractUnsafe {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, + void suspendRead();, + void resumeRead();, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, +, + boolean isReadable();, + void readable(boolean readable);, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, + protected abstract class DefaultServerUnsafe extends AbstractUnsafe {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, + void suspendRead();, + void resumeRead();, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, +, + boolean isReadable();, + void readable(boolean readable);, +++ b/transport/src/main/java/io/netty/channel/ChannelStateHandler.java, +, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, + protected abstract class DefaultServerUnsafe extends AbstractUnsafe {, +++ b/transport/src/main/java/io/netty/channel/Channel.java,
[+++ b/all/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.2.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/util/FingerprintTrustManagerFactory.java, + list.add(farr);]
[+++ b/example/src/main/java/io/netty/example/http2/helloworld/frame/server/HelloWorldHttp2Handler.java, + @Override, + public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {, + ctx.flush();, + }, +, + private static void onDataRead(ChannelHandlerContext ctx, Http2DataFrame data) throws Exception {, + private static void onHeadersRead(ChannelHandlerContext ctx, Http2HeadersFrame headers), + ctx.write(new DefaultHttp2DataFrame(payload, true).streamId(streamId));, +++ b/example/src/main/java/io/netty/example/http2/helloworld/frame/server/HelloWorldHttp2Handler.java, + @Override, + public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {, + ctx.flush();, + }, +, + private static void onDataRead(ChannelHandlerContext ctx, Http2DataFrame data) throws Exception {, + private static void onHeadersRead(ChannelHandlerContext ctx, Http2HeadersFrame headers), + ctx.write(new DefaultHttp2DataFrame(payload, true).streamId(streamId));, +++ b/example/src/main/java/io/netty/example/http2/helloworld/multiplex/server/HelloWorldHttp2Handler.java, + @Override, + public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {, + ctx.flush();, + }, +, + private
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.Unpooled;, + private ByteBuf expectedChallengeResponseBytes;, + expectedChallengeResponseBytes = Unpooled.wrappedBuffer(WebSocketUtil.md5(challenge));, + ByteBuf challenge = response.data();, + if (!challenge.equals(expectedChallengeResponseBytes)) {]
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + b = wrappedBuffer(, + wrappedBuffer(new byte[] { 1 }).order(order),, + b.release();, + b = wrappedBuffer(, + wrappedBuffer(new byte[]{1}).order(order),, + b.release();, + b = wrappedBuffer(, + wrappedBuffer(new byte[] { 0, 1, 2, 3, 4 }, 1, 2).order(order),, + b.release();, + b = wrappedBuffer(, + wrappedBuffer(new byte[] { 1, 2 }).order(order),, + b.release();, + b = wrappedBuffer(, + wrappedBuffer(new byte[] { 0, 1, 2, 4, 5 }, 1, 2).order(order),, + b.release();, + b = wrappedBuffer(, + wrappedBuffer(new byte[] { 1, 2, 3 }).order(order),, + b.release();, + b = wrappedBuffer(, + wrappedBuffer(new byte[] { 0, 1, 2, 3, 4,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, + if (code < 200) {, + // Old Web Socket upgrade response had 16-byte fixed length content., + if (code == 101 &&, + res.containsHeader(HttpHeaders.Names.SEC_WEBSOCKET_ORIGIN) &&, + res.containsHeader(HttpHeaders.Names.SEC_WEBSOCKET_LOCATION)) {, + return false;, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, + if (code < 200) {, + // Old Web Socket upgrade response had 16-byte fixed length content., + if (code == 101 &&, + res.containsHeader(HttpHeaders.Names.SEC_WEBSOCKET_ORIGIN) &&, + res.containsHeader(HttpHeaders.Names.SEC_WEBSOCKET_LOCATION)) {, + return false;, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpPostRequestDecoder.java, + if (method.equals(HttpMethod.POST) || method.equals(HttpMethod.PUT) || method.equals(HttpMethod.PATCH)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, + if (code < 200) {, + // Old Web Socket
[+++ b/pom.xml, + <tcnative.version>2.0.4.Final</tcnative.version>]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.AsciiString;, + if (CharsetUtil.US_ASCII.equals(charset) || CharsetUtil.ISO_8859_1.equals(charset)) {, + // ByteBufUtil.getBytes(...) will return a new copy which the AsciiString uses directly, + return new AsciiString(ByteBufUtil.getBytes(this, index, length, true), false);, + }, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.AsciiString;, + if (CharsetUtil.US_ASCII.equals(charset) || CharsetUtil.ISO_8859_1.equals(charset)) {, + // ByteBufUtil.getBytes(...) will return a new copy which the AsciiString uses directly, + return new AsciiString(ByteBufUtil.getBytes(this, index, length, true), false);, + }, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +import java.nio.CharBuffer;, + private static final CharBuffer EXTENDED_ASCII_CHARS, ASCII_CHARS;, +, + static {, + char[] chars = new char[256];, + for (char c = 0; c < chars.length; c++) {, +
[+++ b/transport/src/main/java/io/netty/channel/pool/FixedChannelPool.java, +import io.netty.util.concurrent.GlobalEventExecutor;, + if (executor.inEventLoop()) {, + close0();, + } else {, + executor.submit(new Runnable() {, + close0();, + }, + }).awaitUninterruptibly();, + }, + }, +, + private void close0() {, +, + // Ensure we dispatch this on another Thread as close0 will be called from the EventExecutor and we need, + // to ensure we will not block in a EventExecutor., + GlobalEventExecutor.INSTANCE.execute(new Runnable() {, + @Override, + public void run() {, +}, +++ b/transport/src/main/java/io/netty/channel/pool/FixedChannelPool.java, +import io.netty.util.concurrent.GlobalEventExecutor;, + if (executor.inEventLoop()) {, + close0();, + } else {, + executor.submit(new Runnable() {, + close0();, +
[+++ b/common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java, +import java.security.AccessController;, +import java.security.PrivilegedAction;, + private static final BlockingQueue<Long> seedQueue;, + boolean secureRandom = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {, + @Override, + public Boolean run() {, + return SystemPropertyUtil.getBoolean("java.util.secureRandomSeed", false);, + }, + });, +, + if (secureRandom) {, + seedQueue = new LinkedBlockingQueue<Long>();, + seedGeneratorStartTime = System.nanoTime();, +, + long s = ((long) seed[0] & 0xff) << 56 |, + ((long) seed[1] & 0xff) << 48 |, + ((long) seed[2] & 0xff) << 40 |, + ((long) seed[3] & 0xff) << 32 |, + ((long) seed[4] & 0xff) << 24 |, + ((long) seed[5] & 0xff) << 16
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/ClientCookieDecoder.java, + return cookieBuilder != null ? cookieBuilder.cookie() : null;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/ClientCookieDecoder.java, + return cookieBuilder != null ? cookieBuilder.cookie() : null;, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/cookie/ClientCookieDecoderTest.java, + public void testDecodingInvalidValuesWithCommaAtStart() {, + assertNull(ClientCookieDecoder.STRICT.decode(","));, + assertNull(ClientCookieDecoder.STRICT.decode(",a"));, + assertNull(ClientCookieDecoder.STRICT.decode(",a=a"));, + }, +, + @Test]
[+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundHandlerAdapter.java, + * Skeleton implementation of a {@link ChannelOutboundHandler}. This implementation just forwards each method call via, + * Calls {@link ChannelHandlerContext#deregister(ChannelPromise)} to forward, + * Calls {@link ChannelHandlerContext#write(Object, ChannelPromise)} to forward]
[+++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + if (components.isEmpty()) {, + return;, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + if (components.isEmpty()) {, + return;, + }, +, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, +import static io.netty.buffer.Unpooled.wrappedBuffer;, +, + @Test, + public void testRemoveLastComponent() {, + CompositeByteBuf buf = freeLater(compositeBuffer());, + buf.addComponent(wrappedBuffer(new byte[]{1, 2}));, + assertEquals(1, buf.numComponents());, + buf.removeComponent(0);, + assertEquals(0, buf.numComponents());, + }]
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeChannelBufferTest.java, + buffers.add(EMPTY_BUFFER);, + buffers.add(wrappedBuffer(new byte[1]));, + buffers.add(EMPTY_BUFFER);, + buffers.add(wrappedBuffer(new byte[2]));, + buffers.add(EMPTY_BUFFER);, + buffers.add(wrappedBuffer(new byte[3]));, + buffers.add(EMPTY_BUFFER);, + buffers.add(wrappedBuffer(new byte[4]));, + buffers.add(EMPTY_BUFFER);, + buffers.add(wrappedBuffer(new byte[5]));, + buffers.add(EMPTY_BUFFER);, + buffers.add(wrappedBuffer(new byte[6]));, + buffers.add(EMPTY_BUFFER);, + buffers.add(wrappedBuffer(new byte[7]));, + buffers.add(EMPTY_BUFFER);, + buffers.add(wrappedBuffer(new byte[8]));, + buffers.add(EMPTY_BUFFER);, + buffers.add(wrappedBuffer(new byte[9]));, + buffers.add(EMPTY_BUFFER);, + CompositeByteBuf buf = (CompositeByteBuf) wrappedBuffer(new byte[]{1, 2, 3, 4, 5}, new byte[]{4, 5, 6, 7, 8, 9, 26});, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeChannelBufferTest.java, + buffers.add(EMPTY_BUFFER);, + buffers.add(wrappedBuffer(new byte[1]));, + buffers.add(EMPTY_BUFFER);, + buffers.add(wrappedBuffer(new byte[2]));, + buffers.add(EMPTY_BUFFER);, + buffers.add(wrappedBuffer(new byte[3]));, + buffers.add(EMPTY_BUFFER);, + buffers.add(wrappedBuffer(new byte[4]));, + buffers.add(EMPTY_BUFFER);, + buffers.add(wrappedBuffer(new byte[5]));, + buffers.add(EMPTY_BUFFER);, + buffers.add(wrappedBuffer(new
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + DefaultChannelHandlerContext nextInbound = findContextInbound();, + if (nextInbound == next) {, + fireInboundBufferUpdated0(nextInbound);]
[+++ b/pom.xml, + <version>1.1.32.Fork1</version>]
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsPtrRecord.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec/src/test/java/io/netty/handler/codec/compression/SnappyIntegrationTest.java, +import org.junit.Ignore;, + @Ignore, + public void test5323211032315942961(){, + testWithSeed(5323211032315942961L);, + }, +, + @Test, + @Ignore, + public void test5956997334949727845(){, + testWithSeed(5956997334949727845L);, + }, +, + @Test, + @Ignore, + public void test987469642329137223(){, + testWithSeed(987469642329137223L);, + }, +, + @Test, + @Ignore, + public void test5798580555644912844(){, + testWithSeed(5798580555644912844L);, + }, +, + @Test, + @Ignore, + public void test6700065949554745127(){, + testWithSeed(6700065949554745127L);, + }, +, + @Test, + @Ignore, + public void test6262781682093393396(){, + testWithSeed(6262781682093393396L);, + }, +, + @Test, + @Ignore, + public void test358737913816100034(){, + testWithSeed(358737913816100034L);, + }, +, + @Test, + @Ignore, + public
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, +/*, + * Copyright 2012 Twitter, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License. You may obtain, + * a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, +
[+++ b/src/docbook/module/start.xml, + <programlisting>bootstrap.setPipelineFactory(new TimeClientPipelineFactory());</programlisting>]
[+++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, + URL url;, + if (loader == null) {, + url = ClassLoader.getSystemResource(path);, + } else {, + url = loader.getResource(path);, + }, + if (loader == null) {, + url = ClassLoader.getSystemResource(fileName);, + } else {, + }, + return Class.forName(helper.getName(), false, loader);, + if (loader == null) {, + // cannot defineClass inside bootstrap class loader, + throw e1;, + }, +++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, + URL url;, + if (loader == null) {, + url = ClassLoader.getSystemResource(path);, + } else {, + url = loader.getResource(path);, + }, + if (loader == null) {, + url =
[+++ b/src/docbook/en-US/module/preface.xml, + This user guide aims to give you the comprehensive introduction to, + <ulink url="&Home;">Netty</ulink> so that you can start to build a network, + application right away.]
[+++ b/all/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR2-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/Java7SslParametersUtils.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/pom.xml, + <version>2.0.2</version>, + <version>2.4.3</version>, + <version>1.4.3</version>, + <version>2.0.4</version>, + <version>1.3</version>, + <version>2.5</version>, + <version>2.1</version>, + <version>2.1.2</version>, + <version>2.2-beta-3</version>, + <version>2.0-beta-8</version>, + <updatePolicy>never</updatePolicy>, + <checksumPolicy>ignore</checksumPolicy>, + <releases>, + <enabled>true</enabled>, + <updatePolicy>interval:10080</updatePolicy>, + <checksumPolicy>ignore</checksumPolicy>, + </releases>, + <updatePolicy>never</updatePolicy>, + <checksumPolicy>ignore</checksumPolicy>, + <enabled>true</enabled>, + <checksumPolicy>ignore</checksumPolicy>]
[+++ b/codec/src/main/java/io/netty/handler/codec/sctp/SctpInboundByteStreamHandler.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameLogger.java, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +, + logger.log(level, "{} {} PRIORITY: streamId={} padding={} endStream={} length={} bytes={}", ctx.channel(),, + direction.name(), streamId, padding, endStream, data.readableBytes(), toString(data));, + logger.log(level, "{} {} PRIORITY: streamId={} headers={} padding={} endStream={}", ctx.channel(),, + direction.name(), streamId, headers, padding, endStream);, + logger.log(level, "{} {} PRIORITY: streamId={} headers={} streamDependency={} weight={} exclusive={} " +, + "padding={} endStream={}", ctx.channel(),, + direction.name(), streamId, headers, streamDependency, weight, exclusive, padding, endStream);, + logger.log(level, "{} {} PRIORITY: streamId={} streamDependency={} weight={} exclusive={}", ctx.channel(),, + direction.name(), streamId, streamDependency, weight, exclusive);, + logger.log(level, "{} {} RST_STREAM: streamId={} errorCode={}", ctx.channel(),, + direction.name(), streamId, errorCode);, + logger.log(level, "{} {} SETTINGS: ack=true",
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + return PlatformDependent.allocateUninitializedArray(MAX_TL_ARRAY_LEN);, + static final int MAX_TL_ARRAY_LEN = 1024;, +, + /**, + * Allocates a new array if minLength > {@link ByteBufUtil#MAX_TL_ARRAY_LEN}, + */, + static byte[] threadLocalTempArray(int minLength) {, + return minLength <= MAX_TL_ARRAY_LEN ? BYTE_ARRAYS.get(), + : PlatformDependent.allocateUninitializedArray(minLength);, + }, +, + array = threadLocalTempArray(len);, + if (length <= MAX_TL_ARRAY_LEN || !allocator.isDirectBufferPooled()) {, + getBytes(buffer, threadLocalTempArray(length), 0, chunkLen, out, length);, + } else {, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + return PlatformDependent.allocateUninitializedArray(MAX_TL_ARRAY_LEN);, + static final int MAX_TL_ARRAY_LEN = 1024;, +, + /**, + * Allocates a new array if minLength > {@link ByteBufUtil#MAX_TL_ARRAY_LEN}, + */, +
[+++ b/all/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/example/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha5</version>, +++ b/codec/pom.xml, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java, + * @see #setKeepAlive(HttpHeaders, HttpVersion, boolean), + setKeepAlive(message.headers(), message.protocolVersion(), keepAlive);, + }, +, + /**, + * Sets the value of the {@code "Connection"} header depending on the, + * protocol version of the specified message. This getMethod sets or removes, + * the {@code "Connection"} header depending on what the default keep alive, + * mode of the message's protocol version is, as specified by, + * {@link HttpVersion#isKeepAliveDefault()}., + * <ul>, + * <li>If the connection is kept alive by default:, + * <ul>, + * <li>set to {@code "close"} if {@code keepAlive} is {@code
[+++ b/src/docbook/module/architecture.xml, + stack. Interesting features of each core component will be explained in, + detail, too., + As you noticed from <xref linkend="start"/>, Netty uses its own buffer, + API instead of <classname>java.nio.ByteBuffer</classname> to hold a, + sequence of bytes. This approach has significant advantage over using, + <classname>ByteBuffer</classname>, which cannot be inherited to modify or, + augment its behavior at all. Netty's new buffer type, &ChannelBuffer; has, + been designed from ground up to address the problems of, + <classname>ByteBuffer</classname> and to meet the daily needs of network, + application developers., + <section>, + <title>Extensibility</title>, + <para>,
[+++ b/NOTICE.txt, +++ b/NOTICE.txt, +++ /dev/null, +++ b/NOTICE.txt, +++ /dev/null, +++ /dev/null, +++ b/NOTICE.txt, +++ /dev/null, +++ /dev/null, +++ b/license/LICENSE.lzma-java.txt, +, + Apache License, + Version 2.0, January 2004, + http://www.apache.org/licenses/, +, + TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION, +, + 1. Definitions., +, + "License" shall mean the terms and conditions for use, reproduction,, + and distribution as defined by Sections 1 through 9 of this document., +, + "Licensor" shall mean the copyright owner or entity authorized by, + the copyright owner that is granting the License., +, + "Legal Entity" shall mean the union
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + @Override, + protected final void finalize() throws Throwable {, + try {, + super.finalize();, + } finally {, + destroyPoolSubPages(smallSubpagePools);, + destroyPoolSubPages(tinySubpagePools);, + destroyPoolChunkLists(qInit, q000, q025, q050, q075, q100);, + }, + }, +, + private static void destroyPoolSubPages(PoolSubpage<?>[] pages) {, + for (PoolSubpage<?> page : pages) {, + page.destroy();, + }, + }, +, + private void destroyPoolChunkLists(PoolChunkList<T>... chunkLists) {, + for (PoolChunkList<T> chunkList: chunkLists) {, + chunkList.destroy(this);, + }, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + @Override, + protected final void finalize() throws Throwable {, + try {, + super.finalize();, + } finally {, +
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpHeadersTest.java, + public void testEqualsIgnoreCase() {]
[+++ b/pom.xml, + <version>16</version>]
[+++ b/handler/src/main/java/io/netty/handler/ssl/ExtendedOpenSslSession.java, + public final void handshakeFinished() throws SSLException {, + public final void tryExpandApplicationBufferSize(int packetLengthDataOnly) {, + public final String[] getLocalSupportedSignatureAlgorithms() {, + public final byte[] getId() {, + public final SSLSessionContext getSessionContext() {, + public final long getCreationTime() {, + public final long getLastAccessedTime() {, + public final void invalidate() {, + public final boolean isValid() {, + public final void putValue(String s, Object o) {, + public final Object getValue(String s) {, + public final void removeValue(String s) {, + public final String[] getValueNames() {, + public final Certificate[] getPeerCertificates() throws SSLPeerUnverifiedException {, + public final
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessage.java, + * An interface that defines a HTTP message, providing common properties for, + * {@link HttpRequest} and {@link HttpResponse}., + * @see HttpResponse, + * @see HttpRequest, + * Gets the value of a header with the specified name. If there are, + * more than one values for the specified name, the first value is returned., + * @param name The name of the header to search, + * @return The first header value or {@code null} if there is no such header, + * Returns the values of headers with the specified name, +
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + // Translate disconnect to close if the channel has no notion of disconnect-reconnect., + // So far, UDP/IP is the only transport that has such behavior., + if (!channel().metadata().hasDisconnect()) {, + next.invokeClose(promise);, + } else {, + }, + if (!channel().metadata().hasDisconnect()) {, + next.invokeClose(promise);, + } else {, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, + byteBuf = allocHandle.allocate(allocator);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, + byteBuf = allocHandle.allocate(allocator);, +++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java, + byteBuf = allocHandle.allocate(allocator);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, + byteBuf = allocHandle.allocate(allocator);, +++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java, + byteBuf = allocHandle.allocate(allocator);, +++ b/transport/src/main/java/io/netty/channel/oio/AbstractOioByteChannel.java, +import io.netty.channel.RecvByteBufAllocator;, + private RecvByteBufAllocator.Handle allocHandle;, + RecvByteBufAllocator.Handle allocHandle = this.allocHandle;, + if (allocHandle == null) {, + this.allocHandle = allocHandle = config.getRecvByteBufAllocator().newHandle();, + }, +, + ByteBuf byteBuf = allocHandle.allocate(alloc());, +, + int totalReadAmount = 0;, +, +, + if (totalReadAmount >= Integer.MAX_VALUE - localReadAmount) {, + // Avoid overflow., + totalReadAmount = Integer.MAX_VALUE;, + break;, + }, +, + totalReadAmount += localReadAmount;, +, + allocHandle.record(totalReadAmount);, +]
[+++ b/pom.xml, + <version>4</version>]
[+++ b/all/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/codec/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/codec/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/common/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta1</version>, +++ b/codec-socks/pom.xml, +
[+++ b/pom.xml, + <version>3.1.4.GA</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.1.4.GA</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.1.4.GA</developerConnection>]
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +import java.util.ArrayDeque;, +import java.util.Deque;, + private final Deque<FlushCheckpoint> flushCheckpoints = new ArrayDeque<FlushCheckpoint>();, + if (buf.hasMessageBuffer()) {, + Queue<Object> msgBuf = buf.messageBuffer();, + int localReadAmount = doRead(msgBuf);, + } else {, + ChannelBuffer byteBuf = buf.byteBuffer();, + for (;;) {, + int localReadAmount = doRead(byteBuf);, + if (localReadAmount > 0) {, + read = true;, + } else if (localReadAmount < 0) {, + closed = true;, + break;, + }, + if (!expandReadBuffer(byteBuf)) {, + break;, + }, + }, + }, + long checkpoint = flushedAmount + out().size();, + if (future instanceof FlushCheckpoint) {, + FlushCheckpoint
[+++ /dev/null, +++ /dev/null, +++ b/src/main/java/io/netty/bootstrap/Bootstrap.java, +++ /dev/null, +++ b/src/main/java/io/netty/bootstrap/Bootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, +++ /dev/null, +++ b/src/main/java/io/netty/bootstrap/Bootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ConnectionlessBootstrap.java, +++ /dev/null, +++ b/src/main/java/io/netty/bootstrap/Bootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ConnectionlessBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ServerBootstrap.java, +++ /dev/null, +++ b/src/main/java/io/netty/bootstrap/Bootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ConnectionlessBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ServerBootstrap.java, +++ b/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, +++ /dev/null, +++ b/src/main/java/io/netty/bootstrap/Bootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ConnectionlessBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ServerBootstrap.java, +++ b/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, +++ b/src/main/java/io/netty/buffer/AbstractChannelBufferFactory.java, +++ /dev/null, +++ b/src/main/java/io/netty/bootstrap/Bootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ConnectionlessBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ServerBootstrap.java, +++ b/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, +++ b/src/main/java/io/netty/buffer/AbstractChannelBufferFactory.java, +++ b/src/main/java/io/netty/buffer/BigEndianHeapChannelBuffer.java, +++ /dev/null, +++ b/src/main/java/io/netty/bootstrap/Bootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ConnectionlessBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ServerBootstrap.java, +++ b/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, +++ b/src/main/java/io/netty/buffer/AbstractChannelBufferFactory.java, +++ b/src/main/java/io/netty/buffer/BigEndianHeapChannelBuffer.java, +++ b/src/main/java/io/netty/buffer/ByteBufferBackedChannelBuffer.java, +++ /dev/null, +++ b/src/main/java/io/netty/bootstrap/Bootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ConnectionlessBootstrap.java, +++
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +import io.netty.channel.ChannelPromise;, + private final DnsQueryLifecycleObserverFactory dnsQueryLifecycleObserverFactory;, + * @param dnsQueryLifecycleObserverFactory used to generate new instances of {@link DnsQueryLifecycleObserver} which, + * can be used to track metrics for DNS servers., + DnsQueryLifecycleObserverFactory dnsQueryLifecycleObserverFactory,, + this.dnsQueryLifecycleObserverFactory =, + checkNotNull(dnsQueryLifecycleObserverFactory, "dnsQueryLifecycleObserverFactory");, + final DnsQueryLifecycleObserverFactory dnsQueryLifecycleObserverFactory() {, + return dnsQueryLifecycleObserverFactory;, + }, +, + /**, + * Provides the opportunity to sort the name servers before following a redirected DNS query., + * @param nameServers The addresses of the DNS servers which are used in the event of a redirect., + * @return A {@link DnsServerAddressStream} which will be
[+++ b/all/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta7</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/transport/src/main/java/io/netty/channel/socket/DatagramPacket.java, +public final class DatagramPacket {]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (nioBufferCount() == 1) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (nioBufferCount() == 1) {, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * Returns the maximum number of NIO {@link ByteBuffer}s that consist this buffer. Note that {@link #nioBuffers()}, + * or {@link #nioBuffers(int, int)} might return a less number of {@link ByteBuffer}s., + *, + * @return {@code -1} if this buffer has no underlying {@link ByteBuffer}., + * the number of the underlying {@link ByteBuffer}s if this buffer has at least one undelying, + * {@link ByteBuffer}. Note that this method does not return {@code 0} to avoid confusion., +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + for (Map.Entry<String, String> e : customHeaders.entrySet()) {, + request.addHeader(e.getKey(), e.getValue());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + for (Map.Entry<String, String> e : customHeaders.entrySet()) {, + request.addHeader(e.getKey(), e.getValue());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + for (Map.Entry<String, String> e : customHeaders.entrySet()) {, + request.addHeader(e.getKey(), e.getValue());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + for (Map.Entry<String, String> e : customHeaders.entrySet()) {, + request.addHeader(e.getKey(), e.getValue());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + for (Map.Entry<String, String> e : customHeaders.entrySet()) {, + request.addHeader(e.getKey(), e.getValue());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java, + for (Map.Entry<String, String> e: customHeaders.entrySet()) {, + request.addHeader(e.getKey(), e.getValue());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + for (Map.Entry<String, String> e : customHeaders.entrySet()) {, + request.addHeader(e.getKey(), e.getValue());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + for (Map.Entry<String, String> e : customHeaders.entrySet())
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + private final int maxCapacity;, + protected AbstractByteBuf(ByteOrder endianness, int maxCapacity) {, + if (maxCapacity < 0) {, + throw new IllegalArgumentException("maxCapacity: " + maxCapacity + " (expected: >= 0)");, + }, + this.maxCapacity = maxCapacity;, + public int maxCapacity() {, + return maxCapacity;, + }, +, + @Override, + adjustMarkers(readerIndex);, + adjustMarkers(readerIndex);, + protected void adjustMarkers(int decrement) {, + markedReaderIndex = Math.max(markedReaderIndex - decrement, 0);, + markedWriterIndex = Math.max(markedWriterIndex - decrement, 0);, +, + @Override, + public void ensureWritableBytes(int minWritableBytes) {, + if (minWritableBytes <= writableBytes()) {, + return;, + }, +, + if (minWritableBytes >
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + checkIndex0(index, fieldLength);, + }, +, + final void checkIndex0(int index, int fieldLength) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + checkIndex0(index, fieldLength);, + }, +, + final void checkIndex0(int index, int fieldLength) {, +++ b/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java, + checkIndex0(index, length);, + checkIndex0(index, length);, + checkIndex0(index, length);, + checkIndex0(index, length);, + checkIndex0(index, dst.remaining());, + checkIndex0(index, length);, + checkIndex0(index, length);, + checkIndex0(index, src.remaining());, + checkIndex0(index, length);, + checkIndex0(index, length);, + checkIndex0(index, length);, + checkIndex0(index, length);, + checkIndex0(index, length);, + checkIndex0(index, length);, + checkIndex0(index, length);, + checkIndex0(index, length);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + checkIndex0(index, fieldLength);, + }, +, + final void checkIndex0(int index, int fieldLength) {, +++
[+++ b/handler/src/main/java/io/netty/handler/ssl/ConscryptAlpnSslEngine.java, + Conscrypt.setBufferAllocator(engine, new BufferAllocatorAdapter(alloc));, + Conscrypt.setApplicationProtocols(engine, protocols.toArray(new String[protocols.size()]));, + long maxOverhead = (long) Conscrypt.maxSealOverhead(getWrappedEngine()) * numBuffers;, + return Conscrypt.unwrap(getWrappedEngine(), srcs, dests);, + Conscrypt.setHandshakeListener(engine, new HandshakeListener() {, + String protocol = Conscrypt.getApplicationProtocol(getWrappedEngine());, + Conscrypt.setHandshakeListener(engine, new HandshakeListener() {, + String protocol = Conscrypt.getApplicationProtocol(getWrappedEngine());, +++ b/handler/src/main/java/io/netty/handler/ssl/ConscryptAlpnSslEngine.java, + Conscrypt.setBufferAllocator(engine, new BufferAllocatorAdapter(alloc));, + Conscrypt.setApplicationProtocols(engine, protocols.toArray(new String[protocols.size()]));, + long maxOverhead = (long) Conscrypt.maxSealOverhead(getWrappedEngine()) * numBuffers;, + return Conscrypt.unwrap(getWrappedEngine(), srcs, dests);, + Conscrypt.setHandshakeListener(engine, new HandshakeListener() {, + String protocol = Conscrypt.getApplicationProtocol(getWrappedEngine());, + Conscrypt.setHandshakeListener(engine, new HandshakeListener() {, + String protocol = Conscrypt.getApplicationProtocol(getWrappedEngine());, +++ b/pom.xml, + <conscrypt.version>1.0.0.RC11</conscrypt.version>]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * if a buffer can be converted into an NIO buffer, use {@link #nioBufferCount()}.]
[+++ b/codec/src/main/java/io/netty/handler/codec/marshalling/ChannelBufferByteOutput.java, + ByteBuf getBuffer() {]
[+++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, + *, + * <p>When not used in a {@link ServerBootstrap} context, the {@link #bind()} methods are useful for connectionless, + * transports such as datagram (UDP).</p>, +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, + *, + * <p>When not used in a {@link ServerBootstrap} context, the {@link #bind()} methods are useful for connectionless, + * transports such as datagram (UDP).</p>, +++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, + * <p>The {@link #bind()} methods are useful in combination with connectionless transports such as datagram (UDP)., + * For regular TCP connections, please use the provided {@link #connect()} methods.</p>]
[+++ /dev/null, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/handler/timeout/IdleStateHandler.java, +import org.jboss.netty.util.Timeout;, +import org.jboss.netty.util.Timer;, +import org.jboss.netty.util.TimerTask;, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/handler/timeout/IdleStateHandler.java, +import org.jboss.netty.util.Timeout;, +import org.jboss.netty.util.Timer;, +import org.jboss.netty.util.TimerTask;, +++ b/src/main/java/org/jboss/netty/handler/timeout/ReadTimeoutHandler.java, +import org.jboss.netty.util.Timeout;, +import org.jboss.netty.util.Timer;, +import org.jboss.netty.util.TimerTask;, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/handler/timeout/IdleStateHandler.java, +import org.jboss.netty.util.Timeout;, +import org.jboss.netty.util.Timer;, +import org.jboss.netty.util.TimerTask;, +++ b/src/main/java/org/jboss/netty/handler/timeout/ReadTimeoutHandler.java, +import org.jboss.netty.util.Timeout;, +import org.jboss.netty.util.Timer;, +import org.jboss.netty.util.TimerTask;, +++ /dev/null, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/handler/timeout/IdleStateHandler.java, +import org.jboss.netty.util.Timeout;, +import org.jboss.netty.util.Timer;, +import org.jboss.netty.util.TimerTask;, +++ b/src/main/java/org/jboss/netty/handler/timeout/ReadTimeoutHandler.java, +import org.jboss.netty.util.Timeout;, +import org.jboss.netty.util.Timer;, +import org.jboss.netty.util.TimerTask;, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/handler/timeout/IdleStateHandler.java, +import org.jboss.netty.util.Timeout;, +import org.jboss.netty.util.Timer;, +import org.jboss.netty.util.TimerTask;, +++ b/src/main/java/org/jboss/netty/handler/timeout/ReadTimeoutHandler.java, +import org.jboss.netty.util.Timeout;, +import org.jboss.netty.util.Timer;, +import org.jboss.netty.util.TimerTask;, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/tarball/assembly.xml, + <includeBaseDirectory>true</includeBaseDirectory>]
[+++ b/handler/src/test/java/io/netty/handler/ssl/CipherSuiteCanaryTest.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version, + * 2.0 (the "License"); you may not use this file except in compliance with the, + * License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +import io.netty.buffer.ChannelBuffers;, + private final SpdyZlibDecoder headerBlockDecompressor = new SpdyZlibDecoder();, + int readerIndex = buffer.readerIndex();, + buffer.skipBytes(dataLength);, + return decodeControlFrame(type, flags, buffer.slice(readerIndex, dataLength));, + decodeHeaderBlock(spdySynStreamFrame, data);, + decodeHeaderBlock(spdySynReplyFrame, data);, + decodeHeaderBlock(spdyHeadersFrame, data);, + private boolean ensureBytes(ChannelBuffer decompressed, int bytes) throws Exception {, + if (decompressed.readableBytes() >= bytes) {, + return true;, + decompressed.discardReadBytes();, + headerBlockDecompressor.decode(decompressed);, + return decompressed.readableBytes() >= bytes;, + if ((headerBlock.readableBytes() == 2) &&, + (headerBlock.getShort(headerBlock.readerIndex()) == 0)) {, + return;, + }, +, + headerBlockDecompressor.setInput(headerBlock);, + ChannelBuffer decompressed = ChannelBuffers.dynamicBuffer(8192);, + headerBlockDecompressor.decode(decompressed);, +, + if (decompressed.readableBytes() < 2) {, + int numEntries = decompressed.readUnsignedShort();,
[+++ b/common/pom.xml, + <!-- Add dependency on dev-tools as otherwise the build will fail if not installed first manually -->, + <!-- See https://github.com/netty/netty/issues/7842 -->, + <dependency>, + <groupId>io.netty</groupId>, + <artifactId>netty-dev-tools</artifactId>, + <version>${project.version}</version>, + <scope>test</scope>, + <optional>true</optional>, + </dependency>]
[+++ b/pom.xml, + <version>2.4.1</version>, + <version>1.6.4</version>, + <version>3.1</version>, + <version>3.1</version>, + <version>1.6.4</version>, + <version>1.0.1</version>, + <version>2.5</version>, + <version>2.10</version>, + <version>1.7</version>, + <version>2.8</version>, + <version>2.3</version>, + <version>2.2.1</version>, + <version>2.2.1</version>, +++ b/pom.xml, + <version>2.4.1</version>, + <version>1.6.4</version>, + <version>3.1</version>, + <version>3.1</version>, + <version>1.6.4</version>, + <version>1.0.1</version>, + <version>2.5</version>, + <version>2.10</version>, + <version>1.7</version>, + <version>2.8</version>, + <version>2.3</version>, + <version>2.2.1</version>, + <version>2.2.1</version>, +++ b/src/main/java/org/jboss/netty/example/localtime/LocalTimeProtocol.java, +// source: src/main/java/org/jboss/netty/example/localtime/LocalTimeProtocol.proto, + public static final int AFRICA_VALUE = 0;, + public static final int AMERICA_VALUE = 1;, + public static final int ANTARCTICA_VALUE = 2;, + public static final int ARCTIC_VALUE = 3;, + public static final int ASIA_VALUE
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java, +import java.security.PrivateKey;, +import java.security.cert.X509Certificate;, + *, + * @deprecated use {@link SslContextBuilder}, + @Deprecated, + * @deprecated use {@link SslContextBuilder}, + @Deprecated, + * @deprecated use {@link SslContextBuilder}, + @Deprecated, + * @deprecated use {@link SslContextBuilder}, + @Deprecated, + * @deprecated use {@link SslContextBuilder}, + * @deprecated use {@link SslContextBuilder}, + @Deprecated, + * @deprecated use {@link SslContextBuilder}, + @Deprecated, + * @deprecated use {@link SslContextBuilder}, + @Deprecated, + * @deprecated use {@link SslContextBuilder}, + @Deprecated, + ctx = newSSLContext(toX509Certificates(trustCertChainFile), trustManagerFactory,, + toX509Certificates(keyCertChainFile), toPrivateKey(keyFile, keyPassword),, + keyPassword, keyManagerFactory, sessionCacheSize, sessionTimeout);, + } catch (Exception e) {, +
[+++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, +import io.netty.util.internal.PlatformDependent;, + try {, + } catch (Throwable cause) {, + STATE_UPDATER.set(this, ST_TERMINATED);, + terminationFuture.tryFailure(cause);, +, + if (!(cause instanceof Exception)) {, + // Also rethrow as it may be an OOME for example, + PlatformDependent.throwException(cause);, + }, + return terminationFuture;, + }, + try {, + } catch (Throwable cause) {, + STATE_UPDATER.set(this, ST_TERMINATED);, + terminationFuture.tryFailure(cause);, +, + if (!(cause instanceof Exception)) {, + // Also rethrow as it may be an OOME for example, + PlatformDependent.throwException(cause);, + }, + return;, + }, + try {, + } catch (Throwable cause) {, + STATE_UPDATER.set(this, ST_NOT_STARTED);,
[+++ b/src/assembly/default.xml, + <directory>target/docbook</directory>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java, + private static final String ANY_ORIGIN = "*";, + setOrigin(response, ANY_ORIGIN);, + if (config.isCredentialsAllowed(), + && !response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN).equals(ANY_ORIGIN)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java, + private static final String ANY_ORIGIN = "*";, + setOrigin(response, ANY_ORIGIN);, + if (config.isCredentialsAllowed(), + && !response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN).equals(ANY_ORIGIN)) {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsHandlerTest.java, + final CorsConfig config = CorsConfig.withOrigin(origin), + .allowNullOrigin(), + .allowCredentials(), + .build();, + assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_CREDENTIALS), is(nullValue()));]
[+++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, + /// TODO: In the future when we move to Java9+ we should use java.lang.ref.Cleaner., + @Override, + protected void finalize() throws Throwable {, + try {, + super.finalize();, + } finally {, + free();, + }, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, + /// TODO: In the future when we move to Java9+ we should use java.lang.ref.Cleaner., + @Override, + protected void finalize() throws Throwable {, + try {, + super.finalize();, + } finally {, + free();, + }, + }, +, +++ b/common/src/main/java/io/netty/util/Recycler.java, + // This act as a place holder for the head Link but
[+++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadClient.java, + channel.write(bodyRequestEncoder);, + channel.flush();, + channel.write(bodyRequestEncoder);, + channel.flush();, +++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadClient.java, + channel.write(bodyRequestEncoder);, + channel.flush();, + channel.write(bodyRequestEncoder);, + channel.flush();, +++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java, + // Not now: LastHttpContent will be sent writeResponse(ctx.channel());, + } else {, + writeResponse(ctx.channel());]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +class EpollEventLoop extends SingleThreadEventLoop {, + @SuppressWarnings("unused") // AtomicIntegerFieldUpdater, + delayNanos = (int) min(totalDelay - delaySeconds * 1000000000L, MAX_SCHEDULED_TIMERFD_NS);, + /**, + * Visible only for testing!, + */, + void handleLoopException(Throwable t) {, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +class EpollEventLoop extends SingleThreadEventLoop {, + @SuppressWarnings("unused") // AtomicIntegerFieldUpdater, + delayNanos = (int) min(totalDelay - delaySeconds * 1000000000L, MAX_SCHEDULED_TIMERFD_NS);, + /**, + * Visible only for testing!, + */, + void handleLoopException(Throwable t) {, +++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollEventLoopTest.java, +import io.netty.channel.DefaultSelectStrategyFactory;, +import io.netty.util.concurrent.DefaultThreadFactory;, +import io.netty.util.concurrent.RejectedExecutionHandlers;, +import io.netty.util.concurrent.ThreadPerTaskExecutor;, +import java.util.concurrent.atomic.AtomicReference;, +import static org.junit.Assert.assertNull;, + final AtomicReference<Throwable> capture = new AtomicReference<Throwable>();, + final EventLoopGroup group =
[+++ b/src/main/java/org/jboss/netty/channel/group/ChannelGroup.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2008, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version., + *, +
[+++ b/codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayDecoder.java, + * void messageReceived({@link ChannelHandlerContext} ctx, byte[] bytes) {, +++ b/codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayDecoder.java, + * void messageReceived({@link ChannelHandlerContext} ctx, byte[] bytes) {, +++ b/codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayEncoder.java, + * void messageReceived({@link ChannelHandlerContext} ctx, byte[] bytes) {, +++ b/codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayDecoder.java, + * void messageReceived({@link ChannelHandlerContext} ctx, byte[] bytes) {, +++ b/codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayEncoder.java, + * void messageReceived({@link ChannelHandlerContext} ctx, byte[] bytes) {, +++ b/codec/src/main/java/io/netty/handler/codec/compression/ZlibEncoder.java, + /**, + * Close this {@link ZlibEncoder} and so finish the encoding., + *, + * The returned {@link ChannelFuture} will be notified once the, + * operation completes., + */, + /**, + * Close this {@link ZlibEncoder} and so
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketAutoReadTest.java, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.ByteBufAllocator;, +import io.netty.channel.ChannelConfig;, +import io.netty.channel.ChannelInitializer;, +import io.netty.channel.ChannelOption;, +import io.netty.channel.RecvByteBufAllocator;, +import java.util.concurrent.atomic.AtomicInteger;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertTrue;, +import static org.junit.Assert.fail;, + @Test, + public void testAutoReadOffDuringReadOnlyReadsOneTime() throws Throwable {, + public void testAutoReadOffDuringReadOnlyReadsOneTime(ServerBootstrap sb, Bootstrap cb) throws Throwable {, + testAutoReadOffDuringReadOnlyReadsOneTime(true, sb, cb);, + testAutoReadOffDuringReadOnlyReadsOneTime(false, sb, cb);, + }, +, + private void testAutoReadOffDuringReadOnlyReadsOneTime(boolean readOutsideEventLoopThread,, + ServerBootstrap sb, Bootstrap cb) throws Throwable {, + Channel serverChannel = null;, + Channel clientChannel = null;, + try {, + AutoReadInitializer serverInitializer = new AutoReadInitializer(!readOutsideEventLoopThread);, + AutoReadInitializer clientInitializer = new AutoReadInitializer(!readOutsideEventLoopThread);, + sb.option(ChannelOption.SO_BACKLOG, 1024),
[+++ b/pom.xml, + <version>2.1.0</version>]
[+++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, +import io.netty.util.internal.DetectionUtil;, +import io.netty.util.internal.DirectByteBufUtil;, +, + static void freeDirect(ByteBuffer buffer) {, + if (DetectionUtil.canFreeDirectBuffer()) {, + DirectByteBufUtil.freeDirect(buffer);, + }, + }, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, +import io.netty.util.internal.DetectionUtil;, +import io.netty.util.internal.DirectByteBufUtil;, +, + static void freeDirect(ByteBuffer buffer) {, + if (DetectionUtil.canFreeDirectBuffer()) {, + DirectByteBufUtil.freeDirect(buffer);, + }, + }, +++ b/common/src/main/java/io/netty/util/internal/DetectionUtil.java, + // Only try to use DirectByteBufUtil if it is not android as otherwise it will give errors because, + // it try to access sun.misc.Cleaner, + if (!isAndroid()) {, + canFreeDirectBuffer = DirectByteBufUtil.canFreeDirect();, + }, + * Return {@code true} if {@link sun.misc.Unsafe} was found on the classpath and can
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Codec.java, + * Construct a new handler whose child channels run in the same event loop as this handler., + *, + * @param server {@code true} this is a server, + * @param streamHandler the handler added to channels for remotely-created streams. It must be, + * {@link ChannelHandler.Sharable}. {@code null} if the event loop from the parent channel should be used., + * @param initialSettings non default initial settings to send to peer, + */, + public Http2Codec(boolean server, ChannelHandler streamHandler, Http2Settings initialSettings) {, + this(server, new Http2StreamChannelBootstrap().handler(streamHandler), HTTP2_FRAME_LOGGER,, + initialSettings);, + }, +, + /**,
[+++ b/codec/src/main/java/io/netty/handler/codec/marshalling/CompatibleMarshallingDecoder.java, +import java.io.ObjectStreamConstants;, +, + private boolean discardingTooLongFrame;, + if (discardingTooLongFrame) {, + buffer.skipBytes(actualReadableBytes());, + checkpoint();, + return null;, + }, +, + }768, + discardingTooLongFrame = true;]
[+++ b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/factorial/FactorialClient.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, +import io.netty.channel.nio.NioEventLoopGroup;, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import
[+++ b/common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java, + private static volatile long initialSeedUniquifier =, + private static final Thread seedGeneratorThread;, + private static final BlockingQueue<byte[]> seedQueue;, + private static final long seedGeneratorStartTime;, + private static volatile long seedGeneratorEndTime;, +, + static {, + seedGeneratorThread = new Thread("initialSeedUniquifierGenerator") {, + final SecureRandom random = new SecureRandom(); // Get the real random seed from /dev/random, + final byte[] seed = random.generateSeed(8);, + seedGeneratorEndTime = System.nanoTime();, + seedQueue.add(seed);, + seedGeneratorThread.setDaemon(true);, + seedGeneratorThread.setUncaughtExceptionHandler(new UncaughtExceptionHandler() {, + seedQueue = new LinkedBlockingQueue<byte[]>();, + seedGeneratorStartTime = System.nanoTime();, + seedGeneratorThread.start();, + } else {, + seedGeneratorThread = null;, + seedQueue = null;,
[+++ b/src/docbook/module/start.xml, +public class TimeEncoder extends &SimpleChannelHandler; {]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +, + if (close) {, + unsafe.epollRdHupReady();, + }, +, + // We need to check if the channel is still open before try to trigger the, + // callbacks as otherwise we may trigger an IllegalStateException when try, + // to access the file descriptor., + //, + // See https://github.com/netty/netty/issues/3443, + if (write && ch.isOpen()) {, + if (read && ch.isOpen()) {]
[+++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java, + // AF_UNIX defines that exactly 108 bytes are reserved for the address. The previous methods, + // did not increase the reader index although we already consumed the information., + header.readerIndex(startIdx + 108);]
[+++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffers.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffers.java, +++ b/buffer/src/test/java/io/netty/buffer/ChannelBuffersTest.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffers.java, +++ b/buffer/src/test/java/io/netty/buffer/ChannelBuffersTest.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import java.security.MessageDigest;, +import java.security.NoSuchAlgorithmException;, +import io.netty.buffer.ChannelBuffer;, +import io.netty.buffer.ChannelBuffers;, +import io.netty.handler.codec.base64.Base64;, +import io.netty.util.CharsetUtil;, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffers.java, +++ b/buffer/src/test/java/io/netty/buffer/ChannelBuffersTest.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import java.security.MessageDigest;, +import java.security.NoSuchAlgorithmException;, +import io.netty.buffer.ChannelBuffer;, +import io.netty.buffer.ChannelBuffers;, +import io.netty.handler.codec.base64.Base64;, +import io.netty.util.CharsetUtil;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +import java.security.MessageDigest;, +import java.security.NoSuchAlgorithmException;, +import io.netty.buffer.ChannelBuffer;, +import io.netty.buffer.ChannelBuffers;, +import io.netty.handler.codec.base64.Base64;, +import io.netty.util.CharsetUtil;, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffers.java, +++ b/buffer/src/test/java/io/netty/buffer/ChannelBuffersTest.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import java.security.MessageDigest;, +import java.security.NoSuchAlgorithmException;, +import io.netty.buffer.ChannelBuffer;, +import io.netty.buffer.ChannelBuffers;, +import io.netty.handler.codec.base64.Base64;, +import io.netty.util.CharsetUtil;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +import java.security.MessageDigest;, +import java.security.NoSuchAlgorithmException;, +import io.netty.buffer.ChannelBuffer;, +import io.netty.buffer.ChannelBuffers;, +import io.netty.handler.codec.base64.Base64;, +import io.netty.util.CharsetUtil;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, +/*, + * Copyright 2012 Twitter, Inc., + *,
[+++ b/buffer/src/test/java/io/netty/buffer/BigEndianUnsafeDirectByteBufTest.java, + @Override, + public void init() {, + super.init();, +++ b/buffer/src/test/java/io/netty/buffer/BigEndianUnsafeDirectByteBufTest.java, + @Override, + public void init() {, + super.init();, +++ b/buffer/src/test/java/io/netty/buffer/BigEndianUnsafeNoCleanerDirectByteBufTest.java, + @Override, + public void init() {, + super.init();, +++ b/buffer/src/test/java/io/netty/buffer/BigEndianUnsafeDirectByteBufTest.java, + @Override, + public void init() {, + super.init();, +++ b/buffer/src/test/java/io/netty/buffer/BigEndianUnsafeNoCleanerDirectByteBufTest.java, + @Override, + public void init() {, + super.init();, +++ b/buffer/src/test/java/io/netty/buffer/LittleEndianUnsafeDirectByteBufTest.java, + @Override, + public void init() {, + super.init();, +++ b/buffer/src/test/java/io/netty/buffer/BigEndianUnsafeDirectByteBufTest.java, + @Override, + public void init() {, + super.init();, +++ b/buffer/src/test/java/io/netty/buffer/BigEndianUnsafeNoCleanerDirectByteBufTest.java, + @Override, + public void init() {, + super.init();, +++ b/buffer/src/test/java/io/netty/buffer/LittleEndianUnsafeDirectByteBufTest.java, + @Override, + public void init() {, + super.init();,
[+++ b/.travis.yml, +install: 'mvn clean install -Pfull -DskipTests']
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCounted.java, + /**, + * An unsafe operation intended for use by a subclass that sets the reference count of the buffer directly, + */, + protected final void setRefCnt(int refCnt) {, + this.refCnt = refCnt;, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCounted.java, + /**, + * An unsafe operation intended for use by a subclass that sets the reference count of the buffer directly, + */, + protected final void setRefCnt(int refCnt) {, + this.refCnt = refCnt;, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + /**, + * An unsafe operation intended for use by a subclass that sets the reference
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, + this(toX509CertificatesInternal(trustCertChainFile), trustManagerFactory,, + toX509CertificatesInternal(keyCertChainFile), toPrivateKeyInternal(keyFile, keyPassword),, + keyPassword, keyManagerFactory, ciphers, cipherFilter, apn, sessionCacheSize, sessionTimeout);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, + this(toX509CertificatesInternal(trustCertChainFile), trustManagerFactory,, + toX509CertificatesInternal(keyCertChainFile), toPrivateKeyInternal(keyFile, keyPassword),, + keyPassword, keyManagerFactory, ciphers, cipherFilter, apn, sessionCacheSize, sessionTimeout);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +import java.io.File;, +import java.security.cert.CertificateException;, +, + static PrivateKey toPrivateKeyInternal(File keyFile, String keyPassword) throws SSLException {, + try {, + return SslContext.toPrivateKey(keyFile, keyPassword);, + } catch (Exception e) {, + throw new SSLException(e);, + }, + }, +, + static X509Certificate[] toX509CertificatesInternal(File file) throws SSLException {, + try {, + return SslContext.toX509Certificates(file);, + } catch (CertificateException e) {, + throw new SSLException(e);, + },
[+++ b/pom.xml, + <groupId>org.apache.felix</groupId>, + <artifactId>org.osgi.compendium</artifactId>, + <version>1.2.0</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, +++ b/pom.xml, + <groupId>org.apache.felix</groupId>, + <artifactId>org.osgi.compendium</artifactId>, + <version>1.2.0</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, +++ b/src/main/java/org/jboss/netty/container/osgi/NettyBundleActivator.java, +import org.jboss.netty.logging.InternalLogger;, +import org.jboss.netty.logging.InternalLoggerFactory;, +import org.jboss.netty.logging.OsgiLoggerFactory;, +import org.osgi.framework.ServiceReference;, +import org.osgi.service.log.LogService;, + initLoggerFactory(ctx);, + private void initLoggerFactory(BundleContext ctx) {, + ServiceReference logServiceRef = ctx.getServiceReference(LogService.class.getName());, + if (logServiceRef == null) {, + // LogService is not available., + return;, + }, +, + LogService logService;, + try {, + logService = (LogService) ctx.getService(logServiceRef);, + } catch (Exception e) {, + // Same name, different service, + return;,
[+++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, +import io.netty.handler.ssl.ApplicationProtocolConfig.Protocol;, +import io.netty.handler.ssl.ApplicationProtocolConfig.SelectedListenerFailureBehavior;, +import io.netty.handler.ssl.ApplicationProtocolConfig.SelectorFailureBehavior;, +import java.nio.ByteBuffer;, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, +import io.netty.handler.ssl.ApplicationProtocolConfig.Protocol;, +import io.netty.handler.ssl.ApplicationProtocolConfig.SelectedListenerFailureBehavior;, +import io.netty.handler.ssl.ApplicationProtocolConfig.SelectorFailureBehavior;, +import java.nio.ByteBuffer;, +++ b/handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java, +import io.netty.channel.socket.SocketChannel;, +import io.netty.util.ReferenceCountUtil;, +import java.util.concurrent.ExecutionException;, +import javax.net.ssl.SSLEngine;, +import javax.net.ssl.SSLEngineResult;, +import javax.net.ssl.SSLException;, +import javax.net.ssl.SSLHandshakeException;, +import javax.net.ssl.SSLSession;, +, +import static org.junit.Assert.assertArrayEquals;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertNotEquals;, +import static org.junit.Assert.assertNotNull;, +import static org.junit.Assert.assertTrue;, + if (clientChannel != null) {, + clientChannel.close();, + clientChannel = null;, + }, + if (serverConnectedChannel != null) {, + serverConnectedChannel.close();, + serverConnectedChannel = null;, + }, + }, + Future<?> serverGroupShutdownFuture = null;, + Future<?> serverChildGroupShutdownFuture = null;, + Future<?>
[+++ b/testsuite/pom.xml, + <dependency>, + <groupId>io.netty</groupId>, + <artifactId>netty-transport-udt</artifactId>, + <version>${project.version}</version>, + </dependency>, +++ b/testsuite/pom.xml, + <dependency>, + <groupId>io.netty</groupId>, + <artifactId>netty-transport-udt</artifactId>, + <version>${project.version}</version>, + </dependency>, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import javax.net.ssl.SSLEngine;, +, +import org.junit.Test;]
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, +++ b/common/src/test/java/io/netty/util/internal/PlatformDependent0Test.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java, + if (future.isDone()) {, + when(connection.numActiveStreams()).thenReturn(0);, + }]
[+++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java, + decoder.freeInboundBuffer(ctx);, + encoder.freeOutboundBuffer(ctx);, + }, +, + @Override, + public void inboundBufferUpdated(, + ChannelHandlerContext ctx) throws Exception {, + decoder.inboundBufferUpdated(ctx);]
[+++ b/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayDecoderTest.java, +import io.netty.handler.codec.DecoderException;, + } catch (DecoderException e) {, +++ b/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayDecoderTest.java, +import io.netty.handler.codec.DecoderException;, + } catch (DecoderException e) {, +++ b/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayEncoderTest.java, +import io.netty.handler.codec.EncoderException;, + } catch (EncoderException e) {, +++ b/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayDecoderTest.java, +import io.netty.handler.codec.DecoderException;, + } catch (DecoderException e) {, +++ b/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayEncoderTest.java, +import io.netty.handler.codec.EncoderException;, + } catch (EncoderException e) {, +++ b/codec/src/test/java/io/netty/handler/codec/frame/DelimiterBasedFrameDecoderTest.java, +import io.netty.handler.codec.DecoderException;, + Assert.fail(DecoderException.class.getSimpleName() + " must be raised.");, + } catch (TooLongFrameException e) {, + Assert.fail(DecoderException.class.getSimpleName() + " must be raised.");, + } catch (TooLongFrameException e) {, +++ b/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayDecoderTest.java, +import io.netty.handler.codec.DecoderException;, + } catch (DecoderException e) {, +++ b/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayEncoderTest.java, +import io.netty.handler.codec.EncoderException;, + } catch (EncoderException e)
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameCodecTest.java, +import io.netty.handler.codec.http.HttpServerUpgradeHandler.UpgradeEvent;, +import io.netty.util.internal.ReflectionUtil;, +import org.junit.Assume;, +import java.lang.reflect.Constructor;, + public void upgradeEventNoRefCntError() throws Exception {, + // Using reflect as the constructor is package-private and the class is final., + Constructor<UpgradeEvent> constructor =, + UpgradeEvent.class.getDeclaredConstructor(CharSequence.class, FullHttpRequest.class);, + // Check if we could make it accessible which may fail on java9., + Assume.assumeTrue(ReflectionUtil.trySetAccessible(constructor) == null);, +, + HttpServerUpgradeHandler.UpgradeEvent upgradeEvent = constructor.newInstance(, + "HTTP/2", new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/"));, + assertEquals(1, upgradeEvent.refCnt());, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameCodecTest.java, +import io.netty.handler.codec.http.HttpServerUpgradeHandler.UpgradeEvent;, +import io.netty.util.internal.ReflectionUtil;, +import org.junit.Assume;, +import java.lang.reflect.Constructor;, + public void upgradeEventNoRefCntError() throws Exception {, + // Using reflect as the constructor is package-private and the
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + static boolean isError(long errorCode) {, + return errorCode != SSL.SSL_ERROR_NONE;, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + static boolean isError(long errorCode) {, + return errorCode != SSL.SSL_ERROR_NONE;, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, + long error = SSL.getLastErrorNumber();, + + certChainFile + " (" + SSL.getErrorString(error) + ')');, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + static boolean isError(long errorCode) {, + return errorCode != SSL.SSL_ERROR_NONE;, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, + long error = SSL.getLastErrorNumber();, + + certChainFile + " (" + SSL.getErrorString(error) + ')');, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + long error = SSL.getLastErrorNumber();, + String err = SSL.getErrorString(error);, + "; OpenSSL error: '" + err + '\'');, + throw new SSLException(err);, +
[+++ b/testsuite/pom.xml, +, + <build>, + <plugins>, + <plugin>, + <artifactId>maven-deploy-plugin</artifactId>, + <version>2.7</version>, + <configuration>, + <skip>true</skip>, + </configuration>, + </plugin>, + </plugins>, + </build>]
[+++ b/src/docbook/module/architecture.xml, + Netty has a universal asynchronous I/O interface called &Channel;, which, + abstracts away all operations required to point-to-point communication., + That is, once you wrote your application on one Netty transport, your, + application can run on other Netty transports. Netty provides a number, + of essential transports via one universal API:]
[+++ b/common/src/main/java/io/netty/util/internal/logging/InternalLoggerFactory.java, + * Netty should use. The default factory is {@link Slf4JLoggerFactory}. If SLF4J, + * is not available, {@link Log4JLoggerFactory} is used. If Log4J is not available,, + * {@link JdkLoggerFactory} is used. You can change it to your preferred, + * logging framework before other Netty classes are loaded:]
[+++ b/example/src/main/java/io/netty/example/spdy/client/SpdyClient.java, +import java.util.Arrays;, + Arrays.asList(SelectedProtocol.SPDY_3_1.protocolName(), SelectedProtocol.HTTP_1_1.protocolName()),, +++ b/example/src/main/java/io/netty/example/spdy/client/SpdyClient.java, +import java.util.Arrays;, + Arrays.asList(SelectedProtocol.SPDY_3_1.protocolName(), SelectedProtocol.HTTP_1_1.protocolName()),, +++ /dev/null, +++ b/example/src/main/java/io/netty/example/spdy/client/SpdyClient.java, +import java.util.Arrays;, + Arrays.asList(SelectedProtocol.SPDY_3_1.protocolName(), SelectedProtocol.HTTP_1_1.protocolName()),, +++ /dev/null, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java, +import java.util.ArrayList;, + private final List<String> nextProtocols;, + * @param nextProtocols the application layer protocols to accept, in the order of preference., + Iterable<String> ciphers, Iterable<String> nextProtocols,, + if (nextProtocols != null && nextProtocols.iterator().hasNext() && !JettyNpnSslEngine.isAvailable()) {, + throw new SSLException("NPN/ALPN unsupported: " + nextProtocols);, + List<String> nextProtoList = new ArrayList<String>();, + for (String p: nextProtocols) {, + if (p == null) {, + break;, + }, + nextProtoList.add(p);, + }, +
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java]
[+++ b/src/docbook/module/architecture.xml, + stack.]
[+++ /dev/null, +++ /dev/null, +++ b/all/pom.xml, + <id>clean-first</id>, + <includeGroupIds>${project.groupId}</includeGroupIds>, + <outputDirectory>${project.build.directory}/src</outputDirectory>, + <groupId>org.codehaus.mojo</groupId>, + <artifactId>build-helper-maven-plugin</artifactId>, + <version>1.7</version>, + <id>add-source</id>, + <phase>generate-sources</phase>, + <goal>add-source</goal>, + <sources>, + <source>target/src</source>, + </sources>, +, + <profiles>, + <profile>, + <id>full</id>, + <build>, + <plugins>, + <plugin>, + <artifactId>maven-jxr-plugin</artifactId>, + <version>2.2</version>, + <executions>, + <execution>, + <id>generate-xref</id>, + <phase>package</phase>, + <goals>, + <goal>jxr</goal>, + </goals>, + </execution>, + </executions>, + <configuration>, + <inputEncoding>UTF-8</inputEncoding>, + <outputEncoding>UTF-8</outputEncoding>, + <linkJavadoc>true</linkJavadoc>, + <destDir>${project.build.directory}/xref</destDir>, + <javadocDir>${project.build.directory}/api</javadocDir>, + <docTitle>Netty Source Xref (${project.version})</docTitle>, + <windowTitle>Netty Source Xref (${project.version})</windowTitle>, + </configuration>, + </plugin>, + <plugin>, + <artifactId>maven-javadoc-plugin</artifactId>, + <version>2.8.1</version>, + <executions>,
[+++ b/transport/src/main/java/io/netty/channel/pool/SimpleChannelPool.java, +import static io.netty.util.internal.ObjectUtil.*;, + return acquireHealthyFromPoolOrNew(promise);, + }, +, + /**, + * Tries to retrieve healthy channel from the pool if any or creates a new channel otherwise., + * @param promise the promise to provide acquire result., + * @return future for acquiring a channel., + */, + private Future<Channel> acquireHealthyFromPoolOrNew(final Promise<Channel> promise) {, + acquireHealthyFromPoolOrNew(promise);, + acquireHealthyFromPoolOrNew(promise);, +++ b/transport/src/main/java/io/netty/channel/pool/SimpleChannelPool.java, +import static io.netty.util.internal.ObjectUtil.*;, + return acquireHealthyFromPoolOrNew(promise);, + }, +, + /**, + * Tries to retrieve healthy channel from the pool if any or creates a new channel otherwise., + * @param promise the promise
[+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java, +import io.netty.util.IpAddresses;, + if (!IpAddresses.isValidIpV4Address(host)) {, + if (!IpAddresses.isValidIp6Address(host)) {, + byteBuf.writeBytes(IpAddresses.createByteArrayFromIpAddressString(host));, + byteBuf.writeBytes(IpAddresses.createByteArrayFromIpAddressString(host));, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java, +import io.netty.util.IpAddresses;, + if (!IpAddresses.isValidIpV4Address(host)) {, + if (!IpAddresses.isValidIp6Address(host)) {, + byteBuf.writeBytes(IpAddresses.createByteArrayFromIpAddressString(host));, + byteBuf.writeBytes(IpAddresses.createByteArrayFromIpAddressString(host));, +++ /dev/null, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java, +import io.netty.util.IpAddresses;, + if (!IpAddresses.isValidIpV4Address(host)) {, + if (!IpAddresses.isValidIp6Address(host)) {, + byteBuf.writeBytes(IpAddresses.createByteArrayFromIpAddressString(host));, + byteBuf.writeBytes(IpAddresses.createByteArrayFromIpAddressString(host));, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/IpAddresses.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You
[+++ b/codec-socks/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<!--, + ~ Copyright 2012 The Netty Project, + ~, + ~ The Netty Project licenses this file to you under the Apache License,, + ~ version 2.0 (the "License"); you may not use this file except in compliance, + ~ with the License. You may obtain a copy of the License at:, + ~, + ~ http://www.apache.org/licenses/LICENSE-2.0, + ~, + ~ Unless required by applicable law or agreed to in writing, software, + ~ distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + ~ WARRANTIES OR CONDITIONS OF ANY
[+++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java, + public ByteBuf retain() {, + leak.record();, + return super.retain();, + }, +, + @Override, + public ByteBuf retain(int increment) {, + leak.record();, + return super.retain(increment);, + }, +, + @Override, + } else{, + leak.record();, + } else {, + leak.record();]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/CookieUtil.java, + sb.append('=');, + sb.append(';');, + sb.append(HttpConstants.SP_CHAR);, + sb.append('=');, + sb.append(';');, + sb.append(HttpConstants.SP_CHAR);, + sb.append(';');, + sb.append(HttpConstants.SP_CHAR);, + sb.append('=');, + sb.append('"');, + sb.append('"');, + sb.append(';');, + sb.append(HttpConstants.SP_CHAR);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/CookieUtil.java, + sb.append('=');, + sb.append(';');, + sb.append(HttpConstants.SP_CHAR);, + sb.append('=');, + sb.append(';');, + sb.append(HttpConstants.SP_CHAR);, + sb.append(';');, + sb.append(HttpConstants.SP_CHAR);, + sb.append('=');, + sb.append('"');, + sb.append('"');, + sb.append(';');, + sb.append(HttpConstants.SP_CHAR);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/ServerCookieEncoder.java, + buf.append('=');, + buf.append(';');, + buf.append(HttpConstants.SP_CHAR);]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + private static final int FLAG_FREED_INBOUND = 4;, + private static final int FLAG_FREED_OUTBOUND = 8;, + flags |= FLAG_FREED;, + flags |= FLAG_FREED_INBOUND;, +, + flags |= FLAG_FREED_OUTBOUND;, +, + if ((flags & FLAG_FREED_INBOUND) != 0) {, + return;, + }, +, + if (handler instanceof ChannelInboundByteHandler && (flags & FLAG_FREED_INBOUND) == 0) {, + if ((flags & FLAG_FREED_OUTBOUND) != 0) {, + promise.setFailure(new ChannelPipelineException(, + "Unable to flush as outbound buffer of next handler was freed already"));, + return;, + }, +, + if (!channel.isActive() && !channel.isRegistered()) {, + if (handler instanceof ChannelOutboundByteHandler && (flags
[+++ b/.travis.yml, +before_install: 'mvn -version', +++ b/.travis.yml, +before_install: 'mvn -version', +++ b/buffer/src/main/java/io/netty/buffer/stream/package-info.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT,
[+++ b/common/src/main/java/io/netty/util/IntSupplier.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/pom.xml, + , + <!-- Google Protocol Buffers - completely optional -->, + <dependency>, + <groupId>com.google.protobuf</groupId>, + <artifactId>protobuf-java</artifactId>, + <version>2.0.3</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + , +++ b/pom.xml, + , + <!-- Google Protocol Buffers - completely optional -->, + <dependency>, + <groupId>com.google.protobuf</groupId>, + <artifactId>protobuf-java</artifactId>, + <version>2.0.3</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + , +++ b/src/main/java/org/jboss/netty/handler/codec/protobuf/ProtobufDecoder.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2008, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full
[+++ b/pom.xml, + <version>3.2.0.ALPHA1-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +++ b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +import io.netty.handler.codec.compression.ZlibDecoder;, +import io.netty.handler.codec.embedder.DecoderEmbedder;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +import io.netty.handler.codec.compression.ZlibDecoder;, +import io.netty.handler.codec.embedder.DecoderEmbedder;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyJZlibDecoder.java, +/*, + * Copyright 2012 Twitter, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may, + * not use this file except in compliance with the License. You may obtain, + * a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkAlpnApplicationProtocolNegotiator.java, + private static final class FailureWrapper extends AllocatorAwareSslEngineWrapperFactory {, + private static final class AlpnWrapper extends AllocatorAwareSslEngineWrapperFactory {, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkAlpnApplicationProtocolNegotiator.java, + private static final class FailureWrapper extends AllocatorAwareSslEngineWrapperFactory {, + private static final class AlpnWrapper extends AllocatorAwareSslEngineWrapperFactory {, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkApplicationProtocolNegotiator.java, + * @param applicationNegotiator The application level protocol negotiator, + * @param isServer <ul>, + * <li>{@code true} if the engine is for server side of connections</li>, + * <li>{@code false} if the engine is for client side of connections</li>, + * </ul>, + * @return The resulting wrapped engine. This may just be {@code engine}., +
[+++ b/pom.xml, + <!-- Test suite dependency for generating a compressed heap dump file -->, +++ b/pom.xml, + <!-- Test suite dependency for generating a compressed heap dump file -->, +++ b/testsuite/pom.xml, +++ b/pom.xml, + <!-- Test suite dependency for generating a compressed heap dump file -->, +++ b/testsuite/pom.xml, +++ b/transport-native-epoll/pom.xml]
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractDiskHttpData.java, + localfileChannel.force(false);, + fileChannel.force(false);, + localfileChannel.force(false);, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractDiskHttpData.java, + localfileChannel.force(false);, + fileChannel.force(false);, + localfileChannel.force(false);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractMemoryHttpData.java, + }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractDiskHttpData.java, + localfileChannel.force(false);, + fileChannel.force(false);, + localfileChannel.force(false);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractMemoryHttpData.java, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractDiskHttpData.java, + localfileChannel.force(false);, + fileChannel.force(false);, + localfileChannel.force(false);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractMemoryHttpData.java, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, + write(ctx, succeededFuture(ctx.channel()), CONTINUE.duplicate());, + m.setContent(ChannelBuffers.dynamicBuffer(e.channel().getConfig().getBufferFactory()));, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractDiskHttpData.java, + localfileChannel.force(false);, + fileChannel.force(false);, + localfileChannel.force(false);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractMemoryHttpData.java, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, +
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + checkReadableBytes(length);, +, + if (minimumReadableBytes < 0) {, + throw new IllegalArgumentException("minimumReadableBytes: " + minimumReadableBytes + " (expected: >= 0)");, + }, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + checkReadableBytes(length);, +, + if (minimumReadableBytes < 0) {, + throw new IllegalArgumentException("minimumReadableBytes: " + minimumReadableBytes + " (expected: >= 0)");, + }, +++ b/buffer/src/test/java/io/netty/buffer/UnpooledTest.java, +, + @Test(expected = IllegalArgumentException.class), + public void skipBytesNegativeLength() {, + ByteBuf buf = freeLater(buffer(8));, + buf.skipBytes(-1);, + }]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + libNames.add("netty_tcnative-" + os + '-' + arch);, + libNames.add("netty_tcnative-" + os + '-' + arch + "-fedora");, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + libNames.add("netty_tcnative-" + os + '-' + arch);, + libNames.add("netty_tcnative-" + os + '-' + arch + "-fedora");, +++ b/pom.xml, + <tcnative.version>2.0.6.Final</tcnative.version>]
[+++ b/handler/src/main/java/io/netty/handler/ssl/util/ThreadLocalInsecureRandom.java, + * Insecure {@link SecureRandom} which relies on {@link PlatformDependent#threadLocalRandom()} for random number, + * generation.]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + // Nothing to do as the handshake is not done yet., + break;, + case FINISHED:, + if (clientMode) {, + // Only supported for server mode at the moment., + }, + // For renegotiate on the server side we need to issue the following command sequence with openssl:, + //, + // SSL_renegotiate(ssl), + // SSL_do_handshake(ssl), + // ssl->state = SSL_ST_ACCEPT, + // SSL_do_handshake(ssl), + //, + // Bcause of this we fall-through to call handshake() after setting the state, as this will also take, + // care of updating the internal OpenSslSession object.,
[+++ b/codec-dns/pom.xml, + <artifactId>netty-common</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-buffer</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/codec-dns/pom.xml, + <artifactId>netty-common</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-buffer</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/codec-haproxy/pom.xml, + <artifactId>netty-buffer</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/codec-dns/pom.xml, + <artifactId>netty-common</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsMessage.java, +, + final ResourceLeak leak = this.leak;, + if (leak != null) {, + leak.close();, + }]
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketConnectTest.java, +import io.netty.channel.ChannelFutureListener;, +import java.util.concurrent.BlockingQueue;, +import java.util.concurrent.LinkedBlockingQueue;, + @Test(timeout = 3000), + public void testChannelEventsFiredWhenClosedDirectly() throws Throwable {, + run();, + }, +, + public void testChannelEventsFiredWhenClosedDirectly(ServerBootstrap sb, Bootstrap cb) throws Throwable {, + final BlockingQueue<Integer> events = new LinkedBlockingQueue<Integer>();, +, + Channel sc = null;, + Channel cc = null;, + try {, + sb.childHandler(new ChannelInboundHandlerAdapter());, + sc = sb.bind(0).syncUninterruptibly().channel();, +, + cb.handler(new ChannelInboundHandlerAdapter() {, + @Override, + public void channelActive(ChannelHandlerContext ctx) throws Exception {, + events.add(0);, + }, +, + @Override, + public void channelInactive(ChannelHandlerContext ctx) throws Exception {, + events.add(1);, + }, + });, +
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java, + public void operationComplete(Future<? super Channel> future) {, + // Remove the id from the manager as we fail the query., + parent.queryContextManager.remove(nameServerAddr(), id);, +]
[+++ b/codec/src/main/java/io/netty/handler/codec/embedder/AbstractCodecEmbedder.java, +++ b/codec/src/main/java/io/netty/handler/codec/embedder/AbstractCodecEmbedder.java, +++ b/handler/src/main/java/io/netty/handler/execution/OrderedDownstreamThreadPoolExecutor.java, +/*, + * Copyright 2011 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import io.netty.handler.ssl.util.SelfSignedCertificate;, + private static final boolean SUPPORTS_KEYMANAGER_FACTORY;, + boolean supportsKeyManagerFactory = false;, + long privateKeyBio = 0;, + long certBio = 0;, + try {, + SelfSignedCertificate cert = new SelfSignedCertificate();, + certBio = OpenSslContext.toBIO(cert.cert());, + SSL.setCertificateChainBio(ssl, certBio, false);, + supportsKeyManagerFactory = true;, + } catch (Throwable ignore) {, + logger.debug("KeyManagerFactory not supported.");, + }, + if (privateKeyBio != 0) {, + SSL.freeBIO(privateKeyBio);, + }, + if (certBio != 0) {, + SSL.freeBIO(certBio);, + }, + SUPPORTS_KEYMANAGER_FACTORY = supportsKeyManagerFactory;, + SUPPORTS_KEYMANAGER_FACTORY = false;, + /**, + * Returns {@code true} if {@link
[+++ b/codec/src/test/java/io/netty/handler/codec/xml/XmlFrameDecoderTest.java, + try {, + } finally {, + ch.finish();, + }]
[+++ b/NOTICE.txt]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, +import io.netty.channel.ChannelHandlerContext;, + public HttpMessage decode(ChannelHandlerContext ctx, Object msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, +import io.netty.channel.ChannelHandlerContext;, + public HttpMessage decode(ChannelHandlerContext ctx, Object msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import io.netty.channel.ChannelHandlerContext;, + ChannelHandlerContext ctx, Object msg, ChannelBuffer out) throws Exception {, + ChannelHandlerContext ctx, ChannelBuffer buffer) throws Exception {, + public void channelInactive(ChannelHandlerContext ctx), +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, +import io.netty.channel.ChannelHandlerContext;, + public HttpMessage decode(ChannelHandlerContext ctx, Object msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import io.netty.channel.ChannelHandlerContext;, + ChannelHandlerContext ctx, Object msg, ChannelBuffer out) throws Exception {, + ChannelHandlerContext ctx, ChannelBuffer buffer) throws Exception {, + public void channelInactive(ChannelHandlerContext ctx), +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, +import
[+++ b/src/main/java/org/jboss/netty/example/discard/DiscardClient.java, +/**, + * Keeps sending random data to the specified address., + *, + * @author The Netty Project (netty-dev@lists.jboss.org), + * @author Trustin Lee (tlee@redhat.com), + *, + * @version $Rev$, $Date$, + */, + DiscardClientHandler handler = new DiscardClientHandler(firstMessageSize);, +++ b/src/main/java/org/jboss/netty/example/discard/DiscardClient.java, +/**, + * Keeps sending random data to the specified address., + *, + * @author The Netty Project (netty-dev@lists.jboss.org), + * @author Trustin Lee (tlee@redhat.com), + *, + * @version $Rev$, $Date$, + */, + DiscardClientHandler handler = new DiscardClientHandler(firstMessageSize);, +++ b/src/main/java/org/jboss/netty/example/discard/DiscardClientHandler.java, +/*, + * JBoss, Home of Professional Open Source, + *,
[+++ b/transport/src/main/java/io/netty/channel/Channel.java, + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/Channel.java, + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/Channel.java, + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/ChannelInboundHandler.java, + *, + * @deprecated use {@link #channelInactive(ChannelHandlerContext)}, + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/Channel.java, + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/ChannelInboundHandler.java, + *, + * @deprecated use {@link #channelInactive(ChannelHandlerContext)}, + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/ChannelInboundInvoker.java, + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/Channel.java, + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/ChannelInboundHandler.java, + *, + * @deprecated use {@link #channelInactive(ChannelHandlerContext)}, + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/ChannelInboundInvoker.java, + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java, + *, + @Deprecated, + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/Channel.java, + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/ChannelInboundHandler.java, +
[+++ b/transport-native-epoll/pom.xml, + <!-- Needed as we use SelfSignedCertificate in our tests -->, + <argLine.java9.extras>--add-exports java.base/sun.security.x509=ALL-UNNAMED</argLine.java9.extras>, +++ b/transport-native-epoll/pom.xml, + <!-- Needed as we use SelfSignedCertificate in our tests -->, + <argLine.java9.extras>--add-exports java.base/sun.security.x509=ALL-UNNAMED</argLine.java9.extras>, +++ b/transport-native-kqueue/pom.xml, + <!-- Needed as we use SelfSignedCertificate in our tests -->, + <argLine.java9.extras>--add-exports java.base/sun.security.x509=ALL-UNNAMED</argLine.java9.extras>]
[+++ b/pom.xml, + <conscrypt.version>1.0.1</conscrypt.version>]
[+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java, + buf.writeByte(message.variableHeader().isSessionPresent() ? 0x01 : 0x00);]
[+++ b/resolver/src/main/java/io/netty/resolver/RoundRobinInetAddressResolver.java, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.concurrent.atomic.AtomicInteger;, + private final AtomicInteger index = new AtomicInteger();, + nameResolver.resolveAll(inetHost).addListener(new FutureListener<List<InetAddress>>() {, + if (numAddresses > 0) {, + // if there are multiple addresses: we shall pick one by one, + // to support the round robin distribution, + promise.setSuccess(inetAddresses.get(index.getAndIncrement() % numAddresses));, + promise.setFailure(new UnknownHostException(inetHost));, + protected void doResolveAll(String inetHost, final Promise<List<InetAddress>> promise) throws Exception {, + nameResolver.resolveAll(inetHost).addListener(new FutureListener<List<InetAddress>>() {, + @Override, + public void operationComplete(Future<List<InetAddress>> future) throws Exception {, + if (future.isSuccess()) {, + List<InetAddress> inetAddresses = future.getNow();, + if (!inetAddresses.isEmpty()) {, + // create a copy to make
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + executor.execute(WriteTask.newInstance(next, msg, size, false, promise));, + if (msg == null) {, + throw new NullPointerException("msg");, + }, + validatePromise(promise, true);, +, + final DefaultChannelHandlerContext next = findContextOutbound();, + EventExecutor executor = next.executor();, + if (executor.inEventLoop()) {, + next.invokeWrite(msg, promise);, + next.invokeFlush();, + } else {, + final int size = channel.estimatorHandle().size(msg);, + if (size > 0) {, + ChannelOutboundBuffer buffer = channel.unsafe().outboundBuffer();, + // Check for null as it may be set to null if the channel is closed already, + if (buffer != null) {, + buffer.incrementPendingOutboundBytes(size);, + }, + }, + executor.execute(WriteTask.newInstance(next, msg, size,
[+++ b/microbench/pom.xml, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-codec-redis</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, +++ b/microbench/pom.xml, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-codec-redis</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, +++ b/microbench/src/main/java/io/netty/microbench/redis/RedisEncoderBenchmark.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software,
[+++ b/pom.xml, + <version>3.0.0.M8-SNAPSHOT</version>]
[+++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java, +import io.netty.channel.ChannelBufferHolder;, +import io.netty.channel.ChannelBufferHolders;, +import io.netty.channel.ChannelInboundHandlerAdapter;, +import io.netty.channel.ChannelInboundHandlerContext;, +import io.netty.channel.EventLoop;, +, +import java.nio.channels.Channels;, +import java.util.concurrent.ScheduledFuture;, +import java.util.concurrent.TimeUnit;, +public class ReadTimeoutHandler extends ChannelInboundHandlerAdapter<Object> {, + private static final ReadTimeoutException EXCEPTION = new ReadTimeoutException();, + static {, + EXCEPTION.setStackTrace(new StackTraceElement[0]);, + }, +, + private final long timeoutMillis;, +, + private volatile ScheduledFuture<?> timeout;, + private volatile long lastReadTime;, + private volatile boolean destroyed;, + public ReadTimeoutHandler(int timeoutSeconds) {, + this(timeoutSeconds, TimeUnit.SECONDS);, + public ReadTimeoutHandler(long timeout, TimeUnit unit) {, + public ChannelBufferHolder<Object> newInboundBuffer(, + ChannelInboundHandlerContext<Object> ctx) throws Exception {, + return ChannelBufferHolders.inboundBypassBuffer(ctx);, + if (ctx.channel().isActive()) {, + // channelActvie()
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + private final PoolSubpage<T>[] tinySubpagePools;, + private final PoolSubpage<T>[] smallSubpagePools;, + tinySubpagePools[i] = newSubpagePoolHead(pageSize);, + smallSubpagePools[i] = newSubpagePoolHead(pageSize);, + private PoolSubpage<T> newSubpagePoolHead(int pageSize) {, + PoolSubpage<T> head = new PoolSubpage<T>(pageSize);, + head.prev = head;, + head.next = head;, + return head;, + }, +, + private PoolSubpage<T>[] newSubpagePoolArray(int size) {, + return new PoolSubpage[size];, + PoolSubpage<T>[] table;, + final PoolSubpage<T> head = table[tableIdx];, + final PoolSubpage<T> s = head.next;, + if (s != head) {, + assert s.doNotDestroy && s.elemSize == normCapacity;, + assert handle >= 0;, + q075.allocate(buf, reqCapacity, normCapacity) || q100.allocate(buf, reqCapacity, normCapacity)) {, +
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + closeFuture.setClosed();, + if (closeFuture.setClosed()) {, + } else {, + // Closed already., + promise.setSuccess();, + }, + * Will be called before the actual close operation will be performed. Sub-classes may override this as the default, + * is to do nothing., + */, + protected void doPreClose() throws Exception {, + // NOOP by default, + }, +, + /**, + try {, + doPreClose();, + } catch (Exception e) {, + logger.warn("doPreClose() raised an exception.", e);, + }, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + closeFuture.setClosed();, + if (closeFuture.setClosed()) {, + } else {, + // Closed
[+++ b/pom.xml, + <execution>, + <id>remove-examples</id>, + <phase>package</phase>, + <goals>, + <goal>run</goal>, + </goals>, + <configuration>, + <tasks>, + <taskdef resource="net/sf/antcontrib/antlib.xml" />, + <if>, + <or>, + <equals arg2="jar" arg1="${project.packaging}" />, + <equals arg2="bundle" arg1="${project.packaging}" />, + </or>, + <then>, + <move file="${project.build.directory}/${project.build.finalName}.jar" tofile="${project.build.directory}/${project.build.finalName}.orig.jar" />, + <zip destfile="${project.build.directory}/${project.build.finalName}.jar">, + <zipfileset filemode="644" src="${project.build.directory}/${project.build.finalName}.orig.jar" dirmode="755">, + <exclude name="*/*/*/example/**" />, + </zipfileset>, + </zip>, + <delete file="${project.build.directory}/${project.build.finalName}.orig.jar" />, + <checksum file="${project.build.directory}/${project.build.finalName}.jar" algorithm="md5" forceoverwrite="yes" />, + <checksum file="${project.build.directory}/${project.build.finalName}.jar" algorithm="sha1" forceoverwrite="yes" />, + <move file="${project.build.directory}/${project.build.finalName}-sources.jar" tofile="${project.build.directory}/${project.build.finalName}-sources.orig.jar" />, + <zip destfile="${project.build.directory}/${project.build.finalName}-sources.jar">, + <zipfileset filemode="644" src="${project.build.directory}/${project.build.finalName}-sources.orig.jar" dirmode="755">, + <exclude name="*/*/*/example/**" />, + </zipfileset>, + </zip>, +
[+++ b/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java, +import static io.netty.util.internal.MathUtil.isOutOfBounds;, +, + if (isOutOfBounds(index, length, buffer.capacity())) {, +++ b/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java, +import static io.netty.util.internal.MathUtil.isOutOfBounds;, +, + if (isOutOfBounds(index, length, buffer.capacity())) {, +++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, + return buf.retainedSlice().order(order);, + return buf.retainedSlice(index, length).order(order);, +++ b/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java, +import static io.netty.util.internal.MathUtil.isOutOfBounds;, +, + if (isOutOfBounds(index, length, buffer.capacity())) {, +++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, + return buf.retainedSlice().order(order);, + return buf.retainedSlice(index, length).order(order);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, + public void testRetainedSliceIndex() throws Exception {, + assertEqualsAndRelease(buffer, 0, buffer.retainedSlice(0, buffer.capacity()).readerIndex());, + assertEqualsAndRelease(buffer, 0, buffer.retainedSlice(0, buffer.capacity() - 1).readerIndex());, + assertEqualsAndRelease(buffer, 0, buffer.retainedSlice(1, buffer.capacity() - 1).readerIndex());, + assertEqualsAndRelease(buffer, 0, buffer.retainedSlice(1, buffer.capacity() - 2).readerIndex());, +, + assertEqualsAndRelease(buffer, buffer.capacity(), buffer.retainedSlice(0, buffer.capacity()).writerIndex());, + assertEqualsAndRelease(buffer,, + buffer.capacity()
[+++ b/all/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/codec-http2/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.7.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_epollCtlAdd0(JNIEnv* env, jclass clazz, jint efd, jint fd, jint flags) {, + int res = epollCtl(env, efd, EPOLL_CTL_ADD, fd, flags);, + if (res < 0) {, + return -errno;, + return res;, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_epollCtlMod0(JNIEnv* env, jclass clazz, jint efd, jint fd, jint flags) {, + int res = epollCtl(env, efd, EPOLL_CTL_MOD, fd, flags);, + if (res < 0) {, + return -errno;, + return res;, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_epollCtlDel0(JNIEnv* env, jclass clazz, jint efd, jint fd) {, + int res = epoll_ctl(efd, EPOLL_CTL_DEL, fd, &event);, + if (res < 0) {, +
[+++ b/pom.xml, + <properties>, + <attach-distribution>false</attach-distribution>, + </properties>, +, + <attach>${attach-distribution}</attach>]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2Decoder.java, + , + final int blockLength = blockDecompressor.blockLength();, + final ByteBuf uncompressed = ctx.alloc().buffer(blockLength);, + boolean success = false;, + try {, + success = true;, + } finally {, + if (!success) {, + uncompressed.release();, + }, + }, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2Decoder.java, + , + final int blockLength = blockDecompressor.blockLength();, + final ByteBuf uncompressed = ctx.alloc().buffer(blockLength);, + boolean success = false;, + try {, + success = true;, + } finally {, + if (!success) {, + uncompressed.release();, + }, + }, +++ b/codec/src/test/java/io/netty/handler/codec/compression/Bzip2DecoderTest.java, + try {, + } finally {, + for (;;) {, + ByteBuf
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, + * public class DataServerHandler extends {@link ChannelInboundMessageHandlerAdapter}&lt;Message&gt; {, + * public class DataServerHandler extends {@link ChannelInboundMessageHandlerAdapter}&lt;Message&gt; {]
[+++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +import java.util.ArrayDeque;, +import java.util.Queue;, + private Queue<UnsafeByteBuf> suspendedDeallocations;, + private final class Component {, + if (suspendedDeallocations == null) {, + buf.free(); // We should not get a NPE here. If so, it must be a bug., + } else {, + suspendedDeallocations.add(buf);, + }, + }, + }, + @Override, + resumeIntermediaryDeallocations();, + public void suspendIntermediaryDeallocations() {, + if (suspendedDeallocations == null) {, + suspendedDeallocations = new ArrayDeque<UnsafeByteBuf>(2);, + }, + }, +, + @Override, + public void resumeIntermediaryDeallocations() {, + if (suspendedDeallocations == null) {, + return;, + }, +, + Queue<UnsafeByteBuf> suspendedDeallocations = this.suspendedDeallocations;,
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/LzfDecoder.java, + * Current state of decompression., + private enum State {, + INIT_BLOCK,, + INIT_ORIGINAL_LENGTH,, + DECOMPRESS_DATA,, + CORRUPTED, + }, +, + private State currentState = State.INIT_BLOCK;, + * Magic number of LZF chunk., + private static final short MAGIC_NUMBER = BYTE_Z << 8 | BYTE_V;, + private ChunkDecoder decoder;, + private BufferRecycler recycler;, + * Length of current received chunk of data., + private int chunkLength;, +, + /**, + * Original length of current received chunk of data., + * It is equal to {@link #chunkLength} for non compressed chunks., + */, + private
[+++ b/transport/src/main/java/io/netty/channel/ChannelConfig.java, + * Set the {@link MessageSizeEstimator} which is used for the channel]
[+++ b/codec/src/main/java/io/netty/handler/codec/embedder/AbstractCodecEmbedder.java, +, + @Override, + public void fireEventLater(ChannelPipeline pipeline, ChannelEvent e) throws Exception {, + handleEvent(e);, + }, +++ b/codec/src/main/java/io/netty/handler/codec/embedder/AbstractCodecEmbedder.java, +, + @Override, + public void fireEventLater(ChannelPipeline pipeline, ChannelEvent e) throws Exception {, + handleEvent(e);, + }, +++ b/transport-http/src/main/java/io/netty/channel/socket/http/AbstractHttpChannelSink.java, +/*
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, + protected static <T extends ByteBuf> T freeLater(T buf) {, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, + protected static <T extends ByteBuf> T freeLater(T buf) {, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + CompositeByteBuf buf = freeLater(compositeBuffer(Integer.MAX_VALUE));, + freeLater(wrappedBuffer(wrappedBuffer(, + new byte[] { 3 }).order(order))));, + freeLater(wrappedBuffer(, + wrappedBuffer(new byte[] { 3 }).order(order))));, + freeLater(wrappedBuffer(wrappedBuffer(, + ByteBuffer.wrap(new byte[] { 3 })))));, + b.writeBytes(wrappedBuffer(new byte[] { 2 }).order(order));, + b.writeBytes(wrappedBuffer(new byte[] { 2 }).order(order));, + b.writeBytes(wrappedBuffer(new byte[] { 0, 1, 2, 3, 4 }, 3, 1).order(order));, + b = freeLater(wrappedBuffer(wrappedBuffer(new byte[] { 1, 2 }, new byte[1]).order(order)));, + b.writeBytes(wrappedBuffer(new byte[] { 4 }).order(order));, + b.writeBytes(wrappedBuffer(new byte[]
[+++ b/all/pom.xml, + <version>4.0.13.Final</version>, + <propertyselector property="versions" match="^(${project.groupId}:(?!netty-example)[^:]+:jar)$" select="\1" />, + <concat destfile="${project.build.outputDirectory}/META-INF/${project.groupId}.versions.properties" append="true">, +++ b/all/pom.xml, + <version>4.0.13.Final</version>, + <propertyselector property="versions" match="^(${project.groupId}:(?!netty-example)[^:]+:jar)$" select="\1" />, + <concat destfile="${project.build.outputDirectory}/META-INF/${project.groupId}.versions.properties" append="true">, +++ b/buffer/pom.xml, + <version>4.0.13.Final</version>, +++ b/all/pom.xml, + <version>4.0.13.Final</version>, + <propertyselector property="versions" match="^(${project.groupId}:(?!netty-example)[^:]+:jar)$" select="\1" />, + <concat destfile="${project.build.outputDirectory}/META-INF/${project.groupId}.versions.properties" append="true">, +++ b/buffer/pom.xml, + <version>4.0.13.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.13.Final</version>, +++ b/all/pom.xml, + <version>4.0.13.Final</version>, + <propertyselector property="versions" match="^(${project.groupId}:(?!netty-example)[^:]+:jar)$" select="\1" />, + <concat destfile="${project.build.outputDirectory}/META-INF/${project.groupId}.versions.properties" append="true">, +++ b/buffer/pom.xml, + <version>4.0.13.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.13.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.13.Final</version>, +++ b/all/pom.xml, + <version>4.0.13.Final</version>, + <propertyselector property="versions" match="^(${project.groupId}:(?!netty-example)[^:]+:jar)$" select="\1" />, + <concat destfile="${project.build.outputDirectory}/META-INF/${project.groupId}.versions.properties" append="true">, +++ b/buffer/pom.xml, + <version>4.0.13.Final</version>, +++
[+++ b/transport-native-epoll/pom.xml, + <replacement>CFLAGS=-O3 -DIO_NETTY_SENDMMSG_NOT_FOUND -Werror -fno-omit-frame-pointer -Wunused-variable</replacement>, + <replacement>CFLAGS=-O3 -Werror -fno-omit-frame-pointer -Wunused-variable</replacement>]
[+++ b/handler/src/main/java/io/netty/handler/ssl/PemPrivateKey.java, + byte[] bytes = key.getEncoded();, + if (bytes == null) {, + throw new IllegalArgumentException(key.getClass().getName() + " does not support encoding");, + }, +, + ByteBuf encoded = Unpooled.wrappedBuffer(bytes);, +++ b/handler/src/main/java/io/netty/handler/ssl/PemPrivateKey.java, + byte[] bytes = key.getEncoded();, + if (bytes == null) {, + throw new IllegalArgumentException(key.getClass().getName() + " does not support encoding");, + }, +, + ByteBuf encoded = Unpooled.wrappedBuffer(bytes);, +++ b/handler/src/test/java/io/netty/handler/ssl/PemEncodedTest.java, +import java.security.PrivateKey;, +import io.netty.buffer.Unpooled;, +import io.netty.buffer.UnpooledByteBufAllocator;, + @Test(expected = IllegalArgumentException.class), + public void testEncodedReturnsNull() throws Exception {, + PemPrivateKey.toPEM(UnpooledByteBufAllocator.DEFAULT, true, new PrivateKey() {, + @Override, + public String getAlgorithm() {, + return null;, + },
[+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + assert !isFreed();]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, + private final long maxFrameSize;, + public WebSocket00FrameDecoder(long maxFrameSize) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, + private final long maxFrameSize;, + public WebSocket00FrameDecoder(long maxFrameSize) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, + private long maxFramePayloadLength;, + * @param maxFramePayloadLength, + * Maximum length of a frame's payload. Setting this to an appropriate value for you application, + * helps check for denial of services attacks., + public WebSocket08FrameDecoder(boolean maskedPayload, boolean allowExtensions, long maxFramePayloadLength) {, + this.maxFramePayloadLength = maxFramePayloadLength;, + if (framePayloadLength > this.maxFramePayloadLength) {, + protocolViolation(channel, "Max frame length of " + this.maxFramePayloadLength + " has been exceeded.");, + return null;, + }, +
[+++ b/transport/src/main/java/io/netty/channel/DelegatingChannelPromiseNotifier.java, + public ChannelPromise addListeners(GenericFutureListener<? extends Future<? super Void>>... listeners) {, + public ChannelPromise removeListeners(GenericFutureListener<? extends Future<? super Void>>... listeners) {, +++ b/transport/src/main/java/io/netty/channel/DelegatingChannelPromiseNotifier.java, + public ChannelPromise addListeners(GenericFutureListener<? extends Future<? super Void>>... listeners) {, + public ChannelPromise removeListeners(GenericFutureListener<? extends Future<? super Void>>... listeners) {, +++ b/transport/src/test/java/io/netty/channel/DelegatingChannelPromiseNotifierTest.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:,
[+++ b/common/src/main/java/io/netty/util/AsciiString.java, + final int subCount = subString.length();, + return start < length ? start : length;, + if (subCount > length - start) {, + return INDEX_NOT_FOUND;, + return INDEX_NOT_FOUND;, + final byte firstCharAsByte = c2b0(firstChar);, + final int len = offset + start + length - subCount;, + for (int i = start + offset; i <= len; ++i) {, + if (value[i] == firstCharAsByte) {, + while (++o2 < subCount && b2c(value[++o1]) == subString.charAt(o2)) {, + return i - offset;, + return INDEX_NOT_FOUND;, + if (ch > MAX_CHAR_VALUE) {, + return INDEX_NOT_FOUND;, + }, +, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java, + private HttpTransferEncoding te = HttpTransferEncoding.SINGLE;, + public HttpTransferEncoding getTransferEncoding() {, + return te;, + public void setTransferEncoding(HttpTransferEncoding te) {, + if (te == null) {, + throw new NullPointerException("te (transferEncoding)");, + }, + this.te = te;, + switch (te) {, + case SINGLE:, + HttpCodecUtil.removeTransferEncodingChunked(this);, + break;, + case STREAMED:, + HttpCodecUtil.removeTransferEncodingChunked(this);, + break;, + case CHUNKED:, + if (!HttpCodecUtil.isTransferEncodingChunked(this)) {, + addHeader(HttpHeaders.Names.TRANSFER_ENCODING, HttpHeaders.Values.CHUNKED);, + }, + removeHeader(HttpHeaders.Names.CONTENT_LENGTH);, + setContent(Unpooled.EMPTY_BUFFER);, + break;, +, + if (!getTransferEncoding().isSingle() && content.readable()) {, + "non-empty content disallowed if this.transferEncoding != SINGLE");, +, + if (getTransferEncoding() == HttpTransferEncoding.SINGLE) {, + }
[+++ b/buffer/src/test/java/io/netty/buffer/EmptyByteBufTest.java, + } finally {, + nonEmpty.release();]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, +import io.netty.util.AsciiString;, +import static io.netty.handler.codec.http.HttpConstants.CR;, +import static io.netty.handler.codec.http.HttpConstants.LF;, +import static io.netty.handler.codec.http.HttpConstants.SP;, + AsciiString method = request.method().asciiName();, + ByteBufUtil.copy(method, method.arrayOffset(), buf, method.length());]
[+++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClient.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, + boot.group(connectGroup), +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClient.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, + boot.group(connectGroup), +++ b/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClient.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, + boot.group(connectGroup), +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClient.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, + boot.group(connectGroup), +++ b/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClient.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, + boot.group(connectGroup), +++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteConnectorChannel.java, +import com.barchart.udt.TypeUDT;, +import com.barchart.udt.nio.SocketChannelUDT;, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, +import java.net.InetSocketAddress;, +import static java.nio.channels.SelectionKey.*;, + doBind(localAddress != null? localAddress : new InetSocketAddress(0));, +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClient.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, + boot.group(connectGroup), +++ b/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClient.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, + boot.group(connectGroup), +++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteConnectorChannel.java, +import com.barchart.udt.TypeUDT;, +import com.barchart.udt.nio.SocketChannelUDT;, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, +import java.net.InetSocketAddress;, +import static java.nio.channels.SelectionKey.*;, + doBind(localAddress != null? localAddress
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractDiskHttpData.java, + localfileChannel.force(false);, + fileChannel.force(false);, + localfileChannel.force(false);, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractDiskHttpData.java, + localfileChannel.force(false);, + fileChannel.force(false);, + localfileChannel.force(false);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractMemoryHttpData.java, + }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractDiskHttpData.java, + localfileChannel.force(false);, + fileChannel.force(false);, + localfileChannel.force(false);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractMemoryHttpData.java, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractDiskHttpData.java, + localfileChannel.force(false);, + fileChannel.force(false);, + localfileChannel.force(false);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractMemoryHttpData.java, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, + write(ctx, succeededFuture(ctx.channel()), CONTINUE.duplicate());, + m.setContent(ChannelBuffers.dynamicBuffer(e.channel().getConfig().getBufferFactory()));, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractDiskHttpData.java, + localfileChannel.force(false);, + fileChannel.force(false);, + localfileChannel.force(false);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractMemoryHttpData.java, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java, +import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, + private final SensitivityDetector sensitivityDetector;, + this(DEFAULT_HEADER_TABLE_SIZE, NEVER_SENSITIVE);, + public DefaultHttp2HeadersEncoder(int maxHeaderTableSize, SensitivityDetector sensitivityDetector) {, + this.sensitivityDetector = checkNotNull(sensitivityDetector, "sensitiveDetector");, + encoder.encodeHeader(stream, key.array(), value.array(), sensitivityDetector.isSensitive(key, value));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java, +import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, + private final SensitivityDetector sensitivityDetector;, + this(DEFAULT_HEADER_TABLE_SIZE, NEVER_SENSITIVE);, + public DefaultHttp2HeadersEncoder(int maxHeaderTableSize, SensitivityDetector sensitivityDetector) {, + this.sensitivityDetector = checkNotNull(sensitivityDetector, "sensitiveDetector");, + encoder.encodeHeader(stream, key.array(), value.array(), sensitivityDetector.isSensitive(key, value));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeadersEncoder.java, +import io.netty.handler.codec.AsciiString;, + * Determine if a header name/value pair is treated as, + * <a href="http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-7.1.3">sensitive</a>., + * If the object can be dynamically modified and shared across
[+++ b/all/pom.xml, + <dependencyVersionsDir>${project.build.directory}/versions</dependencyVersionsDir>, + <includes>io/netty/**</includes>, + <excludes>io/netty/example/**,META-INF/native/libnetty-tcnative*</excludes>, + <includeGroupIds>${project.groupId}</includeGroupIds>, + <delete dir="${dependencyVersionsDir}" quiet="true" />]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, +import static io.netty.buffer.ByteBufUtil.readBytes;, +, + ByteBuf payload = readBytes(ctx.alloc(), buffer, (int) frameSize);, + ByteBuf binaryData = readBytes(ctx.alloc(), buffer, frameSize);, + binaryData.release();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, +import static io.netty.buffer.ByteBufUtil.readBytes;, +, + ByteBuf payload = readBytes(ctx.alloc(), buffer, (int) frameSize);, + ByteBuf binaryData = readBytes(ctx.alloc(), buffer, frameSize);, + binaryData.release();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +import io.netty.handler.codec.ByteToMessageDecoder;, +import static io.netty.buffer.ByteBufUtil.readBytes;, +, +public class WebSocket08FrameDecoder extends ByteToMessageDecoder, + enum State {, + READING_FIRST,, + READING_SECOND,, + READING_SIZE,, + MASKING_KEY,, + PAYLOAD,, + CORRUPT, + }, +, + private int framePayloadLen1;, + private final long maxFramePayloadLength;, + private final boolean allowExtensions;, + private final boolean maskedPayload;, +, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + ChannelHandlerContext ctx, Object msg, List<Object> out) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + ChannelHandlerContext ctx, Object msg, List<Object> out) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, +import io.netty.channel.FileRegion;, +import io.netty.util.ReferenceCountUtil;, +public abstract class HttpObjectEncoder<H extends HttpMessage> extends MessageToMessageEncoder<Object> {, + protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out) throws Exception {, + if (msg instanceof HttpContent || msg instanceof ByteBuf || msg instanceof FileRegion) {, + int contentLength = contentLength(msg);, + out.add(encodeAndRetain(msg));, + if (msg instanceof LastHttpContent) {, + out.add(encodeAndRetain(msg));, + if (msg instanceof LastHttpContent) {, + HttpHeaders headers = ((LastHttpContent) msg).trailingHeaders();, + @Override, + public boolean acceptOutboundMessage(Object msg)
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +import io.netty.channel.CoalescingBufferQueue;, +, + private final CoalescingBufferQueue queue;, + queue = new CoalescingBufferQueue(ctx.channel());, + queue.add(buf, promise);, + return queue.readableBytes() + padding;, + queue.releaseAndFailAll(cause);, + if (!endOfStream && (queue.readableBytes() == 0 || allowedBytes == 0)) {, + // Nothing to write and we don't have to force a write because of EOS., + int allowedFrameSize = Math.min(maxFrameSize, allowedBytes);, + int writeableData = Math.min(queue.readableBytes(), allowedFrameSize);, + ChannelPromise writePromise = ctx.newPromise();, + writePromise.addListener(this);, + ByteBuf toWrite = queue.remove(writeableData, writePromise);, +, + allowedBytes -= writeableData + writeablePadding;, + endOfStream && size() == 0, writePromise);, + } while (size() > 0 &&
[+++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, + *, + * @deprecated use {@link #valueOf(String)}., + @Deprecated]
[+++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor);, + return new NioServerSocketChannelFactory(executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor);, + return new NioServerSocketChannelFactory(executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioOioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor);, + return new NioServerSocketChannelFactory(executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioOioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/OioNioSocketSpdyEchoTest.java, + return new NioServerSocketChannelFactory(executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor);, + return new NioServerSocketChannelFactory(executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioOioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/OioNioSocketSpdyEchoTest.java, + return new NioServerSocketChannelFactory(executor);, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor);, + return new NioServerSocketChannelFactory(executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioOioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/OioNioSocketSpdyEchoTest.java, + return new NioServerSocketChannelFactory(executor);, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, +++
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java, + private int id;, + * @param id the unique ID of this frame, + public DefaultSpdyPingFrame(int id) {, + setId(id);, + public int getId() {, + return id;, + public void setId(int id) {, + this.id = id;, + buf.append(id);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java, + private int id;, + * @param id the unique ID of this frame, + public DefaultSpdyPingFrame(int id) {, + setId(id);, + public int getId() {, + return id;, + public void setId(int id) {, + this.id = id;, + buf.append(id);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, + out.writeInt(spdyPingFrame.getId());, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java, + private int id;, + * @param
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + if (handler instanceof ChannelOutboundHandler) {]
[+++ b/src/docbook/module/start.xml, + multiple &Channel;s and consequently the data will be messed up. To]
[+++ b/pom.xml, +<?xml version="1.0" encoding="UTF-8"?><project>, + <version>3.0.0.CR3-SNAPSHOT</version>, + <description>The Netty project is an effort to provide an asynchronous / event-driven network application framework for rapid development of high-performance / high-scalability protocol servers and clients, including its related out-of-the-box protocol extensions and tool suite.</description>, + <organization>, + <name>JBoss - a division of Red Hat</name>, + <url>http://www.jboss.org/</url>, + </organization>, + <additionalparam>-charset UTF-8, + -group "Miscellaneous" ${project.groupId}.logging*</additionalparam>, + <goals>, + <goal>run</goal>, + </goals>, + <equals arg2="jar" arg1="${project.packaging}" />, + <equals arg2="bundle" arg1="${project.packaging}" />, + <zipfileset filemode="644" src="${project.build.directory}/${project.build.finalName}.orig.jar" dirmode="755">, + <zipfileset filemode="644" src="${project.build.directory}/${project.build.finalName}-sources.orig.jar" dirmode="755">, + <zipfileset filemode="644" src="${project.build.directory}/${project.build.finalName}-javadoc.orig.jar" dirmode="755" />, + <tagBase>https://svn.jboss.org/repos/netty/tags</tagBase>, +
[+++ b/all/pom.xml, + <version>4.0.0.CR1</version>, +++ b/all/pom.xml, + <version>4.0.0.CR1</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR1</version>, +++ b/all/pom.xml, + <version>4.0.0.CR1</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR1</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR1</version>, +++ b/all/pom.xml, + <version>4.0.0.CR1</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR1</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR1</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR1</version>, +++ b/all/pom.xml, + <version>4.0.0.CR1</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR1</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR1</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR1</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR1</version>, +++ b/all/pom.xml, + <version>4.0.0.CR1</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR1</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR1</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR1</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR1</version>, +++ b/common/pom.xml, + <version>4.0.0.CR1</version>, +++ b/all/pom.xml, + <version>4.0.0.CR1</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR1</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR1</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + channelInputClosed(ctx, out);, + * Called when the input of the channel was closed which may be because it changed to inactive or because of, + * {@link ChannelInputShutdownEvent}., + */, + void channelInputClosed(ChannelHandlerContext ctx, List<Object> out) throws Exception {, + if (cumulation != null) {, + callDecode(ctx, cumulation, out);, + decodeLast(ctx, cumulation, out);, + } else {, + decodeLast(ctx, Unpooled.EMPTY_BUFFER, out);, + }, + }, +, + /**, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + channelInputClosed(ctx, out);, + * Called when the input of the channel was closed which may be because it changed to inactive or because of, +
[+++ b/all/pom.xml, + <execution>, + <id>unpack-jars</id>, + <phase>prepare-package</phase>, + <goals>, + <goal>unpack-dependencies</goal>, + </goals>, + <configuration>, + <includes>io/netty/**</includes>, + <excludes>io/netty/example/**</excludes>, + <outputDirectory>${project.build.outputDirectory}</outputDirectory>, + </configuration>, + </execution>]
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + int localReadAmount = doReadMessages(msgBuf);, + int localReadAmount = doReadBytes(byteBuf);, + if (!buf.readable()) {, + // Reset reader/writerIndex to 0 if the buffer is empty., + buf.clear();, + return;, + }, +, + int localFlushedAmount = doWriteBytes(buf, i == 0);, + int localFlushedAmount = doWriteMessages(buf, i == 0);, + protected int doReadMessages(Queue<Object> buf) throws Exception {, + throw new UnsupportedOperationException();, + }, +, + protected int doReadBytes(ChannelBuffer buf) throws Exception {, + throw new UnsupportedOperationException();, + }, +, + protected int doWriteMessages(Queue<Object> buf, boolean lastSpin) throws Exception {, + throw new UnsupportedOperationException();, + }, +, + protected
[+++ b/all/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR8-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelConfig.java, + return ((AbstractEpollChannel) channel).isFlagSet(Native.EPOLLET), + ((AbstractEpollChannel) channel).setFlag(Native.EPOLLET);, + ((AbstractEpollChannel) channel).clearFlag(Native.EPOLLET);, + ((AbstractEpollChannel) channel).clearEpollIn();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelConfig.java, + return ((AbstractEpollChannel) channel).isFlagSet(Native.EPOLLET), + ((AbstractEpollChannel) channel).setFlag(Native.EPOLLET);, + ((AbstractEpollChannel) channel).clearFlag(Native.EPOLLET);, + ((AbstractEpollChannel) channel).clearEpollIn();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannelConfig.java, + return ((EpollDatagramChannel) channel).socket.getSendBufferSize();, + ((EpollDatagramChannel) channel).socket.setSendBufferSize(sendBufferSize);, + return ((EpollDatagramChannel) channel).socket.getReceiveBufferSize();, + ((EpollDatagramChannel) channel).socket.setReceiveBufferSize(receiveBufferSize);, + return ((EpollDatagramChannel) channel).socket.getTrafficClass();, + ((EpollDatagramChannel) channel).socket.setTrafficClass(trafficClass);, + return ((EpollDatagramChannel) channel).socket.isReuseAddress();, + ((EpollDatagramChannel) channel).socket.setReuseAddress(reuseAddress);, + return ((EpollDatagramChannel) channel).socket.isBroadcast();, + ((EpollDatagramChannel) channel).socket.setBroadcast(broadcast);, + return ((EpollDatagramChannel) channel).socket.isReusePort();, + ((EpollDatagramChannel) channel).socket.setReusePort(reusePort);, + return ((EpollDatagramChannel) channel).socket.isIpTransparent();, + ((EpollDatagramChannel) channel).socket.setIpTransparent(ipTransparent);, + return ((EpollDatagramChannel) channel).socket.isIpRecvOrigDestAddr();, + ((EpollDatagramChannel) channel).socket.setIpRecvOrigDestAddr(ipTransparent);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelConfig.java, + return ((AbstractEpollChannel) channel).isFlagSet(Native.EPOLLET), + ((AbstractEpollChannel) channel).setFlag(Native.EPOLLET);, + ((AbstractEpollChannel)
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexCodecTest.java, +import io.netty.channel.ChannelFutureListener;, +import java.net.InetSocketAddress;, +import java.util.concurrent.atomic.AtomicBoolean;, +, + public void channelClosedWhenCloseListenerCompletes() {, + LastInboundHandler inboundHandler = streamActiveAndWriteHeaders(inboundStream);, + Http2StreamChannel childChannel = (Http2StreamChannel) inboundHandler.channel();, +, + assertTrue(childChannel.isOpen());, + assertTrue(childChannel.isActive());, +, + final AtomicBoolean channelOpen = new AtomicBoolean(true);, + final AtomicBoolean channelActive = new AtomicBoolean(true);, +, + // Create a promise before actually doing the close, because otherwise we would be adding a listener to a future, + // that is already completed because we are using EmbeddedChannel which executes code in the JUnit thread., + ChannelPromise p = childChannel.newPromise();, + p.addListener(new ChannelFutureListener() {, + @Override, + public void
[+++ b/pom.xml, + <version>1.3.0.GA</version>]
[+++ b/src/docbook/module/start.xml, + System.out.println((char) buf.readByte());]
[+++ b/example/pom.xml, + <classpathScope>runtime</classpathScope>, + <classpathScope>runtime</classpathScope>, +++ b/example/pom.xml, + <classpathScope>runtime</classpathScope>, + <classpathScope>runtime</classpathScope>, +++ b/pom.xml, + <plugin>, + <groupId>org.codehaus.mojo</groupId>, + <artifactId>exec-maven-plugin</artifactId>, + <version>1.2.1</version>, + </plugin>]
[+++ b/pom.xml, + <!-- JDK12 -->, + <profile>, + <id>java12</id>, + <activation>, + <jdk>12</jdk>, + </activation>, + <properties>, + <!-- Not use alpn agent as Java11 supports alpn out of the box -->, + <argLine.alpnAgent />, + <forbiddenapis.skip>true</forbiddenapis.skip>, + <!-- Needed because of https://issues.apache.org/jira/browse/MENFORCER-275 -->, + <enforcer.plugin.version>3.0.0-M1</enforcer.plugin.version>, + <!-- 1.4.x does not work in Java10+ -->, + <jboss.marshalling.version>2.0.5.Final</jboss.marshalling.version>, + <!-- This is the minimum supported by Java12 -->, + <maven.compiler.source>1.7</maven.compiler.source>, + <maven.compiler.target>1.7</maven.compiler.target>, + </properties>, + </profile>, +]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/Utf8FrameValidator.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/Utf8FrameValidator.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketExtensionUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/Utf8FrameValidator.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketExtensionUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/DeflateDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/Utf8FrameValidator.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketExtensionUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/DeflateDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/Utf8FrameValidator.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketExtensionUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/DeflateDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/WebSocketClientCompressionHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/Utf8FrameValidator.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketExtensionUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/DeflateDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/WebSocketClientCompressionHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/Utf8FrameValidator.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketExtensionUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/DeflateDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/WebSocketClientCompressionHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/CombinedHttpHeadersTest.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/Utf8FrameValidator.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketExtensionUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/DeflateDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/WebSocketClientCompressionHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/CombinedHttpHeadersTest.java, +++ b/common/src/main/java/io/netty/util/HashingStrategy.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/Utf8FrameValidator.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketExtensionUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/DeflateDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/WebSocketClientCompressionHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/CombinedHttpHeadersTest.java, +++ b/common/src/main/java/io/netty/util/HashingStrategy.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/benchmarkserver/WebSocketServer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/Utf8FrameValidator.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketExtensionUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/DeflateDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshaker.java, +++
[+++ /dev/null, +++ /dev/null, +++ b/all/pom.xml, + <id>clean-first</id>, + <includeGroupIds>${project.groupId}</includeGroupIds>, + <outputDirectory>${project.build.directory}/src</outputDirectory>, + <groupId>org.codehaus.mojo</groupId>, + <artifactId>build-helper-maven-plugin</artifactId>, + <version>1.7</version>, + <id>add-source</id>, + <phase>generate-sources</phase>, + <goal>add-source</goal>, + <sources>, + <source>target/src</source>, + </sources>, +, + <profiles>, + <profile>, + <id>full</id>, + <build>, + <plugins>, + <plugin>, + <artifactId>maven-jxr-plugin</artifactId>, + <version>2.2</version>, + <executions>, + <execution>, + <id>generate-xref</id>, + <phase>package</phase>, + <goals>, + <goal>jxr</goal>, + </goals>, + </execution>, + </executions>, + <configuration>, + <inputEncoding>UTF-8</inputEncoding>, + <outputEncoding>UTF-8</outputEncoding>, + <linkJavadoc>true</linkJavadoc>, + <destDir>${project.build.directory}/xref</destDir>, + <javadocDir>${project.build.directory}/api</javadocDir>, + <docTitle>Netty Source Xref (${project.version})</docTitle>, + <windowTitle>Netty Source Xref (${project.version})</windowTitle>, + </configuration>, + </plugin>, + <plugin>, + <artifactId>maven-javadoc-plugin</artifactId>, + <version>2.8.1</version>, + <executions>,
[+++ b/transport-native-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueChannel.java, +import io.netty.channel.ChannelException;, + static boolean isSoErrorZero(BsdSocket fd) {, + try {, + return fd.getSoError() == 0;, + } catch (IOException e) {, + throw new ChannelException(e);, + }, + }, +, +++ b/transport-native-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueChannel.java, +import io.netty.channel.ChannelException;, + static boolean isSoErrorZero(BsdSocket fd) {, + try {, + return fd.getSoError() == 0;, + } catch (IOException e) {, + throw new ChannelException(e);, + }, + }, +, +++ b/transport-native-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueServerChannel.java, + AbstractKQueueServerChannel(BsdSocket fd) {, + this(fd, isSoErrorZero(fd));, + }, +, +++ b/transport-native-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueChannel.java, +import io.netty.channel.ChannelException;, + static boolean isSoErrorZero(BsdSocket fd) {, + try {, + return fd.getSoError() == 0;, + } catch
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/InboundHttpToHttp2Adapter.java, + connection.remote().incrementAndGetNextStreamId());]
[+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java, +import java.net.ConnectException;, + * If the connection fails because of a connection timeout, the {@link ChannelFuture} will get failed with, + * a {@link ConnectTimeoutException}. If it fails because of connection refused a {@link ConnectException}, + * will be used., + * <p>, + *, + * <p>, + * If the connection fails because of a connection timeout, the {@link ChannelFuture} will get failed with, + * a {@link ConnectTimeoutException}. If it fails because of connection refused a {@link ConnectException}, + * will be used., +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java, +import java.net.ConnectException;, + * If the connection fails because
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackDecoder.java, +, + if (state != READ_HEADER_REPRESENTATION) {, + throw connectionError(COMPRESSION_ERROR, "Incomplete header block fragment.");, + }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackDecoder.java, +, + if (state != READ_HEADER_REPRESENTATION) {, + throw connectionError(COMPRESSION_ERROR, "Incomplete header block fragment.");, + }, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/HpackDecoderTest.java, +, + @Test, + public void testIncompleteHeaderFieldRepresentation() throws Http2Exception {, + // Incomplete Literal Header Field with Incremental Indexing, + byte[] input = {(byte) 0x40};, + ByteBuf in = Unpooled.wrappedBuffer(input);, + try {, + expectedException.expect(Http2Exception.class);, + hpackDecoder.decode(0, in, mockHeaders);, + } finally {, + in.release();, + }, + }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackDecoder.java, +, + if (state != READ_HEADER_REPRESENTATION) {, + throw connectionError(COMPRESSION_ERROR,
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + int writerIndex;, + this.swappedBuf = swappedBuf = newSwappedByteBuf();, + /**, + * Creates a new {@link SwappedByteBuf} for this {@link ByteBuf} instance., + */, + protected SwappedByteBuf newSwappedByteBuf() {, + return new SwappedByteBuf(this);, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + int writerIndex;, + this.swappedBuf = swappedBuf = newSwappedByteBuf();, + /**, + * Creates a new {@link SwappedByteBuf} for this {@link ByteBuf} instance., + */, + protected SwappedByteBuf newSwappedByteBuf() {, + return new SwappedByteBuf(this);, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +, + @Override, + protected SwappedByteBuf newSwappedByteBuf() {, + return new UnsafeDirectSwappedByteBuf(this, memoryAddress);, + }, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + int
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskFileUpload.java, + (getCharset() != null? "; " + HttpHeaderValues.CHARSET + '=' + getCharset().name() + "\r\n" : "\r\n") +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskFileUpload.java, + (getCharset() != null? "; " + HttpHeaderValues.CHARSET + '=' + getCharset().name() + "\r\n" : "\r\n") +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, + + localcharset.name() + "\r\n");, + internal.addValue("; " + HttpHeaderValues.CHARSET + '=' + fileUpload.getCharset().name() + "\r\n\r\n");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskFileUpload.java, + (getCharset() != null? "; " + HttpHeaderValues.CHARSET + '=' + getCharset().name() + "\r\n" : "\r\n") +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, + + localcharset.name() + "\r\n");, + internal.addValue("; " + HttpHeaderValues.CHARSET + '=' + fileUpload.getCharset().name() + "\r\n\r\n");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MemoryFileUpload.java, + (getCharset() != null?
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + final ChannelBufferHolder<Object> out = directOutbound;, + final int newSize = out.size();, + writeCounter += oldSize - newSize;, + if (newSize == 0 && out.hasByteBuffer()) {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + final ChannelBufferHolder<Object> out = directOutbound;, + final int newSize = out.size();, + writeCounter += oldSize - newSize;, + if (newSize == 0 && out.hasByteBuffer()) {, +++ b/transport/src/main/java/io/netty/channel/DefaultChildEventExecutor.java, + DefaultChildEventExecutor(ThreadFactory threadFactory) {, + super(threadFactory);, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + final ChannelBufferHolder<Object> out = directOutbound;, + final int newSize = out.size();, + writeCounter += oldSize - newSize;, + if (newSize == 0 && out.hasByteBuffer()) {, +++ b/transport/src/main/java/io/netty/channel/DefaultChildEventExecutor.java, + DefaultChildEventExecutor(ThreadFactory threadFactory) {, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseStatus.java, + * 308 Permanent Redirect (RFC7538), + */, + public static final HttpResponseStatus PERMANENT_REDIRECT = newStatus(308, "Permanent Redirect");, +, + /**, + case 308:, + return PERMANENT_REDIRECT;]
[+++ b/handler/src/main/java/io/netty/handler/ssl/PemReader.java, +import java.io.FileNotFoundException;, + try {, + InputStream in = new FileInputStream(file);, +, + try {, + return readCertificates(in);, + } finally {, + safeClose(in);, + }, + } catch (FileNotFoundException e) {, + throw new CertificateException("could not find certificate file: " + file);, + }, + }, +, + static ByteBuf[] readCertificates(InputStream in) throws CertificateException {, + content = readContent(in);, + throw new CertificateException("failed to read certificate input stream", e);, + throw new CertificateException("found no certificates in input stream");, + try {, + InputStream in = new FileInputStream(file);, +, + try {, + return readPrivateKey(in);, + }
[+++ b/pom.xml, + -group "Central interface for all I/O operations" ${project.groupId}.channel*]
[+++ b/all/pom.xml]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, + private boolean read;, + public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {, + if (!read) {, + if (!ctx.channel().config().isAutoRead()) {, + ctx.read();, + }, + }, + read = false;, + super.channelReadComplete(ctx);, + }, +, + @Override, + read = true;, +, + read = true;, +, + read = true;, +, + read = true;, +, + read = true;, +, + read = true;, +, + read = true;, +, + read = true;, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, + private boolean read;, + public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {, + if (!read) {, + if
[+++ b/README.md, +- __3.2__ branch contains code for Netty v3.X, +++ b/README.md, +- __3.2__ branch contains code for Netty v3.X, +++ b/all/pom.xml, +++ b/README.md, +- __3.2__ branch contains code for Netty v3.X, +++ b/all/pom.xml, +++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E> {, +, + public ObjectArray(E[] array, int offset, int length) {, + super(array, offset, length);, + }, +, + @Override, + public E[] array() {, + return (E[]) super.array();, + }, +}, +++ b/README.md, +- __3.2__ branch contains code for Netty v3.X, +++ b/all/pom.xml, +++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, +++ b/codec-socks/src/main/java/io/netty/codec/socks/SocksAuthRequest.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, +++ b/codec-socks/src/main/java/io/netty/codec/socks/SocksAuthRequest.java, +++ b/codec-socks/src/main/java/io/netty/codec/socks/SocksAuthRequestDecoder.java, + version = SocksMessage.ProtocolVersion.fromByte(byteBuf.readByte());, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, +++ b/codec-socks/src/main/java/io/netty/codec/socks/SocksAuthRequest.java, +++ b/codec-socks/src/main/java/io/netty/codec/socks/SocksAuthRequestDecoder.java, + version = SocksMessage.ProtocolVersion.fromByte(byteBuf.readByte());, +++ b/codec-socks/src/main/java/io/netty/codec/socks/SocksCmdRequest.java, + if (port < 0 && port >= 65535) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + @Override, + @Override, + @Override, + @Override, + @Override, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, + throw new IllegalStateException("unexpected message type: " + StringUtil.simpleClassName(msg), + + ", state: " + state);]
[+++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java]
[+++ b/handler/src/main/java/io/netty/handler/ssl/Java8SslUtils.java, + static boolean checkSniHostnameMatch(Collection<?> matchers, byte[] hostname) {, +++ b/handler/src/main/java/io/netty/handler/ssl/Java8SslUtils.java, + static boolean checkSniHostnameMatch(Collection<?> matchers, byte[] hostname) {, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import io.netty.util.CharsetUtil;, + final boolean checkSniHostnameMatch(byte[] hostname) {, +++ b/handler/src/main/java/io/netty/handler/ssl/Java8SslUtils.java, + static boolean checkSniHostnameMatch(Collection<?> matchers, byte[] hostname) {, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import io.netty.util.CharsetUtil;, + final boolean checkSniHostnameMatch(byte[] hostname) {, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslServerContext.java, +import io.netty.util.CharsetUtil;, + // TODO: In the next release of tcnative we should pass the byte[] directly in and not use a String., + return engine.checkSniHostnameMatch(hostname.getBytes(CharsetUtil.UTF_8));, +++ b/handler/src/main/java/io/netty/handler/ssl/Java8SslUtils.java, + static boolean checkSniHostnameMatch(Collection<?> matchers, byte[] hostname) {, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import io.netty.util.CharsetUtil;, + final boolean checkSniHostnameMatch(byte[] hostname) {, +++
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + final int localReaderIndex = readerIndex();, + int localWriterIndex = writerIndex();, + localMarkedReaderIndex = readerIndex();, + localMarkedWriterIndex = writerIndex();, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + final int localReaderIndex = readerIndex();, + int localWriterIndex = writerIndex();, + localMarkedReaderIndex = readerIndex();, + localMarkedWriterIndex = writerIndex();, +++ b/codec-http/pom.xml, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + final int localReaderIndex = readerIndex();, + int localWriterIndex = writerIndex();, + localMarkedReaderIndex = readerIndex();, + localMarkedWriterIndex = writerIndex();, +++ b/codec-http/pom.xml, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, + if (encoding.contains("*")) {, + } else if (encoding.contains("gzip") && q > gzipQ) {, + } else if (encoding.contains("deflate") && q > deflateQ) {, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + final int localReaderIndex
[+++ b/common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java, + // Get from a different thread to avoid blocking indefinitely on a machine without much entropy., + "Not enough entropy?", timeoutSeconds]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java, + StringBuilder pathBuilder = new StringBuilder(length(uri.getRawPath()) +, + length(uri.getRawQuery()) + length(uri.getRawFragment()) + 2);, + if (!isNullOrEmpty(uri.getRawPath())) {, + pathBuilder.append(uri.getRawPath());, + if (!isNullOrEmpty(uri.getRawQuery())) {, + pathBuilder.append(uri.getRawQuery());, + if (!isNullOrEmpty(uri.getRawFragment())) {, + pathBuilder.append(uri.getRawFragment());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java, + StringBuilder pathBuilder = new StringBuilder(length(uri.getRawPath()) +, + length(uri.getRawQuery()) + length(uri.getRawFragment()) + 2);, + if (!isNullOrEmpty(uri.getRawPath())) {, + pathBuilder.append(uri.getRawPath());, + if (!isNullOrEmpty(uri.getRawQuery())) {, + pathBuilder.append(uri.getRawQuery());, + if (!isNullOrEmpty(uri.getRawFragment())) {, + pathBuilder.append(uri.getRawFragment());, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandlerTest.java, + public void testOriginFormRequestTargetHandledFromUrlencodedUri() throws Exception {, + bootstrapEnv(2, 1, 0);, + final FullHttpRequest request = new DefaultFullHttpRequest(, + HTTP_1_1, GET, "/where%2B0?q=now%2B0&f=then%2B0#section1%2B0");, + final HttpHeaders httpHeaders = request.headers();, + httpHeaders.setInt(HttpConversionUtil.ExtensionHeaderNames.STREAM_ID.text(), 5);,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaders.java, + * {@code ":method"}, + public static final String METHOD = ":method";, + * {@code ":status"}, + public static final String STATUS = ":status";, + * {@code "method"}, + public static final String METHOD = "method";, + * {@code "status"}, + public static final String STATUS = "status";, + * Removes the HTTP method header., + * Returns the {@link HttpMethod} represented by the HTTP method header., + * Sets the HTTP method header., + * Removes the HTTP response status header., + * Returns the {@link HttpResponseStatus} represented by the HTTP response status header., + *
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java, +import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;, +import static io.netty.handler.codec.http2.Http2Exception.connectionError;, +import static io.netty.util.AsciiString.CASE_SENSITIVE_HASHER;, +import static io.netty.util.AsciiString.isUpperCase;, + public boolean equals(Object o) {, + if (!(o instanceof Http2Headers)) {, + return false;, + }, +, + return equals((Http2Headers) o, CASE_SENSITIVE_HASHER);, + }, +, + @Override, + public int hashCode() {, + return hashCode(CASE_SENSITIVE_HASHER);, + }, +, + @Override, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java, +import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;, +import static io.netty.handler.codec.http2.Http2Exception.connectionError;, +import static io.netty.util.AsciiString.CASE_SENSITIVE_HASHER;, +import static io.netty.util.AsciiString.isUpperCase;, + public boolean equals(Object o) {, + if (!(o instanceof Http2Headers)) {, + return false;, + }, +, + return equals((Http2Headers) o, CASE_SENSITIVE_HASHER);, + }, +, + @Override, + public
[+++ b/all/pom.xml, + <version>4.1.17.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.17.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.17.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.17.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.17.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, + <version>4.1.17.Final-SNAPSHOT</version>, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/CompressorHttp2ConnectionEncoder.java, + PromiseCombiner combiner = new PromiseCombiner(ctx.executor());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/CompressorHttp2ConnectionEncoder.java, + PromiseCombiner combiner = new PromiseCombiner(ctx.executor());, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, + final PromiseCombiner combiner = new PromiseCombiner(ctx.executor());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/CompressorHttp2ConnectionEncoder.java, + PromiseCombiner combiner = new PromiseCombiner(ctx.executor());, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, + final PromiseCombiner combiner = new PromiseCombiner(ctx.executor());, +++ b/common/src/main/java/io/netty/util/concurrent/PromiseAggregator.java, + * @deprecated Use {@link PromiseCombiner#PromiseCombiner(EventExecutor)}., +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/CompressorHttp2ConnectionEncoder.java, + PromiseCombiner combiner = new PromiseCombiner(ctx.executor());, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, + final PromiseCombiner combiner = new PromiseCombiner(ctx.executor());, +++ b/common/src/main/java/io/netty/util/concurrent/PromiseAggregator.java, + * @deprecated Use {@link PromiseCombiner#PromiseCombiner(EventExecutor)}., +++ b/common/src/main/java/io/netty/util/concurrent/PromiseCombiner.java, + *, + * <p>This implementation is <strong>NOT</strong> thread-safe and all methods must be called, + * from the {@link EventExecutor} thread.</p>,
[+++ b/src/docbook/en-US/module/architecture.xml, + <imagedata fileref="images/architecture.png" format="PNG" scale="50" scalefit="1" align="center" />, + </mediaobject>, +]
[+++ b/pom.xml, + <version>3.2.1.Final-SNAPSHOT</version>, + <url>http://fisheye.jboss.org/browse/Netty</url>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, + if (sizeMinusOne >= 0) {, + }, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, + if (sizeMinusOne >= 0) {, + }, +++ b/codec/src/test/java/io/netty/handler/codec/MessageToMessageEncoderTest.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under
[+++ b/all/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/example/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha3</version>, +++ b/codec/pom.xml, +
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + * Decode a 2-digit hex byte from within a string., + */, + public static byte decodeHexByte(CharSequence s, int pos) {, + return HexUtil.decodeHexByte(s, pos);, + }, +, + /**, + * Decodes part of a string generated by {@link #hexDump(byte[])}, + */, + public static byte[] decodeHexDump(CharSequence hexDump, int fromIndex, int length) {, + return HexUtil.decodeHexDump(hexDump, fromIndex, length);, + }, +, + /**, + /**, + * Helper to decode half of a hexadecimal number from a string., + * @param c The ASCII character of the hexadecimal number to decode., + * Must be
[+++ b/transport/src/main/java/io/netty/channel/Channel.java, + * <li>the {@link ChannelPipeline} which handles all I/O events and requests, + * A {@link Channel} can have a {@linkplain #parent() parent} depending on, + * as its parent on {@link #parent()}., + /**, + * Returns {@code true} if the {@link Channel} is open an may get active later, + */, +, + /**, + * Returns {@code true} if the {@link Channel} is registered with an {@link EventLoop}., + */, +, + /**, + * Return {@code true} if the {@link Channel} is active and so connected., + */, +++ b/transport/src/main/java/io/netty/channel/Channel.java, + * <li>the
[+++ b/.gitignore, +/*.geany]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +, + // These are initialized on first use, + private IovArray iovArray;, + private NativeDatagramPacketArray datagramPacketArray;, + if (iovArray == null) {, + iovArray = new IovArray();, + } else {, + }, + if (datagramPacketArray == null) {, + datagramPacketArray = new NativeDatagramPacketArray();, + } else {, + }, + if (iovArray != null) {, + iovArray = null;, + }, + if (datagramPacketArray != null) {, + datagramPacketArray = null;, + }, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +, + // These are initialized on first use, + private IovArray iovArray;, + private NativeDatagramPacketArray datagramPacketArray;, + if (iovArray
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollRecvByteAllocatorHandle.java, + final boolean isReceivedRdHup() {, + return receivedRdHup;, + }, +, + // If EPOLLRDHUP has been received we must read until we get a read error., + return isEdgeTriggered && (lastBytesRead() > 0 || receivedRdHup);, + return maybeMoreDataToRead() && config.isAutoRead() || super.continueReading();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollRecvByteAllocatorHandle.java, + final boolean isReceivedRdHup() {, + return receivedRdHup;, + }, +, + // If EPOLLRDHUP has been received we must read until we get a read error., + return isEdgeTriggered && (lastBytesRead() > 0 || receivedRdHup);, + return maybeMoreDataToRead() && config.isAutoRead() || super.continueReading();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollRecvByteAllocatorStreamingHandle.java, + *, + * If EPOLLRDHUP has
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + emptyBuf = new EmptyByteBuf(this);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + emptyBuf = new EmptyByteBuf(this);, +++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, +/**, + * An empty {@link ByteBuf} whose capacity and maximum capacity are all {@code 0}., + */, + private static final ByteBuffer EMPTY_BYTE_BUFFER = ByteBuffer.allocateDirect(0);, + private static final long EMPTY_BYTE_BUFFER_ADDRESS;, + static {, + long emptyByteBufferAddress = 0;, + try {, + emptyByteBufferAddress = PlatformDependent.directBufferAddress(EMPTY_BYTE_BUFFER);, + } catch (Throwable t) {, + // Ignore, + }, + EMPTY_BYTE_BUFFER_ADDRESS = emptyByteBufferAddress;, + }, +, + private final ByteBufAllocator alloc;, + private final ByteOrder order;, + private final String str;, + private EmptyByteBuf
[+++ b/microbench/pom.xml, +++ b/microbench/pom.xml, +++ b/microbench/src/test/java/com/google/caliper/StandardVm.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF
[+++ b/example/src/main/java/io/netty/example/discard/DiscardClientHandler.java, + public void inboundBufferUpdated(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in), + // Server is supposed to send nothing, but if it sends something, discard it., + in.clear();, +++ b/example/src/main/java/io/netty/example/discard/DiscardClientHandler.java, + public void inboundBufferUpdated(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in), + // Server is supposed to send nothing, but if it sends something, discard it., + in.clear();, +++ b/example/src/main/java/io/netty/example/discard/DiscardServerHandler.java, +import io.netty.buffer.ChannelBuffer;, + public void inboundBufferUpdated(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in), + in.clear();]
[+++ b/codec/src/main/java/io/netty/handler/codec/base64/Base64.java, + for (; d < len2; e += 4) {, + d += 3;, +, + if (breakLines && lineLength == MAX_LINE_LENGTH, + // Only add NEW_LINE if we not ended directly on the MAX_LINE_LENGTH, + && d < len2) {, +++ b/codec/src/main/java/io/netty/handler/codec/base64/Base64.java, + for (; d < len2; e += 4) {, + d += 3;, +, + if (breakLines && lineLength == MAX_LINE_LENGTH, + // Only add NEW_LINE if we not ended directly on the MAX_LINE_LENGTH, + && d < len2) {, +++ b/codec/src/test/java/io/netty/handler/codec/base64/Base64Test.java, +/*, + * Copyright 2015 The Netty Project, + *, +
[+++ b/codec-xml/src/main/java/io/netty/handler/codec/xml/XmlDecoder.java, + private final AsyncXMLStreamReader<AsyncByteArrayFeeder> streamReader = XML_INPUT_FACTORY.createAsyncForByteArray();, +++ b/codec-xml/src/main/java/io/netty/handler/codec/xml/XmlDecoder.java, + private final AsyncXMLStreamReader<AsyncByteArrayFeeder> streamReader = XML_INPUT_FACTORY.createAsyncForByteArray();, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, + notifyListener0(this, (GenericFutureListener<?>) listeners);, + listeners = new DefaultFutureListeners((GenericFutureListener<?>) listeners, listener);, +++ b/codec-xml/src/main/java/io/netty/handler/codec/xml/XmlDecoder.java, + private final AsyncXMLStreamReader<AsyncByteArrayFeeder> streamReader = XML_INPUT_FACTORY.createAsyncForByteArray();, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, + notifyListener0(this, (GenericFutureListener<?>) listeners);, + listeners = new DefaultFutureListeners((GenericFutureListener<?>) listeners, listener);, +++ b/microbench/src/main/java/io/netty/microbench/headers/HeadersBenchmark.java, + private final Headers<CharSequence, CharSequence, ? extends Headers<?, ?, ?>> delegate;, + private SlowHeaders(Headers<CharSequence, CharSequence, ? extends Headers<?, ?, ?>> delegate) {, +++ b/codec-xml/src/main/java/io/netty/handler/codec/xml/XmlDecoder.java, + private final AsyncXMLStreamReader<AsyncByteArrayFeeder> streamReader = XML_INPUT_FACTORY.createAsyncForByteArray();, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, + notifyListener0(this, (GenericFutureListener<?>) listeners);, + listeners = new DefaultFutureListeners((GenericFutureListener<?>) listeners, listener);,
[+++ b/src/docbook/module/architecture.xml, + Netty provides a number of basic and advanced codecs built on top of, + its core to address most issues you will encounter when you write a]
[+++ b/handler-proxy/src/test/java/io/netty/handler/proxy/ProxyHandlerTest.java, +import io.netty.resolver.NoopAddressResolverGroup;, + b.resolver(NoopAddressResolverGroup.INSTANCE);, + b.resolver(NoopAddressResolverGroup.INSTANCE);, + b.resolver(NoopAddressResolverGroup.INSTANCE);, +++ b/handler-proxy/src/test/java/io/netty/handler/proxy/ProxyHandlerTest.java, +import io.netty.resolver.NoopAddressResolverGroup;, + b.resolver(NoopAddressResolverGroup.INSTANCE);, + b.resolver(NoopAddressResolverGroup.INSTANCE);, + b.resolver(NoopAddressResolverGroup.INSTANCE);, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsMessage.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/pom.xml, + <stylesheetResource>file:///${basedir}/src/docbook/xslt/xhtml.xsl</stylesheetResource>, + <stylesheetResource>file:///${basedir}/src/docbook/xslt/xhtml-single.xsl</stylesheetResource>, + <stylesheetResource>file:///${basedir}/src/docbook/xslt/eclipse.xsl</stylesheetResource>, + <stylesheetResource>file:///${basedir}/src/docbook/xslt/pdf.xsl</stylesheetResource>]
[+++ b/common/src/main/java/io/netty/util/NetworkConstants.java, + // We cache this because some machine takes almost forever to return, + // from InetAddress.getLocalHost(). I think it's due to the incorrect, + // /etc/hosts or /etc/resolve.conf., + logger.error("Failed to resolve localhost", e2);, + NetworkInterface loopbackIf;, + loopbackIf = NetworkInterface.getByInetAddress(LOCALHOST);, + loopbackIf = null;, + // If null is returned, iterate over all the available network interfaces., + if (loopbackIf == null) {, + for (Enumeration<NetworkInterface> e = NetworkInterface.getNetworkInterfaces();, + e.hasMoreElements();) {, + NetworkInterface nif = e.nextElement();, + if (nif.isLoopback()) {, + loopbackIf = nif;, + LOOPBACK_IF = loopbackIf;, +++ b/common/src/main/java/io/netty/util/NetworkConstants.java, + // We cache
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + final int maxCapacity = maxCapacity();, + final int writerIndex = writerIndex();, + if (!force || capacity() == maxCapacity) {, + capacity(maxCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + final int maxCapacity = maxCapacity();, + final int writerIndex = writerIndex();, + if (!force || capacity() == maxCapacity) {, + capacity(maxCapacity);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, + @Test, + public void ensureWritableWithForceDoesNotThrow() {, + ensureWritableDoesNotThrow(true);, + }, +, + @Test, + public void ensureWritableWithOutForceDoesNotThrow() {, + ensureWritableDoesNotThrow(false);, + }, +, + private void ensureWritableDoesNotThrow(boolean force) {, + final ByteBuf buffer = newBuffer(8);, + buffer.writerIndex(buffer.capacity());, + buffer.ensureWritable(8, force);, + buffer.release();, + }, +]
[+++ b/microbench/src/main/java/io/netty/microbench/http2/NoPriorityByteDistributionBenchmark.java, + private static final ChannelMetadata TEST_METADATA = new ChannelMetadata(false);, + return TEST_METADATA;, +++ b/microbench/src/main/java/io/netty/microbench/http2/NoPriorityByteDistributionBenchmark.java, + private static final ChannelMetadata TEST_METADATA = new ChannelMetadata(false);, + return TEST_METADATA;, +++ b/transport/src/main/java/io/netty/channel/AdaptiveRecvByteBufAllocator.java, + /**, + * @deprecated There is state for {@link #maxMessagesPerRead()} which is typically based upon channel type., + */, + @Deprecated, + public AdaptiveRecvByteBufAllocator() {, +++ b/microbench/src/main/java/io/netty/microbench/http2/NoPriorityByteDistributionBenchmark.java, + private static final ChannelMetadata TEST_METADATA = new ChannelMetadata(false);, + return TEST_METADATA;, +++ b/transport/src/main/java/io/netty/channel/AdaptiveRecvByteBufAllocator.java, + /**, + * @deprecated There is state for {@link #maxMessagesPerRead()} which is typically based upon channel type., + */, + @Deprecated, + public AdaptiveRecvByteBufAllocator() {, +++
[+++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java, +import io.netty.handler.codec.http.DefaultHttpResponse;, +import io.netty.handler.codec.http.HttpResponse;, + HttpResponse response = new DefaultHttpResponse(HTTP_1_1, OK);, + private static void setDateAndCacheHeaders(HttpResponse response, File fileToCache) {, + private static void setContentTypeHeader(HttpResponse response, File file) {]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import io.netty.util.internal.SystemPropertyUtil;, +import java.util.Locale;, + private static final String UNKNOWN = "unknown";, + String os = normalizeOs(SystemPropertyUtil.get("os.name", ""));, + String arch = normalizeArch(SystemPropertyUtil.get("os.arch", ""));, + String libName = "netty-tcnative-" + os + '-' + arch;, + try {, + // First, try loading the platform-specific library. Platform-specific, + // libraries will be available if using a tcnative uber jar., + NativeLibraryLoader.load(libName, SSL.class.getClassLoader());, + } catch (Throwable t) {, + // Either the uber jar isn't on classpath, or it doesn't contain a library, + // for this platform. Load the default library., + logger.debug("Unable to load platform-specific
[+++ b/transport/src/main/java/io/netty/channel/EventLoop.java, + * One {@link EventLoop} instance will usually handle more than one {@link Channel} but this may depend on]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockJZlibEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockJZlibEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockJZlibEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockJZlibEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaders.java, + String status = frame.headers().get(HttpNames.STATUS);, +]
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.CompositeByteBuf;, + public void testSimpleSendDirectByteBuf() throws Throwable {, + public void testSimpleSendDirectByteBuf(Bootstrap sb, Bootstrap cb) throws Throwable {, + testSimpleSend0(sb, cb, Unpooled.directBuffer());, + }, +, + @Test, + public void testSimpleSendHeapByteBuf() throws Throwable {, + run();, + }, +, + public void testSimpleSendHeapByteBuf(Bootstrap sb, Bootstrap cb) throws Throwable {, + testSimpleSend0(sb, cb, Unpooled.directBuffer());, + }, +, + @Test, + public void testSimpleSendCompositeDirectByteBuf() throws Throwable {, + run();, + }, +, + public void testSimpleSendCompositeDirectByteBuf(Bootstrap sb, Bootstrap cb) throws Throwable {, + CompositeByteBuf buf = Unpooled.compositeBuffer();, + buf.addComponent(Unpooled.directBuffer(2, 2));, + buf.addComponent(Unpooled.directBuffer(2, 2));, + testSimpleSend0(sb, cb,
[+++ b/all/pom.xml, +, + <!-- Disable animal sniffer -->, + <plugin>, + <groupId>org.codehaus.mojo</groupId>, + <artifactId>animal-sniffer-maven-plugin</artifactId>, + <executions>, + <execution>, + <id>default</id>, + <phase>none</phase>, + </execution>, + </executions>, + </plugin>, + <!-- Disable checkstyle -->, + <plugin>, + <artifactId>maven-checkstyle-plugin</artifactId>, + <executions>, + <execution>, + <id>check-style</id>, + <phase>none</phase>, + </execution>, + </executions>, + </plugin>, + <!-- Disable all plugin executions configured by jar packaging -->, + <plugin>, + <artifactId>maven-resources-plugin</artifactId>, + <version>2.5</version>, + <executions>, + <execution>, + <id>default-resources</id>, + <phase>none</phase>, + </execution>, + <execution>, + <id>default-testResources</id>, + <phase>none</phase>, + </execution>, + </executions>, + </plugin>, + <plugin>, + <artifactId>maven-compiler-plugin</artifactId>, + <executions>, + <execution>,
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java, + promise = new DefaultChannelPromise(channel);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java, + promise = new DefaultChannelPromise(channel);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, + private volatile Object listeners;, + if (listeners == null) {, + return;, + }, + notifyListenersWithStackOverFlowProtection();, + }, +, + private void notifyListenersWithStackOverFlowProtection() {, + * The logic in this method should be identical to {@link #notifyListenersWithStackOverFlowProtection()} but]
[+++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtMessageConnectorChannel.java, + if (messageSize == 0) {, + return true;, + }, + if (writtenBytes > 0 && writtenBytes != messageSize) {, + return writtenBytes > 0;]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import static io.netty.handler.ssl.SslUtils.PROTOCOL_SSL_V2;, +import static io.netty.handler.ssl.SslUtils.PROTOCOL_SSL_V2_HELLO;, +import static io.netty.handler.ssl.SslUtils.PROTOCOL_SSL_V3;, +import static io.netty.handler.ssl.SslUtils.PROTOCOL_TLS_V1;, +import static io.netty.handler.ssl.SslUtils.PROTOCOL_TLS_V1_1;, +import static io.netty.handler.ssl.SslUtils.PROTOCOL_TLS_V1_2;, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import static io.netty.handler.ssl.SslUtils.PROTOCOL_SSL_V2;, +import static io.netty.handler.ssl.SslUtils.PROTOCOL_SSL_V2_HELLO;, +import static io.netty.handler.ssl.SslUtils.PROTOCOL_SSL_V3;, +import static io.netty.handler.ssl.SslUtils.PROTOCOL_TLS_V1;, +import static io.netty.handler.ssl.SslUtils.PROTOCOL_TLS_V1_1;, +import static io.netty.handler.ssl.SslUtils.PROTOCOL_TLS_V1_2;, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import static io.netty.handler.ssl.SslUtils.PROTOCOL_SSL_V2;, +import static io.netty.handler.ssl.SslUtils.PROTOCOL_SSL_V2_HELLO;, +import static io.netty.handler.ssl.SslUtils.PROTOCOL_SSL_V3;, +import static io.netty.handler.ssl.SslUtils.PROTOCOL_TLS_V1;, +import static io.netty.handler.ssl.SslUtils.PROTOCOL_TLS_V1_1;, +import static io.netty.handler.ssl.SslUtils.PROTOCOL_TLS_V1_2;, + enabled.add(PROTOCOL_SSL_V2_HELLO);, + if (isProtocolEnabled(opts, SSL.SSL_OP_NO_TLSv1, PROTOCOL_TLS_V1)) {, + enabled.add(PROTOCOL_TLS_V1);, + if (isProtocolEnabled(opts, SSL.SSL_OP_NO_TLSv1_1, PROTOCOL_TLS_V1_1)) {, + enabled.add(PROTOCOL_TLS_V1_1);, + if (isProtocolEnabled(opts, SSL.SSL_OP_NO_TLSv1_2, PROTOCOL_TLS_V1_2)) {, + enabled.add(PROTOCOL_TLS_V1_2);, + if (isProtocolEnabled(opts, SSL.SSL_OP_NO_SSLv2, PROTOCOL_SSL_V2)) {, + enabled.add(PROTOCOL_SSL_V2);, + if (isProtocolEnabled(opts, SSL.SSL_OP_NO_SSLv3, PROTOCOL_SSL_V3))
[+++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +import io.netty.util.internal.PlatformDependent;, + if (PlatformDependent.javaVersion() < 7) {, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +import io.netty.util.internal.PlatformDependent;, + if (PlatformDependent.javaVersion() < 7) {, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +import io.netty.util.internal.PlatformDependent;, + PlatformDependent.freeDirectBuffer(chunk.memory);, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +import io.netty.util.internal.PlatformDependent;, + if (PlatformDependent.javaVersion() < 7) {, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +import io.netty.util.internal.PlatformDependent;, + PlatformDependent.freeDirectBuffer(chunk.memory);, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + final void init(PoolChunk<T> chunk, long handle, int offset, int length, int maxLength) {, + final void initUnpooled(PoolChunk<T> chunk, int length) {, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +import io.netty.util.internal.PlatformDependent;, + if (PlatformDependent.javaVersion() < 7) {, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +import io.netty.util.internal.PlatformDependent;, + PlatformDependent.freeDirectBuffer(chunk.memory);, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + final void init(PoolChunk<T> chunk, long handle, int offset, int length, int maxLength) {, +
[+++ b/all/pom.xml, + <version>4.1.26.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.26.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.26.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.26.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.26.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, + <version>4.1.26.Final-SNAPSHOT</version>, +
[+++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, + if (!addTaskWakesUp && wakesUpForTask(task)) {, + @SuppressWarnings("unused"), + protected boolean wakesUpForTask(Runnable task) {, + return true;, + }, +, +++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, + if (!addTaskWakesUp && wakesUpForTask(task)) {, + @SuppressWarnings("unused"), + protected boolean wakesUpForTask(Runnable task) {, + return true;, + }, +, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + Runnable task;, + if (flush) {, + task = WriteAndFlushTask.newInstance(next, msg, size, promise);, + } else {, + task = WriteTask.newInstance(next, msg, size, promise);, + }, + safeExecute(executor, task, promise, msg);, + abstract static class AbstractWriteTask implements Runnable {, + private final Recycler.Handle handle;, +, +, + private AbstractWriteTask(Recycler.Handle handle) {, +
[+++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, + public B localAddress(int inetPort) {, + return localAddress(new InetSocketAddress(inetPort));, + public B localAddress(String inetHost, int inetPort) {, + return localAddress(new InetSocketAddress(inetHost, inetPort));, + public B localAddress(InetAddress inetHost, int inetPort) {, + return localAddress(new InetSocketAddress(inetHost, inetPort));, +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, + public B localAddress(int inetPort) {, + return localAddress(new InetSocketAddress(inetPort));, + public B localAddress(String inetHost, int inetPort) {, + return localAddress(new InetSocketAddress(inetHost, inetPort));, + public B localAddress(InetAddress inetHost, int inetPort) {, + return localAddress(new InetSocketAddress(inetHost, inetPort));, +++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, + public Bootstrap remoteAddress(String inetHost, int inetPort) {, + remoteAddress = new InetSocketAddress(inetHost, inetPort);, + public Bootstrap remoteAddress(InetAddress inetHost, int inetPort)
[+++ b/all/pom.xml, +++ b/all/pom.xml, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + int componentId = toComponentIndex(index);, + int i = componentId;, + int componentId = toComponentIndex(index);, +, + int i = componentId;, + int componentId = toComponentIndex(index);, +, + int i = componentId;, + int componentId = toComponentIndex(index);, + int i = componentId;, + int componentId = toComponentIndex(index);, +++ b/all/pom.xml, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + int componentId = toComponentIndex(index);, + int i = componentId;, + int componentId = toComponentIndex(index);, +, + int i = componentId;, + int componentId = toComponentIndex(index);, +, + int i = componentId;, + int componentId = toComponentIndex(index);, + int i = componentId;,
[+++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java, + if (isKeepAlive(request)) {, + response.setHeader(CONNECTION, HttpHeaders.Values.KEEP_ALIVE);, + }, +++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java, + if (isKeepAlive(request)) {, + response.setHeader(CONNECTION, HttpHeaders.Values.KEEP_ALIVE);, + }, +++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java, +import io.netty.handler.codec.http.HttpHeaders;, + // Add keep alive header as per http://www.w3.org/Protocols/HTTP/1.1/draft-ietf-http-v11-spec-01.html#Connection, + response.setHeader(CONNECTION, HttpHeaders.Values.KEEP_ALIVE);]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + * messages. Any connection level events like {@link Http2SettingsFrame} and {@link Http2GoAwayFrame}, + * will be processed internally and also propagated down the pipeline for other handlers to act on., + Http2MultiplexCodec(Http2ConnectionEncoder encoder,, + Http2ConnectionDecoder decoder,, + Http2Settings initialSettings,, + // Allow other handlers to act on GOAWAY frame, + ctx.fireChannelRead(frame);, + // Allow other handlers to act on SETTINGS frame, + ctx.fireChannelRead(frame);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + * messages. Any connection level events like {@link Http2SettingsFrame} and {@link Http2GoAwayFrame}, + * will be processed internally and also propagated down the pipeline for other handlers to act on.,
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + connection.local().flowController(new DefaultHttp2LocalFlowController(connection));, + connection.local().flowController().frameWriter(encoder.frameWriter());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + connection.local().flowController(new DefaultHttp2LocalFlowController(connection));, + connection.local().flowController().frameWriter(encoder.frameWriter());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + return frameWriter.writePriority(ctx, streamId, streamDependency, weight, exclusive, promise);, + return frameWriter.writeSettings(ctx, settings, promise);, + return frameWriter.writeSettingsAck(ctx, promise);, + return frameWriter.writePing(ctx, ack, data, promise);, + return frameWriter.writePushPromise(ctx, streamId, promisedStreamId, headers, padding, promise);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + connection.local().flowController(new DefaultHttp2LocalFlowController(connection));, + connection.local().flowController().frameWriter(encoder.frameWriter());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + return frameWriter.writePriority(ctx, streamId, streamDependency, weight, exclusive, promise);, + return frameWriter.writeSettings(ctx, settings, promise);, + return frameWriter.writeSettingsAck(ctx, promise);, + return frameWriter.writePing(ctx, ack, data, promise);, + return frameWriter.writePushPromise(ctx, streamId, promisedStreamId, headers, padding, promise);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java, + private Http2FrameWriter frameWriter;, + public DefaultHttp2LocalFlowController(Http2Connection connection) {, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + checkSize(size);, + checkSize(size + localsize);, + checkSize(size);, + checkSize(written);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + checkSize(size);, + checkSize(size + localsize);, + checkSize(size);, + checkSize(written);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java, + protected long maxSize = DefaultHttpDataFactory.MAXSIZE;, + public void setMaxSize(long maxSize) {, + this.maxSize = maxSize;, + }, +, + public void checkSize(long newSize) throws IOException {, + if (maxSize >= 0 && newSize > maxSize) {, + throw new IOException("Size exceed allowed maximum capacity");, + }, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + checkSize(size);, + checkSize(size + localsize);, + checkSize(size);, + checkSize(written);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java, + protected long maxSize = DefaultHttpDataFactory.MAXSIZE;, + public void
[+++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, +import io.netty.util.concurrent.PromiseCombiner;, + ctx.write(out.getUnsafe(0), promise);, + if (promise == ctx.voidPromise()) {, + writeVoidPromise(ctx, out);, + writePromiseCombiner(ctx, out, promise);, + private static void writeVoidPromise(ChannelHandlerContext ctx, CodecOutputList out) {, + final ChannelPromise voidPromise = ctx.voidPromise();, + for (int i = 0; i < out.size(); i++) {, + ctx.write(out.getUnsafe(i), voidPromise);, + }, + }, +, + private static void writePromiseCombiner(ChannelHandlerContext ctx, CodecOutputList out, ChannelPromise promise) {, + final PromiseCombiner combiner = new PromiseCombiner();, + for (int i = 0; i < out.size(); i++) {, + combiner.add(ctx.write(out.getUnsafe(i)));, + }, + combiner.finish(promise);, + }, +, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, +import io.netty.util.concurrent.PromiseCombiner;, + ctx.write(out.getUnsafe(0), promise);,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, + ByteBuf headerBlock = spdyHeaderBlockEncoder.encode(ctx.alloc(), spdySynStreamFrame);, + ByteBuf headerBlock = spdyHeaderBlockEncoder.encode(ctx.alloc(), spdySynReplyFrame);, + ByteBuf headerBlock = spdyHeaderBlockEncoder.encode(ctx.alloc(), spdyHeadersFrame);, + spdyHeaderBlockDecoder.decode(ctx.alloc(), headerBlock, spdyHeadersFrame);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, + ByteBuf headerBlock = spdyHeaderBlockEncoder.encode(ctx.alloc(), spdySynStreamFrame);, + ByteBuf headerBlock = spdyHeaderBlockEncoder.encode(ctx.alloc(), spdySynReplyFrame);, + ByteBuf headerBlock = spdyHeaderBlockEncoder.encode(ctx.alloc(), spdyHeadersFrame);, + spdyHeaderBlockDecoder.decode(ctx.alloc(), headerBlock, spdyHeadersFrame);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockDecoder.java, +import io.netty.buffer.ByteBufAllocator;, + * @param alloc the {@link ByteBufAllocator} which can be used to allocate new {@link ByteBuf}s, + abstract void decode(ByteBufAllocator alloc, ByteBuf headerBlock, SpdyHeadersFrame frame) throws Exception;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, + ByteBuf headerBlock = spdyHeaderBlockEncoder.encode(ctx.alloc(), spdySynStreamFrame);, + ByteBuf headerBlock = spdyHeaderBlockEncoder.encode(ctx.alloc(), spdySynReplyFrame);, + ByteBuf headerBlock = spdyHeaderBlockEncoder.encode(ctx.alloc(), spdyHeadersFrame);,
[+++ b/common/src/main/java/io/netty/util/Attribute.java, + * Remove this attribute from the {@link AttributeMap}., +++ b/common/src/main/java/io/netty/util/Attribute.java, + * Remove this attribute from the {@link AttributeMap}., +++ b/common/src/main/java/io/netty/util/DefaultAttributeMap.java, + private final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {, + synchronized (DefaultAttributeMap.this) {, + map.remove(this);, + }]
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, +import io.netty.util.internal.PlatformDependent;, + // Find the first loopback interface available., + NetworkInterface loopbackIface = null;, + for (Enumeration<NetworkInterface> ifaces = NetworkInterface.getNetworkInterfaces();, + ifaces.hasMoreElements();) {, +, + NetworkInterface iface = ifaces.nextElement();, + if (iface.isLoopback()) {, + // Found, + loopbackIface = iface;, + break;, + }, + }, + if (loopbackIface == null) {, + logger.warn("Failed to find the loopback interface");, + }, + } catch (SocketException e) {, + logger.warn("Failed to find the loopback interface", e);, + }, +, + LOOPBACK_IF = loopbackIface;, +, + // Find the localhost address, + InetAddress localhost = null;, + if
[+++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, +import io.netty.channel.EventLoop;, +, + /**, + * Deregister all {@link Channel}s in this group from their {@link EventLoop}., + * Please note that this operation is asynchronous as {@link Channel#deregister()} is., + *, + * @return the {@link ChannelGroupFuture} instance that notifies when, + * the operation is done for all channels, + */, + ChannelGroupFuture deregister();, +++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, +import io.netty.channel.EventLoop;, +, + /**, + * Deregister all {@link Channel}s in this group from their {@link EventLoop}., + * Please note that this operation is asynchronous as {@link Channel#deregister()} is., + *, + * @return the {@link
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, + , + , + // Check if we exceeded the maximum size of 2gb if this is the case then , + // newCapacity == 0, + //, + // https://github.com/netty/netty/issues/258, + if (newCapacity == 0) {, + throw new IllegalStateException("Maximum size of 2gb exceeded");, + }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return
[+++ b/codec/src/main/java/io/netty/handler/codec/base64/Base64.java, + for (; d < len2; d += 3, e += 4) {, + if (breakLines && lineLength == MAX_LINE_LENGTH) {, + // Remove last byte if it's a newline, + if (e > 1 && dest.getByte(e - 1) == NEW_LINE) {, + e--;, + }, +, +++ b/codec/src/main/java/io/netty/handler/codec/base64/Base64.java, + for (; d < len2; d += 3, e += 4) {, + if (breakLines && lineLength == MAX_LINE_LENGTH) {, + // Remove last byte if it's a newline, + if (e > 1 && dest.getByte(e - 1) == NEW_LINE) {, + e--;, + }, +, +++
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +import io.netty.util.ResourceLeak;, +import io.netty.util.ResourceLeakDetector;, + protected static ByteBuf toLeakAwareBuffer(ByteBuf buf) {, + ResourceLeak leak;, + switch (ResourceLeakDetector.getLevel()) {, + case SIMPLE:, + leak = AbstractByteBuf.leakDetector.open(buf);, + if (leak != null) {, + buf = new SimpleLeakAwareByteBuf(buf, leak);, + }, + break;, + case ADVANCED:, + case PARANOID:, + leak = AbstractByteBuf.leakDetector.open(buf);, + if (leak != null) {, + buf = new AdvancedLeakAwareByteBuf(buf, leak);, + }, + break;, + }, + return buf;, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +import io.netty.util.ResourceLeak;, +import io.netty.util.ResourceLeakDetector;, + protected static ByteBuf toLeakAwareBuffer(ByteBuf buf) {, + ResourceLeak leak;, + switch (ResourceLeakDetector.getLevel()) {, + case
[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +++ b/common/src/main/java/io/netty/util/internal/SharedResourceMisuseDetector.java, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +++ b/common/src/main/java/io/netty/util/internal/SharedResourceMisuseDetector.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +++ b/common/src/main/java/io/netty/util/internal/SharedResourceMisuseDetector.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +++ b/common/src/main/java/io/netty/util/internal/SharedResourceMisuseDetector.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +++ b/common/src/main/java/io/netty/util/internal/SharedResourceMisuseDetector.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerSslContext.java, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +++ b/common/src/main/java/io/netty/util/internal/SharedResourceMisuseDetector.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerSslContext.java, +++ b/handler/src/main/java/io/netty/handler/ipfilter/CIDR6.java, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +++ b/common/src/main/java/io/netty/util/internal/SharedResourceMisuseDetector.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerSslContext.java, +++ b/handler/src/main/java/io/netty/handler/ipfilter/CIDR6.java, +++ b/handler/src/main/java/io/netty/handler/ipfilter/IpFilterRuleList.java, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +++ b/common/src/main/java/io/netty/util/internal/SharedResourceMisuseDetector.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerSslContext.java, +++ b/handler/src/main/java/io/netty/handler/ipfilter/CIDR6.java, +++ b/handler/src/main/java/io/netty/handler/ipfilter/IpFilterRuleList.java, +++ b/handler/src/main/java/io/netty/handler/ipfilter/PatternRule.java, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +++ b/common/src/main/java/io/netty/util/internal/SharedResourceMisuseDetector.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java, +++
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +public abstract class AbstractByteBuf extends ByteBuf {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +public abstract class AbstractByteBuf extends ByteBuf {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + return new CompositeByteBuf(this, false, maxNumComponents);, + return new CompositeByteBuf(this, true, maxNumComponents);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +public abstract class AbstractByteBuf extends ByteBuf {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + return new CompositeByteBuf(this, false, maxNumComponents);, + return new CompositeByteBuf(this, true, maxNumComponents);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +@SuppressWarnings("ClassMayBeInterface"), +public abstract class ByteBuf implements ReferenceCounted, Comparable<ByteBuf> {, + public abstract int capacity();, + public abstract ByteBuf capacity(int newCapacity);, + public abstract int maxCapacity();, + public abstract ByteBufAllocator alloc();, + public abstract ByteOrder order();, + public abstract ByteBuf order(ByteOrder endianness);, +
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + } catch (NoClassDefFoundError e) {, + // Also catch NoClassDefFoundError in case someone uses for example OSGI and it made, + // Unsafe unloadable., + return e;]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, + sessionContext = new OpenSslClientSessionContext(this);, + private OpenSslClientSessionContext(OpenSslContext context) {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, + sessionContext = new OpenSslClientSessionContext(this);, + private OpenSslClientSessionContext(OpenSslContext context) {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + // IMPORTANT: This method must only be called from either the constructor or the finalizer as a user MUST never, + // get access to an OpenSslSessionContext after this method was called to prevent the user from, + // producing a segfault., + final void destroy() {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, + sessionContext = new OpenSslClientSessionContext(this);, + private OpenSslClientSessionContext(OpenSslContext context) {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + // IMPORTANT: This method must only be called from either
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/ZlibCodecFactory.java, +import io.netty.util.internal.SystemPropertyUtil;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(ZlibCodecFactory.class);, +, + private static final boolean noJdkZlibDecoder;, +, + static {, + noJdkZlibDecoder = !SystemPropertyUtil.getBoolean("io.netty.noJdkZlibDecoder", true);, + logger.debug("-Dio.netty.noJdkZlibDecoder: {}", noJdkZlibDecoder);, + }, + if (PlatformDependent.javaVersion() < 7 || noJdkZlibDecoder) {, + if (PlatformDependent.javaVersion() < 7 || noJdkZlibDecoder) {, + if (PlatformDependent.javaVersion() < 7 || noJdkZlibDecoder) {]
[+++ b/buffer/src/test/java/io/netty/buffer/BigEndianUnsafeNoCleanerDirectByteBufTest.java, + Assume.assumeTrue("java.nio.DirectByteBuffer.<init>(long, int) not found, skip tests",, + PlatformDependent.useDirectBufferNoCleaner());, +++ b/buffer/src/test/java/io/netty/buffer/BigEndianUnsafeNoCleanerDirectByteBufTest.java, + Assume.assumeTrue("java.nio.DirectByteBuffer.<init>(long, int) not found, skip tests",, + PlatformDependent.useDirectBufferNoCleaner());, +++ b/buffer/src/test/java/io/netty/buffer/LittleEndianUnsafeNoCleanerDirectByteBufTest.java, + Assume.assumeTrue("java.nio.DirectByteBuffer.<init>(long, int) not found, skip tests",, + PlatformDependent.useDirectBufferNoCleaner());]
[+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java, + if (currentMessage != null && currentMessage.getExtras() != null) {]
[+++ b/pom.xml, + <tracker-code><![CDATA[, +<script type="text/javascript">, +var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");, +document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));, +</script>, +<script type="text/javascript">, +try {, +var pageTracker = _gat._getTracker("UA-95307-3");, +pageTracker._trackPageview();, +} catch(err) {}, +</script>, +]]></tracker-code>, + <footer>${tracker-code}</footer>, + <bottom><![CDATA[Copyright &copy; {inceptionYear}-{currentYear} ${project.organization.name} All Rights Reserved.]]> ${tracker-code}</bottom>]
[+++ /dev/null, +++ /dev/null, +++ b/example/src/main/java/io/netty/example/socksproxy/DirectClientHandler.java, +import io.netty.util.concurrent.Promise;, + private final Promise promise;, + public DirectClientHandler(Promise promise) {, + this.promise = promise;, + promise.setSuccess(ctx.channel());, + promise.setFailure(throwable);, +++ /dev/null, +++ b/example/src/main/java/io/netty/example/socksproxy/DirectClientHandler.java, +import io.netty.util.concurrent.Promise;, + private final Promise promise;, + public DirectClientHandler(Promise promise) {, + this.promise = promise;, + promise.setSuccess(ctx.channel());, + promise.setFailure(throwable);, +++ b/example/src/main/java/io/netty/example/socksproxy/DirectClientInitializer.java, +import io.netty.util.concurrent.Promise;, + private final Promise promise;, + public DirectClientInitializer(Promise promise) {, + this.promise = promise;, + channelPipeline.addLast(DirectClientHandler.getName(), new DirectClientHandler(promise));, +++ /dev/null, +++ b/example/src/main/java/io/netty/example/socksproxy/DirectClientHandler.java, +import io.netty.util.concurrent.Promise;, + private final Promise promise;, + public DirectClientHandler(Promise promise) {, + this.promise = promise;, + promise.setSuccess(ctx.channel());, + promise.setFailure(throwable);, +++ b/example/src/main/java/io/netty/example/socksproxy/DirectClientInitializer.java, +import
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + *]
[+++ b/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClientHandler.java, + out.add(message.retain());, +++ b/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClientHandler.java, + out.add(message.retain());, +++ b/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoServerHandler.java, + out.add(message.retain());, +++ b/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClientHandler.java, + out.add(message.retain());, +++ b/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoServerHandler.java, + out.add(message.retain());, +++ b/example/src/main/java/io/netty/example/udt/echo/rendevous/MsgEchoPeerHandler.java, + out.add(message.retain());]
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +#include <sys/utsname.h>, +JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_setReusePort(JNIEnv * env, jclass clazz, jint fd, jint optval) {, + setOption(env, fd, SOL_SOCKET, SO_REUSEPORT, &optval, sizeof(optval));, +}, +, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_isReusePort(JNIEnv *env, jclass clazz, jint fd) {, + int optval;, + if (getOption(env, fd, SOL_SOCKET, SO_REUSEPORT, &optval, sizeof(optval)) == -1) {, + return -1;, + }, + return optval;, +}, +, +, +JNIEXPORT jstring JNICALL Java_io_netty_channel_epoll_Native_kernelVersion(JNIEnv *env, jclass clazz) {, + struct utsname name;, +, + int res = uname(&name);, + if (res == 0) {, + return (*env)->NewStringUTF(env, name.release);, + }, + int err = errno;, + throwRuntimeException(env, exceptionMessage("Error
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/CompositeBufferGatheringWriteTest.java, +import io.netty.channel.ChannelFutureListener;, +import java.io.IOException;, + final AtomicReference<Object> clientReceived = new AtomicReference<Object>();, + public void channelActive(ChannelHandlerContext ctx) throws Exception {, + ctx.writeAndFlush(newCompositeBuffer(ctx.alloc())), + .addListener(ChannelFutureListener.CLOSE);, +, + @Override, + public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {, + // IOException is fine as it will also close the channel and may just be a connection reset., + if (!(cause instanceof IOException)) {, + clientReceived.set(cause);, + latch.countDown();, + }, + }, +, + @Override, + public void channelInactive(ChannelHandlerContext ctx) throws Exception {, + if (clientReceived.compareAndSet(null, aggregator)) {, + try {, + assertEquals(EXPECTED_BYTES, aggregator.readableBytes());, + } catch (Throwable cause) {,
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, + private final DnsCache authoritativeDnsServerCache;, + private final boolean supportsAAAARecords;, + private final boolean supportsARecords;, + * @deprecated use {@link DnsNameResolver#DnsNameResolver(EventLoop, ChannelFactory, DnsServerAddresses, DnsCache,, + * DnsCache, long, InternetProtocolFamily[], boolean, int, boolean, int, boolean,, + * HostsFileEntriesResolver, String[], int, boolean)}, + this(eventLoop, channelFactory, nameServerAddresses, resolveCache, NoopDnsCache.INSTANCE, queryTimeoutMillis,, + resolvedAddressTypes, recursionDesired, maxQueriesPerResolve, traceEnabled, maxPayloadSize,, + optResourceEnabled, hostsFileEntriesResolver, searchDomains, ndots, true);, + * @param authoritativeDnsServerCache the cache used to find the authoritative DNS server for a domain, + DnsCache authoritativeDnsServerCache,, + this.authoritativeDnsServerCache = checkNotNull(authoritativeDnsServerCache, "authoritativeDnsServerCache");, + boolean supportsARecords = false;, + boolean supportsAAAARecords = false;, + supportsARecords = true;,
[+++ b/testsuite-osgi/README.md, +, +parent for build constrains modules, +++ b/testsuite-osgi/README.md, +, +parent for build constrains modules, +++ /dev/null, +++ b/testsuite-osgi/README.md, +, +parent for build constrains modules, +++ /dev/null, +++ b/testsuite-osgi/testsuite-osgi-deps/README.md, +### info, +, +this module build will fail if any dependencies are not osgi bundles, +, +http://en.wikipedia.org/wiki/OSGi#Bundles, +, +on failure, build log will show error message similar to the following:, +(org.rxtx/rxtx/2.1.7 is not osgi bundle), +```, +-------------------------------------------------------, + T E S T S, +-------------------------------------------------------, +Running io.netty.verify.osgi.IT, +<?xml version="1.0" encoding="UTF-8" standalone="yes"?>, +<features xmlns="http://karaf.apache.org/xmlns/features/v1.2.0" name="netty-verify-osgi-deps">, + <feature name="netty-verify-osgi-deps" version="4.0.0.Beta1-SNAPSHOT" description="Netty/Verify/OSGi/Deps">, + <details>verify osgi compliance: all transitive dependencies are osgi bundles</details>, +
[+++ b/transport/src/main/java/io/netty/channel/socket/InternetProtocolFamily.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java, + ByteBuf buffer = alloc().heapBuffer(packetSize);, + tmpPacket.setData(buffer.array(), buffer.arrayOffset(), packetSize);, +, +, + DatagramPacket packet = new DatagramPacket(buffer.writerIndex(tmpPacket.getLength()), remoteAddr);]
[+++ b/pom.xml, + <version>1.2.2.Final</version>]
[+++ b/pom.xml, + <echo message="// DO NOT MODIFY - WILL BE OVERWRITTEN DURING THE BUILD PROCESS${line.separator}package org.jboss.netty.util;${line.separator}/**${line.separator} * Provides the version information of Netty.${line.separator} * @apiviz.landmark${line.separator} */${line.separator}public final class Version {${line.separator} /** The version identifier. */${line.separator} public static final String ID = &quot;${project.version}-r${buildNumber}&quot;;${line.separator} /** Prints out the version identifier to stdout. */${line.separator} public static void main(String[] args) { System.out.println(ID); }${line.separator} private Version() { super(); }${line.separator}}${line.separator}" file="${basedir}/src/main/java/org/jboss/netty/util/Version.java" />, +++ b/pom.xml, + <echo message="// DO NOT MODIFY - WILL BE OVERWRITTEN DURING THE BUILD PROCESS${line.separator}package org.jboss.netty.util;${line.separator}/**${line.separator} * Provides the version information of Netty.${line.separator} * @apiviz.landmark${line.separator} */${line.separator}public final class Version {${line.separator} /**
[+++ b/all/pom.xml, + <version>4.0.0.CR9</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR9</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR9</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR9</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR9</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR9</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR9</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR9</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR9</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR9</version>, +++ b/common/pom.xml, + <version>4.0.0.CR9</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR9</version>, +++ b/codec-socks/pom.xml, +
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + protected final void checkNewCapacity(int newCapacity) {, + ensureAccessible();, + if (newCapacity < 0 || newCapacity > maxCapacity()) {, + throw new IllegalArgumentException("newCapacity: " + newCapacity + " (expected: 0-" + maxCapacity() + ')');, + }, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + protected final void checkNewCapacity(int newCapacity) {, + ensureAccessible();, + if (newCapacity < 0 || newCapacity > maxCapacity()) {, + throw new IllegalArgumentException("newCapacity: " + newCapacity + " (expected: 0-" + maxCapacity() + ')');, + }, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + checkNewCapacity(newCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + protected final void checkNewCapacity(int newCapacity) {, + ensureAccessible();, + if
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + final int directMemoryCacheAlignment;, + final int directMemoryCacheAlignmentMask;, + protected PoolArena(PooledByteBufAllocator parent, int pageSize,, + int maxOrder, int pageShifts, int chunkSize, int cacheAlignment) {, + this.directMemoryCacheAlignment = cacheAlignment;, + this.directMemoryCacheAlignmentMask = cacheAlignment - 1;, +, + return directMemoryCacheAlignment == 0 ? reqCapacity : alignCapacity(reqCapacity);, + assert directMemoryCacheAlignment == 0 || (normalizedCapacity & directMemoryCacheAlignmentMask) == 0;, + if (directMemoryCacheAlignment > 0) {, + return alignCapacity(reqCapacity);, + }, +, + int alignCapacity(int reqCapacity) {, + int delta = reqCapacity & directMemoryCacheAlignmentMask;, + return delta == 0 ? reqCapacity : reqCapacity + directMemoryCacheAlignment - delta;, + }, +, + HeapArena(PooledByteBufAllocator
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + private final ByteBuffer[] singleSrcBuffer = new ByteBuffer[1];, + private final ByteBuffer[] singleDstBuffer = new ByteBuffer[1];, + // Throw required runtime exceptions, + private ByteBuffer[] singleSrcBuffer(ByteBuffer src) {, + singleSrcBuffer[0] = src;, + return singleSrcBuffer;, + }, +, + private void resetSingleSrcBuffer() {, + singleSrcBuffer[0] = null;, + }, +, + private ByteBuffer[] singleDstBuffer(ByteBuffer src) {, + singleDstBuffer[0] = src;, + return singleDstBuffer;, + }, +, + private void resetSingleDstBuffer() {, + singleDstBuffer[0] = null;, + }, +, + public synchronized SSLEngineResult unwrap(, + try {, + return unwrap(singleSrcBuffer(src), 0, 1, dsts, offset, length);, + } finally
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, +import io.netty.buffer.Unpooled;, + } else {, + // Need to produce some output otherwise an, + // IllegalstateException will be thrown, + out.add(Unpooled.EMPTY_BUFFER);, + } else {, + if (contentLength == 0) {, + // Need to produce some output otherwise an, + // IllegalstateException will be thrown, + out.add(Unpooled.EMPTY_BUFFER);, + }]
[+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java, +import io.netty.util.CharsetUtil;, + private final byte[] willMessage;, + private final byte[] password;, + /**, + * @deprecated use {@link MqttConnectPayload#MqttConnectPayload(String, String, byte[], String, byte[])} instead, + */, + @Deprecated, + this(, + clientIdentifier,, + willTopic,, + willMessage.getBytes(CharsetUtil.UTF_8),, + userName,, + password.getBytes(CharsetUtil.UTF_8));, + }, +, + public MqttConnectPayload(, + String clientIdentifier,, + String willTopic,, + byte[] willMessage,, + String userName,, + byte[] password) {, + /**, + * @deprecated use {@link MqttConnectPayload#willMessageInBytes()} instead, + */, + @Deprecated, + return new String(willMessage, CharsetUtil.UTF_8);, + }, +, + public byte[] willMessageInBytes() {, + /**, + * @deprecated use {@link MqttConnectPayload#passwordInBytes()}
[+++ b/src/docbook/en-US/module/preface.xml]
[+++ b/handler/src/main/java/io/netty/handler/flush/FlushConsolidationHandler.java, + * If {@code explicitFlushAfterFlushes} is reached the flush will be forwarded as well (whether while in a read loop, or, + * while batching outside of a read loop)., + * The default number of flushes after which a flush will be forwarded to downstream handlers (whether while in a, + * read loop, or while batching outside of a read loop)., + */, + public static final int DEFAULT_EXPLICIT_FLUSH_AFTER_FLUSHES = 256;, +, + /**, + * Create new instance which explicit flush after {@value DEFAULT_EXPLICIT_FLUSH_AFTER_FLUSHES} pending flush, + * operations at the latest., + this(DEFAULT_EXPLICIT_FLUSH_AFTER_FLUSHES, false);]
[+++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffers.java, + * Create a {@link ChannelBuffer} that holds all the given values as int's, + * , + */, + public static ChannelBuffer wrapInt(int... values) {, + if (values == null || values.length == 0) {, + return EMPTY_BUFFER;, + }, + ChannelBuffer buffer = buffer(values.length * 4);, + for (int v: values) {, + buffer.writeInt(v);, + }, + return buffer;, + }, + , + /**, + * Create a {@link ChannelBuffer} that holds all the given values as short's, + * , + */, + public static ChannelBuffer wrapShort(int... values) {, + if (values ==
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + flags |= FLAG_FREED | FLAG_FREED_INBOUND | FLAG_FREED_OUTBOUND;, + freeNextInboundBridgeFeeder();, + freeNextOutboundBridgeFeeder();, + private void freeNextInboundBridgeFeeder() {, + private void freeNextOutboundBridgeFeeder() {, + void freeInbound() {, + freeInbound0();, + freeInbound0();, + private void freeInbound0() {, + flags |= FLAG_FREED_INBOUND;, + freeNextInboundBridgeFeeder();, + nextCtx.freeInbound();, + findContextOutbound().freeOutbound();, + /** Invocation initiated by {@link #freeInbound0()} after freeing all inbound buffers. */, + private void freeOutbound() {, + freeOutbound0();, + freeOutbound0();, + freeOutbound0();, + freeOutbound0();, + private void freeOutbound0() {, + flags |= FLAG_FREED_OUTBOUND;, + freeNextOutboundBridgeFeeder();, + findContextOutbound().freeOutbound();, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + flags |= FLAG_FREED | FLAG_FREED_INBOUND | FLAG_FREED_OUTBOUND;, + freeNextInboundBridgeFeeder();, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DefaultHttpDataFactory.java, +import io.netty.util.internal.PlatformDependent;, +import java.util.concurrent.ConcurrentMap;, + private final ConcurrentMap<HttpRequest, List<HttpData>> requestFileDeleteMap =, + PlatformDependent.newConcurrentHashMap();, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DefaultHttpDataFactory.java, +import io.netty.util.internal.PlatformDependent;, +import java.util.concurrent.ConcurrentMap;, + private final ConcurrentMap<HttpRequest, List<HttpData>> requestFileDeleteMap =, + PlatformDependent.newConcurrentHashMap();, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java, +import io.netty.util.internal.PlatformDependent;, +, + private final Map<Integer, StreamState> activeStreams = PlatformDependent.newConcurrentHashMap();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DefaultHttpDataFactory.java, +import io.netty.util.internal.PlatformDependent;, +import java.util.concurrent.ConcurrentMap;, + private final ConcurrentMap<HttpRequest, List<HttpData>> requestFileDeleteMap =, + PlatformDependent.newConcurrentHashMap();, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java, +import io.netty.util.internal.PlatformDependent;, +, + private final Map<Integer, StreamState> activeStreams = PlatformDependent.newConcurrentHashMap();, +++ b/codec/src/main/java/io/netty/handler/codec/serialization/ClassResolvers.java, +import io.netty.util.internal.PlatformDependent;, +, + new WeakReferenceMap<String, Class<?>>(, + PlatformDependent.<String, Reference<Class<?>>>newConcurrentHashMap()));, + new SoftReferenceMap<String, Class<?>>(, + PlatformDependent.<String, Reference<Class<?>>>newConcurrentHashMap()));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DefaultHttpDataFactory.java, +import io.netty.util.internal.PlatformDependent;, +import java.util.concurrent.ConcurrentMap;,
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + return PooledHeapByteBuf.newInstance(maxCapacity);, + return PooledUnsafeDirectByteBuf.newInstance(maxCapacity);, + return PooledDirectByteBuf.newInstance(maxCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + return PooledHeapByteBuf.newInstance(maxCapacity);, + return PooledUnsafeDirectByteBuf.newInstance(maxCapacity);, + return PooledDirectByteBuf.newInstance(maxCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, +import io.netty.util.Recycler;, +import io.netty.util.ResourceLeakDetector;, + private final Recycler.Handle recyclerHandle;, + protected PooledByteBuf(Recycler.Handle recyclerHandle, int maxCapacity) {, + this.recyclerHandle = recyclerHandle;, + if (ResourceLeakDetector.ENABLED) {, + } else {, + recycle();, + }, +, + @SuppressWarnings("unchecked"), + private void recycle() {, + Recycler.Handle recyclerHandle = this.recyclerHandle;, + if (recyclerHandle != null) {, + setRefCnt(1);, + ((Recycler<Object>) recycler()).recycle(this, recyclerHandle);, + }, + }, +, + protected abstract Recycler<?> recycler();, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + return PooledHeapByteBuf.newInstance(maxCapacity);, + return PooledUnsafeDirectByteBuf.newInstance(maxCapacity);,
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, +, + loop: while (true) {, + if (!buffer.isReadable()) {, + return (lineBuf.length() > 0) ? lineBuf.toString() : null;, + int c = buffer.readUnsignedByte();, + switch (c) {, + case '\n':, + break loop;, + case '\r':, + if (buffer.isReadable() && buffer.getUnsignedByte(buffer.readerIndex()) == '\n') {, + buffer.skipBytes(1);, + }, + break loop;, +, + default:, + lineBuf.append((char) c);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, +, + loop: while (true) {, + if (!buffer.isReadable()) {, + return (lineBuf.length() > 0) ? lineBuf.toString() : null;, + int c = buffer.readUnsignedByte();, + switch (c) {, + case '\n':, + break loop;, + case '\r':,
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Lz4FrameEncoder.java, + compressor.compress(buffer.internalNioBuffer(buffer.readerIndex(), flushableBytes), outNioBuffer);]
[+++ b/handler/src/main/java/io/netty/handler/ssl/CipherSuiteConverter.java, + // This may happen if this method is queried when OpenSSL doesn't yet have a cipher setup. It will return, + // "(NONE)" in this case., + if (p2j == null) {, + return null;, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/CipherSuiteConverter.java, + // This may happen if this method is queried when OpenSSL doesn't yet have a cipher setup. It will return, + // "(NONE)" in this case., + if (p2j == null) {, + return null;, + }, +++ b/handler/src/test/java/io/netty/handler/ssl/CipherSuiteConverterTest.java, +import static org.hamcrest.Matchers.is;, +import static org.hamcrest.Matchers.sameInstance;, +import static org.junit.Assert.assertNull;, +import static org.junit.Assert.assertThat;, + @Test, + public void
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + private boolean needRead = true;, + try {, + } finally {, + needRead = out.isEmpty();, + }, + @Override, + public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {, + boolean needRead = this.needRead;, + this.needRead = true;, +, + try {, + ctx.fireChannelReadComplete();, + } finally {, + if (needRead && !ctx.channel().config().isAutoRead()) {, + ctx.read();, + }, + }, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + private boolean needRead = true;, + try {, + } finally {, + needRead = out.isEmpty();, + }, + @Override, + public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {, + boolean needRead
[+++ b/pom.xml, + <repositories>, + <repository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </repository>, + </repositories>, +, + <pluginRepositories>, + <pluginRepository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </pluginRepository>, + </pluginRepositories>, +, +++ b/pom.xml, + <repositories>, + <repository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </repository>, + </repositories>, +, + <pluginRepositories>, + <pluginRepository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </pluginRepository>, + </pluginRepositories>, +, +++ b/src/main/java/org/jboss/netty/channel/socket/sctp/DefaultNioSctpChannelConfig.java, +/*, + * Copyright 2009 Red Hat, Inc., + *, + * Red Hat licenses this file to you under the Apache License, version 2.0, + * (the "License"); you may not use this file except in compliance with the, +
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + if (next != null && !next.isInboundBufferFreed()) {, + if (handler instanceof ChannelInboundByteHandler && !isInboundBufferFreed()) {, + if (prev.isOutboundBufferFreed()) {, + promise.setFailure(new ChannelPipelineException(, + "Unable to flush as outbound buffer of next handler was freed already"));, + return;, + }, + if (isOutboundBufferFreed()) {, + promise.setFailure(new ChannelPipelineException(, + "Unable to write as outbound buffer of next handler was freed already"));, + return;, + }, + private boolean isInboundBufferFreed() {, + if (hasInboundByteBuffer()) {, + return inboundByteBuffer().isFreed();, + }, + if (hasInboundMessageBuffer()) {, + return inboundMessageBuffer().isFreed();, + }, + return false;, + }, +, + private boolean isOutboundBufferFreed()
[+++ b/codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java, +import java.nio.ByteOrder;, +import java.util.List;, +, + private void discardingTooLongFrame(ByteBuf in) {, + private static void failOnNegativeLengthField(ByteBuf in, long frameLength, int lengthFieldEndOffset) {, + private static void failOnFrameLengthLessThanLengthFieldEndOffset(ByteBuf in,, + long frameLength,, + int lengthFieldEndOffset) {, + private void exceededFrameLength(ByteBuf in, long frameLength) {, + }, +, + private static void failOnFrameLengthLessThanInitialBytesToStrip(ByteBuf in,, + long frameLength,, + int initialBytesToStrip) {, + in.skipBytes((int) frameLength);, + throw new CorruptedFrameException(, + "Adjusted frame length (" + frameLength + ") is less " +, + "than initialBytesToStrip: " + initialBytesToStrip);, + }, +, + /**, + * Create a frame out of
[+++ b/src/docbook/en-US/master.xml, + <title>The Netty Project 3.2 User Guide</title>]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java]
[+++ b/NOTICE.txt, +Copyright 2011 The Netty Project, +The Netty Project licenses this file to you under the Apache License,, +version 2.0 (the "License"); you may not use this file except in compliance, +with the License. You may obtain a copy of the License at:, +Unless required by applicable law or agreed to in writing, software, +distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, +WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, +License for the specific language governing permissions and limitations, +under the License., +++ b/NOTICE.txt, +Copyright 2011 The Netty Project, +The
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java, +import static io.netty.util.ReferenceCountUtil.release;, + release(request);, + release(request);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java, +import static io.netty.util.ReferenceCountUtil.release;, + release(request);, + release(request);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsHandlerTest.java, + @Test, + public void preflightRequestShouldReleaseRequest() {, + final CorsConfig config = CorsConfig.withOrigin("http://localhost:8888"), + .preflightResponseHeader("CustomHeader", Arrays.asList("value1", "value2")), + .build();, + final EmbeddedChannel channel = new EmbeddedChannel(new CorsHandler(config));, + final FullHttpRequest request = optionsRequest("http://localhost:8888", "content-type, xheader1");, + channel.writeInbound(request);, + assertThat(request.refCnt(), is(0));, + }, +, + @Test, + public void forbiddenShouldReleaseRequest() {, + final CorsConfig config = CorsConfig.withOrigin("https://localhost").shortCurcuit().build();, + final EmbeddedChannel channel = new EmbeddedChannel(new CorsHandler(config), new EchoHandler());, + final FullHttpRequest request = createHttpRequest(GET);, + request.headers().set(ORIGIN, "http://localhost:8888");, + channel.writeInbound(request);, + assertThat(request.refCnt(),
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + if (length == 0) {, + return true;, + }, + int remainingBytes = length & 7;, +, + if (remainingBytes >= 4) {, + remainingBytes -= 4;, + if (UNSAFE.getInt(bytes1, baseOffset1 + remainingBytes) !=, + UNSAFE.getInt(bytes2, baseOffset2 + remainingBytes)) {, + return false;, + if (remainingBytes >= 2) {, + return UNSAFE.getChar(bytes1, baseOffset1) == UNSAFE.getChar(bytes2, baseOffset2) &&, + (remainingBytes == 2 || bytes1[startPos1 + 2] == bytes2[startPos2 + 2]);, + }, + return bytes1[startPos1] == bytes2[startPos2];, + }, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + if (length == 0) {, + return true;, + }, + int remainingBytes =
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + protected AbstractByteBufAllocator() {, + this(false);, + protected AbstractByteBufAllocator(boolean directByDefault) {, + return heapBuffer(256, Integer.MAX_VALUE);, + return heapBuffer(initialCapacity, Integer.MAX_VALUE);, + return directBuffer(256, Integer.MAX_VALUE);, + return directBuffer(initialCapacity, Integer.MAX_VALUE);, + private static void validate(int initialCapacity, int maxCapacity) {, + if (initialCapacity < 0) {, + throw new IllegalArgumentException("initialCapacity: " + initialCapacity + " (expectd: 0+)");, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + protected AbstractByteBufAllocator() {, + this(false);, + protected AbstractByteBufAllocator(boolean directByDefault) {, + return heapBuffer(256, Integer.MAX_VALUE);, + return heapBuffer(initialCapacity, Integer.MAX_VALUE);, + return directBuffer(256, Integer.MAX_VALUE);, + return directBuffer(initialCapacity, Integer.MAX_VALUE);, + private static void validate(int initialCapacity, int maxCapacity) {, + if (initialCapacity < 0) {,
[+++ b/buffer/src/test/java/io/netty/buffer/ByteBufUtilTest.java, + // Even though we choose random values...make sure they are not equal., + final int copyLength = length - 1;, + final int end = iB1 + copyLength;, + boolean foundDiff = false;, + for (int i = iB1, j = iB2; i < end; ++i, ++j) {, + if (b1[i] != b2[j]) {, + foundDiff = true;, + break;, + }, + }, + if (!foundDiff) {, + ++b1[iB1];, + }, + System.arraycopy(b1, iB1, b2, iB2, copyLength);]
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannelConfig.java, +import java.net.InetAddress;, +import java.net.SocketException;, +import java.util.Enumeration;, + private static final Object IP_MULTICAST_TTL;, + private static final Object IP_MULTICAST_LOOP;, + Object ipMulticastTtl = null;, + Object ipMulticastLoop = null;, + ipMulticastIf = Class.forName("java.net.StandardSocketOptions", true, classLoader).getDeclaredField("IP_MULTICAST_TTL").get(null);, + } catch (Exception e) {, + throw new Error("cannot locate the IP_MULTICAST_TTL field", e);, + }, +, + try {, + ipMulticastIf = Class.forName("java.net.StandardSocketOptions", true, classLoader).getDeclaredField("IP_MULTICAST_LOOP").get(null);, + } catch (Exception e) {, + throw new Error("cannot locate the IP_MULTICAST_LOOP field", e);, + }, +, + try {, + IP_MULTICAST_TTL = ipMulticastTtl;, + IP_MULTICAST_LOOP = ipMulticastLoop;, + public int getTimeToLive() {, + return
[+++ b/src/docbook/module/architecture.xml, + the complexity of the NIO Selector API, hindering rapid development., + Netty has a universal asynchronous I/O interface called &Channel;, + &Channel; abstracts away all operations required to point-to-point, + communication. That is, once you wrote your application on one Netty, + transport, your application can run on other Netty transports. Netty, + provides a number of essential transports via one universal API:, + (See <literal>org.jboss.netty.channel.socket.nio</literal>),, + (See <literal>org.jboss.netty.channel.socket.oio</literal>),, + Local transport (See <literal>org.jboss.netty.channel.local</literal>)., + Switching from one transport from the other usually takes just a couple, + lines of changes such as choosing a different
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, + private final long maxFrameSize;, + public WebSocket00FrameDecoder(long maxFrameSize) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, + private final long maxFrameSize;, + public WebSocket00FrameDecoder(long maxFrameSize) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, + private final long maxFramePayloadLength;, + * @param maxFramePayloadLength, + * Maximum length of a frame's payload. Setting this to an appropriate value for you application, + * helps check for denial of services attacks., + public WebSocket08FrameDecoder(boolean maskedPayload, boolean allowExtensions, long maxFramePayloadLength) {, + this.maxFramePayloadLength = maxFramePayloadLength;, + if (framePayloadLength > maxFramePayloadLength) {, + protocolViolation(ctx, "Max frame length of " + maxFramePayloadLength + " has been exceeded.");, + return null;, + },
[+++ b/NOTICE.txt, +This product contains a modified portion of 'Apache Harmony', an open source, +Java SE, which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.harmony.txt (Apache License 2.0), + * HOMEPAGE:, + * http://archive.apache.org/dist/harmony/, +, +, +++ b/NOTICE.txt, +This product contains a modified portion of 'Apache Harmony', an open source, +Java SE, which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.harmony.txt (Apache License 2.0), + * HOMEPAGE:, + * http://archive.apache.org/dist/harmony/, +, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, +import io.netty.handler.codec.AsciiString;, +import io.netty.handler.codec.DefaultTextHeaders;, +import io.netty.handler.codec.TextHeaders;, + private final TextHeaders headers;, + headers = validate? new ValidatingTextHeaders() : new
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + private static final String IGNORABLE_ERROR_PREFIX = "error:00000000:";, + static boolean isError(String error) {, + return error != null && !error.startsWith(IGNORABLE_ERROR_PREFIX);, + }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + private static final String IGNORABLE_ERROR_PREFIX = "error:00000000:";, + static boolean isError(String error) {, + return error != null && !error.startsWith(IGNORABLE_ERROR_PREFIX);, + }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance,
[+++ b/all/pom.xml, + <artifactId>maven-clean-plugin</artifactId>, + <version>2.5</version>, + <executions>, + <execution>, + <id>clean-all</id>, + <phase>generate-resources</phase>, + <goals>, + <goal>clean</goal>, + </goals>, + <configuration>, + <filesets>, + <fileset>, + <directory>${project.basedir}/src</directory>, + <followSymlinks>false</followSymlinks>, + <useDefaultExcludes>false</useDefaultExcludes>, + </fileset>, + <fileset>, + <directory>${project.basedir}/target</directory>, + <followSymlinks>false</followSymlinks>, + </fileset>, + </filesets>, + </configuration>, + </execution>, + </executions>, + </plugin>, + <plugin>, +]
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + CompositeByteBuf buf = freeLater(compositeBuffer(Integer.MAX_VALUE));]
[+++ b/pom.xml, + <conscrypt.version>1.3.0</conscrypt.version>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ComposedLastHttpContent.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/resolver/src/main/java/io/netty/resolver/DefaultHostsFileEntriesResolver.java, +import io.netty.util.CharsetUtil;, +import io.netty.util.internal.PlatformDependent;, +import java.nio.charset.Charset;, + this(parseEntries());, +, + private static HostsFileEntries parseEntries() {, + if (PlatformDependent.isWindows()) {, + // Ony windows there seems to be no standard for the encoding used for the hosts file, so let us, + // try multiple until we either were able to parse it or there is none left and so we return an, + // empty intstance., + return HostsFileParser.parseSilently(Charset.defaultCharset(), CharsetUtil.UTF_16, CharsetUtil.UTF_8);, + }, + return HostsFileParser.parseSilently();, + }, +++ b/resolver/src/main/java/io/netty/resolver/DefaultHostsFileEntriesResolver.java, +import io.netty.util.CharsetUtil;, +import io.netty.util.internal.PlatformDependent;, +import java.nio.charset.Charset;, + this(parseEntries());, +, + private static HostsFileEntries parseEntries() {, + if
[+++ b/pom.xml]
[+++ b/pom.xml, + <version>3.1.1.GA-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, + return ((ByteBuffer) memory.duplicate().position(index).limit(index + length)).slice();, +++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, + return ((ByteBuffer) memory.duplicate().position(index).limit(index + length)).slice();, +++ b/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java, + ByteBuffer buf = ByteBuffer.wrap(memory, index, length);, + return buf.slice();, +++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, + return ((ByteBuffer) memory.duplicate().position(index).limit(index + length)).slice();, +++ b/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java, + ByteBuffer buf = ByteBuffer.wrap(memory, index, length);, + return buf.slice();, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, + return ((ByteBuffer) memory.duplicate().position(index).limit(index + length)).slice();, +++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, + return ((ByteBuffer) memory.duplicate().position(index).limit(index + length)).slice();, +++ b/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java, + ByteBuffer buf = ByteBuffer.wrap(memory, index, length);, + return buf.slice();, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, + return ((ByteBuffer) memory.duplicate().position(index).limit(index + length)).slice();, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + return ((ByteBuffer) buffer.duplicate().position(index).limit(index + length)).slice();, +++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, + return ((ByteBuffer) memory.duplicate().position(index).limit(index +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, + if (!websocketPath.equals(req.uri())) {, + ctx.fireChannelRead(msg);, + return;, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, + if (!websocketPath.equals(req.uri())) {, + ctx.fireChannelRead(msg);, + return;, + }, +, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketFrameHandler.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in
[+++ b/all/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/example/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec/pom.xml, +
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + // handler was removed in the loop so now copy over all remaining messages, + out.add(msgs, i, size - i);, + return;, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + // handler was removed in the loop so now copy over all remaining messages, + out.add(msgs, i, size - i);, + return;, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, + // handler was removed in the loop so now copy over all remaining messages, + if (ctx.isRemoved()) {, + if (buf != null && buf.isReadable()) {, + out.add(buf);, + }, + out.add(msgs, i, size - i);, + break;, + }, + if (acceptOutboundMessage(m)) {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java,
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + private volatile Runnable flushTask;, + // Override this to signal it will never throw an exception., + @Override, + public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {, + ctx.fireExceptionCaught(cause);, + }, +, + // Override this to signal it will never throw an exception., + @Override, + public void flush(ChannelHandlerContext ctx) {, + ctx.flush();, + }, +, + void flushFromStreamChannel() {, + EventExecutor executor = ctx.executor();, + if (executor.inEventLoop()) {, + flush(ctx);, + } else {, + Runnable task = flushTask;, + if (task == null) {, + task = flushTask = new Runnable() {, + @Override,
[+++ b/common/src/main/java/io/netty/util/internal/DetectionUtil.java, +import java.net.InetSocketAddress;, +import java.net.ServerSocket;, + private static final boolean IS_ROOT;, +, + boolean root = false;, + if (!IS_WINDOWS) {, + for (int i = 1023; i > 0; i --) {, + ServerSocket ss = null;, + try {, + ss = new ServerSocket();, + ss.setReuseAddress(true);, + ss.bind(new InetSocketAddress(i));, + root = true;, + break;, + } catch (Exception e) {, + // Failed to bind., + // Check the error message so that we don't always need to bind 1023 times., + String message = e.getMessage();, + if (message == null) {, + message =
[+++ b/pom.xml, + <version>3.1.5.GA</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.1.5.GA</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.1.5.GA</developerConnection>]
[+++ b/all/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, + <dependencies>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-build</artifactId>, + <version>10</version>, + </dependency>, + </dependencies>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, + <dependencies>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-build</artifactId>, + <version>10</version>, + </dependency>, + </dependencies>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, + <dependencies>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-build</artifactId>, + <version>10</version>, + </dependency>, + </dependencies>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + if (index < 0) {, + throw new IndexOutOfBoundsException("index must be >= 0");, + }, + if (length == 0) {, + return;, + }, + int i = toComponentIndex(index);, +, + if (index
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + ByteBuf buf = alloc().buffer(length, maxCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + ByteBuf buf = alloc().buffer(length, maxCapacity);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, + actualValue.release();, + @Test, + public void testReadBytes() {, + ByteBuf buffer = newBuffer(8);, + byte[] bytes = new byte[8];, + buffer.writeBytes(bytes);, +, + ByteBuf buffer2 = buffer.readBytes(4);, + assertSame(buffer.alloc(), buffer2.alloc());, + assertEquals(4, buffer.readerIndex());, + assertTrue(buffer.release());, + assertEquals(0, buffer.refCnt());, + assertTrue(buffer2.release());, + assertEquals(0, buffer2.refCnt());, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + ByteBuf buf = alloc().buffer(length, maxCapacity);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, + actualValue.release();, + @Test, + public void testReadBytes() {, + ByteBuf buffer = newBuffer(8);, + byte[] bytes = new byte[8];, + buffer.writeBytes(bytes);, +, +
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java, +import io.netty.util.DefaultAttributeMap;, +abstract class AbstractChannelHandlerContext extends DefaultAttributeMap, + implements ChannelHandlerContext, ResourceLeakHint {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java, +import io.netty.util.DefaultAttributeMap;, +abstract class AbstractChannelHandlerContext extends DefaultAttributeMap, + implements ChannelHandlerContext, ResourceLeakHint {, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, +import io.netty.util.Attribute;, + /**, + * @deprecated Use {@link Channel#attr(AttributeKey)}, + */, + @Deprecated, + @Override, + <T> Attribute<T> attr(AttributeKey<T> key);, +, + /**, + * @deprecated Use {@link Channel#hasAttr(AttributeKey)}, + */, + @Deprecated, + @Override, + <T> boolean hasAttr(AttributeKey<T> key);, +]
[+++ b/all/pom.xml, + <version>4.1.11.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.11.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.11.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.11.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.11.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, + <version>4.1.11.Final-SNAPSHOT</version>, +
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + private static final byte WRITE_UTF_UNKNOWN = (byte) '?';, + buffer._setByte(writerIndex++, WRITE_UTF_UNKNOWN);, + continue;, + buffer._setByte(writerIndex++, WRITE_UTF_UNKNOWN);, + break;, + buffer._setByte(writerIndex++, WRITE_UTF_UNKNOWN);, + buffer._setByte(writerIndex++, Character.isHighSurrogate(c2) ? WRITE_UTF_UNKNOWN : c2);, + continue;, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + private static final byte WRITE_UTF_UNKNOWN = (byte) '?';, + buffer._setByte(writerIndex++, WRITE_UTF_UNKNOWN);, + continue;, + buffer._setByte(writerIndex++, WRITE_UTF_UNKNOWN);, + break;, + buffer._setByte(writerIndex++, WRITE_UTF_UNKNOWN);, + buffer._setByte(writerIndex++, Character.isHighSurrogate(c2) ? WRITE_UTF_UNKNOWN : c2);, + continue;, +++ b/buffer/src/test/java/io/netty/buffer/ByteBufUtilTest.java, +import static io.netty.buffer.Unpooled.unreleasableBuffer;, +import static io.netty.util.ReferenceCountUtil.releaseLater;, +import static org.junit.Assert.assertEquals;, + ByteBuf buf = releaseLater(Unpooled.buffer(16));, + ByteBuf buf2 = releaseLater(Unpooled.buffer(16));, + assertEquals(buf, buf2);, + ByteBuf buf = unreleasableBuffer(releaseLater(Unpooled.buffer(16)));, + ByteBuf buf2 =
[+++ b/src/assembly/default.xml]
[+++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java, + if (!config().isAutoRead()) {, + // stop reading until next Channel.read() call, + // See https://github.com/netty/netty/issues/1363, + break loop;, + }, +++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java, + if (!config().isAutoRead()) {, + // stop reading until next Channel.read() call, + // See https://github.com/netty/netty/issues/1363, + break loop;, + }, +++ b/transport/src/main/java/io/netty/channel/oio/AbstractOioByteChannel.java, + if (!byteBuf.isWritable()) {, + if (!config().isAutoRead()) {, + // stop reading until next Channel.read() call, + // See https://github.com/netty/netty/issues/1363, + break;, + }, + }]
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + int bytesToSlice = length;, + int firstBufOffset = offset - firstC.offset;, + ByteBuf slice = firstC.buf.slice(firstBufOffset + firstC.buf.readerIndex(),, + Math.min(firstC.length - firstBufOffset, bytesToSlice));, + bytesToSlice -= slice.readableBytes();, + if (bytesToSlice == 0) {, + return Collections.singletonList(slice);, +, + List<ByteBuf> sliceList = new ArrayList<ByteBuf>(components.size() - componentId);, + sliceList.add(slice);, +, + // Add all the slices until there is nothing more left and then return the List., + do {, + Component component = components.get(++componentId);, + slice = component.buf.slice(component.buf.readerIndex(), Math.min(component.length, bytesToSlice));, + bytesToSlice -= slice.readableBytes();, + sliceList.add(slice);, + return sliceList;, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + int bytesToSlice = length;, +
[+++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelHandlerAdapter;, +import io.netty.channel.ChannelInitializer;, + * // The connection is closed when there is no inbound traffic, + * // for 30 seconds., + * public class MyChannelInitializer extends {@link ChannelInitializer} {, + * public void initChannel({@link Channel} channel) {, + * {@link Channel}.pipeline().addLast("readTimeoutHandler", new {@link ReadTimeoutHandler}(30);, + * {@link Channel}.pipeline().addLast("myHandler", new MyHandler());, + * }, + * // Handler should handle the {@link ReadTimeoutException}., + * public class MyHandler extends {@link ChannelHandlerAdapter} {, + * {@code @Override}, + * public void exceptionCaught({@link ChannelHandlerContext} ctx, {@link Throwable} cause), + * throws {@link Exception} {, +
[+++ b/all/pom.xml, + <version>4.1.23.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.23.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.23.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.23.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.23.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, + <version>4.1.23.Final-SNAPSHOT</version>, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +, + if (accepted != 0 && !receivedShutdown) {, + if (engineClosed || destroyed != 0) {, + if (engineClosed || destroyed != 0) {, +, + @Override, + protected void finalize() throws Throwable {, + super.finalize();, + // Call shutdown as the user may have created the OpenSslEngine and not used it at all., + shutdown();, + }]
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketEchoTest.java, + testSimpleEcho0(sb, cb, Integer.MAX_VALUE, false, false);, + testSimpleEcho0(sb, cb, Integer.MAX_VALUE, true, false);, + testSimpleEcho0(sb, cb, 32, false, false);, + testSimpleEcho0(sb, cb, 32, true, false);, + }, +, + @Test(timeout = 30000), + public void testSimpleEchoWithVoidPromise() throws Throwable {, + run();, + }, +, + public void testSimpleEchoWithVoidPromise(ServerBootstrap sb, Bootstrap cb) throws Throwable {, + testSimpleEcho0(sb, cb, Integer.MAX_VALUE, false, true);, + }, +, + @Test(timeout = 30000), + public void testSimpleEchoWithBridgeAndVoidPromise() throws Throwable {, + run();, + }, +, + public void testSimpleEchoWithBridgeAndVoidPromise(ServerBootstrap sb, Bootstrap cb) throws Throwable {, + testSimpleEcho0(sb, cb, Integer.MAX_VALUE, true, true);, + ServerBootstrap sb,
[+++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, +/**, + * Description of algorithm for PageRun/PoolSubpage allocation from PoolChunk, + *, + * Notation: The following terms are important to understand the code, + * > page - a page is the smallest unit of memory chunk that can be allocated, + * > chunk - a chunk is a collection of pages, + * > in this code chunkSize = 2^{maxOrder} * pageSize, + *, + * To begin we allocate a byte array of size = chunkSize, + * Whenever a ByteBuf of given size needs to be created we search for the
[+++ b/src/main/java/org/jboss/netty/handler/timeout/HashedWheelTimer.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2009, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version., + *, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + if (doesSupportProtocol(SSL.SSL_PROTOCOL_SSLV2, SSL.SSL_OP_NO_SSLv2)) {, + if (doesSupportProtocol(SSL.SSL_PROTOCOL_SSLV3, SSL.SSL_OP_NO_SSLv3)) {, + if (doesSupportProtocol(SSL.SSL_PROTOCOL_TLSV1, SSL.SSL_OP_NO_TLSv1)) {, + if (doesSupportProtocol(SSL.SSL_PROTOCOL_TLSV1_1, SSL.SSL_OP_NO_TLSv1_1)) {, + if (doesSupportProtocol(SSL.SSL_PROTOCOL_TLSV1_2, SSL.SSL_OP_NO_TLSv1_2)) {, + logger.debug("Supported protocols (OpenSSL): {} ", SUPPORTED_PROTOCOLS_SET);, + private static boolean doesSupportProtocol(int protocol, int opt) {, + if (opt == 0) {, + // If the opt is 0 the protocol is not supported. This is for example the case with BoringSSL and SSLv2., + return false;, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + if (doesSupportProtocol(SSL.SSL_PROTOCOL_SSLV2, SSL.SSL_OP_NO_SSLv2)) {, + if (doesSupportProtocol(SSL.SSL_PROTOCOL_SSLV3, SSL.SSL_OP_NO_SSLv3)) {, + if (doesSupportProtocol(SSL.SSL_PROTOCOL_TLSV1, SSL.SSL_OP_NO_TLSv1)) {, + if (doesSupportProtocol(SSL.SSL_PROTOCOL_TLSV1_1, SSL.SSL_OP_NO_TLSv1_1)) {, +
[+++ b/pom.xml, + <version>20</version>]
[+++ b/src/docbook/en-US/module/architecture.xml, + to represent a sequence of bytes. This approach has significant advantages, + &ChannelBuffer; has been designed from the ground up to address the problems, + You can define your own buffer type if necessary., + Transparent zero copy is achieved by a built-in composite buffer type., + Traditional I/O APIs in Java provide different types and methods for, + another tedious and difficult. The lack of portability between, + transports becomes a problem when you need to support additional, + transports, as this often entails rewriting the network layer of the, + application. Logically, many protocols
[+++ b/pom.xml, + <ignore>java.nio.channels.spi.SelectorProvider</ignore>, +++ b/pom.xml, + <ignore>java.nio.channels.spi.SelectorProvider</ignore>, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, +import java.nio.channels.spi.SelectorProvider;, + private static final SelectorProvider SELECTOR_PROVIDER = SelectorProvider.provider();, + /**, + * Use the {@link SelectorProvider} to open {@link SocketChannel} and so remove condition in, + * {@link SelectorProvider#provider()} which is called by each DatagramChannel.open() otherwise., + *, + * See <a href="See https://github.com/netty/netty/issues/2308">#2308</a>., + */, + return SELECTOR_PROVIDER.openDatagramChannel();, + return SELECTOR_PROVIDER.openDatagramChannel(ProtocolFamilyConverter.convert(ipFamily));, +++ b/pom.xml, + <ignore>java.nio.channels.spi.SelectorProvider</ignore>, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, +import java.nio.channels.spi.SelectorProvider;, + private static final SelectorProvider SELECTOR_PROVIDER = SelectorProvider.provider();, + /**, + * Use the {@link SelectorProvider} to open {@link SocketChannel} and so remove condition in, + *
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, + return (buf.getByte(offset) & 0xFF) << 8 |, + buf.getByte(offset + 1) & 0xFF;, + return (buf.getByte(offset) & 0xFF) << 16 |, + buf.getByte(offset + 2) & 0xFF;, + return (buf.getByte(offset) & 0x7F) << 24 |, + buf.getByte(offset + 3) & 0xFF;, + return (buf.getByte(offset) & 0xFF) << 24 |, + buf.getByte(offset + 3) & 0xFF;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, + return (buf.getByte(offset) & 0xFF) << 8 |, + buf.getByte(offset + 1) & 0xFF;, + return (buf.getByte(offset) & 0xFF) << 16 |, + buf.getByte(offset + 2) & 0xFF;, + return (buf.getByte(offset) & 0x7F)
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + * Returns the maximum age of this {@link Cookie} in seconds or {@link Long#MIN_VALUE} if unspecified, + * If {@link Long#MIN_VALUE} is specified, this {@link Cookie} will be removed when the, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + * Returns the maximum age of this {@link Cookie} in seconds or {@link Long#MIN_VALUE} if unspecified, + * If {@link Long#MIN_VALUE} is specified, this {@link Cookie} will be removed when the, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java, + private long maxAge = Long.MIN_VALUE;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + * Returns the maximum age of this {@link Cookie} in seconds or {@link Long#MIN_VALUE} if unspecified, + * If {@link
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, + promiseAggregator.setFailure(t);, + return promiseAggregator.doneAllocatingPromises();, + promiseAggregator.setFailure(t);, + return promiseAggregator.doneAllocatingPromises();, + headerBlock.readSlice(min(headerBlock.readableBytes(), maxFragmentLength));, + ctx.write(fragment.retain(), promiseAggregator.newPromise());, + promiseAggregator.setFailure(t);, + return promiseAggregator.doneAllocatingPromises();, + promiseAggregator.setFailure(t);, + return promiseAggregator.doneAllocatingPromises();, + promiseAggregator.setFailure(t);, + return promiseAggregator.doneAllocatingPromises();, + headerBlock.readSlice(min(headerBlock.readableBytes(), maxFragmentLength));, + ctx.write(fragment.retain(), promiseAggregator.newPromise());, + promiseAggregator.setFailure(t);, + return promiseAggregator.doneAllocatingPromises();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, + promiseAggregator.setFailure(t);, + return promiseAggregator.doneAllocatingPromises();, + promiseAggregator.setFailure(t);, + return promiseAggregator.doneAllocatingPromises();, + headerBlock.readSlice(min(headerBlock.readableBytes(), maxFragmentLength));, + ctx.write(fragment.retain(), promiseAggregator.newPromise());, + promiseAggregator.setFailure(t);, + return promiseAggregator.doneAllocatingPromises();, + promiseAggregator.setFailure(t);, + return promiseAggregator.doneAllocatingPromises();, + promiseAggregator.setFailure(t);, + return promiseAggregator.doneAllocatingPromises();, + headerBlock.readSlice(min(headerBlock.readableBytes(), maxFragmentLength));, + ctx.write(fragment.retain(), promiseAggregator.newPromise());, + promiseAggregator.setFailure(t);, + return promiseAggregator.doneAllocatingPromises();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, + static final class SimpleChannelPromiseAggregator extends DefaultChannelPromise {, +
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/ZlibCodecFactory.java, + noJdkZlibDecoder = SystemPropertyUtil.getBoolean("io.netty.noJdkZlibDecoder", true);]
[+++ b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpRequestEncoder.java, + final SmtpRequest req = (SmtpRequest) msg;, + if (req.command().equals(SmtpCommand.RSET)) {, + contentExpected = false;, + } else {, + }, +++ b/codec-smtp/src/main/java/io/netty/handler/codec/smtp/SmtpRequestEncoder.java, + final SmtpRequest req = (SmtpRequest) msg;, + if (req.command().equals(SmtpCommand.RSET)) {, + contentExpected = false;, + } else {, + }, +++ b/codec-smtp/src/test/java/io/netty/handler/codec/smtp/SmtpRequestEncoderTest.java, +import io.netty.handler.codec.EncoderException;, + assertEquals("DATA\r\nSubject: Test\r\n\r\nTest\r\n.\r\n", getWrittenString(channel));, + }, +, + @Test(expected = EncoderException.class), + public void testThrowsIfContentExpected() {, + EmbeddedChannel channel = new EmbeddedChannel(new SmtpRequestEncoder());, + assertTrue(channel.writeOutbound(SmtpRequests.data()));, + channel.writeOutbound(SmtpRequests.noop());, + }, +, + @Test, + public void testRsetClearsContentExpectedFlag() {, + EmbeddedChannel channel = new EmbeddedChannel(new SmtpRequestEncoder());, +, + assertTrue(channel.writeOutbound(SmtpRequests.data()));, + assertTrue(channel.writeOutbound(SmtpRequests.rset()));,
[+++ b/all/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta8</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufEncoder.java, +import io.netty.handler.codec.MessageToByteEncoder;, +public class ProtobufEncoder extends MessageToByteEncoder<MessageLiteOrBuilder> {, + protected void encode(ChannelHandlerContext ctx, MessageLiteOrBuilder msg, ByteBuf out) throws Exception {, + out.writeBytes(((MessageLite) msg).toByteArray());, + return;, + out.writeBytes(((MessageLite.Builder) msg).build().toByteArray());]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import io.netty.util.ReferenceCountUtil;, + *, + * @deprecated use {@link ReferenceCountUtil#retain(Object)}, + @Deprecated, + return ReferenceCountUtil.retain(msg);, + *, + * @deprecated use {@link ReferenceCountUtil#retain(Object, int)}, + @Deprecated, + return ReferenceCountUtil.retain(msg, increment);, + *, + * @deprecated use {@link ReferenceCountUtil#release(Object)}, + @Deprecated, + return ReferenceCountUtil.release(msg);, + *, + * @deprecated use {@link ReferenceCountUtil#release(Object, int)}, + @Deprecated, + return ReferenceCountUtil.release(msg, decrement);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import io.netty.util.ReferenceCountUtil;, + *, + * @deprecated use {@link ReferenceCountUtil#retain(Object)}, + @Deprecated, + return ReferenceCountUtil.retain(msg);, + *, + * @deprecated use {@link ReferenceCountUtil#retain(Object, int)}, + @Deprecated, + return ReferenceCountUtil.retain(msg, increment);, + *, + * @deprecated use {@link
[+++ b/pom.xml, + <argLine.leak>-D_</argLine.leak> <!-- Overridden when 'leak' profile is active -->]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, + final int shift = Integer.numberOfLeadingZeros(table.length) + 1;, + return in.getInt(index) * 0x1e35a7bd >>> shift;, + return new short[htSize];, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, + final int shift = Integer.numberOfLeadingZeros(table.length) + 1;, + return in.getInt(index) * 0x1e35a7bd >>> shift;, + return new short[htSize];, +++ b/codec/src/test/java/io/netty/handler/codec/compression/SnappyTest.java, +import io.netty.util.CharsetUtil;, +, + in.release();, + out.release();, + expected.release();, +, + in.release();, + out.release();, + expected.release();, + try {, + } finally {, + in.release();, + out.release();, + }, + try {, + } finally {, + in.release();, + out.release();, + }, + try {, + } finally {, + in.release();, + out.release();, + },
[+++ b/buffer/src/test/java/io/netty/buffer/WrappedUnpooledUnsafeByteBufTest.java, + Assume.assumeTrue("PlatformDependent.useDirectBufferNoCleaner() returned false, skip tests",, + PlatformDependent.useDirectBufferNoCleaner());, +++ b/buffer/src/test/java/io/netty/buffer/WrappedUnpooledUnsafeByteBufTest.java, + Assume.assumeTrue("PlatformDependent.useDirectBufferNoCleaner() returned false, skip tests",, + PlatformDependent.useDirectBufferNoCleaner());, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + Field addressField = null;, + Unsafe unsafe;, + unsafe = null;, +, + if (unsafe != null) {, + final Unsafe finalUnsafe = unsafe;, +, + // attempt to access field Buffer#address, + final Object maybeAddressField = AccessController.doPrivileged(new PrivilegedAction<Object>() {, + @Override, + public Object run() {, + try {, + final Field field = Buffer.class.getDeclaredField("address");, + // Use Unsafe to read value of the address field. This way it will not fail on JDK9+ which,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + public void setSingleDecode(boolean singleDecode) {, + decoder().setSingleDecode(singleDecode);, + }, +, + public boolean isSingleDecode() {, + return decoder().isSingleDecode();, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + public void setSingleDecode(boolean singleDecode) {, + decoder().setSingleDecode(singleDecode);, + }, +, + public boolean isSingleDecode() {, + return decoder().isSingleDecode();, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import io.netty.channel.ChannelFutureListener;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelInboundByteHandler;, +import io.netty.channel.ChannelOutboundMessageHandler;, +import io.netty.channel.ChannelPipeline;, +import io.netty.handler.codec.http.FullHttpRequest;, +import io.netty.handler.codec.http.HttpClientCodec;, +import io.netty.handler.codec.http.HttpRequestEncoder;, +import io.netty.handler.codec.http.HttpResponseDecoder;, + private void setHandshakeComplete() {, + private void setActualSubprotocol(String actualSubprotocol) {, + public final ChannelFuture handshake(Channel channel, final ChannelPromise promise) {, + FullHttpRequest request = newHandshakeRequest();, + HttpResponseDecoder decoder = channel.pipeline().get(HttpResponseDecoder.class);,
[+++ b/pom.xml, + <pluginExecution>, + <pluginExecutionFilter>, + <groupId>org.apache.felix</groupId>, + <artifactId>maven-bundle-plugin</artifactId>, + <versionRange>[2.4,)</versionRange>, + <goals>, + <goal>manifest</goal>, + </goals>, + </pluginExecutionFilter>, + <action>, + <ignore />, + </action>, + </pluginExecution>]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackDecoder.java, + headersLength += HpackHeaderField.sizeOf(name, value);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackDecoder.java, + headersLength += HpackHeaderField.sizeOf(name, value);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/HpackDecoderTest.java, +import org.junit.Rule;, +import org.junit.rules.ExpectedException;, +import static org.hamcrest.CoreMatchers.is;, +import static org.hamcrest.Matchers.greaterThanOrEqualTo;, +import static org.junit.Assert.assertThat;, + @Rule, + public ExpectedException expectedException = ExpectedException.none();, +, + ByteBuf in = Unpooled.buffer(300);, + hpackDecoder.setMaxHeaderListSize(200, 300);, +, + @Test, + public void testAccountForHeaderOverhead() throws Exception {, + ByteBuf in = Unpooled.buffer(100);, + try {, + String headerName = "12345";, + String headerValue = "56789";, + long headerSize = headerName.length() + headerValue.length();, + hpackDecoder.setMaxHeaderListSize(headerSize, 100);, + HpackEncoder hpackEncoder = new HpackEncoder(true);, +, + Http2Headers toEncode = new DefaultHttp2Headers();, + toEncode.add(headerName,
[+++ b/example/src/main/java/io/netty/example/http2/helloworld/server/HelloWorldHttp2Handler.java, +import io.netty.handler.codec.http.HttpHeaderNames;, +import io.netty.handler.codec.http.HttpMethod;, +import io.netty.handler.codec.http.HttpScheme;, + CharSequence host = request.headers().get(HttpHeaderNames.HOST);, + Http2Headers http2Headers = new DefaultHttp2Headers(), + .method(HttpMethod.GET.asciiName()), + .scheme(HttpScheme.HTTP.name());, + if (host != null) {, + http2Headers.authority(host);, + }, + return http2Headers;]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java, + ByteBuf footer = Unpooled.dynamicBuffer();, + while (!deflater.finished()) {, + int numBytes = deflater.deflate(encodeBuf, 0, encodeBuf.length);, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(AbstractDiskHttpData.class);, +]
[+++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.handler.logging.LogLevel;, +import io.netty.handler.logging.LoggingHandler;, + new LoggingHandler(LogLevel.INFO),, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.handler.logging.LogLevel;, +import io.netty.handler.logging.LoggingHandler;, + new LoggingHandler(LogLevel.INFO),, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, +import io.netty.handler.logging.LogLevel;, +import io.netty.handler.logging.LoggingHandler;, + .handler(new LoggingHandler(LogLevel.INFO)), + new LoggingHandler(LogLevel.INFO),, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.handler.logging.LogLevel;, +import io.netty.handler.logging.LoggingHandler;, + new LoggingHandler(LogLevel.INFO),, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, +import io.netty.handler.logging.LogLevel;, +import io.netty.handler.logging.LoggingHandler;, + .handler(new LoggingHandler(LogLevel.INFO)), + new LoggingHandler(LogLevel.INFO),, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, + } if (message instanceof ChannelBuffer && ctx.hasOutboundByteBuffer()) {]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, + private final boolean allowGrowing;, + private long[] events;, + if (maxEvents == 0) {, + allowGrowing = true;, + events = new long[128];, + } else {, + allowGrowing = false;, + }, + if (allowGrowing && ready == events.length) {, + // double the size of the array as we needed the whole space for the events, + events = new long[events.length << 1];, + }, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, + private final boolean allowGrowing;, + private long[] events;, + if (maxEvents == 0) {, + allowGrowing = true;, + events = new long[128];, + } else
[+++ b/all/pom.xml, + <plugin>, + <artifactId>maven-javadoc-plugin</artifactId>, + <version>2.8.1</version>, + <executions>, + <execution>, + <id>javadoc</id>, + <phase>package</phase>, + <goals>, + <goal>jar</goal>, + </goals>, + <configuration>, + <attach>false</attach>, + </configuration>, + </execution>, + </executions>, + </plugin>]
[+++ b/common/pom.xml, + <!-- Byte code generator - completely optional -->, + <dependency>, + <groupId>org.javassist</groupId>, + <artifactId>javassist</artifactId>, + <scope>compile</scope> <!-- override the 'test' scope defined at parent pom.xml -->, + <optional>true</optional>, + </dependency>, +, +++ b/common/pom.xml, + <!-- Byte code generator - completely optional -->, + <dependency>, + <groupId>org.javassist</groupId>, + <artifactId>javassist</artifactId>, + <scope>compile</scope> <!-- override the 'test' scope defined at parent pom.xml -->, + <optional>true</optional>, + </dependency>, +, +++ b/pom.xml, + <!-- Byte code generator - completely optional -->, + <dependency>, + <groupId>org.javassist</groupId>, + <artifactId>javassist</artifactId>, + <version>3.17.1-GA</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, +, + <!-- Enable Javassist support
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + try {, + logger.debug("Failed to get useKeyManagerFactory system property.");, + }, + } catch (Throwable ignore) {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + try {, + logger.debug("Failed to get useKeyManagerFactory system property.");, + }, + } catch (Throwable ignore) {, +++ b/handler/src/test/java/io/netty/handler/ssl/JdkOpenSslEngineInteroptTest.java, +import static io.netty.handler.ssl.OpenSslTestUtils.checkShouldUseKeyManagerFactory;, + checkShouldUseKeyManagerFactory();, + checkShouldUseKeyManagerFactory();, + checkShouldUseKeyManagerFactory();, + checkShouldUseKeyManagerFactory();, + checkShouldUseKeyManagerFactory();, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + try {, + logger.debug("Failed to get useKeyManagerFactory system property.");, + }, + } catch (Throwable ignore) {, +++ b/handler/src/test/java/io/netty/handler/ssl/JdkOpenSslEngineInteroptTest.java, +import static io.netty.handler.ssl.OpenSslTestUtils.checkShouldUseKeyManagerFactory;, + checkShouldUseKeyManagerFactory();, + checkShouldUseKeyManagerFactory();, + checkShouldUseKeyManagerFactory();, + checkShouldUseKeyManagerFactory();, + checkShouldUseKeyManagerFactory();, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, +import static io.netty.handler.ssl.OpenSslTestUtils.checkShouldUseKeyManagerFactory;, + checkShouldUseKeyManagerFactory();, + checkShouldUseKeyManagerFactory();,
[+++ b/common/src/main/java/io/netty/util/concurrent/PromiseNotifier.java, +import io.netty.util.internal.PromiseNotificationUtil;, + InternalLogger internalLogger = logNotifyFailure ? logger : null;, + PromiseNotificationUtil.trySuccess(p, result, internalLogger);, + PromiseNotificationUtil.tryCancel(p, internalLogger);, + PromiseNotificationUtil.tryFailure(p, cause, internalLogger);, +++ b/common/src/main/java/io/netty/util/concurrent/PromiseNotifier.java, +import io.netty.util.internal.PromiseNotificationUtil;, + InternalLogger internalLogger = logNotifyFailure ? logger : null;, + PromiseNotificationUtil.trySuccess(p, result, internalLogger);, + PromiseNotificationUtil.tryCancel(p, internalLogger);, + PromiseNotificationUtil.tryFailure(p, cause, internalLogger);, +++ b/common/src/main/java/io/netty/util/internal/PromiseNotificationUtil.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostStandardRequestDecoder.java, +import io.netty.handler.codec.http.QueryStringDecoder;, + return QueryStringDecoder.decodeComponent(s, charset);]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterialManager.java, +import java.util.HashSet;, +import java.util.Set;, + Set<String> aliases = new HashSet<String>(authMethods.length);, + String alias = chooseServerAlias(engine, type);, + if (alias != null && aliases.add(alias)) {, + setKeyMaterial(ssl, alias);, + }, + keyCertChainBio = OpenSslContext.toBIO(certificates);]
[+++ b/pom.xml, +++ b/pom.xml, +++ b/src/main/java/org/jboss/netty/container/osgi/NettyBundleActivator.java, + private OsgiLoggerFactory loggerFactory;, + // Switch the internal logger to the OSGi LogService., + loggerFactory = new OsgiLoggerFactory(ctx);, + InternalLoggerFactory.setDefaultFactory(loggerFactory);, + // Prepare the resources required for creating ChannelFactories., +, + if (loggerFactory != null) {, + InternalLoggerFactory.setDefaultFactory(loggerFactory.getFallback());, + loggerFactory.destroy();, + loggerFactory = null;, +++ b/pom.xml, +++ b/src/main/java/org/jboss/netty/container/osgi/NettyBundleActivator.java, + private OsgiLoggerFactory loggerFactory;, + // Switch the internal logger to the OSGi LogService., + loggerFactory = new OsgiLoggerFactory(ctx);, + InternalLoggerFactory.setDefaultFactory(loggerFactory);, + // Prepare the resources required for creating ChannelFactories., +, + if (loggerFactory != null) {, + InternalLoggerFactory.setDefaultFactory(loggerFactory.getFallback());, + loggerFactory.destroy();, + loggerFactory =
[+++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, +import io.netty.util.collection.IntObjectHashMap;, +, +/**, + * Description of algorithm for PageRun/PoolSubpage allocation from PoolChunk, + *, + * Notation: The following terms are important to understand the code, + * > page - a page is the smallest unit of memory chunk that can be allocated, + * > chunk - a chunk is a collection of pages, + * > in this code chunkSize = 2^{maxOrder} * pageSize, + *, + * To begin we allocate a byte array of size = chunkSize, + * Whenever a ByteBuf of given size needs to be created we
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +, +jint write0(JNIEnv * env, jclass clazz, jint fd, void *buffer, jint pos, jint limit) {, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_write(JNIEnv * env, jclass clazz, jint fd, jobject jbuffer, jint pos, jint limit) {, + void *buffer = (*env)->GetDirectBufferAddress(env, jbuffer);, + if (buffer == NULL) {, + throwRuntimeException(env, "Unable to access address of buffer");, + return -1;, + }, + return write0(env, clazz, fd, buffer, pos, limit);, +}, +, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_writeAddress(JNIEnv * env, jclass clazz, jint fd, jlong address, jint pos, jint limit) {, + return write0(env, clazz, fd, (void *) address, pos, limit);, +}, +,
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java, + final int readable = in.readableBytes();, +, + // Looking at the spec we should always have at least enough readable bytes to read a byte here but it seems, + // some servers do not respect this for empty names. So just workaround this and return an empty name in this, + // case., + //, + // See:, + // - https://github.com/netty/netty/issues/5014, + // - https://www.ietf.org/rfc/rfc1035.txt , Section 3.1, + if (readable == 0) {, + return StringUtil.EMPTY_STRING;, + }, + final StringBuilder name = new StringBuilder(readable << 1);, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java, + final int readable
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/sctp/SctpEchoTest.java, + testSimpleEcho0(sb, cb, false);, + @Test, + public void testSimpleEchoUnordered() throws Throwable {, + Assume.assumeTrue(TestUtils.isSctpSupported());, + run();, + }, +, + public void testSimpleEchoUnordered(ServerBootstrap sb, Bootstrap cb) throws Throwable {, + testSimpleEcho0(sb, cb, true);, + }, +, + private static void testSimpleEcho0(ServerBootstrap sb, Bootstrap cb, final boolean unordered) throws Throwable {, + new SctpOutboundByteStreamHandler(0, 0, unordered),, + new SctpOutboundByteStreamHandler(0, 0, unordered),, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/sctp/SctpEchoTest.java, + testSimpleEcho0(sb, cb, false);, + @Test, + public void testSimpleEchoUnordered() throws Throwable {, + Assume.assumeTrue(TestUtils.isSctpSupported());, + run();, + }, +, + public void testSimpleEchoUnordered(ServerBootstrap sb, Bootstrap cb) throws Throwable {, + testSimpleEcho0(sb, cb, true);,
[+++ b/pom.xml, + <include name="COPYRIGHT.*" />, + <include name="COPYRIGHT.*" />, + <include name="COPYRIGHT.*" />]
[+++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, + String path = "META-INF/native/" + libname;, +++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, + String path = "META-INF/native/" + libname;, +++ b/pom.xml, + <extensions>, + <extension>, + <groupId>kr.motd.maven</groupId>, + <artifactId>os-maven-plugin</artifactId>, + <version>1.1.1</version>, + </extension>, + </extensions>, +, + <plugin>, + <groupId>org.fusesource.hawtjni</groupId>, + <artifactId>maven-hawtjni-plugin</artifactId>, + <version>1.10</version>, + </plugin>, +++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, + String path = "META-INF/native/" + libname;, +++ b/pom.xml, + <extensions>, + <extension>, + <groupId>kr.motd.maven</groupId>, + <artifactId>os-maven-plugin</artifactId>, + <version>1.1.1</version>, + </extension>, + </extensions>, +, + <plugin>, + <groupId>org.fusesource.hawtjni</groupId>, + <artifactId>maven-hawtjni-plugin</artifactId>, + <version>1.10</version>, + </plugin>, +++ b/transport-native-epoll/pom.xml, + <id>build-native-lib</id>, + <nativeSourceDirectory>${project.basedir}/src/main/c</nativeSourceDirectory>, + <libDirectory>${project.build.outputDirectory}</libDirectory>, + <!-- We use Maven's artifact classifier instead., + This
[+++ b/codec/src/main/java/io/netty/handler/codec/serialization/CompactObjectOutputStream.java, + if (clazz.isPrimitive() || clazz.isArray() || clazz.isInterface() ||, + desc.getSerialVersionUID() == 0) {]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + _setShort(writerIndex, value);, + _setMedium(writerIndex, value);, + _setInt(writerIndex, value);, + _setLong(writerIndex, value);]
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, + @Override, + KeyStore ks = buildKeyStore(certChainFile, keyFile, keyPasswordChars);, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, + @Override, + KeyStore ks = buildKeyStore(certChainFile, keyFile, keyPasswordChars);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java, +import io.netty.util.internal.EmptyArrays;, + char[] keyPasswordChars = keyPassword == null ? EmptyArrays.EMPTY_CHARS : keyPassword.toCharArray();, + KeyStore ks = buildKeyStore(certChainFile, keyFile, keyPasswordChars);, + trustManagerFactory.init(ks);, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, + @Override, + KeyStore ks = buildKeyStore(certChainFile, keyFile, keyPasswordChars);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java, +import io.netty.util.internal.EmptyArrays;, + char[] keyPasswordChars = keyPassword == null ? EmptyArrays.EMPTY_CHARS : keyPassword.toCharArray();, + KeyStore ks = buildKeyStore(certChainFile, keyFile, keyPasswordChars);, + trustManagerFactory.init(ks);, +++ b/handler/src/main/java/io/netty/handler/ssl/SslContext.java, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.ByteBufInputStream;, +import java.security.KeyException;, +import java.security.KeyFactory;, +import java.security.KeyStore;, +import java.security.KeyStoreException;, +import java.security.PrivateKey;, +import java.security.cert.Certificate;,
[+++ b/.fbfilter.xml, + <Match>, + <Class name="~.*HttpTunnelingChannelHandler"/>, + <Method name="~await.*"/>, + <Bug pattern="RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,RV_RETURN_VALUE_IGNORED2"/>, + </Match>]
[+++ b/transport/src/main/java/io/netty/channel/DefaultFileRegion.java, + if (count < 0) {]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + private SSLEngineResult readPendingBytesFromBIO(, + ByteBuffer dst, int bytesConsumed, int bytesProduced, HandshakeStatus status) throws SSLException {, + return new SSLEngineResult(BUFFER_OVERFLOW,, + mayFinishHandshake(status != FINISHED ? getHandshakeStatus(pendingNet) : status),, + return new SSLEngineResult(getEngineStatus(),, + mayFinishHandshake(status != FINISHED ? getHandshakeStatus(pendingNet) : status),, + HandshakeStatus status = NOT_HANDSHAKING;, + status = handshake();, + SSLEngineResult pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, status);, + SSLEngineResult pendingNetResult = readPendingBytesFromBIO(dst, 0, bytesProduced, status);, + return newResult(bytesConsumed, bytesProduced, status);, + HandshakeStatus status = NOT_HANDSHAKING;, + status = handshake();, + return newResult(bytesConsumed, bytesProduced, status);, + return newResult(bytesConsumed, bytesProduced, status);, + BUFFER_OVERFLOW, mayFinishHandshake(status != FINISHED ? getHandshakeStatus(): status),,
[+++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, + config().setAllocator(new PreferHeapByteBufAllocator(config.getAllocator()));, + config().setAllocator(new PreferHeapByteBufAllocator(config.getAllocator()));, +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, + config().setAllocator(new PreferHeapByteBufAllocator(config.getAllocator()));, + config().setAllocator(new PreferHeapByteBufAllocator(config.getAllocator()));, +++ b/transport/src/main/java/io/netty/channel/local/LocalServerChannel.java, + public LocalServerChannel() {, + config().setAllocator(new PreferHeapByteBufAllocator(config.getAllocator()));, + }, +, +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, + config().setAllocator(new PreferHeapByteBufAllocator(config.getAllocator()));, + config().setAllocator(new PreferHeapByteBufAllocator(config.getAllocator()));, +++ b/transport/src/main/java/io/netty/channel/local/LocalServerChannel.java, + public LocalServerChannel() {, + config().setAllocator(new PreferHeapByteBufAllocator(config.getAllocator()));, + }, +, +++ b/transport/src/main/java/io/netty/channel/local/PreferHeapByteBufAllocator.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy
[+++ b/common/src/main/java/io/netty/util/AttributeMap.java, + * an {@link Attribute} which does not have a value set yet., +++ b/common/src/main/java/io/netty/util/AttributeMap.java, + * an {@link Attribute} which does not have a value set yet., +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, + // Flushed messages are stored in a circular buffer., +++ b/common/src/main/java/io/netty/util/AttributeMap.java, + * an {@link Attribute} which does not have a value set yet., +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, + // Flushed messages are stored in a circular buffer., +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java, +, +++ b/common/src/main/java/io/netty/util/AttributeMap.java, + * an {@link Attribute} which does not have a value set yet., +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, + // Flushed messages are stored in a circular buffer.,
[+++ b/all/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/codec-http2/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.1.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/pom.xml, + <version>3.1.0.ALPHA4-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +import static io.netty.resolver.dns.UnixResolverDnsServerAddressStreamProvider.parseEtcResolverFirstNdots;, + private static final int DEFAULT_NDOTS;, +, + int ndots;, + try {, + ndots = parseEtcResolverFirstNdots();, + } catch (Exception ignore) {, + ndots = UnixResolverDnsServerAddressStreamProvider.DEFAULT_NDOTS;, + }, + DEFAULT_NDOTS = ndots;, + this.ndots = ndots >= 0 ? ndots : DEFAULT_NDOTS;, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +import static io.netty.resolver.dns.UnixResolverDnsServerAddressStreamProvider.parseEtcResolverFirstNdots;, + private static final int DEFAULT_NDOTS;, +, + int ndots;, + try {, + ndots = parseEtcResolverFirstNdots();, + } catch (Exception ignore) {, + ndots = UnixResolverDnsServerAddressStreamProvider.DEFAULT_NDOTS;, + }, + DEFAULT_NDOTS = ndots;, + this.ndots = ndots >= 0 ? ndots : DEFAULT_NDOTS;, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpContent.java, + return StringUtil.simpleClassName(this) +, + "(data: " + content() + ", getDecoderResult: " + getDecoderResult() + ')';]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java, +import io.netty.channel.ChannelPromiseNotifier;, +import io.netty.util.concurrent.EventExecutor;, + private volatile boolean finished;, + public ChannelFuture close(final ChannelPromise promise) {, + ChannelHandlerContext ctx = ctx();, + EventExecutor executor = ctx.executor();, + if (executor.inEventLoop()) {, + return finishEncode(ctx, promise);, + } else {, + final ChannelPromise p = ctx.newPromise();, + executor.execute(new Runnable() {, + @Override, + public void run() {, + ChannelFuture f = finishEncode(ctx(), p);, + f.addListener(new ChannelPromiseNotifier(promise));, + }, + });, + return p;, + }, + return finished;, + if (finished) {, + final ChannelPromise promise) {, + if (finished) {, + finished = true;, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java, +import io.netty.channel.ChannelPromiseNotifier;,
[+++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/CipherSuiteConverter.java, + "(?:DHE|EDH|ECDH|ECDHE|SRP|RSA)-(?:DSS|RSA|ECDSA|PSK)|" +, + } else if (bulkCipher.contains("CHACHA20")) {, + return handshakeAlgo + '-' + bulkCipher;, + String javaCipherSuite = handshakeAlgo + "_WITH_" + bulkCipher + '_' + hmacAlgo;, + // For historical reasons the CHACHA20 ciphers do not follow OpenSSL's custom naming convention and omits the, + // HMAC algorithm portion of the name. There is currently no way to derive this information because it is, + // omitted from the OpenSSL cipher name, but they currently all use SHA256 for HMAC [1]., + // [1] https://www.openssl.org/docs/man1.1.0/apps/ciphers.html, + return bulkCipher.contains("CHACHA20") ? javaCipherSuite + "_SHA256" : javaCipherSuite;,
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + * for a complete frame, return without modifying the reader index to allow more bytes to arrive., + * To check for complete frames without modifying the reader index, use methods like {@link ByteBuf#getInt(int)}., +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + * for a complete frame, return without modifying the reader index to allow more bytes to arrive., + * To check for complete frames without modifying the reader index, use methods like {@link ByteBuf#getInt(int)}., +++ b/common/src/main/java/io/netty/util/concurrent/EventExecutor.java, + * Besides this, it also extends the {@link EventExecutorGroup} to allow for a generic, + * way to access methods., +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java,
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + checkReadableBytes(1);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + checkReadableBytes(1);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, + @Test(expected = IndexOutOfBoundsException.class), + public void readByteThrowsIndexOutOfBoundsException() {, + final ByteBuf buffer = freeLater(newBuffer(8));, + buffer.writeByte(0);, + assertEquals((byte) 0 , buffer.readByte());, + buffer.readByte();, + }]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.IllegalReferenceCountException;, + throw new IllegalReferenceCountException(0);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.IllegalReferenceCountException;, + throw new IllegalReferenceCountException(0);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +import io.netty.util.IllegalReferenceCountException;, + throw new IllegalReferenceCountException(0, 1);, + throw new IllegalReferenceCountException(Integer.MAX_VALUE, 1);, + throw new IllegalReferenceCountException(0, increment);, + throw new IllegalReferenceCountException(refCnt, increment);, + throw new IllegalReferenceCountException(0, -1);, + throw new IllegalReferenceCountException(refCnt, -decrement);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.IllegalReferenceCountException;, + throw new IllegalReferenceCountException(0);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +import io.netty.util.IllegalReferenceCountException;, + throw new IllegalReferenceCountException(0, 1);, + throw new IllegalReferenceCountException(Integer.MAX_VALUE, 1);, + throw new IllegalReferenceCountException(0, increment);, + throw new IllegalReferenceCountException(refCnt, increment);, + throw new IllegalReferenceCountException(0, -1);, + throw new IllegalReferenceCountException(refCnt, -decrement);, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, +import io.netty.util.IllegalReferenceCountException;, + throw new
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, +package io.netty.handler.codec.http;, +, +import static io.netty.handler.codec.http.CookieEncoderUtil.*;, +, +import java.util.Collection;, +, +/**, + * Encodes client-side {@link Cookie}s into an HTTP header value. This encoder can encode, + * the HTTP cookie version 0, 1, and 2., + * <pre>, + * // Example, + * {@link HttpRequest} req = ...;, + * res.setHeader("Cookie", {@link ClientCookieEncoder}.encode("JSESSIONID", "1234"));, + * </pre>, + *, + * @see CookieDecoder, + *, + * @apiviz.stereotype utility, + * @apiviz.has io.netty.handler.codec.http.Cookie oneway - - encodes, + */, +public final class ClientCookieEncoder {, +, + /**, + * Encodes the specified cookie into an
[+++ b/pom.xml, + <url>http://io.netty/</url>, + <executions>, + <execution>, + <id>enforce-tools</id>, + <goals>, + <goal>enforce</goal>, + </goals>, + <configuration>, + <rules>, + <requireJavaVersion>, + <!-- Enforce java 1.6 as minimum for compiling -->, + <!-- This is needed because of the Unsafe detection code -->, + <version>[1.6.0,)</version>, + </requireJavaVersion>, + <requireMavenVersion>, + <version>[3.0.3,)</version>, + </requireMavenVersion>, + </rules>, + </configuration>, + </execution>, + </executions>]
[+++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, +import java.lang.Thread.State;, +import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;, + private static final Runnable NOOP_TASK = new Runnable() {, + @Override, + public void run() {, + // Do nothing., + }, + };, + private static final AtomicReferenceFieldUpdater<SingleThreadEventExecutor, ThreadProperties> PROPERTIES_UPDATER;, +, + AtomicReferenceFieldUpdater<SingleThreadEventExecutor, ThreadProperties> propertiesUpdater =, + PlatformDependent.newAtomicReferenceFieldUpdater(SingleThreadEventExecutor.class, "threadProperties");, + if (propertiesUpdater == null) {, + propertiesUpdater = AtomicReferenceFieldUpdater.newUpdater(SingleThreadEventExecutor.class,, + ThreadProperties.class, "threadProperties");, + }, + PROPERTIES_UPDATER = propertiesUpdater;, + private volatile ThreadProperties threadProperties;, + /**, + * Returns the {@link ThreadProperties} of the {@link Thread} that powers the {@link SingleThreadEventExecutor}., + * If the {@link SingleThreadEventExecutor} is not started yet, this
[+++ b/src/docbook/module/start.xml, + public void operationComplete(&ChannelFuture; future) {]
[+++ b/transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java, + protected abstract EventLoop newChild(Executor executor, Object... args) throws Exception;, +, + @Override]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + out.add(invalidMessage(buffer, e));, + out.add(invalidMessage(buffer, e));, + out.add(invalidChunk(buffer, e));, + out.add(invalidChunk(buffer, e));, + private HttpMessage invalidMessage(ByteBuf in, Exception cause) {, +, + // Advance the readerIndex so that ByteToMessageDecoder does not complain, + // when we produced an invalid message without consuming anything., + in.skipBytes(in.readableBytes());, +, + private HttpContent invalidChunk(ByteBuf in, Exception cause) {, +, + // Advance the readerIndex so that ByteToMessageDecoder does not complain, + // when we produced an invalid message without consuming anything., + in.skipBytes(in.readableBytes());, +, + final int oldSize = size;, + size = oldSize;, +, + if (++ size > maxLength)
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java, + new RuntimeException("No matching record type found"),, + private static final RuntimeException NAME_SERVERS_EXHAUSTED_EXCEPTION = ThrowableUtil.unknownStackTrace(, + new RuntimeException("No name servers returned an answer"),, + DnsNameResolverContext.class,, + "tryToFinishResolve(..)");, + DnsRecordType[] recordTypes = parent.resolveRecordTypes();, + assert recordTypes.length > 0;, + final int end = recordTypes.length - 1;, + for (int i = 0; i < end; ++i) {, + if (!query(hostname, recordTypes[i], nameServerAddressStream.duplicate(), promise)) {, + query(hostname, recordTypes[end], nameServerAddressStream, promise);, + private void query(final DnsServerAddressStream nameServerAddrStream, final int nameServerAddrStreamIndex,, + final DnsQuestion question,, + query(nameServerAddrStream, nameServerAddrStreamIndex, question,, + parent.dnsQueryLifecycleObserverFactory().newDnsQueryLifecycleObserver(question), promise);, + private void query(final DnsServerAddressStream nameServerAddrStream,, + final int
[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, + if (logger.isWarnEnabled()) {, +, + }, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, + if (logger.isWarnEnabled()) {, +, + }, +++ b/common/src/main/java/io/netty/util/internal/SharedResourceMisuseDetector.java, + if (logger.isWarnEnabled()) {, + }, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, + if (logger.isWarnEnabled()) {, +, + }, +++ b/common/src/main/java/io/netty/util/internal/SharedResourceMisuseDetector.java, + if (logger.isWarnEnabled()) {, + }, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, + if (logger.isDebugEnabled()) {, + }, +, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, + if (logger.isWarnEnabled()) {, +, + }, +++ b/common/src/main/java/io/netty/util/internal/SharedResourceMisuseDetector.java, + if (logger.isWarnEnabled()) {, + }, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, + if (logger.isDebugEnabled()) {, + }, +, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java, + if (logger.isDebugEnabled()) {, + }, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, + if (logger.isWarnEnabled()) {, +, + }, +++ b/common/src/main/java/io/netty/util/internal/SharedResourceMisuseDetector.java, + if
[+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java, +/**, + * Interface which is shared by others which need to execute outbound logic., + */, +, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java, +/**, + * Interface which is shared by others which need to execute outbound logic., + */, +, +++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java, + * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler}, + * methods, + * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler}, + * methods, + * @param group the {@link EventExecutorGroup} which will be used to execute the {@link ChannelHandler}, + * methods,
[+++ b/microbench/src/main/java/io/netty/microbench/channel/EmbeddedChannelWriteReleaseHandlerContext.java, +import io.netty.channel.ChannelHandlerInvoker;, +import io.netty.channel.EventLoop;, + private final EventLoop eventLoop;, + this.eventLoop = checkNotNull(channel.eventLoop(), "eventLoop");, + return eventLoop;, + }, +, + @Override, + public ChannelHandlerInvoker invoker() {, + return eventLoop.asInvoker();, +++ b/microbench/src/main/java/io/netty/microbench/channel/EmbeddedChannelWriteReleaseHandlerContext.java, +import io.netty.channel.ChannelHandlerInvoker;, +import io.netty.channel.EventLoop;, + private final EventLoop eventLoop;, + this.eventLoop = checkNotNull(channel.eventLoop(), "eventLoop");, + return eventLoop;, + }, +, + @Override, + public ChannelHandlerInvoker invoker() {, + return eventLoop.asInvoker();, +++ b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java, + @Override, +++ b/microbench/src/main/java/io/netty/microbench/channel/EmbeddedChannelWriteReleaseHandlerContext.java, +import io.netty.channel.ChannelHandlerInvoker;, +import io.netty.channel.EventLoop;, + private final EventLoop eventLoop;, + this.eventLoop = checkNotNull(channel.eventLoop(), "eventLoop");, + return eventLoop;, + }, +, + @Override, + public ChannelHandlerInvoker invoker() {, + return
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +import static io.netty.handler.codec.http2.Http2PromisedRequestVerifier.ALWAYS_VERIFY;, + private final Http2PromisedRequestVerifier requestVerifier;, + private Http2PromisedRequestVerifier requestVerifier = ALWAYS_VERIFY;, + public Http2ConnectionDecoder.Builder requestVerifier(Http2PromisedRequestVerifier requestVerifier) {, + this.requestVerifier = requestVerifier;, + return this;, + }, +, + @Override, + requestVerifier = checkNotNull(builder.requestVerifier, "requestVerifier");, + if (!requestVerifier.isAuthoritative(ctx, headers)) {, + throw streamError(promisedStreamId, PROTOCOL_ERROR,, + "Promised request on stream %d for promised stream %d is not authoritative",, + streamId, promisedStreamId);, + }, + if (!requestVerifier.isCacheable(headers)) {, + throw streamError(promisedStreamId, PROTOCOL_ERROR,, + "Promised request on stream %d for promised stream %d is not known to be cacheable",, + streamId, promisedStreamId);, + }, + if (!requestVerifier.isSafe(headers)) {,
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java, +import com.jcraft.jzlib.Deflater;, +import com.jcraft.jzlib.JZlib;, + future.setFailure(ZlibUtil.deflaterException(z, "compression failure", resultCode));, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java, +import com.jcraft.jzlib.Deflater;, +import com.jcraft.jzlib.JZlib;, + future.setFailure(ZlibUtil.deflaterException(z, "compression failure", resultCode));, +++ b/codec/src/main/java/io/netty/handler/codec/compression/ZlibUtil.java, +import com.jcraft.jzlib.Deflater;, +import com.jcraft.jzlib.Inflater;, + static void fail(Inflater z, String message, int resultCode) {, + throw inflaterException(z, message, resultCode);, + static void fail(Deflater z, String message, int resultCode) {, + throw deflaterException(z, message, resultCode);, + }, +, + static CompressionException inflaterException(Inflater z, String message, int resultCode) {, + return new CompressionException(message + " (" + resultCode + ')' + (z.msg != null? ": " + z.msg : ""));, + }, +, + static CompressionException deflaterException(Deflater
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + // Connection has terminated, close the encoder and decoder., + encoder().close();, + decoder().close();, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + // Connection has terminated, close the encoder and decoder., + encoder().close();, + decoder().close();, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/StreamBufferingEncoder.java, +import io.netty.buffer.ByteBufUtil;, +import io.netty.util.ByteString;, + * {@link Http2GoAwayException}., + * Thrown if buffered streams are terminated due to this encoder being closed., + */, + public static final class Http2ChannelClosedException extends Http2Exception {, + private static final long serialVersionUID = 4768543442094476971L;, +, + public Http2ChannelClosedException() {, + super(Http2Error.REFUSED_STREAM, "Connection closed");, + }, + }, +, + /**, + public static final class Http2GoAwayException
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpInvalidMessageTest.java, + assertTrue(dr.isFailure());, + assertTrue(dr.isFailure());, + assertTrue(dr.isFailure());]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CombinedHttpHeaders.java, +import io.netty.handler.codec.Headers;, +import java.util.Map;, + public CombinedHttpHeadersImpl add(Headers<? extends CharSequence, ? extends CharSequence, ?> headers) {, + // Override the fast-copy mechanism used by DefaultHeaders, + if (headers == this) {, + throw new IllegalArgumentException("can't add to itself.");, + }, + if (headers instanceof CombinedHttpHeadersImpl) {, + if (isEmpty()) {, + // Can use the fast underlying copy, + addImpl(headers);, + } else {, + // Values are already escaped so don't escape again, + for (Map.Entry<? extends CharSequence, ? extends CharSequence> header : headers) {, + addEscapedValue(header.getKey(), header.getValue());, + }, + }, + } else {,
[+++ b/common/src/main/java/io/netty/util/internal/logging/AbstractInternalLogger.java]
[+++ b/pom.xml, +++ b/pom.xml, +++ b/src/main/java/org/jboss/netty/container/osgi/NettyBundleActivator.java, + InternalLoggerFactory.getInstance(NettyBundleActivator.class).info("YAY");, +, + ServiceReference logServiceRef =, + ctx.getServiceReference("org.osgi.service.log.LogService");]
[+++ /dev/null, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, + ctx.pipeline().addBefore(ctx.name(), WebSocketServerProtocolHandshakeHandler.class.getName(),, + new WebSocketServerProtocolHandshakeHandler(websocketPath, subprotocols, allowExtensions));, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, + ctx.pipeline().addBefore(ctx.name(), WebSocketServerProtocolHandshakeHandler.class.getName(),, + new WebSocketServerProtocolHandshakeHandler(websocketPath, subprotocols, allowExtensions));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + if (peerCerts == null || peerCerts.length == 0) {, + if (x509PeerCerts == null || x509PeerCerts.length == 0) {, + // No need for null or length > 0 is needed as this is done in getPeerCertificates(), + // already., +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + if (peerCerts == null || peerCerts.length == 0) {, + if (x509PeerCerts == null || x509PeerCerts.length == 0) {, + // No need for null or length > 0 is needed as this is done in getPeerCertificates(), + // already., +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSslGreetingTest.java, +import io.netty.handler.ssl.SslHandler;, +import io.netty.handler.ssl.SslHandshakeCompletionEvent;, +import javax.net.ssl.SSLPeerUnverifiedException;, +import javax.net.ssl.SSLSession;, +, + @Override,
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/handler/timeout/ReadTimeoutException.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2009, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation;
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_unix_FileDescriptor.c, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + ctx.fireUserEventTriggered(Http2ConnectionPrefaceWrittenEvent.INSTANCE);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + ctx.fireUserEventTriggered(Http2ConnectionPrefaceWrittenEvent.INSTANCE);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionPrefaceWrittenEvent.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the, + * "License"); you may not use this file except in compliance with the License. You may obtain a, + * copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
[+++ b/codec/src/main/java/io/netty/handler/codec/EmptyHeaders.java, + return defaultValue;, + return defaultValue;]
[+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/AbstractSctpChannelSink.java, +import io.netty.channel.socket.ChannelRunnableWrapper;
[+++ b/src/docbook/custom.dtd, +<!-- Frequently used URLs -->, +, +<!ENTITY Home "http://www.jboss.org/netty/">, +<!ENTITY Downloads "&Home;downloads.html">, +<!ENTITY Community "&Home;community.html">, +<!ENTITY DocHome "http://www.jboss.org/file-access/default/members/netty/freezone/">, +<!ENTITY API "&DocHome;api/3.0/org/jboss/netty/">, +<!ENTITY XRef "&DocHome;xref/3.0/org/jboss/netty/">, +, +<!-- Types in the bootstrap package -->, +, +<!ENTITY Bootstrap "<ulink url='&API;bootstrap/Bootstrap.html'><classname>Bootstrap</classname></ulink>">, +<!ENTITY ClientBootstrap "<ulink url='&API;bootstrap/ClientBootstrap.html'><classname>ClientBootstrap</classname></ulink>">, +<!ENTITY ServerBootstrap "<ulink url='&API;bootstrap/ServerBootstrap.html'><classname>ServerBootstrap</classname></ulink>">, +, +<!-- Types in the channel package -->, +, +<!ENTITY Channel "<ulink url='&API;channel/Channel.html'><interfacename>Channel</interfacename></ulink>">, +<!ENTITY ChannelDownstreamHandler "<ulink url='&API;channel/ChannelDownstreamHandler.html'><interfacename>ChannelDownstreamHandler</interfacename></ulink>">, +<!ENTITY ChannelFactory "<ulink url='&API;channel/ChannelFactory.html'><interfacename>ChannelFactory</interfacename></ulink>">, +<!ENTITY ChannelHandler "<ulink url='&API;channel/ChannelHandler.html'><interfacename>ChannelHandler</interfacename></ulink>">, +<!ENTITY ChannelHandlerContext "<ulink url='&API;channel/ChannelHandlerContext.html'><interfacename>ChannelHandlerContext</interfacename></ulink>">, +<!ENTITY ChannelPipeline "<ulink url='&API;channel/ChannelPipeline.html'><interfacename>ChannelPipeline</interfacename></ulink>">, +<!ENTITY ChannelPipelineCoverage "<ulink url='&API;channel/ChannelPipelineCoverage.html'><interfacename>ChannelPipelineCoverage</interfacename></ulink>">, +<!ENTITY ChannelUpstreamHandler "<ulink url='&API;channel/ChannelUpstreamHandler.html'><interfacename>ChannelUpstreamHandler</interfacename></ulink>">, +<!ENTITY ExceptionEvent "<ulink url='&API;channel/ExceptionEvent.html'><interfacename>ExceptionEvent</interfacename></ulink>">, +<!ENTITY MessageEvent "<ulink url='&API;channel/MessageEvent.html'><interfacename>MessageEvent</interfacename></ulink>">, +<!ENTITY SimpleChannelHandler "<ulink
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + // If we are currently in the channelReadComplete(...) call we should just ignore the flush., + // We will ensure we trigger ctx.flush() after we processed all Channels later on and, + if (!inFireChannelReadComplete) {]
[+++ b/NOTICE.txt, +This product optionally depends on 'JZlib', a re-implementation of zlib in, +pure Java, which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.jzlib.txt (BSD style License), + * HOMEPAGE:, + * http://www.jcraft.com/jzlib/, +, +++ b/NOTICE.txt, +This product optionally depends on 'JZlib', a re-implementation of zlib in, +pure Java, which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.jzlib.txt (BSD style License), + * HOMEPAGE:, + * http://www.jcraft.com/jzlib/, +, +++ b/license/LICENSE.jzlib.txt, +Copyright (c) 2000,2001,2002,2003,2004 ymnk, JCraft,Inc. All rights reserved., +, +Redistribution and use in source and binary forms, with or without, +modification, are permitted
[+++ b/testsuite/src/main/java/io/netty/testsuite/websockets/autobahn/AutobahnServer.java, + * A Web Socket echo server for running the, + * <a href="http://autobahn.ws/testsuite/">autobahn test suite</a>, +++ b/testsuite/src/main/java/io/netty/testsuite/websockets/autobahn/AutobahnServer.java, + * A Web Socket echo server for running the, + * <a href="http://autobahn.ws/testsuite/">autobahn test suite</a>, +++ b/transport/src/main/java/io/netty/channel/ChannelFuture.java, + * +----> isDone() = true |, + * +--------------------------+ | | isSuccess() = true |, + * | isDone() = false | | +---------------------------+, + * | isSuccess() = false |----+----> isDone() = true |, + * | isCancelled() = false | | | cause() = non-null |, + * +----> isDone() = true |, + * | isCancelled() =
[+++ b/handler/src/main/java/io/netty/handler/ssl/ApplicationProtocolNegotiator.java, + *, + * @deprecated use {@link ApplicationProtocolConfig}, +@SuppressWarnings("deprecation"), +++ b/handler/src/main/java/io/netty/handler/ssl/ApplicationProtocolNegotiator.java, + *, + * @deprecated use {@link ApplicationProtocolConfig}, +@SuppressWarnings("deprecation"), +++ b/handler/src/main/java/io/netty/handler/ssl/JdkAlpnApplicationProtocolNegotiator.java, + *, + * @deprecated use {@link ApplicationProtocolConfig}., +@Deprecated, +++ b/handler/src/main/java/io/netty/handler/ssl/ApplicationProtocolNegotiator.java, + *, + * @deprecated use {@link ApplicationProtocolConfig}, +@SuppressWarnings("deprecation"), +++ b/handler/src/main/java/io/netty/handler/ssl/JdkAlpnApplicationProtocolNegotiator.java, + *, + * @deprecated use {@link ApplicationProtocolConfig}., +@Deprecated, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkApplicationProtocolNegotiator.java, + *, + * @deprecated use {@link ApplicationProtocolConfig}, +@Deprecated, +++ b/handler/src/main/java/io/netty/handler/ssl/ApplicationProtocolNegotiator.java, + *, + * @deprecated use {@link ApplicationProtocolConfig}, +@SuppressWarnings("deprecation"), +++ b/handler/src/main/java/io/netty/handler/ssl/JdkAlpnApplicationProtocolNegotiator.java, + *, + * @deprecated use {@link ApplicationProtocolConfig}., +@Deprecated, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkApplicationProtocolNegotiator.java, + *, + * @deprecated use {@link ApplicationProtocolConfig}, +@Deprecated,
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, +import sun.nio.ch.DirectBuffer;, + Cleaner cleaner = ((DirectBuffer) buffer).cleaner();, + if (!(buffer instanceof DirectBuffer)) {, + Cleaner cleaner = ((DirectBuffer) buffer).cleaner();]
[+++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/example/src/main/java/io/netty/example/portunification/PortUnificationServerHandler.java, + // Will use the first five bytes to detect a protocol., + if (in.readableBytes() < 5) {, + if (isSsl(in)) {, + enableSsl(ctx);, + } else {, + if (isGzip(magic1, magic2)) {, + }, + private boolean isSsl(ByteBuf buf) {, + return SslHandler.isEncrypted(buf);]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslCertificateException.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + @Test(timeout = 10000), +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + @Test(timeout = 10000), +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, + if (logger.isWarnEnabled()) {, +, + }, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + @Test(timeout = 10000), +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, + if (logger.isWarnEnabled()) {, +, + }, +++ b/common/src/main/java/io/netty/util/internal/SharedResourceMisuseDetector.java, + if (logger.isWarnEnabled()) {, + }, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + @Test(timeout = 10000), +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, + if (logger.isWarnEnabled()) {, +, + }, +++ b/common/src/main/java/io/netty/util/internal/SharedResourceMisuseDetector.java, + if (logger.isWarnEnabled()) {, + }, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, + if (logger.isDebugEnabled()) {, + }, +, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + @Test(timeout = 10000), +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, + if (logger.isWarnEnabled()) {, +, + }, +++ b/common/src/main/java/io/netty/util/internal/SharedResourceMisuseDetector.java, + if (logger.isWarnEnabled()) {, + },
[+++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, + ch.pipeline().addLast(, + new LoggingHandler(LogLevel.INFO),, + new EchoClientHandler(firstMessageSize));, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, + ch.pipeline().addLast(, + new LoggingHandler(LogLevel.INFO),, + new EchoClientHandler(firstMessageSize));, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + ch.pipeline().addLast(, + new LoggingHandler(LogLevel.INFO),, + new EchoServerHandler());, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, + ch.pipeline().addLast(, + new LoggingHandler(LogLevel.INFO),, + new EchoClientHandler(firstMessageSize));, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + ch.pipeline().addLast(, + new LoggingHandler(LogLevel.INFO),, + new EchoServerHandler());, +++ b/transport/src/main/java/io/netty/channel/ChannelBootstrap.java, + p.addLast(DefaultChannelPipeline.generateName(initializer), initializer);, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, + ch.pipeline().addLast(, + new LoggingHandler(LogLevel.INFO),, + new EchoClientHandler(firstMessageSize));, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + ch.pipeline().addLast(, + new LoggingHandler(LogLevel.INFO),, + new EchoServerHandler());, +++ b/transport/src/main/java/io/netty/channel/ChannelBootstrap.java, + p.addLast(DefaultChannelPipeline.generateName(initializer), initializer);, +++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java, + ChannelPipeline addFirst(String name, ChannelHandler handler);, + ChannelPipeline addLast(String name, ChannelHandler handler);, + ChannelPipeline addBefore(String baseName, String
[+++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxyBackendHandler.java]
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java, + // As java.nio.ServerSocketChannel.isBound() will continue to return true even after the channel was closed, + // we will also need to check if it is open., + return isOpen() && javaChannel().socket().isBound();, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java, + // As java.nio.ServerSocketChannel.isBound() will continue to return true even after the channel was closed, + // we will also need to check if it is open., + return isOpen() && javaChannel().socket().isBound();, +++ b/transport/src/test/java/io/netty/channel/socket/nio/NioServerSocketChannelTest.java, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelFuture;, + @Test, + public void testIsActiveFalseAfterClose() {, + NioServerSocketChannel serverSocketChannel = new NioServerSocketChannel();, + EventLoopGroup group = new NioEventLoopGroup(1);, + try {, + group.register(serverSocketChannel).syncUninterruptibly();, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/ExtendedOpenSslSession.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/src/docbook/en-US/module/architecture.xml, + feature standpoint. Netty has a simple, yet powerful architecture., + difficult to understand the more advanced features which were covered, + briefly in this chapter., + You might still have unanswered questions about what the overall, + architecture looks like exactly and how each of the features work, + together. If so, it is a good idea to, + <ulink url="&Community;">talk to us</ulink> to improve this guide.]
[+++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java, + * inbound and outbount operations of a {@link Channel}. {@link ChannelPipeline}, + * For each new channel, a new pipeline iscreated and attached to the, + * the current pipeline from it. All of this is handled for you and you not need, + * to take care of this., + *, + * The following diagram describes how I/O is processed by, + * A I/O-operation can be handled by either a {@link ChannelInboundHandler}, + * or a {@link ChannelOutboundHandler} and be forwarded to the closest, + * handler by calling either one of the
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractChannelBufferTest.java, + assertEquals(buffer.getByte(readerIndex), duplicate.getByte(readerIndex));, + assertEquals(buffer.getByte(1), duplicate.getByte(1));, +++ b/buffer/src/test/java/io/netty/buffer/AbstractChannelBufferTest.java, + assertEquals(buffer.getByte(readerIndex), duplicate.getByte(readerIndex));, + assertEquals(buffer.getByte(1), duplicate.getByte(1));, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeChannelBufferTest.java, +import org.junit.Test;, +import static io.netty.buffer.Unpooled.*;, +import static org.junit.Assert.*;, + assertEquals(5, buf.componentAtOffset(2).capacity());, + assertEquals(12, header.readableBytes());, + assertEquals(512, payload.readableBytes());, +++ b/buffer/src/test/java/io/netty/buffer/AbstractChannelBufferTest.java, + assertEquals(buffer.getByte(readerIndex), duplicate.getByte(readerIndex));, + assertEquals(buffer.getByte(1), duplicate.getByte(1));, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeChannelBufferTest.java, +import org.junit.Test;, +import static io.netty.buffer.Unpooled.*;, +import static org.junit.Assert.*;, + assertEquals(5, buf.componentAtOffset(2).capacity());, + assertEquals(12, header.readableBytes());, + assertEquals(512, payload.readableBytes());, +++ b/buffer/src/test/java/io/netty/buffer/ChannelBuffersTest.java, +import org.easymock.EasyMock;, +import org.junit.Test;, +import static io.netty.buffer.Unpooled.*;, +import static org.junit.Assert.*;, + assertEquals(12, header.readableBytes());, + assertEquals(512, payload.readableBytes());, + assertTrue(buffer.readBoolean());, + assertFalse(buffer.readBoolean());, +++ b/buffer/src/test/java/io/netty/buffer/AbstractChannelBufferTest.java, + assertEquals(buffer.getByte(readerIndex), duplicate.getByte(readerIndex));, + assertEquals(buffer.getByte(1), duplicate.getByte(1));, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeChannelBufferTest.java, +import org.junit.Test;, +import static io.netty.buffer.Unpooled.*;,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java, + // it must reply with a RST_STREAM with error code INVALID_STREAM., + // If a client receives a SYN_STREAM with isLast set,, + // reply with a RST_STREAM with error code PROTOCOL_ERROR, + // (we only support pushed resources divided into two header blocks)., + if (spdySynStreamFrame.isLast()) {, + FullHttpRequest httpRequestWithEntity = createHttpRequest(spdyVersion, spdySynStreamFrame);, + // Set the Stream-ID, Associated-To-Stream-ID, iand Priority as headers, + httpRequestWithEntity.headers().setInt(Names.STREAM_ID, streamId);, + httpRequestWithEntity.headers().setInt(Names.ASSOCIATED_TO_STREAM_ID, associatedToStreamId);, + httpRequestWithEntity.headers().setInt(Names.PRIORITY, spdySynStreamFrame.priority());, + out.add(httpRequestWithEntity);, +, + // HEADERS frames may initiate a pushed response, + if (SpdyCodecUtil.isServerId(streamId)) {, +, + // If a client receives
[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, +import io.netty.util.internal.StringUtil;, + throw new InterruptedException(toString());, + throw new InterruptedException(toString());, + throw new BlockingOperationException(toString());, + throw new IllegalStateException("complete already: " + this);, + throw new IllegalStateException("complete already: " + this, cause);, + return false;, + return false;, + throw new IllegalStateException("too many waiters: " + this);, +, + @Override, + public String toString() {, + return toStringBuilder().toString();, + }, +, + protected StringBuilder toStringBuilder() {, + StringBuilder buf = new StringBuilder(64);, + buf.append(StringUtil.simpleClassName(this));, + buf.append('@');, + buf.append(Integer.toHexString(hashCode()));, +, + Object result = this.result;, + if (result == SUCCESS) {, + buf.append("(success)");, + } else if (result ==
[+++ b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteAcceptorChannelTest.java, + assertEquals(BufType.BYTE, new NioUdtByteAcceptorChannel().metadata().bufferType());, +++ b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteAcceptorChannelTest.java, + assertEquals(BufType.BYTE, new NioUdtByteAcceptorChannel().metadata().bufferType());, +++ b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteConnectorChannelTest.java, + assertEquals(BufType.BYTE, new NioUdtByteConnectorChannel().metadata().bufferType());, +++ b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteAcceptorChannelTest.java, + assertEquals(BufType.BYTE, new NioUdtByteAcceptorChannel().metadata().bufferType());, +++ b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteConnectorChannelTest.java, + assertEquals(BufType.BYTE, new NioUdtByteConnectorChannel().metadata().bufferType());, +++ b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteRendezvousChannelTest.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, + private static final InternalLogger log = InternalLoggerFactory.getInstance(NioUdtByteAcceptorChannelTest.class);, + assertEquals(BufType.BYTE, new NioUdtByteRendezvousChannel().metadata().bufferType());, + log.info("progress : {} {}", handler1.meter().count(), handler2, + log.info("handler1 : {}", handler1.meter().count());, + log.info("handler2 : {}", handler2.meter().count());, +++ b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteAcceptorChannelTest.java, + assertEquals(BufType.BYTE, new NioUdtByteAcceptorChannel().metadata().bufferType());, +++ b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteConnectorChannelTest.java, + assertEquals(BufType.BYTE, new NioUdtByteConnectorChannel().metadata().bufferType());, +++ b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtByteRendezvousChannelTest.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, + private static final InternalLogger log = InternalLoggerFactory.getInstance(NioUdtByteAcceptorChannelTest.class);, + assertEquals(BufType.BYTE, new NioUdtByteRendezvousChannel().metadata().bufferType());, + log.info("progress : {}
[+++ b/pom.xml, +++ b/pom.xml, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * <p>, + * Also be aware that obtaining derived buffers will NOT call {@link #retain()} and so the, + * reference count will NOT be increased., + * <p>, + * Also be aware that this method will NOT call {@link #retain()} and so the, + * reference count will NOT be increased., + * <p>, + * Also be aware that this method will NOT call {@link #retain()} and so the, + * reference count will NOT be increased., + * <p>, + * Also be aware that this method will NOT call {@link
[+++ b/resolver/src/main/java/io/netty/resolver/InetSocketAddressResolver.java, +, + @Override, + public void close() {, + nameResolver.close();, + }, +++ b/resolver/src/main/java/io/netty/resolver/InetSocketAddressResolver.java, +, + @Override, + public void close() {, + nameResolver.close();, + }, +++ b/resolver/src/test/java/io/netty/resolver/InetSocketAddressResolverTest.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed
[+++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/CompressorHttp2ConnectionEncoder.java, + * A decorating HTTP2 encoder that will compress data frames according to the {@code content-encoding} header for each, + * stream. The compression provided by this class will be applied to the data for the entire stream., +public class CompressorHttp2ConnectionEncoder extends DecoratingHttp2ConnectionEncoder {, + public static final int DEFAULT_COMPRESSION_LEVEL = 6;, + public static final int DEFAULT_WINDOW_BITS = 15;, + public static final int DEFAULT_MEM_LEVEL = 8;, +, + public CompressorHttp2ConnectionEncoder(Http2ConnectionEncoder delegate) {, + this(delegate, DEFAULT_COMPRESSION_LEVEL, DEFAULT_WINDOW_BITS, DEFAULT_MEM_LEVEL);, + }, + public CompressorHttp2ConnectionEncoder(Http2ConnectionEncoder delegate, int compressionLevel, int windowBits,, + int memLevel) {, + super(delegate);, + if
[+++ b/COPYRIGHT.txt, +beve Daniel Bevenius]
[+++ b/pom.xml, + <!-- XXX: maven-release-plugin complains - MRELEASE-715 -->, + <!--, + -->]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, + if (trustCertChainFile != null) {, + trustManagerFactory = buildTrustManagerFactory(trustCertChainFile, trustManagerFactory);, + } else if (trustManagerFactory == null) {, + trustManagerFactory.init((KeyStore) null);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, +import io.netty.handler.codec.DefaultHeaders;, +import io.netty.handler.codec.DefaultTextHeaders.CharSequenceConverter;, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.TreeMap;, +, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, + this(validate, false);, + protected DefaultHttpHeaders(boolean validate, boolean singleHeaderFields) {, + this(true, validate ? HeaderNameValidator.INSTANCE : DefaultTextHeaders.NO_NAME_VALIDATOR, singleHeaderFields);, + protected DefaultHttpHeaders(boolean validate,, + DefaultHeaders.NameValidator<CharSequence> nameValidator,, + headers = new DefaultTextHeaders(, + new TreeMap<CharSequence, Object>(AsciiString.CHARSEQUENCE_CASE_INSENSITIVE_ORDER),, + nameValidator,, + validate ? HeaderValueConverterAndValidator.INSTANCE : HeaderValueConverter.INSTANCE,, + singleHeaderFields);, + return headers.getShort(name, defaultValue);, + public List<Entry<String, String>> entries() {, + if (isEmpty()) {, + return Collections.emptyList();, + }, + List<Entry<String, String>> entriesConverted = new ArrayList<Entry<String, String>>(, + headers.size());, + for (Entry<String, String> entry : this) {, + entriesConverted.add(entry);,
[+++ b/transport/src/main/java/io/netty/channel/DefaultEventLoopGroup.java, + this(nThreads, (ThreadFactory) null);, + /**, + * Create a new instance, + *, + * @param nThreads the number of threads to use, + * @param executor the Executor to use, or {@code null} if the default should be used., + */, + public DefaultEventLoopGroup(int nThreads, Executor executor) {, + super(nThreads, executor);, + }, +]
[+++ b/.gitignore, +/src/main/java/io/netty/util/Version.java, +++ b/.gitignore, +/src/main/java/io/netty/util/Version.java, +++ b/pom.xml, + <echo message="// DO NOT MODIFY - WILL BE OVERWRITTEN DURING THE BUILD PROCESS${line.separator}package io.netty.util;${line.separator}/**${line.separator} * Provides the version information of Netty.${line.separator} * @apiviz.landmark${line.separator} */${line.separator}public final class Version {${line.separator} /** The version identifier. */${line.separator} public static final String ID = &quot;${project.version}-${buildNumber}&quot;;${line.separator} /** Prints out the version identifier to stdout. */${line.separator} public static void main(String[] args) { System.out.println(ID); }${line.separator} private Version() { super(); }${line.separator}}${line.separator}" file="${basedir}/src/main/java/io/netty/util/Version.java" />, +++ b/.gitignore, +/src/main/java/io/netty/util/Version.java, +++ b/pom.xml, + <echo message="// DO NOT MODIFY - WILL BE OVERWRITTEN DURING THE BUILD PROCESS${line.separator}package io.netty.util;${line.separator}/**${line.separator} * Provides the version information of
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + * {@link ByteBuf#release()} ownership of {@code buffer} is transferred to this {@link CompositeByteBuf}., + * @param buffer the {@link ByteBuf} to add. {@link ByteBuf#release()} ownership is transferred to this, + * {@link ByteBuf#release()} ownership of all {@link ByteBuf} objects in {@code buffers} is transferred to this, + * ownership of all {@link ByteBuf} objects is transferred to this {@link CompositeByteBuf}., + * {@link ByteBuf#release()} ownership of all {@link ByteBuf} objects in {@code buffers} is transferred to this, + * ownership of all {@link ByteBuf} objects is transferred to this {@link CompositeByteBuf}., + * {@link ByteBuf#release()} ownership
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + decodeString(decoder, buffer.internalNioBuffer(0, len), dst);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + decodeString(decoder, buffer.internalNioBuffer(0, len), dst);, +++ b/buffer/src/test/java/io/netty/buffer/ByteBufUtilTest.java, +, + @Test, + public void testToStringDoesNotThrowIndexOutOfBounds() {, + CompositeByteBuf buffer = Unpooled.compositeBuffer();, + try {, + byte[] bytes = "1234".getBytes(CharsetUtil.UTF_8);, + buffer.addComponent(Unpooled.buffer(bytes.length).writeBytes(bytes));, + buffer.addComponent(Unpooled.buffer(bytes.length).writeBytes(bytes));, + Assert.assertEquals("1234", buffer.toString(bytes.length, bytes.length, CharsetUtil.UTF_8));, + } finally {, + buffer.release();, + }, + }]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java, + private final boolean decompressConcatenated;, + this(ZlibWrapper.ZLIB, null, false);, + this(ZlibWrapper.ZLIB, dictionary, false);, + this(wrapper, null, false);, + public JdkZlibDecoder(ZlibWrapper wrapper, boolean decompressConcatenated) {, + this(wrapper, null, decompressConcatenated);, + }, +, + public JdkZlibDecoder(boolean decompressConcatenated) {, + this(ZlibWrapper.GZIP, null, decompressConcatenated);, + }, +, + private JdkZlibDecoder(ZlibWrapper wrapper, byte[] dictionary, boolean decompressConcatenated) {, + this.decompressConcatenated = decompressConcatenated;, + finished = !decompressConcatenated;, +, + if (!finished) {, + inflater.reset();, + crc.reset();, + gzipState = GzipState.HEADER_START;, + }, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java, + private final boolean decompressConcatenated;, + this(ZlibWrapper.ZLIB, null, false);, + this(ZlibWrapper.ZLIB, dictionary, false);, + this(wrapper, null, false);, + public JdkZlibDecoder(ZlibWrapper
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseDecoder.java, + int checked = 0;, + int length = buf.writerIndex();, + // check for loops, + checked += 2;, + if (checked >= length) {, + return null;, + }, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseDecoder.java, + int checked = 0;, + int length = buf.writerIndex();, + // check for loops, + checked += 2;, + if (checked >= length) {, + return null;, + }, +++ b/codec-dns/src/test/java/io/netty/handler/codec/dns/DnsResponseTest.java, +import io.netty.handler.codec.DecoderException;, +import org.junit.Rule;, +import org.junit.rules.ExpectedException;, + private static final byte[] malformedLoopPacket = { 0, 4, -127, -128, 0, 1, 0, 0, 0, 0, 0, 0, -64, 12, 0, 1, 0, 1 };,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeaders.java, + this(true);, + }, +, + public DefaultSpdyHeaders(boolean validate) {, + super(CASE_INSENSITIVE_HASHER,, + validate ? HeaderValueConverterAndValidator.INSTANCE : HeaderValueConverter.INSTANCE,, + validate ? SpydNameValidator : NameValidator.NOT_NULL);, + private static class HeaderValueConverter extends CharSequenceValueConverter {, + public static final HeaderValueConverter INSTANCE = new HeaderValueConverter();, + return seq;, + }, + }, +, + private static final class HeaderValueConverterAndValidator extends HeaderValueConverter {, + public static final HeaderValueConverterAndValidator INSTANCE = new HeaderValueConverterAndValidator();, +, + @Override, + public CharSequence convertObject(Object value) {, + final CharSequence seq = super.convertObject(value);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeaders.java, + this(true);, + }, +, + public DefaultSpdyHeaders(boolean validate) {, + super(CASE_INSENSITIVE_HASHER,, +
[+++ b/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtChannelConfig.java, + private volatile int protocolReceiveBufferSize = 10 * M;, + private volatile int protocolSendBufferSize = 10 * M;, + private volatile int systemSendBufferSize = M;, + return protocolReceiveBufferSize;, + public UdtChannelConfig setProtocolReceiveBufferSize(final int protocolReceiveBufferSize) {, + this.protocolReceiveBufferSize = protocolReceiveBufferSize;, + return protocolSendBufferSize;, + final int protocolSendBufferSize) {, + this.protocolSendBufferSize = protocolSendBufferSize;, + final int systemSendBufferSize) {, + this.systemSendBufferSize = systemSendBufferSize;, + return systemSendBufferSize;, +++ b/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtChannelConfig.java, + private volatile int protocolReceiveBufferSize = 10 * M;, + private volatile int protocolSendBufferSize = 10 * M;, + private volatile int systemSendBufferSize = M;, + return protocolReceiveBufferSize;, + public UdtChannelConfig setProtocolReceiveBufferSize(final
[+++ b/src/docbook/master.xml, + <!-- The following chapters are not written yet. -->, + <!--, + -->]
[+++ b/handler/src/main/java/io/netty/handler/ssl/IdentityCipherSuiteFilter.java, +import java.util.ArrayList;, + List<String> newCiphers = new ArrayList<String>(supportedCiphers.size());, +++ b/handler/src/main/java/io/netty/handler/ssl/IdentityCipherSuiteFilter.java, +import java.util.ArrayList;, + List<String> newCiphers = new ArrayList<String>(supportedCiphers.size());, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import java.util.ArrayList;, + List<String> enabled = new ArrayList<String>(6);, +++ b/handler/src/main/java/io/netty/handler/ssl/IdentityCipherSuiteFilter.java, +import java.util.ArrayList;, + List<String> newCiphers = new ArrayList<String>(supportedCiphers.size());, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import java.util.ArrayList;, + List<String> enabled = new ArrayList<String>(6);, +++ b/handler/src/main/java/io/netty/handler/ssl/SupportedCipherSuiteFilter.java, +import java.util.ArrayList;, + newCiphers = new ArrayList<String>(defaultCiphers.size());, + newCiphers = new ArrayList<String>(supportedCiphers.size());, +++ b/handler/src/main/java/io/netty/handler/ssl/IdentityCipherSuiteFilter.java, +import java.util.ArrayList;, + List<String> newCiphers = new ArrayList<String>(supportedCiphers.size());, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import java.util.ArrayList;, + List<String> enabled = new ArrayList<String>(6);, +++ b/handler/src/main/java/io/netty/handler/ssl/SupportedCipherSuiteFilter.java, +import java.util.ArrayList;, + newCiphers = new ArrayList<String>(defaultCiphers.size());, + newCiphers = new ArrayList<String>(supportedCiphers.size());, +++
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, + if (!buffer.isReadable()) {, + return null;, + }, + loop: do {, + } while (buffer.isReadable());]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/Encoder.java, +import static io.netty.handler.codec.http2.internal.hpack.HpackUtil.equalsConstantTime;, + // To avoid short circuit behavior a bitwise operator is used instead of a boolean operator., + if (e.hash == h && (equalsConstantTime(name, e.name) & equalsConstantTime(value, e.value)) != 0) {, + if (e.hash == h && equalsConstantTime(name, e.name) != 0) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/Encoder.java, +import static io.netty.handler.codec.http2.internal.hpack.HpackUtil.equalsConstantTime;, + // To avoid short circuit behavior a bitwise operator is used instead of a boolean operator., + if (e.hash == h && (equalsConstantTime(name, e.name) & equalsConstantTime(value, e.value)) != 0) {, + if (e.hash == h && equalsConstantTime(name, e.name) != 0) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/internal/hpack/HeaderField.java, +import static io.netty.handler.codec.http2.internal.hpack.HpackUtil.equalsConstantTime;,
[+++ b/transport/src/main/java/io/netty/channel/ChannelInboundInvoker.java, +interface ChannelInboundInvoker {, +++ b/transport/src/main/java/io/netty/channel/ChannelInboundInvoker.java, +interface ChannelInboundInvoker {, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java, +interface ChannelOutboundInvoker {]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + // Clear out options which disable protocols, + SSL.clearOptions(ssl, SSL.SSL_OP_NO_SSLv2 | SSL.SSL_OP_NO_SSLv3 | SSL.SSL_OP_NO_TLSv1 |, + SSL.SSL_OP_NO_TLSv1_1 | SSL.SSL_OP_NO_TLSv1_2);, +, + int opts = 0;, + opts |= SSL.SSL_OP_NO_SSLv2;, + opts |= SSL.SSL_OP_NO_SSLv3;, + opts |= SSL.SSL_OP_NO_TLSv1;, + opts |= SSL.SSL_OP_NO_TLSv1_1;, + opts |= SSL.SSL_OP_NO_TLSv1_2;, +, + // Disable protocols we do not want, + SSL.setOptions(ssl, opts);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + // Clear out options which disable protocols, + SSL.clearOptions(ssl, SSL.SSL_OP_NO_SSLv2 | SSL.SSL_OP_NO_SSLv3 | SSL.SSL_OP_NO_TLSv1 |, + SSL.SSL_OP_NO_TLSv1_1 | SSL.SSL_OP_NO_TLSv1_2);, +, + int opts = 0;, + opts |= SSL.SSL_OP_NO_SSLv2;, + opts |= SSL.SSL_OP_NO_SSLv3;, + opts |=
[+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + // Dereference everything so GC can do it's work., + chunk = null;, + tmpNioBuf = null;, + initThread = null;, + memory = null;, +]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/CompressorHttp2ConnectionEncoder.java, + private final Http2Connection.PropertyKey propertyKey;, + propertyKey = connection().newKey();, + connection().addListener(new Http2ConnectionAdapter() {, + @Override, + public void onStreamRemoved(Http2Stream stream) {, + final EmbeddedChannel compressor = stream.getProperty(propertyKey);, + if (compressor != null) {, + cleanup(stream, compressor);, + }, + }, + });, + final EmbeddedChannel channel = stream == null ? null : (EmbeddedChannel) stream.getProperty(propertyKey);, + EmbeddedChannel compressor = stream.getProperty(propertyKey);, + stream.setProperty(propertyKey, compressor);, + void cleanup(Http2Stream stream, EmbeddedChannel compressor) {, + stream.removeProperty(propertyKey);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/CompressorHttp2ConnectionEncoder.java, + private final Http2Connection.PropertyKey propertyKey;, + propertyKey = connection().newKey();, + connection().addListener(new Http2ConnectionAdapter() {, + @Override, + public void onStreamRemoved(Http2Stream stream) {, + final
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + Runnable postTask = null;, + postTask = doDeregister();, +, + if (postTask != null) {, + postTask.run();, + }, + * You can return a {@link Runnable} which will be run as post-task of the registration process., + protected Runnable doDeregister() throws Exception {, + return null;, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + Runnable postTask = null;, + postTask = doDeregister();, +, + if (postTask != null) {, + postTask.run();, + }, + * You can return a {@link Runnable} which will be run as post-task of the registration process., + protected Runnable doDeregister() throws Exception {, + return
[+++ b/common/src/main/java/io/netty/util/DomainNameMapping.java]
[+++ b/README.md, +- __3__ branch contains code for Netty 3.x, +++ b/README.md, +- __3__ branch contains code for Netty 3.x, +++ b/all/.gitignore, +src, +++ b/README.md, +- __3__ branch contains code for Netty 3.x, +++ b/all/.gitignore, +src, +++ b/all/pom.xml, + <id>clean-src</id>, + <phase>clean</phase>, + <goals>, + <goal>clean</goal>, + </goals>, + <configuration>, + <filesets>, + <fileset>, + <directory>${project.basedir}/src</directory>, + <followSymlinks>false</followSymlinks>, + <useDefaultExcludes>false</useDefaultExcludes>, + </fileset>, + <fileset>, + <directory>${project.basedir}/target</directory>, + <followSymlinks>false</followSymlinks>, + </fileset>, + </filesets>, + </configuration>, + </execution>, + <execution>, + <id>clean-all</id>, + <configuration>, + <filesets>, + <fileset>, + <directory>${project.basedir}/src</directory>, + <followSymlinks>false</followSymlinks>, + <useDefaultExcludes>false</useDefaultExcludes>, + </fileset>, + <fileset>, + <directory>${project.basedir}/target</directory>, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, +, + sanitizeHeadersBeforeEncode(m, state == ST_CONTENT_ALWAYS_EMPTY);, +, + encodeHeaders(m.headers(), buf);, + ByteBufUtil.writeShortBE(buf, CRLF_SHORT);, +, + headersEncodedSizeAccumulator = HEADERS_WEIGHT_NEW * padSizeForAccumulation(buf.readableBytes()) +, + HEADERS_WEIGHT_HISTORICAL * headersEncodedSizeAccumulator;, + * Allows to sanitize headers of the message before encoding these., + */, + protected void sanitizeHeadersBeforeEncode(@SuppressWarnings("unused") H msg, boolean isAlwaysEmpty) {, + // noop, + }, +, + /**, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, +, + sanitizeHeadersBeforeEncode(m, state == ST_CONTENT_ALWAYS_EMPTY);, +, + encodeHeaders(m.headers(), buf);, + ByteBufUtil.writeShortBE(buf, CRLF_SHORT);, +, + headersEncodedSizeAccumulator = HEADERS_WEIGHT_NEW * padSizeForAccumulation(buf.readableBytes()) +, + HEADERS_WEIGHT_HISTORICAL * headersEncodedSizeAccumulator;, + * Allows to sanitize headers of the message before encoding these., + */,
[+++ b/common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, + protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception {, + String contentEncoding = headers.headers().get(HttpHeaders.Names.CONTENT_ENCODING);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, + protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception {, + String contentEncoding = headers.headers().get(HttpHeaders.Names.CONTENT_ENCODING);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + * {@link EmbeddedByteChannel}, which is created by {@link #beginEncode(HttpResponse, String)}., + * {@link #beginEncode(HttpResponse, String)}., + * {@link #beginEncode(HttpResponse, String)} should return {@code null} so that, + * and implement {@link #beginEncode(HttpResponse, String)} properly to make, +public abstract class HttpContentEncoder extends MessageToMessageCodec<HttpRequest, HttpObject> {, +, + private enum State {, + PASS_THROUGH,, + AWAIT_HEADERS,, + AWAIT_CONTENT, + }, + private String acceptEncoding;,
[+++ b/pom.xml, + <version>3.1.0.BETA1</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.1.0.BETA1</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.1.0.BETA1</developerConnection>]
[+++ b/buffer/src/test/java/io/netty/buffer/AdvancedLeakAwareByteBufTest.java, +import io.netty.util.ResourceLeakTracker;, +, + protected SimpleLeakAwareByteBuf wrap(ByteBuf buffer, ResourceLeakTracker<ByteBuf> tracker) {, + return new AdvancedLeakAwareByteBuf(buffer, tracker);, +++ b/buffer/src/test/java/io/netty/buffer/AdvancedLeakAwareByteBufTest.java, +import io.netty.util.ResourceLeakTracker;, +, + protected SimpleLeakAwareByteBuf wrap(ByteBuf buffer, ResourceLeakTracker<ByteBuf> tracker) {, + return new AdvancedLeakAwareByteBuf(buffer, tracker);, +++ b/buffer/src/test/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBufTest.java, +import io.netty.util.ResourceLeakTracker;, +, + protected SimpleLeakAwareCompositeByteBuf wrap(CompositeByteBuf buffer, ResourceLeakTracker<ByteBuf> tracker) {, + return new AdvancedLeakAwareCompositeByteBuf(buffer, tracker);, +++ b/buffer/src/test/java/io/netty/buffer/AdvancedLeakAwareByteBufTest.java, +import io.netty.util.ResourceLeakTracker;, +, + protected SimpleLeakAwareByteBuf wrap(ByteBuf buffer, ResourceLeakTracker<ByteBuf> tracker) {, + return new AdvancedLeakAwareByteBuf(buffer, tracker);, +++ b/buffer/src/test/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBufTest.java, +import io.netty.util.ResourceLeakTracker;, +, + protected SimpleLeakAwareCompositeByteBuf wrap(CompositeByteBuf buffer, ResourceLeakTracker<ByteBuf> tracker) {, + return new AdvancedLeakAwareCompositeByteBuf(buffer, tracker);, +++ b/buffer/src/test/java/io/netty/buffer/SimpleLeakAwareByteBufTest.java, +import io.netty.util.ResourceLeakTracker;, +import org.junit.After;, +import org.junit.Before;, +import
[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventListeners.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, + spdyDataFrame.data().readSlice(initialReceiveWindowSize).retain());, + spdyDataFrame.data().readSlice(sendWindowSize).retain());, + spdyDataFrame.data().readSlice(newWindowSize).retain());]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, + p.get(HttpRequestDecoder.class).replace("wsdecoder",, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, + p.get(HttpRequestDecoder.class).replace("wsdecoder",, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java, + p.get(HttpRequestDecoder.class).replace("wsdecoder",, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, + p.get(HttpRequestDecoder.class).replace("wsdecoder",, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java, + p.get(HttpRequestDecoder.class).replace("wsdecoder",, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java, + p.get(HttpRequestDecoder.class).replace("wsdecoder",]
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java, +import io.netty.buffer.ByteBuf;, + ByteBuf expected = Unpooled.wrappedBuffer(otherData);, + ByteBuf buffer = ch.readInbound();, + try {, + assertEquals(expected, buffer);, + } finally {, + expected.release();, + if (buffer != null) {, + buffer.release();, + }, + }]
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddresses.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/handler/src/main/java/io/netty/handler/stream/ChunkedFile.java, + private long offset;, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedFile.java, + private long offset;, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedInput.java, + * Releases the resources associated with the input., +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedFile.java, + private long offset;, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedInput.java, + * Releases the resources associated with the input., +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedNioFile.java, + private long offset;, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedFile.java, + private long offset;, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedInput.java, + * Releases the resources associated with the input., +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedNioFile.java, + private long offset;, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedNioStream.java, + private long offset;, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedFile.java, + private long offset;, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedInput.java, + * Releases the resources associated with the input., +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedNioFile.java, + private long offset;, +++
[+++ b/transport/src/main/java/io/netty/channel/Channel.java, + * automaticly closed via {@link FileRegion#close()}., +++ b/transport/src/main/java/io/netty/channel/Channel.java, + * automaticly closed via {@link FileRegion#close()}., +++ b/transport/src/main/java/io/netty/channel/ChannelOperationHandlerAdapter.java, + /**, + * Do nothing by default, sub-classes may override this method., + */, + /**, + * Do nothing by default, sub-classes may override this method., + */, + /**, + * Do nothing by default, sub-classes may override this method., + */, + /**, + * Do nothing by default, sub-classes may override this method., + */, + /**, + * Calls {@link ChannelHandlerContext#fireExceptionCaught(Throwable)} to forward, + * to the next {@link ChannelHandler} in the {@link
[+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheObject.java, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheObject.java, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java, +import io.netty.channel.ChannelPipeline;, + * after MemcacheObjectDecoder in the {@link ChannelPipeline}., +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheObject.java, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java, +import io.netty.channel.ChannelPipeline;, + * after MemcacheObjectDecoder in the {@link ChannelPipeline}., +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheObjectAggregator.java, +import io.netty.channel.ChannelHandler;, +import io.netty.channel.ChannelPipeline;, +import io.netty.handler.codec.memcache.binary.BinaryMemcacheRequestDecoder;, +import io.netty.handler.codec.memcache.binary.BinaryMemcacheResponseEncoder;, + * A {@link ChannelHandler} that aggregates an {@link MemcacheMessage}, + * handler after a MemcacheObjectDecoder in the {@link ChannelPipeline}., + * {@link ChannelPipeline} p = ...;, + * p.addLast("decoder", new {@link BinaryMemcacheRequestDecoder}());, + * p.addLast("encoder", new {@link BinaryMemcacheResponseEncoder}());, + protected MemcacheObjectAggregator(int maxContentLength) {, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheObject.java, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheContent.java, +import io.netty.channel.ChannelPipeline;, + * after MemcacheObjectDecoder in the {@link ChannelPipeline}., +++
[+++ b/pom.xml, + <version>3.0.0.CR2</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.0.0.CR2</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.0.0.CR2</developerConnection>]
[+++ b/common/src/main/java/io/netty/util/internal/logging/Slf4JLoggerFactory.java, + @SuppressWarnings("deprecation"), + throw new NoClassDefFoundError("NOPLoggerFactory not supported");]
[+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpNotificationHandler.java, +import io.netty.channel.ChannelPipeline;, + private final ChannelPipeline pipeline;, + SctpNotificationHandler(SctpChannelImpl sctpChannel) {, + this.pipeline = sctpChannel.getPipeline();, + Channels.fireChannelDisconnected(sctpChannel);, + pipeline.sendUpstream(new SctpNotificationEvent(sctpChannel, notification, o));, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpNotificationHandler.java, +import io.netty.channel.ChannelPipeline;, + private final ChannelPipeline pipeline;, + SctpNotificationHandler(SctpChannelImpl sctpChannel) {, + this.pipeline = sctpChannel.getPipeline();, + Channels.fireChannelDisconnected(sctpChannel);, + pipeline.sendUpstream(new SctpNotificationEvent(sctpChannel, notification, o));, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpWorker.java, + notificationHandler = new SctpNotificationHandler(channel);]
[+++ b/pom.xml, + <url>dav:https://svn.jboss.org/repos/repository.jboss.org/maven2</url>, + <url>dav:https://snapshots.jboss.org/maven2</url>]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + validatePromise(promise, false);, + validatePromise(promise, false);, + validatePromise(promise, false);, + validatePromise(promise, false);, + validatePromise(promise, false);, + if (msgs == null) {, + throw new NullPointerException("msgs");, + }, + validatePromise(promise, true);, +, + private void validatePromise(ChannelFuture promise, boolean allowUnsafe) {, + if (promise == null) {, + throw new NullPointerException("promise");, + if (promise.channel() != channel()) {, + "promise.channel does not match: %s (expected: %s)", promise.channel(), channel()));, + if (promise.isDone()) {, + if (!allowUnsafe && promise instanceof VoidChannelPromise) {, + if (promise instanceof AbstractChannel.CloseFuture) {]
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import javax.net.ssl.SNIHostName;, + // Mark as volatile as accessed by checkSniHostnameMatch(...), + private volatile Collection<SNIMatcher> matchers;, +, +, + sslParameters.setSNIMatchers(matchers);, + matchers = sslParameters.getSNIMatchers();, + final boolean checkSniHostnameMatch(String hostname) {, + Collection<SNIMatcher> matchers = this.matchers;, + if (matchers != null && !matchers.isEmpty()) {, + SNIHostName name = new SNIHostName(hostname);, + for (SNIMatcher matcher: matchers) {, + // type 0 is for hostname, + if (matcher.getType() == 0 && matcher.matches(name)) {, + return true;, + }, + }, + return false;, + }, + return true;, + }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import javax.net.ssl.SNIHostName;, + // Mark as volatile
[+++ b/codec/src/test/java/io/netty/handler/codec/frame/LengthFieldBasedFrameDecoderTest.java, + buf.release();, +++ b/codec/src/test/java/io/netty/handler/codec/frame/LengthFieldBasedFrameDecoderTest.java, + buf.release();, +++ b/codec/src/test/java/io/netty/handler/codec/frame/LengthFieldPrependerTest.java, + final ByteBuf buf = (ByteBuf) ch.readOutbound();, + assertThat(buf, is(wrappedBuffer(new byte[]{0, 0, 0, 1, 'A'})));, + buf.release();, + final ByteBuf buf = (ByteBuf) ch.readOutbound();, + assertThat(buf, is(wrappedBuffer(new byte[]{0, 0, 0, 5, 'A'})));, + buf.release();, + final ByteBuf buf = (ByteBuf) ch.readOutbound();, + assertThat(buf, is(wrappedBuffer(new byte[]{0, 0, 0, 0, 'A'})));, + buf.release();]
[+++ b/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java, + private final EventExecutorChooser chooser;, + if (isPowerOfTwo(children.length)) {, + chooser = new PowerOfTwoEventExecutorChooser();, + } else {, + chooser = new GenericEventExecutorChooser();, + }, +, + return chooser.next();, +, + private static boolean isPowerOfTwo(int val) {, + return (val & -val) == val;, + }, +, + private interface EventExecutorChooser {, + EventExecutor next();, + }, +, + private final class PowerOfTwoEventExecutorChooser implements EventExecutorChooser {, + @Override, + public EventExecutor next() {, + return children[childIndex.getAndIncrement() & children.length - 1];, + }, + }, +, + private final class GenericEventExecutorChooser implements EventExecutorChooser {, + @Override, + public
[+++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + /**, + * Free a direct {@link ByteBuffer}, + */, + protected void freeDirect(ByteBuffer buffer) {, + PlatformDependent.freeDirectBuffer(buffer);, + }, +, + freeDirect(oldBuffer);, + freeDirect(buffer);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + /**, + * Free a direct {@link ByteBuffer}, + */, + protected void freeDirect(ByteBuffer buffer) {, + PlatformDependent.freeDirectBuffer(buffer);, + }, +, + freeDirect(oldBuffer);, + freeDirect(buffer);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java, + /**, + * Free a direct {@link ByteBuffer}, + */, + protected void freeDirect(ByteBuffer buffer) {, + PlatformDependent.freeDirectBuffer(buffer);, + }, +, + freeDirect(oldBuffer);, + freeDirect(buffer);]
[+++ b/NOTICE.txt, +, +This product optionally depends on 'Webbit', a Java event based , +WebSocket and HTTP server:, +, + * LICENSE:, + * license/LICENSE.webbit.txt (BSD License), + * HOMEPAGE:, + * https://github.com/joewalnes/webbit, +, + , +++ b/NOTICE.txt, +, +This product optionally depends on 'Webbit', a Java event based , +WebSocket and HTTP server:, +, + * LICENSE:, + * license/LICENSE.webbit.txt (BSD License), + * HOMEPAGE:, + * https://github.com/joewalnes/webbit, +, + , +++ b/license/LICENSE.webbit.txt, +(BSD License: http://www.opensource.org/licenses/bsd-license), +, +Copyright (c) 2011, Joe Walnes, Aslak Hellesy and contributors, +All rights reserved., +, +Redistribution and use in source and binary forms,
[+++ b/pom.xml, + <pluginManagement>, + <plugins>, + <!--This plugin's configuration is used to store Eclipse m2e settings only. , + It has no influence on the Maven build itself. -->, + <plugin>, + <groupId>org.eclipse.m2e</groupId>, + <artifactId>lifecycle-mapping</artifactId>, + <version>1.0.0</version>, + <configuration>, + <lifecycleMappingMetadata>, + <pluginExecutions>, + <pluginExecution>, + <pluginExecutionFilter>, + <groupId>org.apache.maven.plugins</groupId>, + <artifactId>maven-antrun-plugin</artifactId>, + <versionRange>[1.7,)</versionRange>, + <goals>, + <goal>run</goal>, + </goals>, + </pluginExecutionFilter>, + <action>, + <ignore />, + </action>, + </pluginExecution>, + </pluginExecutions>, + </lifecycleMappingMetadata>, + </configuration>, + </plugin>, + </plugins>, + </pluginManagement>, +, +++ b/pom.xml, + <pluginManagement>, + <plugins>, + <!--This plugin's configuration is used to store Eclipse
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + * Limits the number of bytes to copy per {@link Unsafe#copyMemory(long, long, long)} to allow safepoint polling, + * during a large copy., + */, + private static final long UNSAFE_COPY_THRESHOLD = 1024L * 1024L;, +, +, + /**, + if (cleaner != null) {, + }, + //UNSAFE.copyMemory(srcAddr, dstAddr, length);, + while (length > 0) {, + long size = Math.min(length, UNSAFE_COPY_THRESHOLD);, + UNSAFE.copyMemory(srcAddr, dstAddr, size);, + length -= size;, + srcAddr += size;, + dstAddr += size;, + }, + //UNSAFE.copyMemory(src, srcOffset, dst, dstOffset, length);, + while (length > 0) {, + long size
[+++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, +/**, + * Wrapper which swap the {@link ByteOrder} of a {@link ByteBuf}., + */, +++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, +/**, + * Wrapper which swap the {@link ByteOrder} of a {@link ByteBuf}., + */, +++ b/common/src/main/java/io/netty/util/concurrent/CompleteFuture.java, + /**, + * Return the {@link EventExecutor} which is used by this {@link CompleteFuture}., + */, +++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, +/**, + * Wrapper which swap the {@link ByteOrder} of a {@link ByteBuf}., + */, +++ b/common/src/main/java/io/netty/util/concurrent/CompleteFuture.java, + /**, + * Return the {@link EventExecutor} which is used by this {@link CompleteFuture}., + */, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, +/**, + * Wrapper which swap
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + void consolidate();, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + void consolidate();, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + components.subList(cIndex, cIndex + numComponents).clear();, + public void consolidate() {, + final int numComponents = numComponents();, + if (numComponents <= 1) {, + return;, + }, +, + final Component last = components.get(numComponents - 1);, + final int capacity = last.endOffset;, + final ByteBuf consolidated = last.buf.unsafe().newBuffer(capacity);, +, + for (int i = 0; i < numComponents; i ++) {, + ByteBuf b = components.get(i).buf;, + consolidated.writeBytes(b);, + b.unsafe().release();, + }, +, + components.clear();, + components.add(new Component(consolidated));, + updateComponentOffsets(0);, + }, +, + @Override, + components.subList(cIndex +
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2FrameReaderTest.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.*;, +import static io.netty.handler.codec.http2.Http2FrameTypes.*;, +import static org.mockito.Mockito.*;, +, + @Test, + public void readUnknownFrame() throws Http2Exception {, + ByteBuf input = Unpooled.buffer();, + ByteBuf payload = Unpooled.buffer();, + try {, + payload.writeByte(1);, +, + writeFrameHeader(input, payload.readableBytes(), (byte) 0xff, new Http2Flags(), 0);, + input.writeBytes(payload);, + frameReader.readFrame(ctx, input, listener);, +, + verify(listener).onUnknownFrame(, + ctx, (byte) 0xff, 0, new Http2Flags(), payload.slice(0, 1));, + } finally {, + payload.release();, + input.release();, + }, + }, +, + @Test(expected = Http2Exception.class), + public void failedWhenContinuationFrameStreamIdMismatch() throws Http2Exception {, + ByteBuf input = Unpooled.buffer();, + try {, + Http2Headers headers =
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + case 204: case 304:, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + case 204: case 304:, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java, + public void testResetContentResponseWithTransferEncoding() {, + EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());, + assertTrue(ch.writeInbound(Unpooled.copiedBuffer(, + "HTTP/1.1 205 Reset Content\r\n" +, + "Transfer-Encoding: chunked\r\n" +, + "\r\n" +, + "0\r\n" +, + "\r\n",, + CharsetUtil.US_ASCII)));, +, + HttpResponse res = ch.readInbound();, + assertThat(res.protocolVersion(), sameInstance(HttpVersion.HTTP_1_1));, + assertThat(res.status(), is(HttpResponseStatus.RESET_CONTENT));, +, + LastHttpContent lastContent = ch.readInbound();, + assertThat(lastContent.content().isReadable(), is(false));, + lastContent.release();, +, + assertThat(ch.finish(), is(false));, + }, +, + @Test]
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java, + HttpContent chunk = (HttpContent) ch.readOutbound();, + assertThat(ByteBufUtil.hexDump(chunk.content()), is("1f8b080000000000000003000000000000000000"));, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java, + HttpContent chunk = (HttpContent) ch.readOutbound();, + assertThat(ByteBufUtil.hexDump(chunk.content()), is("1f8b080000000000000003000000000000000000"));, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java, + out.writeBytes(in);, + return;, + }, +, + int inputLength = in.readableBytes();, + if (inputLength == 0) {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java, + HttpContent chunk = (HttpContent) ch.readOutbound();, + assertThat(ByteBufUtil.hexDump(chunk.content()), is("1f8b080000000000000003000000000000000000"));, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java, + out.writeBytes(in);, + return;, + }, +, + int inputLength = in.readableBytes();, + if (inputLength == 0) {, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java, + if (len == 0) {, + return;, + }, +]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, + this(connection, new WeightedFairQueueByteDistributor(connection), listener);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, + this(connection, new WeightedFairQueueByteDistributor(connection), listener);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, + this(connection, new WeightedFairQueueByteDistributor(connection), listener);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Stream.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, + this(connection, new WeightedFairQueueByteDistributor(connection), listener);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Stream.java, +++ /dev/null, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, + this(connection, new WeightedFairQueueByteDistributor(connection), listener);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Stream.java, +++ /dev/null, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionTest.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, + this(connection, new WeightedFairQueueByteDistributor(connection), listener);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Stream.java, +++ /dev/null, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionTest.java, +++ /dev/null]
[+++ b/transport/src/main/java/io/netty/channel/SimpleChannelInboundHandler.java, + * <h3>Forward compatibility notice</h3>, + * <p>, + * Please keep in mind that {@link #channelRead0(ChannelHandlerContext, Object)} will be renamed to, + * {@code messageReceived(ChannelHandlerContext, I)} in 5.0., + * </p>, + * <strong>Please keep in mind that {@link #channelRead0(ChannelHandlerContext, Object)} will be renamed to, + * {@code messageReceived(ChannelHandlerContext, I)} in 5.0.</strong>, + *]
[+++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java, + * Open your browser at <a href="http://localhost:8080/">http://localhost:8080/</a>, then the demo page will be loaded, + * and a Web Socket connection will be made automatically.]
[+++ b/all/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/example/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha2</version>, +++ b/codec/pom.xml, +
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, +import io.netty.util.internal.DetectionUtil;, +import java.net.SocketException;, +import java.nio.channels.MembershipKey;, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.Iterator;, +import java.util.List;, +import java.util.Map;, + private Map<InetAddress, List<MembershipKey>> memberships;, + try {, + joinGroup(multicastAddress, NetworkInterface.getByInetAddress(getLocalAddress().getAddress()), null);, + } catch (SocketException e) {, + throw new ChannelException(e);, + }, + public void joinGroup(InetSocketAddress multicastAddress, NetworkInterface networkInterface) {, + joinGroup(multicastAddress.getAddress(), networkInterface, null);, + }, +, + /**, + * Joins the specified multicast group at the specified interface using the specified source., + */, + public void joinGroup(InetAddress multicastAddress, NetworkInterface networkInterface, InetAddress source) {, + if (DetectionUtil.javaVersion() < 7) {, + } else {, + if (multicastAddress
[+++ b/all/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/example/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec/pom.xml, +
[+++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, + public static final ChannelOption<Integer> SO_TIMEOUT =, + new ChannelOption<Integer>("SO_TIMEOUT");, +++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, + public static final ChannelOption<Integer> SO_TIMEOUT =, + new ChannelOption<Integer>("SO_TIMEOUT");, +++ b/transport/src/main/java/io/netty/channel/socket/DefaultServerSocketChannelConfig.java, + protected final ServerSocket javaSocket;, +++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, + public static final ChannelOption<Integer> SO_TIMEOUT =, + new ChannelOption<Integer>("SO_TIMEOUT");, +++ b/transport/src/main/java/io/netty/channel/socket/DefaultServerSocketChannelConfig.java, + protected final ServerSocket javaSocket;, +++ b/transport/src/main/java/io/netty/channel/socket/DefaultSocketChannelConfig.java, + protected final Socket javaSocket;, +++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, + public static final ChannelOption<Integer> SO_TIMEOUT =, + new ChannelOption<Integer>("SO_TIMEOUT");, +++ b/transport/src/main/java/io/netty/channel/socket/DefaultServerSocketChannelConfig.java, + protected final ServerSocket javaSocket;, +++ b/transport/src/main/java/io/netty/channel/socket/DefaultSocketChannelConfig.java, + protected final Socket javaSocket;, +++ b/transport/src/main/java/io/netty/channel/socket/oio/AbstractOioByteChannel.java, + /**, + * Check if the input was shutdown and if so return
[+++ b/LICENSE.queue.txt, +, +The person or persons who have associated work with this document (the, +"Dedicator" or "Certifier") hereby either (a) certifies that, to the best of, +his knowledge, the work of authorship identified is in the public domain of, +the country from which the work is published, or (b) hereby dedicates whatever, +copyright the dedicators holds in the work of authorship identified below (the, +"Work") to the public domain. A certifier, moreover, dedicates any copyright, +interest he may have in the associated work, and for these purposes, is, +described as a "dedicator" below., +, +A certifier has taken
[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java, + public DefaultEventExecutor(EventExecutorGroup parent, ThreadFactory threadFactory, int maxPendingTasks,, + RejectedExecutionHandler rejectedExecutionHandler) {, + super(parent, threadFactory, true, maxPendingTasks, rejectedExecutionHandler);, + }, +, + public DefaultEventExecutor(EventExecutorGroup parent, Executor executor, int maxPendingTasks,, + RejectedExecutionHandler rejectedExecutionHandler) {, + super(parent, executor, true, maxPendingTasks, rejectedExecutionHandler);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java, + public DefaultEventExecutor(EventExecutorGroup parent, ThreadFactory threadFactory, int maxPendingTasks,, + RejectedExecutionHandler rejectedExecutionHandler) {, + super(parent, threadFactory, true, maxPendingTasks, rejectedExecutionHandler);, + }, +, + public DefaultEventExecutor(EventExecutorGroup parent, Executor executor, int maxPendingTasks,, + RejectedExecutionHandler rejectedExecutionHandler) {, + super(parent, executor, true, maxPendingTasks, rejectedExecutionHandler);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorGroup.java, + this(nThreads, threadFactory, SingleThreadEventExecutor.DEFAULT_MAX_PENDING_EXECUTOR_TASKS,, + RejectedExecutionHandlers.reject());, + * @param rejectedHandler the {@link RejectedExecutionHandler} to use.,
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslUtils.java, +import io.netty.buffer.ByteBufUtil;, +import java.nio.ByteOrder;, + packetLength = unsignedShortBE(buffer, offset + 3) + SSL_RECORD_HEADER_LENGTH;, + packetLength = headerLength == 2 ?, + (shortBE(buffer, offset) & 0x7FFF) + 2 : (shortBE(buffer, offset) & 0x3FFF) + 3;, + // Reads a big-endian unsigned short integer from the buffer, + @SuppressWarnings("deprecation"), + private static int unsignedShortBE(ByteBuf buffer, int offset) {, + return buffer.order() == ByteOrder.BIG_ENDIAN ?, + buffer.getUnsignedShort(offset) : buffer.getUnsignedShortLE(offset);, + }, +, + // Reads a big-endian short integer from the buffer, + @SuppressWarnings("deprecation"), + private static short shortBE(ByteBuf buffer, int offset) {, + return buffer.order() == ByteOrder.BIG_ENDIAN ?, +
[+++ b/codec/src/main/java/io/netty/handler/codec/redis/Command.java, + public static final byte[] ARGS_PREFIX = "*".getBytes();, + public static final byte[] CRLF = "\r\n".getBytes();, + public static final byte[] BYTES_PREFIX = "$".getBytes();, + public static final byte[] EMPTY_BYTES = new byte[0];, + public static final byte[] NEG_ONE_AND_CRLF = convertWithCRLF(-1);, +++ b/codec/src/main/java/io/netty/handler/codec/redis/Command.java, + public static final byte[] ARGS_PREFIX = "*".getBytes();, + public static final byte[] CRLF = "\r\n".getBytes();, + public static final byte[] BYTES_PREFIX = "$".getBytes();, + public static final byte[] EMPTY_BYTES = new byte[0];, + public static final byte[] NEG_ONE_AND_CRLF = convertWithCRLF(-1);, +++ b/codec/src/main/java/io/netty/handler/codec/redis/RedisDecoder.java, + * @return content , + * , + * @param
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java, + * Returns the graceful shutdown timeout of the {@link Http2Connection} in milliseconds. Returns -1 if the, + * timeout is indefinite., + if (gracefulShutdownTimeoutMillis < -1) {, + throw new IllegalArgumentException("gracefulShutdownTimeoutMillis: " + gracefulShutdownTimeoutMillis +, + " (expected: -1 for indefinite or >= 0)");, + }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java, + * Returns the graceful shutdown timeout of the {@link Http2Connection} in milliseconds. Returns -1 if the, + * timeout is indefinite., + if (gracefulShutdownTimeoutMillis < -1) {, + throw new IllegalArgumentException("gracefulShutdownTimeoutMillis: " + gracefulShutdownTimeoutMillis +, + " (expected: -1 for indefinite or >= 0)");, + }, +++
[+++ b/src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingClientSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingClientSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingClientSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioProviderMetadata.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingClientSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioProviderMetadata.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingClientSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioProviderMetadata.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingClientSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioProviderMetadata.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/oio/OioClientSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingClientSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketPipelineSink.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioProviderMetadata.java, +import org.jboss.netty.util.ThreadRenamingRunnable;, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketPipelineSink.java, +import
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, + assertTrue(sc.write(ChannelBuffers.copyInt(1), groupAddress).awaitUninterruptibly().isSuccess());, + assertTrue(sc.write(ChannelBuffers.copyInt(1), groupAddress).awaitUninterruptibly().isSuccess());, + assertTrue(sc.write(ChannelBuffers.copyInt(1), groupAddress).awaitUninterruptibly().isSuccess());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, + assertTrue(sc.write(ChannelBuffers.copyInt(1), groupAddress).awaitUninterruptibly().isSuccess());, + assertTrue(sc.write(ChannelBuffers.copyInt(1), groupAddress).awaitUninterruptibly().isSuccess());, + assertTrue(sc.write(ChannelBuffers.copyInt(1), groupAddress).awaitUninterruptibly().isSuccess());, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java, + assertTrue(cc.write(ChannelBuffers.copyInt(1), sc.getLocalAddress()).awaitUninterruptibly().isSuccess());]
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +import io.netty.util.ReferenceCountUtil;, + ReferenceCountUtil.release(messages.get(i));, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +import io.netty.util.ReferenceCountUtil;, + ReferenceCountUtil.release(messages.get(i));, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, +import io.netty.util.ReferenceCountUtil;, + ReferenceCountUtil.release(msgs.get(i));, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +import io.netty.util.ReferenceCountUtil;, + ReferenceCountUtil.release(messages.get(i));, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, +import io.netty.util.ReferenceCountUtil;, + ReferenceCountUtil.release(msgs.get(i));, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, +import io.netty.util.ReferenceCountUtil;, + ReferenceCountUtil.release(msg);, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +import io.netty.util.ReferenceCountUtil;, + ReferenceCountUtil.release(messages.get(i));, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, +import io.netty.util.ReferenceCountUtil;, + ReferenceCountUtil.release(msgs.get(i));, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, +import io.netty.util.ReferenceCountUtil;, + ReferenceCountUtil.release(msg);, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, +import io.netty.util.ReferenceCountUtil;, + ReferenceCountUtil.release(m);, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +import io.netty.util.ReferenceCountUtil;, + ReferenceCountUtil.release(messages.get(i));, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, +import io.netty.util.ReferenceCountUtil;, + ReferenceCountUtil.release(msgs.get(i));, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, +import io.netty.util.ReferenceCountUtil;, + ReferenceCountUtil.release(msg);, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, +import io.netty.util.ReferenceCountUtil;, + ReferenceCountUtil.release(m);, +++ b/transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java, + private static final int DEFAULT_EVENT_LOOP_THREADS;, + super(nThreads == 0? DEFAULT_EVENT_LOOP_THREADS : nThreads,
[+++ b/all/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/codec-http2/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.9.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/all/pom.xml, + <version>4.1.0.CR6</version>, +++ b/all/pom.xml, + <version>4.1.0.CR6</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR6</version>, +++ b/all/pom.xml, + <version>4.1.0.CR6</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR6</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR6</version>, +++ b/all/pom.xml, + <version>4.1.0.CR6</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR6</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR6</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR6</version>, +++ b/all/pom.xml, + <version>4.1.0.CR6</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR6</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR6</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR6</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR6</version>, +++ b/all/pom.xml, + <version>4.1.0.CR6</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR6</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR6</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR6</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR6</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.CR6</version>, +++ b/all/pom.xml, + <version>4.1.0.CR6</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR6</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR6</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/all/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/example/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec/pom.xml, +
[+++ b/common/src/main/java/io/netty/util/concurrent/PromiseCombiner.java, + ObjectUtil.checkNotNull(aggregatePromise, "aggregatePromise");, + this.aggregatePromise = aggregatePromise;, +++ b/common/src/main/java/io/netty/util/concurrent/PromiseCombiner.java, + ObjectUtil.checkNotNull(aggregatePromise, "aggregatePromise");, + this.aggregatePromise = aggregatePromise;, +++ b/common/src/test/java/io/netty/util/concurrent/PromiseCombinerTest.java, +import org.junit.Assert;, + public void testNullArgument() {, + try {, + combiner.finish(null);, + Assert.fail();, + } catch (NullPointerException expected) {, + // expected, + }, + combiner.finish(p1);, + verify(p1).trySuccess(null);, + }, +, + @Test]
[+++ b/codec/src/main/java/io/netty/handler/codec/string/StringEncoder.java, +import io.netty.handler.codec.MessageToMessageEncoder;, +import java.util.List;, +public class StringEncoder extends MessageToMessageEncoder<CharSequence> {, + protected void encode(ChannelHandlerContext ctx, CharSequence msg, List<Object> out) throws Exception {, + out.add(Unpooled.copiedBuffer(msg, charset));]
[+++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelOption.java, +public final class RxtxChannelOption<T> extends ChannelOption<T> {, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelOption.java, +public final class RxtxChannelOption<T> extends ChannelOption<T> {, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelOption.java, + protected SctpChannelOption(String name) {, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelOption.java, +public final class RxtxChannelOption<T> extends ChannelOption<T> {, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelOption.java, + protected SctpChannelOption(String name) {, +++ b/transport-udt/src/main/java/io/netty/channel/udt/UdtChannelOption.java, +public final class UdtChannelOption<T> extends ChannelOption<T> {]
[+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java, + if (!NetUtil.isValidIpV6Address(host)) {, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java, + if (!NetUtil.isValidIpV6Address(host)) {, +++ b/common/src/main/java/io/netty/util/NetUtil.java, + * <p/>, + * <p/>, + if (isValidIpV6Address(ipAddressString)) {, + return null;, + }, + /**, + * Converts a 4 character hex word into a 2 byte word equivalent, + */, + public static boolean isValidIpV6Address(String ipAddress) {, + // There is a test case with 7 colons and valid ipv4 this should resolve it, + if (numberOfPeriods != 3 || !(isValidIp4Word(word.toString()) && numberOfColons < 7)) {, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java, + if (!NetUtil.isValidIpV6Address(host)) {, +++ b/common/src/main/java/io/netty/util/NetUtil.java, + * <p/>, + * <p/>, + if
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java]
[+++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannel.java, + super(null);, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannel.java, + super(null);, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpChannel.java, + this(null, sctpChannel);, + public NioSctpChannel(Channel parent, SctpChannel sctpChannel) {, + super(parent, sctpChannel, SelectionKey.OP_READ);, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannel.java, + super(null);, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpChannel.java, + this(null, sctpChannel);, + public NioSctpChannel(Channel parent, SctpChannel sctpChannel) {, + super(parent, sctpChannel, SelectionKey.OP_READ);, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpServerChannel.java, + super(null, newSocket(), SelectionKey.OP_ACCEPT);, + buf.add(new NioSctpChannel(this, ch));, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannel.java, + super(null);, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpChannel.java, + this(null, sctpChannel);, + public NioSctpChannel(Channel parent, SctpChannel sctpChannel) {, + super(parent, sctpChannel, SelectionKey.OP_READ);, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpServerChannel.java, + super(null, newSocket(), SelectionKey.OP_ACCEPT);, + buf.add(new NioSctpChannel(this, ch));, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpChannel.java, + this(null, ch);, + public OioSctpChannel(Channel parent, SctpChannel ch) {, + super(parent);, +++
[+++ b/.gitignore, +++ b/.gitignore, +++ b/src/main/java/org/jboss/netty/handler/execution/OrderedMemoryAwareThreadPoolExecutor.java, +import java.util.Queue;, +import java.util.concurrent.atomic.AtomicBoolean;, +import org.jboss.netty.util.internal.LinkedTransferQueue;, + private final Queue<Runnable> tasks = new LinkedTransferQueue<Runnable>();, + private final AtomicBoolean isRunning = new AtomicBoolean(false);, + // TODO: What todo if the add return false ?, +, + if (isRunning.get() == false) {, + // check if its already running by using CAS. If so just return here. So in the worst case the thread, + // is executed and do nothing, + if (isRunning.compareAndSet(false, true)) {, + try {, + final Runnable task = tasks.poll();, + // if the task is null we should exit
[+++ b/codec/src/main/java/io/netty/handler/codec/redis/Command.java, + public static final byte[] ARGS_PREFIX = "*".getBytes();, + public static final byte[] CRLF = "\r\n".getBytes();, + public static final byte[] BYTES_PREFIX = "$".getBytes();, + public static final byte[] EMPTY_BYTES = new byte[0];, + public static final byte[] NEG_ONE_AND_CRLF = convertWithCRLF(-1);, +++ b/codec/src/main/java/io/netty/handler/codec/redis/Command.java, + public static final byte[] ARGS_PREFIX = "*".getBytes();, + public static final byte[] CRLF = "\r\n".getBytes();, + public static final byte[] BYTES_PREFIX = "$".getBytes();, + public static final byte[] EMPTY_BYTES = new byte[0];, + public static final byte[] NEG_ONE_AND_CRLF = convertWithCRLF(-1);, +++ b/codec/src/main/java/io/netty/handler/codec/redis/RedisDecoder.java, + * @return content , + * , + * @param
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +jbyteArray createInetSocketAddressArray(JNIEnv * env, struct sockaddr_storage addr) {, + int port;, + if (addr.ss_family == AF_INET) {, + struct sockaddr_in *s = (struct sockaddr_in *)&addr;, + port = ntohs(s->sin_port);, +, + // Encode address and port into the array, + unsigned char a[8];, + a[0] = s->sin_addr.s_addr >> 24;, + a[1] = s->sin_addr.s_addr >> 16;, + a[2] = s->sin_addr.s_addr >> 8;, + a[3] = s->sin_addr.s_addr;, + a[4] = port >> 24;, + a[5] = port >> 16;, + a[6] = port >> 8;, + a[7] = port;, +, + jbyteArray bArray = (*env)->NewByteArray(env, 8);, + (*env)->SetByteArrayRegion(env, bArray,
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, + localhost4 = (Inet4Address) InetAddress.getByAddress("localhost", LOCALHOST4_BYTES);, + localhost6 = (Inet6Address) InetAddress.getByAddress("localhost", LOCALHOST6_BYTES);, +++ b/common/src/main/java/io/netty/util/NetUtil.java, + localhost4 = (Inet4Address) InetAddress.getByAddress("localhost", LOCALHOST4_BYTES);, + localhost6 = (Inet6Address) InetAddress.getByAddress("localhost", LOCALHOST6_BYTES);, +++ b/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java, + "blogspot.in",, + "localhost")));, + "localhost",]
[+++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, + if (isSingleDecode()) {, + break;, + }, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, + if (isSingleDecode()) {, + break;, + }, +++ b/codec/src/test/java/io/netty/handler/codec/ReplayingDecoderTest.java, +, + @Test, + public void testSingleDecode() throws Exception {, + LineDecoder decoder = new LineDecoder();, + decoder.setSingleDecode(true);, + EmbeddedByteChannel ch = new EmbeddedByteChannel(decoder);, +, + // "C\n" should be appended to "AB" so that LineDecoder decodes it correctly., + ch.writeInbound(Unpooled.wrappedBuffer(new byte[]{'C', '\n' , 'B', '\n'}));, + assertEquals(Unpooled.wrappedBuffer(new byte[] {'C' }), ch.readInbound());, + assertNull("Must be null as it must only decode one frame", ch.readInbound());, +, + ch.finish();, + assertEquals(Unpooled.wrappedBuffer(new byte[] {'B' }), ch.readInbound());, + assertNull(ch.readInbound());, + }]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2DataFrame.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.verifyPadding;, + * @param padding additional bytes that should be added to obscure the true content size. Must be between 0 and, + * 256 (inclusive)., + verifyPadding(padding);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2DataFrame.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.verifyPadding;, + * @param padding additional bytes that should be added to obscure the true content size. Must be between 0 and, + * 256 (inclusive)., + verifyPadding(padding);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, + int padding = readPadding(payload);, + int dataLength = lengthWithoutTrailingPadding(payload.readableBytes(), padding);, + final ByteBuf fragment = payload.readSlice(lengthWithoutTrailingPadding(payload.readableBytes(), padding));, + final ByteBuf fragment = payload.readSlice(lengthWithoutTrailingPadding(payload.readableBytes(), padding));, + final ByteBuf fragment = payload.readSlice(lengthWithoutTrailingPadding(payload.readableBytes(), padding));, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ClientUpgradeCodec.java, +import static io.netty.handler.codec.base64.Base64Dialect.URL_SAFE;, +import static io.netty.handler.codec.http2.Http2CodecUtil.HTTP_UPGRADE_PROTOCOL_NAME;, +import static io.netty.handler.codec.http2.Http2CodecUtil.HTTP_UPGRADE_SETTINGS_HEADER;, +import static io.netty.handler.codec.http2.Http2CodecUtil.SETTING_ENTRY_LENGTH;, +import static io.netty.handler.codec.http2.Http2CodecUtil.writeUnsignedInt;, +import static io.netty.handler.codec.http2.Http2CodecUtil.writeUnsignedShort;, +import static io.netty.util.CharsetUtil.UTF_8;, +import static io.netty.util.ReferenceCountUtil.release;, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +, + * @param connectionHandler the HTTP/2 connection handler, + this(null, connectionHandler);, + * @param handlerName the name of the HTTP/2 connection handler to be used in the pipeline,, + * or {@code null} to auto-generate the name, + * @param connectionHandler the HTTP/2 connection handler, + public Http2ClientUpgradeCodec(String handlerName, Http2ConnectionHandler connectionHandler) {, + this.handlerName = handlerName;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ClientUpgradeCodec.java, +import static io.netty.handler.codec.base64.Base64Dialect.URL_SAFE;, +import static io.netty.handler.codec.http2.Http2CodecUtil.HTTP_UPGRADE_PROTOCOL_NAME;, +import static io.netty.handler.codec.http2.Http2CodecUtil.HTTP_UPGRADE_SETTINGS_HEADER;, +import static
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodecBuilder.java, + if ((handler instanceof ChannelHandlerAdapter && !((ChannelHandlerAdapter) handler).isSharable()) &&, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodecBuilder.java, + if ((handler instanceof ChannelHandlerAdapter && !((ChannelHandlerAdapter) handler).isSharable()) &&, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexCodecBuilderTest.java, +import io.netty.channel.ChannelHandlerAdapter;, +, + private static class SharableChannelHandler1 extends ChannelHandlerAdapter {, + @Override, + public boolean isSharable() {, + return true;, + }, + }, +, + @Sharable, + private static class SharableChannelHandler2 extends ChannelHandlerAdapter {, + }, +, + private static class UnsharableChannelHandler extends ChannelHandlerAdapter {, + @Override, + public boolean isSharable() {, + return false;, + }, + }, +, + @Test, + public void testSharableCheck() {, + assertNotNull(Http2MultiplexCodecBuilder.forServer(new SharableChannelHandler1()));, + assertNotNull(Http2MultiplexCodecBuilder.forServer(new SharableChannelHandler2()));,
[+++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyTLV.java, + * Returns the {@link Type} for a specific byte value as defined in the PROXY protocol 1.5 spec, +++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyTLV.java, + * Returns the {@link Type} for a specific byte value as defined in the PROXY protocol 1.5 spec, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + // Pass through the full response with empty content and continue waiting for the next resp., +++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyTLV.java, + * Returns the {@link Type} for a specific byte value as defined in the PROXY protocol 1.5 spec, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + // Pass through the full response with empty content and continue waiting for the
[+++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java, + if (isKeepAlive(request)) {, + response.setHeader(CONNECTION, HttpHeaders.Values.KEEP_ALIVE);, + }, +++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java, + if (isKeepAlive(request)) {, + response.setHeader(CONNECTION, HttpHeaders.Values.KEEP_ALIVE);, + }, +++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java, +import io.netty.handler.codec.http.HttpHeaders;, + // Add keep alive header as per http://www.w3.org/Protocols/HTTP/1.1/draft-ietf-http-v11-spec-01.html#Connection, + response.setHeader(CONNECTION, HttpHeaders.Values.KEEP_ALIVE);]
[+++ b/pom.xml, + <version>3.2.0.BETA1</version>, + <url>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.2.0.BETA1</url>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.2.0.BETA1</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.2.0.BETA1</developerConnection>]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + // We don't cache that to keep memory usage to a minimum., + byte[] id = SSL.getSessionId(ssl);, + // The id should never be null, if it was null then the SESSION itself was not valid., + throw new IllegalStateException("SSL session ID not available");]
[+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisDecoder.java, + if (readableBytes == 0 || remainingBulkLength == 0 && readableBytes < RedisConstants.EOL_LENGTH) {, +++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisDecoder.java, + if (readableBytes == 0 || remainingBulkLength == 0 && readableBytes < RedisConstants.EOL_LENGTH) {, +++ b/codec-redis/src/test/java/io/netty/handler/codec/redis/RedisDecoderTest.java, +import static io.netty.handler.codec.redis.RedisCodecTestUtil.byteBufOf;, +import static io.netty.handler.codec.redis.RedisCodecTestUtil.bytesOf;, +import static org.hamcrest.CoreMatchers.equalTo;, +import static org.hamcrest.CoreMatchers.instanceOf;, +import static org.hamcrest.CoreMatchers.is;, +import static org.hamcrest.CoreMatchers.nullValue;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertThat;, +import static org.junit.Assert.assertTrue;, + public void splitEOLDoesNotInfiniteLoop() throws Exception {, + assertFalse(channel.writeInbound(byteBufOf("$6\r\nfoobar\r")));, + assertTrue(channel.writeInbound(byteBufOf("\n")));, +, + RedisMessage msg = channel.readInbound();, + assertTrue(msg instanceof FullBulkStringRedisMessage);, + ReferenceCountUtil.release(msg);, + }, +, + @Test]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + String expectedSubprotocol = getExpectedSubprotocol();, + channel.pipeline().get(HttpResponseDecoder.class).replace(, + "ws-decoder", new WebSocket00FrameDecoder(getMaxFramePayloadLength()));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + String expectedSubprotocol = getExpectedSubprotocol();, + channel.pipeline().get(HttpResponseDecoder.class).replace(, + "ws-decoder", new WebSocket00FrameDecoder(getMaxFramePayloadLength()));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + channel.pipeline().get(HttpResponseDecoder.class).replace(, + "ws-decoder",, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + String expectedSubprotocol = getExpectedSubprotocol();, + channel.pipeline().get(HttpResponseDecoder.class).replace(, + "ws-decoder", new WebSocket00FrameDecoder(getMaxFramePayloadLength()));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + channel.pipeline().get(HttpResponseDecoder.class).replace(, + "ws-decoder",, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java, + channel.pipeline().get(HttpResponseDecoder.class).replace(, + "ws-decoder",]
[+++ b/microbench/src/main/java/io/netty/microbench/channel/EmbeddedChannelHandlerContext.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the, + * "License"); you may not use this file except in compliance with the License. You may obtain a, + * copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express, + *
[+++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java, +import java.nio.channels.FileChannel;, + public int getBytes(int index, FileChannel out, long position, int length) throws IOException {, + recordLeakNonRefCountingOperation(leak);, + return super.getBytes(index, out, position, length);, + }, +, + @Override, + public int setBytes(int index, FileChannel in, long position, int length) throws IOException {, + recordLeakNonRefCountingOperation(leak);, + return super.setBytes(index, in, position, length);, + }, +, + @Override, + public int readBytes(FileChannel out, long position, int length) throws IOException {, + recordLeakNonRefCountingOperation(leak);, + return super.readBytes(out, position, length);, + }, +, + @Override, + public int writeBytes(FileChannel in, long position, int length) throws IOException {, + recordLeakNonRefCountingOperation(leak);, + return super.writeBytes(in,
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(NetUtil.class);, + } catch (IOException e0) {, + // Log all exceptions we caught so far for easier diagnosis., + logger.warn("Failed to resolve localhost with InetAddress.getLocalHost():", e0);, + logger.warn("Failed to resolve localhost with InetAddress.getByAddress(127.0.0.1):", e1);, + logger.warn("Failed to resolve localhost with InetAddress.getByAddress(::1)", e2);, + throw new Error("failed to resolve localhost; incorrect network configuration?");]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + * after a {@code GOAWAY} is sent if the following conditions hold:, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + * after a {@code GOAWAY} is sent if the following conditions hold:, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, + // Mark the state as cancelled, we'll clear the pending queue via cancel() below., +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + * after a {@code GOAWAY} is sent if the following conditions hold:, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, + // Mark the state as cancelled, we'll clear the pending queue via cancel() below., +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Connection.java, + * Notifies the listener that the given stream has
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + // We need to copy parent's channel options into a child's options to make, + // sure they share same allocator, same receive buffer allocator, etc., + //, + // See https://github.com/netty/netty/issues/6551, + channel.config().setOptions(parentChannel.config().getOptions());, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + // We need to copy parent's channel options into a child's options to make, + // sure they share same allocator, same receive buffer allocator, etc., + //, + // See https://github.com/netty/netty/issues/6551, + channel.config().setOptions(parentChannel.config().getOptions());, +, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexCodecTest.java, +, + public void childChannelShouldShareParentsChannelOptions() {, + EmbeddedChannel parent = new EmbeddedChannel();, + parent.config().setAutoRead(false);, + parent.config().setWriteSpinCount(42);, +, + Http2StreamChannelBootstrap b =
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + if (PlatformDependent.isUnaligned() && PlatformDependent.unsafeHasCopyMethods()) {, + if (PlatformDependent.isUnaligned() && PlatformDependent.unsafeHasCopyMethods()) {, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + if (PlatformDependent.isUnaligned() && PlatformDependent.unsafeHasCopyMethods()) {, + if (PlatformDependent.isUnaligned() && PlatformDependent.unsafeHasCopyMethods()) {, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + if (PlatformDependent.isUnaligned() && PlatformDependent.unsafeHasCopyMethods()) {, + if (PlatformDependent.isUnaligned() && PlatformDependent.unsafeHasCopyMethods()) {, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + private static final boolean UNSAFE_HASE_COPY_METHODS = unsafeHasCopyMethods0();, + * Returns {@code true} if unsafe has all needed copy methods which is not the case on latest openjdk6 atm., + */, + public static boolean unsafeHasCopyMethods() {, + return UNSAFE_HASE_COPY_METHODS;, + }, +, + /**, + private static boolean unsafeHasCopyMethods0() {,
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java, +import org.junit.Rule;, +import org.junit.rules.TestName;, + "Running: %s %d of %d (%s + %s)", testName.getMethodName(), ++ i, COMBO.size(), sb, cb));, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java, +import org.junit.Rule;, +import org.junit.rules.TestName;, + "Running: %s %d of %d (%s + %s)", testName.getMethodName(), ++ i, COMBO.size(), sb, cb));, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractSctpTest.java, + "Running: %s %d of %d (%s + %s)", testName.getMethodName(), ++ i, COMBO.size(), sb, cb));, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java, +import org.junit.Rule;, +import org.junit.rules.TestName;, + "Running: %s %d of %d (%s + %s)", testName.getMethodName(), ++ i, COMBO.size(), sb, cb));, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractSctpTest.java, + "Running: %s %d of %d (%s + %s)", testName.getMethodName(), ++ i, COMBO.size(), sb, cb));, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractServerSocketTest.java,
[+++ b/pom.xml, + -group "Miscellaneous" ${project.groupId}.logging*:${project.groupId}.group*, +++ b/pom.xml, + -group "Miscellaneous" ${project.groupId}.logging*:${project.groupId}.group*, +++ b/src/main/java/org/jboss/netty/handler/codec/embedder/DecoderEmbedder.java, + *, + * @apiviz.landmark, +++ b/pom.xml, + -group "Miscellaneous" ${project.groupId}.logging*:${project.groupId}.group*, +++ b/src/main/java/org/jboss/netty/handler/codec/embedder/DecoderEmbedder.java, + *, + * @apiviz.landmark, +++ b/src/main/java/org/jboss/netty/handler/codec/embedder/EncoderEmbedder.java, + *, + * @apiviz.landmark]
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + } catch (Throwable ignored) {, + } catch (Throwable ignored) {, + } catch (Throwable ignored) {, + } catch (Throwable ignored) {, + } catch (Throwable ignored) {, + } catch (Throwable ignored) {, + } catch (Throwable ignored) {, + } catch (Throwable ignored) {, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + } catch (Throwable ignored) {, + } catch (Throwable ignored) {, + } catch (Throwable ignored) {, + } catch (Throwable ignored) {, + } catch (Throwable ignored) {, + } catch (Throwable ignored) {, + } catch (Throwable ignored) {, + } catch (Throwable ignored)
[+++ b/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoop.java, + protected void deregister() {]
[+++ b/pom.xml, + <version>2.0.9.GA</version>, + <version>1.4.0</version>, + <version>1.4.0</version>, + <version>2.1.0.GA</version>, + <version>4.7</version>, + <version>2.5.2</version>, + <version>2.4.1</version>, + <version>2.0.1</version>, + <version>2.1.1</version>, + <version>2.6.1</version>]
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseDecoder.java, + boolean release = true;, + try {, + release = false;, + } finally {, + if (release) {, + // We need to release te DnsResources in case of an Exception as we called retain() on the buffer., + releaseDnsResources(response.answers());, + releaseDnsResources(response.authorityResources());, + releaseDnsResources(response.additionalResources());, + }, + }, + }, +, + private static void releaseDnsResources(List<DnsResource> resources) {, + int size = resources.size();, + for (int i = 0; i < size; i++) {, + DnsResource resource = resources.get(i);, + resource.release();, + }, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseDecoder.java, + boolean release = true;, + try {, + release
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java, + * <p>, + * This class is <strong>NOT</strong> thread safe. The assumption is all methods must be invoked from a single thread., + * Typically this thread is the event loop thread for the {@link ChannelHandlerContext} managed by this class., + private float windowUpdateRatio;, + private int initialWindowSize = DEFAULT_WINDOW_SIZE;, + assert ctx == null || ctx.executor().inEventLoop();, + assert ctx != null && ctx.executor().inEventLoop();, + assert ctx != null && ctx.executor().inEventLoop();, + assert ctx == null || ctx.executor().inEventLoop();, + assert ctx != null && ctx.executor().inEventLoop();, + assert ctx != null && ctx.executor().inEventLoop();, + private int initialStreamWindowSize;,
[+++ /dev/null, +++ /dev/null, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamFrame.java, + private Http2FrameStream stream;, + public AbstractHttp2StreamFrame stream(Http2FrameStream stream) {, + public Http2FrameStream stream() {, + Http2FrameStream stream = this.stream;, + if (stream == null) {, + return super.hashCode();, + }, +++ /dev/null, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamFrame.java, + private Http2FrameStream stream;, + public AbstractHttp2StreamFrame stream(Http2FrameStream stream) {, + public Http2FrameStream stream() {, + Http2FrameStream stream = this.stream;, + if (stream == null) {, + return super.hashCode();, + }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2DataFrame.java, +import io.netty.util.internal.StringUtil;, + private final int initialFlowControlledBytes;, + if (content().readableBytes() + (long) padding > Integer.MAX_VALUE) {, + throw new IllegalArgumentException("content + padding must be <=
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfig.java, +import io.netty.handler.codec.http.DefaultHttpHeaders;, +import io.netty.handler.codec.http.HttpHeaders;, +import io.netty.handler.codec.http.HttpHeaders.Names;, +import java.util.Date;, +import java.util.HashMap;, +import java.util.Map;, +import java.util.Map.Entry;, +import java.util.concurrent.Callable;, + private final Map<CharSequence, Callable<?>> preflightHeaders;, + preflightHeaders = builder.preflightHeaders;, + *, + * To expose other headers they need to be specified, which is what this method enables by, + * adding the headers names to the CORS 'Access-Control-Expose-Headers' response header., + * By default cookies are not included in CORS requests but if isCredentialsAllowed returns, + * true cookies will be added to CORS requests. Setting this value to true will set the, + * CORS 'Access-Control-Allow-Credentials' response header
[+++ b/transport/src/test/java/io/netty/channel/DefaultChannelIdTest.java, + assertTrue(text.matches("^[0-9a-f]{16}-[0-9a-f]{8}-[0-9a-f]{8}-[0-9a-f]{16}-[0-9a-f]{8}$"));]
[+++ b/transport/src/main/java/io/netty/channel/AbstractCoalescingBufferQueue.java, + * Add a buffer to the front of the queue and associate a promise with it that should be completed when, + * all the buffer's bytes have been consumed from the queue and written., + * @param buf to add to the head of the queue, + * @param promise to complete when all the bytes have been consumed and written, can be void., + addFirst(buf, toChannelFutureListener(promise));, + }, + private void addFirst(ByteBuf buf, ChannelFutureListener listener) {, + if (listener != null) {, + bufAndListenerPairs.addFirst(listener);, + }, + bufAndListenerPairs.addFirst(buf);, + * all the buffer's bytes
[+++ b/src/main/java/io/netty/bootstrap/Bootstrap.java, +/*, + * Copyright 2009 Red Hat, Inc., + *, + * Red Hat licenses this file to you under the Apache License, version 2.0, + * (the "License"); you may not use this file except in compliance with the, + * License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/ClientCookieDecoder.java, + maxAge = Math.max(Long.parseLong(value), 0L);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/ClientCookieDecoder.java, + maxAge = Math.max(Long.parseLong(value), 0L);, +++ b/example/src/main/java/io/netty/example/http2/Http2ExampleUtil.java, + return Integer.parseInt(string);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/ClientCookieDecoder.java, + maxAge = Math.max(Long.parseLong(value), 0L);, +++ b/example/src/main/java/io/netty/example/http2/Http2ExampleUtil.java, + return Integer.parseInt(string);, +++ b/example/src/main/java/io/netty/example/http2/tiles/Http2RequestHandler.java, +import static java.lang.Integer.parseInt;, + ByteBuf image = ImageCache.INSTANCE.image(parseInt(x), parseInt(y));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/ClientCookieDecoder.java, + maxAge = Math.max(Long.parseLong(value), 0L);, +++ b/example/src/main/java/io/netty/example/http2/Http2ExampleUtil.java, + return Integer.parseInt(string);, +++ b/example/src/main/java/io/netty/example/http2/tiles/Http2RequestHandler.java, +import static java.lang.Integer.parseInt;, + ByteBuf image = ImageCache.INSTANCE.image(parseInt(x), parseInt(y));, +++ b/transport/src/main/java/io/netty/channel/pool/SimpleChannelPool.java, + if (future.getNow()) {]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + logger.debug(String.format("%s WS Version %s server handshake", channel, version()));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + logger.debug(String.format("%s WS Version %s server handshake", channel, version()));, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java, + logger.fine(String.format("%s received %s", ctx.channel(), request));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + logger.debug(String.format("%s WS Version %s server handshake", channel, version()));, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java, + logger.fine(String.format("%s received %s", ctx.channel(), request));, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java, + logger.fine(String.format("%s received %s", ctx.channel(), request));]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + private volatile int refCnt;, + refCntUpdater.set(this, 1);, + refCntUpdater.set(this, refCnt);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + private volatile int refCnt;, + refCntUpdater.set(this, 1);, + refCntUpdater.set(this, refCnt);, +++ b/common/src/main/java/io/netty/util/AbstractReferenceCounted.java, + refCntUpdater.set(this, refCnt);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + private volatile int refCnt;, + refCntUpdater.set(this, 1);, + refCntUpdater.set(this, refCnt);, +++ b/common/src/main/java/io/netty/util/AbstractReferenceCounted.java, + refCntUpdater.set(this, refCnt);, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, + @SuppressWarnings({ "unused", "FieldMayBeFinal" }), + private volatile int workerState; // 0 - init, 1 - started, 2 - shut down]
[+++ b/pom.xml]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import java.nio.ByteOrder;, + private final SwappedByteBuf swappedBuf;, + private final ByteOrder order;, +, + protected AbstractByteBuf(ByteOrder endianness) {, + if (endianness == null) {, + throw new NullPointerException("endianness");, + }, + order = endianness;, + swappedBuf = new SwappedByteBuf(this);, + }, +, + public final ByteOrder order() {, + return order;, + }, +, + @Override, + public ByteBuf order(ByteOrder endianness) {, + if (endianness == null) {, + throw new NullPointerException("endianness");, + }, + if (endianness == order()) {, + return this;, + }, + return swappedBuf;, + }, +, + @Override, + if (this ==
[+++ b/codec/src/main/java/io/netty/handler/codec/embedder/EmbeddedChannel.java, + super(null, null, ChannelBufferHolders.catchAllBuffer());, +, + Queue<Object> msgBuf = buf.messageBuffer();, + if (!msgBuf.isEmpty()) {, + productQueue.addAll(msgBuf);, + msgBuf.clear();, + }, +++ b/codec/src/main/java/io/netty/handler/codec/embedder/EmbeddedChannel.java, + super(null, null, ChannelBufferHolders.catchAllBuffer());, +, + Queue<Object> msgBuf = buf.messageBuffer();, + if (!msgBuf.isEmpty()) {, + productQueue.addAll(msgBuf);, + msgBuf.clear();, + }, +++ b/handler/pom.xml, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-codec</artifactId>, + <version>${project.version}</version>, + </dependency>, +++ b/codec/src/main/java/io/netty/handler/codec/embedder/EmbeddedChannel.java, + super(null, null, ChannelBufferHolders.catchAllBuffer());, +, + Queue<Object> msgBuf = buf.messageBuffer();, + if (!msgBuf.isEmpty()) {, + productQueue.addAll(msgBuf);, + msgBuf.clear();, + }, +++ b/handler/pom.xml, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-codec</artifactId>, + <version>${project.version}</version>, + </dependency>, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedFile.java, +++ b/codec/src/main/java/io/netty/handler/codec/embedder/EmbeddedChannel.java, + super(null, null, ChannelBufferHolders.catchAllBuffer());, +,
[+++ b/pom.xml, + programming such as TCP and UDP socket server.]
[+++ b/codec/src/main/java/io/netty/handler/codec/CharSequenceValueConverter.java, + return DateFormatter.format(new Date(value));, +++ b/codec/src/main/java/io/netty/handler/codec/CharSequenceValueConverter.java, + return DateFormatter.format(new Date(value));, +++ b/codec/src/test/java/io/netty/handler/codec/CharSequenceValueConverterTest.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the, + * "License"); you may not use this file except in compliance with the License. You may obtain a, + * copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS"
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + static final int DEFAULT_INITIAL_CAPACITY = 256;, + static final int DEFAULT_MAX_CAPACITY = Integer.MAX_VALUE;, + static final int CALCULATE_THRESHOLD = 1048576 * 4; // 4 MiB page, + return heapBuffer(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_CAPACITY);, + return heapBuffer(initialCapacity, DEFAULT_MAX_CAPACITY);, + return directBuffer(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_CAPACITY);, + return directBuffer(initialCapacity, DEFAULT_MAX_CAPACITY);, + final int threshold = CALCULATE_THRESHOLD; // 4 MiB page, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + static final int DEFAULT_INITIAL_CAPACITY = 256;, + static final int DEFAULT_MAX_CAPACITY = Integer.MAX_VALUE;, + static final int CALCULATE_THRESHOLD = 1048576 * 4; // 4 MiB page, + return heapBuffer(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_CAPACITY);, + return heapBuffer(initialCapacity, DEFAULT_MAX_CAPACITY);, + return directBuffer(DEFAULT_INITIAL_CAPACITY, DEFAULT_MAX_CAPACITY);, + return directBuffer(initialCapacity,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java, + if (name.charAt(0) == '$') {, + throw new IllegalArgumentException("name starting with '$' not allowed: " + name);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java, + if (name.charAt(0) == '$') {, + throw new IllegalArgumentException("name starting with '$' not allowed: " + name);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/CookieDecoderTest.java, +, + @Test, + public void testDecodingWeirdNames1() {, + String src = "path=; expires=Mon, 01-Jan-1990 00:00:00 GMT; path=/; domain=.www.google.com";, + Set<Cookie> cookies = new CookieDecoder().decode(src);, + Cookie c = cookies.iterator().next();, + assertEquals("path", c.getName());, + assertEquals("", c.getValue());, + assertEquals("/", c.getPath());, + }, +, + @Test, + public void testDecodingWeirdNames2() {, + String
[+++ b/transport/src/main/java/io/netty/channel/ChannelPromiseAggregator.java]
[+++ b/all/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR3-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfig.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version, + * 2.0 (the "License"); you may not use this file except in compliance with the, + * License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +import java.lang.reflect.Method;, + private static final boolean UNALIGNED;, +, + static {, + boolean unaligned = false;, + try {, + Class<?> bitsClass = Class.forName("java.nio.Bits", false, ClassLoader.getSystemClassLoader());, + Method unalignedMethod = bitsClass.getDeclaredMethod("unaligned");, + unalignedMethod.setAccessible(true);, + unaligned = Boolean.TRUE.equals(unalignedMethod.invoke(null));, + } catch (Throwable t) {, + // Ignore, + }, +, + UNALIGNED = unaligned;, + }, +, + if (UNALIGNED) {, + return new PooledUnsafeDirectByteBuf(maxCapacity);, + } else {, + }, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +import java.lang.reflect.Method;, + private static final boolean UNALIGNED;, +, + static {, + boolean unaligned = false;, + try {, + Class<?> bitsClass =
[+++ b/pom.xml, + <version>3.2.0.CR1</version>, + <url>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.2.0.CR1</url>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.2.0.CR1</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.2.0.CR1</developerConnection>]
[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultProgressivePromise.java, + if (total < 0) {, + total = -1;, + if (progress < 0 || isDone()) {, + return false;, + }, + } else if (progress < 0 || progress > total || isDone()) {, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultProgressivePromise.java, + if (total < 0) {, + total = -1;, + if (progress < 0 || isDone()) {, + return false;, + }, + } else if (progress < 0 || progress > total || isDone()) {, +++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java, +import io.netty.channel.DefaultFileRegion;, + private final boolean useSendFile;, +, + public HttpStaticFileServerHandler(boolean useSendFile) {, + this.useSendFile = useSendFile;, + },
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + if (leak != null) {, + }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + if (leak != null) {, + }, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + if (leak != null) {, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + if (leak != null) {, + }, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + if (leak != null) {, +++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, + buf.setRefCnt(1);, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + if (leak != null) {, + }, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + if (leak != null) {, +++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, + buf.setRefCnt(1);, +++ b/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java, + buf.setRefCnt(1);, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + if (leak != null) {, + }, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + if (leak != null) {, +++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, + buf.setRefCnt(1);, +++
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + --createdBy().numStreams;, + private int maxStreams;, + int numStreams;, + maxStreams = maxActiveStreams = Integer.MAX_VALUE;, + ++numStreams;, + return streamId > 0 && server == ((streamId & 1) == 0);, + return numActiveStreams < maxActiveStreams;, + public int maxStreams() {, + return maxStreams;, + }, +, + @Override, + public void maxStreams(int maxActiveStreams, int maxStreams) throws Http2Exception {, + if (maxStreams < maxActiveStreams) {, + throw connectionError(PROTOCOL_ERROR, "maxStream[%d] streams must be >= maxActiveStreams[%d]",, + maxStreams, maxActiveStreams);, + }, + this.maxStreams = maxStreams;, + if (state.localSideOpen() || state.remoteSideOpen()) {, + if (!canOpenStream()) {, + } else if (numStreams
[+++ b/pom.xml, + <tcnative.version>2.0.20.Final</tcnative.version>]
[+++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, + if (!buffer.isDirect() && buffer.hasArray()) {]
[+++ b/all/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/codec-memcache/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta3</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java, +import java.util.Collections;, +import java.util.List;, +, +import static io.netty.handler.codec.http.HttpMethod.OPTIONS;, +import static io.netty.handler.codec.http.HttpResponseStatus.FORBIDDEN;, +import static io.netty.handler.codec.http.HttpResponseStatus.OK;, +import static io.netty.util.ReferenceCountUtil.release;, +import static io.netty.util.internal.ObjectUtil.checkNonEmpty;, + * This handler can be configured using one or more {@link CorsConfig}, please, + private CorsConfig config;, + private final List<CorsConfig> configList;, + private boolean isShortCircuit;, + * Creates a new instance with a single {@link CorsConfig}., + this(Collections.singletonList(config), config.isShortCircuit());, + }, +, + /**, + * Creates a new instance with the specified config list. If more than one, + * config matches a certain origin, the first in the List will be used., +
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Epoll.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/all/pom.xml, + <version>4.0.1.Final</version>, +++ b/all/pom.xml, + <version>4.0.1.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Final</version>, +++ b/all/pom.xml, + <version>4.0.1.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.Final</version>, +++ b/all/pom.xml, + <version>4.0.1.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.1.Final</version>, +++ b/all/pom.xml, + <version>4.0.1.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.1.Final</version>, +++ b/codec/pom.xml, + <version>4.0.1.Final</version>, +++ b/all/pom.xml, + <version>4.0.1.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.1.Final</version>, +++ b/codec/pom.xml, + <version>4.0.1.Final</version>, +++ b/common/pom.xml, + <version>4.0.1.Final</version>, +++ b/all/pom.xml, + <version>4.0.1.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.Final</version>, +++ b/codec-socks/pom.xml, +
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + buf.add(new DatagramPacket(buffer.writerIndex(buffer.writerIndex() + data.position()), remoteAddress));]
[+++ b/all/pom.xml, + <version>4.1.8.Final</version>, +++ b/all/pom.xml, + <version>4.1.8.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.8.Final</version>, +++ b/all/pom.xml, + <version>4.1.8.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.8.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.8.Final</version>, +++ b/all/pom.xml, + <version>4.1.8.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.8.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.8.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.8.Final</version>, +++ b/all/pom.xml, + <version>4.1.8.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.8.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.8.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.8.Final</version>, +++ b/codec-http/pom.xml, + <version>4.1.8.Final</version>, +++ b/all/pom.xml, + <version>4.1.8.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.8.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.8.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.8.Final</version>, +++ b/codec-http/pom.xml, + <version>4.1.8.Final</version>, +++ b/codec-http2/pom.xml, + <version>4.1.8.Final</version>, +++ b/all/pom.xml, + <version>4.1.8.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.8.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.8.Final</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, + public boolean acceptOutboundMessage(Object msg) throws Exception {, + return super.acceptOutboundMessage(msg) && !(msg instanceof HttpResponse);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, + public boolean acceptOutboundMessage(Object msg) throws Exception {, + return super.acceptOutboundMessage(msg) && !(msg instanceof HttpResponse);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java, + public boolean acceptOutboundMessage(Object msg) throws Exception {, + return super.acceptOutboundMessage(msg) && !(msg instanceof HttpRequest);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, + public boolean acceptOutboundMessage(Object msg) throws Exception {, + return super.acceptOutboundMessage(msg) && !(msg instanceof HttpResponse);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java, + public boolean acceptOutboundMessage(Object msg) throws Exception {, + return super.acceptOutboundMessage(msg) && !(msg instanceof HttpRequest);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameEncoder.java, + public void encode(ChannelHandlerContext
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBufferInputStream.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBufferInputStream.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBufferInputStream.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractChannelBufferTest.java, +import io.netty.util.CharsetUtil;, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBufferInputStream.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractChannelBufferTest.java, +import io.netty.util.CharsetUtil;, +++ b/buffer/src/test/java/io/netty/buffer/ChannelBufferIndexFinderTest.java, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBufferInputStream.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractChannelBufferTest.java, +import io.netty.util.CharsetUtil;, +++ b/buffer/src/test/java/io/netty/buffer/ChannelBufferIndexFinderTest.java, +, +++ b/buffer/src/test/java/io/netty/buffer/ReadOnlyChannelBufferTest.java, +import static org.easymock.EasyMock.*;, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBufferInputStream.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractChannelBufferTest.java, +import io.netty.util.CharsetUtil;, +++ b/buffer/src/test/java/io/netty/buffer/ChannelBufferIndexFinderTest.java, +, +++ b/buffer/src/test/java/io/netty/buffer/ReadOnlyChannelBufferTest.java, +import static org.easymock.EasyMock.*;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpChunkTrailer.java, +import io.netty.buffer.ChannelBuffer;, +import io.netty.buffer.ChannelBuffers;, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffer.java, +++
[+++ b/handler/src/test/java/io/netty/handler/ssl/ConscryptSslEngineTest.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "ADH-AES128-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "AES128-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "ECDHE-RSA-AES128-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "ADH-CAMELLIA128-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "DES-CBC3-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "AECDH-AES128-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "AECDH-DES-CBC3-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "CAMELLIA128-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "DHE-RSA-AES256-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "SEED-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "RC4-MD5");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "ADH-AES256-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "AES256-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "ADH-SEED-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "ADH-DES-CBC3-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "EDH-RSA-DES-CBC3-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "ADH-RC4-MD5");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "IDEA-CBC-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "DHE-RSA-AES128-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "RC4-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "CAMELLIA256-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "AECDH-RC4-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "DHE-RSA-SEED-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "AECDH-AES256-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "ECDHE-RSA-DES-CBC3-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "ADH-CAMELLIA256-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "DHE-RSA-CAMELLIA256-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "ECDHE-RSA-AES256-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "DHE-RSA-CAMELLIA128-SHA");, + testWrapWithDifferentSizes(OpenSsl.PROTOCOL_TLS_V1, "ECDHE-RSA-RC4-SHA");, +, + @Test, + public void testWrapWithDifferentSizesTLSv1_1()
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannelConfig.java, + setTcpKeepCnt((Integer) value);, + * @deprecated use {@link #setTcpKeepCnt(int)}, + */, + @Deprecated, + public EpollSocketChannelConfig setTcpKeepCntl(int probes) {, + return setTcpKeepCnt(probes);, + }, +, + /**, + public EpollSocketChannelConfig setTcpKeepCnt(int probes) {]
[+++ b/all/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, + <version>2.5</version>, + <version>2.4</version>, + <version>1.7</version>, + <version>2.5</version>, + <version>2.2</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, + <version>2.5</version>, + <version>2.4</version>, + <version>1.7</version>, + <version>2.5</version>, + <version>2.2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, + <version>2.5</version>, + <version>2.4</version>, + <version>1.7</version>, + <version>2.5</version>, + <version>2.2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, + <version>2.5</version>, + <version>2.4</version>, + <version>1.7</version>, + <version>2.5</version>, + <version>2.2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, + * Standard and CORS HTTP header names., + * For CORS headers, see, + * https://developer.mozilla.org/en-US/docs/HTTP_access_control, + *, + *
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + bridge = new ByteBridge(ctx, true);, + bridge = new ByteBridge(ctx, false);, + ByteBridge(ChannelHandlerContext ctx, boolean inbound) {, + if (inbound) {, + if (ctx.inboundByteBuffer().isDirect()) {, + byteBuf = ctx.alloc().directBuffer();, + } else {, + byteBuf = ctx.alloc().heapBuffer();, + }, + } else {, + if (ctx.outboundByteBuffer().isDirect()) {, + byteBuf = ctx.alloc().directBuffer();, + } else {, + byteBuf = ctx.alloc().heapBuffer();, + }, + }]
[+++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, + promise.registered();, + static final class PendingRegistrationPromise extends DefaultChannelPromise {, +, + private volatile boolean registered;, + PendingRegistrationPromise(Channel channel) {, + void registered() {, + registered = true;, + }, +, + if (registered) {, + return super.executor();, +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, + promise.registered();, + static final class PendingRegistrationPromise extends DefaultChannelPromise {, +, + private volatile boolean registered;, + PendingRegistrationPromise(Channel channel) {, + void registered() {, + registered = true;, + }, +, + if (registered) {, + return super.executor();, +++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, + private ChannelFuture doResolveAndConnect(final SocketAddress remoteAddress, final SocketAddress localAddress) {, + final Channel channel = regFuture.channel();, +,
[+++ b/common/src/main/java/io/netty/util/AbstractConstant.java, +import io.netty.util.internal.PlatformDependent;, +import io.netty.util.internal.ThreadLocalRandom;, +, +import java.nio.ByteBuffer;, +, + private volatile long uniquifier;, + private ByteBuffer directBuffer;, + public final String toString() {, + return name();, + }, +, + @Override, + public final boolean equals(Object obj) {, + return super.equals(obj);, + public final int compareTo(T o) {, + if (this == o) {, + @SuppressWarnings("UnnecessaryLocalVariable"), + AbstractConstant<T> other = o;, + int returnCode;, +, + returnCode = hashCode() - other.hashCode();, + long thisUV = uniquifier();, + long otherUV = other.uniquifier();, + if (thisUV < otherUV) {, + return -1;, + }, + if (thisUV > otherUV)
[+++ b/codec/src/main/java/io/netty/handler/codec/DefaultTextHeaders.java, +import io.netty.util.internal.FastThreadLocal;, + new FastThreadLocal<HttpHeaderDateFormat>() {, +++ b/codec/src/main/java/io/netty/handler/codec/DefaultTextHeaders.java, +import io.netty.util.internal.FastThreadLocal;, + new FastThreadLocal<HttpHeaderDateFormat>() {, +++ b/common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java, + new FastThreadLocal<ThreadLocalRandom>() {, +++ b/codec/src/main/java/io/netty/handler/codec/DefaultTextHeaders.java, +import io.netty.util.internal.FastThreadLocal;, + new FastThreadLocal<HttpHeaderDateFormat>() {, +++ b/common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java, + new FastThreadLocal<ThreadLocalRandom>() {, +++ b/common/src/main/java/io/netty/util/internal/chmv8/ConcurrentHashMapV8.java, +import io.netty.util.internal.FastThreadLocal;, +, + new FastThreadLocal<CounterHashCode>();]
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java, +import io.netty.channel.socket.InternetProtocolFamily;, + return SocketTestPermutation.INSTANCE.datagram(InternetProtocolFamily.IPv4);, + switch (internetProtocolFamily()) {, + case IPv4:, + case IPv6:, + return new InetSocketAddress(NetUtil.LOCALHOST6, 0);, + default:, + throw new AssertionError();, + }, + }, +, + protected InternetProtocolFamily internetProtocolFamily() {, + return InternetProtocolFamily.IPv4;, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java, +import io.netty.channel.socket.InternetProtocolFamily;, + return SocketTestPermutation.INSTANCE.datagram(InternetProtocolFamily.IPv4);, + switch (internetProtocolFamily()) {, + case IPv4:, + case IPv6:, + return new InetSocketAddress(NetUtil.LOCALHOST6, 0);, + default:, + throw new AssertionError();, + }, + }, +, + protected InternetProtocolFamily internetProtocolFamily() {, + return InternetProtocolFamily.IPv4;, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramMulticastIPv6Test.java, +/*, + * Copyright 2019 The Netty Project, + *, + * The Netty Project
[+++ b/pom.xml, +++ b/pom.xml, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + oldMemory, oldOffset,, + buf.memory, buf.offset, oldCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + oldMemory, oldOffset,, + buf.memory, buf.offset, oldCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + oldBuffer.position(0).limit(oldBuffer.capacity());, + newBuffer.position(0).limit(oldBuffer.capacity());, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + oldMemory, oldOffset,, + buf.memory, buf.offset, oldCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + oldBuffer.position(0).limit(oldBuffer.capacity());, + newBuffer.position(0).limit(oldBuffer.capacity());, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java, + System.arraycopy(array, 0, newArray, 0, array.length);, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + oldMemory, oldOffset,, + buf.memory, buf.offset, oldCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + oldBuffer.position(0).limit(oldBuffer.capacity());, + newBuffer.position(0).limit(oldBuffer.capacity());, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java, + System.arraycopy(array, 0, newArray, 0, array.length);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java, + oldBuffer.position(0).limit(oldBuffer.capacity());, + newBuffer.position(0).limit(oldBuffer.capacity());, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + oldMemory, oldOffset,, + buf.memory, buf.offset, oldCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + oldBuffer.position(0).limit(oldBuffer.capacity());, + newBuffer.position(0).limit(oldBuffer.capacity());, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java, + System.arraycopy(array, 0, newArray, 0, array.length);,
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + // Updated once a new handshake is started and so the SSLSession reused., + private volatile long lastAccessed = -1;, +, +, + lastAccessed = System.currentTimeMillis();, +, + if (lastAccessed == -1) {, + lastAccessed = System.currentTimeMillis();, + }, + long lastAccessed = OpenSslEngine.this.lastAccessed;, + // if lastAccessed is -1 we will just return the creation time as the handshake was not started yet., + return lastAccessed == -1 ? getCreationTime() : lastAccessed;]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, + RFC3986,, +, + /**, + * The HTML5 spec disallows mixed mode in multipart/form-data, + * requests. More concretely this means that more files submitted, + * under the same name will not be encoded using mixed mode, but, + * will be treated as distinct fields., + *, + * Reference:, + * http://www.w3.org/TR/html5/forms.html#multipart-form-data, + */, + HTML5, + * Add a series of Files associated with one File parameter, + if (encoderMode != EncoderMode.HTML5 && currentFileUpload != null, + && currentFileUpload.getName().equals(fileUpload.getName())) {, + // * Content-Disposition: attachment; filename="file1.txt", + // Content-Disposition: attachment; filename="file1.txt", +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + // Upgrade header should be matched case-insensitive., + // See https://github.com/netty/netty/issues/278, + if (upgrade == null || !upgrade.toLowerCase().equals(Values.WEBSOCKET.toLowerCase())) {, + // Connection header should be matched case-insensitive., + // See https://github.com/netty/netty/issues/278, + if (connection == null || !connection.toLowerCase().equals(Values.UPGRADE.toLowerCase())) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + // Upgrade header should be matched case-insensitive., + // See https://github.com/netty/netty/issues/278, + if (upgrade == null || !upgrade.toLowerCase().equals(Values.WEBSOCKET.toLowerCase())) {, + // Connection header should be matched case-insensitive., + // See https://github.com/netty/netty/issues/278, + if (connection == null || !connection.toLowerCase().equals(Values.UPGRADE.toLowerCase())) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java, + // Upgrade header should be matched case-insensitive., + // See https://github.com/netty/netty/issues/278, +
[+++ b/codec/src/main/java/io/netty/handler/codec/base64/Base64.java, + final byte src0 = src[0];, + final byte src1 = src[1];, + final byte src2 = src[2];, + final int decodedValue;, + if (src2 == EQUALS_SIGN) {, + try {, + decodedValue = (decodabet[src0] & 0xff) << 2 | (decodabet[src1] & 0xff) >>> 4;, + } catch (IndexOutOfBoundsException ignored) {, + throw new IllegalArgumentException("not encoded in Base64");, + }, + dest.setByte(destOffset, decodedValue);, + final byte src3 = src[3];, + if (src3 == EQUALS_SIGN) {, + final byte b1 = decodabet[src1];, + try {, + // The decodabet bytes are meant to straddle byte boundaries and so
[+++ b/testsuite-shading/pom.xml, + <version>4.1.28.Final-SNAPSHOT</version>]
[+++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, +import io.netty.channel.ChannelId;, + * Returns the {@link Channel} which has the specified {@link ChannelId}., + *, + * @return the matching {@link Channel} if found. {@code null} otherwise., + */, + Channel find(ChannelId id);, +, + /**, +++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, +import io.netty.channel.ChannelId;, + * Returns the {@link Channel} which has the specified {@link ChannelId}., + *, + * @return the matching {@link Channel} if found. {@code null} otherwise., + */, + Channel find(ChannelId id);, +, + /**, +++ b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java, +import io.netty.channel.ChannelId;, +import io.netty.util.internal.PlatformDependent;, +import java.util.concurrent.ConcurrentMap;, + private final ConcurrentMap<ChannelId, Channel> serverChannels = PlatformDependent.newConcurrentHashMap();, + private final ConcurrentMap<ChannelId, Channel>
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, + * Copyright 2014 The Netty Project, +import io.netty.buffer.ByteBuf;, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelFutureListener;, +import io.netty.channel.ChannelHandler;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelOutboundHandler;, +import io.netty.channel.ChannelPromise;, +import io.netty.handler.codec.ByteToMessageDecoder;, +import io.netty.handler.codec.UnsupportedMessageTypeException;, +, +import java.net.SocketAddress;, +import java.util.List;, + * A {@link ChannelHandler} that encodes and decodes SPDY Frames., +public final class SpdyFrameCodec extends ByteToMessageDecoder, + implements SpdyFrameDecoderDelegate, ChannelOutboundHandler {, +, + private static final SpdyProtocolException INVALID_FRAME =, + new SpdyProtocolException("Received invalid frame");, +, + private final SpdyFrameDecoder spdyFrameDecoder;, + private final SpdyFrameEncoder spdyFrameEncoder;, + private final SpdyHeaderBlockDecoder spdyHeaderBlockDecoder;, + private final SpdyHeaderBlockEncoder spdyHeaderBlockEncoder;, +, + private SpdyHeadersFrame spdyHeadersFrame;, + private SpdySettingsFrame spdySettingsFrame;, +, +
[+++ b/example/src/main/java/io/netty/example/http2/Http2ExampleUtil.java, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.Unpooled;, +import io.netty.handler.codec.http.QueryStringDecoder;, +, +import java.io.IOException;, +import java.io.InputStream;, +import java.util.List;, +, + /**, + * Size of the block to be read from the input stream., + */, + private static final int BLOCK_SIZE = 1024;, +, +, + /**, + * @param string the string to be converted to an integer., + * @param defaultValue the default value, + * @return the integer value of a string or the default value, if the string is either null or empty., + */, + public static int toInt(String string, int defaultValue) {,
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2CodecTest.java, +import io.netty.channel.ChannelInitializer;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +, + private volatile Channel serverConnectedChannel;, + final CountDownLatch serverChannelLatch = new CountDownLatch(1);, + .childHandler(new ChannelInitializer<Channel>() {, + @Override, + protected void initChannel(Channel ch) throws Exception {, + serverConnectedChannel = ch;, + ch.pipeline().addLast(new Http2Codec(true, serverLastInboundHandler));, + serverChannelLatch.countDown();, + }, + });, + assertTrue(serverChannelLatch.await(2, TimeUnit.SECONDS));, + if (serverConnectedChannel != null) {, + serverConnectedChannel.close().sync();, + serverConnectedChannel = null;, + }, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2CodecTest.java, +import io.netty.channel.ChannelInitializer;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +, + private volatile Channel serverConnectedChannel;, + final CountDownLatch serverChannelLatch = new CountDownLatch(1);, + .childHandler(new ChannelInitializer<Channel>() {, + @Override, + protected void initChannel(Channel ch) throws
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +import javax.net.ssl.SSLEngineResult.Status;, + if (pendingNetResult.getStatus() != OK) {, + bytesProduced = pendingNetResult.bytesProduced();, + }, + private Status getEngineStatus() {]
[+++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadClient.java, +import io.netty.handler.codec.http.HttpPostRequestEncoder;, +import io.netty.handler.codec.http.HttpPostRequestEncoder.ErrorDataEncoderException;, +import io.netty.handler.codec.http.InterfaceHttpData;, +import io.netty.handler.codec.http.QueryStringEncoder;, + private final String baseUri;, + private final String filePath;, + , + public HttpUploadClient(String baseUri, String filePath) {, + this.baseUri = baseUri;, + this.filePath = filePath;, + public void run() {, + if (baseUri.endsWith("/")) {, + postSimple = baseUri + "formpost";, + postFile = baseUri + "formpostmultipart";, + get = baseUri + "formget";, + postSimple = baseUri + "/formpost";, + postFile = baseUri + "/formpostmultipart";, + get = baseUri + "/formget";, + File file = new File(filePath);, + formpostmultipart(bootstrap, host, port, uriFile, factory, headers, bodylist);, + *, +
[+++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, + * SingleThreadEventExecutor. So use it with care!</strong>, +++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, + * SingleThreadEventExecutor. So use it with care!</strong>, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, + * SingleThreadEventExecutor. So use it with care!</strong>, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +++ b/transport-native-kqueue/src/main/java/io/netty/channel/kqueue/KQueueEventLoop.java, +++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, + * SingleThreadEventExecutor. So use it with care!</strong>, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +++ b/transport-native-kqueue/src/main/java/io/netty/channel/kqueue/KQueueEventLoop.java, +++ b/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java]
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, + ensureNotSharable();, + ensureNotSharable();, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, + ensureNotSharable();, + ensureNotSharable();, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + ensureNotSharable();, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, + ensureNotSharable();, + ensureNotSharable();, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + ensureNotSharable();, +++ /dev/null, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, + ensureNotSharable();, + ensureNotSharable();, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + ensureNotSharable();, +++ /dev/null, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java, + * Throws {@link IllegalStateException} if {@link ChannelHandlerAdapter#isSharable()} returns {@code true}, + */, + protected void ensureNotSharable() {, + if (isSharable()) {, + throw new IllegalStateException("ChannelHandler " + getClass().getName() + " is not allowed to be shared");, + }, + }, +, + /**, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, + ensureNotSharable();, + ensureNotSharable();, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + ensureNotSharable();, +++ /dev/null, +++
[+++ b/NOTICE.txt, +This product optionally depends on 'JBoss Microcontainer', which can be, +obtained at:, +, + * LICENSE:, + * license/LICENSE.jboss-microcontainer.txt (GNU LGPL 2.1), + * HOMEPAGE:, + * http://www.jboss.org/jbossmc/, +, +This product optionally depends on 'Apache Felix', an open source OSGi, +framework implementation, which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.felix.txt (Apache License 2.0), + * HOMEPAGE:, + * http://felix.apache.org/, +, +This product optionally depends on 'Google Guice', a lightweight dependency, +injection framework, which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.guice.txt (Apache License 2.0), + * HOMEPAGE:, + * http://code.google.com/p/google-guice/,
[+++ b/all/pom.xml, + <version>4.1.22.Final</version>, +++ b/all/pom.xml, + <version>4.1.22.Final</version>, +++ b/bom/pom.xml, + <version>4.1.22.Final</version>, + <tag>netty-4.1.22.Final</tag>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, +++ b/all/pom.xml, + <version>4.1.22.Final</version>, +++ b/bom/pom.xml, + <version>4.1.22.Final</version>, + <tag>netty-4.1.22.Final</tag>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, + <version>4.1.22.Final</version>, +
[+++ b/all/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-memcache/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + if (response.status().code() != 101) {]
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +import static java.lang.Math.max;, +, + return max(val, 0);, + return max(numTinyAllocations() - numTinyDeallocations(), 0);, + return max(numSmallAllocations() - numSmallDeallocations(), 0);, + return max(val, 0);, + return max(numHugeAllocations() - numHugeDeallocations(), 0);, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +import static java.lang.Math.max;, +, + return max(val, 0);, + return max(numTinyAllocations() - numTinyDeallocations(), 0);, + return max(numSmallAllocations() - numSmallDeallocations(), 0);, + return max(val, 0);, + return max(numHugeAllocations() - numHugeDeallocations(), 0);, +++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, + private static final int INTEGER_SIZE_MINUS_ONE = Integer.SIZE - 1;, +, + int memoryMapIdx = memoryMapIdx(handle);, + int bitmapIdx = bitmapIdx(handle);, + int memoryMapIdx = memoryMapIdx(handle);, + int bitmapIdx = bitmapIdx(handle);, + initBufWithSubpage(buf,
[+++ b/all/pom.xml, + <id>attach-javadocs</id>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, + handleOutboundMessage(ctx, msg);, + private void handleOutboundMessage(ChannelHandlerContext ctx, Object msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, + handleOutboundMessage(ctx, msg);, + private void handleOutboundMessage(ChannelHandlerContext ctx, Object msg) throws Exception {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, + handleOutboundMessage(ctx, msg);, + private
[+++ b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java, + .childHandler(new ChannelInitializer<SocketChannel>() {, + ChannelFuture f = bootstrap.bind(9999).sync();, +++ b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java, + .childHandler(new ChannelInitializer<SocketChannel>() {, + ChannelFuture f = bootstrap.bind(9999).sync();, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, + ChannelFuture f = b.connect(host, port).sync();, +++ b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java, + .childHandler(new ChannelInitializer<SocketChannel>() {, + ChannelFuture f = bootstrap.bind(9999).sync();, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, + ChannelFuture f = b.connect(host, port).sync();, +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, + ChannelFuture f = b.bind(port).sync();, +++ b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java, + .childHandler(new ChannelInitializer<SocketChannel>() {, + ChannelFuture f = bootstrap.bind(9999).sync();, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, + ChannelFuture f = b.connect(host, port).sync();, +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, + ChannelFuture f = b.bind(port).sync();, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, + ChannelFuture f = b.connect(host, port).sync();, +++ b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java, + .childHandler(new ChannelInitializer<SocketChannel>() {, + ChannelFuture f
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, +, + // Bypass the encoder in case of an empty buffer, so that the following idiom works:, + //, + // ch.write(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);, + //, + // See https://github.com/netty/netty/issues/2983 for more information., +, + if (msg instanceof ByteBuf && !((ByteBuf) msg).isReadable()) {, + out.add(EMPTY_BUFFER);, + return;, + }, +, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, +, + // Bypass the encoder in case of an empty buffer, so that the following idiom works:, + //, + // ch.write(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);, + //, + // See https://github.com/netty/netty/issues/2983 for more information., +, + if (msg instanceof ByteBuf && !((ByteBuf) msg).isReadable()) {, + out.add(EMPTY_BUFFER);, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java, + private Boolean validateHeaders;, + enforceConstraint("codec", "validateHeaders", validateHeaders);, + * Returns if HTTP headers should be validated according to, + * <a href="https://tools.ietf.org/html/rfc7540#section-8.1.2.6">RFC 7540, 8.1.2.6</a>., + */, + protected boolean isValidateHeaders() {, + return validateHeaders != null ? validateHeaders : true;, + }, +, + /**, + * Sets if HTTP headers should be validated according to, + * <a href="https://tools.ietf.org/html/rfc7540#section-8.1.2.6">RFC 7540, 8.1.2.6</a>., + */, + protected B validateHeaders(boolean validateHeaders) {, + enforceNonCodecConstraints("validateHeaders");, + this.validateHeaders = validateHeaders;, + return self();, + }, +, + /**, + Http2FrameReader reader = new DefaultHttp2FrameReader(isValidateHeaders());]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java, + * Used to cache the value of the hash code and avoid {@link IllegalReferenceCountException}., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java, + * Used to cache the value of the hash code and avoid {@link IllegalReferenceCountException}., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java, + * Used to cache the value of the hash code and avoid {@link IllegalReferenceCountException}., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java, + * Used to cache the value of the hash code and avoid {@link IllegalReferenceCountException}., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java, + * Used to cache the value of the hash code and avoid {@link IllegalReferenceCountException}., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpRequest.java, + * Combine the {@link HttpRequest} and {@link FullHttpMessage}, so the request
[+++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java, +import io.netty.buffer.ReferenceCounted;, + *, + * Be aware that you need to call {@link ReferenceCounted#retain()} on messages that are just passed through if they, + * are of type {@link ReferenceCounted}. This is needed as the {@link MessageToMessageCodec} will call, + * {@link ReferenceCounted#release()} on encoded / decoded messages., +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java, +import io.netty.buffer.ReferenceCounted;, + *, + * Be aware that you need to call {@link ReferenceCounted#retain()} on messages that are just passed through if they, + * are of type {@link ReferenceCounted}. This is needed as the {@link MessageToMessageCodec} will call, + * {@link ReferenceCounted#release()} on encoded
[+++ b/.gitignore, +/*.geany, +++ b/.gitignore, +/*.geany, +++ b/pom.xml, + <version>2.4.1</version>, + <version>1.6.4</version>, + <version>4.10</version>, + <version>3.1</version>, + <version>3.1</version>, + <version>1.6.4</version>, + <version>1.0.1</version>, + <version>2.5</version>, + <version>2.10</version>, + <version>1.7</version>, + <version>2.8</version>, + <groupId>org.eclipse.wst.css</groupId>, + <artifactId>core</artifactId>, + <version>1.1.101-v200705302225</version>, + <exclusions>, + <exclusion>, + <groupId>org.apache</groupId>, + <artifactId>xerces</artifactId>, + </exclusion>, + <exclusion>, + <groupId>com.ibm</groupId>, + <artifactId>icu</artifactId>, + </exclusion>, + </exclusions>, + </dependency>, + <dependency>, + <groupId>org.eclipse.wst.sse</groupId>, + <artifactId>core</artifactId>, + <version>1.1.202-v200709061102</version>, + <exclusions>, + <exclusion>, + <groupId>org.apache</groupId>, + <artifactId>xerces</artifactId>, + </exclusion>, + <exclusion>, + <groupId>com.ibm</groupId>, + <artifactId>icu</artifactId>, + </exclusion>, + </exclusions>, + </dependency>, + <dependency>, + <version>2.2.1</version>, + <version>2.2.1</version>, +++ b/.gitignore, +/*.geany, +++ b/pom.xml,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +import io.netty.handler.codec.PrematureChannelClosureException;, + @Override, + protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, MessageList<Object> out) throws Exception {, + decode(ctx, in, out);, +, + // Handle the last unfinished message., + if (message != null) {, + // Get the length of the content received so far for the last message., + HttpMessage message = this.message;, + int actualContentLength;, + if (content != null) {, + actualContentLength = content.readableBytes();, + } else {, + actualContentLength = 0;, + }, +, + // Add the last message (and its content) to the output., + reset(out);, +, + // Check if
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketEchoTest.java, + testSimpleEcho0(sb, cb, false, false, true);, + }, +, + @Test(timeout = 30000), + public void testSimpleEchoNotAutoRead() throws Throwable {, + run();, + }, +, + public void testSimpleEchoNotAutoRead(ServerBootstrap sb, Bootstrap cb) throws Throwable {, + testSimpleEcho0(sb, cb, false, false, false);, + testSimpleEcho0(sb, cb, true, false, true);, + }, +, + @Test//(timeout = 30000), + public void testSimpleEchoWithAdditionalExecutorNotAutoRead() throws Throwable {, + run();, + }, +, + public void testSimpleEchoWithAdditionalExecutorNotAutoRead(ServerBootstrap sb, Bootstrap cb) throws Throwable {, + testSimpleEcho0(sb, cb, true, false, false);, + testSimpleEcho0(sb, cb, false, true, true);, + }, +, + @Test//(timeout = 30000), + public
[+++ b/pom.xml, + <jetty.alpnAgent.path>"${settings.localRepository}"/org/mortbay/jetty/alpn/jetty-alpn-agent/${jetty.alpnAgent.version}/jetty-alpn-agent-${jetty.alpnAgent.version}.jar</jetty.alpnAgent.path>]
[+++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, + * break;]
[+++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java, + return unwrap().hasMemoryAddress();, + return unwrap().memoryAddress();]
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + final ByteBuffer nioData = data.nioBufferCount() == 1 ? data.internalNioBuffer(data.readerIndex(), dataLen), + : data.nioBuffer(data.readerIndex(), dataLen);]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + @Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, + public int bytesBefore(int index, int length, ByteBufIndexFinder indexFinder) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + @Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, + public int bytesBefore(int index, int length, ByteBufIndexFinder indexFinder) {, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * For simple single-byte searches, use {@link #indexOf(int, int, byte)} and {@link #bytesBefore(int, int, byte)}., + * {@link #bytesBefore(byte)} is especially useful when you deal with a {@code NUL}-terminated string., + * For complicated searches, use {@link #forEachByte(int, int, ByteBufProcessor)} with a {@link ByteBufProcessor}, + * implementation., + * @deprecated Use {@link #forEachByte(int, int, ByteBufProcessor)} instead.,
[+++ b/transport-rxtx/src/main/java/io/netty/transport/rxtx/RxtxChannel.java, +, + private static final RxtxDeviceAddress LOCAL_ADDRESS = new RxtxDeviceAddress("localhost");, + private final RxtxChannelConfig config;, + private boolean open = true;, + public RxtxChannelConfig config() {, + return open;, + public RxtxDeviceAddress localAddress() {, + return (RxtxDeviceAddress) super.localAddress();, + public RxtxDeviceAddress remoteAddress() {, + return (RxtxDeviceAddress) super.remoteAddress();, + }, +, + @Override, + protected RxtxDeviceAddress localAddress0() {, + return LOCAL_ADDRESS;, + }, +, + @Override, + protected RxtxDeviceAddress remoteAddress0() {, + open = false;, +, +++ b/transport-rxtx/src/main/java/io/netty/transport/rxtx/RxtxChannel.java, +, + private static final RxtxDeviceAddress LOCAL_ADDRESS = new RxtxDeviceAddress("localhost");, + private final RxtxChannelConfig config;, + private boolean open =
[+++ b/src/docbook/master.xml, +<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.docbook.org/xml/4.5/docbookx.dtd" []
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + p.addBefore(ctx.name(), "wsdecoder", newWebsocketDecoder());, + p.replace(ctx.name(), "wsencoder", newWebSocketEncoder());]
[+++ b/.classpath, +<?xml version="1.0" encoding="UTF-8"?>, +<classpath>, + <classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.7"/>, + <classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>, + <classpathentry kind="src" path="buffer/src/main/java"/>, + <classpathentry kind="src" path="codec/src/main/java"/>, + <classpathentry kind="src" path="codec-http/src/main/java"/>, + <classpathentry kind="src" path="common/src/main/java"/>, + <classpathentry kind="src" path="handler/src/main/java"/>, + <classpathentry kind="src" path="transport/src/main/java"/>, + <classpathentry combineaccessrules="false" kind="src" path="/ch.finnova.pe.jdk.build.time.dependencies"/>, + <classpathentry kind="output" path="bin"/>, +</classpath>, +++ b/.classpath, +<?xml version="1.0" encoding="UTF-8"?>, +<classpath>, + <classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.7"/>, + <classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>, + <classpathentry kind="src" path="buffer/src/main/java"/>, + <classpathentry kind="src" path="codec/src/main/java"/>, + <classpathentry kind="src" path="codec-http/src/main/java"/>, + <classpathentry kind="src" path="common/src/main/java"/>, + <classpathentry kind="src" path="handler/src/main/java"/>, + <classpathentry kind="src" path="transport/src/main/java"/>, + <classpathentry combineaccessrules="false" kind="src" path="/ch.finnova.pe.jdk.build.time.dependencies"/>, + <classpathentry kind="output" path="bin"/>, +</classpath>, +++ b/.gitignore, +bin/,
[+++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java, + selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);, +++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioChannel.java, + selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);, +++ b/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java, + private Selector selector;, + private Selector unwrappedSelector;, + unwrappedSelector = provider.openSelector();, + return unwrappedSelector;, + !((Class<?>) maybeSelectorImplClass).isAssignableFrom(unwrappedSelector.getClass())) {, + logger.trace("failed to instrument a special java.util.Set into: {}", unwrappedSelector, t);, + return unwrappedSelector;, + selectedKeysField.set(unwrappedSelector, selectedKeySet);, + publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);, + logger.trace("failed to instrument a special java.util.Set into: {}", unwrappedSelector, e);, + return unwrappedSelector;, + selectedKeys = selectedKeySet;, + logger.trace("instrumented a special java.util.Set into: {}", unwrappedSelector);, + return new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet);, + processSelectedKeysOptimized();, + private void processSelectedKeysOptimized() {, + for (int i
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketUtil.java, +import io.netty.util.concurrent.FastThreadLocal;, +, + private static final FastThreadLocal<MessageDigest> MD5 = new FastThreadLocal<MessageDigest>() {, + @Override, + protected MessageDigest initialValue() throws Exception {, + try {, + //Try to get a MessageDigest that uses MD5, + return MessageDigest.getInstance("MD5");, + } catch (NoSuchAlgorithmException e) {, + //This shouldn't happen! How old is the computer?, + throw new InternalError("MD5 not supported on this platform - Outdated?");, + }, + }, + };, +, + private static final FastThreadLocal<MessageDigest> SHA1 = new FastThreadLocal<MessageDigest>() {, + @Override, + protected MessageDigest initialValue() throws Exception {, + try {, + //Try to get a
[+++ b/src/assembly/default.xml, + <include>**/COPYRIGHT*</include>]
[+++ b/common/src/main/java/io/netty/util/concurrent/NonStickyEventExecutorGroup.java, + // After setting the state to NONE, look at the tasks queue one more time., + // If it is empty, then we can return from this method., + // Otherwise, it means the producer thread has called execute(Runnable), + // and enqueued a task in between the tasks.poll() above and the state.set(NONE) here., + // There are two possible scenarios when this happen, + //, + // 1. The producer thread sees state == NONE, hence the compareAndSet(NONE, SUBMITTED), + // is successfully setting the state to SUBMITTED. This mean the producer, + // will
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/WeightedFairQueueByteDistributor.java, + // Only the stream which was just added will change parents. So we only need an array of size 1., + List<ParentChangedEvent> events = new ArrayList<ParentChangedEvent>(1);, + connectionState.takeChild(newParent, false, events);, + notifyParentChanged(events);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/WeightedFairQueueByteDistributor.java, + // Only the stream which was just added will change parents. So we only need an array of size 1., + List<ParentChangedEvent> events = new ArrayList<ParentChangedEvent>(1);, + connectionState.takeChild(newParent, false, events);, + notifyParentChanged(events);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/WeightedFairQueueByteDistributorDependencyTreeTest.java, +, + // Unknown parent streams can come about in two ways:, + // 1. Because the stream is old and its state was purged, + //
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/UniformStreamByteDistributor.java, + if (size == 0) {, + State state = queue.pollFirst();, + if (state.streamableBytes > 0 && maxBytes == 0) {, + // Stop at the first state that can't send. Add this state back to the head of, + // the queue. Note that empty frames at the head of the queue will always be, + // written., + queue.addFirst(state);, + state.enqueued = true;, + break;, + }, + } while ((state = queue.pollFirst()) != null);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/UniformStreamByteDistributor.java, + if (size == 0) {, + State state = queue.pollFirst();, + if (state.streamableBytes > 0 && maxBytes
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateDecoderTest.java, + finalPayloadWrapped.release();, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateDecoderTest.java, + finalPayloadWrapped.release();, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + ByteBuf encoded = Base64.encode(Unpooled.wrappedBuffer(key.getEncoded()), true);, + buffer.writeBytes(encoded);, + encoded.release();, + ByteBuf encoded = Base64.encode(Unpooled.wrappedBuffer(cert.getEncoded()), true);, + buffer.writeBytes(encoded);, + encoded.release();, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateDecoderTest.java, + finalPayloadWrapped.release();, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + ByteBuf encoded = Base64.encode(Unpooled.wrappedBuffer(key.getEncoded()), true);, + buffer.writeBytes(encoded);, + encoded.release();, + ByteBuf encoded = Base64.encode(Unpooled.wrappedBuffer(cert.getEncoded()), true);, + buffer.writeBytes(encoded);, + encoded.release();, +++ b/handler/src/main/java/io/netty/handler/ssl/util/SelfSignedCertificate.java, +import io.netty.buffer.ByteBuf;, + ByteBuf enc = Base64.encode(Unpooled.wrappedBuffer(key.getEncoded()), true);, + String keyText = "-----BEGIN PRIVATE KEY-----\n" + enc.toString(CharsetUtil.US_ASCII) +, + enc.release();, + ByteBuf encoded = Base64.encode(Unpooled.wrappedBuffer(cert.getEncoded()), true);, + encoded.toString(CharsetUtil.US_ASCII) +, + encoded.release();]
[+++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, + /**, + * Determine if the string {@code s} ends with the char {@code c}., + *, + * @param s the string to test, + * @param c the tested char, + * @return true if {@code s} ends with the char {@code c}, + */, + public static boolean endsWith(CharSequence s, char c) {, + int len = s.length();, + return len > 0 && s.charAt(len - 1) == c;, + }, +, +++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, + /**, + * Determine if the string {@code s} ends with the char {@code c}., + *, +
[+++ b/src/docbook/en-US/module/architecture.xml, + of advanced features to accelerate the page of development even more., + idea to separate a protocol codec from business logic. However, there, + multi-layered (i.e. built on top of other lower level protocols). Some, + that generates maintainable user codecs., + Netty provides a number of basic and advanced codecs to address most, + issues you will encounter when you write a protocol codec regardless, + if it is simple or not, binary or text - simply whatever., + as SSL itself. You have to manage all possible states such as cipher, + suite and
[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, + public Future<?> shutdownGracefully() {, + return shutdownGracefully(2, 15, TimeUnit.SECONDS);, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, + public Future<?> shutdownGracefully() {, + return shutdownGracefully(2, 15, TimeUnit.SECONDS);, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutorGroup.java, + public Future<?> shutdownGracefully() {, + return shutdownGracefully(2, 15, TimeUnit.SECONDS);, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, + public Future<?> shutdownGracefully() {, + return shutdownGracefully(2, 15, TimeUnit.SECONDS);, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutorGroup.java, + public Future<?> shutdownGracefully() {, + return shutdownGracefully(2, 15, TimeUnit.SECONDS);, +++ b/common/src/main/java/io/netty/util/concurrent/CompleteFuture.java, + public Future<V> addListener(GenericFutureListener<? extends Future<? super V>> listener) {, + public Future<V> addListeners(GenericFutureListener<? extends Future<? super V>>... listeners) {, + for (GenericFutureListener<? extends Future<? super V>> l: listeners) {, + public Future<V> removeListener(GenericFutureListener<? extends Future<? super
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslContext.java, + * memory!</p>, + * <p><b>Beware</b>: the underlying generated {@link SSLEngine} won't have, + * <a href="https://wiki.openssl.org/index.php/Hostname_validation">hostname verification</a> enabled by default., + * If you create {@link SslHandler} for the client side and want proper security, we advice that you configure, + * the {@link SSLEngine} (see {@link javax.net.ssl.SSLParameters#setEndpointIdentificationAlgorithm(String)}):</p>, + * <pre>, + * SSLEngine sslEngine = sslHandler.engine();, + * SSLParameters sslParameters = sslEngine.getSSLParameters();, + * // only available since Java 7, + * sslParameters.setEndpointIdentificationAlgorithm("HTTPS");, + * sslEngine.setSSLParameters(sslParameters);, + * </pre>, + *, + * @param alloc If supported by the SSLEngine then the SSLEngine will use
[+++ b/pom.xml, + <version>3.0.0.CR6-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/pom.xml, + <version>3.1.1.GA</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.1.1.GA</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.1.1.GA</developerConnection>]
[+++ b/all/pom.xml, + <version>4.1.7.Final</version>, +++ b/all/pom.xml, + <version>4.1.7.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.7.Final</version>, +++ b/all/pom.xml, + <version>4.1.7.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.7.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.7.Final</version>, +++ b/all/pom.xml, + <version>4.1.7.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.7.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.7.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.7.Final</version>, +++ b/all/pom.xml, + <version>4.1.7.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.7.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.7.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.7.Final</version>, +++ b/codec-http/pom.xml, + <version>4.1.7.Final</version>, +++ b/all/pom.xml, + <version>4.1.7.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.7.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.7.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.7.Final</version>, +++ b/codec-http/pom.xml, + <version>4.1.7.Final</version>, +++ b/codec-http2/pom.xml, + <version>4.1.7.Final</version>, +++ b/all/pom.xml, + <version>4.1.7.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.7.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.7.Final</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java, +import java.nio.ByteOrder;, + crc.update(outArray, outIndex, outputLength);, + if (in.readableBytes() < 4) {, + verifyCrc(in);, + verifyCrc(buf);, +, + // read ISIZE and verify, + int dataLength = 0;, + for (int i = 0; i < 4; ++i) {, + dataLength |= buf.readUnsignedByte() << (i * 8);, + }, +, + private void verifyCrc(ByteBuf in) {, + long crcValue = 0;, + for (int i = 0; i < 4; ++i) {, + crcValue |= (long) in.readUnsignedByte() << (i * 8);, + }, + long readCrc = crc.getValue();, + if (crcValue != readCrc) {, + throw new
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + static final Set<String> SUPPORTED_PROTOCOLS_SET;, +, + final long pool = Pool.create(0);, +, + Set<String> protocols = new LinkedHashSet<String>(6);, + // Seems like there is no way to explicitly disable SSLv2Hello in openssl so it is always enabled, + protocols.add(PROTOCOL_SSL_V2_HELLO);, + try {, + if (doesSupportProtocol(pool, SSL.SSL_PROTOCOL_SSLV2)) {, + protocols.add(PROTOCOL_SSL_V2);, + }, + if (doesSupportProtocol(pool, SSL.SSL_PROTOCOL_SSLV3)) {, + protocols.add(PROTOCOL_SSL_V3);, + }, + if (doesSupportProtocol(pool, SSL.SSL_PROTOCOL_TLSV1)) {, + protocols.add(PROTOCOL_TLS_V1);, + }, + if (doesSupportProtocol(pool, SSL.SSL_PROTOCOL_TLSV1_1)) {, + protocols.add(PROTOCOL_TLS_V1_1);, + }, + if (doesSupportProtocol(pool, SSL.SSL_PROTOCOL_TLSV1_2)) {, + protocols.add(PROTOCOL_TLS_V1_2);, + }, + } finally {, + Pool.destroy(aprPool);, + }, +
[+++ b/codec/src/test/java/io/netty/handler/codec/LineBasedFrameDecoderTest.java, +, + @Test, + public void testDecodeSplitsCorrectly() throws Exception {, + EmbeddedChannel ch = new EmbeddedChannel(new LineBasedFrameDecoder(8192, false, false));, +, + assertTrue(ch.writeInbound(copiedBuffer("line\r\n.\r\n", CharsetUtil.US_ASCII)));, +, + ByteBuf buf = ch.readInbound();, + assertEquals("line\r\n", buf.toString(CharsetUtil.US_ASCII));, +, + ByteBuf buf2 = ch.readInbound();, + assertEquals(".\r\n", buf2.toString(CharsetUtil.US_ASCII));, + assertFalse(ch.finishAndReleaseAll());, +, + buf.release();, + buf2.release();, + }]
[+++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java, + private volatile int state; // 0 - none, 1 - initialized, 2 - destroyed, + if (ctx.channel().isActive() & ctx.channel().isRegistered()) {, + // channelActive() event has not been fired yet. this.channelActive() will be invoked, + public void channelRegistered(ChannelHandlerContext ctx) throws Exception {, + // Initialize early if channel is active already., + if (ctx.channel().isActive()) {, + initialize(ctx);, + }, + super.channelRegistered(ctx);, + }, +, + @Override, + switch (state) {, + case 1:, + case 2:, + state = 1;, +, + state = 2;, +++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java, + private volatile int state; // 0 - none, 1
[+++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioDatagramChannel.java, + * The {@link NioDatagramWorker} for this NioDatagramChannnel., + final NioDatagramWorker worker;, + final NioDatagramWorker worker) {, + * WriteTask is a simple runnable performs writes by delegating the {@link NioDatagramWorker}., + NioDatagramWorker.write(NioDatagramChannel.this, false);, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioDatagramChannel.java, + * The {@link NioDatagramWorker} for this NioDatagramChannnel., + final NioDatagramWorker worker;, + final NioDatagramWorker worker) {, + * WriteTask is a simple runnable performs writes by delegating the {@link NioDatagramWorker}., + NioDatagramWorker.write(NioDatagramChannel.this, false);, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioDatagramPipelineSink.java, + * A {@link NioDatagramPipelineSink} contains an array of {@link NioDatagramWorker}s, + private final NioDatagramWorker[] workers;, + * Creates a new {@link NioDatagramPipelineSink} with a
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import io.netty.util.internal.OneTimeTask;, + final ChannelPipeline p = channel.pipeline();, + final HttpClientCodec codec = (HttpClientCodec) ctx.handler();, + // Remove the encoder part of the codec as the user may start writing frames after this method returns., + codec.removeOutboundHandler();, +, + p.addAfter(ctx.name(), "ws-decoder", newWebsocketDecoder());, +, + // Delay the removal of the decoder so the user can setup the pipeline if needed to handle, + // WebSocketFrame messages., + // See https://github.com/netty/netty/issues/4533, + channel.eventLoop().execute(new OneTimeTask() {, + @Override, + public void run() {, + p.remove(codec);, + }, + });, + // Remove the encoder part of the codec as
[+++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, + private static final String[] BYTE2HEX = new String[256];, + private static final String[] HEXPADDING = new String[16];, + private static final String[] BYTEPADDING = new String[16];, + private static final char[] BYTE2CHAR = new char[256];, +, + static {, + int i;, +, + // Generate the lookup table for byte-to-hex-dump conversion, + for (i = 0; i < 10; i ++) {, + StringBuilder buf = new StringBuilder(3);, + buf.append(" 0");, + buf.append(i);, + BYTE2HEX[i] = buf.toString();, + }, + for (;i < 16; i ++) {, + StringBuilder buf = new StringBuilder(3);, + buf.append("
[+++ b/example/pom.xml, + <artifactId>netty-codec-memcache</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/example/pom.xml, + <artifactId>netty-codec-memcache</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/example/src/main/java/io/netty/example/memcache/binary/MemcacheClient.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software,
[+++ b/src/docbook/master.xml, + <title>The Netty Project 3.1 User Guide</title>]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, + // We need at least 4 remaining bytes to read the hash, + if (nextIndex > maxIndex - 4) {, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, + // We need at least 4 remaining bytes to read the hash, + if (nextIndex > maxIndex - 4) {, +++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java, + if (dataLength >= 32768) {, + ByteBuf slice = in.readSlice(32767);, + snappy.encode(slice, out, 32767);, + dataLength -= 32767;, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, + // We need at least 4 remaining bytes to read the hash, + if (nextIndex > maxIndex - 4) {, +++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java, + if (dataLength >= 32768) {, +
[+++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(AdvancedLeakAwareByteBuf.class);, +, +, + if (logger.isDebugEnabled()) {, + logger.debug("-D{}: {}", PROP_ACQUIRE_AND_RELEASE_ONLY, ACQUIRE_AND_RELEASE_ONLY);, + }]
[+++ b/common/src/main/java/io/netty/util/internal/MathUtil.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the, + * "License"); you may not use this file except in compliance with the License. You may obtain a, + * copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express, + *
[+++ b/all/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, + <phase>prepare-package</phase>, + <phase>prepare-package</phase>, + <phase>prepare-package</phase>, + <id>attach-javadocs</id>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, + <phase>prepare-package</phase>, + <phase>prepare-package</phase>, + <phase>prepare-package</phase>, + <id>attach-javadocs</id>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, + <phase>prepare-package</phase>, + <phase>prepare-package</phase>, + <phase>prepare-package</phase>, + <id>attach-javadocs</id>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + private final int maxCapacity;, + int refCnt = 1;, +, + protected AbstractByteBuf(ByteOrder endianness, int maxCapacity) {, + if (maxCapacity < 0) {, + throw new IllegalArgumentException("maxCapacity: " + maxCapacity + " (expected: >= 0)");, + }, + this.maxCapacity = maxCapacity;, + public int maxCapacity() {, + return maxCapacity;, + }, +,
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/DefaultHttpHeadersTest.java, +import java.util.Set;, +import static org.junit.Assert.*;, + @Test, + public void providesHeaderNamesAsArray() throws Exception {, + Set<String> nettyHeaders = new DefaultHttpHeaders(), + .add(HttpHeaderNames.CONTENT_LENGTH, 10), + .names();, +, + String[] namesArray = nettyHeaders.toArray(new String[nettyHeaders.size()]);, + assertArrayEquals(namesArray, new String[] { HttpHeaderNames.CONTENT_LENGTH.toString() });, + }, +, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/DefaultHttpHeadersTest.java, +import java.util.Set;, +import static org.junit.Assert.*;, + @Test, + public void providesHeaderNamesAsArray() throws Exception {, + Set<String> nettyHeaders = new DefaultHttpHeaders(), + .add(HttpHeaderNames.CONTENT_LENGTH, 10), + .names();, +, + String[] namesArray = nettyHeaders.toArray(new String[nettyHeaders.size()]);, + assertArrayEquals(namesArray, new String[] { HttpHeaderNames.CONTENT_LENGTH.toString() });, + }, +, +++ b/codec/src/main/java/io/netty/handler/codec/HeadersUtils.java, +import java.util.AbstractCollection;, + StringEntryIterator(Iterator<Entry<CharSequence, CharSequence>> iter) {, + StringIterator(Iterator<T>
[+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompHeaders.java, + super(CASE_SENSITIVE_HASHER, CharSequenceValueConverter.INSTANCE);, +++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompHeaders.java, + super(CASE_SENSITIVE_HASHER, CharSequenceValueConverter.INSTANCE);, +++ b/codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompHeadersTest.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT,
[+++ b/codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/DefaultSocks5CommandResponseTest.java, + buffer.release();, + buffer.release();, + buffer.release();]
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionRoundtripTest.java, + private static final long DEFAULT_AWAIT_TIMEOUT_SECONDS = 15;, +, + assertTrue(latch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(requestLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(serverSettingsAckLatch1.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(clientDataWrite.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(clientSettingsLatch1.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(serverSettingsAckLatch2.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(clientHeadersLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(serverRevHeadersLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(serverSettingsAckLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(requestLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(serverSettingsAckLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(requestLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(serverSettingsAckLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(requestLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(closeLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(serverSettingsAckLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(requestLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(closeLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(serverSettingsAckLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(requestLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(serverSettingsAckLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(goAwayLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + eq(PROTOCOL_ERROR.code()), any(ByteBuf.class));, + assertTrue(serverSettingsAckLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(trailersLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(prefaceWrittenLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + assertTrue(serverInitLatch.await(DEFAULT_AWAIT_TIMEOUT_SECONDS, SECONDS));, + private static void mockFlowControl(Http2FrameListener listener) throws
[+++ b/transport/src/main/java/io/netty/channel/socket/oio/AbstractOioChannel.java, + protected abstract class AbstractOioUnsafe extends AbstractUnsafe implements OioUnsafe {, +++ b/transport/src/main/java/io/netty/channel/socket/oio/AbstractOioChannel.java, + protected abstract class AbstractOioUnsafe extends AbstractUnsafe implements OioUnsafe {, +++ b/transport/src/main/java/io/netty/channel/socket/oio/AbstractOioMessageChannel.java, +package io.netty.channel.socket.oio;, +, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelBufferHolder;, +import io.netty.channel.ChannelBufferHolders;, +import io.netty.channel.ChannelPipeline;, +, +import java.io.IOException;, +import java.util.Queue;, +, +abstract class AbstractOioMessageChannel extends AbstractOioChannel {, +, + private final ChannelBufferHolder<Object> firstOut = ChannelBufferHolders.messageBuffer();, +, + protected AbstractOioMessageChannel(Channel parent, Integer id) {, + super(parent, id);, + }, +, + @Override, + protected ChannelBufferHolder<Object> firstOut() {, + return firstOut;, + }, +, + @Override, + protected Unsafe newUnsafe() {, + return new OioMessageUnsafe();, + }, +, +
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelPromise.java, + private volatile Throwable cause;, + public boolean isDone() {, + public boolean isSuccess() {, + Throwable cause = this.cause;, + if (isDone()) {, + notifyListener(this, listener);, + return this;, + }, +, + if (isDone()) {, + if (isDone()) {, + return this;, + }, +, + if (!isDone()) {, + if (isDone()) {, + return this;, + }, +, + while (!isDone()) {, + if (isDone()) {, + return this;, + }, +, + while (!isDone()) {, + if (isDone()) {, + return true;, + }, +, + if (timeoutNanos <= 0) {, + return
[+++ b/buffer/src/main/java/io/netty/buffer/PoolChunkList.java, +import static java.lang.Math.*;, +, + return max(1, minUsage);, + return min(maxUsage, 100);]
[+++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBuf.java, + public CompositeByteBuf addComponent(boolean increaseWriterIndex, ByteBuf buffer) {, + recordLeakNonRefCountingOperation(leak);, + return super.addComponent(increaseWriterIndex, buffer);, + }, +, + @Override, + public CompositeByteBuf addComponents(boolean increaseWriterIndex, ByteBuf... buffers) {, + recordLeakNonRefCountingOperation(leak);, + return super.addComponents(increaseWriterIndex, buffers);, + }, +, + @Override, + public CompositeByteBuf addComponents(boolean increaseWriterIndex, Iterable<ByteBuf> buffers) {, + recordLeakNonRefCountingOperation(leak);, + return super.addComponents(increaseWriterIndex, buffers);, + }, +, + @Override, + public CompositeByteBuf addComponent(boolean increaseWriterIndex, int cIndex, ByteBuf buffer) {, + recordLeakNonRefCountingOperation(leak);, + return super.addComponent(increaseWriterIndex, cIndex, buffer);, + }, +, + @Override, + public CompositeByteBuf removeComponent(int cIndex) {, + recordLeakNonRefCountingOperation(leak);, + return super.removeComponent(cIndex);, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBuf.java,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + final String header, final List<String> names, final List<String> values) {, + final int headerLen = header.length();, + loop: for (int i = 0;;) {, +, + // Skip spaces and separators., + for (;;) {, + if (i == headerLen) {, + break loop;, + switch (header.charAt(i)) {, + case '\t': case '\n': case 0x0b: case '\f': case '\r':, + case ' ': case ',': case ';':, + i ++;, + break;, + }, + // Skip '$'., + for (;;) {, + if (i == headerLen) {, + break loop;, + }, + if (header.charAt(i)
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + private boolean freed;, + if (!removed || freed) {, + freed = true;]
[+++ b/common/src/main/java/io/netty/util/AsyncMapping.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/common/src/main/java/io/netty/util/internal/Cleaner.java, +/*, +* Copyright 2017 The Netty Project, +*, +* The Netty Project licenses this file to you under the Apache License,, +* version 2.0 (the "License"); you may not use this file except in compliance, +* with the License. You may obtain a copy of the License at:, +*, +* http://www.apache.org/licenses/LICENSE-2.0, +*, +* Unless required by applicable law or agreed to in writing, software, +* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, +* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, +* License for the specific language governing
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, + if (b == -1 && lineBuf.length() == 0) {, + return null;, + }, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, + if (b == -1 && lineBuf.length() == 0) {, + return null;, + }, +++ b/buffer/src/test/java/io/netty/buffer/ChannelBufferStreamTest.java, +import java.nio.charset.Charset;, + public void testReadLine() throws Exception {, + Charset utf8=Charset.forName("UTF-8");, + ByteBuf buf = Unpooled.buffer();, + assertNull(s);, + int charCount=5;//total chars in the string below without new line characters, + byte[] abc = "a\nb\r\nc\nd\ne".getBytes(utf8);, + buf.writeBytes(abc);, + in.mark(charCount);, + assertEquals("a",in.readLine());, + assertEquals("b",in.readLine());, + assertEquals("c",in.readLine());, + assertEquals("d",in.readLine());, + assertEquals("e",in.readLine());, + assertNull(in.readLine());, +, + in.reset();, + int count=0;, + while(in.readLine() != null){, +
[+++ b/transport/src/main/java/io/netty/channel/ChannelFuture.java, + * | isCancelled() = false | | | cause() = <b>non-null</b> |, + * | cause() = null | | +===========================+, + * f.cause().printStackTrace();, + * f.cause().printStackTrace();]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, + default:]
[+++ b/all/pom.xml, + <version>4.1.27.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.27.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.27.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.27.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.27.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, + <version>4.1.27.Final-SNAPSHOT</version>, +
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java, + sc = setupServerChannel(sb, bytes, latch, false);, + final CountDownLatch clientLatch = new CountDownLatch(count);, +, + cb.handler(new SimpleChannelInboundHandler<DatagramPacket>() {, + public void channelRead0(ChannelHandlerContext ctx, DatagramPacket msg) throws Exception {, + ByteBuf buf = msg.content();, + assertEquals(bytes.length, buf.readableBytes());, + for (int i = 0; i < bytes.length; i++) {, + assertEquals(bytes[i], buf.getByte(buf.readerIndex() + i));, + }, +, + // Test that the channel's localAddress is equal to the message's recipient, + assertEquals(ctx.channel().localAddress(), msg.recipient());, +, + clientLatch.countDown();, + sc = setupServerChannel(sb, bytes, latch, true);, + assertTrue(clientLatch.await(10, TimeUnit.SECONDS));, + private Channel setupServerChannel(Bootstrap sb, final byte[] bytes, final CountDownLatch latch, final
[+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java, + int qos = buffer.readUnsignedByte();, + if (qos != MqttQoS.FAILURE.value()) {, + qos &= 0x03;, + }, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java, + int qos = buffer.readUnsignedByte();, + if (qos != MqttQoS.FAILURE.value()) {, + qos &= 0x03;, + }, +++ b/codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java, + public void testSubAckMessageWithFailureInPayload() throws Exception {, + MqttFixedHeader mqttFixedHeader =, + new MqttFixedHeader(MqttMessageType.SUBACK, false, MqttQoS.AT_MOST_ONCE, false, 0);, + MqttMessageIdVariableHeader mqttMessageIdVariableHeader = MqttMessageIdVariableHeader.from(12345);, + MqttSubAckPayload mqttSubAckPayload = new MqttSubAckPayload(MqttQoS.FAILURE.value());, + MqttSubAckMessage message =, + new MqttSubAckMessage(mqttFixedHeader, mqttMessageIdVariableHeader, mqttSubAckPayload);, +, + ByteBuf byteBuf = MqttEncoder.doEncode(ALLOCATOR, message);, +, + List<Object> out = new LinkedList<Object>();, + mqttDecoder.decode(ctx, byteBuf, out);, +, + assertEquals("Expected
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/codec/src/test/java/io/netty/handler/codec/ReplayingDecoderTest.java, +import io.netty.channel.embedded.EmbeddedStreamChannel;, + EmbeddedStreamChannel ch = new EmbeddedStreamChannel(new LineDecoder());,
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameLogger.java, +import io.netty.channel.ChannelHandlerContext;, + public void logData(Direction direction, ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding,, + "%s DATA: streamId=%d, padding=%d, endStream=%b, length=%d, bytes=%s",, + ctx.channel(), streamId, padding, endStream, data.readableBytes(), toString(data));, + public void logHeaders(Direction direction, ChannelHandlerContext ctx, int streamId, Http2Headers headers,, + int padding, boolean endStream) {, + log(direction, "%s HEADERS: streamId=%d, headers=%s, padding=%d, endStream=%b",, + ctx.channel(), streamId, headers, padding, endStream);, + public void logHeaders(Direction direction, ChannelHandlerContext ctx, int streamId, Http2Headers headers,, + "%s HEADERS: streamId=%d, headers=%s, streamDependency=%d, weight=%d, ", + + "exclusive=%b, padding=%d, endStream=%b",, + ctx.channel(), streamId, headers, streamDependency, weight, exclusive, padding, endStream);, + public void
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DataCompressionHttp2Test.java, +import java.io.ByteArrayOutputStream;, +import java.io.IOException;, +import java.net.InetSocketAddress;, +import java.util.Random;, +import java.util.concurrent.CountDownLatch;, +, +import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_PRIORITY_WEIGHT;, +import static io.netty.handler.codec.http2.Http2TestUtil.as;, +import static io.netty.handler.codec.http2.Http2TestUtil.runInChannel;, +import static java.util.concurrent.TimeUnit.MILLISECONDS;, +import static java.util.concurrent.TimeUnit.SECONDS;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertTrue;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyBoolean;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.anyShort;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.doAnswer;, +import static org.mockito.Mockito.verify;, +, + private CountDownLatch serverLatch;, + public void setup() throws InterruptedException, Http2Exception {, + doAnswer(new Answer<Void>() {, + @Override, + public Void answer(InvocationOnMock invocation) throws Throwable {, + if (invocation.getArgumentAt(4, Boolean.class)) {, + serverConnection.stream(invocation.getArgumentAt(1, Integer.class)).close();, + }, + return null;, + }, + }).when(serverListener).onHeadersRead(any(ChannelHandlerContext.class),
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +import io.netty.util.internal.StringUtil;, + private Throwable lastWriteException;, + if (lastWriteException == null) {, + lastWriteException = t;, + } else if (logger.isWarnEnabled()) {, + logger.warn(, + "More than one exception was raised by " + StringUtil.simpleClassName(handler) + ".write()." +, + "Will fail the subsequent flush() with the first one and log others.", t);, + }, + Throwable lastWriteException = this.lastWriteException;, + if (lastWriteException != null) {, + this.lastWriteException = null;, + promise.setFailure(lastWriteException);, + return;, + }, +]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java, +import io.netty.util.internal.OneTimeTask;, + executor.execute(new OneTimeTask() {, + ctx.executor().schedule(new OneTimeTask() {, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java, +import io.netty.util.internal.OneTimeTask;, + executor.execute(new OneTimeTask() {, + ctx.executor().schedule(new OneTimeTask() {, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java, +import io.netty.util.internal.OneTimeTask;, + executor.execute(new OneTimeTask() {, + ctx.executor().schedule(new OneTimeTask() {, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java, +import io.netty.util.internal.OneTimeTask;, + executor.execute(new OneTimeTask() {, + ctx.executor().schedule(new OneTimeTask() {, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java, +import io.netty.util.internal.OneTimeTask;, + executor.execute(new OneTimeTask() {, + ctx.executor().schedule(new OneTimeTask() {, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + ctx.executor().execute(new OneTimeTask() {, + outboundClosed = true;, + delegatedTaskExecutor.execute(new OneTimeTask() {, + final ScheduledFuture<?> timeoutFuture = ctx.executor().schedule(new OneTimeTask() {, + timeoutFuture = ctx.executor().schedule(new OneTimeTask() {, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java, +import io.netty.util.internal.OneTimeTask;, + executor.execute(new OneTimeTask() {, + ctx.executor().schedule(new OneTimeTask()
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import java.util.Arrays;, +import java.util.HashSet;, + static final Set<String> AVAILABLE_CIPHER_SUITES;, + private static final Set<String> AVAILABLE_OPENSSL_CIPHER_SUITES;, + private static final Set<String> AVAILABLE_JAVA_CIPHER_SUITES;, +, + // Protocols, + static final String PROTOCOL_SSL_V2_HELLO = "SSLv2Hello";, + static final String PROTOCOL_SSL_V2 = "SSLv2";, + static final String PROTOCOL_SSL_V3 = "SSLv3";, + static final String PROTOCOL_TLS_V1 = "TLSv1";, + static final String PROTOCOL_TLS_V1_1 = "TLSv1.1";, + static final String PROTOCOL_TLS_V1_2 = "TLSv1.2";, +, + private static final String[] SUPPORTED_PROTOCOLS = {, + PROTOCOL_SSL_V2_HELLO,, + PROTOCOL_SSL_V2,, + PROTOCOL_SSL_V3,, + PROTOCOL_TLS_V1,, + PROTOCOL_TLS_V1_1,, + PROTOCOL_TLS_V1_2, + };, + static final Set<String> SUPPORTED_PROTOCOLS_SET = Collections.unmodifiableSet(,
[+++ b/common/src/main/java/io/netty/util/DomainMappingBuilder.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/pom.xml, + <version>8</version>]
[+++ b/pom.xml, +++ b/pom.xml, +++ b/tarball/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +, + <!-- Disable animal sniffer -->, + <plugin>, + <groupId>org.codehaus.mojo</groupId>, + <artifactId>animal-sniffer-maven-plugin</artifactId>, + <executions>, + <execution>, + <id>default</id>, + <phase>none</phase>, + </execution>, + </executions>, + </plugin>, + <!-- Disable checkstyle -->, + <plugin>, + <artifactId>maven-checkstyle-plugin</artifactId>, + <executions>, + <execution>, + <id>check-style</id>, + <phase>none</phase>, + </execution>, + </executions>, + </plugin>, + <!-- Do not deploy this module -->, + <plugin>, + <artifactId>maven-deploy-plugin</artifactId>, + <version>2.7</version>, + <configuration>, + <skip>true</skip>, + </configuration>, + </plugin>, + </plugins>, + </build>, +, + <profiles>, + <profile>, + <id>full</id>, + <build>, + <plugins>, + <phase>prepare-package</phase>, + <phase>prepare-package</phase>,
[+++ b/example/src/main/java/io/netty/example/http/cors/HttpServerInitializer.java, + pipeline.addLast("encoder", new HttpResponseEncoder());, +++ b/example/src/main/java/io/netty/example/http/cors/HttpServerInitializer.java, + pipeline.addLast("encoder", new HttpResponseEncoder());, +++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerInitializer.java, + pipeline.addLast("encoder", new HttpResponseEncoder());, +++ b/example/src/main/java/io/netty/example/http/cors/HttpServerInitializer.java, + pipeline.addLast("encoder", new HttpResponseEncoder());, +++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerInitializer.java, + pipeline.addLast("encoder", new HttpResponseEncoder());, +++ b/example/src/main/java/io/netty/example/http/websocketx/html5/WebSocketServer.java, + new HttpResponseEncoder(),, +++ b/example/src/main/java/io/netty/example/http/cors/HttpServerInitializer.java, + pipeline.addLast("encoder", new HttpResponseEncoder());, +++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerInitializer.java, + pipeline.addLast("encoder", new HttpResponseEncoder());, +++ b/example/src/main/java/io/netty/example/http/websocketx/html5/WebSocketServer.java, + new HttpResponseEncoder(),, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerInitializer.java, + pipeline.addLast("encoder", new HttpResponseEncoder());, +++ b/example/src/main/java/io/netty/example/http/cors/HttpServerInitializer.java, + pipeline.addLast("encoder", new HttpResponseEncoder());, +++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerInitializer.java, + pipeline.addLast("encoder", new HttpResponseEncoder());, +++ b/example/src/main/java/io/netty/example/http/websocketx/html5/WebSocketServer.java, + new HttpResponseEncoder(),, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerInitializer.java, + pipeline.addLast("encoder", new HttpResponseEncoder());, +++ b/testsuite/src/test/java/io/netty/testsuite/websockets/autobahn/AutobahnServerInitializer.java, + pipeline.addLast("encoder", new HttpResponseEncoder());]
[+++ b/pom.xml, + <version>14</version>, +++ b/pom.xml, + <version>14</version>, +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +public abstract class AbstractBootstrap<B extends AbstractBootstrap<?>> implements Cloneable {, + private ChannelFactory channelFactory;, + AbstractBootstrap() {, + // Disallow extending from a different package., + }, +, + AbstractBootstrap(AbstractBootstrap<B> bootstrap) {, + group = bootstrap.group;, + channelFactory = bootstrap.channelFactory;, + handler = bootstrap.handler;, + localAddress = bootstrap.localAddress;, + options.putAll(bootstrap.options);, + attrs.putAll(bootstrap.attrs);, + }, +, + public B channelFactory(ChannelFactory channelFactory) {, + if (channelFactory == null) {, + throw new NullPointerException("channelFactory");, + if (this.channelFactory != null) {, + throw new IllegalStateException("channelFactory set already");, + this.channelFactory = channelFactory;, + if (channelFactory
[+++ b/common/src/main/java/io/netty/util/concurrent/PromiseCombiner.java, +/**, + * <p>A promise combiner monitors the outcome of a number of discrete futures, then notifies a final, aggregate promise, + * when all of the combined futures are finished. The aggregate promise will succeed if and only if all of the combined, + * futures succeed. If any of the combined futures fail, the aggregate promise will fail. The cause failure for the, + * aggregate promise will be the failure for one of the failed combined futures; if more than one of the combined, + * futures fails, exactly which cause of failure will
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java, +import io.netty.util.ReferenceCountUtil;, + doAnswer(new Answer() {, + @Override, + public Object answer(InvocationOnMock in) throws Throwable {, + Object msg = in.getArgumentAt(0, Object.class);, + ReferenceCountUtil.release(msg);, + return null;, + }, + }).when(ctx).fireChannelRead(any());, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java, +import io.netty.util.ReferenceCountUtil;, + doAnswer(new Answer() {, + @Override, + public Object answer(InvocationOnMock in) throws Throwable {, + Object msg = in.getArgumentAt(0, Object.class);, + ReferenceCountUtil.release(msg);, + return null;, + }, + }).when(ctx).fireChannelRead(any());, +++ b/codec/src/test/java/io/netty/handler/codec/ReplayingDecoderTest.java, + assertEquals(Unpooled.wrappedBuffer(new byte[] { 'A', 'B', 'C' }), releaseLater(ch.readInbound()));]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java, + public Http2Headers clear() {, + this.firstNonPseudo = head;, + return super.clear();, + }, +, + @Override, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java, + public Http2Headers clear() {, + this.firstNonPseudo = head;, + return super.clear();, + }, +, + @Override, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2HeadersTest.java, +import static org.junit.Assert.assertEquals;, + @Test, + public void testClearResetsPseudoHeaderDivision() {, + DefaultHttp2Headers http2Headers = new DefaultHttp2Headers();, + http2Headers.method("POST");, + http2Headers.set("some", "value");, + http2Headers.clear();, + http2Headers.method("GET");, + assertEquals(1, http2Headers.names().size());, + }, +]
[+++ b/pom.xml, + <version>19</version>]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + public PrefaceDecoder(ChannelHandlerContext ctx) throws Exception {, + private void sendPreface(ChannelHandlerContext ctx) throws Exception {, + // If this handler is extended by the user and we directly fire the userEvent from this context then, + // the user will not see the event. We should fire the event starting with this handler so this class, + // (and extending classes) have a chance to process the event., + userEventTriggered(ctx, Http2ConnectionPrefaceAndSettingsFrameWrittenEvent.INSTANCE);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + public PrefaceDecoder(ChannelHandlerContext ctx) throws Exception {, + private void sendPreface(ChannelHandlerContext ctx) throws Exception {, + // If this handler is extended by the
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + private void fillInboundBridge() {, + if (!(handler instanceof ChannelInboundHandler)) {, + return;, + }, +, + }, +, + private void fillOutboundBridge() {, + if (!(handler instanceof ChannelOutboundHandler)) {, + return;, + }, + private void flushInboundBridge() {, + }, + private void flushOutboundBridge() {, + next.fillInboundBridge();, + if (handler instanceof ChannelInboundHandler) {, + flushInboundBridge();, + }, +, + prev.fillOutboundBridge();, + if (handler instanceof ChannelInboundHandler) {, + flushOutboundBridge();, + }, +, + ChannelOperationHandler handler = (ChannelOperationHandler) handler();, + if (handler instanceof ChannelOutboundHandler) {, + flushOutboundBridge();, + }, +, + handler.sendFile(this, region, promise);]
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +import org.jctools.queues.MpscUnboundedArrayQueue;, +import org.jctools.queues.atomic.MpscGrowableAtomicArrayQueue;, +import org.jctools.queues.atomic.MpscUnboundedAtomicArrayQueue;, +import static java.lang.Math.max;, +import static java.lang.Math.min;, + final int capacity = max(min(maxCapacity, MAX_ALLOWED_MPSC_CAPACITY), MIN_MAX_MPSC_CAPACITY);, + return USE_MPSC_CHUNKED_ARRAY_QUEUE ? new MpscChunkedArrayQueue<T>(MPSC_CHUNK_SIZE, capacity), + : new MpscGrowableAtomicArrayQueue<T>(MPSC_CHUNK_SIZE, capacity);, +, + static <T> Queue<T> newMpscQueue() {, + return USE_MPSC_CHUNKED_ARRAY_QUEUE ? new MpscUnboundedArrayQueue<T>(MPSC_CHUNK_SIZE), + : new MpscUnboundedAtomicArrayQueue<T>(MPSC_CHUNK_SIZE);, + * @return A MPSC queue which may be unbounded., + return Mpsc.newMpscQueue();, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +import org.jctools.queues.MpscUnboundedArrayQueue;, +import org.jctools.queues.atomic.MpscGrowableAtomicArrayQueue;, +import org.jctools.queues.atomic.MpscUnboundedAtomicArrayQueue;, +import static java.lang.Math.max;, +import static java.lang.Math.min;, + final int capacity = max(min(maxCapacity, MAX_ALLOWED_MPSC_CAPACITY), MIN_MAX_MPSC_CAPACITY);, + return USE_MPSC_CHUNKED_ARRAY_QUEUE ? new MpscChunkedArrayQueue<T>(MPSC_CHUNK_SIZE, capacity), + : new MpscGrowableAtomicArrayQueue<T>(MPSC_CHUNK_SIZE, capacity);, +,
[+++ b/common/pom.xml, +++ b/common/pom.xml, +++ /dev/null, +++ b/common/pom.xml, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +++ b/common/pom.xml, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +++ b/common/src/main/java/io/netty/util/internal/TypeParameterMatcher.java, + private static final TypeParameterMatcher NOOP = new TypeParameterMatcher() {, + @Override, + public boolean match(Object msg) {, + return true;, + }, + };, + } else {, + TypeParameterMatcher() { }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieDecoder.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java, +import java.util.List;, +import static io.netty.handler.codec.http.HttpHeaderNames.CONNECTION;, +import static io.netty.handler.codec.http.HttpHeaderNames.COOKIE;, +import static io.netty.handler.codec.http.HttpHeaderNames.TE;, +import static io.netty.handler.codec.http.HttpHeaderValues.TRAILERS;, +import static io.netty.util.AsciiString.contentEqualsIgnoreCase;, +import static io.netty.util.AsciiString.indexOf;, +import static io.netty.util.AsciiString.trim;, +import static io.netty.util.internal.StringUtil.unescapeCsvFields;, + HTTP_TO_HTTP2_HEADER_BLACKLIST.add(CONNECTION, EMPTY_STRING);, + /**, + * Filter the {@link HttpHeaderNames#TE} header according to the, + * <a href="https://tools.ietf.org/html/rfc7540#section-8.1.2.2">special rules in the HTTP/2 RFC</a>., + * @param entry An entry whose name is {@link HttpHeaderNames#TE}., + * @param out the resulting HTTP/2 headers., + */, + private static void toHttp2HeadersFilterTE(Entry<CharSequence, CharSequence> entry,, + Http2Headers out) {, + if (indexOf(entry.getValue(), ',', 0) == -1) {, + if (contentEqualsIgnoreCase(trim(entry.getValue()), TRAILERS)) {, + out.add(TE,
[+++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java, + protected void encode(ChannelHandlerContext ctx, ByteBuf uncompressed, ByteBuf out) throws Exception {, + out.writeBytes(uncompressed);]
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00Test.java, +import io.netty.channel.embedded.EmbeddedByteChannel;, +import io.netty.handler.codec.http.HttpResponseDecoder;, +import io.netty.util.CharsetUtil;, + EmbeddedByteChannel ch = new EmbeddedByteChannel(, + new HttpChunkAggregator(42), new HttpRequestDecoder(), new HttpResponseEncoder());, + ByteBuf buffer = ByteBufs.copiedBuffer("^n:ds[4U", CharsetUtil.US_ASCII);, + new WebSocketServerHandshaker00(, + "ws://example.com/chat", "chat", Integer.MAX_VALUE).handshake(ch, req);, + ByteBuf resBuf = ch.readOutbound();, +, + EmbeddedByteChannel ch2 = new EmbeddedByteChannel(new HttpResponseDecoder());, + ch2.writeInbound(resBuf);, + HttpResponse res = (HttpResponse) ch2.readInbound();, +, + Assert.assertEquals("ws://example.com/chat", res.getHeader(Names.SEC_WEBSOCKET_LOCATION));, + Assert.assertEquals("chat", res.getHeader(Names.SEC_WEBSOCKET_PROTOCOL));, + Assert.assertEquals("8jKS'y:G*Co,Wxa-", res.getContent().toString(CharsetUtil.US_ASCII));, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00Test.java, +import io.netty.channel.embedded.EmbeddedByteChannel;, +import io.netty.handler.codec.http.HttpResponseDecoder;, +import io.netty.util.CharsetUtil;, + EmbeddedByteChannel ch = new EmbeddedByteChannel(, + new HttpChunkAggregator(42), new HttpRequestDecoder(), new HttpResponseEncoder());, + ByteBuf buffer = ByteBufs.copiedBuffer("^n:ds[4U", CharsetUtil.US_ASCII);, + new WebSocketServerHandshaker00(, + "ws://example.com/chat", "chat",
[+++ b/buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java, + direct = false;, +++ b/buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java, + direct = false;, +++ b/buffer/src/test/java/io/netty/buffer/FixedCompositeByteBufTest.java, +, + @Test, + public void testEmptyArray() {, + ByteBuf buf = newBuffer(new ByteBuf[0]);, + buf.release();, + }]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractUnsafeSwappedByteBuf.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/handler/src/main/java/io/netty/handler/ssl/CipherSuiteConverter.java, + "(?:DHE|EDH|ECDH|ECDHE|SRP)-(?:DSS|RSA|ECDSA)|" +, + "(?:ADH|AECDH|KRB5|PSK|SRP)" +, + * Converts the specified Java cipher suites to the colon-separated OpenSSL cipher suite specification., + */, + static String toOpenSsl(Iterable<String> javaCipherSuites) {, + final StringBuilder buf = new StringBuilder();, + for (String c: javaCipherSuites) {, + if (c == null) {, + break;, + }, +, + String converted = toOpenSsl(c);, + if (converted != null) {, + c = converted;, + }, +, + buf.append(c);, + buf.append(':');, + }, +, + if (buf.length() > 0) {, + buf.setLength(buf.length() - 1);, + return buf.toString();, + } else {, + return
[+++ b/microbench/pom.xml, + <version>0.4.1</version>, +++ b/microbench/pom.xml, + <version>0.4.1</version>, +++ b/microbench/src/test/java/io/netty/microbench/buffer/ByteBufAllocatorBenchmark.java, +import org.openjdk.jmh.annotations.Param;, + @Param({ "00000", "00256", "01024", "04096", "16384", "65536" }), + public int size;, +, + public void unpooledHeapAllocAndFree() {, + ByteBuf buffer = unpooledHeapAllocator.buffer(size);, + public void unpooledDirectAllocAndFree() {, + ByteBuf buffer = unpooledDirectAllocator.buffer(size);, + public void pooledHeapAllocAndFree() {, + ByteBuf buffer = pooledHeapAllocator.buffer(size);, + public void pooledDirectAllocAndFree() {, + ByteBuf buffer = pooledDirectAllocator.buffer(size);, +++ b/microbench/pom.xml, + <version>0.4.1</version>, +++ b/microbench/src/test/java/io/netty/microbench/buffer/ByteBufAllocatorBenchmark.java, +import org.openjdk.jmh.annotations.Param;, + @Param({ "00000", "00256", "01024", "04096", "16384", "65536" }), + public int size;, +, + public void unpooledHeapAllocAndFree() {, + ByteBuf buffer = unpooledHeapAllocator.buffer(size);, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, +, +import java.io.File;, +import java.security.PrivateKey;, +import java.security.cert.X509Certificate;, +, +import static io.netty.handler.ssl.ReferenceCountedOpenSslClientContext.newSessionContext;, + * <p>This class will use a finalizer to ensure native resources are automatically cleaned up. To avoid finalizers, + * and manually release the native memory see {@link ReferenceCountedOpenSslClientContext}., + sessionContext = newSessionContext(this, ctx, engineMap, trustCertCollection, trustManagerFactory,, + release();, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, +, +import java.io.File;, +import java.security.PrivateKey;, +import java.security.cert.X509Certificate;, +, +import static io.netty.handler.ssl.ReferenceCountedOpenSslClientContext.newSessionContext;, + * <p>This class will use a finalizer to ensure native resources are automatically cleaned up. To avoid finalizers, + * and manually release the native memory see {@link ReferenceCountedOpenSslClientContext}., + sessionContext =
[+++ b/all/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.CR1-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, + WebSocketFrame frame;, + frame = decodeBinaryFrame(ctx, type, in);, + frame = decodeTextFrame(ctx, in);, + }, +, + if (frame != null) {, + out.add(frame);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshakerFactory.java, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelPromise;, + * @deprecated use {@link #sendUnsupportedVersionResponse(Channel)}, + @Deprecated, + sendUnsupportedVersionResponse(channel);, + }, +, + /**, + * Return that we need cannot not support the web socket version, + */, + public static ChannelFuture sendUnsupportedVersionResponse(Channel channel) {, + return sendUnsupportedVersionResponse(channel, channel.newPromise());, + }, +, + /**, + * Return that we need cannot not support the web socket version, + */, + public static ChannelFuture sendUnsupportedVersionResponse(Channel channel, ChannelPromise promise) {, + return channel.write(res, promise);]
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + // this must be initialized before any code below triggers initialization of PlatformDependent0, + private static final boolean IS_EXPLICIT_NO_UNSAFE = explicitNoUnsafe0();, +, + static boolean isExplicitNoUnsafe() {, + return IS_EXPLICIT_NO_UNSAFE;, + }, +, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + // this must be initialized before any code below triggers initialization of PlatformDependent0, + private static final boolean IS_EXPLICIT_NO_UNSAFE = explicitNoUnsafe0();, +, + static boolean isExplicitNoUnsafe() {, + return IS_EXPLICIT_NO_UNSAFE;, + }, +, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + final ByteBuffer direct;, +, + if (PlatformDependent.isExplicitNoUnsafe()) {, + direct = null;, + addressField = null;, + } else {, + direct = ByteBuffer.allocateDirect(1);,
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFrameDecoder.java, + ByteBuf uncompressed = ctx.alloc().buffer();, + try {, + uncompressed = null;, + } finally {, + if (uncompressed != null) {, + uncompressed.release();, + }, + }]
[+++ b/common/src/main/java/io/netty/util/Attribute.java, +/**, + * An attribute which allows to store an value reference. It may be updated atomically and so is thread-safe., + *, + * @param <T> the type of the value it holds., + */, + /**, + * Returns the current value, which may be {@code null}, + */, +, + /**, + * Sets the value, + */, +, + /**, + * Atomically sets to the given value and returns the old value which may be {@code null} if non was set before., + */, +, + /**, + * Atomically sets to
[+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/BulkStringHeaderRedisMessage.java, + if (bulkStringLength <= 0) {, + throw new RedisCodecException("bulkStringLength: " + bulkStringLength + " (expected: > 0)");, + }, +++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/BulkStringHeaderRedisMessage.java, + if (bulkStringLength <= 0) {, + throw new RedisCodecException("bulkStringLength: " + bulkStringLength + " (expected: > 0)");, + }, +++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisBulkStringAggregator.java, +++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/BulkStringHeaderRedisMessage.java, + if (bulkStringLength <= 0) {, + throw new RedisCodecException("bulkStringLength: " + bulkStringLength + " (expected: > 0)");, + }, +++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisBulkStringAggregator.java, +++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/RedisDecoder.java, + return decodeBulkString(in, out);, + private boolean decodeBulkString(ByteBuf in, List<Object> out) throws Exception {, + switch (remainingBulkLength) {, + out.add(new BulkStringHeaderRedisMessage(remainingBulkLength));, +++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/BulkStringHeaderRedisMessage.java, + if (bulkStringLength <=
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioChannelConfig.java]
[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, +import java.util.Collection;, +import java.util.Set;, + private final Collection<AbstractEventExecutor> selfCollection = Collections.singleton(this);, + public <E extends EventExecutor> Set<E> children() {, + return (Set<E>) selfCollection;, + }, +, + @Override, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, +import java.util.Collection;, +import java.util.Set;, + private final Collection<AbstractEventExecutor> selfCollection = Collections.singleton(this);, + public <E extends EventExecutor> Set<E> children() {, + return (Set<E>) selfCollection;, + }, +, + @Override, +++ b/common/src/main/java/io/netty/util/concurrent/EventExecutor.java, +import java.util.Set;, +, + * Returns an unmodifiable singleton set which contains itself., + */, + @Override, + <E extends EventExecutor> Set<E> children();, +, + /**, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, +import java.util.Collection;, +import java.util.Set;, + private final Collection<AbstractEventExecutor> selfCollection
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java, +++ /dev/null, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoderBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +++
[+++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, + public EventLoopGroup group() {, +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, + public EventLoopGroup group() {, +++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, +public class Bootstrap extends AbstractBootstrap<Bootstrap, Channel> {, +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, + public EventLoopGroup group() {, +++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, +public class Bootstrap extends AbstractBootstrap<Bootstrap, Channel> {, +++ b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java, +public class ServerBootstrap extends AbstractBootstrap<ServerBootstrap, ServerChannel> {]
[+++ b/codec/src/main/java/io/netty/handler/codec/StreamToMessageDecoder.java, + if (!ctx.eventLoop().inEventLoop()) {, +++ b/codec/src/main/java/io/netty/handler/codec/StreamToMessageDecoder.java, + if (!ctx.eventLoop().inEventLoop()) {, +++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxyFrontendHandler.java, + b.eventLoop(ctx.eventLoop()), +++ b/codec/src/main/java/io/netty/handler/codec/StreamToMessageDecoder.java, + if (!ctx.eventLoop().inEventLoop()) {, +++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxyFrontendHandler.java, + b.eventLoop(ctx.eventLoop()), +++ b/example/src/main/java/io/netty/example/uptime/UptimeClient.java, +import io.netty.handler.timeout.IdleStateHandler;, + // A single handler will be reused across multiple connection attempts to keep when the last, + // successful connection attempt was., + private final UptimeClientHandler handler = new UptimeClientHandler(this);, +, + ch.pipeline().addLast(new IdleStateHandler(READ_TIMEOUT, 0, 0), handler);, +++ b/codec/src/main/java/io/netty/handler/codec/StreamToMessageDecoder.java, + if (!ctx.eventLoop().inEventLoop()) {, +++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxyFrontendHandler.java, + b.eventLoop(ctx.eventLoop()), +++ b/example/src/main/java/io/netty/example/uptime/UptimeClient.java, +import io.netty.handler.timeout.IdleStateHandler;, + // A single handler will be reused across multiple connection attempts to keep when the last,
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +import io.netty.util.ReferenceCountUtil;, + }, promise, null);, + }, promise, null);, + }, promise, null);, + }, promise, null);, + }, promise, null);, + safeExecute(executor, task, channel.voidPromise(), null);, + safeExecute(executor, WriteTask.newInstance(next, msg, size, flush, promise), promise, msg);, + private static void safeExecute(EventExecutor executor, Runnable runnable, ChannelPromise promise, Object msg) {, + try {, + } finally {, + if (msg != null) {, + ReferenceCountUtil.release(msg);, + }, + }]
[+++ b/src/main/java/org/jboss/netty/channel/ChannelFutureAggregator.java, +/*, + * Copyright 2009 Red Hat, Inc., + *, + * Red Hat licenses this file to you under the Apache License, version 2.0, + * (the "License"); you may not use this file except in compliance with the, + * License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or
[+++ b/pom.xml, + <dependency>, + <groupId>org.easymock</groupId>, + <artifactId>easymock</artifactId>, + <version>2.4</version>, + <scope>test</scope>, + </dependency>]
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + private static final boolean USE_UNSAFE_DIRECTBUF = PlatformDependent.unsafeHasCopyMethods();, + if (USE_UNSAFE_DIRECTBUF) {, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + private static final boolean USE_UNSAFE_DIRECTBUF = PlatformDependent.unsafeHasCopyMethods();, + if (USE_UNSAFE_DIRECTBUF) {, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + private static final boolean USE_UNSAFE_DIRECTBUF = PlatformDependent.unsafeHasCopyMethods();, + if (USE_UNSAFE_DIRECTBUF) {, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + /**, + * {@code true} if and only if the platform supports unaligned access., + *, + * @see <a href="http://en.wikipedia.org/wiki/Segmentation_fault#Bus_error">Wikipedia on segfault</a>, + */, + if (UNALIGNED) {, + } else {, + return (short)(getByte(address) << 8 | getByte(address + 1) & 0xff);, + }, + if (UNALIGNED) {,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import io.netty.channel.ChannelHandlerAppender;, +public final class HttpClientCodec extends ChannelHandlerAppender {, + add(new Decoder(maxInitialLineLength, maxHeaderSize, maxChunkSize, validateHeaders));, + add(new Encoder());, + private Decoder decoder() {, + return handlerAt(0);, + }, +, + public void setSingleDecode(boolean singleDecode) {, + decoder().setSingleDecode(singleDecode);, + }, +, + public boolean isSingleDecode() {, + return decoder().isSingleDecode();, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import io.netty.channel.ChannelHandlerAppender;, +public final class HttpClientCodec extends ChannelHandlerAppender {, + add(new Decoder(maxInitialLineLength, maxHeaderSize, maxChunkSize, validateHeaders));, + add(new Encoder());, + private Decoder decoder() {, + return handlerAt(0);, + }, +, + public void setSingleDecode(boolean singleDecode) {, + decoder().setSingleDecode(singleDecode);, + }, +, + public boolean isSingleDecode()
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + * Gets the maximum length for any frame's payload., + *, + * @return The maximum length for a frame's payload]
[+++ b/pom.xml, + ${project.groupId}.*;version=${project.version}, +, + -link http://code.google.com/apis/protocolbuffers/docs/reference/java/, + -link http://www.osgi.org/javadoc/r4v41/, + -link http://google-guice.googlecode.com/svn/trunk/javadoc/, + -link http://static.springframework.org/spring/docs/2.5.x/api/, + -link http://www.slf4j.org/apidocs/, + -link http://commons.apache.org/logging/commons-logging-1.1.1/apidocs/, + -link http://logging.apache.org/log4j/1.2/apidocs/, +, +]
[+++ b/all/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +import io.netty.util.Attribute;, +import io.netty.util.AttributeKey;, +import static io.netty.channel.DefaultChannelPipeline.*;, +, +final class DefaultChannelHandlerContext implements ChannelHandlerContext {, + public <T> Attribute<T> attr(AttributeKey<T> key) {, + return channel.attr(key);, + }, +, + @Override, + @SuppressWarnings("deprecation"), + @SuppressWarnings("deprecation"), + @SuppressWarnings("deprecation"), + abstract static class AbstractWriteTask<T extends AbstractWriteTask<T>> implements Runnable {, + private final Recycler.Handle<T> handle;, + private AbstractWriteTask(Recycler.Handle<T> handle) {, + protected static void init(AbstractWriteTask<?> task, DefaultChannelHandlerContext ctx,, + protected abstract void recycle(Recycler.Handle<T> handle);, + static final class WriteTask, + extends AbstractWriteTask<WriteTask> implements SingleThreadEventLoop.NonWakeupRunnable {, + protected WriteTask newObject(Handle<WriteTask> handle) {, + private WriteTask(Recycler.Handle<WriteTask> handle) {, + protected void recycle(Recycler.Handle<WriteTask> handle) {,
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java, + try {, + } catch (IOException e) {, + // Continue on write error as a DatagramChannel can write to multiple remote peers, + //, + // See https://github.com/netty/netty/issues/2665, + in.remove(e);, + }, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java, + try {, + } catch (IOException e) {, + // Continue on write error as a DatagramChannel can write to multiple remote peers, + //, + // See https://github.com/netty/netty/issues/2665, + in.remove(e);, + }, +++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioMessageChannel.java, + try {, + } catch (IOException e) {, + if (continueOnWriteError()) {, + in.remove(e);, + } else {, + throw e;, + }, +
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, +import java.net.UnknownHostException;, + * This defines how many words (represented as ints) are needed to represent an IPv6 address, + */, + private static final int IPV6_WORD_COUNT = 8;, +, + /**, + * The maximum number of characters for an IPV6 string with no scope, + */, + private static final int IPV6_MAX_CHAR_COUNT = 39;, +, + /**, + * Number of bytes needed to represent and IPV6 value, + */, + private static final int IPV6_BYTE_COUNT = 16;, +, + /**, + * Maximum amount of value adding characters in between IPV6 separators, + */,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, + if (buffer == null || !buffer.isReadable()) {, + if (buffer.readableBytes() == 1) {]
[+++ /dev/null, +++ /dev/null, +++ b/all/pom.xml, + <id>clean-first</id>, + <includeGroupIds>${project.groupId}</includeGroupIds>, + <outputDirectory>${project.build.directory}/src</outputDirectory>, + <groupId>org.codehaus.mojo</groupId>, + <artifactId>build-helper-maven-plugin</artifactId>, + <version>1.7</version>, + <id>add-source</id>, + <phase>generate-sources</phase>, + <goal>add-source</goal>, + <sources>, + <source>target/src</source>, + </sources>, +, + <profiles>, + <profile>, + <id>full</id>, + <build>, + <plugins>, + <plugin>, + <artifactId>maven-jxr-plugin</artifactId>, + <version>2.2</version>, + <executions>, + <execution>, + <id>generate-xref</id>, + <phase>package</phase>, + <goals>, + <goal>jxr</goal>, + </goals>, + </execution>, + </executions>, + <configuration>, + <inputEncoding>UTF-8</inputEncoding>, + <outputEncoding>UTF-8</outputEncoding>, + <linkJavadoc>true</linkJavadoc>, + <destDir>${project.build.directory}/xref</destDir>, + <javadocDir>${project.build.directory}/api</javadocDir>, + <docTitle>Netty Source Xref (${project.version})</docTitle>, + <windowTitle>Netty Source Xref (${project.version})</windowTitle>, + </configuration>, + </plugin>, + <plugin>, + <artifactId>maven-javadoc-plugin</artifactId>, + <version>2.8.1</version>, + <executions>,
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslContextBuilder.java, + * Trusted manager for verifying the remote endpoint's certificate. {@code null} uses the system default., + * client contexts, which disables mutual authentication. Using a {@link KeyManagerFactory}, + * is only supported for {@link SslProvider#JDK} or {@link SslProvider#OPENSSL} / {@link SslProvider#OPENSSL_REFCNT}, + * if the used openssl version is 1.0.1+. You can check if your openssl version supports using a, + * {@link KeyManagerFactory} by calling {@link OpenSsl#supportsKeyManagerFactory()}. If this is not the case, + * you must use {@link #keyManager(File, File)} or {@link #keyManager(File, File, String)}., + * applied to the ciphers before use. If
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, +import java.net.URI;, +import java.nio.ByteBuffer;, +import java.util.Arrays;, +import java.util.Map;, +, +, + int wsPort = wsURL.getPort();, + String originValue = "http://" + wsURL.getHost();, + if (wsPort != 80 && wsPort != 443) {, + // if the port is not standard (80/443) its needed to add the port to the header., + // See http://tools.ietf.org/html/rfc6454#section-6.2, + originValue = originValue + ":" + wsPort;, + }, +, + private static String insertRandomCharacters(String key) {, + private static String insertSpaces(String key, int spaces) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, +import java.net.URI;, +import java.nio.ByteBuffer;, +import java.util.Arrays;, +import java.util.Map;, +, +, + int wsPort =
[+++ b/pom.xml, + <version>3.1.0.GA</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.1.0.GA</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.1.0.GA</developerConnection>, + <echo message="${project.version}, r${buildNumber}" file="${project.build.directory}/version.txt" />]
[+++ b/buffer/src/test/java/io/netty/buffer/UnpooledTest.java, + wrapped.release();, +++ b/buffer/src/test/java/io/netty/buffer/UnpooledTest.java, + wrapped.release();, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + handlerRemoved0(ctx);, + protected void handlerRemoved0(ChannelHandlerContext ctx) throws Exception { }, +++ b/buffer/src/test/java/io/netty/buffer/UnpooledTest.java, + wrapped.release();, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + handlerRemoved0(ctx);, + protected void handlerRemoved0(ChannelHandlerContext ctx) throws Exception { }, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, + if (buf != null) {, + if (buf.isReadable()) {, + } else {, + buf.release();, + }, +++ b/buffer/src/test/java/io/netty/buffer/UnpooledTest.java, + wrapped.release();, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + handlerRemoved0(ctx);, + protected void handlerRemoved0(ChannelHandlerContext ctx) throws Exception { }, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, + if (buf != null) {, + if (buf.isReadable()) {, + } else {, + buf.release();, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + protected
[+++ b/all/pom.xml, + <version>4.1.0.CR2</version>, +++ b/all/pom.xml, + <version>4.1.0.CR2</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR2</version>, +++ b/all/pom.xml, + <version>4.1.0.CR2</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR2</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR2</version>, +++ b/all/pom.xml, + <version>4.1.0.CR2</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR2</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR2</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR2</version>, +++ b/all/pom.xml, + <version>4.1.0.CR2</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR2</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR2</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR2</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR2</version>, +++ b/all/pom.xml, + <version>4.1.0.CR2</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR2</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR2</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR2</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR2</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.CR2</version>, +++ b/all/pom.xml, + <version>4.1.0.CR2</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR2</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR2</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, +import io.netty.util.ReferenceCountUtil;, + throw new UnsupportedOperationException("unsupported message type: " + StringUtil.simpleClassName(0));, + ReferenceCountUtil.release(o);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, +import io.netty.util.ReferenceCountUtil;, + throw new UnsupportedOperationException("unsupported message type: " + StringUtil.simpleClassName(0));, + ReferenceCountUtil.release(o);, +++ b/transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java, +import io.netty.util.ReferenceCountUtil;, + throw new UnsupportedOperationException("unsupported message type: " + StringUtil.simpleClassName(o));, + ReferenceCountUtil.release(o);]
[+++ b/transport/src/main/java/io/netty/channel/Channel.java, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.ByteBufAllocator;, +import io.netty.util.concurrent.EventExecutor;, +import io.netty.util.concurrent.FutureListener;, +import java.net.ConnectException;, +public interface Channel extends AttributeMap, Comparable<Channel> {, + * Return the assigned {@link ChannelPipeline}, + */, + ChannelPipeline pipeline();, +, + /**, + * Return the assigned {@link ByteBufAllocator} which will be used to allocate {@link ByteBuf}s., + */, + ByteBufAllocator alloc();, +, + /**, + * Return a new {@link ChannelPromise}., + */, + ChannelPromise newPromise();, +, + /**, + * Return an new {@link ChannelProgressivePromise}, + */, + ChannelProgressivePromise newProgressivePromise();, +, + /**, + * Create a new {@link ChannelFuture} which is marked as succeeded
[+++ b/all/pom.xml, +++ b/all/pom.xml, +++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E> {, +, + public ObjectArray(E[] array, int offset, int length) {, + super(array, offset, length);, + }, +, + @Override, + public E[] array() {, + return (E[]) super.array();, + }, +}, +++ b/all/pom.xml, +++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E> {, +, + public ObjectArray(E[] array, int offset, int length) {, + super(array, offset, length);, + }, +, + @Override, + public E[] array() {, + return (E[]) super.array();, + }, +}, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + throw new IndexOutOfBoundsException();, +
[+++ b/transport/src/main/java/io/netty/channel/SimpleChannelInboundHandler.java, + * Be aware that depending of the constructor parameters it will release all handled messages by pass them to, + * {@link ReferenceCountUtil#release(Object)}. In this case you may need to use, + * {@link ReferenceCountUtil#retain(Object)} if you pass the object to the next handler in the {@link ChannelPipeline}.]
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + if (out.drainToNextInbound(ctx)) {, + if (out.drainToNextInbound(ctx)) {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + if (out.drainToNextInbound(ctx)) {, + if (out.drainToNextInbound(ctx)) {, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, + out.drainToNextInbound(ctx);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + if (out.drainToNextInbound(ctx)) {, + if (out.drainToNextInbound(ctx)) {, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, + out.drainToNextInbound(ctx);, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, + out.drainToNextOutbound(ctx);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + if (out.drainToNextInbound(ctx)) {, + if (out.drainToNextInbound(ctx)) {, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, + out.drainToNextInbound(ctx);, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, + out.drainToNextOutbound(ctx);, +++ b/codec/src/main/java/io/netty/handler/codec/OutputMessageBuf.java, +import io.netty.buffer.BufType;, +import io.netty.buffer.MessageBuf;, +import io.netty.channel.ChannelHandlerContext;, + private int nonByteBufs;, + if (added) {, + if (e instanceof ByteBuf) {, + } else {, + nonByteBufs++;, + }, + if (removed) {, + if (o instanceof ByteBuf)
[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, + public <V> ProgressivePromise<V> newProgressivePromise() {, + return new DefaultProgressivePromise<V>(this);, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, + public <V> ProgressivePromise<V> newProgressivePromise() {, + return new DefaultProgressivePromise<V>(this);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultProgressivePromise.java, + * It is preferable to use {@link EventExecutor#newProgressivePromise()} to create a new progressive promise, + public DefaultProgressivePromise(EventExecutor executor) {, + protected DefaultProgressivePromise() { /* only for subclasses */ }, + public ProgressivePromise<V> setProgress(long progress, long total) {, + "progress: " + progress + " (expected: 0 <= progress <= total (" + total + "))");, + notifyProgressiveListeners(progress, total);, + public boolean tryProgress(long progress, long total) {, + notifyProgressiveListeners(progress, total);, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java, +import java.util.LinkedList;, + private final Queue<Integer> ids = new LinkedList<Integer>();]
[+++ /dev/null, +++ /dev/null, +++ /dev/null]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, +import io.netty.util.internal.StringUtil;, + * Returns {@code true} if a header with the {@code name} and {@code value} exists, {@code false} otherwise., + * This also handles multiple values that are seperated with a {@code ,}., + * <p>, + * If {@code ignoreCase} is {@code true} then a case insensitive compare is done on the value., + * @param name the name of the header to find, + * @param value the value of the header to find, + * @param ignoreCase {@code true} then a case insensitive compare is run to compare values., + * otherwise
[+++ b/all/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/codec-http2/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.8.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/ReadOnlyHttp2Headers.java, + return contains(name, value, false);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/ReadOnlyHttp2Headers.java, + return contains(name, value, false);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/ReadOnlyHttp2HeadersTest.java, + assertFalse(headers.contains("Name1", "Value1"));, + assertTrue(headers.contains("name2", "Value2", true));, + assertFalse(headers.contains("name2", "Value2", false));]
[+++ /dev/null, +++ /dev/null, +++ b/src/javadoc/overview.html, +<div style="text-align: center;"><img src="http://netty.io/images/architecture.png"></div>, +++ /dev/null, +++ b/src/javadoc/overview.html, +<div style="text-align: center;"><img src="http://netty.io/images/architecture.png"></div>, +++ /dev/null]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + /**, + * Closed streams may stay in the priority tree if they have dependents that are in prioritizable states., + * When a stream is requested to be removed we can only actually remove that stream when there are no more, + * prioritizable children., + * (see [1] {@link Http2Stream#prioritizableForTree()} and [2] {@link DefaultStream#removeChild(DefaultStream)})., + * When a priority tree edge changes we also have to re-evaluate viable nodes, + * (see [3] {@link DefaultStream#takeChild(DefaultStream, boolean, List)})., + * @param stream The stream to remove., + */, + void removeStream(DefaultStream stream) {, + //
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + long maxAge = Long.MIN_VALUE;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + long maxAge = Long.MIN_VALUE;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + long maxAge = Long.MIN_VALUE;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java, + private HttpTransferEncoding te = HttpTransferEncoding.SINGLE;, + public HttpTransferEncoding getTransferEncoding() {, + return te;, + public void setTransferEncoding(HttpTransferEncoding te) {, + if (te == null) {, + throw new NullPointerException("te (transferEncoding)");, + }, + this.te = te;, + switch (te) {, + case SINGLE:, + HttpCodecUtil.removeTransferEncodingChunked(this);, + break;, + case STREAMED:, + HttpCodecUtil.removeTransferEncodingChunked(this);, + break;, + case CHUNKED:, + if (!HttpCodecUtil.isTransferEncodingChunked(this)) {, + addHeader(HttpHeaders.Names.TRANSFER_ENCODING, HttpHeaders.Values.CHUNKED);, + }, + removeHeader(HttpHeaders.Names.CONTENT_LENGTH);, + setContent(Unpooled.EMPTY_BUFFER);, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + cleanupSafely(ctx);, + cleanupSafely(ctx);, + decoder.finishAndReleaseAll();, + private void cleanupSafely(ChannelHandlerContext ctx) {, + try {, + cleanup();, + } catch (Throwable cause) {, + // If cleanup throws any error we need to propagate it through the pipeline, + // so we don't fail to propagate pipeline events., + ctx.fireExceptionCaught(cause);, + }, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + cleanupSafely(ctx);, + cleanupSafely(ctx);, + decoder.finishAndReleaseAll();, + private void cleanupSafely(ChannelHandlerContext ctx) {, + try {, + cleanup();, + } catch (Throwable cause) {, + // If cleanup throws any error we need to propagate it through the pipeline, + //
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, +import io.netty.buffer.ByteBuf;, +, + private final HeaderEntry head = new HeaderEntry();, + void validateHeaderName0(CharSequence headerName) {, + public HttpHeaders add(HttpHeaders headers) {, + if (headers instanceof DefaultHttpHeaders) {, + DefaultHttpHeaders defaultHttpHeaders = (DefaultHttpHeaders) headers;, + HeaderEntry e = defaultHttpHeaders.head.after;, + while (e != defaultHttpHeaders.head) {, + add(e.key, e.value);, + e = e.after;, + }, + return this;, + } else {, + return super.add(headers);, + }, + }, +, + @Override, + public HttpHeaders set(HttpHeaders headers) {, + if (headers instanceof DefaultHttpHeaders) {, + clear();, + DefaultHttpHeaders defaultHttpHeaders = (DefaultHttpHeaders) headers;, + HeaderEntry e = defaultHttpHeaders.head.after;, +
[+++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, + return memory;]
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + return super.write(message, remoteAddress);]
[+++ b/common/src/main/java/io/netty/util/Attribute.java, + * If you only want to return the old value and clear the {@link Attribute} while still keep it in the, + *, + * <p>, + * Be aware that even if you call this method another thread that has obtained a reference to this {@link Attribute}, + * via {@link AttributeMap#attr(AttributeKey)} will still operate on the same instance. That said if now another, + * thread or even the same thread later will call {@link AttributeMap#attr(AttributeKey)} again, a new, + * {@link Attribute} instance is created and so is not the same as the
[+++ b/pom.xml, +<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">, + <version>3.0.0.CR4</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.0.0.CR4</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.0.0.CR4</developerConnection>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, + values = splitMultipartHeaderValues(svalue);, +, + /**, + * Split one header value in Multipart, + * @return an array of String where values that were separated by ';' or ',', + */, + private static String[] splitMultipartHeaderValues(String svalue) {, + List<String> values = new ArrayList<String>(1);, + boolean inQuote = false;, + boolean escapeNext = false;, + int start = 0;, + for (int i = 0; i < svalue.length(); i++) {, + char c = svalue.charAt(i);, + if (inQuote) {, + if (escapeNext) {, + escapeNext = false;, + } else {, + if (c ==
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + // Only ever send a reset frame if the connection is still alive and if the stream may have existed, + // as otherwise we may send a RST on a stream in an invalid state and cause a connection error., + if (parent().isActive() && !streamClosedWithoutError &&, + connection().streamMayHaveExisted(stream().id())) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + // Only ever send a reset frame if the connection is still alive and if the stream may have existed, + // as otherwise we may send a RST on a stream in an invalid state and cause a connection error., + if
[+++ b/transport/src/main/java/io/netty/channel/DefaultFileRegion.java, + private long transferred;, + return transferred;, + return transferred;, + transferred += written;]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket07FrameDecoder.java, + * @param expectMaskedFrames, + public WebSocket07FrameDecoder(boolean expectMaskedFrames, boolean allowExtensions, int maxFramePayloadLength) {, + this(expectMaskedFrames, allowExtensions, maxFramePayloadLength, false);, + }, +, + /**, + * Constructor, + *, + * @param expectMaskedFrames, + * Web socket servers must set this to true processed incoming masked payload. Client implementations, + * must set this to false., + * @param allowExtensions, + * Flag to allow reserved extension bits to be used or not, + * @param maxFramePayloadLength, + * Maximum length of a frame's payload. Setting this to an appropriate value for you application, + * helps check
[+++ b/codec/src/main/java/io/netty/handler/codec/base64/Base64.java, +import io.netty.buffer.ByteBufUtil;, +import io.netty.util.ByteProcessor;, +import io.netty.util.internal.PlatformDependent;, +, +import java.nio.ByteOrder;, + int len43 = (len << 2) / 3;, + byte[] alphabet = alphabet(dialect);, + encode3to4(src, d + off, 3, dest, e, alphabet);, + encode3to4(src, d + off, len - d, dest, e, alphabet);, + ByteBuf src, int srcOffset, int numSigBytes, ByteBuf dest, int destOffset, byte[] alphabet) {, + if (src.order() == ByteOrder.BIG_ENDIAN) {, + final int inBuff;, + case 1:, + inBuff = toInt(src.getByte(srcOffset));, + inBuff = toIntBE(src.getShort(srcOffset));, + break;, + default:, + inBuff = numSigBytes <= 0 ? 0 : toIntBE(src.getMedium(srcOffset));, + break;, + }, +
[+++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java, + ctx.nextOutboundMessageBuffer().add(response);, + ctx.flush().addListener(ChannelFutureListener.CLOSE);, + ctx.nextOutboundMessageBuffer().add(response);, + }, +, + @Override, + protected void endMessageReceived(ChannelHandlerContext ctx) throws Exception {, + ctx.flush();]
[+++ b/pom.xml, + The Netty project is an effort to provide an asynchronous event-driven, + network application framework and tools for rapid development of, + maintainable high performance and high scalability protocol servers and, + clients. In other words, Netty is a NIO client server framework which, + enables quick and easy development of network applications such as protocol, + servers and clients. It greatly simplifies and streamlines network, + programming such as TCP/IP socket server.]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + public void goAwayReceived(final int lastKnownStream, long errorCode, ByteBuf debugData) throws Http2Exception {, + if (localEndpoint.lastStreamKnownByPeer() >= 0 && localEndpoint.lastStreamKnownByPeer() < lastKnownStream) {, + throw connectionError(PROTOCOL_ERROR, "lastStreamId MUST NOT increase. Current value: %d new value: %d",, + localEndpoint.lastStreamKnownByPeer(), lastKnownStream);, + }, +, + closeStreamsGreaterThanLastKnownStreamId(lastKnownStream, localEndpoint);, + public boolean goAwaySent(final int lastKnownStream, long errorCode, ByteBuf debugData) throws Http2Exception {, + if (remoteEndpoint.lastStreamKnownByPeer() >= 0) {, + // Protect against re-entrancy. Could happen if writing the frame fails, and error handling, + // treating this is a connection handler and doing a graceful shutdown..., + if (lastKnownStream == remoteEndpoint.lastStreamKnownByPeer())
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java, + DnsServerAddresses nameServerAddresses) {, + this(new ReflectiveChannelFactory<DatagramChannel>(channelType), nameServerAddresses);, + DnsServerAddresses nameServerAddresses) {, + return newResolver((EventLoop) executor, channelFactory, nameServerAddresses);, + * @deprecated Override {@link #newNameResolver(EventLoop, ChannelFactory, DnsServerAddresses)}., + DnsServerAddresses nameServerAddresses) throws Exception {, + newNameResolver(eventLoop, channelFactory, nameServerAddresses),, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java, + DnsServerAddresses nameServerAddresses) {, + this(new ReflectiveChannelFactory<DatagramChannel>(channelType), nameServerAddresses);, + DnsServerAddresses nameServerAddresses) {, + return newResolver((EventLoop) executor, channelFactory, nameServerAddresses);, + * @deprecated Override {@link #newNameResolver(EventLoop, ChannelFactory, DnsServerAddresses)}., + DnsServerAddresses nameServerAddresses) throws Exception {, + newNameResolver(eventLoop, channelFactory, nameServerAddresses),, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelOption;, + final Future<Channel> channelFuture;, + final DnsCache resolveCache,, + b.option(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION, true);, + final DnsResponseHandler responseHandler = new
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + removeComp(cIndex);, + // Release the slice if present since it may have a different, + // refcount to the unwrapped buf if it is a PooledSlicedByteBuf, + ByteBuf buffer = slice;, + if (buffer != null) {, + buffer.release();, + } else {, + buf.release();, + }, + // null out in either case since it could be racy, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + removeComp(cIndex);, + // Release the slice if present since it may have a different, + // refcount to the unwrapped buf if it is a PooledSlicedByteBuf, + ByteBuf buffer = slice;, + if (buffer
[+++ b/pom.xml, + <ignore>java.net.StandardProtocolFamily</ignore>, +++ b/pom.xml, + <ignore>java.net.StandardProtocolFamily</ignore>, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +/*, + * Copyright 2011 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + *
[+++ b/testsuite-osgi/testsuite-osgi-deps/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>]
[+++ b/handler/src/test/java/io/netty/handler/ssl/SniClientTest.java, +import javax.net.ssl.SSLException;, + @Test(timeout = 30000, expected = SSLException.class), + @Test(timeout = 30000, expected = SSLException.class), + @Test(timeout = 30000, expected = SSLException.class), + @Test(timeout = 30000, expected = SSLException.class), +++ b/handler/src/test/java/io/netty/handler/ssl/SniClientTest.java, +import javax.net.ssl.SSLException;, + @Test(timeout = 30000, expected = SSLException.class), + @Test(timeout = 30000, expected = SSLException.class), + @Test(timeout = 30000, expected = SSLException.class), + @Test(timeout = 30000, expected = SSLException.class), +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, + if (writeInProgress && peer != null) {, + finishPeerRead(peer);, + }, + // Always call peer.eventLoop().execute() even if peer.eventLoop().inEventLoop() is true., + // This ensures that if both channels are on the
[+++ b/all/pom.xml, + <excludes>io/netty/internal/tcnative/**,io/netty/example/**,META-INF/native/libnetty_tcnative*,META-INF/native/include/**,META-INF/native/**/*.a</excludes>]
[+++ b/codec/src/main/java/io/netty/handler/codec/base64/Base64Encoder.java, +import io.netty.channel.ChannelHandlerUtil;, +import io.netty.channel.ChannelOutboundMessageHandlerAdapter;, +public class Base64Encoder extends ChannelOutboundMessageHandlerAdapter<ByteBuf> {, + public void flush(ChannelHandlerContext ctx,, + ByteBuf buf = Base64.encode(msg, msg.readerIndex(), msg.readableBytes(), breakLines, dialect);, + ChannelHandlerUtil.addToNextOutboundBuffer(ctx, buf);, +++ b/codec/src/main/java/io/netty/handler/codec/base64/Base64Encoder.java, +import io.netty.channel.ChannelHandlerUtil;, +import io.netty.channel.ChannelOutboundMessageHandlerAdapter;, +public class Base64Encoder extends ChannelOutboundMessageHandlerAdapter<ByteBuf> {, + public void flush(ChannelHandlerContext ctx,, + ByteBuf buf = Base64.encode(msg, msg.readerIndex(), msg.readableBytes(), breakLines, dialect);, + ChannelHandlerUtil.addToNextOutboundBuffer(ctx, buf);, +++ b/codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayEncoder.java, + switch (ctx.nextOutboundBufferType()) {, +++ b/codec/src/main/java/io/netty/handler/codec/base64/Base64Encoder.java, +import io.netty.channel.ChannelHandlerUtil;, +import io.netty.channel.ChannelOutboundMessageHandlerAdapter;, +public class Base64Encoder extends ChannelOutboundMessageHandlerAdapter<ByteBuf> {, + public void flush(ChannelHandlerContext ctx,, + ByteBuf buf = Base64.encode(msg, msg.readerIndex(), msg.readableBytes(), breakLines, dialect);, + ChannelHandlerUtil.addToNextOutboundBuffer(ctx, buf);, +++ b/codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayEncoder.java, + switch (ctx.nextOutboundBufferType()) {,
[+++ b/pom.xml, +++ b/pom.xml, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java, + if (boundary[1].charAt(0) == '"') {, + String bound = boundary[1].trim();, + int index = bound.length() - 1;, + if (bound.charAt(index) == '"') {, + boundary[1] = bound.substring(1, index);, + }, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java, + if (boundary[1].charAt(0) == '"') {, + String bound = boundary[1].trim();, + int index = bound.length() - 1;, + if (bound.charAt(index) == '"') {, + boundary[1] = bound.substring(1, index);, + }, + }, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java, + }, +, + // See https://github.com/netty/netty/issues/2542, + @Test, + public void testQuotedBoundary() throws Exception {, + final String boundary = "dLV9Wyq26L_-JQxk6ferf-RT153LhOO";, +, + final DefaultFullHttpRequest req
[+++ b/pom.xml, + <version>3.2.0.ALPHA3-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/pom.xml, + <version>3.0.0.CR1</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.0.0.CR1</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.0.0.CR1</developerConnection>]
[+++ b/codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java, + /** Last scan position. */, + private int offset;, +, + offset = 0;, + private int findEndOfLine(final ByteBuf buffer) {, + int totalLength = buffer.readableBytes();, + int i = buffer.forEachByte(buffer.readerIndex() + offset, totalLength - offset, ByteProcessor.FIND_LF);, + if (i >= 0) {, + offset = 0;, + } else {, + offset = totalLength;, + }, +++ b/codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java, + /** Last scan position. */, + private int offset;, +, + offset = 0;, + private int findEndOfLine(final ByteBuf buffer) {, + int totalLength = buffer.readableBytes();, + int i = buffer.forEachByte(buffer.readerIndex() + offset, totalLength - offset,
[+++ b/transport/src/main/java/io/netty/channel/socket/DatagramChannel.java, + * A UDP/IP {@link Channel}.]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/UniformStreamByteDistributor.java, + if (state.windowNegative) {, + continue;, + }, + if (maxBytes == 0 && state.streamableBytes > 0) {, + // Stop at the first state that can't send. Add this state back to the head of the queue. Note, + // that empty frames at the head of the queue will always be written, assuming the stream window, + // is not negative., + boolean windowNegative;, + // In addition to only enqueuing state when they have frames we enforce the following restrictions:, + // 1. If the window has gone negative. We never want to queue
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + static final class CloseFuture extends DefaultChannelPromise {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + static final class CloseFuture extends DefaultChannelPromise {, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, + Entry e = buffer[flushed];, + flushed = flushed + 1 & buffer.length - 1;, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + static final class CloseFuture extends DefaultChannelPromise {, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, + Entry e = buffer[flushed];, + flushed = flushed + 1 & buffer.length - 1;, +++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java, + int size = futures.size();, + for (int i = 0; i < size; i++) {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + static final class CloseFuture extends DefaultChannelPromise {, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, + Entry e = buffer[flushed];,
[+++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java, +, + // stop reading, + if (!config.isAutoRead()) {, + break;, + }, +, + } finally {, + if (!config.isAutoRead()) {, + removeReadOp();, + }, +++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java, +, + // stop reading, + if (!config.isAutoRead()) {, + break;, + }, +, + } finally {, + if (!config.isAutoRead()) {, + removeReadOp();, + }, +++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioMessageChannel.java, +, + try {, + // stop reading and remove op, + if (!config.isAutoRead()) {, + break;, + }, +, + if (readBuf.size() >= maxMessagesPerRead) {, + } finally {, + if (!config().isAutoRead()) {, + removeReadOp();, + }, + }, +++
[+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java, + if (port <= 0 || port >= 65536) {, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java, + if (port <= 0 || port >= 65536) {, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponse.java, + if (port <= 0 && port >= 65536) {, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java, + if (port <= 0 || port >= 65536) {, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponse.java, + if (port <= 0 && port >= 65536) {, +++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseTest.java, +, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java, + if (port <= 0 || port >= 65536) {, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponse.java, + if (port <= 0 && port >= 65536) {, +++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksAuthResponseTest.java, +, +++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdRequestDecoderTest.java, + int[] ports = {1, 32769, 65535
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, +import io.netty.buffer.BufUtil;, +import java.util.zip.CRC32;, +, +, + private enum State {, + * @return The number of bytes appended to the output buffer, or -1 to indicate "try again later", + length = BufUtil.swapShort(in.readShort());, + length = BufUtil.swapMedium(in.readUnsignedMedium());, + length = BufUtil.swapInt(in.readInt());, + int offset = BufUtil.swapShort(in.readShort());, + int offset = BufUtil.swapInt(in.readInt());, +, + /**, + * Computes the CRC32 checksum of the supplied data and performs the "mask" operation, + * on the computed checksum, + *, + * @param data The input data to calculate the CRC32 checksum of, + */, + public static int
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java, +import io.netty.handler.codec.http.FullHttpMessage;, + boolean last = false;, + last = spdySynStreamFrame.isLast();, + last = spdySynStreamFrame.isLast();, + last = spdySynReplyFrame.isLast();, + if (msg instanceof HttpContent && !last) {, + spdySynStreamFrame.setLast(isLast(httpMessage));, + spdySynReplyFrame.setLast(isLast(httpResponse));, +, + /**, + * Checks if the given HTTP message should be considered as a last SPDY frame., + *, + * @param httpMessage check this HTTP message, + * @return whether the given HTTP message should generate a <em>last</em> SPDY frame., + */, + private static boolean isLast(HttpMessage httpMessage) {, + if (httpMessage instanceof FullHttpMessage) {, + FullHttpMessage fullMessage = (FullHttpMessage) httpMessage;, + if
[+++ b/codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java]
[+++ b/all/pom.xml, + <version>4.1.17.Final</version>, +++ b/all/pom.xml, + <version>4.1.17.Final</version>, +++ b/bom/pom.xml, + <version>4.1.17.Final</version>, + <tag>netty-4.1.17.Final</tag>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, +++ b/all/pom.xml, + <version>4.1.17.Final</version>, +++ b/bom/pom.xml, + <version>4.1.17.Final</version>, + <tag>netty-4.1.17.Final</tag>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, + <version>4.1.17.Final</version>, +
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioChannel.java, +/*, + * Copyright 2011 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +import java.security.SecureRandom;, +import java.util.concurrent.BlockingQueue;, +import java.util.concurrent.LinkedBlockingQueue;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicLong;, +, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(ThreadLocalRandom.class);, +, + private static final AtomicLong seedUniquifier = new AtomicLong();, +, + private static volatile long initialSeedUniquifier;, +, + public static void setInitialSeedUniquifier(long initialSeedUniquifier) {, + ThreadLocalRandom.initialSeedUniquifier = initialSeedUniquifier;, + }, +, + public static synchronized long getInitialSeedUniquifier() {, + // Use the value set via the setter., + long initialSeedUniquifier = ThreadLocalRandom.initialSeedUniquifier;, + if (initialSeedUniquifier == 0) {, + // Use the system property value., + ThreadLocalRandom.initialSeedUniquifier = initialSeedUniquifier =, + SystemPropertyUtil.getLong("io.netty.initialSeedUniquifier",
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoopGroup.java, + Epoll.ensureAvailability();, + Epoll.ensureAvailability();, + Epoll.ensureAvailability();, + Epoll.ensureAvailability();]
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/common/src/main/java/io/netty/util/AsciiString.java, + final int len = offset + length;, +++ b/common/src/main/java/io/netty/util/AsciiString.java, + final int len = offset + length;, +++ b/common/src/test/java/io/netty/util/AsciiStringCharacterTest.java, +, + @Test, + public void testIndexOf() {, + AsciiString foo = AsciiString.of("This is a test");, + int i1 = foo.indexOf(' ', 0);, + assertEquals(4, i1);, + int i2 = foo.indexOf(' ', i1 + 1);, + assertEquals(7, i2);, + int i3 = foo.indexOf(' ', i2 + 1);, + assertEquals(9, i3);, + assertTrue(i3 + 1 < foo.length());, + int i4 = foo.indexOf(' ', i3 + 1);, + assertEquals(i4, -1);, + }]
[+++ b/common/src/main/java/io/netty/util/DefaultAttributeMap.java, + @SuppressWarnings("unchecked"), +++ b/common/src/main/java/io/netty/util/DefaultAttributeMap.java, + @SuppressWarnings("unchecked"), +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, + @SuppressWarnings("unchecked"), + B b = (B) this;, + return b;, +++ b/common/src/main/java/io/netty/util/DefaultAttributeMap.java, + @SuppressWarnings("unchecked"), +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, + @SuppressWarnings("unchecked"), + B b = (B) this;, + return b;, +++ b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java, + @SuppressWarnings("unchecked"), + AttributeKey<Object> key = (AttributeKey<Object>) e.getKey();, + channel.attr(key).set(e.getValue());, +++ b/common/src/main/java/io/netty/util/DefaultAttributeMap.java, + @SuppressWarnings("unchecked"), +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, + @SuppressWarnings("unchecked"), + B b = (B) this;, + return b;, +++ b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java, + @SuppressWarnings("unchecked"), + AttributeKey<Object> key = (AttributeKey<Object>) e.getKey();, + channel.attr(key).set(e.getValue());, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + @SuppressWarnings("unchecked"), + public <T> MessageBuf<T> outboundMessageBuffer() {, + return (MessageBuf<T>) pipeline.outboundMessageBuffer();, +++ b/common/src/main/java/io/netty/util/DefaultAttributeMap.java, + @SuppressWarnings("unchecked"), +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderValues.java, + * {@code "application/json"}, + */, + public static final AsciiString APPLICATION_JSON = new AsciiString("application/json");, + /**, + * {@code "gzip,deflate"}, + */, + public static final AsciiString GZIP_DEFLATE = new AsciiString("gzip,deflate");, + /**, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderValues.java, + * {@code "application/json"}, + */, + public static final AsciiString APPLICATION_JSON = new AsciiString("application/json");, + /**, + * {@code "gzip,deflate"}, + */, + public static final AsciiString GZIP_DEFLATE = new AsciiString("gzip,deflate");, + /**, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, + * {@code "application/json"}, + */, + public static final String APPLICATION_JSON = "application/json";, + /**, + * {@code "gzip,deflate"}, + */, + public static
[+++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyUnsafeDirectByteBuf.java, + ReadOnlyUnsafeDirectByteBuf(ByteBufAllocator allocator, ByteBuffer byteBuffer) {, + super(allocator, byteBuffer);, + // Use buffer as the super class will slice the passed in ByteBuffer which means the memoryAddress, + // may be different if the position != 0., +++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyUnsafeDirectByteBuf.java, + ReadOnlyUnsafeDirectByteBuf(ByteBufAllocator allocator, ByteBuffer byteBuffer) {, + super(allocator, byteBuffer);, + // Use buffer as the super class will slice the passed in ByteBuffer which means the memoryAddress, + // may be different if the position != 0., +++ b/buffer/src/test/java/io/netty/buffer/ReadOnlyDirectByteBufferBufTest.java, +import io.netty.util.internal.PlatformDependent;, +import java.io.File;, +import java.io.FileInputStream;, +import java.io.FileOutputStream;, +import java.nio.channels.FileChannel;, +, + @Test, + public void testWrapMemoryMapped() throws Exception
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + int hashCode = EmptyByteBuf.EMPTY_BYTE_BUF_HASH_CODE;, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + int hashCode = EmptyByteBuf.EMPTY_BYTE_BUF_HASH_CODE;, +++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, + static final int EMPTY_BYTE_BUF_HASH_CODE = 1;, + return EMPTY_BYTE_BUF_HASH_CODE;, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + int hashCode = EmptyByteBuf.EMPTY_BYTE_BUF_HASH_CODE;, +++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, + static final int EMPTY_BYTE_BUF_HASH_CODE = 1;, + return EMPTY_BYTE_BUF_HASH_CODE;, +++ b/buffer/src/test/java/io/netty/buffer/EmptyByteBufTest.java, +, + @Test, + public void consistentEqualsAndHashCodeWithAbstractBytebuf() {, + ByteBuf empty = new EmptyByteBuf(UnpooledByteBufAllocator.DEFAULT);, + ByteBuf emptyAbstract = new UnpooledHeapByteBuf(UnpooledByteBufAllocator.DEFAULT, 0, 0);, + assertEquals(emptyAbstract, empty);, + assertEquals(emptyAbstract.hashCode(), empty.hashCode());, + assertEquals(EmptyByteBuf.EMPTY_BYTE_BUF_HASH_CODE, empty.hashCode());, + assertTrue(emptyAbstract.release());, + assertFalse(empty.release());, + }]
[+++ b/buffer/src/test/java/io/netty/buffer/ByteBufUtilTest.java, + private static int random(Random r, int min, int max) {, + return r.nextInt((max - min) + 1) + min;, + }, +, + System.arraycopy(b1, iB1, b2, iB2, length);, + // Randomly pick an index in the range that will be compared and make the value at that index differ between, + // the 2 arrays., + int diffIndex = random(rand, iB1, iB1 + length - 1);, + ++b1[diffIndex];]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + int i = readerIndex;, + byte b = getByte(i);, + readerIndex = i + 1;, + return b;, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + int i = readerIndex;, + byte b = getByte(i);, + readerIndex = i + 1;, + return b;, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + int i = readerIndex;, + byte b = getByte(i);, + readerIndex = i + 1;, + return b;, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, +import io.netty.util.internal.PlatformDependent;, +, + } else if (PlatformDependent.hasUnsafe()) {, + return new UnpooledUnsafeDirectByteBuf(ALLOC, buffer, buffer.remaining());, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + int i = readerIndex;, + byte b = getByte(i);, + readerIndex =
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + /** Invocation initiated by {@link DefaultChannelPipeline#teardownAll()}}. */, + void teardown() {, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + /** Invocation initiated by {@link DefaultChannelPipeline#teardownAll()}}. */, + void teardown() {, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, + // Remove all handlers sequentially if channel is closed and unregistered., + teardownAll();, + /**, + * Removes all handlers from the pipeline one by one from tail (exclusive) to head (inclusive) to trigger, + * handlerRemoved(). Note that the tail handler is excluded because it's neither an outbound handler nor it, + * does anything in handlerRemoved()., + */, + private void teardownAll() {, + tail.prev.teardown();, +
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +public abstract class AbstractByteBuf implements UnsafeByteBuf {, + private final int maxCapacity;, + private SwappedByteBuf swappedBuf;, +, + protected AbstractByteBuf(int maxCapacity) {, + if (endianness == order() || capacity() == 0) {, +, + SwappedByteBuf swappedBuf = this.swappedBuf;, + if (swappedBuf == null) {, + this.swappedBuf = swappedBuf = new SwappedByteBuf(this);, + }, +, + // Use an unpooled heap buffer because there's no way to mandate a user to free the returned buffer., + ByteBuf buf = Unpooled.buffer(length, maxCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +public abstract class AbstractByteBuf implements UnsafeByteBuf {, + private final int maxCapacity;, + private SwappedByteBuf
[+++ b/all/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketFileRegionTest.java, +import io.netty.channel.ChannelInboundHandlerAdapter;, +import org.hamcrest.CoreMatchers;, + @Test, + public void testFileRegionCountLargerThenFile() throws Throwable {, + run();, + }, +, + public void testFileRegionCountLargerThenFile(ServerBootstrap sb, Bootstrap cb) throws Throwable {, + File file = File.createTempFile("netty-", ".tmp");, + file.deleteOnExit();, +, + final FileOutputStream out = new FileOutputStream(file);, + out.write(data);, + out.close();, +, + sb.childHandler(new SimpleChannelInboundHandler<ByteBuf>() {, + @Override, + protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) {, + // Just drop the message., + }, + });, + cb.handler(new ChannelInboundHandlerAdapter());, +, + Channel sc = sb.bind().sync().channel();, + Channel cc = cb.connect(sc.localAddress()).sync().channel();, +, + // Request file region which is bigger then
[+++ b/transport/src/main/java/io/netty/channel/local/LocalServerChannel.java, + if (localAddress != null) {, + }, +++ b/transport/src/main/java/io/netty/channel/local/LocalServerChannel.java, + if (localAddress != null) {, + }, +++ b/transport/src/test/java/io/netty/bootstrap/BootstrapTest.java, + @Test, + public void testLateRegisterFailed() throws Exception {, + final TestEventLoopGroup group = new TestEventLoopGroup();, + try {, + ServerBootstrap bootstrap = new ServerBootstrap();, + bootstrap.group(group);, + bootstrap.channel(LocalServerChannel.class);, + bootstrap.childHandler(new DummyHandler());, + bootstrap.localAddress(new LocalAddress("1"));, + ChannelFuture future = bootstrap.bind();, + Assert.assertFalse(future.isDone());, + group.promise.setFailure(new IllegalStateException());, + final BlockingQueue<Boolean> queue = new LinkedBlockingQueue<Boolean>();, + future.addListener(new ChannelFutureListener() {, + @Override, + public void operationComplete(ChannelFuture future) throws Exception {, + queue.add(group.next().inEventLoop(Thread.currentThread()));, + }, + });, + Assert.assertFalse(queue.take());, + } finally
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java, + if (!in.readable()) {, + return;, + }, +, + try {, + int resultCode = z.inflate(JZlib.Z_SYNC_FLUSH);, + if (inHasArray) {, + in.skipBytes(z.next_in_index - oldNextInIndex);, + }, + }, + } finally {, +++ b/codec/src/main/java/io/netty/handler/codec/compression/ZlibDecoder.java, + if (!in.readable()) {, + return;, + }, +, + try {, + int resultCode = z.inflate(JZlib.Z_SYNC_FLUSH);, + if (inHasArray) {, + in.skipBytes(z.next_in_index - oldNextInIndex);, + }, + }, + } finally {, +++ b/example/src/main/java/io/netty/example/factorial/BigIntegerDecoder.java, +import io.netty.channel.ChannelInboundHandlerContext;, +import io.netty.handler.codec.StreamToMessageDecoder;, +, +import java.math.BigInteger;, +public class BigIntegerDecoder extends StreamToMessageDecoder<BigInteger> {, + public BigInteger decode(ChannelInboundHandlerContext<Byte> ctx, ChannelBuffer in) {, + if (in.readableBytes() < 5) {,
[+++ b/transport/src/main/java/io/netty/channel/socket/DatagramChannel.java, + boolean isConnected();, +, +++ b/transport/src/main/java/io/netty/channel/socket/DatagramChannel.java, + boolean isConnected();, +, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + public boolean isConnected() {, + return javaChannel().isConnected();, + }, +, + @Override, +++ b/transport/src/main/java/io/netty/channel/socket/DatagramChannel.java, + boolean isConnected();, +, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + public boolean isConnected() {, + return javaChannel().isConnected();, + }, +, + @Override, +++ b/transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java, + public boolean isConnected() {, + return socket.isConnected();, + }, +, + @Override]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + //please do not make one line from below code, + //as it breaks +XX:OptimizeStringConcat optimization, + String valueStr = String.valueOf(value);, + value = valueStr + ' ' + trimmedLine;, + //please do not make one line from below code, + //as it breaks +XX:OptimizeStringConcat optimization, + String currentLastPos = current.get(lastPos);, + current.set(lastPos, currentLastPos + lineTrimmed);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + //please do not make one line from below code, + //as it breaks +XX:OptimizeStringConcat optimization, + String valueStr = String.valueOf(value);, + value = valueStr + ' ' + trimmedLine;, + //please do not make one line from below
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +import io.netty.resolver.ResolvedAddressTypes;, + private static final DnsRecord[] EMPTY_ADDITIONALS = new DnsRecord[0];, + private static final DnsRecordType[] IPV4_ONLY_RESOLVED_RECORD_TYPES =, + new DnsRecordType[] {DnsRecordType.A};, + private static final InternetProtocolFamily[] IPV4_ONLY_RESOLVED_PROTOCOL_FAMILIES =, + new InternetProtocolFamily[] {InternetProtocolFamily.IPv4};, + private static final DnsRecordType[] IPV4_PREFERRED_RESOLVED_RECORD_TYPES =, + new DnsRecordType[] {DnsRecordType.A, DnsRecordType.AAAA};, + private static final InternetProtocolFamily[] IPV4_PREFERRED_RESOLVED_PROTOCOL_FAMILIES =, + new InternetProtocolFamily[] {InternetProtocolFamily.IPv4, InternetProtocolFamily.IPv6};, + private static final DnsRecordType[] IPV6_ONLY_RESOLVED_RECORD_TYPES =, + new DnsRecordType[] {DnsRecordType.AAAA};, + private static final InternetProtocolFamily[] IPV6_ONLY_RESOLVED_PROTOCOL_FAMILIES =, + new InternetProtocolFamily[] {InternetProtocolFamily.IPv6};, + private static final DnsRecordType[] IPV6_PREFERRED_RESOLVED_RECORD_TYPES =, + new DnsRecordType[] {DnsRecordType.AAAA, DnsRecordType.A};, + private static final InternetProtocolFamily[] IPV6_PREFERRED_RESOLVED_PROTOCOL_FAMILIES
[+++ b/.gitignore, +#Eclipse project files, +, +#IntelliJ IDEA project files and directories, +, +#Geany project file, +, +#KDevelop project file and directory, +, +#Build targets, +/target, +*/target, +, +#Report directories, +/reports, +*/reports, +, +#Mac-specific directory that no other operating system needs., +.DS_Store]
[+++ b/NOTICE.txt, +This product contains a modified portion of Nitsan Wakart's 'JCTools', Java Concurrency Tools for the JVM,, + which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.jctools.txt (ASL2 License), + * HOMEPAGE:, + * https://github.com/JCTools/JCTools, +, +++ b/NOTICE.txt, +This product contains a modified portion of Nitsan Wakart's 'JCTools', Java Concurrency Tools for the JVM,, + which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.jctools.txt (ASL2 License), + * HOMEPAGE:, + * https://github.com/JCTools/JCTools, +, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + void free(PoolChunk<T> chunk, long handle, int normCapacity, PoolThreadCache cache) {, + if (cache != null &&
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, +++ b/pom.xml, + <netty.build.version>25</netty.build.version>, + <groupId>com.puppycrawl.tools</groupId>, + <artifactId>checkstyle</artifactId>, + <version>8.18</version>, + </dependency>, + <dependency>, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, +++ b/pom.xml, + <netty.build.version>25</netty.build.version>, + <groupId>com.puppycrawl.tools</groupId>, + <artifactId>checkstyle</artifactId>, + <version>8.18</version>, + </dependency>, + <dependency>, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java, + private static native int epollCtlAdd0(int efd, int fd, int flags);, + private static native int epollCtlMod0(int efd, int fd, int flags);, + private static native int epollCtlDel0(int efd, int fd);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeaders.java, + public SpdyHeaders addTimeMillis(CharSequence name, long value) {, + super.addTimeMillis(name, value);, + return this;, + }, +, + @Override, + public SpdyHeaders setTimeMillis(CharSequence name, long value) {, + super.setTimeMillis(name, value);, + return this;, + }, +, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeaders.java, + public SpdyHeaders addTimeMillis(CharSequence name, long value) {, + super.addTimeMillis(name, value);, + return this;, + }, +, + @Override, + public SpdyHeaders setTimeMillis(CharSequence name, long value) {, + super.setTimeMillis(name, value);, + return this;, + }, +, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaders.java, + SpdyHeaders addTimeMillis(CharSequence name, long value);, +, + @Override, + SpdyHeaders setTimeMillis(CharSequence name, long value);, +, +
[+++ b/all/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/example/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/codec/pom.xml, +
[+++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, +import io.netty.bootstrap.Bootstrap;, +import io.netty.bootstrap.ServerBootstrap;, + private ServerBootstrap sb;, + private Bootstrap cb;, + protected abstract ServerBootstrap newServerBootstrap();, + protected abstract Bootstrap newClientBootstrap();, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, +import io.netty.bootstrap.Bootstrap;, +import io.netty.bootstrap.ServerBootstrap;, + private ServerBootstrap sb;, + private Bootstrap cb;, + protected abstract ServerBootstrap newServerBootstrap();, + protected abstract Bootstrap newClientBootstrap();, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, +import io.netty.bootstrap.Bootstrap;, +import io.netty.bootstrap.ServerBootstrap;, + protected Bootstrap newClientBootstrap() {, + return new Bootstrap(), + protected ServerBootstrap newServerBootstrap() {, + return new ServerBootstrap(), +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, +import io.netty.bootstrap.Bootstrap;, +import io.netty.bootstrap.ServerBootstrap;, + private ServerBootstrap sb;, + private Bootstrap cb;, + protected abstract ServerBootstrap newServerBootstrap();, + protected abstract Bootstrap newClientBootstrap();, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, +import
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + private final ChannelPipeline pipeline = new DefaultChannelPipeline(this);, + private final ChannelFuture succeededFuture = new SucceededChannelFuture(this);, +, +, + @Override, + public ChannelFuture newFuture() {, + return new DefaultChannelFuture(this, false);, + }, +, + @Override, + public ChannelFuture newSucceededFuture() {, + return succeededFuture;, + }, +, + @Override, + public ChannelFuture newFailedFuture(Throwable cause) {, + return new FailedChannelFuture(this, cause);, + }, +, +, + @Override, + public void removeClosureListener(ChannelFutureListener listener) {, + if (listener == null) {, + throw new NullPointerException("listener");, + }, + synchronized (closureListeners) {, + if (!notifiedClosureListeners) {, + closureListeners.remove(listener);, + }, + },
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslServerContext.java, +, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.ByteBufInputStream;, +, +import javax.crypto.Cipher;, +import javax.crypto.EncryptedPrivateKeyInfo;, +import javax.crypto.NoSuchPaddingException;, +import javax.crypto.SecretKey;, +import javax.crypto.SecretKeyFactory;, +import javax.crypto.spec.PBEKeySpec;, +import javax.net.ssl.KeyManagerFactory;, +import javax.net.ssl.SSLContext;, +import javax.net.ssl.SSLException;, +import javax.net.ssl.SSLSessionContext;, + * @param keyPassword the password of the {@code keyFile}., + * {@code null} if it's not password-protected., + * @param keyPassword the password of the {@code keyFile}., + * {@code null} if it's not password-protected., + * @param ciphers the cipher suites to enable, in the order of preference., + * {@code null} to use the default cipher suites., + * @param nextProtocols the application layer protocols to accept, in
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + if (headers.contains(HttpHeaderNames.CONTENT_LENGTH)) {, + }, + // Either it is already chunked or EOF terminated., + // See https://github.com/netty/netty/issues/5892, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + if (headers.contains(HttpHeaderNames.CONTENT_LENGTH)) {, + }, + // Either it is already chunked or EOF terminated., + // See https://github.com/netty/netty/issues/5892, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentDecoderTest.java, + byte[] receivedContent = readContent(req, contentLength, true);, + byte[] receivedContent = readContent(resp, contentLength, true);, +, + assertEquals(HELLO_WORLD, new String(receivedContent, CharsetUtil.US_ASCII));, +, + assertHasInboundMessages(channel, true);, + assertHasOutboundMessages(channel, false);, + assertFalse(channel.finish());, + }, +, + // See https://github.com/netty/netty/issues/5892, + @Test, + public void testFullHttpResponseEOF() {, + // test that ContentDecoder can be used after the
[+++ b/.gitignore]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + public void write(int allowedBytes) {, + if (data == null || (allowedBytes == 0 && size != 0)) {, + return;, + try {, + public void write(int allowedBytes) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + public void write(int allowedBytes) {, + if (data == null || (allowedBytes == 0 && size != 0)) {, + return;, + try {, + public void write(int allowedBytes) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + public void write(int allowedBytes) {, + if (data == null || (allowedBytes == 0 && size != 0)) {, +
[+++ b/all/pom.xml, + <id>uber-staging</id>, + <profile>, + <id>uber-snapshot</id>, +, + <dependencies>, + <!-- Depend on all our native jars -->, + <!-- As this is executed on either macOS or Linux we directly need to specify the classifier -->, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport-native-epoll</artifactId>, + <version>${project.version}</version>, + <classifier>linux-x86_64</classifier>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport-native-kqueue</artifactId>, + <version>${project.version}</version>, + <classifier>osx-x86_64</classifier>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + </dependencies>, + </profile>, +++ b/all/pom.xml, + <id>uber-staging</id>, + <profile>, + <id>uber-snapshot</id>, +, + <dependencies>, + <!-- Depend on all our native jars -->, + <!-- As this
[+++ b/NOTICE.txt, +Red Hat licenses this product to you under the Apache License, version 2.0 (the]
[+++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, + *, + * @param resolver the {@link NameResolver} for this {@code Bootstrap}; may be {@code null}, in which case a default, + * resolver will be used, + *, + * @see io.netty.resolver.DefaultAddressResolverGroup, + this.resolver = (AddressResolverGroup<SocketAddress>) (resolver == null ? DEFAULT_RESOLVER : resolver);]
[+++ b/pom.xml, + <organization>, + <name>The Netty Project</name>, + <url>http://netty.io/</url>, + </organization>, +]
[+++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, + this.size = MathUtil.safeFindNextPositivePowerOfTwo(size);, +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, + this.size = MathUtil.safeFindNextPositivePowerOfTwo(size);, +++ b/common/src/main/java/io/netty/util/Recycler.java, +import static io.netty.util.internal.MathUtil.safeFindNextPositivePowerOfTwo;, + LINK_CAPACITY = safeFindNextPositivePowerOfTwo(, + RATIO = safeFindNextPositivePowerOfTwo(SystemPropertyUtil.getInt("io.netty.recycler.ratio", 8));, + ratioMask = safeFindNextPositivePowerOfTwo(ratio) - 1;, +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, + this.size = MathUtil.safeFindNextPositivePowerOfTwo(size);, +++ b/common/src/main/java/io/netty/util/Recycler.java, +import static io.netty.util.internal.MathUtil.safeFindNextPositivePowerOfTwo;, + LINK_CAPACITY = safeFindNextPositivePowerOfTwo(, + RATIO = safeFindNextPositivePowerOfTwo(SystemPropertyUtil.getInt("io.netty.recycler.ratio", 8));, + ratioMask = safeFindNextPositivePowerOfTwo(ratio) - 1;, +++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java, + this.samplingInterval = MathUtil.safeFindNextPositivePowerOfTwo(samplingInterval);, +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, + this.size = MathUtil.safeFindNextPositivePowerOfTwo(size);, +++ b/common/src/main/java/io/netty/util/Recycler.java, +import static io.netty.util.internal.MathUtil.safeFindNextPositivePowerOfTwo;, + LINK_CAPACITY = safeFindNextPositivePowerOfTwo(, + RATIO = safeFindNextPositivePowerOfTwo(SystemPropertyUtil.getInt("io.netty.recycler.ratio", 8));, + ratioMask = safeFindNextPositivePowerOfTwo(ratio) - 1;, +++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java, + this.samplingInterval = MathUtil.safeFindNextPositivePowerOfTwo(samplingInterval);, +++ b/common/src/main/java/io/netty/util/internal/MathUtil.java, +
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return new UnpooledDuplicatedByteBuf(this);, + return new UnpooledSlicedByteBuf(this, index, length);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return new UnpooledDuplicatedByteBuf(this);, + return new UnpooledSlicedByteBuf(this, index, length);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java, +abstract class AbstractPooledDerivedByteBuf extends AbstractReferenceCountedByteBuf {, + private final Handle<AbstractPooledDerivedByteBuf> recyclerHandle;, + AbstractPooledDerivedByteBuf(Handle<? extends AbstractPooledDerivedByteBuf> recyclerHandle) {, + this.recyclerHandle = (Handle<AbstractPooledDerivedByteBuf>) recyclerHandle;, + final <U extends AbstractPooledDerivedByteBuf> U init(, + AbstractByteBuf unwrapped, ByteBuf wrapped, int readerIndex, int writerIndex, int maxCapacity) {, + wrapped.retain(); // Retain up front to ensure the wrapped buffer is accessible before doing more work., + this.buffer = unwrapped;, + setIndex0(readerIndex, writerIndex); // It is assumed the bounds checking is
[+++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, + ChannelGroupFuture writeAndFlush(Object message);, + ChannelGroupFuture writeAndFlush(Object message, ChannelMatcher matcher);, +++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, + ChannelGroupFuture writeAndFlush(Object message);, + ChannelGroupFuture writeAndFlush(Object message, ChannelMatcher matcher);, +++ b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java, + public ChannelGroupFuture writeAndFlush(Object message) {, + return writeAndFlush(message, ChannelMatchers.all());, + public ChannelGroupFuture writeAndFlush(Object message, ChannelMatcher matcher) {]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + protected Object encode(ChannelHandlerContext ctx, HttpObject msg), +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + protected Object encode(ChannelHandlerContext ctx, HttpObject msg), +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, + protected Object decode(ChannelHandlerContext ctx, ByteBuf in) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + protected Object encode(ChannelHandlerContext ctx, HttpObject msg), +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, + protected Object decode(ChannelHandlerContext ctx, ByteBuf in) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameEncoder.java, + protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, ByteBuf out) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + protected Object encode(ChannelHandlerContext ctx, HttpObject msg), +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, + protected Object decode(ChannelHandlerContext ctx, ByteBuf in) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameEncoder.java, + protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, ByteBuf out) throws Exception
[+++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClient.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, + boot.group(connectGroup).localAddress(0), +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClient.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, + boot.group(connectGroup).localAddress(0), +++ b/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClient.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, + boot.group(connectGroup).localAddress(0), +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClient.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, + boot.group(connectGroup).localAddress(0), +++ b/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClient.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, + boot.group(connectGroup).localAddress(0), +++ b/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtChannelConfig.java, + SO_LINGER);, +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClient.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, + boot.group(connectGroup).localAddress(0), +++ b/example/src/main/java/io/netty/example/udt/echo/message/MsgEchoClient.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, + boot.group(connectGroup).localAddress(0), +++ b/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtChannelConfig.java, + SO_LINGER);, +++ b/transport-udt/src/main/java/io/netty/channel/udt/DefaultUdtServerChannelConfig.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + *
[+++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E> {, +, + public ObjectArray(E[] array, int offset, int length) {, + super(array, offset, length);, + }, +, + @Override, + public E[] array() {, + return (E[]) super.array();, + }, +}, +++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E> {, +, + public ObjectArray(E[] array, int offset, int length) {, + super(array, offset, length);, + }, +, + @Override, + public E[] array() {, + return (E[]) super.array();, + }, +}, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E>
[+++ b/all/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR9-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/CleartextHttp2ServerUpgradeHandler.java, + .remove(httpServerUpgradeHandler);, +, + ctx.pipeline().addAfter(ctx.name(), null, http2ServerHandler);, + ctx.pipeline().remove(this);, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/CleartextHttp2ServerUpgradeHandler.java, + .remove(httpServerUpgradeHandler);, +, + ctx.pipeline().addAfter(ctx.name(), null, http2ServerHandler);, + ctx.pipeline().remove(this);, +, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/CleartextHttp2ServerUpgradeHandlerTest.java, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelInitializer;, + private void setUpServerChannel() {, + setUpServerChannel();, +, + setUpServerChannel();, +, + setUpServerChannel();, +, + setUpServerChannel();, +, + @Test, + public void usedHttp2Codec() throws Exception {, + final Http2Codec http2Codec = new Http2CodecBuilder(true, new ChannelInitializer<Channel>() {, + @Override, + protected void initChannel(Channel ch) throws Exception {, + }, + }).build();, + UpgradeCodecFactory upgradeCodecFactory = new UpgradeCodecFactory() {, + @Override, + public UpgradeCodec newUpgradeCodec(CharSequence protocol) {, + return new Http2ServerUpgradeCodec(http2Codec);,
[+++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, +import java.util.Collections;, +import java.util.Set;, +import java.util.concurrent.ConcurrentHashMap;, + // We use a Set as a ChannelInitializer is usually shared between all Channels in a Bootstrap /, + private final Set<ChannelHandlerContext> initMap = Collections.newSetFromMap(, + new ConcurrentHashMap<ChannelHandlerContext, Boolean>());, + @Override, + public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {, + initMap.remove(ctx);, + }, +, + if (initMap.add(ctx)) { // Guard against re-entrance., + private void remove(final ChannelHandlerContext ctx) {, + // The removal may happen in an async fashion if the EventExecutor we use does something funky., + if (ctx.isRemoved()) {, + } else {, + // Ensure we always
[+++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, + private static final String[] HEXDUMP_ROWPREFIXES = new String[65536 >>> 4];, +, + // Generate the lookup table for the start-offset header in each row (up to 64KiB)., + for (i = 0; i < HEXDUMP_ROWPREFIXES.length; i ++) {, + StringBuilder buf = new StringBuilder(12);, + buf.append(NEWLINE);, + buf.append(Long.toHexString(i << 4 & 0xFFFFFFFFL | 0x100000000L));, + buf.setCharAt(buf.length() - 9, '|');, + buf.append('|');, + HEXDUMP_ROWPREFIXES[i] = buf.toString();, + }, + ctx.fireChannelRegistered();, + ctx.fireChannelActive();, + ctx.fireChannelInactive();, + logger.log(internalLevel, format(ctx, "EXCEPTION", cause), cause);, + ctx.fireExceptionCaught(cause);, + logger.log(internalLevel, format(ctx, "USER_EVENT", evt));, + ctx.fireUserEventTriggered(evt);, + logger.log(internalLevel, format(ctx, "BIND", localAddress));, + ctx.bind(localAddress, promise);,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + path = "";, + int pathEndPos = uri.indexOf('?');, + path = decodeComponent(pathEndPos < 0 ? uri : uri.substring(0, pathEndPos), this.charset);, + int pathEndPos = uri.indexOf('?');, + if (pathEndPos >= 0 && pathEndPos < uri.length() - 1) {, + decodeParams(uri.substring(pathEndPos + 1));, + } else {, + params = Collections.emptyMap();, + params = Collections.emptyMap();, + } else {, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + path = "";, + int pathEndPos = uri.indexOf('?');, + path = decodeComponent(pathEndPos < 0 ? uri : uri.substring(0, pathEndPos), this.charset);, + int pathEndPos = uri.indexOf('?');, + if (pathEndPos >= 0 && pathEndPos < uri.length()
[+++ b/pom.xml, + <version>[3.0.5,)</version>]
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + return addComponents0(increaseIndex, cIndex, col.toArray(new ByteBuf[0]), 0 , col.size());, + return buffers.toArray(new ByteBuffer[0]);, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + return addComponents0(increaseIndex, cIndex, col.toArray(new ByteBuf[0]), 0 , col.size());, + return buffers.toArray(new ByteBuffer[0]);, +++ b/buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java, + return array.toArray(new ByteBuffer[0]);, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + return addComponents0(increaseIndex, cIndex, col.toArray(new ByteBuf[0]), 0 , col.size());, + return buffers.toArray(new ByteBuffer[0]);, +++ b/buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java, + return array.toArray(new ByteBuffer[0]);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + ByteBuf buffer = wrappedBuffer(Integer.MAX_VALUE, buffers.toArray(new ByteBuf[0])).order(order);, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + return addComponents0(increaseIndex, cIndex, col.toArray(new ByteBuf[0]), 0 , col.size());, + return buffers.toArray(new ByteBuffer[0]);, +++ b/buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java, + return array.toArray(new ByteBuffer[0]);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + ByteBuf buffer = wrappedBuffer(Integer.MAX_VALUE, buffers.toArray(new ByteBuf[0])).order(order);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/ClientCookieEncoder.java, +
[+++ b/pom.xml, + <arguments>-P release,sonatype-oss-release,full,no-osgi</arguments>, +++ b/pom.xml, + <arguments>-P release,sonatype-oss-release,full,no-osgi</arguments>, +++ b/testsuite-osgi/pom.xml, + <!-- This test is guaranteed to fail during the release phase; skip'em all -->, + <profiles>, + <profile>, + <id>no-osgi</id>, + <properties>, + <skipITs>true</skipITs>, + <skipTests>true</skipTests>, + </properties>, + </profile>, + </profiles>, +, +++ b/pom.xml, + <arguments>-P release,sonatype-oss-release,full,no-osgi</arguments>, +++ b/testsuite-osgi/pom.xml, + <!-- This test is guaranteed to fail during the release phase; skip'em all -->, + <profiles>, + <profile>, + <id>no-osgi</id>, + <properties>, + <skipITs>true</skipITs>, + <skipTests>true</skipTests>, + </properties>, + </profile>, + </profiles>, +, +++ b/testsuite-osgi/testsuite-osgi-exam/pom.xml]
[+++ b/example/src/main/java/io/netty/example/memcache/binary/MemcacheClientHandler.java]
[+++ b/pom.xml, + <ignore>sun.nio.ch.DirectBuffer</ignore>]
[+++ b/all/pom.xml, + -link http://commons.apache.org/proper/commons-logging/javadocs/api-1.1.2/]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + private ByteBuf retain0(final int increment) {, + int oldRef = refCntUpdater.getAndAdd(this, increment);, + if (oldRef <= 0 || oldRef + increment < oldRef) {, + // Ensure we don't resurrect (which means the refCnt was 0) and also that we encountered an overflow., + refCntUpdater.getAndAdd(this, -increment);, + throw new IllegalReferenceCountException(oldRef, increment);, + int oldRef = refCntUpdater.getAndAdd(this, -decrement);, + if (oldRef == decrement) {, + } else if (oldRef < decrement || oldRef - decrement > oldRef) {, + // Ensure we don't over-release, and avoid underflow., + refCntUpdater.getAndAdd(this, decrement);, + throw new IllegalReferenceCountException(oldRef, decrement);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java,
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + final void channelReadComplete0(ChannelHandlerContext ctx) {, + // Discard bytes of the cumulation buffer if needed., + discardSomeReadBytes();, +, + // Ensure we never stale the HTTP/2 Channel. Flow-control is enforced by HTTP/2., + //, + // See https://tools.ietf.org/html/rfc7540#section-5.2.2, + if (!ctx.channel().config().isAutoRead()) {, + ctx.read();, + }, +, + ctx.fireChannelReadComplete();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + final void channelReadComplete0(ChannelHandlerContext ctx) {, + // Discard bytes of the cumulation buffer if needed., + discardSomeReadBytes();, +, + // Ensure we never stale the HTTP/2 Channel. Flow-control is enforced by HTTP/2., + //, + // See https://tools.ietf.org/html/rfc7540#section-5.2.2, + if (!ctx.channel().config().isAutoRead()) {, + ctx.read();,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ComposedLastHttpContent.java, + ComposedLastHttpContent(HttpHeaders trailingHeaders, DecoderResult result) {, + this(trailingHeaders);, + this.result = result;, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ComposedLastHttpContent.java, + ComposedLastHttpContent(HttpHeaders trailingHeaders, DecoderResult result) {, + this(trailingHeaders);, + this.result = result;, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, +import io.netty.handler.codec.DecoderResult;, + out.add(new ComposedLastHttpContent(headers, DecoderResult.SUCCESS));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ComposedLastHttpContent.java, + ComposedLastHttpContent(HttpHeaders trailingHeaders, DecoderResult result) {, + this(trailingHeaders);, + this.result = result;, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, +import io.netty.handler.codec.DecoderResult;, + out.add(new ComposedLastHttpContent(headers, DecoderResult.SUCCESS));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +import io.netty.handler.codec.DecoderResult;, + out.add(new ComposedLastHttpContent(headers, DecoderResult.SUCCESS));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ComposedLastHttpContent.java, + ComposedLastHttpContent(HttpHeaders trailingHeaders, DecoderResult result) {, + this(trailingHeaders);, + this.result = result;, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, +import io.netty.handler.codec.DecoderResult;, + out.add(new ComposedLastHttpContent(headers,
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + "minWritableBytes: %d (expected: 0+)", minWritableBytes));, + throw new IllegalArgumentException(String.format(, + "minWritableBytes: %d (exceeds maxCapacity(%d))", minWritableBytes, maxCapacity));, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + "minWritableBytes: %d (expected: 0+)", minWritableBytes));, + throw new IllegalArgumentException(String.format(, + "minWritableBytes: %d (exceeds maxCapacity(%d))", minWritableBytes, maxCapacity));, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * Otherwise:, + * <ul>, + * <li>a non-dynamic buffer will throw an {@link IndexOutOfBoundsException}.</li>, + * <li>a dynamic buffer will expand its capacity so that the number of the, + * {@link #writableBytes() writable bytes} becomes equal to or greater, + * than the specified value. The expansion involves the reallocation of, + * the internal buffer
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + if (ctx.channel().isActive() && readClientPrefaceString(in) && verifyFirstFrameIsSettings(in)) {, + if (logger.isWarnEnabled()) {, + logger.warn("{} Sending GOAWAY failed: lastStreamId '{}', errorCode '{}', " +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + if (ctx.channel().isActive() && readClientPrefaceString(in) && verifyFirstFrameIsSettings(in)) {, + if (logger.isWarnEnabled()) {, + logger.warn("{} Sending GOAWAY failed: lastStreamId '{}', errorCode '{}', " +, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java, + @Test, + public void channelClosedDoesNotThrowPrefaceException() throws Exception {, + when(connection.isServer()).thenReturn(true);, + handler = newHandler();, + when(channel.isActive()).thenReturn(false);, + handler.channelInactive(ctx);, + verify(frameWriter, never()).writeGoAway(any(ChannelHandlerContext.class), anyInt(), anyLong(),, + any(ByteBuf.class), any(ChannelPromise.class));, + verify(frameWriter, never()).writeRstStream(any(ChannelHandlerContext.class), anyInt(), anyLong(),, + any(ChannelPromise.class));, + }, +]
[+++ b/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoop.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +import io.netty.util.internal.PlatformDependent;, +import java.util.ArrayDeque;, +import java.util.Queue;, + // Fields accessed by inner classes, + final IntObjectMap<Http2Stream> streamMap = new IntObjectHashMap<Http2Stream>();, + final ConnectionStream connectionStream = new ConnectionStream();, + final DefaultEndpoint<Http2LocalFlowController> localEndpoint;, + final DefaultEndpoint<Http2RemoteFlowController> remoteEndpoint;, + final List<Listener> listeners = new ArrayList<Listener>(4);, + final ActiveStreams activeStreams;, + activeStreams = new ActiveStreams(listeners, checkNotNull(removalPolicy, "removalPolicy"));, + public Http2Stream forEachActiveStream(StreamVisitor visitor) throws Http2Exception {, + return activeStreams.forEachActiveStream(visitor);, + public void goAwayReceived(final int lastKnownStream, long errorCode, ByteBuf debugData) {, + try {, + forEachActiveStream(new StreamVisitor() {, + @Override, + public boolean visit(Http2Stream stream) {, + return true;, + }, + });,
[+++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeNoCleanerDirectByteBuf.java, + if (newCapacity == oldCapacity) {, + return this;, +, + ByteBuffer newBuffer = reallocateDirect(buffer, newCapacity);, +, + if (newCapacity < oldCapacity) {, + if (readerIndex() < newCapacity) {, + if (writerIndex() > newCapacity) {, + writerIndex(newCapacity);, + }, + setByteBuffer(newBuffer, false);]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, +import io.netty.util.internal.StringUtil;, + private StringBuilder lineBuf;, + if (lineBuf != null) {, + }, +, + boolean anyChar = false;, + return toStringIfAnyChar(lineBuf, anyChar);, + anyChar = true;, + if (lineBuf == null) {, + lineBuf = new StringBuilder();, + }, + return lineBuf != null && lineBuf.length() > 0 ? lineBuf.toString() : StringUtil.EMPTY_STRING;, + }, +, + private static String toStringIfAnyChar(StringBuilder lineBuf, boolean anyChars) {, + if (anyChars) {, + return lineBuf != null && lineBuf.length() > 0 ? lineBuf.toString() : StringUtil.EMPTY_STRING;, + } else {, + return null;, + }, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, +import io.netty.util.internal.StringUtil;, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + HttpHeaderDateFormat.get().parse(value).getTime() -, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + HttpHeaderDateFormat.get().parse(value).getTime() -, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, + return HttpHeaderDateFormat.get().format((Date) value);, + return HttpHeaderDateFormat.get().format(((Calendar) value).getTime());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + HttpHeaderDateFormat.get().parse(value).getTime() -, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, + return HttpHeaderDateFormat.get().format((Date) value);, + return HttpHeaderDateFormat.get().format(((Calendar) value).getTime());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderDateFormat.java, + private static ThreadLocal<HttpHeaderDateFormat> dateFormatThreadLocal = new ThreadLocal<HttpHeaderDateFormat>() {, + @Override, + protected HttpHeaderDateFormat initialValue() {, + return new HttpHeaderDateFormat();, + }, + };, +, + static HttpHeaderDateFormat get() {, + return dateFormatThreadLocal.get();, + }, +, + private HttpHeaderDateFormat() {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + HttpHeaderDateFormat.get().parse(value).getTime() -, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, + return HttpHeaderDateFormat.get().format((Date) value);, + return HttpHeaderDateFormat.get().format(((Calendar) value).getTime());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderDateFormat.java, + private static ThreadLocal<HttpHeaderDateFormat> dateFormatThreadLocal
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + Set<String> libNames = new LinkedHashSet<String>(4);, + // in Java 8, statically compiled JNI code is namespaced, + libNames.add("netty_tcnative");, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + Set<String> libNames = new LinkedHashSet<String>(4);, + // in Java 8, statically compiled JNI code is namespaced, + libNames.add("netty_tcnative");, +++ b/transport-native-epoll/src/main/c/netty_epoll_linuxsocket.c, +, +#include "netty_unix_errors.h", +#include "netty_unix_filedescriptor.h", +#include "netty_unix_jni.h", +#include "netty_unix_socket.h", +#include "netty_unix_util.h", + return NETTY_JNI_VERSION;, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + Set<String> libNames = new LinkedHashSet<String>(4);, + // in Java 8, statically compiled JNI code is namespaced, + libNames.add("netty_tcnative");, +++ b/transport-native-epoll/src/main/c/netty_epoll_linuxsocket.c, +, +#include "netty_unix_errors.h", +#include "netty_unix_filedescriptor.h", +#include "netty_unix_jni.h", +#include "netty_unix_socket.h", +#include "netty_unix_util.h", + return NETTY_JNI_VERSION;, +++ b/transport-native-epoll/src/main/c/netty_epoll_native.c, +, +#include
[+++ b/all/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-memcache/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/common/src/main/java/io/netty/util/internal/LongAdderCounter.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + static final int numTinySubpagePools = 512 >>> 4;, +, + final int pageSize;, + final int pageShifts;, + final int chunkSize;, + final int subpageOverflowMask;, + final int numSmallSubpagePools;, + tinySubpagePools = newSubpagePoolArray(numTinySubpagePools);, + numSmallSubpagePools = pageShifts - 9;, + smallSubpagePools = newSubpagePoolArray(numSmallSubpagePools);, + abstract boolean isDirect();, +, + static int tinyIdx(int normCapacity) {, + return normCapacity >>> 4;, + }, +, + static int smallIdx(int normCapacity) {, + int tableIdx = 0;, + return tableIdx;, + }, +, + // capacity < pageSize, + boolean isTinyOrSmall(int normCapacity) {, + return (normCapacity & subpageOverflowMask) == 0;,
[+++ b/codec/src/test/java/io/netty/handler/codec/LineBasedFrameDecoderTest.java, +, + @Test, + public void testFragmentedDecode() throws Exception {, + EmbeddedChannel ch = new EmbeddedChannel(new LineBasedFrameDecoder(8192, false, false));, +, + assertFalse(ch.writeInbound(copiedBuffer("huu", CharsetUtil.US_ASCII)));, + assertNull(ch.readInbound());, +, + assertFalse(ch.writeInbound(copiedBuffer("haa\r", CharsetUtil.US_ASCII)));, + assertNull(ch.readInbound());, +, + assertTrue(ch.writeInbound(copiedBuffer("\nhuuhaa\r\n", CharsetUtil.US_ASCII)));, + ByteBuf buf = ch.readInbound();, + assertEquals("huuhaa\r\n", buf.toString(CharsetUtil.US_ASCII));, +, + ByteBuf buf2 = ch.readInbound();, + assertEquals("huuhaa\r\n", buf2.toString(CharsetUtil.US_ASCII));, + assertFalse(ch.finishAndReleaseAll());, +, + buf.release();, + buf2.release();, + }]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoopGroup.java, +import io.netty.channel.EventLoop;, + protected EventLoop newChild(Executor executor, Object... args) throws Exception {, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoopGroup.java, +import io.netty.channel.EventLoop;, + protected EventLoop newChild(Executor executor, Object... args) throws Exception {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + public final ChannelHandlerInvoker invoker() {, + return eventLoop().asInvoker();, + }, +, + @Override, + @SuppressWarnings("deprecation"), +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoopGroup.java, +import io.netty.channel.EventLoop;, + protected EventLoop newChild(Executor executor, Object... args) throws Exception {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + public final ChannelHandlerInvoker invoker() {, + return eventLoop().asInvoker();, + }, +, + @Override, + @SuppressWarnings("deprecation"), +++ b/transport/src/main/java/io/netty/channel/Channel.java, + * <li>{@link #invoker()}</li>, +, + /**, + * Returns the {@link ChannelHandlerInvoker} which is used by default unless
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, +import io.netty.channel.ChannelHandlerContext;, + private ChannelHandlerContext ctx;, + public void handlerAdded(ChannelHandlerContext ctx) throws Exception {, + this.ctx = ctx;, + }, +, + @Override, + new EmbeddedChannel(ctx.channel().id(), ctx.channel().metadata().hasDisconnect(),, + ctx.channel().config(), ZlibCodecFactory.newZlibEncoder(, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, +import io.netty.channel.ChannelHandlerContext;, + private ChannelHandlerContext ctx;, + public void handlerAdded(ChannelHandlerContext ctx) throws Exception {, + this.ctx = ctx;, + }, +, + @Override, + new EmbeddedChannel(ctx.channel().id(), ctx.channel().metadata().hasDisconnect(),, + ctx.channel().config(), ZlibCodecFactory.newZlibEncoder(, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + protected ChannelHandlerContext ctx;, + @Override, + public void handlerAdded(ChannelHandlerContext ctx) throws Exception {, + this.ctx = ctx;, + super.handlerAdded(ctx);, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, +import io.netty.channel.ChannelHandlerContext;, + private ChannelHandlerContext ctx;, + public
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java, + final String[] searchDomains = parent.searchDomains();, + if (searchDomains.length == 0 || parent.ndots() == 0 || StringUtil.endsWith(hostname, '.')) {, + final boolean startWithoutSearchDomain = hasNDots();, + final String initialHostname = startWithoutSearchDomain ? hostname : hostname + '.' + searchDomains[0];, + final int initialSearchDomainIdx = startWithoutSearchDomain ? 0 : 1;, + doSearchDomainQuery(initialHostname, new FutureListener<T>() {, + private int searchDomainIdx = initialSearchDomainIdx;, + } else if (searchDomainIdx < searchDomains.length) {, + doSearchDomainQuery(hostname + '.' + searchDomains[searchDomainIdx++], this);, + } else {, + if (!startWithoutSearchDomain) {, + internalResolve(promise);, + }, + private boolean hasNDots() {, + for (int idx =
[+++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, + if (isShutdown()) {, + boolean reject = false;, + try {, + if (removeTask(task)) {, + reject = true;, + }, + } catch (UnsupportedOperationException e) {, + // The task queue does not support removal so the best thing we can do is to just move on and, + // hope we will be able to pick-up the task before its completely terminated., + // In worst case we will log on termination., + }, + if (reject) {, + }, +++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, + if (isShutdown()) {, + boolean reject = false;, + try {,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, + encodeChunkedContent(ctx, msg, contentLength, out);, + } else {, + throw new Error();, + }, + }, + }, +, + private void encodeChunkedContent(ChannelHandlerContext ctx, Object msg, int contentLength, List<Object> out) {]
[+++ b/handler/src/test/java/io/netty/handler/ssl/JdkOpenSslEngineInteroptTest.java, + return super.mySetupMutualAuthServerIsValidClientException(cause) || cause instanceof SSLException;]
[+++ b/pom.xml, + <showDeprecation>true</showDeprecation>, + <showWarnings>true</showWarnings>]
[+++ b/transport/src/main/java/io/netty/channel/WriteBufferWaterMark.java, + * WriteBufferWaterMark is used to set low water mark and high water mark for the write buffer., + * {@linkplain #high high water mark}, {@link Channel#isWritable()}]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java, + if (trustCertChainFile != null) {, + trustManagerFactory = buildTrustManagerFactory(trustCertChainFile, trustManagerFactory);, + } else if (trustManagerFactory == null) {, + trustManagerFactory.init((KeyStore) null);, + if (trustCertChain != null) {, + trustManagerFactory = buildTrustManagerFactory(trustCertChain, trustManagerFactory);, + } else if (trustManagerFactory == null) {, + trustManagerFactory.init((KeyStore) null);]
[+++ b/pom.xml, + <!-- Our Javadoc has poor enough quality to fail the build thanks to JDK8 javadoc which got more strict. -->, + <profile>, + <id>jdk8</id>, + <activation>, + <jdk>[1.8,)</jdk>, + </activation>, + <properties>, + <maven.javadoc.failOnError>false</maven.javadoc.failOnError>, + </properties>, + </profile>]
[+++ b/pom.xml, + <version>2.2.0</version>, +++ b/pom.xml, + <version>2.2.0</version>, +++ b/src/main/java/org/jboss/netty/example/localtime/LocalTimeProtocol.java, + public enum Continent, + public static com.google.protobuf.Internal.EnumLiteMap<Continent>, + internalGetValueMap() {, + return internalValueMap;, + }, + private static com.google.protobuf.Internal.EnumLiteMap<Continent>, + internalValueMap =, + new com.google.protobuf.Internal.EnumLiteMap<Continent>() {, + public Continent findValueByNumber(int number) {, + return Continent.valueOf(number), + ; }, + };, +, + public enum DayOfWeek, + public static com.google.protobuf.Internal.EnumLiteMap<DayOfWeek>, + internalGetValueMap() {, + return internalValueMap;, + }, + private static com.google.protobuf.Internal.EnumLiteMap<DayOfWeek>, + internalValueMap =, + new com.google.protobuf.Internal.EnumLiteMap<DayOfWeek>() {, + public DayOfWeek findValueByNumber(int number) {, + return DayOfWeek.valueOf(number), + ; }, + };, +, + com.google.protobuf.ExtensionRegistryLite extensionRegistry), + com.google.protobuf.ExtensionRegistryLite
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, + protected HttpMessage decode(ChannelHandlerContext ctx, HttpObject msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, + protected HttpMessage decode(ChannelHandlerContext ctx, HttpObject msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + protected void encode(, + protected Object decode(, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, + protected HttpMessage decode(ChannelHandlerContext ctx, HttpObject msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + protected void encode(, + protected Object decode(, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + protected Object decode(ChannelHandlerContext ctx, Object msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, + protected HttpMessage decode(ChannelHandlerContext ctx, HttpObject msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + protected void encode(, + protected Object decode(, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + protected Object decode(ChannelHandlerContext ctx, Object msg)
[+++ b/.gitignore, +.idea/]
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java, + ciphers, cipherFilter, apn, ClientAuth.NONE, false);, + ciphers, cipherFilter, toNegotiator(apn, false), ClientAuth.NONE, false);, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java, + ciphers, cipherFilter, apn, ClientAuth.NONE, false);, + ciphers, cipherFilter, toNegotiator(apn, false), ClientAuth.NONE, false);, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, + JdkDefaultApplicationProtocolNegotiator.INSTANCE, clientAuth, false);, + this(sslContext, isClient, ciphers, cipherFilter, toNegotiator(apn, !isClient), clientAuth, false);, + JdkApplicationProtocolNegotiator apn, ClientAuth clientAuth, boolean startTls) {, + super(startTls);, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java, + ciphers, cipherFilter, apn, ClientAuth.NONE, false);, + ciphers, cipherFilter, toNegotiator(apn, false), ClientAuth.NONE, false);, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, + JdkDefaultApplicationProtocolNegotiator.INSTANCE, clientAuth, false);, + this(sslContext, isClient, ciphers, cipherFilter, toNegotiator(apn, !isClient), clientAuth, false);, + JdkApplicationProtocolNegotiator apn, ClientAuth clientAuth, boolean startTls) {, + super(startTls);, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslServerContext.java, + ciphers,
[+++ b/pom.xml, + <version>3.18.0-GA</version>]
[+++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffers.java, + * Create a {@link ChannelBuffer} that holds all the given values as int's, + * , + */, + public static ChannelBuffer wrapInt(int... values) {, + if (values == null || values.length == 0) {, + return EMPTY_BUFFER;, + }, + ChannelBuffer buffer = buffer(values.length * 4);, + for (int v: values) {, + buffer.writeInt(v);, + }, + return buffer;, + }, + , + /**, + * Create a {@link ChannelBuffer} that holds all the given values as short's, + * , + */, + public static ChannelBuffer wrapShort(int... values) {, + if (values ==
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseStatus.java, + * Returns the code of this {@link HttpResponseStatus}., + * Returns the reason phrase of this {@link HttpResponseStatus}., + /**, + * Equality of {@link HttpResponseStatus} only depends on {@link #code()}. The, + * reason phrase is not considered for equality., + */, + /**, + * Equality of {@link HttpResponseStatus} only depends on {@link #code()}. The, + * reason phrase is not considered for equality., + */]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, + , + // Check if the buffer is readable first as we use the readable byte count, + // to create the HttpChunk. This is needed as otherwise we may end up with, + // create a HttpChunk instance that contains an empty buffer and so is, + // handled like it is the last HttpChunk., + //, + // See https://github.com/netty/netty/issues/433, + if (readLimit == 0) {, + return null;, + }, +, +, + // Check if the buffer is readable first as we use the readable byte count, + // to create the
[+++ b/pom.xml, + <jboss.marshalling.version>1.3.18.GA</jboss.marshalling.version>, + <version>3.2</version>, + <version>3.2</version>, + <version>1.3</version>, + <version>2.9.1</version>]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java, + crc.update(inAry, offset, len);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ComposedLastHttpContent.java, + public LastHttpContent duplicate() {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ComposedLastHttpContent.java, + public LastHttpContent duplicate() {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpMessage.java, +, + @Override, + FullHttpMessage duplicate();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ComposedLastHttpContent.java, + public LastHttpContent duplicate() {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpMessage.java, +, + @Override, + FullHttpMessage duplicate();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpRequest.java, + FullHttpRequest duplicate();, +, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ComposedLastHttpContent.java, + public LastHttpContent duplicate() {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpMessage.java, +, + @Override, + FullHttpMessage duplicate();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpRequest.java, + FullHttpRequest duplicate();, +, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpResponse.java, + FullHttpResponse duplicate();, +, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ComposedLastHttpContent.java, + public LastHttpContent duplicate() {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpMessage.java, +, + @Override, + FullHttpMessage duplicate();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpRequest.java, + FullHttpRequest duplicate();, +, + @Override,
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketGatheringWriteTest.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/all/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.1.Alpha8-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMethod.java, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +import io.netty.util.AsciiString;, + * The request method of HTTP or its derived protocols, such as, + * The OPTIONS method represents a request for information about the communication options, + * available on the request/response chain identified by the Request-URI. This method allows, + public static final HttpMethod OPTIONS = new HttpMethod("OPTIONS");, + * The GET method means retrieve whatever information (in the form of an entity) is identified, + public static final HttpMethod GET = new HttpMethod("GET");, + * The HEAD method is identical to GET except that the server MUST NOT return
[+++ b/pom.xml, + <attach>true</attach>]
[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, + public Timer timer() {, + public TimerTask task() {, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, + public Timer timer() {, + public TimerTask task() {, +++ b/common/src/main/java/io/netty/util/Timeout.java, + Timer timer();, + TimerTask task();]
[+++ b/pom.xml, + x86_64/AARCH64 JDK must be used., + <regex>^(x86_64|aarch_64)$</regex>]
[+++ b/transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java, + // Ensure we null out the address which may have been set before., + tmpPacket.setAddress(null);, + // Ensure we null out the address which may have been set before., + tmpPacket.setAddress(null);]
[+++ b/common/src/test/java/io/netty/util/DefaultAttributeMapTest.java, +import static org.junit.Assert.*;, +, + map = new DefaultAttributeMap();, + assertNotNull(map);, + Attribute<String> one = map.attr(key);, + assertSame(one, map.attr(key));, + Attribute<Integer> one = map.attr(key);, + assertSame(one, map.attr(key));, + assertEquals(one.get(), Integer.valueOf(3653));]
[+++ b/pom.xml, + <version>3.1.4.GA-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, + currentBuffer.retain();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, + currentBuffer.retain();, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoderTest.java, +import io.netty.buffer.SlicedByteBuf;, +import io.netty.handler.codec.http.HttpContent;, +import java.util.Arrays;, + @Test, + public void testHttpPostRequestEncoderSlicedBuffer() throws Exception {, + DefaultFullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1,, + HttpMethod.POST, "http://localhost");, +, + HttpPostRequestEncoder encoder = new HttpPostRequestEncoder(request, true);, + // add Form attribute, + encoder.addBodyAttribute("getform", "POST");, + encoder.addBodyAttribute("info", "first value");, + encoder.addBodyAttribute("secondinfo", "secondvalue a&");, + encoder.addBodyAttribute("thirdinfo", "short text");, + int length = 100000;, + char[] array = new char[length];, + Arrays.fill(array, 'a');, + String longText = new String(array);, + encoder.addBodyAttribute("fourthinfo", longText.substring(0, 7470));, + File file1 = new File(getClass().getResource("/file-01.txt").toURI());, + encoder.addBodyFileUpload("myfile", file1, "application/x-zip-compressed", false);, + encoder.finalizeRequest();,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ServerCookieEncoder.java, +import static io.netty.handler.codec.http.CookieEncoderUtil.*;, +, +import java.util.Date;, + Date expires = new Date(cookie.maxAge() * 1000 + System.currentTimeMillis());, + addUnquoted(buf, CookieHeaderNames.EXPIRES, HttpHeaderDateFormat.get().format(expires));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ServerCookieEncoder.java, +import static io.netty.handler.codec.http.CookieEncoderUtil.*;, +, +import java.util.Date;, + Date expires = new Date(cookie.maxAge() * 1000 + System.currentTimeMillis());, + addUnquoted(buf, CookieHeaderNames.EXPIRES, HttpHeaderDateFormat.get().format(expires));, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/ServerCookieEncoderTest.java, +import java.text.ParseException;, +import java.util.Date;, +import java.util.regex.Matcher;, +import java.util.regex.Pattern;, +, + public void testEncodingSingleCookieV0() throws ParseException {, +, + int maxAge = 50;, +, + String result =, + "myCookie=myValue; Max-Age=50; Expires=(.+?); Path=/apathsomewhere; Domain=.adomainsomewhere; Secure";, + cookie.setMaxAge(maxAge);, +, + Matcher matcher = Pattern.compile(result).matcher(encodedCookie);, + assertTrue(matcher.find());, + Date expiresDate = HttpHeaderDateFormat.get().parse(matcher.group(1));, + long diff =
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ReadOnlyHttpHeaders.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/example/src/main/java/io/netty/example/spdy/client/SpdyClient.java, +import io.netty.handler.codec.spdy.SpdyOrHttpChooser.SelectedProtocol;, + sslCtx = SslContext.newClientContext(, + null, InsecureTrustManagerFactory.INSTANCE, null,, + SslContext.newApplicationProtocolSelector(, + SelectedProtocol.SPDY_3_1.protocolName(),, + SelectedProtocol.HTTP_1_1.protocolName()),, + 0, 0);, +, +++ b/example/src/main/java/io/netty/example/spdy/client/SpdyClient.java, +import io.netty.handler.codec.spdy.SpdyOrHttpChooser.SelectedProtocol;, + sslCtx = SslContext.newClientContext(, + null, InsecureTrustManagerFactory.INSTANCE, null,, + SslContext.newApplicationProtocolSelector(, + SelectedProtocol.SPDY_3_1.protocolName(),, + SelectedProtocol.HTTP_1_1.protocolName()),, + 0, 0);, +, +++ b/example/src/main/java/io/netty/example/spdy/client/SpdyClientInitializer.java, + pipeline.addLast("ssl", sslCtx.newHandler(ch.alloc()));, +++ b/example/src/main/java/io/netty/example/spdy/client/SpdyClient.java, +import io.netty.handler.codec.spdy.SpdyOrHttpChooser.SelectedProtocol;, + sslCtx = SslContext.newClientContext(, + null, InsecureTrustManagerFactory.INSTANCE, null,, + SslContext.newApplicationProtocolSelector(, + SelectedProtocol.SPDY_3_1.protocolName(),, + SelectedProtocol.HTTP_1_1.protocolName()),, + 0, 0);, +, +++ b/example/src/main/java/io/netty/example/spdy/client/SpdyClientInitializer.java, + pipeline.addLast("ssl", sslCtx.newHandler(ch.alloc()));, +++ /dev/null, +++ b/example/src/main/java/io/netty/example/spdy/client/SpdyClient.java, +import io.netty.handler.codec.spdy.SpdyOrHttpChooser.SelectedProtocol;, + sslCtx = SslContext.newClientContext(, + null, InsecureTrustManagerFactory.INSTANCE, null,, + SslContext.newApplicationProtocolSelector(, + SelectedProtocol.SPDY_3_1.protocolName(),, + SelectedProtocol.HTTP_1_1.protocolName()),, + 0, 0);,
[+++ b/microbench/pom.xml, + <profile>, + <id>benchmark-jar</id>, + <build>, + <plugins>, + <plugin>, + <groupId>org.apache.maven.plugins</groupId>, + <artifactId>maven-shade-plugin</artifactId>, + <version>2.2</version>, + <executions>, + <execution>, + <phase>package</phase>, + <goals>, + <goal>shade</goal>, + </goals>, + <configuration>, + <finalName>microbenchmarks</finalName>, + <transformers>, + <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">, + <mainClass>org.openjdk.jmh.Main</mainClass>, + </transformer>, + </transformers>, + <filters>, + <filter>, + <!--, + Shading signed JARs will fail without this., + http://stackoverflow.com/questions/999489/invalid-signature-file-when-attempting-to-run-a-jar, + -->, + <artifact>*:*</artifact>, + <excludes>, + <exclude>META-INF/*.SF</exclude>, + <exclude>META-INF/*.DSA</exclude>, + <exclude>META-INF/*.RSA</exclude>, + </excludes>, + </filter>, + </filters>, + </configuration>, + </execution>, + </executions>, + </plugin>, + </plugins>, + </build>, + </profile>]
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslContext.java, + * {@link SslContext} sslCtx = {@link SslContextBuilder#forClient() SslContextBuilder.forClient()}.build();, +++ b/handler/src/main/java/io/netty/handler/ssl/SslContext.java, + * {@link SslContext} sslCtx = {@link SslContextBuilder#forClient() SslContextBuilder.forClient()}.build();, +++ b/handler/src/main/java/io/netty/handler/ssl/SslContextBuilder.java, + * @see #keyManager(File, File), + * @see #keyManager(File, File, String), + /**, + * Creates a builder for new server-side {@link SslContext}., + *, + * @param keyManagerFactory non-{@code null} factory for server's private key, + * @see #keyManager(KeyManagerFactory), + */, + public static SslContextBuilder forServer(KeyManagerFactory keyManagerFactory) {, + return new SslContextBuilder(true).keyManager(keyManagerFactory);, + }, +]
[+++ b/pom.xml, + <stylesheetfile>${basedir}/src/javadoc/stylesheet.css</stylesheetfile>, +++ b/pom.xml, + <stylesheetfile>${basedir}/src/javadoc/stylesheet.css</stylesheetfile>, +++ b/src/javadoc/stylesheet.css, +/* Javadoc style sheet */
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_getSoError(JNIEnv* env, jclass clazz, jint fd) {, + int optval = 0;, + if (getOption(env, fd, SOL_SOCKET, SO_ERROR, &optval, sizeof(optval)) == -1) {, + return optval;, + }, + return 0;, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_getSoError(JNIEnv* env, jclass clazz, jint fd) {, + int optval = 0;, + if (getOption(env, fd, SOL_SOCKET, SO_ERROR, &optval, sizeof(optval)) == -1) {, + return optval;, + }, + return 0;, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +jint Java_io_netty_channel_epoll_Native_getSoError(JNIEnv* env, jclass clazz, jint fd);, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_getSoError(JNIEnv* env, jclass clazz, jint fd) {, + int
[+++ b/.gitignore, +.project, +.classpath, +.settings, +*.iml, +*.ipr, +*.iws, +.geany, +*/target, +*/target, +*/reports, +, +++ b/.gitignore, +.project, +.classpath, +.settings, +*.iml, +*.ipr, +*.iws, +.geany, +*/target, +*/target, +*/reports, +, +++ b/all/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<!--, + ~ Copyright 2011 The Netty Project, + ~, + ~ The Netty Project licenses this file to you under the Apache License,, + ~ version 2.0 (the "License"); you may not use this file except in compliance, + ~ with the License. You may obtain a copy of the License at:, + ~, + ~ http://www.apache.org/licenses/LICENSE-2.0, + ~, + ~ Unless required by applicable law or
[+++ b/common/src/main/java/io/netty/util/internal/CleanerJava9.java, +import java.security.AccessController;, +import java.security.PrivilegedAction;, + final ByteBuffer buffer = ByteBuffer.allocateDirect(1);, + Object maybeInvokeMethod = AccessController.doPrivileged(new PrivilegedAction<Object>() {, + @Override, + public Object run() {, + Method m = PlatformDependent0.UNSAFE.getClass().getDeclaredMethod(, + "invokeCleaner", ByteBuffer.class);, + return m;, + return e;, + return e;, + return e;, + }, + });, +, + // Try to minimize overhead when there is no SecurityManager present., + // See https://bugs.openjdk.java.net/browse/JDK-8191053., + if (System.getSecurityManager() == null) {, + } else {, + freeDirectBufferPrivileged(buffer);, + }, + }, +, + private static void freeDirectBufferPrivileged(final ByteBuffer buffer) {, + Exception error = AccessController.doPrivileged(new PrivilegedAction<Exception>() {,
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + // The user can fire `deregister` events multiple times but we only want to fire the pipeline, + // event if the channel was actually registered.]
[+++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, +import static org.junit.Assume.assumeTrue;, +, + public void testMutualAuthSameCerts() throws Exception {, + assumeTrue(OpenSsl.isAvailable());, + super.testMutualAuthSameCerts();, + }, +, + @Override, + public void testMutualAuthDiffCerts() throws Exception {, + assumeTrue(OpenSsl.isAvailable());, + super.testMutualAuthDiffCerts();, + }, +, + @Override, + public void testMutualAuthDiffCertsServerFailure() throws Exception {, + assumeTrue(OpenSsl.isAvailable());, + super.testMutualAuthDiffCertsServerFailure();, + }, +, + @Override, + public void testMutualAuthDiffCertsClientFailure() throws Exception {, + assumeTrue(OpenSsl.isAvailable());, + super.testMutualAuthDiffCertsClientFailure();, + }, +, + @Override]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import io.netty.util.Recycler;, +import io.netty.util.Recycler.Handle;, + private static final int THREAD_LOCAL_BUFFER_SIZE;, +, + String allocType = SystemPropertyUtil.get("io.netty.allocator.type", "unpooled").toLowerCase(Locale.US).trim();, +, + THREAD_LOCAL_BUFFER_SIZE = SystemPropertyUtil.getInt("io.netty.threadLocalDirectBufferSize", 64 * 1024);, + logger.debug("-Dio.netty.threadLocalDirectBufferSize: {}", THREAD_LOCAL_BUFFER_SIZE);, + /**, + * Returns a cached thread-local direct buffer, if available., + *, + * @return a cached thread-local direct buffer, if available. {@code null} otherwise., + */, + public static ByteBuf threadLocalDirectBuffer() {, + if (THREAD_LOCAL_BUFFER_SIZE <= 0) {, + return null;, + }, +, + if (PlatformDependent.hasUnsafe()) {, + return ThreadLocalUnsafeDirectByteBuf.newInstance();, + } else {, + return ThreadLocalDirectByteBuf.newInstance();, + }, + }, +, + static
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + }, + if (executor().inEventLoop()) {, + throw new IllegalStateException("nextInboundByteBuffer() called from outside the eventLoop");, + }, + if (executor().inEventLoop()) {, + throw new IllegalStateException("nextInboundMessageBuffer() called from outside the eventLoop");, + }, + if (executor().inEventLoop()) {, + throw new IllegalStateException("nextOutboundByteBuffer() called from outside the eventLoop");, + }, + if (executor().inEventLoop()) {, + throw new IllegalStateException("nextOutboundMessageBuffer() called from outside the eventLoop");, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + }, + if (executor().inEventLoop()) {, + throw new IllegalStateException("nextInboundByteBuffer() called from outside the eventLoop");, + }, + if (executor().inEventLoop()) {, + throw new IllegalStateException("nextInboundMessageBuffer() called from outside the eventLoop");, + }, + if (executor().inEventLoop())
[+++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientInitializer.java, +import io.netty.handler.ssl.SslHandler;, + p.addLast("ssl", new SslHandler(engine));, +++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClientInitializer.java, +import io.netty.handler.ssl.SslHandler;, + p.addLast("ssl", new SslHandler(engine));, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + wrapLater = true;]
[+++ b/buffer/src/test/java/io/netty/buffer/FixedCompositeByteBufTest.java, +import static io.netty.buffer.Unpooled.*;, +import static io.netty.util.ReferenceCountUtil.*;, +import static org.junit.Assert.*;, + private static ByteBuf newBuffer(ByteBuf... buffers) {, + return releaseLater(new FixedCompositeByteBuf(UnpooledByteBufAllocator.DEFAULT, buffers));, + ByteBuf buf = newBuffer(wrappedBuffer(new byte[8]));, + ByteBuf buf = newBuffer(wrappedBuffer(new byte[8]));, + ByteBuf buf = newBuffer(wrappedBuffer(new byte[8]));, + buf.setBytes(0, wrappedBuffer(new byte[4]));, + ByteBuf buf = newBuffer(wrappedBuffer(new byte[8]));, + ByteBuf buf = newBuffer(wrappedBuffer(new byte[8]));, + ByteBuf buf = newBuffer(wrappedBuffer(new byte[8]));, + public long read(ByteBuffer[] dsts, int offset, int length) {, + public long read(ByteBuffer[] dsts) {, + public int read(ByteBuffer dst) {, + public void close() {, + ByteBuf buf = newBuffer(wrappedBuffer(new byte[8]));, + ByteBuf buf
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + try {, + } finally {, + }, + int written = 0;, + try {, + } finally {, + outputStream.close();, + }, + IOException exception = null;, + FileInputStream inputStream = null;, + FileOutputStream outputStream = null;, + try {, + inputStream = new FileInputStream(file);, + outputStream = new FileOutputStream(dest);, + FileChannel in = inputStream.getChannel();, + FileChannel out = outputStream.getChannel();, + } catch (IOException e) {, + exception = e;, + } finally {, + if (inputStream != null) {, + try {, + inputStream.close();, + } catch (IOException e) {, + if (exception
[+++ b/example/src/main/java/io/netty/example/echo/EchoServerHandler.java, +import io.netty.channel.ChannelHandler.Sharable;, +@Sharable, +++ b/example/src/main/java/io/netty/example/echo/EchoServerHandler.java, +import io.netty.channel.ChannelHandler.Sharable;, +@Sharable, +++ b/pom.xml, + <version>9</version>]
[+++ b/pom.xml, + <excludes>, + <!-- Exclude sctp from build for now -->, + <!-- See: https://github.com/netty/netty/issues/120 -->, + <exclude>**/sctp/*.java</exclude>, + </excludes>]
[+++ b/transport-native-epoll/src/main/c/netty_epoll_linuxsocket.c, + { "setTcpMd5Sig", "(I[BI[B)V", (void *) netty_epoll_linuxsocket_setTcpMd5Sig }, +++ b/transport-native-epoll/src/main/c/netty_epoll_linuxsocket.c, + { "setTcpMd5Sig", "(I[BI[B)V", (void *) netty_epoll_linuxsocket_setTcpMd5Sig }, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java, + } catch (SocketException e) {, + } catch (SocketException e) {, +, +++ b/transport-native-epoll/src/main/c/netty_epoll_linuxsocket.c, + { "setTcpMd5Sig", "(I[BI[B)V", (void *) netty_epoll_linuxsocket_setTcpMd5Sig }, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java, + } catch (SocketException e) {, + } catch (SocketException e) {, +, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannelConfig.java, + return -1;, + throw new UnsupportedOperationException("Multicast not supported");, + throw new UnsupportedOperationException("Multicast not supported");, + throw new UnsupportedOperationException("Multicast not supported");, +++ b/transport-native-epoll/src/main/c/netty_epoll_linuxsocket.c, + { "setTcpMd5Sig", "(I[BI[B)V", (void *) netty_epoll_linuxsocket_setTcpMd5Sig }, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java, + } catch (SocketException
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + * Used to determine if the return value of {@link ByteBuf#ensureWritable(int, boolean)} means that there is, + * adequate space and a write operation will succeed., + * @param ensureWritableResult The return value from {@link ByteBuf#ensureWritable(int, boolean)}., + * @return {@code true} if {@code ensureWritableResult} means that there is adequate space and a write operation, + * will succeed., + */, + public static boolean ensureWritableSuccess(int ensureWritableResult) {, + return ensureWritableResult == 0 || ensureWritableResult == 2;, + }, +, + /**, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + * Used to determine if the return value of {@link ByteBuf#ensureWritable(int,
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());, + lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());, + lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + return lifecycleManager.resetStream(ctx, streamId, errorCode, promise);, + return lifecycleManager.goAway(ctx, lastStreamId, errorCode, debugData, promise);, + lifecycleManager.closeStreamLocal(stream, promise);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());, + lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + return lifecycleManager.resetStream(ctx, streamId, errorCode, promise);, + return lifecycleManager.goAway(ctx, lastStreamId, errorCode, debugData, promise);, + lifecycleManager.closeStreamLocal(stream, promise);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + ChannelFuture future = goAway(ctx, null);, + public void closeStreamLocal(Http2Stream stream, ChannelFuture future) {, + public void closeStreamRemote(Http2Stream stream, ChannelFuture future) {, + goAway(ctx, http2Ex).addListener(new ClosingChannelFutureListener(ctx, ctx.newPromise()));, + resetStream(ctx, http2Ex.streamId(), http2Ex.error().code(), ctx.newPromise());, + public ChannelFuture resetStream(final ChannelHandlerContext
[+++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, + public int pendingTasks() {, +++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, + public int pendingTasks() {, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, +import java.util.concurrent.Callable;, + private final Callable<Integer> pendingTasksCallable = new Callable<Integer>() {, + @Override, + public Integer call() throws Exception {, + return EpollEventLoop.super.pendingTasks();, + }, + };, + @Override, + public int pendingTasks() {, + // As we use a MpscQueue we need to ensure pendingTasks() is only executed from within the EventLoop as, + // otherwise we may see unexpected behavior (as size() is only allowed to be called by a single consumer)., + // See https://github.com/netty/netty/issues/5297, + if (inEventLoop()) {, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import io.netty.channel.CombinedChannelHandler;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import io.netty.channel.CombinedChannelHandler;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java, +import io.netty.channel.CombinedChannelHandler;, +, +import io.netty.channel.CombinedChannelHandler;, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import io.netty.channel.CombinedChannelHandler;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java, +import io.netty.channel.CombinedChannelHandler;, +, +import io.netty.channel.CombinedChannelHandler;, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, +import io.netty.channel.CombinedChannelHandler;, +, +import io.netty.channel.CombinedChannelHandler;, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import io.netty.channel.CombinedChannelHandler;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java, +import io.netty.channel.CombinedChannelHandler;, +, +import io.netty.channel.CombinedChannelHandler;, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, +import io.netty.channel.CombinedChannelHandler;, +, +import io.netty.channel.CombinedChannelHandler;, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpCodec.java, +import io.netty.channel.CombinedChannelHandler;, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import io.netty.channel.CombinedChannelHandler;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java, +import io.netty.channel.CombinedChannelHandler;, +, +import io.netty.channel.CombinedChannelHandler;, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, +import io.netty.channel.CombinedChannelHandler;, +, +import io.netty.channel.CombinedChannelHandler;, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpCodec.java, +import io.netty.channel.CombinedChannelHandler;, +, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, +import io.netty.channel.ChannelInboundMessageHandlerAdapter;, +public abstract class MessageToMessageDecoder<I, O> extends ChannelInboundMessageHandlerAdapter<I> {, +++
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + DefaultHttp2StreamChannel childChannel = new DefaultHttp2StreamChannel(stream, false);, + return new DefaultHttp2StreamChannel(newStream(), true);, + private final boolean outbound;, + DefaultHttp2StreamChannel(Http2FrameStream stream, boolean outbound) {, + this.outbound = outbound;, + if (!outbound) {, + }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + DefaultHttp2StreamChannel childChannel = new DefaultHttp2StreamChannel(stream, false);, + return new DefaultHttp2StreamChannel(newStream(), true);, + private final boolean outbound;, + DefaultHttp2StreamChannel(Http2FrameStream stream, boolean outbound) {, + this.outbound = outbound;, + if (!outbound) {, + }, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexCodecBuilderTest.java, +import org.junit.Assert;, + .handler(new Http2MultiplexCodecBuilder(false, new ChannelInitializer<Channel>() {, + @Override, + protected void initChannel(Channel ch) throws Exception {, + Assert.fail("Should not be called for outbound streams");, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java, + private final class StreamComparator implements Comparator<Integer>, Serializable {, +, + private static final long serialVersionUID = 1161471649740544848L;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java, + private final class StreamComparator implements Comparator<Integer>, Serializable {, +, + private static final long serialVersionUID = 1161471649740544848L;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java, + private Boolean encoderEnforceMaxConcurrentStreams;, + return encoderEnforceMaxConcurrentStreams != null ? encoderEnforceMaxConcurrentStreams : false;]
[+++ b/all/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta5</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, + assumeTrue(OpenSsl.isAlpnSupported());, + assumeTrue(OpenSsl.isAlpnSupported());]
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java, + fullMsg.release();]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/ByteBufChecksum.java, +import io.netty.util.ByteProcessor;, + private final ByteProcessor updateProcessor = new ByteProcessor() {, + @Override, + public boolean process(byte value) throws Exception {, + update(value);, + return true;, + }, + };, +, + static ByteBufChecksum wrapChecksum(Checksum checksum) {, + ObjectUtil.checkNotNull(checksum, "checksum");, + if (checksum instanceof Adler32 && ADLER32_UPDATE_METHOD != null) {, + return new ReflectiveByteBufChecksum(checksum, ADLER32_UPDATE_METHOD);, + }, + if (checksum instanceof CRC32 && CRC32_UPDATE_METHOD != null) {, + return new ReflectiveByteBufChecksum(checksum, CRC32_UPDATE_METHOD);, + }, + return new SlowByteBufChecksum(checksum);, + }, + /**, + * @see {@link #update(byte[], int, int)}., + */, + public void update(ByteBuf b, int
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + // These needs to be volatile as otherwise an other Thread may see an half initialized instance., + // See the JMM for more details, + private volatile Runnable invokeChannelReadCompleteTask;, + private volatile Runnable invokeReadTask;, + private volatile Runnable invokeChannelWritableStateChangedTask;, + private volatile Runnable invokeFlushTask;]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return Unpooled.EMPTY_BUFFER;, + return Unpooled.decodeString(nioBuffer, charset);, + return Unpooled.indexOf(this, fromIndex, toIndex, value);, + return Unpooled.indexOf(this, fromIndex, toIndex, indexFinder);, + return Unpooled.hashCode(this);, + return Unpooled.equals(this, (ByteBuf) o);, + return Unpooled.compare(this, that);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return Unpooled.EMPTY_BUFFER;, + return Unpooled.decodeString(nioBuffer, charset);, + return Unpooled.indexOf(this, fromIndex, toIndex, value);, + return Unpooled.indexOf(this, fromIndex, toIndex, indexFinder);, + return Unpooled.hashCode(this);, + return Unpooled.equals(this, (ByteBuf) o);, + return Unpooled.compare(this, that);, +++ b/buffer/src/main/java/io/netty/buffer/BigEndianHeapByteBuf.java, + * A big-endian Java heap buffer. It is recommended to use {@link Unpooled#buffer(int)}, + * and {@link Unpooled#wrappedBuffer(byte[])} instead of calling the, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return Unpooled.EMPTY_BUFFER;, + return Unpooled.decodeString(nioBuffer,
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, + // If a task was submitted when wakenUp value was 1, the task didn't get a chance to produce wakeup event., + // So we need to check task queue again before calling epoll_wait. If we don't, the task might be pended, + // until epoll_wait was timed out. It might be pended until idle timeout if IdleStateHandler existed, + // in pipeline., + if (hasTasks() && WAKEN_UP_UPDATER.compareAndSet(this, 0, 1)) {, + return Native.epollWait(epollFd.intValue(), events, 0);, + }, +]
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java]
[+++ b/pom.xml, +++ b/pom.xml, +++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, +++ b/pom.xml, +++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ConnectionlessBootstrap.java, + ch.getConfig().setPipelineFactory(getPipelineFactory());, +++ b/pom.xml, +++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ConnectionlessBootstrap.java, + ch.getConfig().setPipelineFactory(getPipelineFactory());, +++ b/src/main/java/io/netty/bootstrap/ServerBootstrap.java, +++ b/pom.xml, +++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ConnectionlessBootstrap.java, + ch.getConfig().setPipelineFactory(getPipelineFactory());, +++ b/src/main/java/io/netty/bootstrap/ServerBootstrap.java, +++ b/src/main/java/io/netty/example/http/websocketx/autobahn/WebSocketServer.java, + * A Web Socket echo server for running the <a href="http://www.tavendo.de/autobahn/testsuite.html">autobahn</a>, + * test suite, +++ b/pom.xml, +++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ConnectionlessBootstrap.java, + ch.getConfig().setPipelineFactory(getPipelineFactory());, +++ b/src/main/java/io/netty/bootstrap/ServerBootstrap.java, +++ b/src/main/java/io/netty/example/http/websocketx/autobahn/WebSocketServer.java, + * A Web Socket echo server for running the <a href="http://www.tavendo.de/autobahn/testsuite.html">autobahn</a>, + * test suite, +++ b/src/main/java/io/netty/example/http/websocketx/autobahn/WebSocketServerHandler.java, + ctx.getChannel().write(new TextWebSocketFrame(frame.isFinalFragment(), frame.getRsv(), frame.getBinaryData()));, +++ b/pom.xml, +++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/io/netty/bootstrap/ConnectionlessBootstrap.java, + ch.getConfig().setPipelineFactory(getPipelineFactory());, +++ b/src/main/java/io/netty/bootstrap/ServerBootstrap.java, +++ b/src/main/java/io/netty/example/http/websocketx/autobahn/WebSocketServer.java,
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + // Check if this handler was removed before continuing the loop., + // If it was removed, it is not safe to continue to operate on the buffer., +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + // Check if this handler was removed before continuing the loop., + // If it was removed, it is not safe to continue to operate on the buffer., +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, + // Check if this handler was removed before continuing the loop., + // If it was removed, it is not safe to continue to operate on the buffer., + // Check if this handler
[+++ b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java, + bossGroup = new NioEventLoopGroup(1);, +++ b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java, + bossGroup = new NioEventLoopGroup(1);, +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, + EventLoopGroup bossGroup = new NioEventLoopGroup(1);, +++ b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java, + bossGroup = new NioEventLoopGroup(1);, +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, + EventLoopGroup bossGroup = new NioEventLoopGroup(1);, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + EventLoopGroup bossGroup = new NioEventLoopGroup(1);, +++ b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java, + bossGroup = new NioEventLoopGroup(1);, +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, + EventLoopGroup bossGroup = new NioEventLoopGroup(1);, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + EventLoopGroup bossGroup = new NioEventLoopGroup(1);, +++ b/example/src/main/java/io/netty/example/factorial/FactorialServer.java, + EventLoopGroup bossGroup = new NioEventLoopGroup(1);, +++ b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java, + bossGroup = new NioEventLoopGroup(1);, +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, + EventLoopGroup bossGroup = new NioEventLoopGroup(1);, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + EventLoopGroup bossGroup = new NioEventLoopGroup(1);,
[+++ b/all/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/example/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha7-SNAPSHOT</version>, +++ b/codec/pom.xml, +
[+++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslClientContextTest.java, +import org.junit.BeforeClass;, +import static org.junit.Assume.assumeTrue;, +, +, + @BeforeClass, + public static void checkOpenSsl() {, + assumeTrue(OpenSsl.isAvailable());, + }, +, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslClientContextTest.java, +import org.junit.BeforeClass;, +import static org.junit.Assume.assumeTrue;, +, +, + @BeforeClass, + public static void checkOpenSsl() {, + assumeTrue(OpenSsl.isAvailable());, + }, +, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, +import org.junit.BeforeClass;, + @BeforeClass, + public static void checkOpenSsl() {, + assumeTrue(OpenSsl.isAvailable());, + }, +, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslClientContextTest.java, +import org.junit.BeforeClass;, +import static org.junit.Assume.assumeTrue;, +, +, + @BeforeClass, + public static void checkOpenSsl() {, + assumeTrue(OpenSsl.isAvailable());, + }, +, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, +import org.junit.BeforeClass;, + @BeforeClass, + public static void checkOpenSsl() {, + assumeTrue(OpenSsl.isAvailable());, + },
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + private static final FastThreadLocal<byte[]> BYTE_ARRAYS = new FastThreadLocal<byte[]>() {, + protected byte[] initialValue() throws Exception {, + return PlatformDependent.allocateUninitializedArray(1024);, + @SuppressWarnings("deprecation"), + final byte[] array;, + final int offset;, + if (src.hasArray()) {, + array = src.array();, + offset = src.arrayOffset() + readerIndex;, + } else {, + if (len <= 1024) {, + array = BYTE_ARRAYS.get();, + } else {, + array = PlatformDependent.allocateUninitializedArray(len);, + offset = 0;, + src.getBytes(readerIndex, array, 0, len);, + if (CharsetUtil.US_ASCII.equals(charset)) {, + // Fast-path for US-ASCII which is used frequently., + return new String(array, 0, offset, len);, + return
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +import io.netty.util.internal.PlatformDependent;, +import javax.net.ssl.SSLSessionBindingEvent;, +import javax.net.ssl.SSLSessionBindingListener;, +import java.util.HashMap;, +import java.util.Map;, +import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;, +, + AtomicIntegerFieldUpdater<OpenSslEngine> destroyedUpdater =, + PlatformDependent.newAtomicIntegerFieldUpdater(OpenSslEngine.class, "destroyed");, + if (destroyedUpdater == null) {, + destroyedUpdater = AtomicIntegerFieldUpdater.newUpdater(OpenSslEngine.class, "destroyed");, + }, + DESTROYED_UPDATER = destroyedUpdater;, + AtomicReferenceFieldUpdater<OpenSslEngine, SSLSession> sessionUpdater =, + PlatformDependent.newAtomicReferenceFieldUpdater(OpenSslEngine.class, "session");, + if (sessionUpdater == null) {, + sessionUpdater = AtomicReferenceFieldUpdater.newUpdater(OpenSslEngine.class, SSLSession.class, "session");, + }, + SESSION_UPDATER = sessionUpdater;, + private static final AtomicIntegerFieldUpdater<OpenSslEngine> DESTROYED_UPDATER;, + private static final AtomicReferenceFieldUpdater<OpenSslEngine, SSLSession> SESSION_UPDATER;, +, + // We store this outside of the SslSession so we not need to create an instance during verifyCertificates(...), +,
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + boolean removed;]
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteDecoder.java, + public void inboundBufferUpdated(ChannelHandlerContext ctx, ChannelBuffer in) throws Exception {, + callDecode(ctx, in, ctx.nextOutboundByteBuffer());, + ChannelBuffer out = ctx.nextInboundByteBuffer();, + callDecode(ctx, in, out);, + private void callDecode(ChannelHandlerContext ctx, ChannelBuffer in, ChannelBuffer out) {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteDecoder.java, + public void inboundBufferUpdated(ChannelHandlerContext ctx, ChannelBuffer in) throws Exception {, + callDecode(ctx, in, ctx.nextOutboundByteBuffer());, + ChannelBuffer out = ctx.nextInboundByteBuffer();, + callDecode(ctx, in, out);, + private void callDecode(ChannelHandlerContext ctx, ChannelBuffer in, ChannelBuffer out) {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +import io.netty.channel.ChannelBufferHolder;, +import io.netty.channel.ChannelBufferHolders;, +import io.netty.channel.ChannelInboundHandlerAdapter;, +public abstract class ByteToMessageDecoder<O> extends ChannelInboundHandlerAdapter<Byte> {, + public ChannelBufferHolder<Byte> newInboundBuffer(ChannelHandlerContext ctx) throws Exception {, + return ChannelBufferHolders.byteBuffer();, + }, +,
[+++ b/src/docbook/master.xml, + <xi:include href="module/buffer.xml", + xmlns:xi="http://www.w3.org/2001/XInclude" />, +, +++ b/src/docbook/master.xml, + <xi:include href="module/buffer.xml", + xmlns:xi="http://www.w3.org/2001/XInclude" />, +, +++ b/src/docbook/module/architecture.xml, + Netty uses its own buffer API instead of NIO <classname>ByteBuffer</classname>, + to represent a sequence of bytes. This approach has significant advantage, + over using <classname>ByteBuffer</classname>. Netty's new buffer type,, + &ChannelBuffer; has been designed from ground up to address the problems, + of <classname>ByteBuffer</classname> and to meet the daily needs of, + network application developers. To list a few cool features:, + <itemizedlist>, + <listitem>, + You can define your buffer type if necessary., + </listitem>, +
[+++ b/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java, + frame = buffer.readSlice(minFrameLength);, + frame = buffer.readSlice(minFrameLength + minDelimLength);, + return frame.retain();, +++ b/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java, + frame = buffer.readSlice(minFrameLength);, + frame = buffer.readSlice(minFrameLength + minDelimLength);, + return frame.retain();, +++ b/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java, + return in.readSlice(frameLength).retain();, +++ b/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java, + frame = buffer.readSlice(minFrameLength);, + frame = buffer.readSlice(minFrameLength + minDelimLength);, + return frame.retain();, +++ b/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java, + return in.readSlice(frameLength).retain();, +++ b/codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java, + frame = buffer.readSlice(length);, + frame = buffer.readSlice(length + delimLength);, + return frame.retain();]
[+++ b/bom/pom.xml, + <dependency>, + <groupId>io.netty</groupId>, + <artifactId>netty-transport-unix-common</artifactId>, + <version>4.1.12.Final-SNAPSHOT</version>, + </dependency>, + <dependency>, + <groupId>io.netty</groupId>, + <artifactId>netty-transport-native-epoll</artifactId>, + <version>4.1.12.Final-SNAPSHOT</version>, + <classifier>linux-x86_64</classifier>, + </dependency>, + <dependency>, + <groupId>io.netty</groupId>, + <artifactId>netty-transport-native-kqueue</artifactId>, + <version>4.1.12.Final-SNAPSHOT</version>, + <classifier>osx-x86_64</classifier>, + </dependency>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/CookieUtil.java, + private static final BitSet VALID_COOKIE_NAME_OCTETS = validCookieNameOctets();, +, + private static final BitSet VALID_COOKIE_ATTRIBUTE_VALUE_OCTETS = validCookieAttributeValueOctets();, +, + // token = 1*<any CHAR except CTLs or separators>, + // separators = "(" | ")" | "<" | ">" | "@", + // | "," | ";" | ":" | "\" | <">, + // | "/" | "[" | "]" | "?" | "=", + // | "{" | "}" | SP | HT, + private static BitSet validCookieNameOctets() {, + BitSet bits = new BitSet();, + for (int i = 32; i < 127; i++)
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + public final ByteBuf touch(Object hint) {, + unwrap().touch(hint);, + return this;, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + public final ByteBuf touch(Object hint) {, + unwrap().touch(hint);, + return this;, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + public ByteBuf touch() {, + return this;, + }, +, + @Override, + public ByteBuf touch(Object hint) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + public final ByteBuf touch(Object hint) {, + unwrap().touch(hint);, + return this;, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + public ByteBuf touch() {, + return this;, + }, +, + @Override, + public ByteBuf touch(Object hint) {,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java, + @Override, + @Override, + @Override, + @Override, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java, +
[+++ b/codec/src/main/java/io/netty/handler/codec/serialization/ClassResolvers.java, + final ClassLoader contextClassLoader = PlatformDependent.getContextClassLoader();, + return PlatformDependent.getClassLoader(ClassResolvers.class);, +++ b/codec/src/main/java/io/netty/handler/codec/serialization/ClassResolvers.java, + final ClassLoader contextClassLoader = PlatformDependent.getContextClassLoader();, + return PlatformDependent.getClassLoader(ClassResolvers.class);, +++ b/common/src/main/java/io/netty/util/Version.java, +import io.netty.util.internal.PlatformDependent;, +, + classLoader = PlatformDependent.getContextClassLoader();, +++ b/codec/src/main/java/io/netty/handler/codec/serialization/ClassResolvers.java, + final ClassLoader contextClassLoader = PlatformDependent.getContextClassLoader();, + return PlatformDependent.getClassLoader(ClassResolvers.class);, +++ b/common/src/main/java/io/netty/util/Version.java, +import io.netty.util.internal.PlatformDependent;, +, + classLoader = PlatformDependent.getContextClassLoader();, +++ b/common/src/main/java/io/netty/util/internal/JavassistTypeParameterMatcherGenerator.java, + ClassLoader classLoader = PlatformDependent.getContextClassLoader();, + classLoader = PlatformDependent.getSystemClassLoader();, +++ b/codec/src/main/java/io/netty/handler/codec/serialization/ClassResolvers.java, + final ClassLoader contextClassLoader = PlatformDependent.getContextClassLoader();, + return PlatformDependent.getClassLoader(ClassResolvers.class);, +++ b/common/src/main/java/io/netty/util/Version.java, +import io.netty.util.internal.PlatformDependent;, +, + classLoader = PlatformDependent.getContextClassLoader();, +++ b/common/src/main/java/io/netty/util/internal/JavassistTypeParameterMatcherGenerator.java, + ClassLoader classLoader = PlatformDependent.getContextClassLoader();, + classLoader = PlatformDependent.getSystemClassLoader();, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + /**, + *
[+++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + switch (s.nioBufferCount()) {, + case 0:, + throw new UnsupportedOperationException();, + case 1:, + break;, + default:, + Collections.addAll(buffers, s.nioBuffers(index - adjustment, localLength));, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + switch (s.nioBufferCount()) {, + case 0:, + throw new UnsupportedOperationException();, + case 1:, + break;, + default:, + Collections.addAll(buffers, s.nioBuffers(index - adjustment, localLength));, + }, +, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, +, + @Test, + public void testNestedLayout() {, + CompositeByteBuf buf = freeLater(compositeBuffer());, + buf.addComponent(, + compositeBuffer(), + .addComponent(wrappedBuffer(new byte[]{1, 2})), + .addComponent(wrappedBuffer(new byte[]{3, 4})).slice(1, 2));, +, + ByteBuffer[] nioBuffers = buf.nioBuffers(0, 2);, + assertThat(nioBuffers.length, is(2));, + assertThat(nioBuffers[0].remaining(), is(1));,
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, + "SSL_RSA_WITH_DES_CBC_SHA",, + "SSL_RSA_WITH_RC4_128_SHA");, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, + "SSL_RSA_WITH_DES_CBC_SHA",, + "SSL_RSA_WITH_RC4_128_SHA");, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java, + "DES-CBC3-SHA",, + "RC4-SHA");]
[+++ b/buffer/src/main/java/io/netty/buffer/PoolChunkList.java, + // Move the PoolChunk down the PoolChunkList linked-list., + return move0(chunk);, + }, + return true;, + }, +, + private boolean move(PoolChunk<T> chunk) {, + assert chunk.usage() < maxUsage;, +, + if (chunk.usage() < minUsage) {, + // Move the PoolChunk down the PoolChunkList linked-list., + return move0(chunk);, + }, +, + // PoolChunk fits into this PoolChunkList, adding it here., + add0(chunk);, + return true;, + }, +, + /**, + * Moves the {@link PoolChunk} down the {@link PoolChunkList} linked-list so it will end up in the right, + * {@link PoolChunkList} that
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + if (unwrap().release()) {, + deallocate();, + return true;, + }, + return false;, + if (unwrap().release(decrement)) {, + deallocate();, + return true;, + }, + return false;, +, + /**, + * Called when the wrapped {@link ByteBuf} was released due calling of {@link #release()} or {@link #release(int)}., + */, + protected void deallocate() { }, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + if (unwrap().release()) {, + deallocate();, + return true;, + }, + return false;, + if (unwrap().release(decrement)) {, + deallocate();, + return true;, + }, + return false;, +, + /**, + * Called when the wrapped {@link
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + private static final int ADDRESS_SIZE = addressSize0();, +, + * Return the address size of the OS., + * 4 (for 32 bits systems ) and 8 (for 64 bits systems)., + */, + public static int addressSize() {, + return ADDRESS_SIZE;, + }, +, + public static long allocateMemory(long size) {, + return PlatformDependent0.allocateMemory(size);, + }, +, + public static void freeMemory(long address) {, + PlatformDependent0.freeMemory(address);, + }, +, + /**, + private static int addressSize0() {, + if (!hasUnsafe()) {, + return -1;, + }, + return PlatformDependent0.addressSize();, + }, +, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + int bytesWritten = 0;, + try {, + if (allowedBytes == 0 && size != 0) {, + } finally {, + size -= bytesWritten;, + // Ensure error() gets called in case something goes wrong after the frame is passed to Netty., + public void writeComplete() {, + if (endOfStream) {, + lifecycleManager.closeLocalSide(stream, promise);, + }, + }, +, + @Override, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + int bytesWritten = 0;, + try {, + if (allowedBytes == 0 && size != 0) {, + } finally {, + size -= bytesWritten;, + // Ensure error() gets called
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/TrafficShapingHandlerTest.java, +/*, + * Copyright 2012 The Netty Project, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + * http://www.apache.org/licenses/LICENSE-2.0, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + *
[+++ b/common/src/main/java/io/netty/util/concurrent/BlockingOperationException.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +, +static inline int addressLength(struct sockaddr_storage addr) {, + if (addr.ss_family == AF_INET) {, + return 8;, + } else {, + struct sockaddr_in6* s = (struct sockaddr_in6*) &addr;, + if (s->sin6_addr.s6_addr[0] == 0x00 && s->sin6_addr.s6_addr[1] == 0x00 && s->sin6_addr.s6_addr[2] == 0x00 && s->sin6_addr.s6_addr[3] == 0x00 && s->sin6_addr.s6_addr[4] == 0x00, + && s->sin6_addr.s6_addr[5] == 0x00 && s->sin6_addr.s6_addr[6] == 0x00 && s->sin6_addr.s6_addr[7] == 0x00 && s->sin6_addr.s6_addr[8] == 0x00 && s->sin6_addr.s6_addr[9] == 0x00, + && s->sin6_addr.s6_addr[10] == 0xff && s->sin6_addr.s6_addr[11] == 0xff) {, + // IPv4-mapped-on-IPv6, + return 8;, + } else {, + return 24;, + }, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, + // IMPORTANT: The callbacks set for verification must be static to prevent memory leak as, + // otherwise the context can never be collected. This is because the JNI code holds, + // a global reference to the callbacks., + //, + // See https://github.com/netty/netty/issues/5372, +, + SSLContext.setCertVerifyCallback(ctx,, + new ExtendedTrustManagerVerifyCallback(engineMap, (X509ExtendedTrustManager) manager));, + SSLContext.setCertVerifyCallback(ctx, new TrustManagerVerifyCallback(engineMap, manager));, +, + private static final class TrustManagerVerifyCallback extends AbstractCertificateVerifier {, + private final X509TrustManager manager;, +, + TrustManagerVerifyCallback(OpenSslEngineMap engineMap, X509TrustManager manager) {, + super(engineMap);, + this.manager = manager;, + }, +, + @Override, + void verify(OpenSslEngine engine, X509Certificate[]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + protected final void checkSrcIndex(int index, int length, int srcIndex, int srcCapacity) {, + checkIndex(index, length);, + if (srcIndex < 0 || srcIndex > srcCapacity - length) {, + throw new IndexOutOfBoundsException(String.format(, + "srcIndex: %d, length: %d (expected: range(0, %d))", srcIndex, length, srcCapacity));, + }, + }, +, + protected final void checkDstIndex(int index, int length, int dstIndex, int dstCapacity) {, + checkIndex(index, length);, + if (dstIndex < 0 || dstIndex > dstCapacity - length) {, + throw new IndexOutOfBoundsException(String.format(, + "dstIndex: %d, length: %d (expected: range(0, %d))", dstIndex, length, dstCapacity));, + }, + }, +, +++
[+++ b/testsuite-shading/pom.xml, + <id>windows</id>, + <activation>, + <os>, + <family>windows</family>, + </os>, + </activation>, + <dependencies>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-common</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-handler</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>${tcnative.artifactId}</artifactId>, + <version>${tcnative.version}</version>, + <classifier>${tcnative.classifier}</classifier>, + <scope>compile</scope>, + </dependency>, + </dependencies>, + </profile>, + <profile>, + <artifactId>netty-common</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-common</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/testsuite-shading/pom.xml, + <id>windows</id>, + <activation>, + <os>, + <family>windows</family>, + </os>, + </activation>, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java, +import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;, + private long maxHeaderListSizeGoAway;, + this.maxHeaderListSizeGoAway =, + Http2CodecUtil.calculateMaxHeaderListSizeGoAway(hpackDecoder.getMaxHeaderListSize());, + if (goAwayMax < max || goAwayMax < 0) {, + throw connectionError(INTERNAL_ERROR, "Header List Size GO_AWAY %d must be non-negative and >= %d",, + goAwayMax, max);, + }, + hpackDecoder.setMaxHeaderListSize(max);, + this.maxHeaderListSizeGoAway = goAwayMax;, + return maxHeaderListSizeGoAway;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java, +import static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;, + private long maxHeaderListSizeGoAway;, + this.maxHeaderListSizeGoAway =, + Http2CodecUtil.calculateMaxHeaderListSizeGoAway(hpackDecoder.getMaxHeaderListSize());, + if (goAwayMax < max || goAwayMax < 0) {, + throw connectionError(INTERNAL_ERROR, "Header List Size GO_AWAY %d must be non-negative and >= %d",, + goAwayMax, max);, + }, + hpackDecoder.setMaxHeaderListSize(max);, + this.maxHeaderListSizeGoAway
[+++ b/pom.xml, + <excludePackageNames>${project.groupId}.example*:${project.groupId}.container*:${project.groupId}.util.internal*</excludePackageNames>]
[+++ b/codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java, + return buffer.slice(index, length).retain();]
[+++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxyFrontendHandler.java]
[+++ b/pom.xml, + <requireProperty>, + <regexMessage>, + x86_64 JDK must be used., + </regexMessage>, + <property>os.detected.arch</property>, + <regex>^x86_64$</regex>, + </requireProperty>]
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, +, + ctx.flush(future);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, +, + ctx.flush(future);, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, +, + ctx.flush(future);, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, + CodecUtil.unfoldAndAdd(ctx, omsg, false);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, +, + ctx.flush(future);, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, + CodecUtil.unfoldAndAdd(ctx, omsg, false);, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedNioFile.java, + int localReadBytes = buffer.writeBytes(in, chunkSize - readBytes);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, +, + ctx.flush(future);, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, + CodecUtil.unfoldAndAdd(ctx, omsg, false);, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedNioFile.java, + int localReadBytes = buffer.writeBytes(in, chunkSize - readBytes);, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java, + private final int maxPendingWrites;, + public ChunkedWriteHandler() {, + this(4);, + }, +, + public ChunkedWriteHandler(int maxPendingWrites) {, + if (maxPendingWrites <= 0) {, +
[+++ b/NOTICE.txt, +This product contains a modified portion of 'Webbit', an event based , +WebSocket and HTTP server, which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.webbit.txt (BSD License), + * HOMEPAGE:, + * https://github.com/joewalnes/webbit, +, +This product contains a modified portion of 'Caliper', Google's micro-, +benchmarking framework, which can be obtained at::, +, + * LICENSE:, + * license/LICENSE.caliper.txt (Apache License 2.0), + * HOMEPAGE:, + * http://code.google.com/p/caliper/, +, +This product optionally depends on 'Metrics', Yammer's JVM- and application-, +level metrics library, which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.metrics.txt (Apache
[+++ b/example/src/main/java/io/netty/example/sctp/NioSctpEchoClient.java, +import io.netty.channel.sctp.SctpChannelOption;, + .option(SctpChannelOption.SCTP_NODELAY, true), +++ b/example/src/main/java/io/netty/example/sctp/NioSctpEchoClient.java, +import io.netty.channel.sctp.SctpChannelOption;, + .option(SctpChannelOption.SCTP_NODELAY, true), +++ b/example/src/main/java/io/netty/example/sctp/NioSctpEchoServer.java, +import io.netty.channel.sctp.SctpChannelOption;, + .childOption(SctpChannelOption.SCTP_NODELAY, true), +++ b/example/src/main/java/io/netty/example/sctp/NioSctpEchoClient.java, +import io.netty.channel.sctp.SctpChannelOption;, + .option(SctpChannelOption.SCTP_NODELAY, true), +++ b/example/src/main/java/io/netty/example/sctp/NioSctpEchoServer.java, +import io.netty.channel.sctp.SctpChannelOption;, + .childOption(SctpChannelOption.SCTP_NODELAY, true), +++ b/example/src/main/java/io/netty/example/sctp/OioSctpEchoClient.java, +import io.netty.channel.sctp.SctpChannelOption;, + .option(SctpChannelOption.SCTP_NODELAY, true), +++ b/example/src/main/java/io/netty/example/sctp/NioSctpEchoClient.java, +import io.netty.channel.sctp.SctpChannelOption;, + .option(SctpChannelOption.SCTP_NODELAY, true), +++ b/example/src/main/java/io/netty/example/sctp/NioSctpEchoServer.java, +import io.netty.channel.sctp.SctpChannelOption;, + .childOption(SctpChannelOption.SCTP_NODELAY, true), +++ b/example/src/main/java/io/netty/example/sctp/OioSctpEchoClient.java, +import io.netty.channel.sctp.SctpChannelOption;, + .option(SctpChannelOption.SCTP_NODELAY, true), +++ b/example/src/main/java/io/netty/example/sctp/OioSctpEchoServer.java, +import io.netty.channel.sctp.SctpChannelOption;, + .childOption(SctpChannelOption.SCTP_NODELAY, true), +++ b/example/src/main/java/io/netty/example/sctp/NioSctpEchoClient.java, +import io.netty.channel.sctp.SctpChannelOption;, + .option(SctpChannelOption.SCTP_NODELAY, true), +++ b/example/src/main/java/io/netty/example/sctp/NioSctpEchoServer.java, +import io.netty.channel.sctp.SctpChannelOption;, + .childOption(SctpChannelOption.SCTP_NODELAY, true), +++ b/example/src/main/java/io/netty/example/sctp/OioSctpEchoClient.java, +import io.netty.channel.sctp.SctpChannelOption;, + .option(SctpChannelOption.SCTP_NODELAY, true), +++ b/example/src/main/java/io/netty/example/sctp/OioSctpEchoServer.java, +import io.netty.channel.sctp.SctpChannelOption;, + .childOption(SctpChannelOption.SCTP_NODELAY, true), +++
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + // mark as package-private, only for unit test, + int offsetCacheLine(ByteBuffer memory) {, + int remainder = HAS_UNSAFE, + ? (int) (PlatformDependent.directBufferAddress(memory) & directMemoryCacheAlignmentMask), + : 0;, +, + // offset = alignment - address & (alignment - 1), + return directMemoryCacheAlignment - remainder;, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + // mark as package-private, only for unit test, + int offsetCacheLine(ByteBuffer memory) {, + int remainder = HAS_UNSAFE, + ? (int) (PlatformDependent.directBufferAddress(memory) & directMemoryCacheAlignmentMask), + : 0;, +, + // offset = alignment - address & (alignment - 1), + return directMemoryCacheAlignment - remainder;, +++ b/buffer/src/test/java/io/netty/buffer/PoolArenaTest.java, +import io.netty.util.internal.PlatformDependent;, +
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +import java.lang.reflect.Method;, + private static final boolean UNALIGNED;, +, + static {, + boolean unaligned = false;, + try {, + Class<?> bitsClass = Class.forName("java.nio.Bits", false, ClassLoader.getSystemClassLoader());, + Method unalignedMethod = bitsClass.getDeclaredMethod("unaligned");, + unalignedMethod.setAccessible(true);, + unaligned = Boolean.TRUE.equals(unalignedMethod.invoke(null));, + } catch (Throwable t) {, + // Ignore, + }, +, + UNALIGNED = unaligned;, + }, +, + if (UNALIGNED) {, + return new PooledUnsafeDirectByteBuf(maxCapacity);, + } else {, + }, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +import java.lang.reflect.Method;, + private static final boolean UNALIGNED;, +, + static {, + boolean unaligned = false;, + try {, + Class<?> bitsClass =
[+++ b/common/src/main/java/io/netty/util/AttributeKey.java, +@SuppressWarnings({"UnusedDeclaration", "deprecation"}) // 'T' is used only at compile time, + * Creates a new {@link AttributeKey} with the specified {@code name}., + @SuppressWarnings("deprecation"), + public static <T> AttributeKey<T> valueOf(String name) {, + return new AttributeKey<T>(name);, + }, +, + /**, + * @deprecated Use {@link #valueOf(String)} instead., + */, + @Deprecated, +++ b/common/src/main/java/io/netty/util/AttributeKey.java, +@SuppressWarnings({"UnusedDeclaration", "deprecation"}) // 'T' is used only at compile time, + * Creates a new {@link AttributeKey} with the specified {@code name}., + @SuppressWarnings("deprecation"), + public static <T> AttributeKey<T> valueOf(String name) {, + return new AttributeKey<T>(name);, + }, +, + /**, + *
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/LzmaFrameEncoder.java, + if (lc + lp > 4) {]
[+++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +import io.netty.channel.DefaultChannelPromise;, +import io.netty.util.concurrent.GlobalEventExecutor;, + final ChannelFuture regFuture = initAndRegister();, + final Channel channel = regFuture.channel();, + if (regFuture.cause() != null) {, + return regFuture;, + }, +, + final ChannelPromise promise;, + if (regFuture.isDone()) {, + promise = channel.newPromise();, + doBind0(regFuture, channel, localAddress, promise);, + // Registration future is almost always fulfilled already, but just in case it's not., + promise = new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE);, + regFuture.addListener(new ChannelFutureListener() {, + doBind0(regFuture, channel, localAddress, promise);, + ChannelFuture regFuture = group().register(channel);, + if (regFuture.cause() != null) {, + return regFuture;, +++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +import io.netty.channel.DefaultChannelPromise;, +import io.netty.util.concurrent.GlobalEventExecutor;, + final
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + private static final AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> refCntUpdater =, + AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCountedByteBuf.class, "refCnt");, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + private static final AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> refCntUpdater =, + AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCountedByteBuf.class, "refCnt");, +++ b/common/src/main/java/io/netty/util/AbstractReferenceCounted.java, + private static final AtomicIntegerFieldUpdater<AbstractReferenceCounted> refCntUpdater =, + AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCounted.class, "refCnt");, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + private static final AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> refCntUpdater =, + AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCountedByteBuf.class, "refCnt");, +++ b/common/src/main/java/io/netty/util/AbstractReferenceCounted.java, + private static final AtomicIntegerFieldUpdater<AbstractReferenceCounted> refCntUpdater =, + AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCounted.class, "refCnt");, +++ b/common/src/main/java/io/netty/util/DefaultAttributeMap.java, + private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =, + AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, "attributes");, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + private static final AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> refCntUpdater =, + AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCountedByteBuf.class, "refCnt");, +++ b/common/src/main/java/io/netty/util/AbstractReferenceCounted.java, + private static final AtomicIntegerFieldUpdater<AbstractReferenceCounted> refCntUpdater =, + AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCounted.class, "refCnt");, +++
[+++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java, +import io.netty.util.internal.ObjectUtil;, +public class IdleStateEvent {, + /**, + * Constructor for sub-classes., + *, + * @param state the {@link IdleStateEvent} which triggered the event., + * @param first {@code true} if its the first idle event for the {@link IdleStateEvent}., + */, + protected IdleStateEvent(IdleState state, boolean first) {, + this.state = ObjectUtil.checkNotNull(state, "state");, +++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java, +import io.netty.util.internal.ObjectUtil;, +public class IdleStateEvent {, + /**, + * Constructor for sub-classes., + *, + * @param state the {@link IdleStateEvent} which triggered the event., + * @param first {@code true} if its the first idle event for
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketHalfClosedTest.java, +import io.netty.channel.SimpleChannelInboundHandler;, +import io.netty.channel.socket.ChannelOutputShutdownEvent;, +import java.util.concurrent.atomic.AtomicReference;, +import static org.junit.Assert.assertNull;, + private static void testAllDataReadAfterHalfClosure(final boolean autoRead,, + public void testAutoCloseFalseDoesShutdownOutput() throws Throwable {, + run();, + }, +, + public void testAutoCloseFalseDoesShutdownOutput(ServerBootstrap sb, Bootstrap cb) throws Throwable {, + testAutoCloseFalseDoesShutdownOutput(false, false, sb, cb);, + testAutoCloseFalseDoesShutdownOutput(false, true, sb, cb);, + testAutoCloseFalseDoesShutdownOutput(true, false, sb, cb);, + testAutoCloseFalseDoesShutdownOutput(true, true, sb, cb);, + }, +, + private static void testAutoCloseFalseDoesShutdownOutput(boolean allowHalfClosed,, + final boolean clientIsLeader,, + ServerBootstrap sb,, + Bootstrap cb) throws InterruptedException {, + final int expectedBytes = 100;, + final CountDownLatch serverReadExpectedLatch = new CountDownLatch(1);, + final CountDownLatch doneLatch
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + } else {, + // Send any other frames down the pipeline, + ctx.fireChannelRead(frame);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + } else {, + // Send any other frames down the pipeline, + ctx.fireChannelRead(frame);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexCodecTest.java, + public void unhandledHttp2FramesShouldBePropagated() {, + ByteBuf content = UnpooledByteBufAllocator.DEFAULT.buffer(8).writeLong(0);, + Http2PingFrame decodedFrame = new DefaultHttp2PingFrame(content);, +, + codec.onHttp2Frame(decodedFrame);, + Http2PingFrame receivedPing = parentChannel.readInbound();, + assertSame(receivedPing, decodedFrame);, + assertTrue(receivedPing.release());, + }, +, + @Test]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Set;, + // Protocols, + private static final String PROTOCOL_SSL_V2_HELLO = "SSLv2Hello";, + private static final String PROTOCOL_SSL_V2 = "SSLv2";, + private static final String PROTOCOL_SSL_V3 = "SSLv3";, + private static final String PROTOCOL_TLS_V1 = "TLSv1";, + private static final String PROTOCOL_TLS_V1_1 = "TLSv1.1";, + private static final String PROTOCOL_TLS_V1_2 = "TLSv1.2";, +, + private static final String[] SUPPORTED_PROTOCOLS = {, + PROTOCOL_SSL_V2_HELLO,, + PROTOCOL_SSL_V2,, + PROTOCOL_SSL_V3,, + PROTOCOL_TLS_V1,, + PROTOCOL_TLS_V1_1,, + PROTOCOL_TLS_V1_2, + };, + private static final Set<String> SUPPORTED_PROTOCOLS_SET = new HashSet<String>(Arrays.asList(SUPPORTED_PROTOCOLS));,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoder.java, + releaseBuffer();, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoder.java, + releaseBuffer();, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoderTest.java, +import io.netty.util.ReferenceCountUtil;, +import org.junit.After;, + @After, + public void tearDown() {, + decoder.end();, + }, +, + ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.EMPTY_BUFFER);, + ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(4));, + ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(4));, + ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(21));, + ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(4));, + ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(8));, + ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(8));, + ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(8));, + ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(18));, + ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(12));, + ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(16));, + ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(16));, + ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(16));, + ByteBuf headerBlock = ReferenceCountUtil.releaseLater(Unpooled.buffer(17));, + ByteBuf headerBlock
[+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, + final ByteBuf buf;, + buf = PlatformDependent.hasUnsafe() ?, + new UnpooledUnsafeHeapByteBuf(this, initialCapacity, maxCapacity) :, + new UnpooledHeapByteBuf(this, initialCapacity, maxCapacity);, + final ByteBuf buf;, + buf = PlatformDependent.hasUnsafe() ?, + UnsafeByteBufUtil.newUnsafeDirectByteBuf(this, initialCapacity, maxCapacity) :, + new UnpooledDirectByteBuf(this, initialCapacity, maxCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, + final ByteBuf buf;, + buf = PlatformDependent.hasUnsafe() ?, + new UnpooledUnsafeHeapByteBuf(this, initialCapacity, maxCapacity) :, + new UnpooledHeapByteBuf(this, initialCapacity, maxCapacity);, + final ByteBuf buf;, + buf = PlatformDependent.hasUnsafe() ?, + UnsafeByteBufUtil.newUnsafeDirectByteBuf(this, initialCapacity, maxCapacity) :, + new UnpooledDirectByteBuf(this, initialCapacity, maxCapacity);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufAllocatorTest.java, +import static org.junit.Assert.assertTrue;, + protected abstract AbstractByteBufAllocator newUnpooledAllocator();, +, +, + @Test, + public void
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, + localhost6 = (Inet6Address) InetAddress.getByAddress(, + new byte[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1});, +++ b/common/src/main/java/io/netty/util/NetUtil.java, + localhost6 = (Inet6Address) InetAddress.getByAddress(, + new byte[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1});, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java, + NetUtil.LOCALHOST4, TestUtils.getFreePort());]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + * Use this as wildcard to support all requested sub-protocols, + */, + public final static String SUB_PROTOCOL_WILDCARD = "*";, +, + /**, + if (SUB_PROTOCOL_WILDCARD.equals(supportedSubprotocol), + || requestedSubprotocol.equals(supportedSubprotocol)) {]
[+++ b/transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java, +import java.nio.channels.NotYetConnectedException;, + try {, + } else {, + if (!isConnected()) {, + // If not connected we should throw a NotYetConnectedException() to be consistent with, + // NioDatagramChannel, + throw new NotYetConnectedException();, + }]
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/OutputMessageBuf.java, + assert buf.isEmpty();, + super(2);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/OutputMessageBuf.java, + assert buf.isEmpty();, + super(2);, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java]
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + private static final ByteBuffer FULL_BYTEBUFFER = (ByteBuffer) ByteBuffer.allocate(1).position(1);, + if (length == 0) {, + return this;, + }, +, + if (length == 0) {, + return this;, + }, + if (length == 0) {, + return this;, + }, +, + if (length == 0) {, + return this;, + }, + if (length == 0) {, + return in.read(EmptyArrays.EMPTY_BYTES);, + }, + if (length == 0) {, + return in.read(FULL_BYTEBUFFER);, + }, + if (length != 0) {, + }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + private static final ByteBuffer FULL_BYTEBUFFER = (ByteBuffer) ByteBuffer.allocate(1).position(1);, +
[+++ b/codec/src/main/java/io/netty/handler/codec/sctp/SctpInboundByteStreamHandler.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + private static final long CLEANER_FIELD_OFFSET;, + ByteBuffer direct = ByteBuffer.allocateDirect(1);, + Field cleanerField;, + cleanerField = direct.getClass().getDeclaredField("cleaner");, + cleanerField.setAccessible(true);, + Cleaner cleaner = (Cleaner) cleanerField.get(direct);, + cleaner.clean();, + // We don't have ByteBuffer.cleaner()., + cleanerField = null;, +, + logger.debug("java.nio.ByteBuffer.cleaner(): {}", cleanerField != null? "available" : "unavailable");, + if (addressField != null && cleanerField != null) {, + CLEANER_FIELD_OFFSET = -1;, + CLEANER_FIELD_OFFSET = objectFieldOffset(cleanerField);, +, + // free temporary buffer if possible, + freeDirectBuffer(direct);, + if (CLEANER_FIELD_OFFSET == -1 || !buffer.isDirect()) {, + Cleaner cleaner = (Cleaner) getObject(buffer, CLEANER_FIELD_OFFSET);]
[+++ b/buffer/src/main/java/io/netty/buffer/Buf.java, +/**, + * A buffer to operate on, + */, +++ b/buffer/src/main/java/io/netty/buffer/Buf.java, +/**, + * A buffer to operate on, + */, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +/**, + * Utility class for operate on a {@link ByteBuf}, + */, +++ b/buffer/src/main/java/io/netty/buffer/Buf.java, +/**, + * A buffer to operate on, + */, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +/**, + * Utility class for operate on a {@link ByteBuf}, + */, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, +/**, + * A {@link ByteBuf} which is composed out of other {@link ByteBuf}s., + */, + /**, + * Add the given {@link ByteBuf}., + *, + * @param buffer
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, + super(WebSocketFrame.class);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, + super(WebSocketFrame.class);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, + super(FullHttpRequest.class);]
[+++ b/src/main/java/org/jboss/netty/container/spring/NettyResourceFactory.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2009, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version., + *, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, + public WebSocketServerProtocolHandshakeHandler(String websocketPath, String subprotocols,, + boolean allowExtensions) {]
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + ChannelBuffer frame = ctx.getChannel().getConfig().getBufferFactory().getBuffer(outAppBuf.remaining());, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + ChannelBuffer frame = ctx.getChannel().getConfig().getBufferFactory().getBuffer(outAppBuf.remaining());, +++ b/pom.xml, + <forkMode>once</forkMode>]
[+++ b/NOTICE.txt, +This product contains a modified version of 'HPACK', a Java implementation of, +the HTTP/2 HPACK algorithm written by Twitter. It can be obtained at:, +, + * LICENSE:, + * license/LICENSE.hpack.txt (Apache License 2.0), + * HOMEPAGE:, + * https://github.com/twitter/hpack, +, +++ b/NOTICE.txt, +This product contains a modified version of 'HPACK', a Java implementation of, +the HTTP/2 HPACK algorithm written by Twitter. It can be obtained at:, +, + * LICENSE:, + * license/LICENSE.hpack.txt (Apache License 2.0), + * HOMEPAGE:, + * https://github.com/twitter/hpack, +, +++ b/codec-http2/pom.xml, + <dependency>, + <groupId>com.google.code.gson</groupId>, + <artifactId>gson</artifactId>, + </dependency>, +++ b/NOTICE.txt, +This
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketRstTest.java]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, +import io.netty.handler.codec.http.QueryStringDecoder;, + attribute = getContentDispositionAttribute(values);, + private static final String FILENAME_ENCODED = HttpHeaderValues.FILENAME.toString() + '*';, +, + private Attribute getContentDispositionAttribute(String... values) {, + String name = cleanString(values[0]);, + String value = values[1];, +, + // Filename can be token, quoted or encoded. See https://tools.ietf.org/html/rfc5987, + if (HttpHeaderValues.FILENAME.contentEquals(name)) {, + // Value is quoted or token. Strip if quoted:, + int last = value.length() - 1;, + if (last > 0 &&, + value.charAt(0) == HttpConstants.DOUBLE_QUOTE &&, + value.charAt(last) == HttpConstants.DOUBLE_QUOTE) {, + value = value.substring(1, last);, + }, + } else if (FILENAME_ENCODED.equals(name)) {, + try
[+++ b/common/src/main/java/io/netty/util/internal/AppendableCharSequence.java, + pos = chars.length;, +++ b/common/src/main/java/io/netty/util/internal/AppendableCharSequence.java, + pos = chars.length;, +++ b/common/src/test/java/io/netty/util/internal/AppendableCharSequenceTest.java, + @Test, + public void testSubSequence() {, + AppendableCharSequence master = new AppendableCharSequence(26);, + master.append("abcdefghijlkmonpqrstuvwxyz");, + assertEquals(master.subSequence(0, 10).toString(), "abcdefghij");, + }, +]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ComposedLastHttpContent.java, + public DecoderResult decoderResult() {, + public DecoderResult getDecoderResult() {, + return decoderResult();, + }, +, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ComposedLastHttpContent.java, + public DecoderResult decoderResult() {, + public DecoderResult getDecoderResult() {, + return decoderResult();, + }, +, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpContent.java, + "(data: " + content() + ", decoderResult: " + decoderResult() + ')';, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ComposedLastHttpContent.java, + public DecoderResult decoderResult() {, + public DecoderResult getDecoderResult() {, + return decoderResult();, + }, +, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpContent.java, + "(data: " + content() + ", decoderResult: " + decoderResult() + ')';, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpObject.java, + public DecoderResult decoderResult() {, + public
[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +import java.util.concurrent.locks.Lock;, +import java.util.concurrent.locks.ReentrantLock;, + int idx = (int) (tick & mask);, + wheel[idx];, + bucket.lock.lock();, + try {, + transferTimeoutsToBuckets();, + } finally {, + bucket.lock.unlock();, + }, + if (timeout.state() == HashedWheelTimeout.ST_CANCELLED) {, + // Was cancelled in the meantime., +, + private static final int ST_CANCELLED = 1;, + private static final int ST_EXPIRED = 2;, + if (!compareAndSetState(ST_INIT, ST_CANCELLED)) {, + HashedWheelBucket bucket = this.bucket;, + // if tryLock fails it means that HashedWheelBucket is currently processed and so there is nothing for, + // us to do as the remove itself will
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, +import java.util.ConcurrentModificationException;, +import java.util.NoSuchElementException;, + private static final Iterator<ByteBuf> EMPTY_ITERATOR = Collections.<ByteBuf>emptyList().iterator();, + if (components.isEmpty()) {, + return EMPTY_ITERATOR;, + return new CompositeByteBufIterator();, +, + private final class CompositeByteBufIterator implements Iterator<ByteBuf> {, + private final int size = components.size();, + private int index;, +, + @Override, + public boolean hasNext() {, + return size > index;, + }, +, + @Override, + public ByteBuf next() {, + if (size != components.size()) {, + throw new ConcurrentModificationException();, + }, + if (!hasNext()) {, + throw new NoSuchElementException();, + }, + try {, + return components.get(index++).buf;, + } catch
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, +, + if (unsafe != null) {, + // There are assumptions made where ever BYTE_ARRAY_BASE_OFFSET is used (equals, hashCodeAscii, and, + // primitive accessors) that arrayIndexScale == 1, and results are undefined if this is not the case., + long byteArrayIndexScale = unsafe.arrayIndexScale(byte[].class);, + if (byteArrayIndexScale != 1) {, + logger.debug("unsafe.arrayIndexScale is {} (expected: 1). Not using unsafe.", byteArrayIndexScale);, + unsafe = null;, + }, + }]
[+++ b/handler/src/main/java/io/netty/handler/ssl/Conscrypt.java, +import java.lang.reflect.InvocationTargetException;, + private static final Method IS_CONSCRYPT_SSLENGINE = loadIsConscryptEngine();, + private static Method loadIsConscryptEngine() {, + return conscryptClass.getMethod("isConscrypt", SSLEngine.class);, + /**, + * Indicates whether or not conscrypt is available on the current system., + */, + static boolean isAvailable() {, + return IS_CONSCRYPT_SSLENGINE != null && PlatformDependent.javaVersion() >= 8;, + static boolean isEngineSupported(SSLEngine engine) {, + return isAvailable() && isConscryptEngine(engine);, + }, +, + private static boolean isConscryptEngine(SSLEngine engine) {, + try {, + return (Boolean) IS_CONSCRYPT_SSLENGINE.invoke(null, engine);, + } catch (IllegalAccessException ignore) {, + return false;, + } catch (InvocationTargetException ex) {, + throw
[+++ b/transport-native-epoll/pom.xml, + <Automatic-Module-Name>${javaModuleName}</Automatic-Module-Name>, +++ b/transport-native-epoll/pom.xml, + <Automatic-Module-Name>${javaModuleName}</Automatic-Module-Name>, +++ b/transport-native-kqueue/pom.xml, + <Automatic-Module-Name>${javaModuleName}</Automatic-Module-Name>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + * Returns the maximum age of this {@link Cookie} in seconds., + * If {@code -1} is specified, this {@link Cookie} will be removed when the, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + * Returns the maximum age of this {@link Cookie} in seconds., + * If {@code -1} is specified, this {@link Cookie} will be removed when the, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java, + private long maxAge = -1;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + * Returns the maximum age of this {@link Cookie} in seconds., + * If {@code -1} is specified, this {@link Cookie} will be removed when the, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java, + private
[+++ b/pom.xml, + <version>1.6.6</version>, + <version>1.1</version>, + <version>1.8</version>, + <version>2.3.2</version>]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.CONTINUATION_FRAME_HEADER_LENGTH;, +import static io.netty.handler.codec.http2.Http2CodecUtil.DATA_FRAME_HEADER_LENGTH;, +import static io.netty.handler.codec.http2.Http2CodecUtil.GO_AWAY_FRAME_HEADER_LENGTH;, +import static io.netty.handler.codec.http2.Http2CodecUtil.HEADERS_FRAME_HEADER_LENGTH;, +import static io.netty.handler.codec.http2.Http2CodecUtil.PRIORITY_FRAME_LENGTH;, +import static io.netty.handler.codec.http2.Http2CodecUtil.PUSH_PROMISE_FRAME_HEADER_LENGTH;, +import static io.netty.handler.codec.http2.Http2CodecUtil.RST_STREAM_FRAME_LENGTH;, +import static io.netty.handler.codec.http2.Http2CodecUtil.WINDOW_UPDATE_FRAME_LENGTH;, +import static io.netty.handler.codec.http2.Http2CodecUtil.writeFrameHeaderInternal;, +import static io.netty.handler.codec.http2.Http2Exception.connectionError;, +import io.netty.buffer.Unpooled;, +import io.netty.handler.codec.http2.Http2CodecUtil.SimpleChannelPromiseAggregator;, + /**, + * This buffer is allocated to the maximum padding size needed, and filled with padding., + * When padding is needed it can be taken as a slice of this buffer. Users should call {@link ByteBuf#retain()}, + * before using their slice., + */, + private static final ByteBuf ZERO_BUFFER = Unpooled.buffer(MAX_UNSIGNED_BYTE).writeZero(MAX_UNSIGNED_BYTE);, + boolean releaseData = true;, + ByteBuf buf
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, + protected ByteToMessageCodec(Class<? extends I> outboundMessageType) {, + outboundMsgMatcher = TypeParameterMatcher.get(outboundMessageType);, + }, +, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, + protected ByteToMessageCodec(Class<? extends I> outboundMessageType) {, + outboundMsgMatcher = TypeParameterMatcher.get(outboundMessageType);, + }, +, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, + protected MessageToByteEncoder() { }, +, + protected MessageToByteEncoder(Class<? extends I> outboundMessageType) {, + super(outboundMessageType);, + }, +, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, + protected ByteToMessageCodec(Class<? extends I> outboundMessageType) {, + outboundMsgMatcher = TypeParameterMatcher.get(outboundMessageType);, + }, +, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, + protected MessageToByteEncoder() { }, +, + protected MessageToByteEncoder(Class<? extends I> outboundMessageType) {, + super(outboundMessageType);, + }, +, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java, + protected MessageToMessageCodec(, + Class<? extends INBOUND_IN> inboundMessageType, Class<?
[+++ b/all/pom.xml]
[+++ b/all/lib/apiviz-1.3.1-jdk7.jar, +++ b/all/lib/apiviz-1.3.1-jdk7.jar, +++ b/all/pom.xml, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <!-- Add optional dependencies explicitly to avoid Javadoc warnings and errors. -->, + <dependency>, + <groupId>com.google.protobuf</groupId>, + <artifactId>protobuf-java</artifactId>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>org.jboss.marshalling</groupId>, + <artifactId>jboss-marshalling</artifactId>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>org.slf4j</groupId>, + <artifactId>slf4j-api</artifactId>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>commons-logging</groupId>, + <artifactId>commons-logging</artifactId>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>org.jboss.logging</groupId>, + <artifactId>jboss-logging-spi</artifactId>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>log4j</groupId>, + <artifactId>log4j</artifactId>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>,
[+++ b/transport/src/main/java/io/netty/channel/ChannelInboundHandler.java, + * Return the {@link Buf} which will be used for inbound data for the given {@link ChannelHandlerContext}.]
[+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpServerChannel.java, + private static final ChannelMetadata METADATA = new ChannelMetadata(false, 1);, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/oio/OioSctpServerChannel.java, + private static final ChannelMetadata METADATA = new ChannelMetadata(false, 1);, +++ b/transport/src/main/java/io/netty/channel/socket/oio/OioServerSocketChannel.java, + private static final ChannelMetadata METADATA = new ChannelMetadata(false, 1);]
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, + "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",, + "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",, + "TLS_RSA_WITH_AES_256_CBC_SHA");, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, + "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",, + "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",, + "TLS_RSA_WITH_AES_256_CBC_SHA");, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, + "ECDHE-ECDSA-AES256-GCM-SHA384",, + "ECDHE-ECDSA-AES128-GCM-SHA256",, + "AES256-SHA");]
[+++ b/example/pom.xml, + <dependency>, + <groupId>ch.qos.logback</groupId>, + <artifactId>logback-classic</artifactId>, + <scope>runtime</scope>, + </dependency>, +++ b/example/pom.xml, + <dependency>, + <groupId>ch.qos.logback</groupId>, + <artifactId>logback-classic</artifactId>, + <scope>runtime</scope>, + </dependency>, +++ b/example/src/main/resources/logback.xml, +<configuration debug="false">, + <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">, + <encoder>, + <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>, + </encoder>, + </appender>, +, + <root level="${logLevel:-info}">, + <appender-ref ref="STDOUT" />, + </root>, +</configuration>, +++ b/example/pom.xml, + <dependency>, + <groupId>ch.qos.logback</groupId>, + <artifactId>logback-classic</artifactId>, + <scope>runtime</scope>, + </dependency>, +++ b/example/src/main/resources/logback.xml, +<configuration debug="false">, + <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">, + <encoder>, + <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>, + </encoder>, + </appender>, +, + <root level="${logLevel:-info}">, + <appender-ref ref="STDOUT" />, + </root>,
[+++ b/example/src/main/java/io/netty/example/securechat/SecureChatServerHandler.java, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelFutureListener;, + public void channelActive(final ChannelHandlerContext ctx) throws Exception {, + // Once session is secured, send a greeting and register the channel to the global channel, + // list so the channel received the messages from others., + ctx.pipeline().get(SslHandler.class).handshake().addListener(new ChannelFutureListener() {, + @Override, + public void operationComplete(ChannelFuture future) throws Exception {, + });, + }]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +import io.netty.buffer.Unpooled;, +import io.netty.util.ReferenceCountUtil;, + connection.remote().flowController(new DefaultHttp2RemoteFlowController(connection));, + final Http2Stream stream;, + flowController().sendFlowControlled(ctx, stream,, + new FlowControlledData(ctx, stream, data, padding, endOfStream, promise));, + return promise;, + Http2Stream stream = connection.stream(streamId);, + stream = connection.createLocalStream(streamId);, + } else if (stream.isResetSent()) {, + } else if (stream.isEndOfStreamSent()) {, + // Pass headers to the flow-controller so it can maintain their sequence relative to DATA frames., + flowController().sendFlowControlled(ctx, stream,, + new FlowControlledHeaders(ctx, stream, headers, streamDependency, weight,, + exclusive, padding, endOfStream, promise));, + if (endOfStream) {, + // Flag delivery of EOS synchronously to prevent subsequent frames being enqueued in the
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + throw new IllegalArgumentException("srcs is null");, + throw new IllegalArgumentException("dst is null");, + if (src == null) {, + throw new IllegalArgumentException("srcs[" + i + "] is null");, + }, + throw new IllegalArgumentException("dsts is null");, + throw new IllegalArgumentException("dsts[" + i + "] is null");, + throw new IllegalArgumentException("srcs[" + i + "] is null");]
[+++ /dev/null, +++ /dev/null, +++ b/all/pom.xml, + <id>clean-first</id>, + <outputDirectory>${project.build.directory}/src</outputDirectory>, + <plugin>, + <groupId>org.codehaus.mojo</groupId>, + <artifactId>build-helper-maven-plugin</artifactId>, + <version>1.7</version>, + <executions>, + <execution>, + <id>add-source</id>, + <phase>generate-sources</phase>, + <goals>, + <goal>add-source</goal>, + </goals>, + <configuration>, + <sources>, + <source>target/src</source>, + </sources>, + </configuration>, + </execution>, + </executions>, + </plugin>, + <detectJavaApiLink>false</detectJavaApiLink>]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java, + out.writeByte(chunkLength >>> 16 & 0xff);, +++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java, + out.writeByte(chunkLength >>> 16 & 0xff);, +++ b/codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedEncoderTest.java, + -0x80, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,, + 0x01, 0x09, 0x00, 0x00, 0x2d, -0x5a, -0x7e, -0x5e, 'n', 'e', 't', 't', 'y', + -0x80, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,, + 0x00, 0x0E, 0x00, 0x00, 0x7b, 0x1f, 0x65, 0x64,, + -0x80, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,, + 0x01, 0x09, 0x00, 0x00, 0x2d, -0x5a, -0x7e, -0x5e, 'n', 'e', 't', 't', 'y',, + 0x01, 0x09, 0x00, 0x00, 0x2d, -0x5a, -0x7e, -0x5e, 'n', 'e',
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + ctx.nextInboundByteBuffer().writeBytes(in);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + ctx.nextInboundByteBuffer().writeBytes(in);, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, + * <p>, + * Be cautious with caching {@link #inboundByteBuffer()} as it may change as a result of this, + * method. For example, instead of extending {@link io.netty.handler.codec.ByteToMessageDecoder},, + * extend what that class does (currently, {@link ChannelInboundHandlerAdapter} and, + * {@link ChannelInboundByteHandler}. In other words, implementing your own, + * {@link ChannelInboundHandlerAdapter#inboundBufferUpdated(ChannelHandlerContext)}/{@link ChannelStateHandler#inboundBufferUpdated(ChannelHandlerContext)}, + * will help guarantee a replaced buffer won't be missed.</p>, + * <p>, + * Be cautious with caching {@link #inboundMessageBuffer()} as it may change as a result of this, + *
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + byte[] bytes = seq.toString().getBytes(CharsetUtil.US_ASCII);, + buf.writeBytes(bytes);, + return bytes.length;, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + byte[] bytes = seq.toString().getBytes(CharsetUtil.US_ASCII);, + buf.writeBytes(bytes);, + return bytes.length;, +++ b/buffer/src/test/java/io/netty/buffer/ByteBufUtilTest.java, + public void testWriteUsAsciiSwapped() {, + String usAscii = "NettyRocks";, + ByteBuf buf = Unpooled.buffer(16);, + buf.writeBytes(usAscii.getBytes(CharsetUtil.US_ASCII));, + SwappedByteBuf buf2 = new SwappedByteBuf(Unpooled.buffer(16));, + ByteBufUtil.writeAscii(buf2, usAscii);, +, + assertEquals(buf, buf2);, +, + buf.release();, + buf2.release();, + }, +, + @Test]
[+++ b/transport/src/main/java/io/netty/channel/ChannelTaskScheduler.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/all/pom.xml, + <artifactId>netty-codec-dns</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-codec-haproxy</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-codec-memcache</artifactId>, + <artifactId>netty-codec-socks</artifactId>, +++ b/all/pom.xml, + <artifactId>netty-codec-dns</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-codec-haproxy</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-codec-memcache</artifactId>, + <artifactId>netty-codec-socks</artifactId>, +++ b/codec-haproxy/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<!--, + ~ Copyright 2012 The Netty Project, + ~, + ~ The Netty Project licenses this file to you under the Apache License,, + ~
[+++ b/src/docbook/module/preface.xml, + high-scalability protocol servers and clients. Netty is a NIO client, + server framework which enables quick and easy development of network, + applications such as protocol servers and clients. -- it's often called]
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerInvoker.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerInvoker.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerInvokerUtil.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerInvoker.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerInvokerUtil.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + ChannelHandlerInvoker invoker = next.invoker();, + invoker.invokeWrite(next, msg, promise);, + invoker.invokeFlush(next);, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerInvoker.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerInvokerUtil.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + ChannelHandlerInvoker invoker = next.invoker();, + invoker.invokeWrite(next, msg, promise);, + invoker.invokeFlush(next);, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerInvoker.java, + safeExecuteOutbound(WriteTask.newInstance(ctx, msg, size, promise), promise, msg);, + static final class WriteTask extends OneTimeTask implements SingleThreadEventLoop.NonWakeupRunnable {, + private static WriteTask newInstance(, + ChannelHandlerContext ctx, Object msg, int size, ChannelPromise promise) {, + task.ctx = ctx;, + task.msg = msg;, + task.promise = promise;, + task.size = size;, + private final Recycler.Handle<WriteTask> handle;, +, + this.handle =
[+++ b/all/pom.xml, + <version>4.1.23.Final</version>, +++ b/all/pom.xml, + <version>4.1.23.Final</version>, +++ b/bom/pom.xml, + <version>4.1.23.Final</version>, + <tag>netty-4.1.23.Final</tag>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, +++ b/all/pom.xml, + <version>4.1.23.Final</version>, +++ b/bom/pom.xml, + <version>4.1.23.Final</version>, + <tag>netty-4.1.23.Final</tag>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, + <version>4.1.23.Final</version>, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + pendingUnencryptedWrites.addFirst(buf, promise);, + // When we add the buffer/promise pair back we need to be sure we don't complete the promise, + // later in finishWrap. We only complete the promise if the buffer is completely consumed., + promise = null;, + releaseAndFailAll(cause);, + }, + }, +, + private void releaseAndFailAll(Throwable cause) {, + try {, + } finally {, + releaseAndFailAll(HANDSHAKE_TIMED_OUT);, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + pendingUnencryptedWrites.addFirst(buf, promise);, + // When we add the buffer/promise pair back we need to be sure we don't complete the promise, + // later in finishWrap. We only
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerSocketChannel.java, + if (!config.isAutoRead() && !readPending) {, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerSocketChannel.java, + if (!config.isAutoRead() && !readPending) {, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, + if (!config.isAutoRead() && !readPending) {, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerSocketChannel.java, + if (!config.isAutoRead() && !readPending) {, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, + if (!config.isAutoRead() && !readPending) {, +++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java, + if (!config.isAutoRead() && !readPending) {, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerSocketChannel.java, + if (!config.isAutoRead() && !readPending) {, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, + if (!config.isAutoRead() && !readPending) {, +++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java, + if (!config.isAutoRead() && !readPending) {, +++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioMessageChannel.java, + if (!config.isAutoRead() && !readPending) {]
[+++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, + *, + * @deprecated this transport will be removed in the next major version., +@Deprecated, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, + *, + * @deprecated this transport will be removed in the next major version., +@Deprecated, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannel.java, + *, + * @deprecated this transport will be removed in the next major version., +@Deprecated, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, + *, + * @deprecated this transport will be removed in the next major version., +@Deprecated, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannel.java, + *, + * @deprecated this transport will be removed in the next major version., +@Deprecated, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java, + *, + * @deprecated this transport
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * while (buffer.isReadable()) {]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return new DuplicatedAbstractByteBuf(this);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return new DuplicatedAbstractByteBuf(this);, +++ b/buffer/src/main/java/io/netty/buffer/DuplicatedAbstractByteBuf.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS"
[+++ b/all/pom.xml, + <version>4.1.26.Final</version>, +++ b/all/pom.xml, + <version>4.1.26.Final</version>, +++ b/bom/pom.xml, + <version>4.1.26.Final</version>, + <tag>netty-4.1.26.Final</tag>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, +++ b/all/pom.xml, + <version>4.1.26.Final</version>, +++ b/bom/pom.xml, + <version>4.1.26.Final</version>, + <tag>netty-4.1.26.Final</tag>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, + <version>4.1.26.Final</version>, +
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/ZlibCodecFactory.java, + private static final int DEFAULT_JDK_WINDOW_SIZE = 15;, + private static final int DEFAULT_JDK_MEM_LEVEL = 8;, +, + private static final boolean noJdkZlibEncoder;, +, + noJdkZlibEncoder = SystemPropertyUtil.getBoolean("io.netty.noJdkZlibEncoder", false);, + logger.debug("-Dio.netty.noJdkZlibEncoder: {}", noJdkZlibEncoder);, + if (PlatformDependent.javaVersion() < 7 || noJdkZlibEncoder) {, + if (PlatformDependent.javaVersion() < 7 || noJdkZlibEncoder) {, + if (PlatformDependent.javaVersion() < 7 || noJdkZlibEncoder) {, + if (PlatformDependent.javaVersion() < 7 || noJdkZlibEncoder ||, + windowBits != DEFAULT_JDK_WINDOW_SIZE || memLevel != DEFAULT_JDK_MEM_LEVEL) {, + if (PlatformDependent.javaVersion() < 7 || noJdkZlibEncoder) {, + if (PlatformDependent.javaVersion() < 7 || noJdkZlibEncoder) {, + if (PlatformDependent.javaVersion() < 7 ||, +
[+++ b/all/pom.xml, + <version>4.1.14.Final</version>, +++ b/all/pom.xml, + <version>4.1.14.Final</version>, +++ b/bom/pom.xml, + <version>4.1.14.Final</version>, + <tag>netty-4.1.14.Final</tag>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, +++ b/all/pom.xml, + <version>4.1.14.Final</version>, +++ b/bom/pom.xml, + <version>4.1.14.Final</version>, + <tag>netty-4.1.14.Final</tag>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, + <version>4.1.14.Final</version>, +
[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultThreadFactory.java, + protected final ThreadGroup threadGroup;]
[+++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, +import java.nio.ByteBuffer;, +import java.util.ArrayDeque;, +import java.util.Deque;, +, + // Use as cache for ByteBuffer created from the memory. These are just duplicates and so are only a container, + // around the memory itself. These are often needed for operations within the Pooled*DirectByteBuf and so, + // may produce extra GC, which can be greatly reduced by caching the duplicates., + //, + // This may be null if the PoolChunk is unpooled as pooling the ByteBuffer instances does not make any sense here., + private final Deque<ByteBuffer> cachedNioBuffers;, +, + cachedNioBuffers = new ArrayDeque<ByteBuffer>();, + cachedNioBuffers
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + private boolean headerSent;, + public boolean isHeaderSent() {, + return headerSent;, + }, +, + @Override, + public Http2Stream headerSent() {, + headerSent = true;, + return this;, + }, +, + @Override, + if (!createdBy().canOpenStream()) {, + throw connectionError(PROTOCOL_ERROR, "Maximum active streams violated for this endpoint.");, + }, + DefaultEndpoint<? extends Http2FlowController> createdBy() {, + DefaultEndpoint<? extends Http2FlowController> createdBy() {, + return null;, + }, +, + @Override, + public boolean isHeaderSent() {, + return false;, + }, +, + @Override, + public Http2Stream headerSent() {, + throw new UnsupportedOperationException();, + }, +, + @Override,
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java, + return new DefaultDnsPtrRecord(name, dnsClass, timeToLive, decodeName0(in.slice(offset, length)));, + name, type, dnsClass, timeToLive, in.retainedSlice(offset, length));, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java, + return new DefaultDnsPtrRecord(name, dnsClass, timeToLive, decodeName0(in.slice(offset, length)));, + name, type, dnsClass, timeToLive, in.retainedSlice(offset, length));, +++ b/codec-dns/src/test/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoderTest.java, +import static org.junit.Assert.assertEquals;, +, + assertEquals(expected, decoder.decodeName0(buffer));, + } finally {, + buffer.release();, + }, + }, +, + @Test, + public void testDecodePtrRecord() throws Exception {, + DefaultDnsRecordDecoder decoder = new DefaultDnsRecordDecoder();, + ByteBuf buffer = Unpooled.buffer().writeByte(0);, + int readerIndex = buffer.readerIndex();, + int writerIndex = buffer.writerIndex();, + try {, + DnsPtrRecord record = (DnsPtrRecord) decoder.decodeRecord(, + "netty.io", DnsRecordType.PTR, DnsRecord.CLASS_IN, 60, buffer,
[+++ b/transport/src/main/java/io/netty/channel/ChannelFutureListener.java, + * A {@link ChannelFutureListener} that forwards the {@link Throwable} of the {@link ChannelFuture} into the, + * {@link ChannelPipeline}. This mimics the old behavior of Netty 3., + */, + ChannelFutureListener FIRE_EXCEPTION_ON_FAILURE = new ChannelFutureListener() {, + @Override, + public void operationComplete(ChannelFuture future) {, + if (!future.isSuccess()) {, + future.channel().pipeline().fireExceptionCaught(future.cause());, + }, + }, + };, +, + /**]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsHandlerTest.java, + assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_HEADERS), is(nullValue()));, + assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_HEADERS), is(nullValue()));, + assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_HEADERS), is(nullValue()));, + assertThat(response1.headers().get(ACCESS_CONTROL_ALLOW_HEADERS), is(nullValue()));, + assertThat(response2.headers().get(ACCESS_CONTROL_ALLOW_HEADERS), is(nullValue()));, + assertThat(response.headers().get(ACCESS_CONTROL_ALLOW_HEADERS), is(nullValue()));]
[+++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, +import io.netty.channel.ChannelHandlerUtil;, + freeOutboundMessage(imsg);, + protected void freeOutboundMessage(I msg) throws Exception {]
[+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java, + String asciiHost = IDN.toASCII(host);, + if (asciiHost.length() > 255) {, + throw new IllegalArgumentException(host + " IDN: " + asciiHost + " exceeds 255 char limit");, + host = asciiHost;, + this.host = host;, + return addressType == SocksAddressType.DOMAIN ? IDN.toUnicode(host) : host;, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequest.java, + String asciiHost = IDN.toASCII(host);, + if (asciiHost.length() > 255) {, + throw new IllegalArgumentException(host + " IDN: " + asciiHost + " exceeds 255 char limit");, + host = asciiHost;, + this.host = host;, + return addressType == SocksAddressType.DOMAIN ? IDN.toUnicode(host) : host;, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponse.java, + String asciiHost = IDN.toASCII(host);,
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + long capacity = 0;, + long len = 0;, + // Number of produced bytes, + if (capacity > 0) {, + // TODO: We may want to consider if we move this check and only do it in a less often called place at, + // the price of not being 100% accurate, like for example when calling SSL.getError(...)., + } else {, + // We read everything return now., + return newResult(bytesConsumed, bytesProduced);, + } else {, + // If the capacity of all destination buffers is 0 we need to trigger a SSL_read
[+++ b/transport/src/main/java/io/netty/channel/ChannelConfig.java, + * @deprecated Auto close will be removed in a future release., + * @deprecated Auto close will be removed in a future release., +++ b/transport/src/main/java/io/netty/channel/ChannelConfig.java, + * @deprecated Auto close will be removed in a future release., + * @deprecated Auto close will be removed in a future release., +++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, + * @deprecated Auto close will be removed in a future release.]
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java, + HttpResponse res = (HttpResponse) ch.readInbound();]
[+++ b/testsuite/pom.xml, + <!-- Required for generating a compressed heap dump file -->, +, + <!-- Testing frameworks and related dependencies -->, + <!-- NOTE: Keep these dependencies in sync with the parent POM's common test dependencies. -->, + <dependency>, + <groupId>junit</groupId>, + <artifactId>junit</artifactId>, + <scope>compile</scope>, + </dependency>, + <dependency>, + <groupId>org.hamcrest</groupId>, + <artifactId>hamcrest-library</artifactId>, + <scope>compile</scope>, + </dependency>, + <dependency>, + <groupId>org.easymock</groupId>, + <artifactId>easymock</artifactId>, + <scope>compile</scope>, + </dependency>, + <dependency>, + <groupId>org.easymock</groupId>, + <artifactId>easymockclassextension</artifactId>, + <scope>compile</scope>, + </dependency>, + <dependency>, + <groupId>org.jmock</groupId>, + <artifactId>jmock-junit4</artifactId>, + <scope>compile</scope>, + </dependency>, + <dependency>, + <groupId>org.mockito</groupId>, + <artifactId>mockito-core</artifactId>, + <scope>compile</scope>, + </dependency>, +
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, + this.ndots = checkPositiveOrZero(ndots, "ndots");, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, + this.ndots = checkPositiveOrZero(ndots, "ndots");, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java, + * The default value is {@code 1}., +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, + this.ndots = checkPositiveOrZero(ndots, "ndots");, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java, + * The default value is {@code 1}., +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java, + if (parent.ndots() == 0) {, + internalResolve(promise);, + } else {, + }, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, + this.ndots = checkPositiveOrZero(ndots, "ndots");, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java, + * The default value is {@code 1}., +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java, + if (parent.ndots() == 0) {, + internalResolve(promise);, + } else {, + }, +++ b/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java, + private DnsNameResolver resolver;, + if (resolver
[+++ b/handler/src/main/java/io/netty/handler/ssl/DefaultOpenSslKeyMaterial.java, +import java.security.cert.X509Certificate;, +, + private final X509Certificate[] x509CertificateChain;, + DefaultOpenSslKeyMaterial(long chain, long privateKey, X509Certificate[] x509CertificateChain) {, + this.x509CertificateChain = x509CertificateChain;, + public X509Certificate[] certificateChain() {, + return x509CertificateChain.clone();, + }, +, + @Override, +++ b/handler/src/main/java/io/netty/handler/ssl/DefaultOpenSslKeyMaterial.java, +import java.security.cert.X509Certificate;, +, + private final X509Certificate[] x509CertificateChain;, + DefaultOpenSslKeyMaterial(long chain, long privateKey, X509Certificate[] x509CertificateChain) {, + this.x509CertificateChain = x509CertificateChain;, + public X509Certificate[] certificateChain() {, + return x509CertificateChain.clone();, + }, +, + @Override, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterial.java, +import java.security.cert.X509Certificate;, +, + * Returns the configured {@link X509Certificate}s., + */, + X509Certificate[] certificateChain();, +, + /**, +++ b/handler/src/main/java/io/netty/handler/ssl/DefaultOpenSslKeyMaterial.java, +import java.security.cert.X509Certificate;, +, + private final X509Certificate[]
[+++ b/common/src/main/java/io/netty/util/internal/ObjectUtil.java, +, + /**, + * Checks that the given argument is strictly positive. If it is, throws {@link IllegalArgumentException}., + * Otherwise, returns the argument., + */, + public static int checkPositive(int i, String name) {, + if (i <= 0) {, + throw new IllegalArgumentException(name + ": " + i + " (expected: > 0)");, + }, + return i;, + }, +, + /**, + * Checks that the given argument is strictly positive. If it is, throws {@link IllegalArgumentException}., + * Otherwise, returns the argument., + */, + public static long checkPositive(long i, String
[+++ b/transport-native-epoll/pom.xml, + <replacement>CFLAGS=-O3 -DIO_NETTY_SENDMMSG_NOT_FOUND -Werror -fno-omit-frame-pointer</replacement>, + <replacement>CFLAGS=-O3 -Werror -fno-omit-frame-pointer</replacement>]
[+++ b/transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpMessageCompletionHandler.java, + ByteBuf frag = fragments.remove(streamIdentifier);, + if (frag == null) {]
[+++ b/.fbprefs, +#FindBugs User Preferences, +#Fri Feb 13 19:51:40 KST 2009, +detectorAppendingToAnObjectOutputStream=AppendingToAnObjectOutputStream|true, +detectorBCPMethodReturnCheck=BCPMethodReturnCheck|false, +detectorBadAppletConstructor=BadAppletConstructor|true, +detectorBadResultSetAccess=BadResultSetAccess|true, +detectorBadSyntaxForRegularExpression=BadSyntaxForRegularExpression|true, +detectorBadUseOfReturnValue=BadUseOfReturnValue|true, +detectorBadlyOverriddenAdapter=BadlyOverriddenAdapter|true, +detectorBooleanReturnNull=BooleanReturnNull|true, +detectorBuildInterproceduralCallGraph=BuildInterproceduralCallGraph|false, +detectorBuildObligationPolicyDatabase=BuildObligationPolicyDatabase|true, +detectorCallToUnsupportedMethod=CallToUnsupportedMethod|true, +detectorCalledMethods=CalledMethods|true, +detectorCheckCalls=CheckCalls|false, +detectorCheckExpectedWarnings=CheckExpectedWarnings|false, +detectorCheckImmutableAnnotation=CheckImmutableAnnotation|true, +detectorCheckTypeQualifiers=CheckTypeQualifiers|true, +detectorCloneIdiom=CloneIdiom|true, +detectorComparatorIdiom=ComparatorIdiom|true, +detectorConfusedInheritance=ConfusedInheritance|true, +detectorConfusionBetweenInheritedAndOuterMethod=ConfusionBetweenInheritedAndOuterMethod|true, +detectorCrossSiteScripting=CrossSiteScripting|true, +detectorDoInsideDoPrivileged=DoInsideDoPrivileged|true, +detectorDontCatchIllegalMonitorStateException=DontCatchIllegalMonitorStateException|true, +detectorDontUseEnum=DontUseEnum|true, +detectorDroppedException=DroppedException|true, +detectorDumbMethodInvocations=DumbMethodInvocations|true, +detectorDumbMethods=DumbMethods|true, +detectorDuplicateBranches=DuplicateBranches|true, +detectorEmptyZipFileEntry=EmptyZipFileEntry|true, +detectorEqStringTest=EqStringTest|false, +detectorEqualsOperandShouldHaveClassCompatibleWithThis=EqualsOperandShouldHaveClassCompatibleWithThis|true, +detectorFieldItemSummary=FieldItemSummary|true, +detectorFinalizerNullsFields=FinalizerNullsFields|true, +detectorFindBadCast=FindBadCast|false, +detectorFindBadCast2=FindBadCast2|true, +detectorFindBadEqualsImplementation=FindBadEqualsImplementation|false, +detectorFindBadForLoop=FindBadForLoop|true, +detectorFindBugsSummaryStats=FindBugsSummaryStats|true, +detectorFindCircularDependencies=FindCircularDependencies|false, +detectorFindDeadLocalStores=FindDeadLocalStores|true, +detectorFindDoubleCheck=FindDoubleCheck|true, +detectorFindEmptySynchronizedBlock=FindEmptySynchronizedBlock|true, +detectorFindFieldSelfAssignment=FindFieldSelfAssignment|true, +detectorFindFinalizeInvocations=FindFinalizeInvocations|true, +detectorFindFloatEquality=FindFloatEquality|true, +detectorFindFloatMath=FindFloatMath|false, +detectorFindHEmismatch=FindHEmismatch|true, +detectorFindInconsistentSync2=FindInconsistentSync2|true, +detectorFindJSR166LockMonitorenter=FindJSR166LockMonitorenter|true, +detectorFindLocalSelfAssignment2=FindLocalSelfAssignment2|true, +detectorFindMaskedFields=FindMaskedFields|true, +detectorFindMismatchedWaitOrNotify=FindMismatchedWaitOrNotify|true, +detectorFindNakedNotify=FindNakedNotify|true, +detectorFindNonSerializableStoreIntoSession=FindNonSerializableStoreIntoSession|true, +detectorFindNonSerializableValuePassedToWriteObject=FindNonSerializableValuePassedToWriteObject|true, +detectorFindNonShortCircuit=FindNonShortCircuit|true, +detectorFindNullDeref=FindNullDeref|true, +detectorFindNullDerefsInvolvingNonShortCircuitEvaluation=FindNullDerefsInvolvingNonShortCircuitEvaluation|true, +detectorFindOpenStream=FindOpenStream|true, +detectorFindPuzzlers=FindPuzzlers|true, +detectorFindRefComparison=FindRefComparison|true, +detectorFindReturnRef=FindReturnRef|true, +detectorFindRunInvocations=FindRunInvocations|true, +detectorFindSelfComparison=FindSelfComparison|true, +detectorFindSelfComparison2=FindSelfComparison2|true, +detectorFindSleepWithLockHeld=FindSleepWithLockHeld|true, +detectorFindSpinLoop=FindSpinLoop|true, +detectorFindSqlInjection=FindSqlInjection|true, +detectorFindTwoLockWait=FindTwoLockWait|true, +detectorFindUncalledPrivateMethods=FindUncalledPrivateMethods|true, +detectorFindUnconditionalWait=FindUnconditionalWait|true, +detectorFindUninitializedGet=FindUninitializedGet|true, +detectorFindUnrelatedTypesInGenericContainer=FindUnrelatedTypesInGenericContainer|true, +detectorFindUnreleasedLock=FindUnreleasedLock|true, +detectorFindUnsatisfiedObligation=FindUnsatisfiedObligation|true, +detectorFindUnsyncGet=FindUnsyncGet|true, +detectorFindUselessControlFlow=FindUselessControlFlow|true, +detectorFormatStringChecker=FormatStringChecker|true, +detectorHugeSharedStringConstants=HugeSharedStringConstants|true, +detectorIDivResultCastToDouble=IDivResultCastToDouble|true, +detectorIncompatMask=IncompatMask|true, +detectorInconsistentAnnotations=InconsistentAnnotations|true, +detectorInefficientMemberAccess=InefficientMemberAccess|true, +detectorInefficientToArray=InefficientToArray|true, +detectorInfiniteLoop=InfiniteLoop|true, +detectorInfiniteRecursiveLoop=InfiniteRecursiveLoop|true, +detectorInfiniteRecursiveLoop2=InfiniteRecursiveLoop2|true, +detectorInheritanceUnsafeGetResource=InheritanceUnsafeGetResource|true,
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + private final int maxCapacity;, + int refCnt = 1;, +, + protected AbstractByteBuf(ByteOrder endianness, int maxCapacity) {, + if (maxCapacity < 0) {, + throw new IllegalArgumentException("maxCapacity: " + maxCapacity + " (expected: >= 0)");, + }, + this.maxCapacity = maxCapacity;, + public int maxCapacity() {, + return maxCapacity;, + }, +, + @Override, + adjustMarkers(readerIndex);, + adjustMarkers(readerIndex);, + protected void adjustMarkers(int decrement) {, + markedReaderIndex = Math.max(markedReaderIndex - decrement, 0);, + markedWriterIndex = Math.max(markedWriterIndex - decrement, 0);, +, + @Override, + public void ensureWritableBytes(int minWritableBytes) {, + if (minWritableBytes <= writableBytes()) {, + return;, +
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +import io.netty.util.internal.PlatformDependent;, +, + * @param preferDirect {@code true} if {@link #buffer(int)} should try to allocate a direct buffer rather than, + * a heap buffer, + protected AbstractByteBufAllocator(boolean preferDirect) {, + directByDefault = preferDirect && PlatformDependent.hasUnsafe();, + public ByteBuf ioBuffer() {, + if (PlatformDependent.hasUnsafe()) {, + return directBuffer(0);, + }, + return heapBuffer(0);, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +import io.netty.util.internal.PlatformDependent;, +, + * @param preferDirect {@code true} if {@link #buffer(int)} should try to allocate a direct buffer rather than, + * a heap buffer, + protected AbstractByteBufAllocator(boolean preferDirect) {, + directByDefault = preferDirect &&
[+++ b/transport/src/main/java/io/netty/channel/socket/oio/AbstractOioByteChannel.java, +/**, + * Abstract base class for OIO which reads and writes bytes from/to a Socket, + */, + /**, + * @see AbstractOioByteChannel#AbstractOioByteChannel(Channel, Integer), + */, + protected AbstractOioUnsafe newUnsafe() {, + /**, + * Return the number of bytes ready to read from the underlying Socket., + */, +, + /**, + * Read bytes from the underlying Socket., + *, + * @param buf the {@link ByteBuf} into which the read bytes will be written, + * @return amount the number of bytes read. This may return a negative amount if the underlying, +
[+++ b/src/docbook/custom.dtd, +<!-- Types in the buffer package -->, +, +<!ENTITY ChannelBuffer "<ulink url='&API;buffer/ChannelBuffer.html'><interfacename>ChannelBuffer</interfacename></ulink>">, +<!ENTITY ChannelBuffers "<ulink url='&API;buffer/ChannelBuffers.html'><classname>ChannelBuffers</classname></ulink>">, +, +<!ENTITY ChannelFuture "<ulink url='&API;channel/ChannelFuture.html'><interfacename>ChannelFuture</interfacename></ulink>">, +<!ENTITY ChannelFutureListener "<ulink url='&API;channel/ChannelFutureListener.html'><interfacename>ChannelFutureListener</interfacename></ulink>">, +<!ENTITY Channels "<ulink url='&API;channel/Channels.html'><classname>Channels</classname></ulink>">, +<!ENTITY ChannelStateEvent "<ulink url='&API;channel/ChannelStateEvent.html'><interfacename>ChannelStateEvent</interfacename></ulink>">, +++ b/src/docbook/custom.dtd, +<!-- Types in the buffer package -->, +, +<!ENTITY ChannelBuffer "<ulink url='&API;buffer/ChannelBuffer.html'><interfacename>ChannelBuffer</interfacename></ulink>">, +<!ENTITY ChannelBuffers "<ulink url='&API;buffer/ChannelBuffers.html'><classname>ChannelBuffers</classname></ulink>">, +, +<!ENTITY ChannelFuture "<ulink url='&API;channel/ChannelFuture.html'><interfacename>ChannelFuture</interfacename></ulink>">, +<!ENTITY ChannelFutureListener "<ulink url='&API;channel/ChannelFutureListener.html'><interfacename>ChannelFutureListener</interfacename></ulink>">, +<!ENTITY Channels "<ulink url='&API;channel/Channels.html'><classname>Channels</classname></ulink>">, +<!ENTITY ChannelStateEvent "<ulink url='&API;channel/ChannelStateEvent.html'><interfacename>ChannelStateEvent</interfacename></ulink>">, +++ b/src/docbook/master.xml, + <subtitle>The Proven Approach to Rapid Network Application Development</subtitle>, +++ b/src/docbook/custom.dtd, +<!-- Types in the buffer package -->, +, +<!ENTITY ChannelBuffer "<ulink url='&API;buffer/ChannelBuffer.html'><interfacename>ChannelBuffer</interfacename></ulink>">, +<!ENTITY ChannelBuffers "<ulink url='&API;buffer/ChannelBuffers.html'><classname>ChannelBuffers</classname></ulink>">,
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketRstTest.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketUtil.java, + return digest(MD5, data);, + return digest(SHA1, data);, + }, +, + private static byte[] digest(FastThreadLocal<MessageDigest> digestFastThreadLocal, byte[] data) {, + MessageDigest digest = digestFastThreadLocal.get();, + digest.reset();, + return digest.digest(data);]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, +++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java, +final class SystemPropertyUtil {, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, +++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java, +final class SystemPropertyUtil {, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, +++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java, +final class SystemPropertyUtil {, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, +++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java, +final class SystemPropertyUtil {, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, +++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java, +final
[+++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, + for (;;) {, + Runnable task = taskQueue.poll();, + if (task == WAKEUP_TASK) {, + continue;, + }, + return task;, + }, + *, + * @return {@code true} if and only if at least one task was run, + Runnable task = pollTask();, + return false;, + for (;;) {, +, + task = pollTask();, + if (task == null) {, + return true;, + }, + }, +, + /**, + * Poll all tasks from the task queue and run them via {@link Runnable#run()} method. This method stops running, + * the
[+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + private ByteBufAllocator allocator;, + allocator = chunk.arena.parent;, + return allocator;, + tmpNioBuf = null;, + chunk = null;]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either
[+++ b/buffer/src/main/java/io/netty/buffer/BufType.java, + * Operates on bytes., +++ b/buffer/src/main/java/io/netty/buffer/BufType.java, + * Operates on bytes., +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + // Note we use an AtomicReferenceFieldUpdater for atomic operations on these to save memory. This will save us]
[+++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, + private ChannelHandlerContext ctx;, + private final ReplayingDecoderBuffer replayable = new ReplayingDecoderBuffer();, + checkpoint = internalBuffer().readerIndex();, + return ctx.inboundByteBuffer();, + public void handlerAdded(ChannelHandlerContext ctx) throws Exception {, + this.ctx = ctx;, + ByteBuf in = internalBuffer();, + replayable.setCumulation(in);, + ByteBuf in = internalBuffer();, + replayable.setCumulation(in);, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, + private ChannelHandlerContext ctx;, + private final ReplayingDecoderBuffer replayable = new ReplayingDecoderBuffer();, + checkpoint = internalBuffer().readerIndex();, + return ctx.inboundByteBuffer();, + public void handlerAdded(ChannelHandlerContext ctx) throws Exception {, + this.ctx = ctx;, + ByteBuf in = internalBuffer();, + replayable.setCumulation(in);, + ByteBuf in = internalBuffer();, + replayable.setCumulation(in);, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoderBuffer.java, + private ByteBuf
[+++ b/common/pom.xml, + <groupId>org.osgi</groupId>, + <groupId>org.osgi</groupId>, +++ b/common/pom.xml, + <groupId>org.osgi</groupId>, + <groupId>org.osgi</groupId>, +++ b/pom.xml, + <groupId>org.osgi</groupId>, + <version>4.3.0</version>, + <groupId>org.osgi</groupId>, + <version>4.3.0</version>, + <version>1.6.5</version>, + <version>1.2.17</version>, + <version>2.5.1</version>, + <version>2.9.1</version>, + <execute>, + <runOnIncremental>false</runOnIncremental>, + </execute>, + </action>, + </pluginExecution>, + <pluginExecution>, + <pluginExecutionFilter>, + <groupId>org.apache.maven.plugins</groupId>, + <artifactId>maven-enforcer-plugin</artifactId>, + <versionRange>[1.0,)</versionRange>, + <goals>, + <goal>enforce</goal>, + </goals>, + </pluginExecutionFilter>, + <action>, + <execute>, + <runOnIncremental>false</runOnIncremental>, + </execute>]
[+++ b/pom.xml, + <version>1.1.33.Fork6</version>]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, +, + @Override, + public void setSessionCacheEnabled(boolean enabled) {, + // ignored, + }, +, + @Override, + public boolean isSessionCacheEnabled() {, + return false;, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, +, + @Override, + public void setSessionCacheEnabled(boolean enabled) {, + // ignored, + }, +, + @Override, + public boolean isSessionCacheEnabled() {, + return false;, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java, +, + @Override, + public void setSessionCacheEnabled(boolean enabled) {, + long mode = enabled ? SSL.SSL_SESS_CACHE_SERVER : SSL.SSL_SESS_CACHE_OFF;, + SSLContext.setSessionCacheMode(context, mode);, + }, +, + @Override, + public boolean isSessionCacheEnabled() {, + return SSLContext.getSessionCacheMode(context) == SSL.SSL_SESS_CACHE_SERVER;, + }, +++
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + decoder.writeInbound(in.retain());, + ByteBuf buf = (ByteBuf) decoder.readInbound();]
[+++ b/example/pom.xml]
[+++ b/pom.xml, + , + <profiles>, + <profile>, + <id>unix</id>, + <activation>, + <os>, + <family>unix</family>, + </os>, + </activation>, + <properties>, + <!--, + Note: Java SCTP only available for Linux and Solaris, + -->, + <sctp.test.skip>false</sctp.test.skip>, + </properties>, + </profile>, + , + <profile>, + <id>default</id>, + <activation>, + <activeByDefault>true</activeByDefault>, + </activation>, + <properties>, + <sctp.test.skip>true</sctp.test.skip>, + </properties>, + </profile>, + </profiles>, +++ b/pom.xml, + , + <profiles>, + <profile>, + <id>unix</id>, + <activation>, + <os>, + <family>unix</family>, + </os>, + </activation>, + <properties>, + <!--, + Note: Java SCTP only available for Linux and Solaris, +
[+++ b/all/pom.xml, + <version>4.0.7.Final</version>, +++ b/all/pom.xml, + <version>4.0.7.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.7.Final</version>, +++ b/all/pom.xml, + <version>4.0.7.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.7.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.7.Final</version>, +++ b/all/pom.xml, + <version>4.0.7.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.7.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.7.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.7.Final</version>, +++ b/all/pom.xml, + <version>4.0.7.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.7.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.7.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.7.Final</version>, +++ b/codec/pom.xml, + <version>4.0.7.Final</version>, +++ b/all/pom.xml, + <version>4.0.7.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.7.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.7.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.7.Final</version>, +++ b/codec/pom.xml, + <version>4.0.7.Final</version>, +++ b/common/pom.xml, + <version>4.0.7.Final</version>, +++ b/all/pom.xml, + <version>4.0.7.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.7.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.7.Final</version>, +++ b/codec-socks/pom.xml, +
[+++ b/pom.xml]
[+++ b/all/pom.xml, + <version>4.1.33.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.33.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.33.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.33.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.33.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, + <version>4.1.33.Final-SNAPSHOT</version>, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerUpgradeHandler.java, + * Prepares the {@code upgradeHeaders} for a protocol update based upon the contents of {@code upgradeRequest}., + * This method returns a boolean value to proceed or abort the upgrade in progress. If {@code false} is, + * returned, the upgrade is aborted and the {@code upgradeRequest} will be passed through the inbound pipeline, + * as if no upgrade was performed. If {@code true} is returned, the upgrade will proceed to the next, + * step which invokes {@link #upgradeTo}. When returning {@code true}, you can add headers to, + * the {@code upgradeHeaders} so
[+++ b/pom.xml, + <Import-Package>sun.misc.*;resolution:=optional,sun.nio.ch;resolution:=optional,sun.security.*;resolution:=optional,org.eclipse.jetty.npn;version="[1,2)";resolution=optional,org.eclipse.jetty.alpn;version="[1,2)";resolution=optional,*</Import-Package>]
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, + * public class DataServerHandler extends {@link SimpleChannelInboundHandler}&lt;Message&gt; {, + * public class DataServerHandler extends {@link SimpleChannelInboundHandler}&lt;Message&gt; {, +++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, + * public class DataServerHandler extends {@link SimpleChannelInboundHandler}&lt;Message&gt; {, + * public class DataServerHandler extends {@link SimpleChannelInboundHandler}&lt;Message&gt; {, +++ b/transport/src/main/java/io/netty/channel/ChannelPropertyAccess.java, + * it for {@link ChannelOutboundInvoker#write(Object, ChannelPromise)} and,, + * {@link ChannelOutboundInvoker#write(MessageList, ChannelPromise)}., +++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, + * public class DataServerHandler extends {@link SimpleChannelInboundHandler}&lt;Message&gt; {, + * public class DataServerHandler extends {@link SimpleChannelInboundHandler}&lt;Message&gt; {, +++ b/transport/src/main/java/io/netty/channel/ChannelPropertyAccess.java, + * it for {@link ChannelOutboundInvoker#write(Object, ChannelPromise)} and,, + * {@link ChannelOutboundInvoker#write(MessageList, ChannelPromise)}., +++ b/transport/src/main/java/io/netty/channel/RecvByteBufAllocator.java, + interface Handle {]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpCodec.java, +, + /**, + * Creates a new instance with the specified decoder options., + */, + public SpdyHttpCodec(SpdyVersion version, int maxContentLength, boolean validateHttpHeaders) {, + super(new SpdyHttpDecoder(version, maxContentLength, validateHttpHeaders), new SpdyHttpEncoder(version));, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpCodec.java, +, + /**, + * Creates a new instance with the specified decoder options., + */, + public SpdyHttpCodec(SpdyVersion version, int maxContentLength, boolean validateHttpHeaders) {, + super(new SpdyHttpDecoder(version, maxContentLength, validateHttpHeaders), new SpdyHttpEncoder(version));, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java, + private final boolean validateHeaders;, + this(version, maxContentLength, new HashMap<Integer, FullHttpMessage>(), true);, + }, +, + /**, + * Creates a new instance., + *,
[+++ b/pom.xml, + <version>2.4.1</version>, + <version>1.6.4</version>, + <version>4.10</version>, + <version>3.1</version>, + <version>3.1</version>, + <version>1.6.4</version>, + <version>1.0.1</version>, + <version>2.5</version>, + <version>2.10</version>, + <version>1.7</version>, + <version>2.8</version>, + <groupId>org.eclipse.wst.css</groupId>, + <artifactId>core</artifactId>, + <version>1.1.101-v200705302225</version>, + <exclusions>, + <exclusion>, + <groupId>org.apache</groupId>, + <artifactId>xerces</artifactId>, + </exclusion>, + <exclusion>, + <groupId>com.ibm</groupId>, + <artifactId>icu</artifactId>, + </exclusion>, + </exclusions>, + </dependency>, + <dependency>, + <groupId>org.eclipse.wst.sse</groupId>, + <artifactId>core</artifactId>, + <version>1.1.202-v200709061102</version>, + <exclusions>, + <exclusion>, + <groupId>org.apache</groupId>, + <artifactId>xerces</artifactId>, + </exclusion>, + <exclusion>, + <groupId>com.ibm</groupId>, + <artifactId>icu</artifactId>, + </exclusion>, + </exclusions>, + </dependency>, + <dependency>, + <version>2.2.1</version>, + <version>2.2.1</version>, +++ b/pom.xml, + <version>2.4.1</version>, + <version>1.6.4</version>, + <version>4.10</version>, + <version>3.1</version>, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackDecoder.java, +import static io.netty.handler.codec.http2.Http2Exception.streamError;, + Http2HeadersSink sink = new Http2HeadersSink(streamId, headers, maxHeaderListSize, validateHeaders);, + decode(in, sink);, + // Now that we've read all of our headers we can perform the validation steps. We must, + // delay throwing until this point to prevent dynamic table corruption., + sink.finish();, + private void decode(ByteBuf in, Sink sink) throws Http2Exception {, + * @deprecated use {@link #setMaxHeaderListSize(long)}; {@code maxHeaderListSizeGoAway} is, + private static HeaderType validate(int streamId, CharSequence name,, + HeaderType previousHeaderType) throws Http2Exception {, + throw streamError(streamId, PROTOCOL_ERROR,, + "Pseudo-header field '%s' found after regular header.", name);, + throw streamError(streamId, PROTOCOL_ERROR,
[+++ b/pom.xml, + <jetty.alpn.version>8.1.5.v20150921</jetty.alpn.version>, + <id>alpn-8u60</id>, + <activation>, + <property>, + <name>java.version</name>, + <value>1.8.0_60</value>, + </property>, + </activation>, + <properties>, + <jetty.alpn.version>8.1.5.v20150921</jetty.alpn.version>, + </properties>, + </profile>, + <profile>]
[+++ b/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +import static org.junit.Assert.*;, +, + @Test, + public void sliceEmptyNotLeak() {, + ByteBuf buffer = Unpooled.buffer(8).retain();, + assertEquals(2, buffer.refCnt());, +, + ByteBuf slice1 = buffer.slice();, + assertEquals(2, slice1.refCnt());, +, + ByteBuf slice2 = slice1.slice();, + assertEquals(2, slice2.refCnt());, +, + assertFalse(slice2.release());, + assertEquals(1, buffer.refCnt());, + assertEquals(1, slice1.refCnt());, + assertEquals(1, slice2.refCnt());, +, + assertTrue(slice2.release());, +, + assertEquals(0, buffer.refCnt());, + assertEquals(0, slice1.refCnt());, + assertEquals(0, slice2.refCnt());, + }]
[+++ b/src/docbook/en-US/module/start.xml, + time.writeInt((int) (System.currentTimeMillis() / 1000));, +++ b/src/docbook/en-US/module/start.xml, + time.writeInt((int) (System.currentTimeMillis() / 1000));, +++ b/src/main/java/org/jboss/netty/buffer/ChannelBuffers.java, + short va = bufferA.getUnsignedByte(aIndex);, + short vb = bufferB.getUnsignedByte(bIndex);, +++ b/src/docbook/en-US/module/start.xml, + time.writeInt((int) (System.currentTimeMillis() / 1000));, +++ b/src/main/java/org/jboss/netty/buffer/ChannelBuffers.java, + short va = bufferA.getUnsignedByte(aIndex);, + short vb = bufferB.getUnsignedByte(bIndex);, +++ b/src/main/java/org/jboss/netty/channel/AbstractChannel.java, + // Deallocate the current channel's ID from allChannels so that other, + // new channels can use it., + allChannels.remove(id);, +, +++ b/src/docbook/en-US/module/start.xml, + time.writeInt((int) (System.currentTimeMillis() / 1000));, +++ b/src/main/java/org/jboss/netty/buffer/ChannelBuffers.java, + short va = bufferA.getUnsignedByte(aIndex);, + short vb = bufferB.getUnsignedByte(bIndex);, +++ b/src/main/java/org/jboss/netty/channel/AbstractChannel.java, + // Deallocate the current channel's ID from allChannels
[+++ b/common/src/main/java/io/netty/util/internal/NonReentrantLock.java, +++ b/common/src/main/java/io/netty/util/internal/NonReentrantLock.java, +++ b/pom.xml, + <version>1.6.6</version>, + <version>1.1</version>, + <version>1.8</version>, + <version>2.3.2</version>]
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java]
[+++ b/common/src/main/java/io/netty/util/Mapping.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/microbench/src/main/java/io/netty/microbench/channel/DefaultChannelPipelineBenchmark.java, +/*, + * Copyright 2019 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + int markedReaderIndex = this.markedReaderIndex;, + if (markedReaderIndex <= decrement) {, + this.markedReaderIndex = 0;, + int markedWriterIndex = this.markedWriterIndex;, + if (markedWriterIndex <= decrement) {, + this.markedWriterIndex = 0;, + } else {, + this.markedWriterIndex = markedWriterIndex - decrement;, + }, + } else {, + this.markedReaderIndex = markedReaderIndex - decrement;, + markedWriterIndex -= decrement;, + }]
[+++ b/src/main/java/org/jboss/netty/channel/Channels.java, + return new DownstreamMessageEvent(channel, future, message, remoteAddress);, + new UpstreamChannelStateEvent(, + channel, ChannelState.OPEN, Boolean.TRUE));, + ctx.sendUpstream(new UpstreamChannelStateEvent(, + ctx.getChannel(), ChannelState.OPEN, Boolean.TRUE));, + new UpstreamChannelStateEvent(, + channel, ChannelState.BOUND, localAddress));, + ctx.sendUpstream(new UpstreamChannelStateEvent(, + ctx.getChannel(), ChannelState.BOUND, localAddress));, + new UpstreamChannelStateEvent(, + channel, ChannelState.CONNECTED, remoteAddress));, + ctx.sendUpstream(new UpstreamChannelStateEvent(, + ctx.getChannel(), ChannelState.CONNECTED, remoteAddress));, + new UpstreamMessageEvent(channel, message, remoteAddress));, + ctx.sendUpstream(new UpstreamMessageEvent(ctx.getChannel(), message, null));, + ctx.sendUpstream(new UpstreamMessageEvent(, + ctx.getChannel(), message, remoteAddress));, + new DefaultWriteCompletionEvent(channel, amount));, + ctx.sendUpstream(new DefaultWriteCompletionEvent(ctx.getChannel(), amount));, + new UpstreamChannelStateEvent(, + channel, ChannelState.INTEREST_OPS, Channel.OP_READ));, + new UpstreamChannelStateEvent(, + ctx.getChannel(), ChannelState.INTEREST_OPS, Channel.OP_READ));, + new UpstreamChannelStateEvent(, + channel, ChannelState.CONNECTED, null));, + ctx.sendUpstream(new
[+++ b/src/docbook/en-US/module/architecture.xml, + to represent a sequence of bytes. This approach has significant advantages, + &ChannelBuffer; has been designed from the ground up to address the problems, + You can define your own buffer type if necessary., + Transparent zero copy is achieved by a built-in composite buffer type., + Traditional I/O APIs in Java provide different types and methods for, + another tedious and difficult. The lack of portability between, + transports becomes a problem when you need to support additional, + transports, as this often entails rewriting the network layer of the, + application. Logically, many protocols
[+++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +import io.netty.channel.ChannelFutureListener;, +import io.netty.channel.ChannelPromise;, + private ChannelFuture doBind(final SocketAddress localAddress) {, + final ChannelFuture regPromise = initAndRegister();, + final Channel channel = regPromise.channel();, + final ChannelPromise promise = channel.newPromise();, + if (regPromise.isDone()) {, + doBind0(regPromise, channel, localAddress, promise);, + } else {, + regPromise.addListener(new ChannelFutureListener() {, + @Override, + public void operationComplete(ChannelFuture future) throws Exception {, + doBind0(future, channel, localAddress, promise);, + }, + });, + }, +, + return promise;, + }, +, + final ChannelFuture initAndRegister() {, + final Channel channel = channelFactory().newChannel();, + try {, + init(channel);, + } catch (Throwable t) {, +
[+++ b/pom.xml, + <Import-Package>sun.misc.*;resolution:=optional,sun.nio.ch;resolution:=optional,*</Import-Package>]
[+++ b/codec-http/pom.xml, + <dependency>, + <groupId>com.jcraft</groupId>, + <artifactId>jzlib</artifactId>, + <optional>true</optional>, + </dependency>, +++ b/codec-http/pom.xml, + <dependency>, + <groupId>com.jcraft</groupId>, + <artifactId>jzlib</artifactId>, + <optional>true</optional>, + </dependency>, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockJZlibCompressor.java, +, +import com.jcraft.jzlib.Deflater;, +import com.jcraft.jzlib.JZlib;, + private final Deflater z = new Deflater();, +++ b/codec-http/pom.xml, + <dependency>, + <groupId>com.jcraft</groupId>, + <artifactId>jzlib</artifactId>, + <optional>true</optional>, + </dependency>, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockJZlibCompressor.java, +, +import com.jcraft.jzlib.Deflater;, +import com.jcraft.jzlib.JZlib;, + private final Deflater z = new Deflater();, +++ b/codec/pom.xml, + <dependency>, + <groupId>com.jcraft</groupId>, + <artifactId>jzlib</artifactId>, + <optional>true</optional>, + </dependency>, +++ b/codec-http/pom.xml, + <dependency>, + <groupId>com.jcraft</groupId>, + <artifactId>jzlib</artifactId>, + <optional>true</optional>, + </dependency>, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockJZlibCompressor.java, +, +import com.jcraft.jzlib.Deflater;, +import com.jcraft.jzlib.JZlib;, + private
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, + String origin = req.headers().get(HttpHeaderNames.ORIGIN);, + if (origin == null) {, + throw new WebSocketHandshakeException("Missing origin header, got only " + req.headers().names());, + }, + res.headers().add(HttpHeaderNames.WEBSOCKET_ORIGIN, origin);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, + String origin = req.headers().get(HttpHeaderNames.ORIGIN);, + if (origin == null) {, + throw new WebSocketHandshakeException("Missing origin header, got only " + req.headers().names());, + }, + res.headers().add(HttpHeaderNames.WEBSOCKET_ORIGIN, origin);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00Test.java, +import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.fail;, + @Test, + public void testPerformHandshakeWithoutOriginHeader() {, + EmbeddedChannel ch = new EmbeddedChannel(, + new HttpObjectAggregator(42), new HttpRequestDecoder(), new HttpResponseEncoder());, +, + FullHttpRequest req = new DefaultFullHttpRequest(, + HTTP_1_1, HttpMethod.GET,
[+++ b/pom.xml, + <argLine>, + -server , + -dsa -da -ea:io.netty..., + -XX:+AggressiveOpts -XX:+UseFastAccessorMethods, + -XX:+OptimizeStringConcat, + -XX:+HeapDumpOnOutOfMemoryError, + </argLine>]
[+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java, +import io.netty.handler.codec.DecoderException;, + // as MQTT 3.1 & 3.1.1 spec, If the User Name Flag is set to 0, the Password Flag MUST be set to 0, + if (!variableHeader.hasUserName() && variableHeader.hasPassword()) {, + throw new DecoderException("Without a username, the password MUST be not set");, + }, +, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java, +import io.netty.handler.codec.DecoderException;, + // as MQTT 3.1 & 3.1.1 spec, If the User Name Flag is set to 0, the Password Flag MUST be set to 0, + if (!variableHeader.hasUserName() && variableHeader.hasPassword()) {, + throw new DecoderException("Without a username, the password MUST be not set");, + },
[+++ b/pom.xml, + <artifactId>maven-deploy-plugin</artifactId>, + <version>2.7</version>, + <configuration>, + <retryFailedDeploymentCount>10</retryFailedDeploymentCount>, + </configuration>, + </plugin>, + <plugin>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameEncoder.java, +import io.netty.buffer.Unpooled;, +import io.netty.handler.codec.MessageToMessageEncoder;, +, +import java.util.List;, +public class WebSocket00FrameEncoder extends MessageToMessageEncoder<WebSocketFrame> implements WebSocketFrameEncoder {, + private static final ByteBuf _0X00 = Unpooled.unreleasableBuffer(, + Unpooled.directBuffer(1, 1).writeByte((byte) 0x00));, + private static final ByteBuf _0XFF = Unpooled.unreleasableBuffer(, + Unpooled.directBuffer(1, 1).writeByte((byte) 0xFF));, + private static final ByteBuf _0XFF_0X00 = Unpooled.unreleasableBuffer(, + Unpooled.directBuffer(2, 2).writeByte((byte) 0xFF).writeByte((byte) 0x00));, + protected void encode(ChannelHandlerContext ctx, WebSocketFrame msg, List<Object> out) throws Exception {, +, + out.add(_0X00.duplicate());, + out.add(data.retain());, + out.add(_0XFF.duplicate());, + out.add(_0XFF_0X00);, + ByteBuf buf = ctx.alloc().buffer(5);, + boolean release = true;, + try {, + buf.writeByte((byte) 0x80);, + buf.writeByte(b4);, + buf.writeByte(b3 | 0x80);, + buf.writeByte(b4);,
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, + @Override, + public final boolean isWriteAllowed() {, + return windowSize() >= 0;, + }, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, + @Override, + public final boolean isWriteAllowed() {, + return windowSize() >= 0;, + }, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/StreamByteDistributor.java, +, + /**, + * Determine if a write operation is allowed for this stream. This will typically take into account the, + * stream's flow controller being non-negative., + * @return {@code true} if a write is allowed on this stream. {@code false} otherwise., + */, + boolean isWriteAllowed();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, + @Override, + public final boolean isWriteAllowed() {, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + return Http2CodecUtil.calculateMaxHeaderListSizeGoAway(maxHeaderListSize);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + return Http2CodecUtil.calculateMaxHeaderListSizeGoAway(maxHeaderListSize);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, + * Calculate the threshold in bytes which should trigger a {@code GO_AWAY} if a set of headers exceeds this amount., + * @param maxHeaderListSize, + * <a href="https://tools.ietf.org/html/rfc7540#section-6.5.2">SETTINGS_MAX_HEADER_LIST_SIZE</a> for the local, + * endpoint., + * @return the threshold in bytes which should trigger a {@code GO_AWAY} if a set of headers exceeds this amount., + */, + public static long calculateMaxHeaderListSizeGoAway(long maxHeaderListSize) {, + // This is equivalent to `maxHeaderListSize * 1.25` but we avoid floating point multiplication., + return maxHeaderListSize + (maxHeaderListSize >>> 2);,
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + final boolean exclusive, final int padding, final boolean endOfStream, ChannelPromise promise) {, + final ChannelFutureListener closeStreamLocalListener = new ChannelFutureListener() {, + lifecycleManager.closeStreamLocal(finalStream, future);, + };, + promise = promise.unvoid().addListener(closeStreamLocalListener);, + return frameWriter.writeHeaders(ctx, streamId, headers, streamDependency, weight,, + exclusive, padding, endOfStream, promise);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + final boolean exclusive, final int padding, final boolean endOfStream, ChannelPromise promise) {, + final ChannelFutureListener closeStreamLocalListener = new ChannelFutureListener() {, + lifecycleManager.closeStreamLocal(finalStream, future);, + };, + promise = promise.unvoid().addListener(closeStreamLocalListener);, + return frameWriter.writeHeaders(ctx, streamId, headers, streamDependency, weight,, + exclusive, padding, endOfStream, promise);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + promise = promise.unvoid();, + ChannelPromise promise) {, +
[+++ b/transport/src/main/java/io/netty/channel/FailedChannelFuture.java, +final class FailedChannelFuture extends CompleteChannelFuture {, +++ b/transport/src/main/java/io/netty/channel/FailedChannelFuture.java, +final class FailedChannelFuture extends CompleteChannelFuture {, +++ b/transport/src/main/java/io/netty/channel/SucceededChannelFuture.java, +final class SucceededChannelFuture extends CompleteChannelFuture {]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, +import io.netty.buffer.DefaultByteBufHolder;, +import io.netty.handler.codec.DecoderResult;, + AggregatedFullHttpMessage ret;, + ret = new AggregatedFullHttpRequest((HttpRequest) start, content, null);, + ret = new AggregatedFullHttpResponse((HttpResponse) start, content, null);, + ((AggregatedFullHttpMessage) aggregated).setTrailingHeaders(((LastHttpContent) content).trailingHeaders());, +, + private abstract static class AggregatedFullHttpMessage extends DefaultByteBufHolder implements FullHttpMessage {, + protected final HttpMessage message;, + private HttpHeaders trailingHeaders;, +, + private AggregatedFullHttpMessage(HttpMessage message, ByteBuf content, HttpHeaders trailingHeaders) {, + super(content);, + this.message = message;, + this.trailingHeaders = trailingHeaders;, + }, + @Override, + public HttpHeaders trailingHeaders() {, + return trailingHeaders;, + }, +, + public void setTrailingHeaders(HttpHeaders trailingHeaders) {, + this.trailingHeaders = trailingHeaders;, + }, +, +
[+++ b/src/docbook/images/architecture.odg, +++ b/src/docbook/images/architecture.odg, +++ b/src/docbook/images/architecture.png, +++ b/src/docbook/images/architecture.odg, +++ b/src/docbook/images/architecture.png, +++ b/src/docbook/module/architecture.xml, + <title>Architectural Overview</title>, + , + <mediaobject>, + <imageobject>, + <imagedata fileref="images/architecture.png" format="PNG"/>, + </imageobject>, + <textobject>, + <phrase>The Architecture Diagram of Netty</phrase>, + </textobject>, + <caption>, + In this chapter, we will examine what core functionalities are provided, + in Netty and how they constitute a complete network application, + development stack on top of the core. Please keep this diagram in mind, + as you read this chapter., + </caption>, + </mediaobject>]
[+++ b/microbench/src/main/java/io/netty/buffer/AbstractByteBufNoCleanerBenchmark.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + private static final Unsafe UNSAFE;, + Throwable cause = ReflectionUtil.trySetAccessible(field);, + if (cause != null) {, + return cause;, + }, + Throwable cause = ReflectionUtil.trySetAccessible(unsafeField);, + if (cause != null) {, + return cause;, + }, + Throwable cause = ReflectionUtil.trySetAccessible(constructor);, + if (cause != null) {, + return cause;, + }, + Throwable cause = ReflectionUtil.trySetAccessible(unalignedMethod);, + if (cause != null) {, + return unalignedMethod.invoke(null);, + } catch (NoSuchMethodException e) {, + return e;, + } catch (SecurityException e) {, + return e;, + } catch (IllegalAccessException e) {, + return e;, + }
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +, +]
[+++ b/common/src/main/java/io/netty/util/internal/Cleaner0.java, +/*, +* Copyright 2014 The Netty Project, +*, +* The Netty Project licenses this file to you under the Apache License,, +* version 2.0 (the "License"); you may not use this file except in compliance, +* with the License. You may obtain a copy of the License at:, +*, +* http://www.apache.org/licenses/LICENSE-2.0, +*, +* Unless required by applicable law or agreed to in writing, software, +* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, +* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, +* License for the specific language governing
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, +import io.netty.channel.ChannelFutureListener;, + future.addListener(new ChannelFutureListener() {, + public void operationComplete(ChannelFuture future) {, + ChannelPipeline p = future.channel().pipeline();, + }, + });, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, +import io.netty.channel.ChannelFutureListener;, + future.addListener(new ChannelFutureListener() {, + public void operationComplete(ChannelFuture future) {, + ChannelPipeline p = future.channel().pipeline();, + }, + });, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java, + future.addListener(new ChannelFutureListener() {, + public void operationComplete(ChannelFuture future) {, + ChannelPipeline p = future.channel().pipeline();, + }, + });, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, +import io.netty.channel.ChannelFutureListener;, + future.addListener(new ChannelFutureListener() {, + public void operationComplete(ChannelFuture future) {, + ChannelPipeline p = future.channel().pipeline();, + }, + });, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java, + future.addListener(new ChannelFutureListener() {, + public void
[+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundHandlerAdapter.java, + /**, + * Calls {@link ChannelHandlerContext#write(MessageList, ChannelPromise)} to forward, + * to the next {@link ChannelOutboundHandler} in the {@link ChannelPipeline}., + *, + * Sub-classes may override this method to change behavior., + */, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundHandlerAdapter.java, + /**, + * Calls {@link ChannelHandlerContext#write(MessageList, ChannelPromise)} to forward, + * to the next {@link ChannelOutboundHandler} in the {@link ChannelPipeline}., + *, + * Sub-classes may override this method to change behavior., + */, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java, + * {@link IncompleteFlushException}., + * {@link ChannelInboundHandler#messageReceived(ChannelHandlerContext, MessageList)} event if data was, + * {@link IncompleteFlushException}., +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundHandlerAdapter.java, + /**, + *
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + /**, + * Called once data should be decoded from the given {@link ByteBuf}. This method will call, + * {@link #decode(ChannelHandlerContext, ByteBuf, List)} as long as decoding should take place., + *, + * @param ctx the {@link ChannelHandlerContext} which this {@link ByteToMessageDecoder} belongs to, + * @param in the {@link ByteBuf} from which to read data, + * @param out the {@link List} to which decoded messages should be added, + */, + protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + /**, + * Called once data should be decoded
[+++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, +++ b/buffer/src/test/java/io/netty/buffer/EmptyByteBufTest.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + final boolean consumeBytes(int streamId, int bytes) throws Http2Exception {, + return connection().local().flowController().consumeBytes(stream, bytes);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + final boolean consumeBytes(int streamId, int bytes) throws Http2Exception {, + return connection().local().flowController().consumeBytes(stream, bytes);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + private boolean parentReadInProgress;, + addChildChannelToReadPendingQueue(childChannel);, + break;, + case READ_IGNORED_CHANNEL_INACTIVE:, + case READ_QUEUED:, + // nothing to do:, + break;, + default:, + throw new Error();, + }, + }, +, + final void addChildChannelToReadPendingQueue(DefaultHttp2StreamChannel childChannel) {, + parentReadInProgress = false;, + @Override, + public final void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {, + parentReadInProgress = true;, + super.channelRead(ctx, msg);, + }, +,
[+++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslTestUtils.java, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslTestUtils.java, +++ b/handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java, + serverSslCtx =, + .sessionTimeout(0).build();, + clientSslCtx =, + .sessionTimeout(0).build();, + serverSslCtx =, + .sessionTimeout(0).build();, + clientSslCtx =, + .sessionTimeout(0).build();, + serverSslCtx =, + .ciphers(ciphers()).build();, + clientSslCtx =, + .protocols(protocols()).ciphers(ciphers()).build();, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslTestUtils.java, +++ b/handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java, + serverSslCtx =, + .sessionTimeout(0).build();, + clientSslCtx =, + .sessionTimeout(0).build();, + serverSslCtx =, + .sessionTimeout(0).build();, + clientSslCtx =, + .sessionTimeout(0).build();, + serverSslCtx =, + .ciphers(ciphers()).build();, + clientSslCtx =, + .protocols(protocols()).ciphers(ciphers()).build();, +++ b/handler/src/test/java/io/netty/handler/ssl/SslErrorTest.java, + final SslContext sslServerCtx =, + }).clientAuth(ClientAuth.REQUIRE).build();, + final SslContext sslClientCtx = SslContextBuilder.forClient(), + .sslProvider(clientProvider).build();]
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java, + assertEquals(chunk1.data().readableBytes() + chunk2.data().readableBytes(),, + HttpHeaders.getContentLength(aggratedMessage));]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, +import io.netty.util.ReferenceCountUtil;, + private static final FullHttpResponse CONTINUE = new DefaultFullHttpResponse(, + HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE, Unpooled.EMPTY_BUFFER);, + private static final FullHttpResponse TOO_LARGE = new DefaultFullHttpResponse(, + HttpVersion.HTTP_1_1, HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE, Unpooled.EMPTY_BUFFER);, + private boolean is100Continue;, + private boolean isKeepAlive;, + * {@link #messageTooLong(io.netty.channel.ChannelHandlerContext, HttpObject)}, + * will be called., + is100Continue = is100ContinueExpected(m);, + isKeepAlive = isKeepAlive(m);, +, + // if content length is set, preemptively close if it's too large, + if (isContentLengthSet(m)) {, + if (getContentLength(m) > maxContentLength) {, + // handle oversized message, + handleMessageTooLong(ctx, m);, + return;, + }, + }, +, + if (is100Continue) {,
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2BlockCompressor.java, +import io.netty.util.ByteProcessor;, + private final ByteProcessor writeProcessor = new ByteProcessor() {, + @Override, + public boolean process(byte value) throws Exception {, + return write(value);, + }, + };, +, + * @param buffer The buffer to write, + int write(final ByteBuf buffer, int offset, int length) {, + int index = buffer.forEachByte(offset, length, writeProcessor);, + return index == -1 ? length : index - offset;, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2BlockCompressor.java, +import io.netty.util.ByteProcessor;, + private final ByteProcessor writeProcessor = new ByteProcessor() {, + @Override, + public boolean process(byte value) throws Exception {, + return write(value);, + }, + };, +, +
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_errnoECONNRESET(JNIEnv* env, jclass clazz) {, + return ECONNRESET;, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_errnoECONNRESET(JNIEnv* env, jclass clazz) {, + return ECONNRESET;, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +jint Java_io_netty_channel_epoll_Native_errnoECONNRESET(JNIEnv* env, jclass clazz);, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_errnoECONNRESET(JNIEnv* env, jclass clazz) {, + return ECONNRESET;, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +jint Java_io_netty_channel_epoll_Native_errnoECONNRESET(JNIEnv* env, jclass clazz);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java, + private static final int ERRNO_ECONNRESET_NEGATIVE = -errnoECONNRESET();, +, + CONNECTION_RESET_EXCEPTION_READ = newConnectionResetException("syscall:read(...)",, + ERRNO_ECONNRESET_NEGATIVE);, + CONNECTION_RESET_EXCEPTION_WRITE = newConnectionResetException("syscall:write(...)",, + ERRNO_EPIPE_NEGATIVE);, + CONNECTION_RESET_EXCEPTION_WRITEV = newConnectionResetException("syscall:writev(...)",, + ERRNO_EPIPE_NEGATIVE);, + CONNECTION_RESET_EXCEPTION_SENDFILE = newConnectionResetException("syscall:sendfile(...)",, + ERRNO_EPIPE_NEGATIVE);, + CONNECTION_RESET_EXCEPTION_SENDTO = newConnectionResetException("syscall:sendto(...)",, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpChunk.java, + buf.append(getDecoderResult());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpChunk.java, + buf.append(getDecoderResult());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpChunkTrailer.java, + buf.append(getDecoderResult());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpChunk.java, + buf.append(getDecoderResult());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpChunkTrailer.java, + buf.append(getDecoderResult());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpObject.java, + public DecoderResult getDecoderResult() {, + public void setDecoderResult(DecoderResult result) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpChunk.java, + buf.append(getDecoderResult());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpChunkTrailer.java, + buf.append(getDecoderResult());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpObject.java, + public DecoderResult getDecoderResult() {, + public void setDecoderResult(DecoderResult result) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpRequest.java, + buf.append(getDecoderResult());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpChunk.java, + buf.append(getDecoderResult());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpChunkTrailer.java, + buf.append(getDecoderResult());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpObject.java, + public DecoderResult getDecoderResult() {, + public void setDecoderResult(DecoderResult result) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpRequest.java, + buf.append(getDecoderResult());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpResponse.java, + buf.append(getDecoderResult());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpChunk.java, + buf.append(getDecoderResult());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpChunkTrailer.java, + buf.append(getDecoderResult());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpObject.java, + public
[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +, + public static final int WORKER_STATE_INIT = 0;, + public static final int WORKER_STATE_STARTED = 1;, + public static final int WORKER_STATE_SHUTDOWN = 2;, + case WORKER_STATE_INIT:, + if (workerState.compareAndSet(WORKER_STATE_INIT, WORKER_STATE_STARTED)) {, + case WORKER_STATE_STARTED:, + case WORKER_STATE_SHUTDOWN:, + throw new Error("Invalid WorkerState");, + if (!workerState.compareAndSet(WORKER_STATE_STARTED, WORKER_STATE_SHUTDOWN)) {, + workerState.set(WORKER_STATE_SHUTDOWN);, + long relativeIndex = (delay + tickDuration - 1) / tickDuration;, + // if the previous line had an overflow going on, then well just schedule this timeout, + // one tick early; that shouldnt matter since were talking 270 years here, + if (relativeIndex <
[+++ b/pom.xml, + <version>false</version>, + <author>false</author>]
[+++ b/pom.xml, + <version>2.2.5</version>]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (readerIndex != writerIndex) {, + } else {, + markedReaderIndex = Math.max(markedReaderIndex - readerIndex, 0);, + markedWriterIndex = Math.max(markedWriterIndex - readerIndex, 0);, + writerIndex = readerIndex = 0;, + }]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + EventExecutor exec = executor();, + if (exec.inEventLoop()) {, + } else {, + try {, + getFromFuture(exec.submit(new Runnable() {, + @Override, + public void run() {, + lazyInitOutboundBuffer();, + }, + }));, + } catch (Exception e) {, + throw new ChannelPipelineException("failed to initialize an outbound buffer lazily", e);, + }, + }, + throw new ChannelPipelineException("failed to replace an inbound byte buffer", ex);, + throw new ChannelPipelineException("failed to replace an inbound message buffer", ex);, + throw new ChannelPipelineException("failed to replace an outbound byte buffer", ex);, + throw new ChannelPipelineException("failed to replace an outbound message buffer", ex);]
[+++ b/handler/src/main/java/io/netty/handler/stream/ChunkedInput.java, + * call must return {@code true}.]
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +jmethodID datagramSocketAddrMethodId = NULL;, +jclass datagramSocketAddressClass = NULL;, +, +jobject createDatagramSocketAddress(JNIEnv * env, struct sockaddr_storage addr, int len) {, + char ipstr[INET6_ADDRSTRLEN];, + int port;, + if (addr.ss_family == AF_INET) {, + struct sockaddr_in *s = (struct sockaddr_in *)&addr;, + port = ntohs(s->sin_port);, + inet_ntop(AF_INET, &s->sin_addr, ipstr, sizeof ipstr);, + } else {, + struct sockaddr_in6 *s = (struct sockaddr_in6 *)&addr;, + port = ntohs(s->sin6_port);, + inet_ntop(AF_INET6, &s->sin6_addr, ipstr, sizeof ipstr);, + }, + jstring ipString = (*env)->NewStringUTF(env, ipstr);, + jobject socketAddr = (*env)->NewObject(env, datagramSocketAddressClass, datagramSocketAddrMethodId, ipString, port, len);, + return socketAddr;, +}, +, +, +void init_in_addr(JNIEnv
[+++ b/common/src/main/java/io/netty/util/AttributeKey.java, + private final String strVal;, + strVal = name + '[' + valueType.getSimpleName() + ']';, + return strVal;]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + if (line.length() == 0 && trailer == null) {, + // We have received the empty line which signals the trailer is complete and did not parse any trailers, + // before. Just return an empty last content to reduce allocations., + return LastHttpContent.EMPTY_LAST_CONTENT;, + }, +, + CharSequence lastHeader = null;, + while (line.length() > 0) {, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + if (line.length() == 0 && trailer == null) {, + // We have received the empty line which signals the trailer is complete and did not parse any trailers, + // before. Just
[+++ b/src/main/java/org/jboss/netty/channel/ChannelLocal.java, +import org.jboss.netty.util.ConcurrentIdentityWeakKeyHashMap;, + new ConcurrentIdentityWeakKeyHashMap<Channel, T>();, +++ b/src/main/java/org/jboss/netty/channel/ChannelLocal.java, +import org.jboss.netty.util.ConcurrentIdentityWeakKeyHashMap;, + new ConcurrentIdentityWeakKeyHashMap<Channel, T>();, +++ b/src/main/java/org/jboss/netty/channel/group/ChannelGroupFactory.java, + // FIXME: Memory leak - use ConcurrentWeakValueHashMap, +++ b/src/main/java/org/jboss/netty/channel/ChannelLocal.java, +import org.jboss.netty.util.ConcurrentIdentityWeakKeyHashMap;, + new ConcurrentIdentityWeakKeyHashMap<Channel, T>();, +++ b/src/main/java/org/jboss/netty/channel/group/ChannelGroupFactory.java, + // FIXME: Memory leak - use ConcurrentWeakValueHashMap, +++ b/src/main/java/org/jboss/netty/channel/local/LocalAddress.java, +import org.jboss.netty.util.ConcurrentHashMap;, + // FIXME: Memory leak - use ConcurrentWeakValueHashMap, + new ConcurrentHashMap<String, LocalAddress>();, +++ b/src/main/java/org/jboss/netty/channel/ChannelLocal.java, +import org.jboss.netty.util.ConcurrentIdentityWeakKeyHashMap;, + new ConcurrentIdentityWeakKeyHashMap<Channel, T>();, +++ b/src/main/java/org/jboss/netty/channel/group/ChannelGroupFactory.java, + // FIXME: Memory leak - use ConcurrentWeakValueHashMap, +++ b/src/main/java/org/jboss/netty/channel/local/LocalAddress.java, +import org.jboss.netty.util.ConcurrentHashMap;, + // FIXME: Memory leak - use ConcurrentWeakValueHashMap, + new ConcurrentHashMap<String, LocalAddress>();, +++ b/src/main/java/org/jboss/netty/handler/execution/DefaultObjectSizeEstimator.java, +import org.jboss.netty.util.ConcurrentIdentityWeakKeyHashMap;, +
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +import java.net.InetAddress;, + NetworkInterface iface = NetworkInterface.getByInetAddress(InetAddress.getLoopbackAddress());, +, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +import java.net.InetAddress;, + NetworkInterface iface = NetworkInterface.getByInetAddress(InetAddress.getLoopbackAddress());, +, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/nio/oio/NioOioDatagramMulticastTest.java, + return new NioDatagramChannelFactory(executor);, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +import java.net.InetAddress;, + NetworkInterface iface = NetworkInterface.getByInetAddress(InetAddress.getLoopbackAddress());, +, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/nio/oio/NioOioDatagramMulticastTest.java, + return new NioDatagramChannelFactory(executor);, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Exception e) {, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +import java.net.InetAddress;, + NetworkInterface iface = NetworkInterface.getByInetAddress(InetAddress.getLoopbackAddress());, +, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/nio/oio/NioOioDatagramMulticastTest.java, + return new NioDatagramChannelFactory(executor);, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Exception e) {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +import java.io.IOException;, +import java.net.InetSocketAddress;, +import java.net.SocketAddress;, +import java.nio.channels.NotYetConnectedException;, +import java.nio.channels.SelectionKey;, +, + EventLoop eventLoop();, +, +, + ChannelFuture deregister();, + void deregister(ChannelFuture future);,
[+++ b/pom.xml, + <id>npn-alpn-7</id>, + <activation>, + <property>, + <name>java.version</name>, + <value>1.7</value>, + </property>, + </activation>, + <properties>, + <jetty.npn.version>${jetty.npn.version.latest}</jetty.npn.version>, + <jetty.alpn.version>${jetty.alpn.version.latest7}</jetty.alpn.version>, + </properties>, + </profile>, + <profile>, + <id>alpn-8</id>, + <activation>, + <property>, + <name>java.version</name>, + <value>1.8</value>, + </property>, + </activation>, + <properties>, + <jetty.alpn.version>${jetty.alpn.version.latest8}</jetty.alpn.version>, + </properties>, + </profile>, + <profile>, + <id>npn-alpn-7u79</id>, + <activation>, + <property>, + <name>java.version</name>, + <value>1.7.0_79</value>, + </property>, + </activation>, + <properties>, + <jetty.npn.version>1.1.10.v20150130</jetty.npn.version>, + <jetty.alpn.version>7.1.3.v20150130</jetty.alpn.version>, + </properties>, + </profile>, + <profile>, + <id>npn-alpn-7u80</id>, + <activation>, + <property>, + <name>java.version</name>, + <value>1.7.0_80</value>, + </property>, + </activation>, + <properties>, + <jetty.npn.version>1.1.10.v20150130</jetty.npn.version>, + <jetty.alpn.version>7.1.3.v20150130</jetty.alpn.version>, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, + static final int MAX_PLAINTEXT_LENGTH = 16 * 1024; // 2^14, + /**, + * This is the maximum overhead when encrypting plaintext as defined by, + * <a href="https://www.ietf.org/rfc/rfc5246.txt">rfc5264</a>,, + * <a href="https://www.ietf.org/rfc/rfc5289.txt">rfc5289</a> and openssl implementation itself., + *, + * Please note that we use a padding of 16 here as openssl uses PKC#5 which uses 16 bytes while the spec itself, + * allow up to 255 bytes. 16 bytes is the max for PKC#5 (which handles it the same way as PKC#7) as we use a block, + * size of 16. See
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, + static boolean isServerId(int ID) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, + static boolean isServerId(int ID) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java, + if (SpdyCodecUtil.isServerId(streamID)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, + static boolean isServerId(int ID) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java, + if (SpdyCodecUtil.isServerId(streamID)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, + boolean serverID = SpdyCodecUtil.isServerId(ID);]
[+++ b/pom.xml, + <!-- We don't want to use the default release profile because it, + causes the JavaDoc and source jars to be deployed twice. -->, + <useReleaseProfile>false</useReleaseProfile>, + <!-- Activate a custom profile called "release" -->, + <arguments>-Prelease</arguments>, + <profiles>, + <profile>, + <id>release</id>, + <build>, + <plugins>, + <plugin>, + <inherited>true</inherited>, + <groupId>org.apache.maven.plugins</groupId>, + <artifactId>maven-deploy-plugin</artifactId>, + <configuration>, + <updateReleaseInfo>true</updateReleaseInfo>, + </configuration>, + </plugin>, + </plugins>, + </build>, + </profile>, + </profiles>]
[+++ b/transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpInboundByteStreamHandler.java, + protected final boolean acceptInboundMessage(Object msg) throws Exception {, +++ b/transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpInboundByteStreamHandler.java, + protected final boolean acceptInboundMessage(Object msg) throws Exception {, +++ b/transport/src/main/java/io/netty/channel/ChannelInboundMessageHandlerAdapter.java, + protected boolean acceptInboundMessage(Object msg) throws Exception {, +++ b/transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpInboundByteStreamHandler.java, + protected final boolean acceptInboundMessage(Object msg) throws Exception {, +++ b/transport/src/main/java/io/netty/channel/ChannelInboundMessageHandlerAdapter.java, + protected boolean acceptInboundMessage(Object msg) throws Exception {, +++ b/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java, + protected boolean acceptInboundMessage(Object msg) throws Exception {]
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsMessage.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsMessage.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsRecord.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsMessage.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsRecord.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQuery.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsMessage.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsRecord.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQuery.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryDecoder.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsMessage.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsRecord.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQuery.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryDecoder.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryEncoder.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsMessage.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsRecord.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQuery.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryDecoder.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryEncoder.java, +import io.netty.util.internal.UnstableApi;,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java, + out.writeInt(random);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java, + out.writeInt(random);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteDecoder.java, + callDecode(ctx, in, ctx.nextOutboundByteBuffer());]
[+++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ /dev/null, +++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, + , + , + // Check if we exceeded the maximum
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseDecoder.java, +import io.netty.handler.codec.CorruptedFrameException;, + throw new CorruptedFrameException("name contains a loop.");, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseDecoder.java, +import io.netty.handler.codec.CorruptedFrameException;, + throw new CorruptedFrameException("name contains a loop.");, +++ b/codec-dns/src/test/java/io/netty/handler/codec/dns/DnsResponseTest.java, +import io.netty.handler.codec.CorruptedFrameException;, + exception.expect(CorruptedFrameException.class);]
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioSctpChannel.java, + if (!connected) {, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioSctpChannel.java, + if (!connected) {, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java, + if (!connected) {]
[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java, +import java.util.concurrent.ThreadFactory;, +public final class DefaultEventExecutor extends SingleThreadEventExecutor {, + public DefaultEventExecutor() {, + this((EventExecutorGroup) null);, + }, +, + public DefaultEventExecutor(ThreadFactory threadFactory) {, + this(null, threadFactory);, + }, +, + public DefaultEventExecutor(Executor executor) {, + this(null, executor);, + }, +, + public DefaultEventExecutor(EventExecutorGroup parent) {, + this(parent, new DefaultThreadFactory(DefaultEventExecutor.class));, + }, +, + public DefaultEventExecutor(EventExecutorGroup parent, ThreadFactory threadFactory) {, + super(parent, threadFactory, true);, + }, +, + public DefaultEventExecutor(EventExecutorGroup parent, Executor executor) {]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + private volatile boolean handshakeComplete;, + private volatile String actualSubprotocol;]
[+++ b/src/docbook/module/start.xml, + this chapter are only two; the latest version of Netty and JDK 1.5 or, + <ulink url="&Downloads;">the project download page</ulink>. To download, + the right version of JDK, please refer to your preferred JDK vendor's web, + To implement the DISCARD protocol, you only need to log the received data., + Let us start straight from the handler implementation, which handles I/O, + events generated by Netty., + <classname>DiscardServerHandler</classname> does not manage any, + stateful information, and therefore it is annotated with the value, + handler methods that you can override. For now, it is just
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + throw new ChannelPipelineException("A user handler's newOutboundBuffer() returned null");]
[+++ b/all/pom.xml, +++ b/all/pom.xml, +++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E> {, +, + public ObjectArray(E[] array, int offset, int length) {, + super(array, offset, length);, + }, +, + @Override, + public E[] array() {, + return (E[]) super.array();, + }, +}, +++ b/all/pom.xml, +++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E> {, +, + public ObjectArray(E[] array, int offset, int length) {, + super(array, offset, length);, + }, +, + @Override, + public E[] array() {, + return (E[]) super.array();, + }, +}, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return writerIndex > readerIndex;,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + try {, + } finally {, + headerBlockDecompressor.end();, + }]
[+++ b/all/pom.xml, + <version>4.1.35.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.35.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.35.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.35.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.35.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, + <version>4.1.35.Final-SNAPSHOT</version>, +
[+++ b/pom.xml, + <version>3.0.2.GA-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + return new PooledHeapByteBuf(maxCapacity);, + return new PooledUnsafeDirectByteBuf(maxCapacity);, + return new PooledDirectByteBuf(maxCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + return new PooledHeapByteBuf(maxCapacity);, + return new PooledUnsafeDirectByteBuf(maxCapacity);, + return new PooledDirectByteBuf(maxCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + protected PooledByteBuf(int maxCapacity) {, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + return new PooledHeapByteBuf(maxCapacity);, + return new PooledUnsafeDirectByteBuf(maxCapacity);, + return new PooledDirectByteBuf(maxCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + protected PooledByteBuf(int maxCapacity) {, +++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, + PooledDirectByteBuf(int maxCapacity) {, + super(maxCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + return new PooledHeapByteBuf(maxCapacity);, + return new PooledUnsafeDirectByteBuf(maxCapacity);, + return new PooledDirectByteBuf(maxCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + protected PooledByteBuf(int maxCapacity) {, +++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, + PooledDirectByteBuf(int maxCapacity) {, + super(maxCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java, + PooledHeapByteBuf(int maxCapacity) {,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + long getMaxAge();, + void setMaxAge(long maxAge);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + long getMaxAge();, + void setMaxAge(long maxAge);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + Pattern.compile(, + // See: https://github.com/netty/netty/pull/96, + //"(?:\\s|[;,])*\\$*([^;=]+)(?:=(?:[\"']((?:\\\\.|[^\"])*)[\"']|([^;,]*)))?(\\s*(?:[;,]+\\s*|$))", + "(?:\\s|[;,])*\\$*([^;=]+)(?:=(?:[\"']((?:\\\\.|[^\"])*)[\"']|([^;]*)))?(\\s*(?:[;,]+\\s*|$))", + );, + long maxAge = -1;, + maxAge = maxAgeMillis / 1000 + (maxAgeMillis % 1000 != 0? 1 : 0);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + long getMaxAge();, + void setMaxAge(long maxAge);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + Pattern.compile(, + // See: https://github.com/netty/netty/pull/96, + //"(?:\\s|[;,])*\\$*([^;=]+)(?:=(?:[\"']((?:\\\\.|[^\"])*)[\"']|([^;,]*)))?(\\s*(?:[;,]+\\s*|$))", + "(?:\\s|[;,])*\\$*([^;=]+)(?:=(?:[\"']((?:\\\\.|[^\"])*)[\"']|([^;]*)))?(\\s*(?:[;,]+\\s*|$))", + );, + long maxAge = -1;, + maxAge = maxAgeMillis / 1000 + (maxAgeMillis % 1000 != 0? 1 : 0);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java, + private
[+++ b/pom.xml, + <repositories>, + <repository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </repository>, + </repositories>, +, + <pluginRepositories>, + <pluginRepository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </pluginRepository>, + </pluginRepositories>, +, +++ b/pom.xml, + <repositories>, + <repository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </repository>, + </repositories>, +, + <pluginRepositories>, + <pluginRepository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </pluginRepository>, + </pluginRepositories>, +, +++ b/src/main/java/org/jboss/netty/channel/socket/sctp/DefaultNioSocketChannelConfig.java, +import java.net.Socket;, +import java.util.Map;, +, +++ b/pom.xml, + <repositories>, + <repository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </repository>, + </repositories>, +, + <pluginRepositories>, + <pluginRepository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </pluginRepository>, + </pluginRepositories>, +, +++ b/src/main/java/org/jboss/netty/channel/socket/sctp/DefaultNioSocketChannelConfig.java, +import java.net.Socket;, +import java.util.Map;, +, +++
[+++ b/example/src/main/java/io/netty/example/uptime/UptimeClient.java, + private static final int READ_TIMEOUT = Integer.parseInt(System.getProperty("readTimeout", "10"));, + private static final Bootstrap bs = new Bootstrap();, + EventLoopGroup group = new NioEventLoopGroup();, + bs.group(group), + protected void initChannel(SocketChannel ch) throws Exception {, + bs.connect();, + static void connect() {, + bs.connect().addListener(new ChannelFutureListener() {, +++ b/example/src/main/java/io/netty/example/uptime/UptimeClient.java, + private static final int READ_TIMEOUT = Integer.parseInt(System.getProperty("readTimeout", "10"));, + private static final Bootstrap bs = new Bootstrap();, + EventLoopGroup group = new NioEventLoopGroup();, + bs.group(group), + protected void initChannel(SocketChannel ch) throws Exception {, + bs.connect();, + static void connect() {, + bs.connect().addListener(new ChannelFutureListener() {, +++ b/example/src/main/java/io/netty/example/uptime/UptimeClientHandler.java, + ctx.channel().eventLoop().schedule(new Runnable()
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, + static final int DEFAULT_MAX_FRAME_SIZE = 16384;, + public WebSocket00FrameDecoder(int maxFrameSize) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, + static final int DEFAULT_MAX_FRAME_SIZE = 16384;, + public WebSocket00FrameDecoder(int maxFrameSize) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, + public WebSocket08FrameDecoder(boolean maskedPayload, boolean allowExtensions, int maxFramePayloadLength) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, + static final int DEFAULT_MAX_FRAME_SIZE = 16384;, + public WebSocket00FrameDecoder(int maxFrameSize) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, + public WebSocket08FrameDecoder(boolean maskedPayload, boolean allowExtensions, int maxFramePayloadLength) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket13FrameDecoder.java, + public WebSocket13FrameDecoder(boolean maskedPayload, boolean allowExtensions, int maxFramePayloadLength) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, + static final int DEFAULT_MAX_FRAME_SIZE = 16384;, + public WebSocket00FrameDecoder(int maxFrameSize) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, + public WebSocket08FrameDecoder(boolean maskedPayload, boolean allowExtensions, int maxFramePayloadLength)
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket07FrameDecoder.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + return release0(decrement);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + return release0(decrement);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java, + return new PooledNonRetainedDuplicateByteBuf(referenceCountDelegate, unwrap()), + .setIndex(idx(readerIndex()), idx(writerIndex()));, + return PooledDuplicatedByteBuf.newInstance(unwrap(), this, idx(readerIndex()), idx(writerIndex()));, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + return release0(decrement);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java, + return new PooledNonRetainedDuplicateByteBuf(referenceCountDelegate, unwrap()), + .setIndex(idx(readerIndex()), idx(writerIndex()));, + return PooledDuplicatedByteBuf.newInstance(unwrap(), this, idx(readerIndex()), idx(writerIndex()));, +++ b/buffer/src/main/java/io/netty/buffer/AbstractUnpooledSlicedByteBuf.java, + return unwrap().duplicate().setIndex(idx(readerIndex()), idx(writerIndex()));, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + return release0(decrement);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java, + return new PooledNonRetainedDuplicateByteBuf(referenceCountDelegate, unwrap()), + .setIndex(idx(readerIndex()), idx(writerIndex()));, + return PooledDuplicatedByteBuf.newInstance(unwrap(), this, idx(readerIndex()), idx(writerIndex()));, +++ b/buffer/src/main/java/io/netty/buffer/AbstractUnpooledSlicedByteBuf.java, + return unwrap().duplicate().setIndex(idx(readerIndex()), idx(writerIndex()));, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * @return A buffer whose readable content is equivalent to the buffer returned by {@link #slice()}.,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/FullHttpMessage.java, + * Combines {@link HttpMessage} and {@link LastHttpContent} into one]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, +import io.netty.util.ReferenceCountUtil;, + if (msg instanceof ByteBuf) {, + final ByteBuf potentialEmptyBuf = (ByteBuf) msg;, + if (!potentialEmptyBuf.isReadable()) {, + out.add(potentialEmptyBuf.retain());, + }, + out.add(ReferenceCountUtil.retain(msg));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, +import io.netty.util.ReferenceCountUtil;, + if (msg instanceof ByteBuf) {, + final ByteBuf potentialEmptyBuf = (ByteBuf) msg;, + if (!potentialEmptyBuf.isReadable()) {, + out.add(potentialEmptyBuf.retain());, + }, + out.add(ReferenceCountUtil.retain(msg));, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpRequestEncoderTest.java, +import io.netty.channel.embedded.EmbeddedChannel;, +import io.netty.util.IllegalReferenceCountException;, +import java.util.concurrent.ExecutionException;, +import static org.hamcrest.Matchers.instanceOf;, +import static org.hamcrest.Matchers.is;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertThat;, +import static org.junit.Assert.fail;, +, + @Test, + public void testEmptyReleasedBufferShouldNotWriteEmptyBufferToChannel() throws Exception {, + HttpRequestEncoder encoder = new HttpRequestEncoder();, + EmbeddedChannel channel = new EmbeddedChannel(encoder);,
[+++ b/pom.xml, + <argLine.bootcp>-Xbootclasspath/p:${jetty.alpn.path}</argLine.bootcp>]
[+++ b/handler/src/test/java/io/netty/handler/ssl/Java8SslTestUtils.java, +import javax.net.ssl.SSLEngine;, +, + /**, + * Wraps the given {@link SSLEngine} to add extra tests while executing methods if possible / needed., + */, + static SSLEngine wrapSSLEngineForTesting(SSLEngine engine) {, + if (engine instanceof ReferenceCountedOpenSslEngine) {, + return new OpenSslErrorStackAssertSSLEngine((ReferenceCountedOpenSslEngine) engine);, + }, + return engine;, + }, +++ b/handler/src/test/java/io/netty/handler/ssl/Java8SslTestUtils.java, +import javax.net.ssl.SSLEngine;, +, + /**, + * Wraps the given {@link SSLEngine} to add extra tests while executing methods if possible / needed., + */, + static SSLEngine wrapSSLEngineForTesting(SSLEngine engine) {, + if (engine instanceof ReferenceCountedOpenSslEngine) {, + return new OpenSslErrorStackAssertSSLEngine((ReferenceCountedOpenSslEngine) engine);, + }, + return
[+++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + ctx.flush();, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + ctx.flush();, +++ b/handler/src/main/java/io/netty/handler/ssl/SslUtils.java, + // We have may haven written some parts of data before an exception was thrown so ensure we always flush., + // See https://github.com/netty/netty/issues/3900#issuecomment-172481830, + ctx.flush();, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + ctx.flush();, +++ b/handler/src/main/java/io/netty/handler/ssl/SslUtils.java, + // We have may haven written some parts of data before an exception was thrown so ensure we always flush., + // See https://github.com/netty/netty/issues/3900#issuecomment-172481830, + ctx.flush();, +++ b/handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java, +import io.netty.util.ReferenceCountUtil;, + assertThat(ch.finish(), is(true));, +, + for (;;) {, + Object msg = ch.readOutbound();, + if (msg == null) {, + break;, + }, + ReferenceCountUtil.release(msg);,
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2Decoder.java]
[+++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, + @SuppressWarnings("unchecked"), +++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, + @SuppressWarnings("unchecked"), +++ b/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java, + @SuppressWarnings("unchecked"), + @SuppressWarnings("unchecked"), +++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, + @SuppressWarnings("unchecked"), +++ b/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java, + @SuppressWarnings("unchecked"), + @SuppressWarnings("unchecked"), +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, + @SuppressWarnings("unchecked"), + @SuppressWarnings("unchecked"), +++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, + @SuppressWarnings("unchecked"), +++ b/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java, + @SuppressWarnings("unchecked"), + @SuppressWarnings("unchecked"), +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, + @SuppressWarnings("unchecked"), + @SuppressWarnings("unchecked"), +++ b/transport/src/main/java/io/netty/channel/socket/DefaultDatagramChannelConfig.java, + @SuppressWarnings("unchecked"), +++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, + @SuppressWarnings("unchecked"), +++ b/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java, + @SuppressWarnings("unchecked"), + @SuppressWarnings("unchecked"), +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, + @SuppressWarnings("unchecked"), + @SuppressWarnings("unchecked"), +++ b/transport/src/main/java/io/netty/channel/socket/DefaultDatagramChannelConfig.java, + @SuppressWarnings("unchecked"), +++ b/transport/src/main/java/io/netty/channel/socket/DefaultSctpChannelConfig.java, + @SuppressWarnings("unchecked"), +++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, + @SuppressWarnings("unchecked"), +++ b/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java, + @SuppressWarnings("unchecked"), + @SuppressWarnings("unchecked"), +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, + @SuppressWarnings("unchecked"), + @SuppressWarnings("unchecked"), +++ b/transport/src/main/java/io/netty/channel/socket/DefaultDatagramChannelConfig.java, + @SuppressWarnings("unchecked"), +++ b/transport/src/main/java/io/netty/channel/socket/DefaultSctpChannelConfig.java, + @SuppressWarnings("unchecked"), +++
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + ensureAccessible();, + checkIndex(index, length);, + ensureAccessible();, + checkIndex(index, length);, +]
[+++ b/pom.xml, + -group "IoC (Dependency Injection) container integration" ${project.groupId}.container*]
[+++ b/pom.xml, + <name>JBoss, a division of Red Hat</name>, + <version>1.5.6</version>, + <version>4.5</version>, + <version>2.4</version>, + <version>1.5.6</version>, + <groupId>org.apache.ant</groupId>, + <artifactId>ant</artifactId>, + <version>1.7.1</version>, + </dependency>, + <dependency>, + <groupId>org.apache.ant</groupId>, + <artifactId>ant-launcher</artifactId>, + <version>1.7.1</version>, + </dependency>, + <dependency>, + <exclusions>, + <exclusion>, + <groupId>ant</groupId>, + <artifactId>ant</artifactId>, + </exclusion>, + </exclusions>, + <useStandardDocletOptions>true</useStandardDocletOptions>, + <outputDirectory>${project.build.directory}/api</outputDirectory>, + <reportOutputDirectory>${project.build.directory}/api</reportOutputDirectory>, + <destDir>api</destDir>, + <charset>UTF-8</charset>, + <docencoding>UTF-8</docencoding>, + <breakiterator>true</breakiterator>, + <version>true</version>, + <author>true</author>, + <keywords>true</keywords>, + <overview>${basedir}/src/javadoc/overview.html</overview>, + <doctitle>${project.name} ${project.version} API Reference</doctitle>, + <windowtitle>${project.name} ${project.version} API Reference</windowtitle>, + <goal>single</goal>, + <version>2.4</version>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpResponseStreamIdHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/package-info.java, + * <p>05. Install AutoBahn: <tt>sudo easy_install autobahntestsuite</tt>. Test using <tt>wstest --help</tt>.]
[+++ b/common/src/main/java/io/netty/util/internal/logging/InternalLoggerFactory.java, + } catch (Throwable ignore1) {, + } catch (Throwable ignore2) {, + try {, + f = Log4J2LoggerFactory.INSTANCE;, + f.newInstance(name).debug("Using Log4J2 as the default logging framework");, + } catch (Throwable ignore3) {, + }]
[+++ b/pom.xml, + <developerConnection>scm:git:ssh://git@github.com/netty/netty.git</developerConnection>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/ContinuationWebSocketFrame.java, + this(Unpooled.buffer(0));, + this(finalFragment, rsv, fromText(text));, + return new ContinuationWebSocketFrame(isFinalFragment(), rsv(), content().copy());, + return new ContinuationWebSocketFrame(isFinalFragment(), rsv(), content().duplicate());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/ContinuationWebSocketFrame.java, + this(Unpooled.buffer(0));, + this(finalFragment, rsv, fromText(text));, + return new ContinuationWebSocketFrame(isFinalFragment(), rsv(), content().copy());, + return new ContinuationWebSocketFrame(isFinalFragment(), rsv(), content().duplicate());, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/ContinuationWebSocketFrame.java, + this(Unpooled.buffer(0));, + this(finalFragment, rsv, fromText(text));, + return new ContinuationWebSocketFrame(isFinalFragment(), rsv(), content().copy());, + return new ContinuationWebSocketFrame(isFinalFragment(), rsv(), content().duplicate());, +++ /dev/null, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/ContinuationWebSocketFrame.java, + this(Unpooled.buffer(0));, + this(finalFragment, rsv, fromText(text));, + return new ContinuationWebSocketFrame(isFinalFragment(), rsv(), content().copy());, + return new ContinuationWebSocketFrame(isFinalFragment(), rsv(), content().duplicate());, +++ /dev/null, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/Utf8Validator.java, +/*, + * Copyright 2012 The Netty
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + for (DefaultStream stream : children.values()) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + for (DefaultStream stream : children.values()) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, + settings.put(id, Long.valueOf(value));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + for (DefaultStream stream : children.values()) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, + settings.put(id, Long.valueOf(value));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, + for (CharObjectMap.PrimitiveEntry<Long> entry : settings.entries()) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + for (DefaultStream stream : children.values()) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, + settings.put(id, Long.valueOf(value));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, + for (CharObjectMap.PrimitiveEntry<Long> entry : settings.entries()) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ClientUpgradeCodec.java, +import io.netty.buffer.ByteBuf;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.handler.codec.base64.Base64;, +import io.netty.handler.codec.http.FullHttpResponse;, +import io.netty.handler.codec.http.HttpClientUpgradeHandler;, +import io.netty.handler.codec.http.HttpRequest;, +import io.netty.util.collection.CharObjectMap;, +, +import java.util.Collection;, +import java.util.Collections;, +import java.util.List;, +, + for (CharObjectMap.PrimitiveEntry<Long> entry : settings.entries())
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, +import io.netty.handler.codec.http.HttpResponseStatus;, + if (!response.status().equals(HttpResponseStatus.SWITCHING_PROTOCOLS)) {]
[+++ b/pom.xml, + <url>https://github.com/netty/netty</url>, + <connection>scm:git:git://github.com/netty/netty.git</connection>, + <developerConnection>scm:git:ssh://git@github.com:netty/netty.git</developerConnection>]
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Throwable e) {, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Throwable e) {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +import io.netty.channel.socket.DatagramChannel;, +import io.netty.channel.socket.ServerSocketChannel;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.channel.socket.nio.NioSocketChannelConfig;, +, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Throwable e) {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +import io.netty.channel.socket.DatagramChannel;, +import io.netty.channel.socket.ServerSocketChannel;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.channel.socket.nio.NioSocketChannelConfig;, +, +++ /dev/null, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Throwable e) {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +import io.netty.channel.socket.DatagramChannel;, +import io.netty.channel.socket.ServerSocketChannel;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.channel.socket.nio.NioSocketChannelConfig;, +, +++ /dev/null, +++ /dev/null, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Throwable e) {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +import io.netty.channel.socket.DatagramChannel;, +import io.netty.channel.socket.ServerSocketChannel;, +import io.netty.channel.socket.SocketChannel;,
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java, + testSimpleSend0(sb, cb, Unpooled.directBuffer(), true, 1);, + testSimpleSend0(sb, cb, Unpooled.directBuffer(), true, 4);, + testSimpleSend0(sb, cb, Unpooled.directBuffer(), true, 1);, + testSimpleSend0(sb, cb, Unpooled.directBuffer(), true, 4);, + testSimpleSend0(sb, cb, buf, true, 1);, +, + CompositeByteBuf buf2 = Unpooled.compositeBuffer();, + buf2.addComponent(Unpooled.directBuffer(2, 2));, + buf2.addComponent(Unpooled.directBuffer(2, 2));, + testSimpleSend0(sb, cb, buf2, true, 4);, + testSimpleSend0(sb, cb, buf, true, 1);, +, + CompositeByteBuf buf2 = Unpooled.compositeBuffer();, + buf2.addComponent(Unpooled.buffer(2, 2));, + buf2.addComponent(Unpooled.buffer(2, 2));, + testSimpleSend0(sb, cb, buf2, true, 4);, + testSimpleSend0(sb, cb, buf, true, 1);, + CompositeByteBuf buf2 = Unpooled.compositeBuffer();, + buf2.addComponent(Unpooled.directBuffer(2, 2));, + buf2.addComponent(Unpooled.buffer(2, 2));, + testSimpleSend0(sb, cb, buf2, true, 4);, + testSimpleSend0(sb,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java, + FullHttpRequest request = new DefaultFullHttpRequest(protocolVersion(), method(), uri(), content,, + headers().copy(), trailingHeaders().copy());, + request.setDecoderResult(decoderResult());, + return request;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java, + FullHttpRequest request = new DefaultFullHttpRequest(protocolVersion(), method(), uri(), content,, + headers().copy(), trailingHeaders().copy());, + request.setDecoderResult(decoderResult());, + return request;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java, + FullHttpResponse response = new DefaultFullHttpResponse(protocolVersion(), status(), content,, + headers().copy(), trailingHeaders().copy());, + response.setDecoderResult(decoderResult());, + return response;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java, + FullHttpRequest request = new DefaultFullHttpRequest(protocolVersion(), method(), uri(), content,, + headers().copy(), trailingHeaders().copy());, + request.setDecoderResult(decoderResult());, + return request;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java, + FullHttpResponse response = new DefaultFullHttpResponse(protocolVersion(), status(), content,, + headers().copy(), trailingHeaders().copy());, + response.setDecoderResult(decoderResult());, + return response;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, + @Override, + public
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CombinedHttpHeaders.java, + private static CharSequence commaSeparateEscapedValues(CharSequence currentValue, CharSequence value) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CombinedHttpHeaders.java, + private static CharSequence commaSeparateEscapedValues(CharSequence currentValue, CharSequence value) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/ServerCookieEncoder.java, + private static List<String> dedup(List<String> encoded, Map<String, Integer> nameToLastIndex) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CombinedHttpHeaders.java, + private static CharSequence commaSeparateEscapedValues(CharSequence currentValue, CharSequence value) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/ServerCookieEncoder.java, + private static List<String> dedup(List<String> encoded, Map<String, Integer> nameToLastIndex) {, +++ b/common/src/main/java/io/netty/util/ConstantPool.java, + private static String checkNotNullAndNotEmpty(String name) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CombinedHttpHeaders.java, + private static CharSequence commaSeparateEscapedValues(CharSequence currentValue, CharSequence value) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/ServerCookieEncoder.java, + private static List<String> dedup(List<String> encoded, Map<String, Integer> nameToLastIndex) {, +++ b/common/src/main/java/io/netty/util/ConstantPool.java, + private static String checkNotNullAndNotEmpty(String name) {, +++
[+++ b/all/pom.xml, + <version>4.1.4.Final</version>, +++ b/all/pom.xml, + <version>4.1.4.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.4.Final</version>, +++ b/all/pom.xml, + <version>4.1.4.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.4.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.4.Final</version>, +++ b/all/pom.xml, + <version>4.1.4.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.4.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.4.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.4.Final</version>, +++ b/all/pom.xml, + <version>4.1.4.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.4.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.4.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.4.Final</version>, +++ b/codec-http/pom.xml, + <version>4.1.4.Final</version>, +++ b/all/pom.xml, + <version>4.1.4.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.4.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.4.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.4.Final</version>, +++ b/codec-http/pom.xml, + <version>4.1.4.Final</version>, +++ b/codec-http2/pom.xml, + <version>4.1.4.Final</version>, +++ b/all/pom.xml, + <version>4.1.4.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.4.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.4.Final</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/example/pom.xml, + <artifactId>netty-codec-redis</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/example/pom.xml, + <artifactId>netty-codec-redis</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/example/src/main/java/io/netty/example/redis/RedisClient.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the, + * "License"); you may not use this file except in compliance with the License. You may obtain a, + * copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software
[+++ b/pom.xml, + Netty must be released from RHEL 6.8 x86_64 or compatible so that:, + Release process must be performed on RHEL 6.8 or its derivatives., + <content>release 6.8</content>]
[+++ b/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java]
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpInvalidMessageTest.java, + Assert.assertFalse(dr.isPartialFailure());, + Assert.assertTrue(dr.isPartialFailure());, + Assert.assertFalse(dr.isPartialFailure());, + Assert.assertTrue(dr.isPartialFailure());, + Assert.assertFalse(dr.isPartialFailure());, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpInvalidMessageTest.java, + Assert.assertFalse(dr.isPartialFailure());, + Assert.assertTrue(dr.isPartialFailure());, + Assert.assertFalse(dr.isPartialFailure());, + Assert.assertTrue(dr.isPartialFailure());, + Assert.assertFalse(dr.isPartialFailure());, +++ b/codec/src/main/java/io/netty/handler/codec/DecoderResult.java, + public boolean isFailure() {, + return cause != null;, + }, +, + public boolean isCompleteFailure() {, + return cause != null && !partial;, + }, +, + public boolean isPartialFailure() {, + if (isPartialFailure()) {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpInvalidMessageTest.java, + Assert.assertFalse(dr.isPartialFailure());, + Assert.assertTrue(dr.isPartialFailure());, + Assert.assertFalse(dr.isPartialFailure());, + Assert.assertTrue(dr.isPartialFailure());, + Assert.assertFalse(dr.isPartialFailure());, +++ b/codec/src/main/java/io/netty/handler/codec/DecoderResult.java, + public boolean isFailure() {, + return cause != null;, + }, +, + public boolean isCompleteFailure() {, + return cause !=
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseStatus.java, + return new HttpResponseStatus(code);, + private HttpStatusClass codeClass;, + * Creates a new instance with the specified {@code code} and the auto-generated default reason phrase., + */, + private HttpResponseStatus(int code) {, + this(code, HttpStatusClass.valueOf(code).defaultReasonPhrase() + " (" + code + ')', false);, + }, +, + /**, + * Creates a new instance with the specified {@code code} and its {@code reasonPhrase}., + /**, + * Returns the class of this {@link HttpResponseStatus}, + */, + public HttpStatusClass codeClass() {, + HttpStatusClass type = this.codeClass;, + if (type == null) {, + this.codeClass = type =
[+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java]
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java, + *, + * @deprecated Use {@link SslContextBuilder} to create {@link JdkSslContext} instances and only, + * use {@link JdkSslContext} in your code., +@Deprecated, + super(newSSLContext(toX509CertificatesInternal(, + trustCertCollectionFile), trustManagerFactory,, + toX509CertificatesInternal(keyCertChainFile), toPrivateKeyInternal(keyFile, keyPassword),, + keyPassword, keyManagerFactory, sessionCacheSize, sessionTimeout), true,, + ciphers, cipherFilter, apn, ClientAuth.NONE);, + super(newSSLContext(trustCertCollection, trustManagerFactory, keyCertChain, key, keyPassword,, + keyManagerFactory, sessionCacheSize, sessionTimeout), true,, + ciphers, cipherFilter, toNegotiator(apn, false), ClientAuth.NONE);, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java, + *, + * @deprecated Use {@link SslContextBuilder} to create {@link JdkSslContext} instances and only, + * use {@link JdkSslContext} in your code., +@Deprecated, + super(newSSLContext(toX509CertificatesInternal(, + trustCertCollectionFile), trustManagerFactory,, + toX509CertificatesInternal(keyCertChainFile), toPrivateKeyInternal(keyFile, keyPassword),, +
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + try {, + } finally {, + buf.release();, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java, +import java.util.regex.Pattern;, + private static final Pattern STRIP_PATTERN = Pattern.compile("(?:^\\s+|\\s+$|\\n)");, + private static final Pattern REPLACE_PATTERN = Pattern.compile("[\\r\\t]");, +, +, + name = REPLACE_PATTERN.matcher(name).replaceAll(" ");, + name = STRIP_PATTERN.matcher(name).replaceAll("");, +]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackDecoder.java, + nameLength = name.length();, + nameLength = name.length();, + nameLength = name.length();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackDecoder.java, + nameLength = name.length();, + nameLength = name.length();, + nameLength = name.length();, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/HpackDecoderTest.java, +, + @Test, + public void testDecodeCountsNamesOnlyOnce() throws Http2Exception {, + ByteBuf in = Unpooled.buffer(200);, + try {, + hpackDecoder.setMaxHeaderListSize(3500, 4000);, + HpackEncoder hpackEncoder = new HpackEncoder(true);, +, + // encode headers that are slightly larger than maxHeaderListSize, + // but smaller than maxHeaderListSizeGoAway, + Http2Headers toEncode = new DefaultHttp2Headers();, + toEncode.add(String.format("%03000d", 0).replace('0', 'f'), "value");, + toEncode.add("accept", "value");, + hpackEncoder.encodeHeaders(1, in, toEncode, NEVER_SENSITIVE);, +, + Http2Headers decoded = new
[+++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java, + private HttpRequest request;, + private boolean readingChunks;]
[+++ b/transport/src/main/java/io/netty/channel/pool/SimpleChannelPool.java, + } else { //channel not healthy, just releasing it., + promise.setSuccess(null);, +++ b/transport/src/main/java/io/netty/channel/pool/SimpleChannelPool.java, + } else { //channel not healthy, just releasing it., + promise.setSuccess(null);, +++ b/transport/src/test/java/io/netty/channel/pool/FixedChannelPoolTest.java, +import org.junit.AfterClass;, +import org.junit.BeforeClass;, + private static EventLoopGroup group;, +, + @BeforeClass, + public static void createEventLoop() {, + group = new LocalEventLoopGroup();, + }, +, + @AfterClass, + public static void destroyEventLoop() {, + if (group != null) {, + group.shutdownGracefully();, + }, + }, +, + @Test, + public void testReleaseClosed() {, + LocalAddress addr = new LocalAddress(LOCAL_ADDR_ID);, + Bootstrap cb = new Bootstrap();, + cb.remoteAddress(addr);, +
[+++ b/common/src/main/java/io/netty/util/concurrent/PromiseCombiner.java, + * Adds a new promise to be combined. New promises may be added until an aggregate promise is added via the, + * {@link PromiseCombiner#finish(Promise)} method., + *, + * @param promise the promise to add to this promise combiner, + *, + * @deprecated Replaced by {@link PromiseCombiner#add(Future)}., + */, + @Deprecated, + public void add(Promise promise) {, + add((Future) promise);, + }, +, + /**, + * {@link PromiseCombiner#finish(Promise)} method., + * Adds new promises to be combined. New promises may be added until an aggregate promise is added via the, + * {@link
[+++ b/transport/src/main/java/io/netty/channel/CompleteChannelFuture.java, +abstract class CompleteChannelFuture implements ChannelFuture {, +++ b/transport/src/main/java/io/netty/channel/CompleteChannelFuture.java, +abstract class CompleteChannelFuture implements ChannelFuture {, +++ b/transport/src/main/java/io/netty/channel/FailedChannelFuture.java, +class FailedChannelFuture extends CompleteChannelFuture {, +++ b/transport/src/main/java/io/netty/channel/CompleteChannelFuture.java, +abstract class CompleteChannelFuture implements ChannelFuture {, +++ b/transport/src/main/java/io/netty/channel/FailedChannelFuture.java, +class FailedChannelFuture extends CompleteChannelFuture {, +++ b/transport/src/main/java/io/netty/channel/SucceededChannelFuture.java, + class SucceededChannelFuture extends CompleteChannelFuture {]
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshakerTest.java, + assertEquals("10", data.parameters().get(SERVER_MAX_WINDOW));, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshakerTest.java, + assertEquals("10", data.parameters().get(SERVER_MAX_WINDOW));, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateServerExtensionHandshakerTest.java, + assertEquals("10", data.parameters().get(CLIENT_MAX_WINDOW));, + assertEquals("12", data.parameters().get(SERVER_MAX_WINDOW));, + assertEquals("12", data.parameters().get(SERVER_MAX_WINDOW));, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshakerTest.java, + assertEquals("10", data.parameters().get(SERVER_MAX_WINDOW));, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateServerExtensionHandshakerTest.java, + assertEquals("10", data.parameters().get(CLIENT_MAX_WINDOW));, + assertEquals("12", data.parameters().get(SERVER_MAX_WINDOW));, + assertEquals("12", data.parameters().get(SERVER_MAX_WINDOW));, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/compression/WebSocketServerCompressionHandlerTest.java, + Assert.assertNotNull(ch.pipeline().get(PerMessageDeflateDecoder.class));, + Assert.assertNotNull(ch.pipeline().get(PerMessageDeflateEncoder.class));, + Assert.assertNotNull(ch.pipeline().get(PerMessageDeflateDecoder.class));, + Assert.assertNotNull(ch.pipeline().get(PerMessageDeflateEncoder.class));, + Assert.assertNotNull(ch.pipeline().get(PerMessageDeflateDecoder.class));, + Assert.assertNotNull(ch.pipeline().get(PerMessageDeflateEncoder.class));, + Assert.assertNotNull(ch.pipeline().get(PerMessageDeflateDecoder.class));, + Assert.assertNotNull(ch.pipeline().get(PerMessageDeflateEncoder.class));, + Assert.assertNull(ch.pipeline().get(PerMessageDeflateDecoder.class));, + Assert.assertNull(ch.pipeline().get(PerMessageDeflateEncoder.class));, + Assert.assertNull(ch.pipeline().get(PerMessageDeflateDecoder.class));, + Assert.assertNull(ch.pipeline().get(PerMessageDeflateEncoder.class));, + Assert.assertNotNull(ch.pipeline().get(PerMessageDeflateDecoder.class));, + Assert.assertNotNull(ch.pipeline().get(PerMessageDeflateEncoder.class));, + Assert.assertNotNull(ch.pipeline().get(PerMessageDeflateDecoder.class));, + Assert.assertNotNull(ch.pipeline().get(PerMessageDeflateEncoder.class));, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshakerTest.java, + assertEquals("10", data.parameters().get(SERVER_MAX_WINDOW));, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateServerExtensionHandshakerTest.java, + assertEquals("10", data.parameters().get(CLIENT_MAX_WINDOW));, + assertEquals("12", data.parameters().get(SERVER_MAX_WINDOW));, + assertEquals("12", data.parameters().get(SERVER_MAX_WINDOW));, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/compression/WebSocketServerCompressionHandlerTest.java, + Assert.assertNotNull(ch.pipeline().get(PerMessageDeflateDecoder.class));, + Assert.assertNotNull(ch.pipeline().get(PerMessageDeflateEncoder.class));, + Assert.assertNotNull(ch.pipeline().get(PerMessageDeflateDecoder.class));, + Assert.assertNotNull(ch.pipeline().get(PerMessageDeflateEncoder.class));, + Assert.assertNotNull(ch.pipeline().get(PerMessageDeflateDecoder.class));,
[+++ b/buffer/src/main/java/io/netty/buffer/DefaultMessageBuf.java, + * Default {@link MessageBuf} implementation., + *, + * You should use {@link Unpooled#messageBuffer()} to create an instance, +public class DefaultMessageBuf<T> extends AbstractMessageBuf<T> {, + protected DefaultMessageBuf() {, + protected DefaultMessageBuf(int initialCapacity) {, + protected DefaultMessageBuf(int initialCapacity, int maxCapacity) {, +++ b/buffer/src/main/java/io/netty/buffer/DefaultMessageBuf.java, + * Default {@link MessageBuf} implementation., + *, + * You should use {@link Unpooled#messageBuffer()} to create an instance, +public class DefaultMessageBuf<T> extends AbstractMessageBuf<T> {, + protected DefaultMessageBuf() {, + protected DefaultMessageBuf(int initialCapacity) {, + protected DefaultMessageBuf(int initialCapacity, int maxCapacity) {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + private static final ThreadLocal<OutputMessageBuf> decoderOutput =, + new ThreadLocal<OutputMessageBuf>() {,
[+++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslRenegotiateTest.java, + // BoringSSL does not support renegotiation intentionally., + Assume.assumeFalse("BoringSSL".equals(OpenSsl.versionString()));, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslRenegotiateTest.java, + // BoringSSL does not support renegotiation intentionally., + Assume.assumeFalse("BoringSSL".equals(OpenSsl.versionString()));, +++ b/pom.xml, + <tcnative.version>1.1.33.Fork13</tcnative.version>, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslRenegotiateTest.java, + // BoringSSL does not support renegotiation intentionally., + Assume.assumeFalse("BoringSSL".equals(OpenSsl.versionString()));, +++ b/pom.xml, + <tcnative.version>1.1.33.Fork13</tcnative.version>, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSslClientRenegotiateTest.java, + // BoringSSL does not support renegotiation intentionally., + Assume.assumeFalse("BoringSSL".equals(OpenSsl.versionString()));]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameLogger.java, + log(direction, "HEADERS: streamId=%d, headers=%s, padding=%d, endStream=%b",, + "HEADERS: streamId=%d, headers=%s, streamDependency=%d, weight=%d, exclusive=%b, "]
[+++ b/codec/src/main/java/io/netty/handler/codec/MessageAggregator.java, + if (maxContentLength < 0) {, + throw new IllegalArgumentException("maxContentLength: " + maxContentLength + " (expected: >= 0)");]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + switch(stream.state()) {, + case IDLE:, + throw connectionError(PROTOCOL_ERROR, "RST_STREAM received for IDLE stream %d", streamId);, + case CLOSED:, + return; // RST_STREAM frames must be ignored for closed streams., + default:, + break;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + switch(stream.state()) {, + case IDLE:, + throw connectionError(PROTOCOL_ERROR, "RST_STREAM received for IDLE stream %d", streamId);, + case CLOSED:, + return; // RST_STREAM frames must be ignored for closed streams., + default:, + break;, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoderTest.java, +import static io.netty.handler.codec.http2.Http2Stream.State.IDLE;, + @Test(expected = Http2Exception.class), + public void rstStreamOnIdleStreamShouldThrow() throws Exception {, + when(stream.state()).thenReturn(IDLE);, + decode().onRstStreamRead(ctx, STREAM_ID, PROTOCOL_ERROR.code());, + verify(lifecycleManager).closeStream(eq(stream), eq(future));, + verify(listener,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java, + setFinalBuffer(undecodedChunk.slice(firstpos, ampersandpos - firstpos).copy());, + setFinalBuffer(undecodedChunk.slice(firstpos, ampersandpos - firstpos).copy());, + setFinalBuffer(undecodedChunk.slice(firstpos, ampersandpos - firstpos).copy());, + setFinalBuffer(undecodedChunk.slice(firstpos, ampersandpos - firstpos).copy());, + currentAttribute.addContent(undecodedChunk.slice(firstpos, currentpos - firstpos).copy(),, + false);, + setFinalBuffer(undecodedChunk.slice(firstpos, ampersandpos - firstpos).copy());, + setFinalBuffer(undecodedChunk.slice(firstpos, ampersandpos - firstpos).copy());, + setFinalBuffer(undecodedChunk.slice(firstpos, ampersandpos - firstpos).copy());, + setFinalBuffer(undecodedChunk.slice(firstpos, ampersandpos - firstpos).copy());, + currentAttribute.addContent(undecodedChunk.slice(firstpos, currentpos - firstpos).copy(),, + false);, + ByteBuf buffer = undecodedChunk.slice(readerIndex, lastPosition - readerIndex).copy();, + ByteBuf buffer = undecodedChunk.slice(readerIndex, lastPosition - readerIndex).copy();, + undecodedChunk.slice(readerIndex, lastPosition - readerIndex).copy(), true);, + undecodedChunk.slice(readerIndex, lastPosition - readerIndex).copy(), false);, + undecodedChunk.slice(readerIndex, lastPosition - readerIndex).copy(), true);, + undecodedChunk.slice(readerIndex, lastPosition - readerIndex).copy(), false);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java, +
[+++ b/pom.xml, + <ignore>java.net.SocketOption</ignore> , + <ignore>java.nio.channels.NetworkChannel</ignore>, +++ b/pom.xml, + <ignore>java.net.SocketOption</ignore> , + <ignore>java.nio.channels.NetworkChannel</ignore>, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioChannelOption.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + setIndex0(readerIndex, writerIndex);, + final void setIndex0(int readerIndex, int writerIndex) {, + this.readerIndex = readerIndex;, + this.writerIndex = writerIndex;, + }, +, + final void discardMarks() {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + setIndex0(readerIndex, writerIndex);, + final void setIndex0(int readerIndex, int writerIndex) {, + this.readerIndex = readerIndex;, + this.writerIndex = writerIndex;, + }, +, + final void discardMarks() {, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + /**, + * Method must be called before reuse this {@link PooledByteBufAllocator}, + */, + final void reuse(int maxCapacity) {, + maxCapacity(maxCapacity);, + setRefCnt(1);, + setIndex0(0, 0);, + discardMarks();, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + setIndex0(readerIndex, writerIndex);, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyNoOpFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyNoOpFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyNoOpFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyNoOpFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java, +++ b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32FrameDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyNoOpFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java, +++ b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32FrameDecoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/sctp/SctpMessageCompletionHandler.java]
[+++ b/transport-native-epoll/pom.xml, + <configureArgs>, + <arg>${jni.compiler.args}</arg>, + </configureArgs>, +, + <plugin>, + <artifactId>maven-antrun-plugin</artifactId>, + <version>1.7</version>, + <executions>, + <execution>, + <!-- Phase must be before regex-glibc-sendmmsg and regex-linux-sendmmsg -->, + <phase>validate</phase>, + <goals>, + <goal>run</goal>, + </goals>, + <id>ant-get-systeminfo</id>, + <configuration>, + <exportAntProperties>true</exportAntProperties>, + <tasks>, + <exec executable="sh" outputproperty="ldd_version">, + <arg value="-c"/>, + <arg value="ldd --version | head -1"/>, + </exec>, + <exec executable="uname" outputproperty="uname_os_version">, + <arg value="-r"/>, + </exec>, + </tasks>, + </configuration>, + </execution>, + </executions>, + </plugin>, + <plugin>, + <groupId>org.codehaus.mojo</groupId>, + <artifactId>build-helper-maven-plugin</artifactId>, + <version>1.7</version>, + <executions>, + <execution>, + <!-- Phase must be before regex-combined-sendmmsg
[+++ b/transport/src/main/java/io/netty/channel/socket/SocketChannelConfig.java, +import io.netty.channel.ChannelHandler;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelInputShutdownEvent;, + * remote peer shuts down output. Instead, {@link ChannelHandler#userEventTriggered(ChannelHandlerContext, Object)}, + * is invoked with a {@link ChannelInputShutdownEvent} object. If {@code false}, the connection, + * is closed automatically.]
[+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java, + private static final int MIN_CLIENT_ID_LENGTH = 1;, + return clientId != null && clientId.length() >= MIN_CLIENT_ID_LENGTH &&, + clientId.length() <= MAX_CLIENT_ID_LENGTH;]
[+++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java, + @SuppressWarnings("all"), +++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java, + @SuppressWarnings("all"), +++ b/example/src/main/java/io/netty/example/securechat/SecureChatTrustManagerFactory.java, +import java.security.InvalidAlgorithmParameterException;, +import java.security.KeyStore;, +import java.security.KeyStoreException;, +import java.security.cert.X509Certificate;, + public void checkClientTrusted(X509Certificate[] chain, String authType) {, + public void checkServerTrusted(X509Certificate[] chain, String authType) {, +++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java, + @SuppressWarnings("all"), +++ b/example/src/main/java/io/netty/example/securechat/SecureChatTrustManagerFactory.java, +import java.security.InvalidAlgorithmParameterException;, +import java.security.KeyStore;, +import java.security.KeyStoreException;, +import java.security.cert.X509Certificate;, + public void checkClientTrusted(X509Certificate[] chain, String authType) {, + public void checkServerTrusted(X509Certificate[] chain, String authType) {, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java, + public void checkClientTrusted(X509Certificate[] chain, String authType) {, + public void checkServerTrusted(X509Certificate[] chain, String authType) {, +++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java, + @SuppressWarnings("all"), +++ b/example/src/main/java/io/netty/example/securechat/SecureChatTrustManagerFactory.java, +import java.security.InvalidAlgorithmParameterException;, +import java.security.KeyStore;, +import java.security.KeyStoreException;, +import java.security.cert.X509Certificate;, + public void
[+++ b/handler/src/main/java/io/netty/handler/execution/ChainedExecutor.java, +++ b/handler/src/main/java/io/netty/handler/execution/ChainedExecutor.java, +++ b/handler/src/main/java/io/netty/handler/execution/ChannelDownstreamEventRunnable.java, +public class ChannelDownstreamEventRunnable extends ChannelEventRunnable {, +++ b/handler/src/main/java/io/netty/handler/execution/ChainedExecutor.java, +++ b/handler/src/main/java/io/netty/handler/execution/ChannelDownstreamEventRunnable.java, +public class ChannelDownstreamEventRunnable extends ChannelEventRunnable {, +++ b/handler/src/main/java/io/netty/handler/execution/ChannelDownstreamEventRunnableFilter.java, +/*
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + ensureAccessible();, + checkIndex(index, length);, +, + checkIndex(index, length);, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + ensureAccessible();, + checkIndex(index, length);, +, + checkIndex(index, length);, +, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + ensureAccessible();, + checkIndex(index, length);, +, + checkIndex(index, length);, +, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + checkIndex(index, length);, + checkIndex(index, length);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + ensureAccessible();, + checkIndex(index, length);, +, + checkIndex(index, length);, +, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, +
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + ChannelHandler handler = handler();]
[+++ b/src/docbook/module/start.xml, + The last task left is to insert a <classname>TimeEncoder</classname>, + into the &ChannelPipeline; on the server side, and it's left as a]
[+++ b/handler-proxy/src/main/java/io/netty/handler/proxy/HttpProxyHandler.java, + private final HttpHeaders outboundHeaders;, + private HttpHeaders inboundHeaders;, + this.outboundHeaders = headers;, + this.outboundHeaders = headers;, + if (outboundHeaders != null) {, + req.headers().add(outboundHeaders);, + protected boolean handleResponse(ChannelHandlerContext ctx, Object response) throws HttpProxyConnectException {, + throw new HttpProxyConnectException(exceptionMessage("too many responses"), /*headers=*/ null);, + HttpResponse res = (HttpResponse) response;, + status = res.status();, + inboundHeaders = res.headers();, + throw new HttpProxyConnectException(exceptionMessage("missing response"), inboundHeaders);, + throw new HttpProxyConnectException(exceptionMessage("status: " + status), inboundHeaders);, +, + /**, + * Specific case of a connection failure, which may include headers from the proxy., + */, + public static final class HttpProxyConnectException
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, + final List<InterfaceHttpData> multipartHttpDatas;, + String multipartDataBoundary;, + String multipartMixedBoundary;, + 139 + multipartDataBoundary.length() + multipartMixedBoundary.length() * 2 +, + fileUpload.getFilename().length() + fileUpload.getName().length());, +, + replacement.append("--");, + replacement.append(multipartDataBoundary);, + replacement.append("\r\n");, +, + replacement.append(HttpPostBodyUtil.ATTACHMENT);, + pastAttribute.setValue("", 2);, +, + internal.addValue(HttpPostBodyUtil.CONTENT_DISPOSITION + ": " + HttpPostBodyUtil.ATTACHMENT + "; ", +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, + final List<InterfaceHttpData> multipartHttpDatas;, + String multipartDataBoundary;, + String multipartMixedBoundary;, + 139 + multipartDataBoundary.length() + multipartMixedBoundary.length() * 2 +, + fileUpload.getFilename().length() + fileUpload.getName().length());, +, + replacement.append("--");, + replacement.append(multipartDataBoundary);, + replacement.append("\r\n");, +, + replacement.append(HttpPostBodyUtil.ATTACHMENT);, + pastAttribute.setValue("", 2);, +, + internal.addValue(HttpPostBodyUtil.CONTENT_DISPOSITION + ": " + HttpPostBodyUtil.ATTACHMENT + "; ", +++
[+++ b/all/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/example/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6</version>, +++ b/codec/pom.xml, +
[+++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.handler.logging.LoggingHandler;, +import io.netty.logging.InternalLogLevel;, + s.pipeline().addLast("logger", new LoggingHandler(InternalLogLevel.INFO));]
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, + * (using {@link AttributeKey}s) which is specific to the handler., + * public void channelRead0({@link ChannelHandlerContext} ctx, Message message) {, + * <h4>Using {@link AttributeKey}</h4>, + * In such a case, you can use {@link AttributeKey}s which is provided by, + * {@link Attribute}&lt{@link Boolean}&gt attr = ctx.attr(auth);, + * Now that the state of the handler isattached to the {@link ChannelHandlerContext}, you can add the, + * In the example above which used an {@link AttributeKey},, +++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, + * (using {@link AttributeKey}s) which is specific to the handler., + * public void channelRead0({@link ChannelHandlerContext}
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import java.nio.charset.CodingErrorAction;, + /**, + * Returns {@code true} if the given {@link ByteBuf} is valid text using the given {@link Charset},, + * otherwise return {@code false}., + *, + * @param buf The given {@link ByteBuf}., + * @param charset The specified {@link Charset}., + */, + public static boolean isText(ByteBuf buf, Charset charset) {, + return isText(buf, buf.readerIndex(), buf.readableBytes(), charset);, + }, +, + /**, + * Returns {@code true} if the specified {@link ByteBuf} starting at {@code index} with {@code length} is valid, + * text using the given {@link Charset}, otherwise return
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, + encodeAscii(header, buf);, + encodeAscii(value, buf);, + private static void encodeAscii(String s, ByteBuf buf) {, + for (int i = 0; i < s.length(); i++) {, + buf.writeByte(s.charAt(i));, + }, + }, +]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + // Check if the closure of the connection signifies the end of the content., + if (!prematureClosure) {, + if (actualContentLength == 0) {, + out.add(LastHttpContent.EMPTY_LAST_CONTENT);, + } else {, + out.add(new DefaultLastHttpContent(content));, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + // Check if the closure of the connection signifies the end of the content., + if (!prematureClosure) {, + if (actualContentLength == 0) {, + out.add(LastHttpContent.EMPTY_LAST_CONTENT);, + } else {, + out.add(new DefaultLastHttpContent(content));, + }, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java, + public void testLastResponseWithEmptyHeaderAndEmptyContent() {, +, + @Test, + public void testLastResponseWithoutContentLengthHeader() {, + EmbeddedChannel ch = new EmbeddedChannel(new HttpResponseDecoder());, +
[+++ b/common/src/main/java/io/netty/util/internal/InternalThreadLocalMap.java, + private static final int STRING_BUILDER_MAX_CAPACITY = 1024 << 6;, + if (builder == null || builder.capacity() > STRING_BUILDER_MAX_CAPACITY) {]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + ByteBuf buf = alloc.buffer(utf8MaxBytes(seq));, + buf.ensureWritable(utf8MaxBytes(seq));, + * Returns max bytes length of UTF8 character sequence., + */, + public static int utf8MaxBytes(CharSequence seq) {, + return seq.length() * MAX_BYTES_PER_CHAR_UTF8;, + }, +, + /**, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + ByteBuf buf = alloc.buffer(utf8MaxBytes(seq));, + buf.ensureWritable(utf8MaxBytes(seq));, + * Returns max bytes length of UTF8 character sequence., + */, + public static int utf8MaxBytes(CharSequence seq) {, + return seq.length() * MAX_BYTES_PER_CHAR_UTF8;, + }, +, + /**, +++ b/codec-redis/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<!--, + ~ Copyright 2016 The Netty Project, + ~, + ~ The Netty Project licenses this file
[+++ b/pom.xml, + <version>3.1.0.ALPHA2-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/pom.xml, + ${project.groupId}.container.osgi.NettyBundleActivator, +++ b/pom.xml, + ${project.groupId}.container.osgi.NettyBundleActivator, +++ /dev/null, +++ b/pom.xml, + ${project.groupId}.container.osgi.NettyBundleActivator, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/container/osgi/NettyBundleActivator.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2009, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import java.io.IOException;, +import java.io.OutputStream;, + static final int WRITE_CHUNK_SIZE = 8192;, + /**, + * Read bytes from the given {@link ByteBuffer} into the given {@link OutputStream} using the {@code position} and, + * {@code length}. The position and limit of the given {@link ByteBuffer} may be adjusted., + */, + static void readBytes(ByteBufAllocator allocator, ByteBuffer buffer, int position, int length, OutputStream out), + throws IOException {, + if (buffer.hasArray()) {, + out.write(buffer.array(), position + buffer.arrayOffset(), length);, + } else {, + int chunkLen = Math.min(length, WRITE_CHUNK_SIZE);, + buffer.clear().position(position);, +, + if (allocator.isDirectBufferPooled()) {, + // if
[+++ b/all/pom.xml, + <version>4.1.18.Final</version>, +++ b/all/pom.xml, + <version>4.1.18.Final</version>, +++ b/bom/pom.xml, + <version>4.1.18.Final</version>, + <tag>netty-4.1.18.Final</tag>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, +++ b/all/pom.xml, + <version>4.1.18.Final</version>, +++ b/bom/pom.xml, + <version>4.1.18.Final</version>, + <tag>netty-4.1.18.Final</tag>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, + <version>4.1.18.Final</version>, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + public SSLEngineResult wrap(, + synchronized (this) {, + // Check to make sure the engine has not been closed, + if (isDestroyed()) {, + return CLOSED_NOT_HANDSHAKING;, + }, +, + // If there is no pending data to read from BIO we should go back to event loop and try, + // to read more data [1]. It is also possible that event loop will detect the socket, + // has been closed. [1] https://www.openssl.org/docs/manmaster/ssl/SSL_write.html, + new SSLEngineResult(getEngineStatus(),, + NEED_UNWRAP, bytesConsumed, bytesProduced);, + // SSL_ERROR_WANT_WRITE typically means that the underlying transport is not writable, + //
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.internal.SystemPropertyUtil;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(AbstractByteBuf.class);, + private static final String PROP_MODE = "io.netty.buffer.bytebuf.checkAccessible";, + private static final boolean checkAccessible;, +, + static {, + checkAccessible = SystemPropertyUtil.getBoolean(PROP_MODE, true);, + if (logger.isDebugEnabled()) {, + logger.debug("-D{}: {}", PROP_MODE, checkAccessible);, + }, + }, + if (checkAccessible && refCnt() == 0) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.internal.SystemPropertyUtil;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(AbstractByteBuf.class);, + private static final String PROP_MODE = "io.netty.buffer.bytebuf.checkAccessible";, + private static final boolean checkAccessible;, +, + static {, + checkAccessible = SystemPropertyUtil.getBoolean(PROP_MODE, true);,
[+++ b/.gitignore, +/src/main/java/org/jboss/netty/util/Version.java]
[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutorGroup.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java, + out.ensureWritable(maxOutputLength);]
[+++ b/all/pom.xml, + <version>4.1.20.Final</version>, +++ b/all/pom.xml, + <version>4.1.20.Final</version>, +++ b/bom/pom.xml, + <version>4.1.20.Final</version>, + <tag>netty-4.1.20.Final</tag>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, +++ b/all/pom.xml, + <version>4.1.20.Final</version>, +++ b/bom/pom.xml, + <version>4.1.20.Final</version>, + <tag>netty-4.1.20.Final</tag>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, + <version>4.1.20.Final</version>, +
[+++ b/codec-mqtt/pom.xml, +++ b/codec-mqtt/pom.xml, +++ b/handler/pom.xml, +++ b/codec-mqtt/pom.xml, +++ b/handler/pom.xml, +++ b/pom.xml, + <groupId>org.hamcrest</groupId>, + <artifactId>hamcrest-library</artifactId>, + <version>1.3</version>, + <scope>test</scope>, + </dependency>, + <dependency>, + <exclusions>, + <exclusion>, + <groupId>junit</groupId>, + <artifactId>junit-dep</artifactId>, + </exclusion>, + </exclusions>, + <artifactId>mockito-core</artifactId>, + <version>1.10.8</version>, + <groupId>org.hamcrest</groupId>, + <artifactId>hamcrest-library</artifactId>, + <scope>test</scope>, + </dependency>, + <dependency>, + <groupId>org.mockito</groupId>, + <artifactId>mockito-core</artifactId>, + <scope>test</scope>, + </dependency>, + <dependency>]
[+++ b/codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java, +++ b/codec/src/test/java/io/netty/handler/codec/json/JsonObjectDecoderTest.java, + public void testStreamJsonArrayOverMultipleWrites() {, + EmbeddedChannel ch = new EmbeddedChannel(new JsonObjectDecoder(true));, +, + String arrayPart1 = "[{\"test";, + String arrayPart2 = "case\" : \"\\\"}]Escaped dou\\\"ble quotes \\\" in JSON str\\\"ing\"";, + String arrayPart3 = " }\n\n , ";, + String arrayPart4 = "{\"testcase\" : \"Streaming string me";, + String arrayPart5 = "ssage\"} ]";, +, + // Test array, + boolean dataAvailable = ch.writeInbound(Unpooled.copiedBuffer(" " + arrayPart1, CharsetUtil.UTF_8));, + assertFalse(dataAvailable);, + dataAvailable = ch.writeInbound(Unpooled.copiedBuffer(arrayPart2, CharsetUtil.UTF_8));, + assertFalse(dataAvailable);, + dataAvailable = ch.writeInbound(Unpooled.copiedBuffer(arrayPart3, CharsetUtil.UTF_8));, + assertTrue(dataAvailable);, + dataAvailable = ch.writeInbound(Unpooled.copiedBuffer(arrayPart4, CharsetUtil.UTF_8));, + assertTrue(dataAvailable);, + dataAvailable
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsClass.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/CompressorHttp2ConnectionEncoder.java, + public void onStreamRemoved(Http2Stream stream) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/CompressorHttp2ConnectionEncoder.java, + public void onStreamRemoved(Http2Stream stream) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +, +import io.netty.buffer.ByteBuf;, + public void goAwayReceived(int lastKnownStream, long errorCode, ByteBuf debugData) {, + boolean alreadyNotified = goAwayReceived();, + if (!alreadyNotified) {, + for (Listener listener : listeners) {, + listener.onGoAwayReceived(lastKnownStream, errorCode, debugData);, + }, + }, + public void goAwaySent(int lastKnownStream, long errorCode, ByteBuf debugData) {, + boolean alreadyNotified = goAwaySent();, + if (!alreadyNotified) {, + for (Listener listener : listeners) {, + listener.onGoAwaySent(lastKnownStream, errorCode, debugData);, + }, + }, + listener.onStreamRemoved(stream);, + listener.onStreamActive(this);, + listener.onStreamClosed(this);, + listener.onStreamHalfClosed(stream);, + l.onPriorityTreeParentChanged(stream,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskAttribute.java, + public static final String prefix = "Attr_";, + public static final String postfix = ".att";, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskAttribute.java, + public static final String prefix = "Attr_";, + public static final String postfix = ".att";, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskFileUpload.java, + public static final String prefix = "FUp_";, + public static final String postfix = ".tmp";, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskAttribute.java, + public static final String prefix = "Attr_";, + public static final String postfix = ".att";, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskFileUpload.java, + public static final String prefix = "FUp_";, + public static final String postfix = ".tmp";, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostBodyUtil.java, + public static final int chunkSize =
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + flowController.receiveFlowControlledFrame(stream, data, padding, endOfStream);, + flowController.consumeBytes(stream, bytesToReturn);, + flowController.receiveFlowControlledFrame(stream, data, padding, endOfStream);, + flowController.consumeBytes(stream, bytesToReturn);, + encoder.flowController().incrementWindowSize(stream, windowSizeIncrement);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + flowController.receiveFlowControlledFrame(stream, data, padding, endOfStream);, + flowController.consumeBytes(stream, bytesToReturn);, + flowController.receiveFlowControlledFrame(stream, data, padding, endOfStream);, + flowController.consumeBytes(stream, bytesToReturn);, + encoder.flowController().incrementWindowSize(stream, windowSizeIncrement);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + flowController().addFlowControlled(stream,, + new FlowControlledData(stream, data, padding, endOfStream, promise));, + flowController().addFlowControlled(stream,, + new FlowControlledHeaders(stream, headers, streamDependency, weight, exclusive, padding,, + endOfStream, promise));, + private FlowControlledData(Http2Stream stream, ByteBuf buf, int padding, boolean endOfStream,, + ChannelPromise promise) {, + super(stream, padding, endOfStream, promise);, + queue = new CoalescingBufferQueue(promise.channel());, + public void error(ChannelHandlerContext ctx, Throwable cause) {, +
[+++ b/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingDecoderTest.java, +public abstract class AbstractCompatibleMarshallingDecoderTest extends AbstractMarshallingTest {, +++ b/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingDecoderTest.java, +public abstract class AbstractCompatibleMarshallingDecoderTest extends AbstractMarshallingTest {, +++ b/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingEncoderTest.java, +public abstract class AbstractCompatibleMarshallingEncoderTest extends AbstractMarshallingTest {, +++ b/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingDecoderTest.java, +public abstract class AbstractCompatibleMarshallingDecoderTest extends AbstractMarshallingTest {, +++ b/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractCompatibleMarshallingEncoderTest.java, +public abstract class AbstractCompatibleMarshallingEncoderTest extends AbstractMarshallingTest {, +++ b/codec/src/test/java/io/netty/handler/codec/marshalling/AbstractMarshallingTest.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_setTcpKeepIdle(JNIEnv *env, jclass clazz, jint fd, jint optval) {, + setOption(env, fd, SOL_TCP, TCP_KEEPIDLE, &optval, sizeof(optval));, +}, +, +JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_setTcpKeepIntvl(JNIEnv *env, jclass clazz, jint fd, jint optval) {, + setOption(env, fd, SOL_TCP, TCP_KEEPINTVL, &optval, sizeof(optval));, +}, +, +JNIEXPORT void Java_io_netty_channel_epoll_Native_setTcpKeepCnt(JNIEnv *env, jclass clazz, jint fd, jint optval) {, + setOption(env, fd, SOL_TCP, TCP_KEEPCNT, &optval, sizeof(optval));, +}, +, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_getTcpKeepIdle(JNIEnv *env, jclass clazz, jint fd) {, + int optval;, + if (getOption(env, fd, SOL_TCP, TCP_KEEPIDLE, &optval, sizeof(optval)) == -1) {, + return -1;, + }, + return optval;, +}, +, +JNIEXPORT
[+++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/AbstractSocksMessage.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, +import io.netty.buffer.BufUtil;, + private boolean continueResponse;, + BufUtil.retain(msg);, + if (!(msg instanceof LastHttpContent)) {, + continueResponse = true;, +, + if (continueResponse) {, + if (msg instanceof LastHttpContent) {, + continueResponse = false;, + }, + // 100-continue response must be passed through., + BufUtil.retain(msg);, + return msg;, + }, +]
[+++ b/codec/src/test/java/io/netty/handler/codec/json/JsonObjectDecoderTest.java, + try {, + } finally {, + assertFalse(ch.finish());, + }, + try {, + } finally {, + assertFalse(ch.finish());, + }, + try {, + } finally {, + assertFalse(ch.finish());, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + p.replaceAndForward(ctx.name(), "ws-decoder", newWebsocketDecoder());]
[+++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxyFrontendHandler.java, + // As we use inboundChannel.eventLoop() when buildling the Bootstrap this does not need to be volatile as, + // the outboundChannel will use the same EventLoop (and therefore Thread) as the inboundChannel., + private Channel outboundChannel;]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + this.uri = uri.toASCIIString().replace(';', '&');, + hasPath = false;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + this.uri = uri.toASCIIString().replace(';', '&');, + hasPath = false;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + this.uri = uri.toASCIIString().replace(';', '&');, + hasPath = false;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, + private final SpdyFrameDecoder decoder = new SpdyFrameDecoder();, + private final SpdyFrameEncoder encoder = new SpdyFrameEncoder();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + this.uri = uri.toASCIIString().replace(';', '&');, + hasPath = false;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, + private final SpdyFrameDecoder decoder = new SpdyFrameDecoder();, + private final SpdyFrameEncoder encoder = new SpdyFrameEncoder();, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + super();, + spdyDataFrame.setCompressed((flags & SPDY_DATA_FLAG_COMPRESS) != 0);, + spdyDataFrame.setData(buffer.readBytes(dataLength));, +
[+++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxyInitializer.java, +import io.netty.handler.logging.ByteLoggingHandler;, + new ByteLoggingHandler(LogLevel.INFO),]
[+++ b/pom.xml, + <version>[3.0.2,)</version>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java, +import io.netty.buffer.BufUtil;, +import io.netty.handler.codec.DecoderException;, +import java.util.Iterator;, +public class HttpPostRequestDecoder implements Iterator<InterfaceHttpData> {, + public HttpPostRequestDecoder offer(HttpContent content) throws ErrorDataDecoderException {, + // Maybe we should better not copy here for performance reasons but this will need, + // more care by teh caller to release the content in a correct manner later, + // So maybe something to optimize on a later stage, + ByteBuf chunked = content.content().copy();, + return this;, + setFinalBuffer(undecodedChunk.slice(firstpos, ampersandpos - firstpos).retain());, + setFinalBuffer(undecodedChunk.slice(firstpos, ampersandpos - firstpos).retain());, + setFinalBuffer(undecodedChunk.slice(firstpos, ampersandpos - firstpos).retain());, + setFinalBuffer(undecodedChunk.slice(firstpos, ampersandpos - firstpos).retain());, + currentAttribute.addContent(undecodedChunk.slice(firstpos, currentpos - firstpos).retain(), false);,
[+++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, + checkIndex(index, dst.remaining());, + tmpBuf.clear().position(index).limit(index + dst.remaining());, +++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, + checkIndex(index, dst.remaining());, + tmpBuf.clear().position(index).limit(index + dst.remaining());, +++ b/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java, + checkIndex(index, dst.remaining());, + dst.put(memory, idx(index), dst.remaining());, +++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, + checkIndex(index, dst.remaining());, + tmpBuf.clear().position(index).limit(index + dst.remaining());, +++ b/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java, + checkIndex(index, dst.remaining());, + dst.put(memory, idx(index), dst.remaining());, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + checkIndex(index, dst.remaining());, + tmpBuf.clear().position(index).limit(index + dst.remaining());, +++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, + checkIndex(index, dst.remaining());, + tmpBuf.clear().position(index).limit(index + dst.remaining());, +++ b/buffer/src/main/java/io/netty/buffer/PooledHeapByteBuf.java, + checkIndex(index, dst.remaining());, + dst.put(memory, idx(index), dst.remaining());, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + checkIndex(index, dst.remaining());, + tmpBuf.clear().position(index).limit(index + dst.remaining());, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java, + checkIndex(index, dst.remaining());, + dst.put(array, index, dst.remaining());, +++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, + checkIndex(index, dst.remaining());, + tmpBuf.clear().position(index).limit(index + dst.remaining());,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionStatus.java, + * 2 Internal Error, + new SpdySessionStatus(2, "INTERNAL_ERROR");, + case 2:]
[+++ /dev/null, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, +@Deprecated, + @Deprecated, + return io.netty.handler.codec.http.cookie.ClientCookieEncoder.LAX.encode(name, value);, + @Deprecated, + return io.netty.handler.codec.http.cookie.ClientCookieEncoder.LAX.encode(cookie);, + @Deprecated, + return io.netty.handler.codec.http.cookie.ClientCookieEncoder.LAX.encode(cookies);, + @Deprecated, + return io.netty.handler.codec.http.cookie.ClientCookieEncoder.LAX.encode(cookies);, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, +@Deprecated, + @Deprecated, + return io.netty.handler.codec.http.cookie.ClientCookieEncoder.LAX.encode(name, value);, + @Deprecated, + return io.netty.handler.codec.http.cookie.ClientCookieEncoder.LAX.encode(cookie);, + @Deprecated, + return io.netty.handler.codec.http.cookie.ClientCookieEncoder.LAX.encode(cookies);, + @Deprecated, + return io.netty.handler.codec.http.cookie.ClientCookieEncoder.LAX.encode(cookies);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + * @deprecated Use {@link io.netty.handler.codec.http.cookie.Cookie} instead., +@Deprecated, +public interface Cookie extends io.netty.handler.codec.http.cookie.Cookie {, + *, + * @deprecated Not part of RFC6265, + @Deprecated, + *, + * @deprecated Not part of RFC6265, + @Deprecated, + *, + * @deprecated Not part
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, + // file.exists() may throw a SecurityException if a SecurityManager is used, so execute it in the, + // try / catch block., + // See https://github.com/netty/netty/issues/4936, + if (file.exists()) {, + } else {, + if (logger.isDebugEnabled()) {, + logger.debug("{}: {} (non-existent)", file, somaxconn);, + }, + }]
[+++ b/codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java, +import java.nio.ByteOrder;, +, + private final ByteOrder byteOrder;, + int maxFrameLength, int lengthFieldOffset, int lengthFieldLength,, + this(, + ByteOrder.BIG_ENDIAN, maxFrameLength, lengthFieldOffset, lengthFieldLength,, + lengthAdjustment, initialBytesToStrip, failFast);, + }, +, + /**, + * Creates a new instance., + *, + * @param byteOrder, + * the {@link ByteOrder} of the length field, + * @param maxFrameLength, + * the maximum length of the frame. If the length of the frame is, + * greater than this value, {@link TooLongFrameException} will be, + * thrown., + * @param lengthFieldOffset, + * the offset of the length field, +
[+++ b/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java, + int ret = buffer.forEachByte(fromIndex + adjustment, toIndex + adjustment, new SlicedByteBufProcessor(processor));, + if (ret >= adjustment) {, + return ret - adjustment;, + } else {, + return -1;, + }, + }, +, + private final class SlicedByteBufProcessor implements ByteBufProcessor {, + private final ByteBufProcessor processor;, +, + SlicedByteBufProcessor(ByteBufProcessor processor) {, + if (processor == null) {, + throw new NullPointerException("processor");, + }, + this.processor = processor;, + }, +, + @Override, + public int process(ByteBuf buf, int index, byte value) throws Exception {, + return processor.process(buf, index - adjustment, value);, + }, +++ b/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java,
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelPromise.java, + if (!isDone()) {, + return this;, + if (set(SUCCESS)) {, + if (set(SUCCESS)) {, + if (set(cause)) {, + if (set(cause)) {, + private boolean set(Throwable cause) {]
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +, + private static final ThreadLocal<MessageBuf<Object>> decoderOutput =, + new ThreadLocal<MessageBuf<Object>>() {, + @Override, + protected MessageBuf<Object> initialValue() {, + return Unpooled.messageBuffer();, + }, + };, + try {, + }, + }, + }, + return decoderOutput.get();, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +, + private static final ThreadLocal<MessageBuf<Object>> decoderOutput =, + new ThreadLocal<MessageBuf<Object>>() {, + @Override, + protected MessageBuf<Object> initialValue() {, + return Unpooled.messageBuffer();, + }, + };, + try {, + }, + }, + }, + return decoderOutput.get();, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, +, + assert out.isEmpty();, +, + try {, + }, + }, + }]
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, + int percentPos = ipAddressString.indexOf('%');, + if (percentPos >= 0) {, + ipAddressString = ipAddressString.substring(0, percentPos);, + }, +]
[+++ b/example/src/main/java/io/netty/example/sctp/NioSctpEchoClient.java, +import io.netty.channel.sctp.SctpChannel;, +import io.netty.channel.sctp.nio.NioSctpChannel;, +++ b/example/src/main/java/io/netty/example/sctp/NioSctpEchoClient.java, +import io.netty.channel.sctp.SctpChannel;, +import io.netty.channel.sctp.nio.NioSctpChannel;, +++ b/example/src/main/java/io/netty/example/sctp/NioSctpEchoServer.java, +import io.netty.channel.sctp.SctpChannel;, +import io.netty.channel.sctp.nio.NioSctpServerChannel;, +++ b/example/src/main/java/io/netty/example/sctp/NioSctpEchoClient.java, +import io.netty.channel.sctp.SctpChannel;, +import io.netty.channel.sctp.nio.NioSctpChannel;, +++ b/example/src/main/java/io/netty/example/sctp/NioSctpEchoServer.java, +import io.netty.channel.sctp.SctpChannel;, +import io.netty.channel.sctp.nio.NioSctpServerChannel;, +++ b/example/src/main/java/io/netty/example/sctp/OioSctpEchoClient.java, +import io.netty.channel.sctp.SctpChannel;, +import io.netty.channel.sctp.oio.OioSctpChannel;, +++ b/example/src/main/java/io/netty/example/sctp/NioSctpEchoClient.java, +import io.netty.channel.sctp.SctpChannel;, +import io.netty.channel.sctp.nio.NioSctpChannel;, +++ b/example/src/main/java/io/netty/example/sctp/NioSctpEchoServer.java, +import io.netty.channel.sctp.SctpChannel;, +import io.netty.channel.sctp.nio.NioSctpServerChannel;, +++ b/example/src/main/java/io/netty/example/sctp/OioSctpEchoClient.java, +import io.netty.channel.sctp.SctpChannel;, +import io.netty.channel.sctp.oio.OioSctpChannel;, +++ b/example/src/main/java/io/netty/example/sctp/OioSctpEchoServer.java, +import io.netty.channel.sctp.SctpChannel;, +import io.netty.channel.sctp.oio.OioSctpServerChannel;, +++ b/example/src/main/java/io/netty/example/sctp/NioSctpEchoClient.java, +import io.netty.channel.sctp.SctpChannel;, +import io.netty.channel.sctp.nio.NioSctpChannel;, +++ b/example/src/main/java/io/netty/example/sctp/NioSctpEchoServer.java, +import io.netty.channel.sctp.SctpChannel;, +import io.netty.channel.sctp.nio.NioSctpServerChannel;, +++ b/example/src/main/java/io/netty/example/sctp/OioSctpEchoClient.java, +import io.netty.channel.sctp.SctpChannel;, +import io.netty.channel.sctp.oio.OioSctpChannel;, +++ b/example/src/main/java/io/netty/example/sctp/OioSctpEchoServer.java, +import io.netty.channel.sctp.SctpChannel;, +import io.netty.channel.sctp.oio.OioSctpServerChannel;, +++ b/example/src/main/java/io/netty/example/sctp/SctpEchoClientHandler.java, +import io.netty.channel.sctp.SctpMessage;, +++ b/example/src/main/java/io/netty/example/sctp/NioSctpEchoClient.java, +import io.netty.channel.sctp.SctpChannel;, +import io.netty.channel.sctp.nio.NioSctpChannel;, +++ b/example/src/main/java/io/netty/example/sctp/NioSctpEchoServer.java, +import io.netty.channel.sctp.SctpChannel;, +import
[+++ b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java, + request.release();, +, + content.release();]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java, + int writerIndex = decompressed.writerIndex();, + int outIndex = decompressed.arrayOffset() + writerIndex;, + int length = decompressed.writableBytes();, + decompressed.writerIndex(writerIndex + outputLength);, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java, + int writerIndex = decompressed.writerIndex();, + int outIndex = decompressed.arrayOffset() + writerIndex;, + int length = decompressed.writableBytes();, + decompressed.writerIndex(writerIndex + outputLength);, +++ b/codec/src/test/java/io/netty/handler/codec/compression/ZlibTest.java, +import java.io.OutputStream;, +import java.util.zip.DeflaterOutputStream;, + private static final byte[] BYTES_LARGE2 = ("<!--?xml version=\"1.0\" encoding=\"ISO-8859-1\"?-->\n" +, + "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" " +, + "\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n" +, + "<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\"><head>\n" +, + " <title>Apache Tomcat</title>\n" +, + "</head>\n" +, + '\n' +, + "<body>\n" +, + "<h1>It works
[+++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java, +, + @Override, + public int forEachByte(int fromIndex, int toIndex, ByteBufProcessor processor) {, + return buffer.forEachByte(fromIndex, toIndex, processor);, + }, +++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java, +, + @Override, + public int forEachByte(int fromIndex, int toIndex, ByteBufProcessor processor) {, + return buffer.forEachByte(fromIndex, toIndex, processor);, + }, +++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java, + public int forEachByte(int fromIndex, int toIndex, ByteBufProcessor processor) {, + return buffer.forEachByte(fromIndex, toIndex, processor);, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java, +, + @Override, + public int forEachByte(int fromIndex, int toIndex, ByteBufProcessor processor) {, + return buffer.forEachByte(fromIndex, toIndex, processor);, + }, +++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java, + public int forEachByte(int fromIndex, int toIndex, ByteBufProcessor processor)
[+++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java, + private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);, + private final long readerIdleTimeNanos;, + private final long writerIdleTimeNanos;, + private final long allIdleTimeNanos;, + readerIdleTimeNanos = 0;, + readerIdleTimeNanos = Math.max(unit.toNanos(readerIdleTime), MIN_TIMEOUT_NANOS);, + writerIdleTimeNanos = 0;, + writerIdleTimeNanos = Math.max(unit.toNanos(writerIdleTime), MIN_TIMEOUT_NANOS);, + allIdleTimeNanos = 0;, + allIdleTimeNanos = Math.max(unit.toNanos(allIdleTime), MIN_TIMEOUT_NANOS);, + return TimeUnit.NANOSECONDS.toMillis(readerIdleTimeNanos);, + return TimeUnit.NANOSECONDS.toMillis(writerIdleTimeNanos);, + return TimeUnit.NANOSECONDS.toMillis(allIdleTimeNanos);, + lastReadTime = System.nanoTime();, + lastWriteTime = System.nanoTime();, + lastReadTime = lastWriteTime = System.nanoTime();, + if (readerIdleTimeNanos > 0) {, + readerIdleTimeNanos, TimeUnit.NANOSECONDS);, + if (writerIdleTimeNanos > 0) {, + writerIdleTimeNanos, TimeUnit.NANOSECONDS);, + if (allIdleTimeNanos > 0) {,
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +import io.netty.channel.ChannelHandlerUtil;, + if (ChannelHandlerUtil.unfoldAndAdd(ctx, decodeLast(ctx, in), true)) {, + if (ChannelHandlerUtil.unfoldAndAdd(ctx, o, true)) {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +import io.netty.channel.ChannelHandlerUtil;, + if (ChannelHandlerUtil.unfoldAndAdd(ctx, decodeLast(ctx, in), true)) {, + if (ChannelHandlerUtil.unfoldAndAdd(ctx, o, true)) {, +++ /dev/null, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +import io.netty.channel.ChannelHandlerUtil;, + if (ChannelHandlerUtil.unfoldAndAdd(ctx, decodeLast(ctx, in), true)) {, + if (ChannelHandlerUtil.unfoldAndAdd(ctx, o, true)) {, +++ /dev/null, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +import io.netty.channel.ChannelHandlerUtil;, + this.acceptedMsgTypes = ChannelHandlerUtil.acceptedMessageTypes(acceptedMsgTypes);, + ChannelHandlerUtil.addToNextOutboundBuffer(ctx, msg);, + return ChannelHandlerUtil.acceptMessage(acceptedMsgTypes, msg);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +import io.netty.channel.ChannelHandlerUtil;, + if (ChannelHandlerUtil.unfoldAndAdd(ctx, decodeLast(ctx, in), true)) {, + if (ChannelHandlerUtil.unfoldAndAdd(ctx, o, true)) {, +++ /dev/null, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +import io.netty.channel.ChannelHandlerUtil;, + this.acceptedMsgTypes = ChannelHandlerUtil.acceptedMessageTypes(acceptedMsgTypes);, + ChannelHandlerUtil.addToNextOutboundBuffer(ctx,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java]
[+++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java, + "specify the JVM option '-D{}={}' or call {}.setLevel() " +, + "See http://netty.io/wiki/reference-counted-objects.html for more information.",, + "LEAK: {}.release() was not called before it's garbage-collected. " +, + "See http://netty.io/wiki/reference-counted-objects.html for more information.{}",, + @Override, +++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java, + "specify the JVM option '-D{}={}' or call {}.setLevel() " +, + "See http://netty.io/wiki/reference-counted-objects.html for more information.",, + "LEAK: {}.release() was not called before it's garbage-collected. " +, + "See http://netty.io/wiki/reference-counted-objects.html for more information.{}",, + @Override, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + OpenSslEngine.class.getSimpleName() + " will be unavailable. " +, + "See http://netty.io/wiki/forked-tomcat-native.html for more information.", t);]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import io.netty.buffer.ByteBufAllocator;, + certBio = ReferenceCountedOpenSslContext.toBIO(ByteBufAllocator.DEFAULT, cert.cert());, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import io.netty.buffer.ByteBufAllocator;, + certBio = ReferenceCountedOpenSslContext.toBIO(ByteBufAllocator.DEFAULT, cert.cert());, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterialManager.java, + setKeyMaterial(ssl, alias, engine.alloc);, + keyCertChainBio = toBIO(engine.alloc, certificates);, + keyBio = toBIO(engine.alloc, key);, + private void setKeyMaterial(long ssl, String alias, ByteBufAllocator allocator) throws SSLException {, + PemEncoded encoded = PemX509Certificate.toPEM(allocator, true, certificates);, + keyCertChainBio = toBIO(allocator, encoded.retain());, + keyCertChainBio2 = toBIO(allocator, encoded.retain());, + keyBio = toBIO(allocator, key);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import io.netty.buffer.ByteBufAllocator;, + certBio = ReferenceCountedOpenSslContext.toBIO(ByteBufAllocator.DEFAULT, cert.cert());, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterialManager.java, + setKeyMaterial(ssl, alias, engine.alloc);, + keyCertChainBio = toBIO(engine.alloc, certificates);, + keyBio = toBIO(engine.alloc, key);, + private void setKeyMaterial(long ssl, String
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, + * <strong>Be aware that calling this method will clear the contends of the {@link CookieEncoder}</strong>, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, + * <strong>Be aware that calling this method will clear the contends of the {@link CookieEncoder}</strong>, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + , + int wsPort = wsURL.getPort();, + String originValue = "http://" + wsURL.getHost();, + if (wsPort != 80 && wsPort != 443) {, + // if the port is not standard (80/443) its needed to add the port to the header. , + // See http://tools.ietf.org/html/rfc6454#section-6.2, + originValue = originValue + ":" + wsPort;, + }, + , +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java,
[+++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java, +public class ReadTimeoutHandler extends IdleStateHandler {, + super(timeout, 0, 0, unit);, + protected final void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) throws Exception {, + assert evt.state() == IdleState.READER_IDLE;, + readTimedOut(ctx);]
[+++ b/pom.xml, + <configuration>, + <attach>true</attach>, + </configuration>, + <artifactId>maven-antrun-plugin</artifactId>, + <executions>, + <execution>, + <id>write-version</id>, + <phase>compile</phase>, + <goals>, + <goal>run</goal>, + </goals>, + <configuration>, + <tasks>, + <echo message="${project.version}" file="${project.build.directory}/version.txt" />, + </tasks>, + </configuration>, + </execution>, + <execution>, + <id>add-license</id>, + <phase>package</phase>, + <goals>, + <goal>run</goal>, + </goals>, + <configuration>, + <tasks>, + <taskdef resource="net/sf/antcontrib/antlib.xml" />, + <if>, + <or>, + <equals arg2="jar" arg1="${project.packaging}" />, + <equals arg2="bundle" arg1="${project.packaging}" />, + </or>, + <then>, + <move file="${project.build.directory}/${project.build.finalName}.jar" tofile="${project.build.directory}/${project.build.finalName}.orig.jar" />, + <zip destfile="${project.build.directory}/${project.build.finalName}.jar">, + <zipfileset dir="${basedir}" prefix="META-INF/">, + <include name="LICENSE.*" />, + <include name="NOTICE.*" />, + <include
[+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +import io.netty.util.NettyRuntime;, + /*, + * We use 2 * available processors by default to reduce contention as we use 2 * available processors for the, + * number of EventLoops in NIO and EPOLL as well. If we choose a smaller number we will run into hot spots as, + * allocation and de-allocation needs to be synchronized on the PoolArena., + *, + * See https://github.com/netty/netty/issues/3888., + */, + final int defaultMinNumArena = NettyRuntime.availableProcessors() * 2;, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +import io.netty.util.NettyRuntime;, + /*, + * We use 2 * available processors by default to reduce contention
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessage.java, + * An interface that defines a HTTP message, providing common properties for, + * {@link HttpRequest} and {@link HttpResponse}., + * @see HttpResponse, + * @see HttpRequest, + * Gets the value of a header with the specified name. If there are, + * more than one values for the specified name, the first value is returned., + * @param name The name of the header to search, + * @return The first header value or {@code null} if there is no such header, + * Returns the values of headers with the specified name, +
[+++ b/common/src/main/java/io/netty/util/internal/RecyclableArrayList.java, +import java.util.List;, +import java.util.RandomAccess;, + checkNullElements(c);, + checkNullElements(c);, + return super.addAll(index, c);, + }, +, + private void checkNullElements(Collection<?> c) {, + if (c instanceof RandomAccess && c instanceof List) {, + // produce less garbage, + List<?> list = (List<?>) c;, + int size = list.size();, + for (int i = 0; i < size; i++) {, + if (list.get(i) == null) {, + throw new IllegalArgumentException("c contains null values");, + }, + }, + } else {, + }]
[+++ b/src/test/java/org/jboss/netty/bootstrap/AbstractSocketClientBootstrapTest.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2008, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version., + *, +
[+++ /dev/null, +++ /dev/null, +++ b/all/pom.xml, + <id>clean-first</id>, + <outputDirectory>${project.build.directory}/src</outputDirectory>, + <plugin>, + <groupId>org.codehaus.mojo</groupId>, + <artifactId>build-helper-maven-plugin</artifactId>, + <version>1.7</version>, + <executions>, + <execution>, + <id>add-source</id>, + <phase>generate-sources</phase>, + <goals>, + <goal>add-source</goal>, + </goals>, + <configuration>, + <sources>, + <source>target/src</source>, + </sources>, + </configuration>, + </execution>, + </executions>, + </plugin>, + <detectJavaApiLink>false</detectJavaApiLink>]
[+++ b/buffer/src/main/java/io/netty/buffer/HeapByteBufUtil.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/pom.xml, + <version>3.1.0.CR1-SNAPSHOT</version>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, +import io.netty.channel.embedded.EmbeddedStreamChannel;, + new EmbeddedStreamChannel(, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, +import io.netty.channel.embedded.EmbeddedStreamChannel;, + new EmbeddedStreamChannel(, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, +import io.netty.channel.embedded.EmbeddedStreamChannel;, + private EmbeddedStreamChannel decoder;, + ChannelBuffer newContent = ChannelBuffers.dynamicBuffer();, + decode(content, newContent);, + finishDecode(newContent);, + m.setContent(newContent);, + Integer.toString(newContent.readableBytes()));, + ChannelBuffer newContent = ChannelBuffers.dynamicBuffer();, + decode(content, newContent);, + if (newContent.readable()) {, + c.setContent(newContent);, + } else {, + return null;, + ChannelBuffer lastProduct = ChannelBuffers.dynamicBuffer();, + finishDecode(lastProduct);, + protected abstract EmbeddedStreamChannel newContentDecoder(String contentEncoding) throws Exception;, + private void decode(ChannelBuffer in, ChannelBuffer out) {, + decoder.writeInbound(in);, + fetchDecoderOutput(out);, + private void finishDecode(ChannelBuffer out) {, + fetchDecoderOutput(out);, + }, +, + private void fetchDecoderOutput(ChannelBuffer
[+++ b/handler/src/test/java/io/netty/handler/ssl/ConscryptJdkSslEngineInteropTest.java, +, + @Ignore("Ignore due bug in Conscrypt"), + @Override, + public void testSessionBindingEvent() throws Exception {, + // Ignore due bug in Conscrypt where the incorrect SSLSession object is used in the SSLSessionBindingEvent., + // See https://github.com/google/conscrypt/issues/593, + }, +++ b/handler/src/test/java/io/netty/handler/ssl/ConscryptJdkSslEngineInteropTest.java, +, + @Ignore("Ignore due bug in Conscrypt"), + @Override, + public void testSessionBindingEvent() throws Exception {, + // Ignore due bug in Conscrypt where the incorrect SSLSession object is used in the SSLSessionBindingEvent., + // See https://github.com/google/conscrypt/issues/593, + }, +++ b/handler/src/test/java/io/netty/handler/ssl/ConscryptSslEngineTest.java, +, + @Ignore("Ignore due bug in Conscrypt"), + @Override, + public void testSessionBindingEvent() throws Exception
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.MessageBuf;, +import io.netty.handler.codec.http.DefaultHttpChunk;, +import io.netty.handler.codec.http.HttpChunk;, +import io.netty.handler.codec.http.HttpConstants;, +import io.netty.handler.codec.http.HttpHeaders;, +import io.netty.handler.codec.http.HttpMethod;, +import io.netty.handler.codec.http.HttpRequest;, +import io.netty.handler.codec.http.HttpTransferEncoding;, +import io.netty.handler.stream.ChunkedMessageInput;, +, + buffer = ((HttpData) currentData).getChunk(sizeleft);, + buffer = ((HttpData) currentData).getChunk(size);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.MessageBuf;, +import io.netty.handler.codec.http.DefaultHttpChunk;, +import io.netty.handler.codec.http.HttpChunk;, +import io.netty.handler.codec.http.HttpConstants;, +import io.netty.handler.codec.http.HttpHeaders;, +import io.netty.handler.codec.http.HttpMethod;, +import io.netty.handler.codec.http.HttpRequest;, +import io.netty.handler.codec.http.HttpTransferEncoding;, +import io.netty.handler.stream.ChunkedMessageInput;, +, + buffer = ((HttpData) currentData).getChunk(sizeleft);, + buffer = ((HttpData) currentData).getChunk(size);, +++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java, +import static io.netty.buffer.Unpooled.*;, +import static io.netty.handler.codec.http.HttpHeaders.Names.*;, +, + responseContent.append(fileUpload.getString(fileUpload.getCharset()));]
[+++ b/all/pom.xml, + <configuration>, +++ b/all/pom.xml, + <configuration>, +++ b/example/pom.xml, + <!-- run-example.sh invokes this plugin to launch an example. -->, + <groupId>kr.motd.maven</groupId>, + <artifactId>exec-maven-plugin</artifactId>, + <executable>${java.home}/bin/java</executable>, + <commandlineArgs>, + ${argLine.common}, + ${argLine.bootcp}, + -classpath %classpath, + ${argLine.leak}, + ${argLine.coverage}, + ${argLine.example}, + ${exampleClass}, + </commandlineArgs>, +++ b/all/pom.xml, + <configuration>, +++ b/example/pom.xml, + <!-- run-example.sh invokes this plugin to launch an example. -->, + <groupId>kr.motd.maven</groupId>, + <artifactId>exec-maven-plugin</artifactId>, + <executable>${java.home}/bin/java</executable>, + <commandlineArgs>, + ${argLine.common}, + ${argLine.bootcp}, + -classpath %classpath, + ${argLine.leak}, + ${argLine.coverage}, + ${argLine.example}, + ${exampleClass}, + </commandlineArgs>, +++ b/pom.xml, + <configuration>, + <plugin>, + <groupId>kr.motd.maven</groupId>, + <artifactId>exec-maven-plugin</artifactId>, +
[+++ b/transport/src/main/java/io/netty/channel/oio/OioByteStreamChannel.java, +import java.nio.channels.ClosedChannelException;, + private static final InputStream CLOSED_IN = new InputStream() {, + @Override, + public int read() {, + return -1;, + }, + };, +, + private static final OutputStream CLOSED_OUT = new OutputStream() {, + @Override, + public void write(int b) throws IOException {, + throw new ClosedChannelException();, + }, + };, +, + InputStream is = this.is;, + if (is == null || is == CLOSED_IN) {, + return false;, + }, +, + OutputStream os = this.os;, + if (os == null || os == CLOSED_OUT) {, + return false;, + },
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java, + * {@link QueryStringEncoder} encoder = new {@link QueryStringEncoder}("/hello");]
[+++ b/codec/src/test/java/io/netty/handler/codec/compression/ZlibTest.java, + dispose(chDecoderGZip);, + dispose(chEncoder);, + dispose(chDecoderZlib);, + dispose(chEncoder);, + dispose(chDecoderZlib);, + private static void dispose(EmbeddedChannel ch) {, + if (ch.finish()) {, + for (;;) {, + Object msg = ch.readInbound();, + if (msg == null) {, + break;, + }, + ReferenceCountUtil.release(msg);, + }, + for (;;) {, + Object msg = ch.readOutbound();, + if (msg == null) {, + break;, + }, + ReferenceCountUtil.release(msg);, + }, + }, + }]
[+++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, + /**, + * Return {@link ByteBuf#toString()} without checking the reference count first. This is useful to implemement, + * {@link #toString()}., + */, + protected final String contentToString() {, + return data.toString();, + }, +, + return StringUtil.simpleClassName(this) + '(' + contentToString() + ')';, +++ b/buffer/src/main/java/io/netty/buffer/DefaultByteBufHolder.java, + /**, + * Return {@link ByteBuf#toString()} without checking the reference count first. This is useful to implemement, + * {@link #toString()}., + */, + protected final String contentToString() {, + return data.toString();, + }, +, + return StringUtil.simpleClassName(this) + '(' + contentToString() + ')';, +++ b/buffer/src/test/java/io/netty/buffer/DefaultByteBufHolderTest.java, +/*, + *
[+++ b/common/src/main/java/io/netty/util/AttributeKey.java, + * Returns {@code true} if a {@link AttributeKey} exists for the given {@code name}., + public static boolean exists(String name) {, + return pool.exists(name);, + }, +, + /**, + * Creates a new {@link AttributeKey} for the given {@param name} or fail with an, + * {@link IllegalArgumentException} if a {@link AttributeKey} for the given {@param name} exists., + */, + @SuppressWarnings("unchecked"), + public static <T> AttributeKey<T> newInstance(String name) {, + return (AttributeKey<T>) pool.newInstance(name);, + }, +, +++ b/common/src/main/java/io/netty/util/AttributeKey.java, + * Returns {@code true} if a {@link AttributeKey} exists for the given {@code name}., +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + if (c == '%' || c == '+') {]
[+++ b/resolver/src/main/java/io/netty/resolver/DefaultNameResolver.java, + // Note that InetSocketAddress.getHostName() will never incur a reverse lookup here,, + // because an unresolved address always has a host name., + promise.setSuccess(new InetSocketAddress(, + InetAddress.getByName(unresolvedAddress.getHostName()), unresolvedAddress.getPort()));]
[+++ b/all/pom.xml, + <version>4.0.0.CR3</version>, +++ b/all/pom.xml, + <version>4.0.0.CR3</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR3</version>, +++ b/all/pom.xml, + <version>4.0.0.CR3</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR3</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR3</version>, +++ b/all/pom.xml, + <version>4.0.0.CR3</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR3</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR3</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR3</version>, +++ b/all/pom.xml, + <version>4.0.0.CR3</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR3</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR3</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR3</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR3</version>, +++ b/all/pom.xml, + <version>4.0.0.CR3</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR3</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR3</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR3</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR3</version>, +++ b/common/pom.xml, + <version>4.0.0.CR3</version>, +++ b/all/pom.xml, + <version>4.0.0.CR3</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR3</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR3</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec/src/test/java/io/netty/handler/codec/compression/Bzip2IntegrationTest.java, +public class Bzip2IntegrationTest extends IntegrationTest {, + @Override, + protected EmbeddedChannel createEncoderEmbeddedChannel() {, + return new EmbeddedChannel(new Bzip2Encoder());, + @Override, + protected EmbeddedChannel createDecoderEmbeddedChannel() {, + return new EmbeddedChannel(new Bzip2Decoder());, +++ b/codec/src/test/java/io/netty/handler/codec/compression/Bzip2IntegrationTest.java, +public class Bzip2IntegrationTest extends IntegrationTest {, + @Override, + protected EmbeddedChannel createEncoderEmbeddedChannel() {, + return new EmbeddedChannel(new Bzip2Encoder());, + @Override, + protected EmbeddedChannel createDecoderEmbeddedChannel() {, + return new EmbeddedChannel(new Bzip2Decoder());, +++ b/codec/src/test/java/io/netty/handler/codec/compression/IntegrationTest.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpUtil.java, + setHttp2Scheme(inHeaders, requestTargetUri, out);, + if (!isOriginForm(requestTargetUri) && !isAsteriskForm(requestTargetUri)) {, + if (host == null || host.isEmpty()) {, + setHttp2Authority(inHeaders, requestTargetUri.getAuthority(), out);, + setHttp2Authority(inHeaders, host, out);, + private static void setHttp2Authority(HttpHeaders in, String autority, Http2Headers out) {, + if (autority != null) {, + int endOfUserInfo = autority.indexOf('@');, + out.authority(new AsciiString(autority));, + } else if (endOfUserInfo + 1 < autority.length()) {, + out.authority(new AsciiString(autority.substring(endOfUserInfo + 1)));, + } else {, + throw new IllegalArgumentException("autority: " + autority);, + private static void setHttp2Scheme(HttpHeaders in, URI uri, Http2Headers out) {, + return;, +, + return;, +, + if (uri.getPort()
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08Test.java, + return new WebSocketClientHandshaker08(uri, WebSocketVersion.V08, null, false, null, 1024);]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java, + for (;;) {, + if (deflater.needsInput()) {, + // Consumed everything, + break;, + } else {, + if (!out.isWritable()) {, + // We did not consume everything but the buffer is not writable anymore. Increase the capacity to, + // make more room., + out.ensureWritable(out.writerIndex());, + }, + }]
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, + } catch (Throwable ignore) {, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, + } catch (Throwable ignore) {, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + } catch (Throwable cause) {, + logger.debug("Unexpected exception while loading class {} classname {}",, + getClass(), classname, cause);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, + } catch (Throwable ignore) {, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + } catch (Throwable cause) {, + logger.debug("Unexpected exception while loading class {} classname {}",, + getClass(), classname, cause);, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelId.java, + ClassLoader loader = null;, + loader = PlatformDependent.getClassLoader(DefaultChannelId.class);, + } catch (Throwable t) {, + logger.debug("Could not invoke ManagementFactory.getRuntimeMXBean().getName(); Android?", t);, + } catch (Throwable t2) {, + logger.debug("Could not
[+++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + private final ResourceLeak leak;, + leak = leakDetector.open(this);, + leak = leakDetector.open(this);, + leak = leakDetector.open(this);, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + private final ResourceLeak leak;, + leak = leakDetector.open(this);, + leak = leakDetector.open(this);, + leak = leakDetector.open(this);, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + private final ResourceLeak leak;, + leak = leakDetector.open(this);, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + private final ResourceLeak leak;, + leak = leakDetector.open(this);, + leak = leakDetector.open(this);, + leak = leakDetector.open(this);, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + private final ResourceLeak leak;, + leak = leakDetector.open(this);, +++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java, + private final ResourceLeak leak;, + leak = leakDetector.open(this);, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + private final ResourceLeak leak;, + leak
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + readerIndex += length;]
[+++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, + PlatformDependent.copyMemory(addr(index), dst.array(), dst.arrayOffset() + dstIndex, length);, + PlatformDependent.copyMemory(src.array(), src.arrayOffset() + srcIndex, addr(index), length);, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, + PlatformDependent.copyMemory(addr(index), dst.array(), dst.arrayOffset() + dstIndex, length);, + PlatformDependent.copyMemory(src.array(), src.arrayOffset() + srcIndex, addr(index), length);, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + private static final long ARRAY_BASE_OFFSET = arrayBaseOffset0();, +, + public static void copyMemory(byte[] src, int srcIndex, long dstAddr, long length) {, + PlatformDependent0.copyMemory(src, ARRAY_BASE_OFFSET + srcIndex, null, dstAddr, length);, + }, +, + public static void copyMemory(long srcAddr, byte[] dst, int dstIndex, long length) {, + PlatformDependent0.copyMemory(null, srcAddr, dst, ARRAY_BASE_OFFSET + dstIndex, length);, + }, +, + private static long arrayBaseOffset0() {, + if
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.ByteProcessor;, + public int forEachByte(ByteProcessor processor) {, + public int forEachByte(int index, int length, ByteProcessor processor) {, + private int forEachByteAsc0(int index, int length, ByteProcessor processor) {, + public int forEachByteDesc(ByteProcessor processor) {, + public int forEachByteDesc(int index, int length, ByteProcessor processor) {, + private int forEachByteDesc0(int index, int length, ByteProcessor processor) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.ByteProcessor;, + public int forEachByte(ByteProcessor processor) {, + public int forEachByte(int index, int length, ByteProcessor processor) {, + private int forEachByteAsc0(int index, int length, ByteProcessor processor) {, + public int forEachByteDesc(ByteProcessor processor) {, + public int forEachByteDesc(int index, int length,
[+++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxyFrontendHandler.java, + .channel(ctx.channel().getClass())]
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + out.recycle();, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + out.recycle();, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, + out.recycle();]
[+++ b/all/pom.xml, + <phase>prepare-package</phase>, + <phase>prepare-package</phase>, + <phase>prepare-package</phase>]
[+++ b/example/pom.xml, + <dependency>, + <groupId>org.eclipse.jetty.npn</groupId>, + <artifactId>npn-api</artifactId>, + </dependency>, +++ b/example/pom.xml, + <dependency>, + <groupId>org.eclipse.jetty.npn</groupId>, + <artifactId>npn-api</artifactId>, + </dependency>, +++ b/example/src/main/java/io/netty/example/spdy/SpdyOrHttpHandler.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, +import io.netty.channel.Channel.Unsafe;, + headHandler = new ByteHeadHandler(channel.unsafe());, + headHandler = new MessageHeadHandler(channel.unsafe());, + static abstract class HeadHandler implements ChannelOutboundHandler {, + protected final Unsafe unsafe;, + protected HeadHandler(Unsafe unsafe) {, + this.unsafe = unsafe;, + }, +, + private static final class ByteHeadHandler extends HeadHandler {, +, + private ByteHeadHandler(Unsafe unsafe) {, + super(unsafe);, + }, +, + private static final class MessageHeadHandler extends HeadHandler {, +, + private MessageHeadHandler(Unsafe unsafe) {, + super(unsafe);, + }, +]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + super.decodeLast(ctx, in, out);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + super.decodeLast(ctx, in, out);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, + if (in.isReadable()) {, + // Only call decode() if there is something left in the buffer to decode., + // See https://github.com/netty/netty/issues/4386, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + super.decodeLast(ctx, in, out);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, + if (in.isReadable()) {, + // Only call decode() if there is something left in the buffer to decode., + // See https://github.com/netty/netty/issues/4386, + }, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + if (in.isReadable()) {, + // Only call decode() if there is something left in the buffer to decode., + // See https://github.com/netty/netty/issues/4386, + },
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, + public int windowSize() {, + public int pendingBytes() {, + public int windowSize() {, + public int pendingBytes() {, + private final Writer writer;, + protected WritabilityMonitor(Writer writer) {, + this.writer = writer;, + }, + protected final void writePendingBytes() throws Http2Exception {, + protected void initialWindowSize(int newWindowSize) throws Http2Exception {, + writePendingBytes();, + DefaultWritabilityMonitor() {, + super(new StreamByteDistributor.Writer() {, + });, +, + ListenerWritabilityMonitor(final Listener listener) {, + super(new StreamByteDistributor.Writer() {, + int written = state.writeAllocatedBytes(numBytes);, + if (written != -1) {, + listener.streamWritten(state.stream(), written);, + });, + protected void initialWindowSize(int newWindowSize) throws Http2Exception {,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java, + messageMap.put(Integer.valueOf(streamID), httpResponse);, + messageMap.put(Integer.valueOf(streamID), httpRequest);, + messageMap.put(Integer.valueOf(streamID), httpResponse);, + Integer streamID = Integer.valueOf(spdyHeadersFrame.getStreamId());, + Integer streamID = Integer.valueOf(spdyDataFrame.getStreamId());, + Integer streamID = Integer.valueOf(spdyRstStreamFrame.getStreamId());, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java, + messageMap.put(Integer.valueOf(streamID), httpResponse);, + messageMap.put(Integer.valueOf(streamID), httpRequest);, + messageMap.put(Integer.valueOf(streamID), httpResponse);, + Integer streamID = Integer.valueOf(spdyHeadersFrame.getStreamId());, + Integer streamID = Integer.valueOf(spdyDataFrame.getStreamId());, + Integer streamID = Integer.valueOf(spdyRstStreamFrame.getStreamId());, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java, + return activeStreams.containsKey(Integer.valueOf(streamID));, + Integer.valueOf(streamID),, + Integer StreamID = Integer.valueOf(streamID);, + StreamState state = activeStreams.get(Integer.valueOf(streamID));, + Integer StreamID = Integer.valueOf(streamID);, + StreamState state = activeStreams.get(Integer.valueOf(streamID));, + Integer StreamID = Integer.valueOf(streamID);, + StreamState state = activeStreams.get(Integer.valueOf(streamID));, + StreamState state = activeStreams.get(Integer.valueOf(streamID));, + StreamState state = activeStreams.get(Integer.valueOf(streamID));,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + try {, + } catch (final NumberFormatException e) {, + return false;, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + try {, + } catch (final NumberFormatException e) {, + return false;, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java, + * Returns the length of the content or the specified default value if the message does not have the {@code, + * "Content-Length" header}. Please note that this value is not retrieved from {@link HttpContent#content()} but, + * from the {@code "Content-Length"} header, and thus they are independent from each other., + * @param message the message, + * @param defaultValue the
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + private static final boolean MAYBE_SUPER_USER;, +, + MAYBE_SUPER_USER = maybeSuperUser0();, + * Return {@code true} if the current user may be a super-user. Be aware that this is just an hint and so it may, + * return false-positives., + public static boolean maybeSuperUser() {, + return MAYBE_SUPER_USER;, + private static boolean maybeSuperUser0() {, + String username = SystemPropertyUtil.get("user.name");, + return "Administrator".equals(username);, + // Check for root and toor as some BSDs have a toor user that is basically the same as root., + return "root".equals(username) || "toor".equals(username);, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + private static final boolean MAYBE_SUPER_USER;,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/InternalAttribute.java, + if (!(o instanceof InternalAttribute)) {, + InternalAttribute attribute = (InternalAttribute) o;]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + if (buf instanceof WrappedCompositeByteBuf) {, + // WrappedCompositeByteBuf is a sub-class of AbstractByteBuf so it needs special handling., + buf = buf.unwrap();, + } else if (buf instanceof AbstractByteBuf) {, + if (buf instanceof WrappedCompositeByteBuf) {, + // WrappedCompositeByteBuf is a sub-class of AbstractByteBuf so it needs special handling., + buf = buf.unwrap();, + } else if (buf instanceof AbstractByteBuf) {, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + if (buf instanceof WrappedCompositeByteBuf) {, + // WrappedCompositeByteBuf is a sub-class of AbstractByteBuf so it needs special handling., + buf = buf.unwrap();, + } else if (buf instanceof AbstractByteBuf) {, + if
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, + * {@link AttributeKey#valueOf(String) AttributeKey.valueOf("auth")};, + * {@link Attribute}&lt{@link Boolean}&gt attr = ctx.attr(auth);]
[+++ b/pom.xml, + <tcnative.version>2.0.9.Final</tcnative.version>]
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, + * Integer a = ctx.attr(counter).get();, + * Return {@code true} if the {@link ChannelHandler} which belongs to this context was removed]
[+++ b/common/src/main/java/io/netty/util/concurrent/FastThreadLocal.java, + return initialize(threadLocalMap);, + setKnownNotUnset(threadLocalMap, value);, + private void setKnownNotUnset(InternalThreadLocalMap threadLocalMap, V value) {]
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufAllocatorTest.java, +import io.netty.util.internal.PlatformDependent;, + protected boolean isDirectExpected(boolean preferDirect) {, + return preferDirect && PlatformDependent.hasUnsafe();, + }, +, + @Override, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufAllocatorTest.java, +import io.netty.util.internal.PlatformDependent;, + protected boolean isDirectExpected(boolean preferDirect) {, + return preferDirect && PlatformDependent.hasUnsafe();, + }, +, + @Override, +++ b/buffer/src/test/java/io/netty/buffer/ByteBufAllocatorTest.java, + assertBuffer(buffer, isDirectExpected(preferDirect), 1, defaultMaxCapacity());, + assertBuffer(buffer, isDirectExpected(preferDirect), 1, maxCapacity);, + protected abstract boolean isDirectExpected(boolean preferDirect);, +, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufAllocatorTest.java, +import io.netty.util.internal.PlatformDependent;, + protected boolean isDirectExpected(boolean preferDirect) {, + return preferDirect && PlatformDependent.hasUnsafe();, + }, +, + @Override, +++ b/buffer/src/test/java/io/netty/buffer/ByteBufAllocatorTest.java, + assertBuffer(buffer, isDirectExpected(preferDirect), 1, defaultMaxCapacity());, + assertBuffer(buffer, isDirectExpected(preferDirect), 1, maxCapacity);, + protected abstract boolean isDirectExpected(boolean preferDirect);, +, +++
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + long chunkSize = 8196;, + chunkSize = size - position;]
[+++ /dev/null, +++ /dev/null, +++ b/.gitignore, +.project, +.classpath, +++ /dev/null, +++ b/.gitignore, +.project, +.classpath, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +.project, +.classpath, +++ /dev/null, +++ b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java, + if (handler() != null) {, + p.addLast(handler());]
[+++ b/common/src/main/java/io/netty/logging/AbstractInternalLogger.java, + case TRACE:, + return isTraceEnabled();, + case TRACE:, + trace(msg, cause);, + break;, + case TRACE:, + trace(msg);, + break;, +++ b/common/src/main/java/io/netty/logging/AbstractInternalLogger.java, + case TRACE:, + return isTraceEnabled();, + case TRACE:, + trace(msg, cause);, + break;, + case TRACE:, + trace(msg);, + break;, +++ b/common/src/main/java/io/netty/logging/CommonsLogger.java, + public void trace(String msg) {, + logger.trace(msg);, + }, +, + @Override, + public void trace(String msg, Throwable cause) {, + logger.trace(msg, cause);, + }, +, + @Override, + public boolean isTraceEnabled() {, + return logger.isTraceEnabled();, + }, +, + @Override, +++ b/common/src/main/java/io/netty/logging/AbstractInternalLogger.java, + case TRACE:, + return isTraceEnabled();, +
[+++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java, +import io.netty.util.internal.SystemPropertyUtil;, + private static final String PROP_ACQUIRE_AND_RELEASE_ONLY = "io.netty.leakDetection.acquireAndReleaseOnly";, + private static final boolean ACQUIRE_AND_RELEASE_ONLY;, +, + static {, + ACQUIRE_AND_RELEASE_ONLY = SystemPropertyUtil.getBoolean(PROP_ACQUIRE_AND_RELEASE_ONLY, false);, + }, +, + private void recordLeakNonRefCountingOperation() {, + if (!ACQUIRE_AND_RELEASE_ONLY) {, + leak.record();, + }, + }, +, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, + recordLeakNonRefCountingOperation();, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, + * Returns {@code true} if ID is for a server initiated stream or ping., + */, + static boolean isServerID(int ID) {, + // Server initiated streams and pings have even IDs, + return ID % 2 == 0;, + }, +, + /**, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, + * Returns {@code true} if ID is for a server initiated stream or ping., + */, + static boolean isServerID(int ID) {, + // Server initiated streams and pings have even IDs, + return ID % 2 == 0;, + }, +, + /**, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, + private final
[+++ b/pom.xml, + <argLine.leak>-Dio.netty.leakDetectionLevel=paranoid -Dio.netty.leakDetection.maxRecords=32</argLine.leak>]
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, +import java.security.cert.CertPathValidatorException;, + // Try to extract the correct error code that should be used., + // This will never return a negative error code as its validated when constructing the, + // OpenSslCertificateException., + if (PlatformDependent.javaVersion() >= 7) {, + if (cause instanceof CertificateRevokedException) {, +, + // The X509TrustManagerImpl uses a Validator which wraps a CertPathValidatorException into, + // an CertificateException. So we need to handle the wrapped CertPathValidatorException to be, + // able to send the correct alert., + Throwable wrapped = cause.getCause();, + while (wrapped != null) {, + if (wrapped instanceof CertPathValidatorException)
[+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpMessage.java, + public SctpMessage retain() {, + super.retain();, + return this;, + }, +, + @Override, + public SctpMessage retain(int increment) {, + super.retain(increment);, + return this;, + }, +, + @Override, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpMessage.java, + public SctpMessage retain() {, + super.retain();, + return this;, + }, +, + @Override, + public SctpMessage retain(int increment) {, + super.retain(increment);, + return this;, + }, +, + @Override, +++ b/transport-udt/src/main/java/io/netty/channel/udt/UdtMessage.java, + @Override, + public UdtMessage retain() {, + super.retain();, + return this;, + }, +, + @Override, + public UdtMessage retain(int increment) {, + super.retain(increment);, + return this;, + }, +++
[+++ b/pom.xml, + <!-- This is needed because of java.util.zip.Deflater and NIO UDP multicast-->, + <!-- Used for NIO UDP multicast -->, + <ignore>java.nio.channels.DatagramChannel</ignore>, + <ignore>java.nio.channels.MembershipKey</ignore>, + <ignore>java.net.StandardSocketOptions</ignore>, +++ b/pom.xml, + <!-- This is needed because of java.util.zip.Deflater and NIO UDP multicast-->, + <!-- Used for NIO UDP multicast -->, + <ignore>java.nio.channels.DatagramChannel</ignore>, + <ignore>java.nio.channels.MembershipKey</ignore>, + <ignore>java.net.StandardSocketOptions</ignore>, +++ b/transport/src/main/java/io/netty/channel/socket/DatagramChannel.java, +import io.netty.channel.ChannelFuture;, + ChannelFuture joinGroup(InetAddress multicastAddress);, + ChannelFuture joinGroup(InetSocketAddress multicastAddress, NetworkInterface networkInterface);, + ChannelFuture leaveGroup(InetAddress multicastAddress);, + ChannelFuture leaveGroup(InetSocketAddress multicastAddress, NetworkInterface networkInterface);, +++ b/pom.xml, + <!-- This is needed because of java.util.zip.Deflater and NIO UDP multicast-->, + <!-- Used for NIO
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + components = newList(0, maxNumComponents);, + components = newList(len, maxNumComponents);, + int len = buffers instanceof Collection ? ((Collection<ByteBuf>) buffers).size() : 0;, +, + components = newList(len, maxNumComponents);, + private static ComponentList newList(int initComponents, int maxNumComponents) {, + int capacityGuess = Math.min(AbstractByteBufAllocator.DEFAULT_MAX_COMPONENTS, maxNumComponents);, + return new ComponentList(Math.max(initComponents, capacityGuess));, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + components = newList(0, maxNumComponents);, + components = newList(len, maxNumComponents);, + int len = buffers instanceof Collection ? ((Collection<ByteBuf>) buffers).size() : 0;, +, + components = newList(len, maxNumComponents);, + private static ComponentList newList(int initComponents, int maxNumComponents) {, + int capacityGuess = Math.min(AbstractByteBufAllocator.DEFAULT_MAX_COMPONENTS, maxNumComponents);, + return new ComponentList(Math.max(initComponents,
[+++ b/handler/src/main/java/io/netty/handler/ssl/util/FingerprintTrustManagerFactory.java, + * <strong>NOTE:</strong> It is recommended to verify certificates and their chain to prevent, + * <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">Man-in-the-middle attacks</a>., + * This {@link TrustManagerFactory} will <strong>only</strong> verify that the fingerprint of certificates match one, + * of the given fingerprints. This procedure is called, + * <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#Certificate_pinning">certificate pinning</a> and, + * is an effective protection. For maximum security one should verify that the whole certificate chain is as expected., + * It is worth mentioning that certain firewalls, proxies or other appliances found in corporate environments,, + * actually perform Man-in-the-middle attacks and thus present a
[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultFutureListeners.java, +final class DefaultFutureListeners {]
[+++ b/common/src/main/java/io/netty/util/concurrent/PromiseAggregator.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.PING_FRAME_PAYLOAD_LENGTH;, + clientPrefaceString = clientPrefaceString(encoder.connection());, + /**, + * Releases the {@code clientPrefaceString}. Any active streams will be left in the open., + */, + if (clientPrefaceString != null) {, + clientPrefaceString.release();, + clientPrefaceString = null;, + }, + try {, + } finally {, + try {, + encoder().close();, + } finally {, + decoder().close();, + }, + }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.PING_FRAME_PAYLOAD_LENGTH;, + clientPrefaceString = clientPrefaceString(encoder.connection());, + /**, + * Releases the {@code clientPrefaceString}. Any active streams will be left in the open., + */, + if (clientPrefaceString != null) {, +
[+++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, + Formatter formatter = new Formatter();, + newLine = formatter.format("%n").toString();, + } finally {, + formatter.close();, + /**, + * Get the length of a string, {@code null} input is considered {@code 0} length., + */, + public static int length(String s) {, + return s == null ? 0 : s.length();, + }, +, + /**, + * Determine if a string is {@code null} or {@link String#isEmpty()} returns {@code true}., + */, + public static boolean isNullOrEmpty(String s) {, + return s == null || s.isEmpty();, + }, +]
[+++ b/example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java, + String scheme = uri.getScheme() == null? "ws" : uri.getScheme();, + if ("ws".equalsIgnoreCase(scheme)) {, + } else if ("wss".equalsIgnoreCase(scheme)) {]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, + private Charset charset;, + * Set from the request ContentType the multipartDataBoundary and the possible charset., + String[] dataBoundary = HttpPostRequestDecoder.getMultipartDataBoundary(contentType);, + if (dataBoundary != null) {, + multipartDataBoundary = dataBoundary[0];, + if (dataBoundary.length > 1 && dataBoundary[1] != null) {, + charset = Charset.forName(dataBoundary[1]);, + }, + } else {, + multipartDataBoundary = null;, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, + private Charset charset;, + * Set from the request ContentType the multipartDataBoundary and the possible charset., + String[] dataBoundary = HttpPostRequestDecoder.getMultipartDataBoundary(contentType);, + if (dataBoundary != null) {, + multipartDataBoundary = dataBoundary[0];, + if (dataBoundary.length > 1
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, + private static final float HEADERS_WEIGHT_NEW = 1 / 5f;, + private static final float HEADERS_WEIGHT_HISTORICAL = 1 - HEADERS_WEIGHT_NEW;, + private static final float TRAILERS_WEIGHT_NEW = HEADERS_WEIGHT_NEW;, + private static final float TRAILERS_WEIGHT_HISTORICAL = HEADERS_WEIGHT_HISTORICAL;, + /**, + * Used to calculate an exponential moving average of the encoded size of the initial line and the headers for, + * a guess for future buffer allocations., + */, + private float headersEncodedSizeAccumulator = 256;, +, + /**, + * Used to calculate an exponential moving average of the encoded size of the trailers for, + *
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java, + @SuppressWarnings("deprecation"), + * @deprecated Override {@link #newNameResolver(EventLoop, ChannelFactory, InetSocketAddress, DnsServerAddresses)}., + @Deprecated, + newNameResolver(eventLoop, channelFactory, localAddress, nameServerAddresses),, +, + /**, + * Creates a new {@link NameResolver}. Override this method to create an alternative {@link NameResolver}, + * implementation or override the default configuration., + */, + protected NameResolver<InetAddress> newNameResolver(EventLoop eventLoop,, + ChannelFactory<? extends DatagramChannel> channelFactory,, + InetSocketAddress localAddress,, + DnsServerAddresses nameServerAddresses) throws Exception {, + return new DnsNameResolverBuilder(eventLoop), + .channelFactory(channelFactory), + .localAddress(localAddress), + .nameServerAddresses(nameServerAddresses), + .build();, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java, + m.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java, + m.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpUtilTest.java, +import java.util.Collections;, +, + @Test, + public void testDoubleChunkedHeader() {, + HttpMessage message = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);, + message.headers().add(HttpHeaderNames.TRANSFER_ENCODING, "chunked");, + HttpUtil.setTransferEncodingChunked(message, true);, + List<String> expected = Collections.singletonList("chunked");, + assertEquals(expected, message.headers().getAll(HttpHeaderNames.TRANSFER_ENCODING));, + }]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + private static final AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> refCntUpdater;, + AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> updater =, + PlatformDependent.newAtomicIntegerFieldUpdater(AbstractReferenceCountedByteBuf.class, "refCnt");, + if (updater == null) {, + updater = AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCountedByteBuf.class, "refCnt");, + }, + refCntUpdater = updater;, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + private static final AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> refCntUpdater;, + AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> updater =, + PlatformDependent.newAtomicIntegerFieldUpdater(AbstractReferenceCountedByteBuf.class, "refCnt");, + if (updater == null) {, + updater = AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCountedByteBuf.class, "refCnt");, + }, + refCntUpdater = updater;, +++ b/common/src/main/java/io/netty/util/AbstractReferenceCounted.java, + private static final AtomicIntegerFieldUpdater<AbstractReferenceCounted> refCntUpdater;, +, + AtomicIntegerFieldUpdater<AbstractReferenceCounted> updater =, + PlatformDependent.newAtomicIntegerFieldUpdater(AbstractReferenceCounted.class, "refCnt");, + if (updater == null) {, + updater = AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCounted.class, "refCnt");, + }, + refCntUpdater = updater;, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, + private int lastGoodStreamId;, + * @param lastGoodStreamId the Last-good-stream-ID of this frame, + public DefaultSpdyGoAwayFrame(int lastGoodStreamId) {, + this(lastGoodStreamId, 0);, + * @param lastGoodStreamId the Last-good-stream-ID of this frame, + public DefaultSpdyGoAwayFrame(int lastGoodStreamId, int statusCode) {, + this(lastGoodStreamId, SpdySessionStatus.valueOf(statusCode));, + * @param lastGoodStreamId the Last-good-stream-ID of this frame, + public DefaultSpdyGoAwayFrame(int lastGoodStreamId, SpdySessionStatus status) {, + setLastGoodStreamId(lastGoodStreamId);, + public int getLastGoodStreamId() {, + return lastGoodStreamId;, + public void setLastGoodStreamId(int lastGoodStreamId) {, + if (lastGoodStreamId < 0) {, + + " cannot be negative: " + lastGoodStreamId);, + this.lastGoodStreamId = lastGoodStreamId;, + buf.append(lastGoodStreamId);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, + private
[+++ b/handler/src/main/java/io/netty/handler/ssl/util/FingerprintTrustManagerFactory.java, + * Never use this {@link TrustManagerFactory} in production unless you are sure exactly what you are doing with it.]
[+++ b/pom.xml, + <tcnative.version>2.0.12.Final</tcnative.version>]
[+++ b/pom.xml, + <tcnative.version>2.0.0.Beta2</tcnative.version>]
[+++ b/example/src/main/java/io/netty/example/filetransfer/FileServer.java, +++ b/example/src/main/java/io/netty/example/filetransfer/FileServer.java, +++ b/pom.xml, + <version>13</version>, +++ b/example/src/main/java/io/netty/example/filetransfer/FileServer.java, +++ b/pom.xml, + <version>13</version>, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +++ b/example/src/main/java/io/netty/example/filetransfer/FileServer.java, +++ b/pom.xml, + <version>13</version>, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +++ b/example/src/main/java/io/netty/example/filetransfer/FileServer.java, +++ b/pom.xml, + <version>13</version>, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java, +++ b/example/src/main/java/io/netty/example/filetransfer/FileServer.java, +++ b/pom.xml, + <version>13</version>, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioByteChannel.java, +++ b/example/src/main/java/io/netty/example/filetransfer/FileServer.java, +++ b/pom.xml, + <version>13</version>, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioByteChannel.java, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioEventLoop.java, +++ b/example/src/main/java/io/netty/example/filetransfer/FileServer.java, +++ b/pom.xml, + <version>13</version>, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioByteChannel.java, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioEventLoop.java, +++ b/transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannel.java]
[+++ b/codec-http2/pom.xml]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CombinedHttpHeaders.java, +import io.netty.handler.codec.Headers;, + @Override, + public boolean containsValue(CharSequence name, CharSequence value, boolean ignoreCase) {, + return super.containsValue(name, StringUtil.trimOws(value), ignoreCase);, + }, +, + return StringUtil.escapeCsv(valueConverter().convertObject(value), true);, + return StringUtil.escapeCsv(value, true);, + return addEscapedValue(name, charSequenceEscaper().escape(value));, + public CombinedHttpHeadersImpl addObject(CharSequence name, Object value) {, + return addEscapedValue(name, commaSeparate(objectEscaper(), value));, + }, +, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CombinedHttpHeaders.java, +import io.netty.handler.codec.Headers;, + @Override, + public boolean containsValue(CharSequence name, CharSequence value, boolean ignoreCase) {, + return super.containsValue(name, StringUtil.trimOws(value), ignoreCase);, + }, +, + return StringUtil.escapeCsv(valueConverter().convertObject(value), true);, + return StringUtil.escapeCsv(value, true);, + return addEscapedValue(name, charSequenceEscaper().escape(value));, + public CombinedHttpHeadersImpl addObject(CharSequence name, Object value) {, +
[+++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + logger.debug(String.format("Channel %s WS Version %s server handshake", version(), channel.hashCode()));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + logger.debug(String.format("Channel %s WS Version %s server handshake", version(), channel.hashCode()));, +++ b/common/src/main/java/io/netty/util/internal/ConcurrentSet.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, + encodeAscii(request.getMethod().toString(), buf);, + encodeAscii(request.getProtocolVersion().toString(), buf);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + // call retain as it will be release after is written, + decoder.writeInbound(in.retain());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + // call retain as it will be release after is written, + decoder.writeInbound(in.retain());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + // call retain here as it will call release after its written to the channel, + encoder.writeOutbound(in.retain());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + // call retain as it will be release after is written, + decoder.writeInbound(in.retain());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + // call retain here as it will call release after its written to the channel, + encoder.writeOutbound(in.retain());, +++ b/codec/src/test/java/io/netty/handler/codec/compression/JZlibTest.java, + chEncoder.writeOutbound(data.copy());, + chEncoder.writeOutbound(data.copy());, + chEncoder.writeOutbound(data.copy());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/util/OpenJdkSelfSignedCertGenerator.java, + new CertificateAlgorithmId(new AlgorithmId(AlgorithmId.sha256WithRSAEncryption_oid)));, + cert.sign(key, "SHA256withRSA");, + cert.sign(key, "SHA256withRSA");]
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/WriteBeforeRegisteredTest.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + private static final int FLAG_REMOVED = 1;, + private static final int FLAG_FREED = 2;, +, + private int flags;, +, + void setRemoved() {, + flags |= FLAG_REMOVED;, +, + // Free all buffers before completing removal., + if (!channel.isRegistered()) {, + freeHandlerBuffersAfterRemoval();, + }, +, + private void freeHandlerBuffersAfterRemoval() {, + if (flags == FLAG_REMOVED) { // Removed, but not freed yet, + flags |= FLAG_FREED;, +, + }, + if ((flags & FLAG_FREED) == 0) {, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + private static final int FLAG_REMOVED = 1;, + private static final int FLAG_FREED =
[+++ b/example/pom.xml, +, + <build>, + <plugins>, + <plugin>, + <artifactId>maven-dependency-plugin</artifactId>, + <executions>, + <execution>, + <id>copy</id>, + <phase>generate-resources</phase>, + <goals>, + <goal>copy</goal>, + </goals>, + <configuration>, + <artifactItems>, + <artifactItem>, + <groupId>org.mortbay.jetty.npn</groupId>, + <artifactId>npn-boot</artifactId>, + <version>${npn.version}</version>, + <type>jar</type>, + <overWrite>false</overWrite>, + <outputDirectory>${project.build.directory}/npn</outputDirectory>, + </artifactItem>, + </artifactItems>, + </configuration>, + </execution>, + </executions>, + </plugin>, + </plugins>, + </build>, +, + <profiles>, + <profile>, + <id>spdy-server</id>, + <build>, + <plugins>, + <plugin>, + <groupId>org.codehaus.mojo</groupId>, + <artifactId>exec-maven-plugin</artifactId>, + <version>1.2.1</version>, + <configuration>, + <executable>${java.home}/bin/java</executable>, + <arguments>, + <argument>-Xbootclasspath/p:${project.build.directory}/npn/npn-boot-${npn.version}.jar</argument>, + <argument>-classpath</argument>, + <classpath/>, + <argument>io.netty.example.spdy.server.SpdyServer</argument>, + </arguments>, + <classpathScope>compile</classpathScope>, + <systemProperties>, +
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, + * Creates an byte[] based on an ipAddressString. No error handling is performed here., + return getIPv6ByName(ipAddressString, true);, + } else if (numberOfPeriods == 1) {, + // Verify this address is of the correct structure to contain an IPv4 address., + // It must be IPv4-Mapped or IPv4-Compatible, + // (see https://tools.ietf.org/html/rfc4291#section-2.5.5)., + int j = i - word.length() - 2; // index of character before the previous ':'., + final int beginColonIndex = ipAddress.lastIndexOf(':', j);, + if (beginColonIndex == -1) {, + return false;, + }, + char tmpChar = ipAddress.charAt(j);, + if (isValidIPv4MappedChar(tmpChar))
[+++ b/pom.xml, + <version>4.12</version>]
[+++ b/all/pom.xml, + <version>4.1.0.CR5</version>, +++ b/all/pom.xml, + <version>4.1.0.CR5</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR5</version>, +++ b/all/pom.xml, + <version>4.1.0.CR5</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR5</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR5</version>, +++ b/all/pom.xml, + <version>4.1.0.CR5</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR5</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR5</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR5</version>, +++ b/all/pom.xml, + <version>4.1.0.CR5</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR5</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR5</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR5</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR5</version>, +++ b/all/pom.xml, + <version>4.1.0.CR5</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR5</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR5</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR5</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR5</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.CR5</version>, +++ b/all/pom.xml, + <version>4.1.0.CR5</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR5</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR5</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/pom.xml, + <groupId>com.google.code.guice</groupId>]
[+++ /dev/null, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/channel/socket/http/ChannelFutureAggregator.java, +/*, + * Copyright 2009 Red Hat, Inc., + *, + * Red Hat licenses this file to you under the Apache License, version 2.0, + * (the "License"); you may not use this file except in compliance with the, + * License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + // Will be set to null if no child executor should be used, otherwise it will be set to the, + // child executor., + final EventExecutor executor;, + return channel.eventLoop();, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + // Will be set to null if no child executor should be used, otherwise it will be set to the, + // child executor., + final EventExecutor executor;, + return channel.eventLoop();, +++ b/transport/src/test/java/io/netty/channel/AbstractEventLoopTest.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/Cookie.java, + * Constant for undefined MaxAge attribute value., + */, + long UNDEFINED_MAX_AGE = Long.MIN_VALUE;, +, + /**, + * Returns the maximum age of this {@link Cookie} in seconds or {@link Cookie#UNDEFINED_MAX_AGE} if unspecified, + * If {@link Cookie#UNDEFINED_MAX_AGE} is specified, this {@link Cookie} will be removed when the, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/Cookie.java, + * Constant for undefined MaxAge attribute value., + */, + long UNDEFINED_MAX_AGE = Long.MIN_VALUE;, +, + /**, + * Returns the maximum age of this {@link Cookie} in seconds or {@link Cookie#UNDEFINED_MAX_AGE} if unspecified, + * If {@link Cookie#UNDEFINED_MAX_AGE} is specified, this {@link Cookie}
[+++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, + ctx.pipeline().fireChannelRegistered();, +++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, + ctx.pipeline().fireChannelRegistered();, +++ b/transport/src/test/java/io/netty/channel/ChannelInitializerTest.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + *
[+++ b/microbench/src/main/java/io/netty/microbenchmark/common/NetUtilBenchmark.java, + public int useGetByNameIpv4() {, + int invalidCount = 0;, + for (String testEntry : invalidIpV4Hosts) {, + if (NetUtil.getByName(testEntry) == null) {, + ++invalidCount;, + return invalidCount;, + public int useGetByNameIpv6() {, + int invalidCount = 0;, + for (String testEntry : invalidIpV6Hosts) {, + if (NetUtil.getByName(testEntry) == null) {, + ++invalidCount;, + return invalidCount;, + public int useIsValidIpv6() {, + int invalidCount = 0;, + for (String host : invalidIpV6Hosts) {, + if (!NetUtil.isValidIpV6Address(host)) {, + ++invalidCount;, + return invalidCount;, + public int useIsValidIpv4() {, + int invalidCount = 0;, + for (String host :
[+++ b/all/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, + private final int maxFrameSize;, + public WebSocket00FrameDecoder(int maxFrameSize) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, + private final int maxFrameSize;, + public WebSocket00FrameDecoder(int maxFrameSize) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, + public WebSocket08FrameDecoder(boolean maskedPayload, boolean allowExtensions) {, + int willHaveReadByteCount = framePayloadBytesRead + rbytes;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, + private final int maxFrameSize;, + public WebSocket00FrameDecoder(int maxFrameSize) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, + public WebSocket08FrameDecoder(boolean maskedPayload, boolean allowExtensions) {, + int willHaveReadByteCount = framePayloadBytesRead + rbytes;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket13FrameDecoder.java, + public WebSocket13FrameDecoder(boolean maskedPayload, boolean allowExtensions) {, + super(maskedPayload, allowExtensions);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, + private final int maxFrameSize;, + public WebSocket00FrameDecoder(int maxFrameSize) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, + public WebSocket08FrameDecoder(boolean maskedPayload, boolean
[+++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + * A NIO {@link ByteBuffer} based buffer. It is recommended to use, + * {@link UnpooledByteBufAllocator#directBuffer(int, int)}, {@link Unpooled#directBuffer(int)} and, + * {@link Unpooled#wrappedBuffer(ByteBuffer)} instead of calling the constructor explicitly., + public UnpooledDirectByteBuf(ByteBufAllocator alloc, int initialCapacity, int maxCapacity) {, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + * A NIO {@link ByteBuffer} based buffer. It is recommended to use, + * {@link UnpooledByteBufAllocator#directBuffer(int, int)}, {@link Unpooled#directBuffer(int)} and, + * {@link Unpooled#wrappedBuffer(ByteBuffer)} instead of calling the constructor explicitly., + public UnpooledDirectByteBuf(ByteBufAllocator alloc, int initialCapacity, int maxCapacity) {, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java, + * Big endian Java heap buffer implementation. It is recommended to use,
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +, + void discardMarks() {, + markedReaderIndex = markedWriterIndex = 0;, + }, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +, + void discardMarks() {, + markedReaderIndex = markedWriterIndex = 0;, + }, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + discardMarks();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +, + void discardMarks() {, + markedReaderIndex = markedWriterIndex = 0;, + }, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + discardMarks();, +++ b/buffer/src/test/java/io/netty/buffer/AbstractPooledByteBufTest.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License.
[+++ b/transport-native-epoll/pom.xml, + <content>release 6.9</content>]
[+++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java, + nextDelay -= System.nanoTime() - lastReadTime;]
[+++ b/codec-dns/src/test/java/io/netty/handler/codec/dns/DnsQueryTest.java, + InetSocketAddress addr = new InetSocketAddress("8.8.8.8", 53);, + queries.add(new DatagramDnsQuery(null, addr, 1).setRecord(, + queries.add(new DatagramDnsQuery(null, addr, 1).setRecord(, + queries.add(new DatagramDnsQuery(null, addr, 1).setRecord(, + queries.add(new DatagramDnsQuery(null, addr, 1).setRecord(, + queries.add(new DatagramDnsQuery(null, addr, 1).setRecord(]
[+++ b/common/src/main/java/io/netty/util/internal/logging/AbstractInternalLogger.java, + static final String EXCEPTION_MESSAGE = "Unexpected exception:";, +++ b/common/src/main/java/io/netty/util/internal/logging/AbstractInternalLogger.java, + static final String EXCEPTION_MESSAGE = "Unexpected exception:";, +++ b/common/src/main/java/io/netty/util/internal/logging/Log4J2Logger.java, +import static io.netty.util.internal.logging.AbstractInternalLogger.EXCEPTION_MESSAGE;, +, + private static Level toLevel(InternalLogLevel level) {, +++ b/common/src/main/java/io/netty/util/internal/logging/AbstractInternalLogger.java, + static final String EXCEPTION_MESSAGE = "Unexpected exception:";, +++ b/common/src/main/java/io/netty/util/internal/logging/Log4J2Logger.java, +import static io.netty.util.internal.logging.AbstractInternalLogger.EXCEPTION_MESSAGE;, +, + private static Level toLevel(InternalLogLevel level) {, +++ b/common/src/test/java/io/netty/util/internal/logging/Log4J2LoggerTest.java]
[+++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java, + public static final IdleStateEvent FIRST_READER_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.READER_IDLE, true);, + public static final IdleStateEvent READER_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.READER_IDLE, false);, + public static final IdleStateEvent FIRST_WRITER_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.WRITER_IDLE, true);, + public static final IdleStateEvent WRITER_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.WRITER_IDLE, false);, + public static final IdleStateEvent FIRST_ALL_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.ALL_IDLE, true);, + public static final IdleStateEvent ALL_IDLE_STATE_EVENT = new IdleStateEvent(IdleState.ALL_IDLE, false);, + private final boolean first;, + private IdleStateEvent(IdleState state, boolean first) {, + this.first = first;, + * Returns the idle state., + * Returns {@code true} if this was the first event for the {@link IdleState},
[+++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, +import io.netty.buffer.ByteBufHolder;, + } else if (msg instanceof ByteBufHolder) {, + return formatByteBufHolder(eventName, (ByteBufHolder) msg);, +, + /**, + * Returns a String which contains all details to log the {@link ByteBufHolder}., + *, + * By default this method just delegates to {@link #formatByteBuf(String, ByteBuf)},, + * using the content of the {@link ByteBufHolder}. Sub-classes may override this., + */, + protected String formatByteBufHolder(String eventName, ByteBufHolder msg) {, + return formatByteBuf(eventName, msg.content());, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, +public class SpdyFrameCodec extends ByteToMessageDecoder]
[+++ b/handler/src/main/java/io/netty/handler/stream/ChunkedMessageInput.java, +import io.netty.buffer.MessageBuf;, +, +public interface ChunkedMessageInput<T> extends ChunkedInput<MessageBuf<T>> {, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedMessageInput.java, +import io.netty.buffer.MessageBuf;, +, +public interface ChunkedMessageInput<T> extends ChunkedInput<MessageBuf<T>> {, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java, + @SuppressWarnings("unchecked"), + return ((ChunkedMessageInput<Object>) chunks).readChunk(ctx.nextOutboundMessageBuffer());, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedMessageInput.java, +import io.netty.buffer.MessageBuf;, +, +public interface ChunkedMessageInput<T> extends ChunkedInput<MessageBuf<T>> {, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java, + @SuppressWarnings("unchecked"), + return ((ChunkedMessageInput<Object>) chunks).readChunk(ctx.nextOutboundMessageBuffer());, +++ b/handler/src/test/java/io/netty/handler/stream/ChunkedWriteHandlerTest.java, +import static org.junit.Assert.*;, +import io.netty.buffer.MessageBuf;, + ChunkedMessageInput<Object> input = new ChunkedMessageInput<Object>() {, + public boolean readChunk(MessageBuf<Object> buffer) throws Exception {, + ByteBuf buffer = ch.readOutbound();, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedMessageInput.java, +import io.netty.buffer.MessageBuf;, +, +public interface ChunkedMessageInput<T> extends ChunkedInput<MessageBuf<T>> {, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java, + @SuppressWarnings("unchecked"), + return ((ChunkedMessageInput<Object>) chunks).readChunk(ctx.nextOutboundMessageBuffer());, +++ b/handler/src/test/java/io/netty/handler/stream/ChunkedWriteHandlerTest.java, +import static
[+++ b/common/src/main/java/io/netty/util/concurrent/CompleteFuture.java, + /**, + * {@inheritDoc}, + *, + * @param mayInterruptIfRunning this value has no effect in this implementation., + */, +++ b/common/src/main/java/io/netty/util/concurrent/CompleteFuture.java, + /**, + * {@inheritDoc}, + *, + * @param mayInterruptIfRunning this value has no effect in this implementation., + */, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, + /**, + * {@inheritDoc}, + *, + * @param mayInterruptIfRunning this value has no effect in this implementation., + */, +++ b/common/src/main/java/io/netty/util/concurrent/CompleteFuture.java, + /**, + * {@inheritDoc}, + *, + * @param mayInterruptIfRunning this value has no effect in this implementation., + */, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, + /**, + * {@inheritDoc},
[+++ b/transport/src/main/java/io/netty/channel/ChannelPromiseAggregator.java]
[+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpMessage.java, + return new SctpMessage(msgInfo, content().duplicate());]
[+++ b/src/docbook/module/architecture.xml, + <para>, + In this chapter, we will examine what core functionalities are provided in, + Netty and how they constitute a complete network application development, + stack., + </para>, + <section>, + <title>Rich Buffer Data Structure</title>, + <para>, + , + </para>, + </section>, + <section>, + <title>Universal Asynchronous I/O API</title>, + <para>, + , + </para>, + </section>, + , + <section>, + <title>Event Model based on the Interceptor Chain Pattern</title>, + <para>, + , + </para>, + </section>, + , + <section>, + <title>Miscellaneous Constructs</title>, + <para>, + </para>, + </section>, +, + <section>,
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +import javax.net.ssl.SSLEngine;, +import javax.net.ssl.SSLEngineResult;, +import javax.net.ssl.SSLEngineResult.HandshakeStatus;, +import javax.net.ssl.SSLException;, +import javax.net.ssl.SSLHandshakeException;, +import javax.net.ssl.SSLParameters;, +import javax.net.ssl.SSLPeerUnverifiedException;, +import javax.net.ssl.SSLSession;, +import javax.net.ssl.SSLSessionBindingEvent;, +import javax.net.ssl.SSLSessionBindingListener;, +import javax.net.ssl.SSLSessionContext;, +import javax.security.cert.X509Certificate;, +, +import static javax.net.ssl.SSLEngineResult.HandshakeStatus.FINISHED;, +import static javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_UNWRAP;, +import static javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_WRAP;, +import static javax.net.ssl.SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING;, +import static javax.net.ssl.SSLEngineResult.Status.BUFFER_OVERFLOW;, +import static javax.net.ssl.SSLEngineResult.Status.CLOSED;, +import static javax.net.ssl.SSLEngineResult.Status.OK;, + int bytesProduced = 0;, + final SSLEngineResult pendingNetResult;, +, + pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, status);, + if (pendingNetResult != null) {, + return pendingNetResult;, + }, + pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, status);, + return pendingNetResult != null ? pendingNetResult : CLOSED_NOT_HANDSHAKING;, + // If there is no pending
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramMulticastIPv6Test.java, +import org.junit.Ignore;, + @Ignore("Fails on some systems"), + @Override, + public void testMulticast() throws Throwable {, + super.testMulticast();, + }, +, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramMulticastIPv6Test.java, +import org.junit.Ignore;, + @Ignore("Fails on some systems"), + @Override, + public void testMulticast() throws Throwable {, + super.testMulticast();, + }, +, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramMulticastTest.java]
[+++ b/all/pom.xml, + <version>4.1.31.Final</version>, +++ b/all/pom.xml, + <version>4.1.31.Final</version>, +++ b/bom/pom.xml, + <version>4.1.31.Final</version>, + <tag>netty-4.1.31.Final</tag>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, +++ b/all/pom.xml, + <version>4.1.31.Final</version>, +++ b/bom/pom.xml, + <version>4.1.31.Final</version>, + <tag>netty-4.1.31.Final</tag>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, + <version>4.1.31.Final</version>, +
[+++ b/all/pom.xml, + <!-- If the uber profile is used it will automatically fetch the missing native jar from maven and add it to the all jar as well. -->, + <profile>, + <id>uber</id>, + <repositories>, + <repository>, + <id>staged-releases</id>, + <name>Staged Releases</name>, + <url>https://oss.sonatype.org/service/local/repositories/${stagingRepositoryId}/content/</url>, + </repository>, + </repositories>, +, + <dependencies>, + <!-- Depend on all our native jars -->, + <!-- As this is executed on either macOS or Linux we directly need to specify the classifier -->, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport-native-epoll</artifactId>, + <version>${project.version}</version>, + <classifier>linux-x86_64</classifier>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, +
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, +import io.netty.util.internal.SystemPropertyUtil;, + private static final boolean IPV4_PREFERRED = SystemPropertyUtil.getBoolean("java.net.preferIPv4Stack", false);, + private static final boolean IPV6_ADDRESSES_PREFERRED =, + SystemPropertyUtil.getBoolean("java.net.preferIPv6Addresses", false);, +++ b/common/src/main/java/io/netty/util/NetUtil.java, +import io.netty.util.internal.SystemPropertyUtil;, + private static final boolean IPV4_PREFERRED = SystemPropertyUtil.getBoolean("java.net.preferIPv4Stack", false);, + private static final boolean IPV6_ADDRESSES_PREFERRED =, + SystemPropertyUtil.getBoolean("java.net.preferIPv6Addresses", false);, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + return majorVersion(SystemPropertyUtil.get("java.specification.version", "1.6"));, +++ b/common/src/main/java/io/netty/util/NetUtil.java, +import io.netty.util.internal.SystemPropertyUtil;, + private static final boolean IPV4_PREFERRED = SystemPropertyUtil.getBoolean("java.net.preferIPv4Stack", false);, + private static final boolean IPV6_ADDRESSES_PREFERRED =, + SystemPropertyUtil.getBoolean("java.net.preferIPv6Addresses", false);, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + return majorVersion(SystemPropertyUtil.get("java.specification.version", "1.6"));, +++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, + public static final String NEWLINE = SystemPropertyUtil.get("line.separator", "\n");, +++ b/common/src/main/java/io/netty/util/NetUtil.java, +import io.netty.util.internal.SystemPropertyUtil;, + private static
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractDiskHttpData.java, + localfileChannel.force(false);, + fileChannel.force(false);, + localfileChannel.force(false);, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractDiskHttpData.java, + localfileChannel.force(false);, + fileChannel.force(false);, + localfileChannel.force(false);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractMemoryHttpData.java, + }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractDiskHttpData.java, + localfileChannel.force(false);, + fileChannel.force(false);, + localfileChannel.force(false);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractMemoryHttpData.java, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractDiskHttpData.java, + localfileChannel.force(false);, + fileChannel.force(false);, + localfileChannel.force(false);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractMemoryHttpData.java, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, + write(ctx, succeededFuture(ctx.channel()), CONTINUE.duplicate());, + m.setContent(ChannelBuffers.dynamicBuffer(e.channel().getConfig().getBufferFactory()));, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractDiskHttpData.java, + localfileChannel.force(false);, + fileChannel.force(false);, + localfileChannel.force(false);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/AbstractMemoryHttpData.java, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import java.io.ByteArrayInputStream;, +import java.security.cert.CertificateFactory;, +import java.security.cert.X509Certificate;, + // Bytes of self-signed certificate for netty.io, + byte[] certBytes = {, + 48, -126, 1, -92, 48, -126, 1, 13, -96, 3, 2, 1, 2, 2, 9, 0, -9, 61,, + 44, 121, -118, -4, -45, -120, 48, 13, 6, 9, 42, -122, 72, -122,, + -9, 13, 1, 1, 5, 5, 0, 48, 19, 49, 17, 48, 15, 6, 3, 85, 4, 3, 19,, + 8, 110, 101, 116, 116, 121, 46, 105, 111, 48, 32, 23, 13, 49, 55,, + 49, 48, 50, 48, 49, 56, 49,
[+++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + components.remove(cIndex).freeIfNecessary();, +, + List<Component> toRemove = components.subList(cIndex, cIndex + numComponents);, + for (Component c: toRemove) {, + c.freeIfNecessary();, + }, + toRemove.clear();, +, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + components.remove(cIndex).freeIfNecessary();, +, + List<Component> toRemove = components.subList(cIndex, cIndex + numComponents);, + for (Component c: toRemove) {, + c.freeIfNecessary();, + }, + toRemove.clear();, +, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, +import java.util.Collections;, +import static org.hamcrest.CoreMatchers.*;, +, + @Test, + public void testComponentMustBeSlice() {, + CompositeByteBuf buf = freeLater(compositeBuffer());, + buf.addComponent(buffer(4).setIndex(1, 3));, + assertThat(buf.component(0), is(instanceOf(SlicedByteBuf.class)));, + assertThat(buf.component(0).capacity(), is(2));, + assertThat(buf.component(0).maxCapacity(), is(2));, + }, +, + @Test, + public void testReferenceCounts1() {, + ByteBuf c1 = buffer().writeByte(1);,
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java, + * @param trustCertCollectionFile an X.509 certificate collection file in PEM format., + * {@code null} to use the default or the results of parsing, + * {@code trustCertCollectionFile}, + public JdkSslClientContext(File trustCertCollectionFile, TrustManagerFactory trustManagerFactory,, + this(trustCertCollectionFile, trustManagerFactory, keyCertChainFile, keyFile, keyPassword, keyManagerFactory,, + * @param trustCertCollectionFile an X.509 certificate collection file in PEM format., + * {@code null} to use the default or the results of parsing, + * {@code trustCertCollectionFile}, + public JdkSslClientContext(File trustCertCollectionFile, TrustManagerFactory trustManagerFactory,, + ctx = newSSLContext(toX509Certificates(trustCertCollectionFile), trustManagerFactory,, + JdkSslClientContext(X509Certificate[] trustCertCollection, TrustManagerFactory trustManagerFactory,, + ctx = newSSLContext(trustCertCollection, trustManagerFactory, keyCertChain, key, keyPassword,, + private
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, + private static final ChannelMetadata METADATA = new ChannelMetadata(ChannelBufType.MESSAGE, false);, +, + public ChannelMetadata metadata() {, + return METADATA;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, + private static final ChannelMetadata METADATA = new ChannelMetadata(ChannelBufType.MESSAGE, false);, +, + public ChannelMetadata metadata() {, + return METADATA;, +++ b/transport/src/main/java/io/netty/channel/Channel.java, + ChannelMetadata metadata();, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, + private static final ChannelMetadata METADATA = new ChannelMetadata(ChannelBufType.MESSAGE, false);, +, + public ChannelMetadata metadata() {, + return METADATA;, +++
[+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectEncoder.java]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket07FrameDecoder.java, + * When set to true, frames which are not masked properly according to the standard will still be, + * accepted., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket07FrameDecoder.java, + * When set to true, frames which are not masked properly according to the standard will still be, + * accepted., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, + * When set to true, frames which are not masked properly according to the standard will still be, + * accepted., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket07FrameDecoder.java, + * When set to true, frames which are not masked properly according to the standard will still be, + * accepted., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseStatus.java, + if (responseStatus.reasonPhrase().toString().equals(reasonPhrase)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseStatus.java, + if (responseStatus.reasonPhrase().toString().equals(reasonPhrase)) {, +++ b/codec/src/test/java/io/netty/handler/codec/AsciiStringTest.java, +import org.junit.Assert;, + @Test, + public void testComparisonWithString() {, + String string = "shouldn't fail";, + AsciiString ascii = new AsciiString(string.toCharArray());, + Assert.assertEquals(string, ascii.toString());, + }, +]
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, + * @deprecated Use {@link #JdkSslContext(SSLContext, boolean, Iterable, CipherSuiteFilter,, + * ApplicationProtocolConfig, ClientAuth, String[], boolean)}, + @Deprecated, + * @deprecated Use {@link #JdkSslContext(SSLContext, boolean, Iterable, CipherSuiteFilter,, + * ApplicationProtocolConfig, ClientAuth, String[], boolean)}, + @Deprecated, + this(sslContext, isClient, ciphers, cipherFilter, apn, clientAuth, null, false);, + }, +, + /**, + * Creates a new {@link JdkSslContext} from a pre-configured {@link SSLContext}., + *, + * @param sslContext the {@link SSLContext} to use., + * @param isClient {@code true} if this context should create {@link SSLEngine}s for client-side usage., + * @param ciphers the ciphers to use or {@code
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpRequestDecoderTest.java, +import io.netty.handler.codec.TooLongFrameException;, +, + @Test, + public void testTooLargeInitialLine() {, + EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder(10, 1024, 1024));, + String requestStr = "GET /some/path HTTP/1.1\r\n" +, + "Host: localhost1\r\n\r\n";, +, + assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));, + HttpRequest request = channel.readInbound();, + assertTrue(request.decoderResult().isFailure());, + assertTrue(request.decoderResult().cause() instanceof TooLongFrameException);, + assertFalse(channel.finish());, + }, +, + @Test, + public void testTooLargeHeaders() {, + EmbeddedChannel channel = new EmbeddedChannel(new HttpRequestDecoder(1024, 10, 1024));, + String requestStr = "GET /some/path HTTP/1.1\r\n" +, + "Host: localhost1\r\n\r\n";, +, + assertTrue(channel.writeInbound(Unpooled.copiedBuffer(requestStr, CharsetUtil.US_ASCII)));, + HttpRequest request = channel.readInbound();, + assertTrue(request.decoderResult().isFailure());, + assertTrue(request.decoderResult().cause() instanceof TooLongFrameException);, + assertFalse(channel.finish());, + }]
[+++ b/src/docbook/en-US/module/start.xml, + time.writeInt((int) (System.currentTimeMillis() / 1000));, +++ b/src/docbook/en-US/module/start.xml, + time.writeInt((int) (System.currentTimeMillis() / 1000));, +++ b/src/main/java/org/jboss/netty/handler/codec/frame/DelimiterBasedFrameDecoder.java, + // TODO Let user choose when the exception should be raised - early or late?, + // If early, fail() should be called when discardingTooLongFrame is set to true., +++ b/src/docbook/en-US/module/start.xml, + time.writeInt((int) (System.currentTimeMillis() / 1000));, +++ b/src/main/java/org/jboss/netty/handler/codec/frame/DelimiterBasedFrameDecoder.java, + // TODO Let user choose when the exception should be raised - early or late?, + // If early, fail() should be called when discardingTooLongFrame is set to true., +++ b/src/main/java/org/jboss/netty/handler/codec/frame/LengthFieldBasedFrameDecoder.java, + failIfNecessary(ctx);, + failIfNecessary(ctx);, + private void failIfNecessary(ChannelHandlerContext ctx) {, + //
[+++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBuf.java, + public CompositeByteBuf addFlattenedComponents(boolean increaseWriterIndex, ByteBuf buffer) {, + recordLeakNonRefCountingOperation(leak);, + return super.addFlattenedComponents(increaseWriterIndex, buffer);, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareCompositeByteBuf.java, + public CompositeByteBuf addFlattenedComponents(boolean increaseWriterIndex, ByteBuf buffer) {, + recordLeakNonRefCountingOperation(leak);, + return super.addFlattenedComponents(increaseWriterIndex, buffer);, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + writerIndex += readableBytes;, + writerIndex += components[ci - 1].endOffset - components[cIndex].offset;, + /**, + * Add the given {@link ByteBuf} and increase the {@code writerIndex} if {@code increaseWriterIndex} is, + * {@code true}. If the provided buffer is a {@link CompositeByteBuf} itself, a "shallow copy" of its, + * readable components will be performed.
[+++ b/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<!--, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2009, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version.,
[+++ b/.fbfilter.xml, +<!--, + ~ Copyright 2011 The Netty Project, + ~, + ~ The Netty Project licenses this file to you under the Apache License,, + ~ version 2.0 (the "License"); you may not use this file except in compliance, + ~ with the License. You may obtain a copy of the License at:, + ~, + ~ http://www.apache.org/licenses/LICENSE-2.0, + ~, + ~ Unless required by applicable law or agreed to in writing, software, + ~ distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + ~ WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import io.netty.util.CharsetUtil;, + public CharSequence getCharSequence(int index, int length, Charset charset) {, + // TODO: We could optimize this for UTF8 and US_ASCII, + return toString(index, length, charset);, + }, +, + @Override, + public CharSequence readCharSequence(int length, Charset charset) {, + CharSequence sequence = getCharSequence(readerIndex, length, charset);, + readerIndex += length;, + return sequence;, + }, +, + @Override, + public int setCharSequence(int index, CharSequence sequence, Charset charset) {, + if (charset.equals(CharsetUtil.UTF_8)) {, + ensureWritable(ByteBufUtil.utf8MaxBytes(sequence));, + return ByteBufUtil.writeUtf8(this, index, sequence, sequence.length());, + }, + if (charset.equals(CharsetUtil.US_ASCII)) {, + int len = sequence.length();, + ensureWritable(len);, + return
[+++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java, + if (f.isHidden() || !f.canRead()) {]
[+++ /dev/null, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, + , + , + // Check if we exceeded the maximum size of 2gb if this is the case then , + // newCapacity == 0, + //, + // https://github.com/netty/netty/issues/258,
[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultThreadFactory.java, +import io.netty.util.internal.StringUtil;, +, + String poolName = StringUtil.simpleClassName(poolType);]
[+++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java, +, +++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java, +, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, +, +++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java, +, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, +, +++ b/transport/src/main/java/io/netty/channel/oio/AbstractOioByteChannel.java]
[+++ b/example/src/main/java/io/netty/example/localecho/LocalEcho.java, +import io.netty.channel.local.LocalEventLoop;, + // Note that we can use any event loop to ensure certain local channels, + // are handled by the same event loop thread which drives a certain socket channel, + // to reduce the communication latency between socket channels and local channels., + sb.eventLoop(new LocalEventLoop(), new LocalEventLoop()), +++ b/example/src/main/java/io/netty/example/localecho/LocalEcho.java, +import io.netty.channel.local.LocalEventLoop;, + // Note that we can use any event loop to ensure certain local channels, + // are handled by the same event loop thread which drives a certain socket channel, + // to reduce the communication latency between socket channels and
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + /**, + * The current status of the read-processing for a {@link Http2StreamChannel}., + */, + private enum ReadStatus {, + /**, + * No read in progress and no read was requested (yet), + */, + IDLE,, +, + /**, + * Reading in progress, + */, + IN_PROGRESS,, +, + /**, + * A read operation was requested., + */, + REQUESTED, + }, +, +, + * This variable represents if a read is in progress for the current channel or was requested., + * Note that depending upon the {@link RecvByteBufAllocator} behavior
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +<<<<<<< HEAD, + * Returns the max length for any frame's payload., +=======, + * Returns the max length for any frame's payload, +>>>>>>> abd10d9... Fixed bug where subprotocol not sent by client, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +<<<<<<< HEAD, + * Returns the max length for any frame's payload., +=======, + * Returns the max length for any frame's payload, +>>>>>>> abd10d9... Fixed bug where subprotocol not sent by client, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketUtil.java, + * A utility class mainly for use by web sockets, + * Performs a MD5 hash on the specified data, + * @param data The data
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +, + ensureContent(res);, + encodeFullResponse(newRes, (HttpContent) res, out);, + break;, + // Make the response chunked to simplify content transformation., + res.headers().remove(HttpHeaderNames.CONTENT_LENGTH);, + res.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);, +, + private void encodeFullResponse(HttpResponse newRes, HttpContent content, List<Object> out) {, + int existingMessages = out.size();, + encodeContent(content, out);, +, + if (HttpUtil.isContentLengthSet(newRes)) {, + // adjust the content-length header, + int messageSize = 0;, + for (int i = existingMessages; i < out.size(); i++) {, + Object item = out.get(i);, + if (item instanceof HttpContent) {, + messageSize += ((HttpContent) item).content().readableBytes();, + }, + }, + HttpUtil.setContentLength(newRes, messageSize);, + } else
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java, + private Inflater inflater;, + private boolean decideZlibOrNone;, +, + case ZLIB_OR_NONE:, + // Postpone the decision until decode(...) is called., + decideZlibOrNone = true;, + crc = null;, + break;, + if (decideZlibOrNone) {, + // First two bytes are needed to decide if it's a ZLIB stream., + if (in.readableBytes() < 2) {, + return;, + }, +, + boolean nowrap = !looksLikeZlib(in.getShort(0));, + inflater = new Inflater(nowrap);, + decideZlibOrNone = false;, + }, +, + if (inflater != null) {, + }, +, + /*, + * Returns true if the cmf_flg parameter (think:
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + final void epollInBefore() { maybeMoreDataToRead = false; }, + readPending = false;, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + final void epollInBefore() { maybeMoreDataToRead = false; }, + readPending = false;, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollServerChannel.java, + if (fd().isInputShutdown()) {, + final ChannelConfig config = config();, + epollInBefore();, + readPending = false;, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + final void epollInBefore() { maybeMoreDataToRead = false; }, + readPending = false;, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollServerChannel.java, + if (fd().isInputShutdown()) {, + final ChannelConfig config = config();, + epollInBefore();, + readPending = false;, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + readPending = false;, + if (fd().isInputShutdown()) {, + final ChannelConfig config = config();, + epollInBefore();,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/CaseIgnoringComparator.java, +final class CaseIgnoringComparator implements Comparator<String>, Serializable {, + static final CaseIgnoringComparator INSTANCE = new CaseIgnoringComparator();]
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, + * {@code true} if IPv4 should be used even if the system supports both IPv4 and IPv6., + * {@code true} if an IPv6 address should be preferred when a host has both an IPv4 address and an IPv6 address., + */, + private static final boolean IPV6_ADDRESSES_PREFERRED = Boolean.getBoolean("java.net.preferIPv6Addresses");, +, + /**, + logger.debug("-Djava.net.preferIPv4Stack: {}", IPV4_PREFERRED);, + logger.debug("-Djava.net.preferIPv6Addresses: {}", IPV6_ADDRESSES_PREFERRED);, +, + * Returns {@code true} if IPv4 should be used even if the system supports both IPv4 and IPv6. Setting this, + * property to {@code true} will disable IPv6 support. The default value
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + if (uintCount > 0) {, + boolean bufferAIsBigEndian = bufferA.order() == ByteOrder.BIG_ENDIAN;, + final long res;, + int uintCountIncrement = uintCount << 2;, +, + res = bufferAIsBigEndian ? compareUintBigEndian(bufferA, bufferB, aIndex, bIndex, uintCountIncrement) :, + compareUintLittleEndian(bufferA, bufferB, aIndex, bIndex, uintCountIncrement);, + res = bufferAIsBigEndian ? compareUintBigEndianA(bufferA, bufferB, aIndex, bIndex, uintCountIncrement) :, + compareUintBigEndianB(bufferA, bufferB, aIndex, bIndex, uintCountIncrement);, + if (res != 0) {, + // Ensure we not overflow when cast, + return (int) Math.min(Integer.MAX_VALUE, res);, + aIndex += uintCountIncrement;, + bIndex += uintCountIncrement;, + for (int aEnd = aIndex +
[+++ b/codec/src/test/java/io/netty/handler/codec/bytes/ByteArrayEncoderTest.java, +import org.junit.After;, +import static org.hamcrest.CoreMatchers.*;, + @After, + public void tearDown() {, + assertThat(ch.finish(), is(false));, + }, +, + ByteBuf encoded = ch.readOutbound();, + assertThat(encoded, is(wrappedBuffer(b)));, + encoded.release();, + assertThat((ByteBuf) ch.readOutbound(), is(sameInstance(EMPTY_BUFFER)));]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + } else {, + if (header == null) {, + return new Object[] { new DefaultLastHttpContent(newContent) };, + } else {, + return new Object[] { header, new DefaultLastHttpContent(newContent) };, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + } else {, + if (header == null) {, + return new Object[] { new DefaultLastHttpContent(newContent) };, + } else {, + return new Object[] { header, new DefaultLastHttpContent(newContent) };, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + } else {, + if (header == null) {, + return new Object[] { new DefaultLastHttpContent(newContent) };, + } else {, + return new Object[] {
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + ClassLoader systemClassLoader = null;, + systemClassLoader = getSystemClassLoader();, + Class<?> vmClass = Class.forName("sun.misc.VM", true, systemClassLoader);, + "java.lang.management.ManagementFactory", true, systemClassLoader);, + "java.lang.management.RuntimeMXBean", true, systemClassLoader);, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + ClassLoader systemClassLoader = null;, + systemClassLoader = getSystemClassLoader();, + Class<?> vmClass = Class.forName("sun.misc.VM", true, systemClassLoader);, + "java.lang.management.ManagementFactory", true, systemClassLoader);, + "java.lang.management.RuntimeMXBean", true, systemClassLoader);, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + } catch (Throwable cause) {, + return cause;, + Throwable t = (Throwable) maybeUnaligned;, + logger.debug("java.nio.Bits.unaligned: unavailable {}", unaligned, t);, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + ClassLoader systemClassLoader = null;, + systemClassLoader = getSystemClassLoader();, + Class<?> vmClass = Class.forName("sun.misc.VM", true, systemClassLoader);, + "java.lang.management.ManagementFactory", true, systemClassLoader);, + "java.lang.management.RuntimeMXBean",
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + String newpostfix;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + String newpostfix;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java, +import static io.netty.buffer.Unpooled.*;, +, + encoding = HttpConstants.DEFAULT_CHARSET;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + String newpostfix;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java, +import static io.netty.buffer.Unpooled.*;, +, + encoding = HttpConstants.DEFAULT_CHARSET;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java, + int equalpos;, + int ampersandpos;, + SeekAheadOptimize sao;, + int equalpos;, + int ampersandpos;, + SeekAheadOptimize sao;, + boolean checkSecondArg;, + SeekAheadOptimize sao;, + SeekAheadOptimize sao;, + SeekAheadOptimize sao;, + int lastPosition;, + SeekAheadOptimize sao;, + int lastPosition;, + for (int i = 0; i < field.length(); i++) {, + String[] values;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + String newpostfix;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java, +import static
[+++ b/pom.xml]
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +, + // Check if this handler was removed before try to continue the loop., + // If it was removed it is not safe to continue to operate on the buffer, + //, + // See https://github.com/netty/netty/issues/1664, + if (ctx.isRemoved()) {, + break;, + }, +, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +, + // Check if this handler was removed before try to continue the loop., + // If it was removed it is not safe to continue to operate on the buffer, + //, + // See https://github.com/netty/netty/issues/1664, + if (ctx.isRemoved()) {, + break;, + }, +, +++
[+++ b/common/src/main/java/io/netty/util/AbstractConstant.java, +import java.util.concurrent.atomic.AtomicLong;, + private static final AtomicLong uniqueIdGenerator = new AtomicLong();, + private final long uniquifier;, + this.uniquifier = uniqueIdGenerator.getAndIncrement();, + if (uniquifier < other.uniquifier) {, + if (uniquifier > other.uniquifier) {]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshaker.java, +, +import io.netty.handler.codec.compression.ZlibCodecFactory;, + this(6, ZlibCodecFactory.isSupportingWindowSizeAndMemLevel(), MAX_WINDOW_SIZE, false, false);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshaker.java, +, +import io.netty.handler.codec.compression.ZlibCodecFactory;, + this(6, ZlibCodecFactory.isSupportingWindowSizeAndMemLevel(), MAX_WINDOW_SIZE, false, false);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateServerExtensionHandshaker.java, +import io.netty.handler.codec.compression.ZlibCodecFactory;, + this(6, ZlibCodecFactory.isSupportingWindowSizeAndMemLevel(), MAX_WINDOW_SIZE, false, false);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshaker.java, +, +import io.netty.handler.codec.compression.ZlibCodecFactory;, + this(6, ZlibCodecFactory.isSupportingWindowSizeAndMemLevel(), MAX_WINDOW_SIZE, false, false);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateServerExtensionHandshaker.java, +import io.netty.handler.codec.compression.ZlibCodecFactory;, + this(6, ZlibCodecFactory.isSupportingWindowSizeAndMemLevel(), MAX_WINDOW_SIZE, false, false);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshakerTest.java, +, +import io.netty.handler.codec.compression.ZlibCodecFactory;, + assertEquals(ZlibCodecFactory.isSupportingWindowSizeAndMemLevel() ? 1 : 0, data.parameters().size());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshaker.java, +, +import io.netty.handler.codec.compression.ZlibCodecFactory;, + this(6, ZlibCodecFactory.isSupportingWindowSizeAndMemLevel(), MAX_WINDOW_SIZE, false, false);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateServerExtensionHandshaker.java, +import io.netty.handler.codec.compression.ZlibCodecFactory;, + this(6, ZlibCodecFactory.isSupportingWindowSizeAndMemLevel(), MAX_WINDOW_SIZE, false, false);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshakerTest.java, +, +import io.netty.handler.codec.compression.ZlibCodecFactory;, + assertEquals(ZlibCodecFactory.isSupportingWindowSizeAndMemLevel() ? 1 : 0, data.parameters().size());, +++
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, + /**, + * Create a new instance which will try to detect the types to encode out of the type parameter, + * of the class., + */, + /**, + * Create a new instance., + *, + * @param outboundMessageType The type of messages to encode, + */, + /**, + * Returns {@code true} if and only if the specified message can be encoded by this codec., + *, + * @param msg the message, + */, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, + /**, + * Create a new instance which will try to detect the
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpVersion.java, + if ("HTTP/1.1".equals(text)) {, + if ("HTTP/1.0".equals(text)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpVersion.java, + if ("HTTP/1.1".equals(text)) {, + if ("HTTP/1.0".equals(text)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspVersions.java, + if ("RTSP/1.0".equals(text)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpVersion.java, + if ("HTTP/1.1".equals(text)) {, + if ("HTTP/1.0".equals(text)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspVersions.java, + if ("RTSP/1.0".equals(text)) {, +++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java, + if ("true".equals(value) || "yes".equals(value) || "1".equals(value)) {, + if ("false".equals(value) || "no".equals(value) || "0".equals(value)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpVersion.java, + if ("HTTP/1.1".equals(text)) {, + if ("HTTP/1.0".equals(text)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspVersions.java, + if ("RTSP/1.0".equals(text)) {, +++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java, + if ("true".equals(value) || "yes".equals(value) || "1".equals(value)) {, + if ("false".equals(value) || "no".equals(value) || "0".equals(value)) {, +++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClient.java, + if ("http".equalsIgnoreCase(scheme))
[+++ b/handler/src/main/java/io/netty/handler/ssl/CipherSuiteConverter.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, + try {, + } finally {, + // Ensure we always run tasks., + }, + try {, + } finally {, + // Ensure we always run tasks., + }, + } catch (Throwable t) {, + handleLoopException(t);, + }, + // Always handle shutdown even if the loop processing threw an exception., + try {, + handleLoopException(t);, + }, + }, + }, +, + private static void handleLoopException(Throwable t) {, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, + try {, + } finally {, + // Ensure we always run tasks., + }, + try {, + }
[+++ b/pom.xml, + <tcnative.version>2.0.14.Final</tcnative.version>]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, + // Only process up to payloadLength bytes., + int payloadEndIndex = in.readerIndex() + payloadLength;, + readDataFrame(ctx, in, payloadEndIndex, listener);, + readHeadersFrame(ctx, in, payloadEndIndex, listener);, + readPriorityFrame(ctx, in, listener);, + readRstStreamFrame(ctx, in, listener);, + readSettingsFrame(ctx, in, listener);, + readPushPromiseFrame(ctx, in, payloadEndIndex, listener);, + readPingFrame(ctx, in.readLong(), listener);, + readGoAwayFrame(ctx, in, payloadEndIndex, listener);, + readWindowUpdateFrame(ctx, in, listener);, + readContinuationFrame(in, payloadEndIndex, listener);, + readUnknownFrame(ctx, in, payloadEndIndex, listener);, + in.readerIndex(payloadEndIndex);, + private void readDataFrame(ChannelHandlerContext ctx, ByteBuf payload, int payloadEndIndex,, + int dataLength = lengthWithoutTrailingPadding(payloadEndIndex - payload.readerIndex(), padding);, + private void readHeadersFrame(final ChannelHandlerContext ctx, ByteBuf payload, int payloadEndIndex,, + final int lenToRead
[+++ b/NOTICE.txt, +This product contains a modified portion of 'jfastlz', a Java port of FastLZ compression, +and decompression library written by William Kinney. It can be obtained at:, +, + * LICENSE:, + * license/LICENSE.jfastlz.txt (MIT License), + * HOMEPAGE:, + * https://code.google.com/p/jfastlz/, +, +++ b/NOTICE.txt, +This product contains a modified portion of 'jfastlz', a Java port of FastLZ compression, +and decompression library written by William Kinney. It can be obtained at:, +, + * LICENSE:, + * license/LICENSE.jfastlz.txt (MIT License), + * HOMEPAGE:, + * https://code.google.com/p/jfastlz/, +, +++ b/codec/src/main/java/io/netty/handler/codec/compression/FastLz.java, +/*, + * Copyright 2014 The Netty Project, +
[+++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioSocketChannel.java, +import org.jboss.netty.util.WriteMessageQueue;, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioSocketChannel.java, +import org.jboss.netty.util.WriteMessageQueue;, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioSocketChannel.java, +import org.jboss.netty.util.WriteMessageQueue;, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/util/WriteMessageQueue.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2008, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version
[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java, + public DefaultEventExecutor(EventExecutorGroup parent, Executor executor, int maxPendingTasks) {, + super(parent, executor, true, maxPendingTasks);, + }, +, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java, + public DefaultEventExecutor(EventExecutorGroup parent, Executor executor, int maxPendingTasks) {, + super(parent, executor, true, maxPendingTasks);, + }, +, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorGroup.java, + this(nThreads, threadFactory, DefaultEventExecutor.DEFAULT_MAX_PENDING_TASKS);, + }, +, + /**, + * Create a new instance., + *, + * @param nThreads the number of threads that will be used by this instance., + * @param threadFactory the ThreadFactory to use, or {@code null} if the default should be used., + * @param maxPendingTasks the maximum number of pending tasks
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataFrame.java]
[+++ b/all/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/example/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha3-SNAPSHOT</version>, +++ b/codec/pom.xml, +
[+++ b/pom.xml, + <version>3.2.0.ALPHA3</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.2.0.ALPHA3</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.2.0.ALPHA3</developerConnection>]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + throw new IllegalReferenceCountException(oldRef, -decrement);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + throw new IllegalReferenceCountException(oldRef, -decrement);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractReferenceCountedByteBufTest.java, +import static org.junit.Assert.fail;, + @Test, + public void testReleaseErrorMessage() {, + AbstractReferenceCountedByteBuf referenceCounted = newReferenceCounted();, + assertTrue(referenceCounted.release());, + try {, + referenceCounted.release(1);, + fail("IllegalReferenceCountException didn't occur");, + } catch (IllegalReferenceCountException e) {, + assertEquals("refCnt: 0, decrement: 1", e.getMessage());, + }, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + throw new IllegalReferenceCountException(oldRef, -decrement);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractReferenceCountedByteBufTest.java, +import static org.junit.Assert.fail;, + @Test, + public void testReleaseErrorMessage() {, + AbstractReferenceCountedByteBuf referenceCounted = newReferenceCounted();, + assertTrue(referenceCounted.release());, + try {, + referenceCounted.release(1);, + fail("IllegalReferenceCountException didn't occur");, + } catch (IllegalReferenceCountException e)
[+++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, +import io.netty.channel.ChannelHandlerUtil;, + Object encoded = encode(ctx, msg);, + // Handle special case when the encoded output is a ByteBuf and the next handler in the pipeline, + // accept bytes. Related to #1222, + ChannelHandlerUtil.addToNextOutboundBuffer(ctx, encoded);, +]
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java, +import javax.naming.Context;, +import javax.naming.NamingException;, +import javax.naming.directory.DirContext;, +import javax.naming.directory.InitialDirContext;, +import java.net.URI;, +import java.net.URISyntaxException;, +import java.util.Hashtable;, +, + // Using jndi-dns to obtain the default name servers., + //, + // See:, + // - http://docs.oracle.com/javase/8/docs/technotes/guides/jndi/jndi-dns.html, + // - http://mail.openjdk.java.net/pipermail/net-dev/2017-March/010695.html, + Hashtable<String, String> env = new Hashtable<String, String>();, + env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.dns.DnsContextFactory");, + env.put("java.naming.provider.url", "dns://");, + try {, + DirContext ctx = new InitialDirContext(env);, + String dnsUrls = (String) ctx.getEnvironment().get("java.naming.provider.url");, + String[] servers = dnsUrls.split(" ");, + for (String server : servers) {, + try {, + defaultNameServers.add(SocketUtils.socketAddress(new URI(server).getHost(), DNS_PORT));, + } catch (URISyntaxException e) {, + logger.debug("Skipping a malformed
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + * Create a new {@link EpollRecvByteAllocatorHandle} instance., +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + * Create a new {@link EpollRecvByteAllocatorHandle} instance., +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollServerChannel.java, + @Deprecated, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + * Create a new {@link EpollRecvByteAllocatorHandle} instance., +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollServerChannel.java, + @Deprecated, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + private static void safeClosePipe(FileDescriptor fd) {, + abstract boolean spliceIn(RecvByteBufAllocator.Handle handle);, + public boolean spliceIn(RecvByteBufAllocator.Handle handle) {, + private final int offset;, + public boolean spliceIn(RecvByteBufAllocator.Handle handle) {, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + * Create a new {@link EpollRecvByteAllocatorHandle} instance., +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollServerChannel.java, + @Deprecated, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + private static void safeClosePipe(FileDescriptor fd) {, + abstract boolean spliceIn(RecvByteBufAllocator.Handle handle);, + public
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + * The handshake will be automaticly issued for you once the {@link Channel} is active and, + * {@link SSLEngine#getUseClientMode()} returns {@code true}., + * So no need to bother with it by your self., +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + * The handshake will be automaticly issued for you once the {@link Channel} is active and, + * {@link SSLEngine#getUseClientMode()} returns {@code true}., + * So no need to bother with it by your self., +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedFile.java, +import io.netty.channel.FileRegion;, + * {@link #readChunk(ByteBuf)} call, + * {@link #readChunk(ByteBuf)} call, + * {@link #readChunk(ByteBuf)} call, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + *
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslX509KeyManagerFactory.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamFrameToHttpObjectCodec.java, +import io.netty.util.Attribute;, +import io.netty.util.AttributeKey;, +, + private static final AttributeKey<HttpScheme> SCHEME_ATTR_KEY =, + AttributeKey.valueOf(HttpScheme.class, "STREAMFRAMECODEC_SCHEME");, +, + final Http2Headers headers = toHttp2Headers(ctx, res);, + Http2Headers headers = toHttp2Headers(ctx, (HttpMessage) obj);, + private Http2Headers toHttp2Headers(final ChannelHandlerContext ctx, final HttpMessage msg) {, + connectionScheme(ctx));, + // this handler is typically used on an Http2StreamChannel. At this, + final Attribute<HttpScheme> schemeAttribute = connectionSchemeAttribute(ctx);, + if (schemeAttribute.get() == null) {, + final HttpScheme scheme = isSsl(ctx) ? HttpScheme.HTTPS : HttpScheme.HTTP;, + schemeAttribute.set(scheme);, + }, + final Channel connChannel = connectionChannel(ctx);, +, + private static HttpScheme connectionScheme(ChannelHandlerContext ctx) {, + final HttpScheme
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java, + * Skeleton implementation of a {@link ChannelHandler}.]
[+++ b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, + super(HttpMessage.class, HttpChunk.class);, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, + super(HttpMessage.class, HttpChunk.class);, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + super(HttpMessage.class, HttpChunk.class);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, + super(HttpMessage.class, HttpChunk.class);, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + super(HttpMessage.class, HttpChunk.class);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + super(, + new Class<?>[] { HttpMessage.class },, + new Class<?>[] { HttpMessage.class, HttpChunk.class });, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, + super(HttpMessage.class, HttpChunk.class);, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + super(HttpMessage.class, HttpChunk.class);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + super(, + new Class<?>[] { HttpMessage.class },, + new Class<?>[] { HttpMessage.class, HttpChunk.class });, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageEncoder.java, + super(HttpMessage.class, HttpChunk.class);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, + super(HttpMessage.class, HttpChunk.class);, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + super(HttpMessage.class, HttpChunk.class);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + super(, + new Class<?>[] { HttpMessage.class },,
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + return new OpenSslEngine(ctx, alloc, isClient(), sessionContext(), apn, engineMap,, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + return new OpenSslEngine(ctx, alloc, isClient(), sessionContext(), apn, engineMap,, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + private final Certificate[] localCerts;, + // Adding the OpenSslEngine to the OpenSslEngineMap so it can be used in the AbstractCertificateVerifier., + engineMap.add(this);, +, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + return new OpenSslEngine(ctx, alloc, isClient(), sessionContext(), apn, engineMap,, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + private final Certificate[] localCerts;, + // Adding the OpenSslEngine to the OpenSslEngineMap so it can be used in the AbstractCertificateVerifier., + engineMap.add(this);, +, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + if (engine instanceof OpenSslEngine) {, + // Call shutdown so we
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + * Creates a new instance with the specified decoder options., + */, + public HttpClientCodec(, + int maxInitialLineLength, int maxHeaderSize, int maxChunkSize, boolean failOnMissingResponse,, + boolean validateHeaders, int initialBufferSize) {, + init(new Decoder(maxInitialLineLength, maxHeaderSize, maxChunkSize, validateHeaders, initialBufferSize),, + new Encoder());, + this.failOnMissingResponse = failOnMissingResponse;, + }, +, + /**, + Decoder(int maxInitialLineLength, int maxHeaderSize, int maxChunkSize, boolean validateHeaders,, + int initialBufferSize) {, + super(maxInitialLineLength, maxHeaderSize, maxChunkSize, validateHeaders, initialBufferSize);, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + * Creates a new instance with the specified decoder options., + */, + public HttpClientCodec(, + int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,
[+++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, + super.setConnectTimeoutMillis(connectTimeoutMillis);, + return this;, + }, +, + @Override, + public RxtxChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead) {, + super.setMaxMessagesPerRead(maxMessagesPerRead);, + return this;, + super.setWriteSpinCount(writeSpinCount);, + return this;, + super.setAllocator(allocator);, + return this;, + super.setAutoRead(autoRead);, + return this;, + super.setWriteBufferHighWaterMark(writeBufferHighWaterMark);, + return this;, + super.setWriteBufferLowWaterMark(writeBufferLowWaterMark);, + return this;, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, + super.setConnectTimeoutMillis(connectTimeoutMillis);, + return this;, + }, +, + @Override, + public RxtxChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead) {, + super.setMaxMessagesPerRead(maxMessagesPerRead);, + return this;, + super.setWriteSpinCount(writeSpinCount);, + return this;, + super.setAllocator(allocator);, + return this;, + super.setAutoRead(autoRead);, + return this;, + super.setWriteBufferHighWaterMark(writeBufferHighWaterMark);, + return this;, + super.setWriteBufferLowWaterMark(writeBufferLowWaterMark);, + return this;, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, +import io.netty.handler.codec.DecoderResult;, +import io.netty.handler.codec.http.DefaultFullHttpRequest;, +import io.netty.handler.codec.http.HttpRequest;, +import io.netty.handler.codec.http.HttpVersion;, +import io.netty.handler.codec.http.LastHttpContent;, + private final HttpRequest request;, + public HttpPostRequestEncoder(HttpRequest request, boolean multipart) throws ErrorDataEncoderException {, + public HttpPostRequestEncoder(HttpDataFactory factory, HttpRequest request, boolean multipart), + HttpDataFactory factory, HttpRequest request, boolean multipart, Charset charset,, + public HttpRequest finalizeRequest() throws ErrorDataEncoderException {, +, + // wrap to hide the possible content, + return new WrappedHttpRequest(request);, + if (request instanceof FullHttpRequest) {, + FullHttpRequest fullRequest = (FullHttpRequest) request;, + if (!fullRequest.content().equals(chunk.content())) {, + fullRequest.content().clear().writeBytes(chunk.content());, + return fullRequest;, + } else {, + return new WrappedFullHttpRequest(request, chunk);, + }, + }, +, +
[+++ b/codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java, + @SuppressWarnings("UnusedParameters")]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + pipeline.remove0(this, true);, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + pipeline.remove0(this, true);, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, + remove0(ctx, false);, + remove0(ctx, false);, + void remove0(DefaultChannelHandlerContext ctx, boolean tearDown) {, + callHandlerRemoved(ctx, tearDown);, + callHandlerRemoved(oldCtx, false);, + private void callHandlerRemoved(final DefaultChannelHandlerContext ctx, final boolean tearDown) {, + callHandlerRemoved0(ctx, tearDown);, + callHandlerRemoved0(ctx, tearDown);, + private void callHandlerRemoved0(final DefaultChannelHandlerContext ctx, boolean tearDown) {, + if (!tearDown) {, + }]
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, + "TLSv1.2", "TLSv1.1", "TLSv1");, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, + "TLSv1.2", "TLSv1.1", "TLSv1");, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java, + SSLContext.setOptions(ctx, SSL.SSL_OP_NO_SSLv3);]
[+++ b/common/src/main/java/io/netty/util/UncheckedBooleanSupplier.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java, +public final class IdleStateEvent {, + /**, + * Create a new instance, + *, + * @param state the detailed idle state., + * @param count the count how often this kind of {@IdleStateEvent} was fired before, + * @param durationMillis the duration which caused the {@link IdleStateEvent} to get fired in milliseconds, + */, + /**, + * Return the count how often this kind of {@IdleStateEvent} was fired before., + */, + /**, + * Return the duration which caused the {@link IdleStateEvent} to get fired in milliseconds., + */]
[+++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, +import io.netty.channel.socket.nio.NioEventLoop;, + .eventLoop(new NioEventLoop()), + .eventLoop(new NioEventLoop(), new NioEventLoop()), +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, +import io.netty.channel.socket.nio.NioEventLoop;, + .eventLoop(new NioEventLoop()), + .eventLoop(new NioEventLoop(), new NioEventLoop()), +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioOioSocketSpdyEchoTest.java, +import io.netty.channel.socket.nio.NioEventLoop;, +import io.netty.channel.socket.oio.OioEventLoop;, + .eventLoop(new NioEventLoop()), + .eventLoop(new OioEventLoop(), new OioEventLoop()), +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, +import io.netty.channel.socket.nio.NioEventLoop;, + .eventLoop(new NioEventLoop()), + .eventLoop(new NioEventLoop(), new NioEventLoop()), +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioOioSocketSpdyEchoTest.java, +import io.netty.channel.socket.nio.NioEventLoop;, +import io.netty.channel.socket.oio.OioEventLoop;, + .eventLoop(new NioEventLoop()), + .eventLoop(new OioEventLoop(), new OioEventLoop()), +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/OioNioSocketSpdyEchoTest.java, +import io.netty.channel.socket.nio.NioEventLoop;, +import io.netty.channel.socket.oio.OioEventLoop;, + .eventLoop(new OioEventLoop()), + .eventLoop(new NioEventLoop(), new NioEventLoop()), +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, +import io.netty.channel.socket.nio.NioEventLoop;, + .eventLoop(new NioEventLoop()), + .eventLoop(new NioEventLoop(), new NioEventLoop()), +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioOioSocketSpdyEchoTest.java, +import io.netty.channel.socket.nio.NioEventLoop;, +import io.netty.channel.socket.oio.OioEventLoop;, + .eventLoop(new NioEventLoop()),
[+++ b/handler/src/main/java/io/netty/handler/ssl/ClientAuth.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/pom.xml, + <Import-Package>sun.misc.*;resolution:=optional,sun.nio.ch;resolution:=optional,sun.security.*;resolution:=optional,*</Import-Package>]
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketShutdownOutputBySelfTest.java, + ch.shutdownOutput().sync();, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketShutdownOutputBySelfTest.java, + ch.shutdownOutput().sync();, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java, + final ChannelFuture future = newFuture();, + shutdownOutput(future);, + } else {, + loop.execute(new Runnable() {, + @Override, + public void run() {, + shutdownOutput(future);, + }, + });, + }, + return future;, + }, +, + private void shutdownOutput(ChannelFuture future) {, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketShutdownOutputBySelfTest.java, + ch.shutdownOutput().sync();, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java, + final ChannelFuture future = newFuture();, + shutdownOutput(future);, + } else {, + loop.execute(new Runnable() {, + @Override, + public void run() {, + shutdownOutput(future);, + }, + });, + }, + return future;, + }, +, + private void
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + String[] ID_COMMANDS = { "/usr/bin/id", "/bin/id", "/usr/xpg4/bin/id", "id"};, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + String[] ID_COMMANDS = { "/usr/bin/id", "/bin/id", "/usr/xpg4/bin/id", "id"};, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + if (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &&, + !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &&, + !PlatformDependent.isWindows() && !PlatformDependent.isRoot()) {, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + String[] ID_COMMANDS = { "/usr/bin/id", "/bin/id", "/usr/xpg4/bin/id", "id"};, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + if (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &&, + !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &&, + !PlatformDependent.isWindows() && !PlatformDependent.isRoot()) {, +++ b/transport/src/main/java/io/netty/channel/socket/DefaultDatagramChannelConfig.java, + !javaSocket.getLocalAddress().isAnyLocalAddress() &&, + !PlatformDependent.isWindows() && !PlatformDependent.isRoot()) {]
[+++ b/pom.xml, + <repositories>, + <repository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </repository>, + </repositories>, +, + <pluginRepositories>, + <pluginRepository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </pluginRepository>, + </pluginRepositories>, +, +++ b/pom.xml, + <repositories>, + <repository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </repository>, + </repositories>, +, + <pluginRepositories>, + <pluginRepository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </pluginRepository>, + </pluginRepositories>, +, +++ b/src/docbook/en-US/module/architecture.xml, + to represent a sequence of bytes. This approach has significant advantage, + &ChannelBuffer; has been designed from ground up to address the problems, + You can define your buffer type if necessary., + Transparent zero copy is achieved by built-in
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsQueryContext.java, +import io.netty.util.concurrent.FutureListener;, +final class DnsQueryContext implements FutureListener<AddressedEnvelope<DnsResponse, InetSocketAddress>> {, + // Ensure we remove the id from the QueryContextManager once the query completes., + promise.addListener(this);, +, + public void operationComplete(ChannelFuture future) {, +, + @Override, + public void operationComplete(Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> future) {, + // Cancel the timeout task., + final ScheduledFuture<?> timeoutFuture = this.timeoutFuture;, + if (timeoutFuture != null) {, + this.timeoutFuture = null;, + timeoutFuture.cancel(false);, + }, +, + // Remove the id from the manager as soon as the query completes. This may be because of success, failure or, + // cancellation, + parent.queryContextManager.remove(nameServerAddr, id);,
[+++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, + /**, + * Returns a String which contains all details to log the {@link ByteBuf}, + */, + /**, + * Returns a String which contains all details to log the {@link Object}, + */, +++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, + /**, + * Returns a String which contains all details to log the {@link ByteBuf}, + */, + /**, + * Returns a String which contains all details to log the {@link Object}, + */, +++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java, + * ctx.close();, + * ctx.writeAndFlush(new PingMessage());, + /**, + * Is called when an {@link IdleStateEvent} should be fired. This
[+++ b/transport/src/main/java/io/netty/channel/ChannelPromiseAggregator.java, + public ChannelPromiseAggregator add(ChannelPromise... promises) {, + if (promises == null) {, + throw new NullPointerException("promises");, + }, + for (ChannelPromise p: promises) {, + if (p == null) {, + continue;, + pendingPromises.add(p);, + p.addListener(this);, + }, + }, + return this;]
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java, + ciphers, cipherFilter, apn, ClientAuth.NONE, null, false);, + ApplicationProtocolConfig apn, String[] protocols, long sessionCacheSize, long sessionTimeout), + throws SSLException {, + ciphers, cipherFilter, toNegotiator(apn, false), ClientAuth.NONE, protocols, false);, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslClientContext.java, + ciphers, cipherFilter, apn, ClientAuth.NONE, null, false);, + ApplicationProtocolConfig apn, String[] protocols, long sessionCacheSize, long sessionTimeout), + throws SSLException {, + ciphers, cipherFilter, toNegotiator(apn, false), ClientAuth.NONE, protocols, false);, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, + static final String[] DEFAULT_PROTOCOLS;, + DEFAULT_PROTOCOLS = protocols.toArray(new String[protocols.size()]);, + DEFAULT_PROTOCOLS = engine.getEnabledProtocols();, + logger.debug("Default protocols (JDK): {} ", Arrays.asList(DEFAULT_PROTOCOLS));, + private final String[] protocols;, + JdkDefaultApplicationProtocolNegotiator.INSTANCE, clientAuth, null, false);, + this(sslContext, isClient, ciphers, cipherFilter, toNegotiator(apn,
[+++ b/handler/src/main/java/io/netty/handler/ssl/NotSslRecordException.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, +import javax.net.ssl.X509ExtendedTrustManager;, + private final OpenSslEngineMap engineMap;, + engineMap = newEngineMap(manager);, +, + // Use this to prevent an error when running on java < 7, + if (useExtendedTrustManager(manager)) {, + final X509ExtendedTrustManager extendedManager = (X509ExtendedTrustManager) manager;, + SSLContext.setCertVerifyCallback(ctx, new AbstractCertificateVerifier() {, + void verify(long ssl, X509Certificate[] peerCerts, String auth) throws Exception {, + OpenSslEngine engine = engineMap.remove(ssl);, + extendedManager.checkServerTrusted(peerCerts, auth, engine);, + } else {, + SSLContext.setCertVerifyCallback(ctx, new AbstractCertificateVerifier() {, + @Override, + void verify(long ssl, X509Certificate[] peerCerts, String auth) throws Exception {, + manager.checkServerTrusted(peerCerts, auth);, + }, + });, + }, + @Override, + OpenSslEngineMap
[+++ b/all/pom.xml, + <artifactId>netty-codec-http2</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>]
[+++ b/transport/src/main/java/io/netty/channel/socket/oio/DefaultOioSocketChannelConfig.java, + super.setAllowHalfClosure(allowHalfClosure);]
[+++ b/transport-sctp/pom.xml, + <plugin>, + <artifactId>maven-jar-plugin</artifactId>, + <configuration>, + <excludes>, + <!-- Exclude the com.sun.nio stuff as this is included in the jdk if its supported by the running os -->, + <exclude>**/com/**</exclude>, + </excludes>, + , + </configuration>, + </plugin>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/WebSocketClientCompressionHandler.java, +import io.netty.channel.ChannelHandler;, +@ChannelHandler.Sharable, +public final class WebSocketClientCompressionHandler extends WebSocketClientExtensionHandler {, + public static final WebSocketClientCompressionHandler INSTANCE = new WebSocketClientCompressionHandler();, +, + private WebSocketClientCompressionHandler() {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/WebSocketClientCompressionHandler.java, +import io.netty.channel.ChannelHandler;, +@ChannelHandler.Sharable, +public final class WebSocketClientCompressionHandler extends WebSocketClientExtensionHandler {, + public static final WebSocketClientCompressionHandler INSTANCE = new WebSocketClientCompressionHandler();, +, + private WebSocketClientCompressionHandler() {, +++ b/example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java, + WebSocketClientCompressionHandler.INSTANCE,]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + handler().userEventTriggered(this, event);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, + private final SpdyFrameDecoder decoder = new SpdyFrameDecoder();, + private final SpdyFrameEncoder encoder = new SpdyFrameEncoder();, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, + private final SpdyFrameDecoder decoder = new SpdyFrameDecoder();, + private final SpdyFrameEncoder encoder = new SpdyFrameEncoder();, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + super();, + spdyDataFrame.setCompressed((flags & SPDY_DATA_FLAG_COMPRESS) != 0);, + spdyDataFrame.setData(buffer.readBytes(dataLength));, + return spdyDataFrame;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyCodecUtil.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, + private final SpdyFrameDecoder decoder = new SpdyFrameDecoder();, + private final SpdyFrameEncoder encoder = new SpdyFrameEncoder();, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + super();, + spdyDataFrame.setCompressed((flags & SPDY_DATA_FLAG_COMPRESS) != 0);, + spdyDataFrame.setData(buffer.readBytes(dataLength));, + return spdyDataFrame;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, + private final EncoderEmbedder<ChannelBuffer> headerBlockCompressor
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * Similar to {@link ByteBuf#discardReadBytes()} except that this method might discard, + * some, all, or none of read bytes depending on its internal implementation to reduce, + * overall memory bandwidth consumption at the cost of potentially additional memory, + * consumption., + */, + void discardSomeReadBytes();, +, + /**, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * Similar to {@link ByteBuf#discardReadBytes()} except that this method might discard, + * some, all, or none of read bytes depending on its internal implementation to reduce, + * overall memory bandwidth consumption at the cost of potentially additional memory, + *
[+++ b/buffer/src/main/java/io/netty/buffer/PoolSubpage.java, + if (chunk == null) {, + // This is the head so there is no need to synchronize at all as these never change., + doNotDestroy = true;, + maxNumElems = 0;, + numAvail = 0;, + elemSize = -1;, + } else {, + }, + if (chunk == null) {, + // It's the head., + return 0;, + }, +, + if (chunk == null) {, + // It's the head., + return 0;, + }, +, + if (chunk == null) {, + // It's the head., + return -1;, + }, +]
[+++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java]
[+++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, +++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, +++ b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java, + channel.closeFuture().addListener(remover);, + c.closeFuture().removeListener(remover);]
[+++ b/codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java, +import io.netty.util.ByteProcessor;, + int i = buffer.forEachByte(ByteProcessor.FIND_LF);, + if (i > 0 && buffer.getByte(i - 1) == '\r') {, + i--;, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + * @apiviz.has io.netty.handler.codec.http.HttpRequest oneway - - decodes URI, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + * @apiviz.has io.netty.handler.codec.http.HttpRequest oneway - - decodes URI, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java, + * @apiviz.has io.netty.handler.codec.http.HttpRequest oneway - - encodes URI, + return URLEncoder.encode(s, charset.name()).replace("+", "%20");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + * @apiviz.has io.netty.handler.codec.http.HttpRequest oneway - - decodes URI, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java, + * @apiviz.has io.netty.handler.codec.http.HttpRequest oneway - - encodes URI, + return URLEncoder.encode(s, charset.name()).replace("+", "%20");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + * @apiviz.has io.netty.handler.codec.http.HttpRequest oneway - - decodes URI, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java, + * @apiviz.has io.netty.handler.codec.http.HttpRequest oneway - - encodes URI, + return URLEncoder.encode(s, charset.name()).replace("+", "%20");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameEncoder.java, +++
[+++ b/common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java, +import java.lang.Thread.UncaughtExceptionHandler;, + generatorThread.setDaemon(true);, + generatorThread.setUncaughtExceptionHandler(new UncaughtExceptionHandler() {, + @Override, + public void uncaughtException(Thread t, Throwable e) {, + logger.debug("An exception has been raised by {}", t.getName(), e);, + }, + });, + boolean interrupted = false;, + generatorThread.interrupt();, + "Not enough entrophy?", timeoutSeconds, + );, + interrupted = true;, + generatorThread.interrupt();, + logger.warn("Failed to generate a seed from SecureRandom due to an InterruptedException.");, + break;, +, + if (interrupted) {, + // restore interrupt status because we don't know how to/don't need to handle it here, + Thread.currentThread().interrupt();, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpContent.java, + "(data: " + content() + ", decoderResult: " + getDecoderResult() + ')';, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpContent.java, + "(data: " + content() + ", decoderResult: " + getDecoderResult() + ')';, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpRequest.java, + buf.append(getMethod());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpContent.java, + "(data: " + content() + ", decoderResult: " + getDecoderResult() + ')';, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpRequest.java, + buf.append(getMethod());, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java, +import io.netty.util.internal.StringUtil;, + return StringUtil.simpleClassName(this) +, + "(data: " + content() + ", getDecoderResult: " + getDecoderResult() + ')';, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpContent.java, + "(data: " + content() + ", decoderResult: " + getDecoderResult() + ')';, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpRequest.java, + buf.append(getMethod());, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java, +import io.netty.util.internal.StringUtil;, + return
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, + InternalAttribute internal = new InternalAttribute(charset);, + InternalAttribute internal = new InternalAttribute(charset);, + InternalAttribute internal = new InternalAttribute(charset);, + internal = new InternalAttribute(charset);, + InternalAttribute internal = new InternalAttribute(charset);, + buffer = ((InternalAttribute) currentData).toByteBuf();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, + InternalAttribute internal = new InternalAttribute(charset);, + InternalAttribute internal = new InternalAttribute(charset);, + InternalAttribute internal = new InternalAttribute(charset);, + internal = new InternalAttribute(charset);, + InternalAttribute internal = new InternalAttribute(charset);, + buffer = ((InternalAttribute) currentData).toByteBuf();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/InternalAttribute.java, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.Unpooled;, +, +import java.nio.charset.Charset;, + private final List<ByteBuf> value = new ArrayList<ByteBuf>();, + private final Charset charset;, + private int size;, +
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;, + checkPositiveOrZero(maxCapacity, "maxCapacity");, + checkPositiveOrZero(minWritableBytes, "minWritableBytes");, + checkPositiveOrZero(minWritableBytes, "minWritableBytes");, + checkPositiveOrZero(minimumReadableBytes, "minimumReadableBytes");, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;, + checkPositiveOrZero(maxCapacity, "maxCapacity");, + checkPositiveOrZero(minWritableBytes, "minWritableBytes");, + checkPositiveOrZero(minWritableBytes, "minWritableBytes");, + checkPositiveOrZero(minimumReadableBytes, "minimumReadableBytes");, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;, +, + checkPositiveOrZero(initialCapacity, "initialCapacity");, + checkPositiveOrZero(minNewCapacity, "minNewCapacity");, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;, + checkPositiveOrZero(maxCapacity, "maxCapacity");, + checkPositiveOrZero(minWritableBytes, "minWritableBytes");, + checkPositiveOrZero(minWritableBytes, "minWritableBytes");, + checkPositiveOrZero(minimumReadableBytes, "minimumReadableBytes");, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;, +, + checkPositiveOrZero(initialCapacity, "initialCapacity");, + checkPositiveOrZero(minNewCapacity, "minNewCapacity");, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;, + checkPositiveOrZero(length, "length");, + checkPositiveOrZero(length, "length");, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;, + checkPositiveOrZero(maxCapacity, "maxCapacity");, + checkPositiveOrZero(minWritableBytes, "minWritableBytes");, + checkPositiveOrZero(minWritableBytes,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, + private int streamId;, + * @param streamId the Stream-ID of this frame, + public DefaultSpdyDataFrame(int streamId) {, + setStreamId(streamId);, + public int getStreamId() {, + return streamId;, + public void setStreamId(int streamId) {, + if (streamId <= 0) {, + "Stream-ID must be positive: " + streamId);, + this.streamId = streamId;, + buf.append(streamId);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, + private int streamId;, + * @param streamId the Stream-ID of this frame, + public DefaultSpdyDataFrame(int streamId) {, + setStreamId(streamId);, + public int getStreamId() {, + return streamId;, + public void setStreamId(int streamId) {, + if (streamId <= 0) {, +
[+++ b/src/main/java/org/jboss/netty/handler/codec/serialization/CompatibleObjectDecoder.java, +++ b/src/main/java/org/jboss/netty/handler/codec/serialization/CompatibleObjectDecoder.java, +++ b/src/main/java/org/jboss/netty/handler/codec/serialization/SwitchableInputStream.java, +/*, + * Copyright 2009 Red Hat, Inc., + *, + * Red Hat licenses this file to you under the Apache License, version 2.0, + * (the "License"); you may not use this file except in compliance with the, + * License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY
[+++ b/common/src/main/java/io/netty/util/concurrent/PromiseAggregator.java, + @SafeVarargs, +++ b/common/src/main/java/io/netty/util/concurrent/PromiseAggregator.java, + @SafeVarargs, +++ b/common/src/main/java/io/netty/util/concurrent/PromiseNotifier.java, + @SafeVarargs]
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java, +import io.netty.util.internal.PlatformDependent;, + if (!PlatformDependent.isAndroid()) {, + // Only try to use when not on Android as the classes not exists there:, + // See https://github.com/netty/netty/issues/8654, + DirContextUtils.addNameServers(defaultNameServers, DNS_PORT);, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java, +import io.netty.util.internal.PlatformDependent;, + if (!PlatformDependent.isAndroid()) {, + // Only try to use when not on Android as the classes not exists there:, + // See https://github.com/netty/netty/issues/8654, + DirContextUtils.addNameServers(defaultNameServers, DNS_PORT);, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DirContextUtils.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + final AtomicBoolean readable = new AtomicBoolean(true);, + return readable.get();, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + final AtomicBoolean readable = new AtomicBoolean(true);, + return readable.get();, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, + if (ctx.readable.compareAndSet(!readable, readable)) {]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java, + public boolean consumeBytes(ChannelHandlerContext ctx, Http2Stream stream, int numBytes), + boolean windowUpdateSent = connectionState().consumeBytes(ctx, numBytes);, + windowUpdateSent |= state(stream).consumeBytes(ctx, numBytes);, + return windowUpdateSent;, + return false;, + public boolean consumeBytes(ChannelHandlerContext ctx, int numBytes) throws Http2Exception {, + return writeWindowUpdateIfNeeded(ctx);, + public boolean writeWindowUpdateIfNeeded(ChannelHandlerContext ctx) throws Http2Exception {, + return false;, + return true;, + return false;, + public boolean writeWindowUpdateIfNeeded(ChannelHandlerContext ctx) throws Http2Exception {, + public boolean consumeBytes(ChannelHandlerContext ctx, int numBytes) throws Http2Exception {, + return false;, + *, + * @return true if {@code WINDOW_UPDATE} was written, false otherwise., + boolean writeWindowUpdateIfNeeded(ChannelHandlerContext ctx) throws Http2Exception;, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, + if (HttpHeaderValues.IDENTITY.contentEqualsIgnoreCase(contentEncoding)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, + if (HttpHeaderValues.IDENTITY.contentEqualsIgnoreCase(contentEncoding)) {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java, + @Test, + public void testIdentity() throws Exception {, + EmbeddedChannel ch = new EmbeddedChannel(new HttpContentCompressor());, + assertTrue(ch.writeInbound(newRequest()));, +, + FullHttpResponse res = new DefaultFullHttpResponse(, + HttpVersion.HTTP_1_1, HttpResponseStatus.OK,, + Unpooled.copiedBuffer("Hello, World", CharsetUtil.US_ASCII));, + int len = res.content().readableBytes();, + res.headers().set(HttpHeaderNames.CONTENT_LENGTH, len);, + res.headers().set(HttpHeaderNames.CONTENT_ENCODING, HttpHeaderValues.IDENTITY);, + assertTrue(ch.writeOutbound(res));, +, + FullHttpResponse response = (FullHttpResponse) ch.readOutbound();, + assertEquals(String.valueOf(len), response.headers().get(HttpHeaderNames.CONTENT_LENGTH));, + assertEquals(HttpHeaderValues.IDENTITY.toString(), response.headers().get(HttpHeaderNames.CONTENT_ENCODING));, + assertEquals("Hello, World", response.content().toString(CharsetUtil.US_ASCII));, + response.release();, +, + assertTrue(ch.finishAndReleaseAll());, + }, +]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/transport-native-epoll/src/main/c/netty_epoll_linuxsocket.c, +static void netty_epoll_linuxsocket_setTimeToLive(JNIEnv* env, jclass clazz, jint fd, jint optval) {, + netty_unix_socket_setOption(env, fd, IPPROTO_IP, IP_TTL, &optval, sizeof(optval));, +}, +, +static void netty_epoll_linuxsocket_setInterface(JNIEnv* env, jclass clazz, jint fd, jbyteArray interfaceAddress, jint scopeId) {, + struct sockaddr_storage interfaceAddr;, + socklen_t interfaceAddrSize;, + struct sockaddr_in* interfaceIpAddr;, + struct sockaddr_in6* interfaceIp6Addr;, +, + if (netty_unix_socket_initSockaddr(env, interfaceAddress, scopeId, 0, &interfaceAddr, &interfaceAddrSize) == -1) {, + return;, + }, +, + switch (interfaceAddr.ss_family) {, + case AF_INET:, + interfaceIpAddr = (struct sockaddr_in*) &interfaceAddr;, + netty_unix_socket_setOption(env, fd, IPPROTO_IP, IP_MULTICAST_IF, &interfaceIpAddr->sin_addr, sizeof(interfaceIpAddr->sin_addr));, + break;, + case AF_INET6:, + interfaceIp6Addr = (struct sockaddr_in6*) &interfaceAddr;, +
[+++ b/pom.xml, + <javadocDirectory>${basedir}/src/javadoc</javadocDirectory>, + <docfilessubdirs>true</docfilessubdirs>]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + ChannelHandlerContext ctx, HttpObject msg, MessageList<Object> out) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + ChannelHandlerContext ctx, HttpObject msg, MessageList<Object> out) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, +import io.netty.channel.MessageList;, +import io.netty.handler.codec.MessageToMessageEncoder;, +public abstract class HttpObjectEncoder<H extends HttpMessage> extends MessageToMessageEncoder<HttpObject> {, + private static final ByteBuf ZERO_CRLF_CRLF_BUF =, + unreleasableBuffer(directBuffer(5, 5).writeBytes(ZERO_CRLF).writeBytes(CRLF));, + protected void encode(ChannelHandlerContext ctx, HttpObject msg, MessageList<Object> out) throws Exception {, + ByteBuf buf = ctx.alloc().buffer();, + encodeInitialLine(buf, m);, + encodeHeaders(buf, m.headers());, + buf.writeBytes(CRLF);, + out.add(buf);, + out.add(content.retain());, + byte[] length = Integer.toHexString(contentLength).getBytes(CharsetUtil.US_ASCII);, + ByteBuf buf = ctx.alloc().buffer(length.length + 2);, + buf.writeBytes(length);, + buf.writeBytes(CRLF);, + out.add(buf);, + out.add(content.retain());, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java, + maxHeaderListSize = MAX_HEADER_LIST_SIZE;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HpackEncoder.java, + maxHeaderListSize = MAX_HEADER_LIST_SIZE;, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/HpackEncoderTest.java, +, + /**, + * The encoder should not impose an arbitrary limit on the header size if, + * the server has not specified any limit., + * @throws Http2Exception, + */, + @Test, + public void testWillEncode16MBHeaderByDefault() throws Http2Exception {, + ByteBuf buf = Unpooled.buffer();, + String bigHeaderName = "x-big-header";, + int bigHeaderSize = 1024 * 1024 * 16;, + String bigHeaderVal = new String(new char[bigHeaderSize]).replace('\0', 'X');, + Http2Headers headersIn = new DefaultHttp2Headers().add(, + "x-big-header", bigHeaderVal);, + Http2Headers headersOut = new DefaultHttp2Headers();, +,
[+++ b/common/src/main/java/io/netty/util/internal/SocketUtils.java, + public static InetAddress loopbackAddress() {, + return AccessController.doPrivileged(new PrivilegedAction<InetAddress>() {, + @Override, + public InetAddress run() {, + if (PlatformDependent.javaVersion() >= 7) {, + return InetAddress.getLoopbackAddress();, + }, + try {, + return InetAddress.getByName(null);, + } catch (UnknownHostException e) {, + throw new IllegalStateException(e);, + }, + }, + });, + }, +, +++ b/common/src/main/java/io/netty/util/internal/SocketUtils.java, + public static InetAddress loopbackAddress() {, + return AccessController.doPrivileged(new PrivilegedAction<InetAddress>() {, + @Override, + public InetAddress run() {, + if (PlatformDependent.javaVersion() >= 7) {, + return InetAddress.getLoopbackAddress();, + }, + try {, + return InetAddress.getByName(null);, + } catch (UnknownHostException e) {,
[+++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +import java.util.Collections;, + final Channel channel = channelFactory.newChannel();, + /**, + * Returns the configured {@link EventLoopGroup} or {@code null} if non is configured yet., + *, + * @deprecated Use {@link #config()} instead., + */, + @Deprecated, + public final EventLoopGroup group() {, + return group;, + }, +, + /**, + * Returns the {@link AbstractBootstrapConfig} object that can be used to obtain the current config, + * of the bootstrap., + */, + public abstract AbstractBootstrapConfig<B, C> config();, +, + static <K, V> Map<K, V> copiedMap(Map<K, V> map) {, + final Map<K, V> copied;,
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkNpnApplicationProtocolNegotiator.java, + + " See https://wiki.eclipse.org/Jetty/Feature/NPN");]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseStatus.java, + if (responseStatus.reasonPhrase().contentEquals(reasonPhrase)) {, + if (!status.reasonPhrase().contentEquals(actualReason)) {]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, + final String charsetHeader = HttpHeaderValues.CHARSET.toString();, + if (contents[i].regionMatches(true, 0, charsetHeader, 0, charsetHeader.length())) {, + attribute = factory.createAttribute(request, charsetHeader, cleanString(values));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, + final String charsetHeader = HttpHeaderValues.CHARSET.toString();, + if (contents[i].regionMatches(true, 0, charsetHeader, 0, charsetHeader.length())) {, + attribute = factory.createAttribute(request, charsetHeader, cleanString(values));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java, + final String multiPartHeader = HttpHeaderValues.MULTIPART_FORM_DATA.toString();, + if (headerContentType[0].regionMatches(true, 0, multiPartHeader, 0 , multiPartHeader.length())) {, + final String boundaryHeader = HttpHeaderValues.BOUNDARY.toString();, + if (headerContentType[1].regionMatches(true, 0, boundaryHeader, 0, boundaryHeader.length())) {, + } else if (headerContentType[2].regionMatches(true, 0, boundaryHeader, 0, boundaryHeader.length())) {, + final String charsetHeader = HttpHeaderValues.CHARSET.toString();, + if (headerContentType[crank].regionMatches(true, 0, charsetHeader, 0, charsetHeader.length())) {]
[+++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, +import io.netty.util.internal.MathUtil;, + this.size = MathUtil.findNextPositivePowerOfTwo(size);, +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, +import io.netty.util.internal.MathUtil;, + this.size = MathUtil.findNextPositivePowerOfTwo(size);, +++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java, +import io.netty.util.internal.MathUtil;, + // Should be power of two., + private static final int DEFAULT_SAMPLING_INTERVAL = 128;, + private final int mask;, + this.samplingInterval = MathUtil.findNextPositivePowerOfTwo(samplingInterval);, + // samplingInterval is a power of two so we calculate a mask that we can use to, + // check if we need to do any leak detection or not., + mask = this.samplingInterval - 1;, + if ((leakCheckCnt ++ & mask) == 0) {, +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, +import io.netty.util.internal.MathUtil;, + this.size = MathUtil.findNextPositivePowerOfTwo(size);, +++
[+++ b/pom.xml, + <groupId>org.ops4j.pax.exam</groupId>, + <artifactId>maven-paxexam-plugin</artifactId>, + <version>1.2.4</version>, + </plugin>, + <plugin>]
[+++ b/pom.xml, + <autoVersionSubmodules>true</autoVersionSubmodules>, + <tagNameFormat>netty-${project.version}</tagNameFormat>]
[+++ /dev/null, +++ /dev/null, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + setHandshakeComplete();, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + setHandshakeComplete();, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + setHandshakeComplete();, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + setHandshakeComplete();, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + setHandshakeComplete();, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java, + setHandshakeComplete();, +]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2ConnectionDecoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2ConnectionDecoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2ConnectionDecoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionDecoder.java]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + if (executor.inEventLoop()) {, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + if (executor.inEventLoop()) {, +++ b/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java, + processSelectedKeys();, + runAllTasks();, + if (!inEventLoop && wakenUp.compareAndSet(false, true)) {]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, + q = Float.parseFloat(encoding.substring(equalsPos + 1));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, + q = Float.parseFloat(encoding.substring(equalsPos + 1));, +++ b/codec/src/main/java/io/netty/handler/codec/CharSequenceValueConverter.java, + return Byte.parseByte(value.toString());, + return Short.parseShort(value.toString());, + return Float.parseFloat(value.toString());, + return Double.parseDouble(value.toString());]
[+++ b/buffer/src/main/java/io/netty/buffer/UnsafeByteBufUtil.java, + src.position(src.position() + length);, + } else if (src.hasArray()) {, + } else {, + ByteBuf tmpBuf = buf.alloc().heapBuffer(length);, + try {, + byte[] tmp = tmpBuf.array();, + src.get(tmp, tmpBuf.arrayOffset(), length); // moves the src position too, + PlatformDependent.copyMemory(tmp, 0, addr, length);, + } finally {, + tmpBuf.release();, + }, + }, +++ b/buffer/src/main/java/io/netty/buffer/UnsafeByteBufUtil.java, + src.position(src.position() + length);, + } else if (src.hasArray()) {, + } else {, + ByteBuf tmpBuf = buf.alloc().heapBuffer(length);, + try {, + byte[] tmp = tmpBuf.array();, + src.get(tmp, tmpBuf.arrayOffset(), length); // moves the src position too, + PlatformDependent.copyMemory(tmp, 0, addr, length);, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, + payloadBuffer.release();]
[+++ b/src/main/resources/META-INF/jboss-beans.xml, + <bean name="org.jboss.netty.internal.ResourceFactory", + <depends>org.jboss.netty.internal.ResourceFactory</depends>, + <factory bean="org.jboss.netty.internal.ResourceFactory"/>]
[+++ b/transport/src/main/java/io/netty/channel/EventLoopGroup.java, + * Register a {@link Channel} with this {@link EventLoop} using a {@link ChannelFuture}. The passed, + * {@link ChannelFuture} will get notified once the registration was complete and also will get returned., + */, + ChannelFuture register(ChannelPromise promise);, +, + /**, + *, + * @deprecated Use {@link #register(ChannelPromise)} instead., + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/EventLoopGroup.java, + * Register a {@link Channel} with this {@link EventLoop} using a {@link ChannelFuture}. The passed, + * {@link ChannelFuture} will get notified once the registration was complete and also will get returned., + */, + ChannelFuture register(ChannelPromise promise);, +, + /**,
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + EventExecutor executor = next.executor();, + if (executor.inEventLoop()) {, + next.curCtxFireInboundBufferUpdatedTask.run();, + } else {, + executor.execute(next.curCtxFireInboundBufferUpdatedTask);, + }, + DefaultChannelHandlerContext ctx = next;, + for (;;) {, + if (ctx == null) {, + return false;, + }, + if (ctx.inByteBridge != null) {, + return true;, + }, + ctx = ctx.next;, + }, + DefaultChannelHandlerContext ctx = next;, + for (;;) {, + if (ctx == null) {, + return false;, + }, + if (ctx.inMsgBridge != null) {, + return true;, + }, + ctx = ctx.next;, + }, + DefaultChannelHandlerContext ctx =
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java, +import io.netty.resolver.InetSocketAddressResolver;, +import io.netty.resolver.NameResolver;, +import io.netty.util.concurrent.Promise;, +import java.net.InetAddress;, +import java.util.List;, +import java.util.concurrent.ConcurrentMap;, +import static io.netty.util.internal.PlatformDependent.newConcurrentHashMap;, + private final ConcurrentMap<String, Promise<InetAddress>> resolvesInProgress = newConcurrentHashMap();, + private final ConcurrentMap<String, Promise<List<InetAddress>>> resolveAllsInProgress = newConcurrentHashMap();, +, + final NameResolver<InetAddress> resolver = new InflightNameResolver<InetAddress>(, + eventLoop,, + new DnsNameResolverBuilder(eventLoop), + .build(),, + resolvesInProgress,, + resolveAllsInProgress);, +, + return new InetSocketAddressResolver(eventLoop, resolver);, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java, +import io.netty.resolver.InetSocketAddressResolver;, +import io.netty.resolver.NameResolver;, +import io.netty.util.concurrent.Promise;, +import java.net.InetAddress;, +import java.util.List;, +import java.util.concurrent.ConcurrentMap;, +import static io.netty.util.internal.PlatformDependent.newConcurrentHashMap;, + private final ConcurrentMap<String, Promise<InetAddress>> resolvesInProgress = newConcurrentHashMap();, + private final ConcurrentMap<String, Promise<List<InetAddress>>> resolveAllsInProgress = newConcurrentHashMap();, +, + final NameResolver<InetAddress> resolver = new InflightNameResolver<InetAddress>(,
[+++ b/common/src/main/java/io/netty/util/internal/MacAddressUtil.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/src/docbook/master.xml, + <!-- The following chapters are not written yet. -->, + <!--]
[+++ b/codec/src/main/java/io/netty/handler/codec/embedder/EmbeddedChannel.java, + super(null, null, ChannelBufferHolders.catchAllBuffer(, + productQueue, ChannelBuffers.dynamicBuffer()));, +++ b/codec/src/main/java/io/netty/handler/codec/embedder/EmbeddedChannel.java, + super(null, null, ChannelBufferHolders.catchAllBuffer(, + productQueue, ChannelBuffers.dynamicBuffer()));, +++ /dev/null, +++ b/codec/src/main/java/io/netty/handler/codec/embedder/EmbeddedChannel.java, + super(null, null, ChannelBufferHolders.catchAllBuffer(, + productQueue, ChannelBuffers.dynamicBuffer()));, +++ /dev/null, +++ /dev/null, +++ b/codec/src/main/java/io/netty/handler/codec/embedder/EmbeddedChannel.java, + super(null, null, ChannelBufferHolders.catchAllBuffer(, + productQueue, ChannelBuffers.dynamicBuffer()));, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/codec/src/main/java/io/netty/handler/codec/embedder/EmbeddedChannel.java, + super(null, null, ChannelBufferHolders.catchAllBuffer(, + productQueue, ChannelBuffers.dynamicBuffer()));, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/example/src/main/java/io/netty/example/localecho/LocalEcho.java, +/*, + * Copyright 2011 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use
[+++ b/transport/src/test/java/io/netty/channel/nio/NioEventLoopTest.java, + @Test(timeout = 3000)]
[+++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketChannelTest.java, +import io.netty.util.ReferenceCountUtil;, + ReferenceCountUtil.release(msg);]
[+++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, +, + // We are done with init the Channel, removing all the state for the Channel now., + removeState(ctx);, + if (initChannel(ctx)) {, +, + // We are done with init the Channel, removing the initializer now., + removeState(ctx);, + }, + ChannelPipeline pipeline = ctx.pipeline();, + if (pipeline.context(this) != null) {, + pipeline.remove(this);, + }, + private void removeState(final ChannelHandlerContext ctx) {, + // The context is not removed yet which is most likely the case because a custom EventExecutor is used., + // Let's schedule it on the EventExecutor to give it some more
[+++ b/all/pom.xml, + <id>linux</id>, +++ b/all/pom.xml, + <id>linux</id>, +++ b/pom.xml, + <version>9</version>, + <id>linux</id>, + <!--, + Netty must be released from RHEL 6.5 x86_64 or compatible so that:, +, + 1) we ship x86_64 version of epoll transport officially, and, + 2) we ensure the ABI compatibility with older GLIBC versions., +, + The shared library built on a distribution with newer GLIBC, + will not run on older distributions., + -->, + <profile>, + <id>release</id>, + <build>, + <plugins>, + <plugin>, + <artifactId>maven-enforcer-plugin</artifactId>, + <executions>, + <execution>, + <id>enforce-release-environment</id>, + <goals>, + <goal>enforce</goal>, + </goals>, + <configuration>,
[+++ b/common/src/main/java/io/netty/util/DomainMappingBuilder.java, +import java.util.Collections;, +import java.util.HashMap;, + public Set<Map.Entry<String, V>> entries() {, + int length = domainNamePatterns.length;, + Map<String, V> map = new HashMap<String, V>(length);, + for (int index = 0; index < length; ++index) {, + map.put(domainNamePatterns[index], values[index]);, + }, + return Collections.unmodifiableSet(map.entrySet());, + }, +, + @Override, +++ b/common/src/main/java/io/netty/util/DomainMappingBuilder.java, +import java.util.Collections;, +import java.util.HashMap;, + public Set<Map.Entry<String, V>> entries() {, + int length = domainNamePatterns.length;, + Map<String, V> map = new HashMap<String, V>(length);, + for (int index = 0; index < length; ++index) {, + map.put(domainNamePatterns[index], values[index]);, + }, + return Collections.unmodifiableSet(map.entrySet());, + }, +, + @Override, +++
[+++ b/src/docbook/module/architecture.xml, + stack on top of the core., + against other frameworks. Many NIO frameworks have no or very limited, + For more information about the event model, please refer to the, + have to deal with the fragmentation of messages. Some protocols are, + multi-layered (i.e. built on top of other lower level protocol). Some, + are too complicated to be implemented in a single state machine., + Unlike old blocking I/O, it is a non-trivial task to support SSL in NIO., + You can't simply wrap a stream to encrypt or decrypt data but you have,
[+++ b/all/pom.xml, + <version>4.1.30.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.30.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.30.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.30.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.30.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, + <version>4.1.30.Final-SNAPSHOT</version>, +
[+++ b/all/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR6-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java, + // Two years are supported by all our EventLoop implementations and so safe to use as maximum., + // See also: https://github.com/netty/netty/commit/b47fb817991b42ec8808c7d26538f3f2464e1fa6, + private static final int MAX_SUPPORTED_TTL_SECS = (int) TimeUnit.DAYS.toSeconds(365 * 2);, + this(0, MAX_SUPPORTED_TTL_SECS, 0);, + cache0(e, Math.max(minTtl, Math.min(MAX_SUPPORTED_TTL_SECS, (int) Math.min(maxTtl, originalTtl))), loop);, + cache0(e, Math.min(MAX_SUPPORTED_TTL_SECS, negativeTtl), loop);, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java, + // Two years are supported by all our EventLoop implementations and so safe to use as maximum., + // See also: https://github.com/netty/netty/commit/b47fb817991b42ec8808c7d26538f3f2464e1fa6, + private static final int MAX_SUPPORTED_TTL_SECS = (int) TimeUnit.DAYS.toSeconds(365 * 2);, + this(0, MAX_SUPPORTED_TTL_SECS, 0);, + cache0(e, Math.max(minTtl, Math.min(MAX_SUPPORTED_TTL_SECS, (int) Math.min(maxTtl,
[+++ b/common/src/main/java/io/netty/monitor/MonitorName.java, + result = prime * result + (group == null ? 0 : group.hashCode());, + result = prime * result + (instance == null ? 0 : instance.hashCode());, + result = prime * result + (name == null ? 0 : name.hashCode());, + result = prime * result + (type == null ? 0 : type.hashCode());, +++ b/common/src/main/java/io/netty/monitor/MonitorName.java, + result = prime * result + (group == null ? 0 : group.hashCode());, + result = prime * result + (instance == null ? 0 : instance.hashCode());, + result = prime * result + (name == null ?
[+++ b/src/test/java/org/jboss/netty/channel/socket/NioClientSocketShutdownTimeTest.java, +import org.jboss.netty.util.TestOptions;, + if (!TestOptions.isTimingTestEnabled()) {, +++ b/src/test/java/org/jboss/netty/channel/socket/NioClientSocketShutdownTimeTest.java, +import org.jboss.netty.util.TestOptions;, + if (!TestOptions.isTimingTestEnabled()) {, +++ b/src/test/java/org/jboss/netty/channel/socket/NioServerSocketShutdownTimeTest.java, +import org.jboss.netty.util.TestOptions;, + if (!TestOptions.isTimingTestEnabled()) {, +++ b/src/test/java/org/jboss/netty/channel/socket/NioClientSocketShutdownTimeTest.java, +import org.jboss.netty.util.TestOptions;, + if (!TestOptions.isTimingTestEnabled()) {, +++ b/src/test/java/org/jboss/netty/channel/socket/NioServerSocketShutdownTimeTest.java, +import org.jboss.netty.util.TestOptions;, + if (!TestOptions.isTimingTestEnabled()) {, +++ b/src/test/java/org/jboss/netty/util/TestOptions.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2009, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + private String selectedSubprotocol;]
[+++ b/pom.xml, + <ignore>java.nio.channels.NetworkChannel</ignore>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, + private static final ChannelMetadata METADATA = new ChannelMetadata(ChannelBufType.MESSAGE, false);, +, + public ChannelMetadata metadata() {, + return METADATA;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, + private static final ChannelMetadata METADATA = new ChannelMetadata(ChannelBufType.MESSAGE, false);, +, + public ChannelMetadata metadata() {, + return METADATA;, +++ b/transport/src/main/java/io/netty/channel/Channel.java, + ChannelMetadata metadata();, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibEncoder.java, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, + private static final ChannelMetadata METADATA = new ChannelMetadata(ChannelBufType.MESSAGE, false);, +, + public ChannelMetadata metadata() {, + return METADATA;, +++
[+++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, + * @return {@link CharSequence} the escaped value if necessary, or the value unchanged, + (!isNextCharDoubleQuote || i + 1 == last)) {]
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, + if (logger.isDebugEnabled()) {, + logger.debug("{}: {}", file, somaxconn);, + }, + logger.debug("Failed to get SOMAXCONN from: {}", file, e);, + if (logger.isDebugEnabled()) {, + logger.debug("{}: {} (non-existent)", file, somaxconn);, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, + public HttpPostMultipartRequestDecoder(HttpRequest request) {, + public HttpPostMultipartRequestDecoder(HttpDataFactory factory, HttpRequest request) {, + public HttpPostMultipartRequestDecoder(HttpDataFactory factory, HttpRequest request, Charset charset) {, + private void setMultipart(String contentType) {, + @Override, + @Override, + @Override, + @Override, + public List<InterfaceHttpData> getBodyHttpDatas() {, + @Override, + public List<InterfaceHttpData> getBodyHttpDatas(String name) {, + @Override, + public InterfaceHttpData getBodyHttpData(String name) {, + @Override, + public HttpPostMultipartRequestDecoder offer(HttpContent content) {, + @Override, + public boolean hasNext() {, + @Override, + public InterfaceHttpData next() {, + private void parseBody() {, + private void parseBodyMultipart() {, + private InterfaceHttpData decodeMultipart(MultiPartStatus state) {, + void skipControlCharacters()
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractChannelBufferTest.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractChannelBufferTest.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + * Sub protocol request sent to the server., + expectedSubprotocol = subprotocol;, + * Returns the sub protocol request sent to the server as specified in the constructor, + * Returns the sub protocol response and sent by the server. Only available after end of handshake., +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractChannelBufferTest.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + * Sub protocol request sent to the server., + expectedSubprotocol = subprotocol;, + * Returns the sub protocol request sent to the server as specified in the constructor, + * Returns the sub
[+++ b/codec/src/main/java/io/netty/handler/codec/redis/Command.java, + public static final byte[] ARGS_PREFIX = "*".getBytes();, + public static final byte[] CRLF = "\r\n".getBytes();, + public static final byte[] BYTES_PREFIX = "$".getBytes();, + public static final byte[] EMPTY_BYTES = new byte[0];, + public static final byte[] NEG_ONE_AND_CRLF = convertWithCRLF(-1);, +++ b/codec/src/main/java/io/netty/handler/codec/redis/Command.java, + public static final byte[] ARGS_PREFIX = "*".getBytes();, + public static final byte[] CRLF = "\r\n".getBytes();, + public static final byte[] BYTES_PREFIX = "$".getBytes();, + public static final byte[] EMPTY_BYTES = new byte[0];, + public static final byte[] NEG_ONE_AND_CRLF = convertWithCRLF(-1);, +++ b/codec/src/main/java/io/netty/handler/codec/redis/RedisDecoder.java, + * @return content , + * , + * @param
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java, +import io.netty.util.internal.PlatformDependent;, +import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;, + private static final AtomicIntegerFieldUpdater<DefaultChannelConfig> AUTOREAD_UPDATER;, +, + static {, + AtomicIntegerFieldUpdater<DefaultChannelConfig> autoReadUpdater =, + PlatformDependent.newAtomicIntegerFieldUpdater(DefaultChannelConfig.class, "autoRead");, + if (autoReadUpdater == null) {, + autoReadUpdater = AtomicIntegerFieldUpdater.newUpdater(DefaultChannelConfig.class, "autoRead");, + }, + AUTOREAD_UPDATER = autoReadUpdater;, + }, +, + @SuppressWarnings("FieldMayBeFinal"), + private volatile int autoRead = 1;, + return autoRead == 1;, + boolean oldAutoRead = AUTOREAD_UPDATER.getAndSet(this, autoRead ? 1 : 0) == 1;]
[+++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java, + final boolean keepAlive = HttpUtil.isKeepAlive(request);, + sendListing(ctx, file, uri, keepAlive);, + sendRedirect(ctx, uri + '/', keepAlive);, + sendNotModified(ctx, keepAlive);, +, + if (!keepAlive) {, + response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);, + if (!keepAlive) {, + private static void sendListing(ChannelHandlerContext ctx, File dir, String dirPath, boolean keepAlive) {, + sendAndCleanupConnection(ctx, response, keepAlive);, + private static void sendRedirect(ChannelHandlerContext ctx, String newUri, boolean keepAlive) {, + sendAndCleanupConnection(ctx, response, keepAlive);, + sendAndCleanupConnection(ctx, response, false);, + private static void sendNotModified(ChannelHandlerContext ctx, boolean keepAlive) {, + sendAndCleanupConnection(ctx, response, keepAlive);, + }, +, + /**, + * If Keep-Alive is disabled, attaches "Connection: close" header to
[+++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, + static {, + assert EMPTY_BUFFER instanceof EmptyByteBuf: "EMPTY_BUFFER must be an EmptyByteBuf.";, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, + static {, + assert EMPTY_BUFFER instanceof EmptyByteBuf: "EMPTY_BUFFER must be an EmptyByteBuf.";, + }, +, +++ b/buffer/src/test/java/io/netty/buffer/EmptyByteBufTest.java, +import static org.hamcrest.Matchers.*;, +import static org.junit.Assert.*;, +, +, + @Test, + public void testArray() {, + EmptyByteBuf empty = new EmptyByteBuf(UnpooledByteBufAllocator.DEFAULT);, + assertThat(empty.hasArray(), is(true));, + assertThat(empty.array().length, is(0));, + assertThat(empty.arrayOffset(), is(0));, + }, +, + @Test, + public void testNioBuffer() {, + EmptyByteBuf empty = new EmptyByteBuf(UnpooledByteBufAllocator.DEFAULT);, + assertThat(empty.nioBufferCount(), is(1));, + assertThat(empty.nioBuffer().position(), is(0));, + assertThat(empty.nioBuffer().limit(), is(0));, + assertThat(empty.nioBuffer(), is(sameInstance(empty.nioBuffer())));, + assertThat(empty.nioBuffer(), is(sameInstance(empty.internalNioBuffer(0,
[+++ b/src/docbook/master.xml, + <xi:include href="module/state-mgmt.xml", + xmlns:xi="http://www.w3.org/2001/XInclude" />, + , +++ b/src/docbook/master.xml, + <xi:include href="module/state-mgmt.xml", + xmlns:xi="http://www.w3.org/2001/XInclude" />, + , +++ b/src/docbook/module/architecture.xml, + <title>Architecture</title>, +++ b/src/docbook/master.xml, + <xi:include href="module/state-mgmt.xml", + xmlns:xi="http://www.w3.org/2001/XInclude" />, + , +++ b/src/docbook/module/architecture.xml, + <title>Architecture</title>, +++ b/src/docbook/module/preface.xml, + <para>, + The most fundamental question, <quote>What is Netty and why should I, + care?</quote>, will be answered here., + </para>, + , + <section>, + <title>The Problem</title>, + <para>, + We are using a general purpose application or library to communicate, + with each other nowadays. For example, we often use an open source, + HTTP client
[+++ b/all/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR7-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, + private static final InternalLogger logger =, + InternalLoggerFactory.getInstance(DiscardClient.class);, +, + logger.error(, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, + private static final InternalLogger logger =, + InternalLoggerFactory.getInstance(DiscardClient.class);, +, + logger.error(, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, + private static final InternalLogger logger =, + InternalLoggerFactory.getInstance(EchoClient.class);, +, + logger.error(, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, + private static final InternalLogger logger =, + InternalLoggerFactory.getInstance(DiscardClient.class);, +, + logger.error(, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, + private static final InternalLogger logger =, + InternalLoggerFactory.getInstance(EchoClient.class);, +, + logger.error(, +++ b/example/src/main/java/io/netty/example/factorial/FactorialClient.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, + private static
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + break;]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, + @Test, + public void testSliceRelease() {, + ByteBuf buf = newBuffer(8);, + assertEquals(1, buf.refCnt());, + assertTrue(buf.slice().release());, + assertEquals(0, buf.refCnt());, + }, +, + @Test, + public void testDuplicateRelease() {, + ByteBuf buf = newBuffer(8);, + assertEquals(1, buf.refCnt());, + assertTrue(buf.duplicate().release());, + assertEquals(0, buf.refCnt());, + }, +]
[+++ b/all/pom.xml, + <version>4.0.0.CR7</version>, +++ b/all/pom.xml, + <version>4.0.0.CR7</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR7</version>, +++ b/all/pom.xml, + <version>4.0.0.CR7</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR7</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR7</version>, +++ b/all/pom.xml, + <version>4.0.0.CR7</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR7</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR7</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR7</version>, +++ b/all/pom.xml, + <version>4.0.0.CR7</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR7</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR7</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR7</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR7</version>, +++ b/all/pom.xml, + <version>4.0.0.CR7</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR7</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR7</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR7</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR7</version>, +++ b/common/pom.xml, + <version>4.0.0.CR7</version>, +++ b/all/pom.xml, + <version>4.0.0.CR7</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR7</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR7</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java, + FullHttpResponse response = (FullHttpResponse) msg;, + try {, + handshaker.finishHandshake(ctx.channel(), response);, + } finally {, + response.release();, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + p.addAfter(, + p.context(HttpRequestEncoder.class).name(),, + "ws-encoder", new WebSocket00FrameEncoder());, + ChannelPipeline p = channel.pipeline();, + p.remove(HttpRequestEncoder.class);, + p.get(HttpResponseDecoder.class).replace(, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + p.addAfter(, + p.context(HttpRequestEncoder.class).name(),, + "ws-encoder", new WebSocket00FrameEncoder());, + ChannelPipeline p = channel.pipeline();, + p.remove(HttpRequestEncoder.class);, + p.get(HttpResponseDecoder.class).replace(, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + p.addAfter(, + p.context(HttpRequestEncoder.class).name(),, + "ws-encoder", new WebSocket08FrameEncoder(true));, + ChannelPipeline p = channel.pipeline();, + p.remove(HttpRequestEncoder.class);, + p.get(HttpResponseDecoder.class).replace(, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + p.addAfter(, + p.context(HttpRequestEncoder.class).name(),, + "ws-encoder", new WebSocket00FrameEncoder());, + ChannelPipeline p = channel.pipeline();, + p.remove(HttpRequestEncoder.class);, + p.get(HttpResponseDecoder.class).replace(, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + p.addAfter(, + p.context(HttpRequestEncoder.class).name(),, + "ws-encoder", new WebSocket08FrameEncoder(true));, + ChannelPipeline p = channel.pipeline();, + p.remove(HttpRequestEncoder.class);, + p.get(HttpResponseDecoder.class).replace(, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java, + p.addAfter(,
[+++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ /dev/null, +++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + throw new IndexOutOfBoundsException("Invalid readerIndex: " , + + readerIndex + " - Maximum is " + writerIndex);, + throw new IndexOutOfBoundsException("Invalid writerIndex: " , + + writerIndex + " - Maximum is " + readerIndex + " or " + capacity());, + throw new IndexOutOfBoundsException("Invalid indexes: readerIndex is ", + + readerIndex + ", writerIndex is ", + + writerIndex + ", capacity is " + capacity());, + return readableBytes() > 0;, + throw new IndexOutOfBoundsException("Writable bytes exceeded: Got "
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + private static final Pattern PATTERN = Pattern.compile(, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + private static final Pattern PATTERN = Pattern.compile(, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, + addCookie(new DefaultCookie(name, value));, + if (cookies.size() > 1) {, + throw new IllegalStateException(, + "encode() can encode only one cookie on server mode: " + cookies.size() + " cookies added");, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + private static final Pattern PATTERN = Pattern.compile(, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, + addCookie(new DefaultCookie(name, value));, + if (cookies.size() > 1) {, + throw new IllegalStateException(, + "encode() can encode only one cookie on server mode: " + cookies.size() + " cookies added");,
[+++ b/common/src/main/java/io/netty/util/internal/AppendableCharSequence.java, + if (start == end) {, + // If start and end index is the same we need to return an empty sequence to conform to the interface., + // As our expanding logic depends on the fact that we have a char[] with length > 0 we need to construct, + // an instance for which this is true., + return new AppendableCharSequence(Math.min(16, chars.length));, + }, +++ b/common/src/main/java/io/netty/util/internal/AppendableCharSequence.java, + if (start == end) {, + // If start and end index is the same we need to return an empty sequence to conform to the interface.,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshaker.java, + return new PerMessageDeflateEncoder(compressionLevel, clientWindowSize, clientNoContext);, + return new PerMessageDeflateDecoder(serverNoContext);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshaker.java, + return new PerMessageDeflateEncoder(compressionLevel, clientWindowSize, clientNoContext);, + return new PerMessageDeflateDecoder(serverNoContext);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateServerExtensionHandshaker.java, + return new PerMessageDeflateEncoder(compressionLevel, serverWindowSize, serverNoContext);, + return new PerMessageDeflateDecoder(clientNoContext);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshaker.java, + return new PerMessageDeflateEncoder(compressionLevel, clientWindowSize, clientNoContext);, + return new PerMessageDeflateDecoder(serverNoContext);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateServerExtensionHandshaker.java, + return new PerMessageDeflateEncoder(compressionLevel, serverWindowSize, serverNoContext);, + return new PerMessageDeflateDecoder(clientNoContext);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerFrameDeflateDecoderTest.java, +import static io.netty.handler.codec.http.websocketx.extensions.WebSocketExtension.RSV1;, +import static io.netty.handler.codec.http.websocketx.extensions.WebSocketExtension.RSV3;, +import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;, + RSV1 | RSV3,, + assertEquals(RSV3, uncompressedFrame.rsv());, + RSV3, Unpooled.wrappedBuffer(payload));, + assertEquals(RSV3, newFrame.rsv());, + new BinaryWebSocketFrame(true, RSV1 | RSV3, compressedPayload);, + assertEquals(RSV3, uncompressedFrame.rsv());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/compression/PerMessageDeflateClientExtensionHandshaker.java, + return new PerMessageDeflateEncoder(compressionLevel,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, + String contentType;, + if (contentTypeAttribute != null) {, + contentType = contentTypeAttribute.getValue();, + } else {, + contentType = HttpPostBodyUtil.DEFAULT_BINARY_CONTENT_TYPE;, + }, + contentType, mechanism.value(), localCharset,, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, + String contentType;, + if (contentTypeAttribute != null) {, + contentType = contentTypeAttribute.getValue();, + } else {, + contentType = HttpPostBodyUtil.DEFAULT_BINARY_CONTENT_TYPE;, + }, + contentType, mechanism.value(), localCharset,, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java, +, + @Test, + public void testMultipartRequestWithoutContentTypeBody() {, + final String boundary = "dLV9Wyq26L_-JQxk6ferf-RT153LhOO";, +, + final DefaultFullHttpRequest req = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST,, + "http://localhost");, +, + req.setDecoderResult(DecoderResult.SUCCESS);, + req.headers().add(HttpHeaderNames.CONTENT_TYPE, "multipart/form-data; boundary=" + boundary);, + req.headers().add(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);, +, +
[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/NOTICE.txt, +This product optionally depends on 'JZlib', a re-implementation of zlib in pure, +Java, which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.jzlib.txt (BSD Style License), + * HOMEPAGE:, + * http://www.jcraft.com/jzlib/, +, +++ b/NOTICE.txt, +This product optionally depends on 'JZlib', a re-implementation of zlib in pure, +Java, which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.jzlib.txt (BSD Style License), + * HOMEPAGE:, + * http://www.jcraft.com/jzlib/, +, +++ b/license/LICENSE.jzlib.txt, +Copyright (c) 2000,2001,2002,2003,2004 ymnk, JCraft,Inc. All rights reserved., +, +Redistribution and use in source and binary forms, with or without, +modification, are permitted
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpExpectationFailedEvent.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/transport-sctp/src/main/java/com/sun/nio/sctp/SctpChannel.java, + , + public abstract Set<SctpSocketOption<?>> supportedOptions();]
[+++ b/pom.xml, + <Eclipse-BuddyPolicy>registered</Eclipse-BuddyPolicy>, + <Bundle-BuddyPolicy>registered</Bundle-BuddyPolicy>]
[+++ b/pom.xml]
[+++ b/transport/src/main/java/io/netty/channel/DelegatingChannelPromiseNotifier.java, + this(delegate, !(delegate instanceof VoidChannelPromise));]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + int readerIndex;, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + int readerIndex;, +++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, + getBytes(index, dst, dstIndex, length, false);, + return this;, + }, +, + private void getBytes(int index, byte[] dst, int dstIndex, int length, boolean internal) {, + ByteBuffer tmpBuf;, + if (internal) {, + tmpBuf = internalNioBuffer();, + } else {, + tmpBuf = memory.duplicate();, + }, + }, +, + @Override, + public ByteBuf readBytes(byte[] dst, int dstIndex, int length) {, + checkReadableBytes(length);, + getBytes(readerIndex, dst, dstIndex, length, true);, + readerIndex += length;, + getBytes(index, dst, false);, + return this;, + }, +, + private void
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + sb.subStringUnsafe(aStart, aEnd),, + sb.subStringUnsafe(bStart, bEnd),, + cStart < cEnd? sb.subStringUnsafe(cStart, cEnd) : "" };, + name = sb.subStringUnsafe(nameStart, nameEnd);, + value = sb.subStringUnsafe(valueStart, valueEnd);, + private static int findNonWhitespace(AppendableCharSequence sb, int offset) {, + for (int result = offset; result < sb.length(); ++result) {, + if (!Character.isWhitespace(sb.charAtUnsafe(result))) {, + }, + return sb.length();, + }, + private static int findWhitespace(AppendableCharSequence sb, int offset) {, + for (int result = offset; result < sb.length(); ++result) {, + if (Character.isWhitespace(sb.charAtUnsafe(result))) {, + }, + return sb.length();, + }, + private static int findEndOfString(AppendableCharSequence sb) {, + for (int
[+++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, + // Should not reach here, but just in case., + if (o == null) {, + return "null_object";, + } else {, + }, + if (clazz == null) {, + return "null_class";, + }, +]
[+++ b/buffer/pom.xml, + <dependency>, + <groupId>org.mockito</groupId>, + <artifactId>mockito-core</artifactId>, + </dependency>, +++ b/buffer/pom.xml, + <dependency>, + <groupId>org.mockito</groupId>, + <artifactId>mockito-core</artifactId>, + </dependency>, +++ b/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java, +import org.mockito.Mock;, +import org.mockito.Mockito;, +import static org.mockito.Mockito.*;, + ByteBuf buf = mock(ByteBuf.class);, + when(buf.order()).thenReturn(BIG_ENDIAN);, + when(buf.maxCapacity()).thenReturn(65536);, + when(buf.readerIndex()).thenReturn(0);, + when(buf.writerIndex()).thenReturn(0);, + when(buf.capacity()).thenReturn(0);, + when(buf.getBytes(1, (GatheringByteChannel) null, 2)).thenReturn(3);, + when(buf.getBytes(4, (OutputStream) null, 5)).thenReturn(buf);, + when(buf.getBytes(6, (byte[]) null, 7, 8)).thenReturn(buf);, + when(buf.getBytes(9, (ByteBuf) null, 10, 11)).thenReturn(buf);, + when(buf.getBytes(12, (ByteBuffer) null)).thenReturn(buf);, + when(buf.getByte(13)).thenReturn(Byte.valueOf((byte) 14));, + when(buf.getShort(15)).thenReturn(Short.valueOf((short) 16));, + when(buf.getUnsignedMedium(17)).thenReturn(18);, + when(buf.getInt(19)).thenReturn(20);, + when(buf.getLong(21)).thenReturn(22L);, + when(buf.nioBuffer(23, 24)).thenReturn(bb);, + when(buf.capacity()).thenReturn(27);, +++ b/buffer/pom.xml, + <dependency>, + <groupId>org.mockito</groupId>, + <artifactId>mockito-core</artifactId>, + </dependency>, +++ b/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java,
[+++ b/src/main/java/org/jboss/netty/buffer/ByteBufferBackedChannelBuffer.java, + if (index >= 0 && length == 0) {, + return ChannelBuffers.EMPTY_BUFFER;, + }, +++ b/src/main/java/org/jboss/netty/buffer/ByteBufferBackedChannelBuffer.java, + if (index >= 0 && length == 0) {, + return ChannelBuffers.EMPTY_BUFFER;, + }, +++ b/src/main/java/org/jboss/netty/buffer/ChannelBuffers.java, + if (buffer.order() == BIG_ENDIAN) {, + } else {, + for (int i = intCount; i > 0; i --) {, + hashCode = 31 * hashCode + swapInt(buffer.getInt(arrayIndex));, + arrayIndex += 4;, + }, + }, +, +, +++ b/src/main/java/org/jboss/netty/buffer/ByteBufferBackedChannelBuffer.java, + if (index >= 0 && length == 0) {, + return ChannelBuffers.EMPTY_BUFFER;, + }, +++ b/src/main/java/org/jboss/netty/buffer/ChannelBuffers.java, + if (buffer.order() ==
[+++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, + private static final char PACKAGE_SEPARATOR_CHAR = '.';, + String className = ObjectUtil.checkNotNull(clazz, "clazz").getName();, + final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);, + if (lastDotIdx > -1) {, + return className.substring(lastDotIdx + 1);, + return className;, +++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, + private static final char PACKAGE_SEPARATOR_CHAR = '.';, + String className = ObjectUtil.checkNotNull(clazz, "clazz").getName();, + final int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);, + if (lastDotIdx > -1) {, + return className.substring(lastDotIdx + 1);, + return className;, +++ b/common/src/test/java/io/netty/util/internal/StringUtilTest.java, + @Test, + public void testSimpleClassName() throws Exception {, + testSimpleClassName(String.class);, + }, +, + @Test, + public void testSimpleInnerClassName() throws Exception {, + testSimpleClassName(TestClass.class);,
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/HashCollisionTest.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the, + * "License"); you may not use this file except in compliance with the License. You may obtain a, + * copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express, + *
[+++ b/example/src/main/java/io/netty/example/http2/helloworld/server/HelloWorldHttp1Handler.java, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.ByteBufUtil;, +import io.netty.channel.ChannelFutureListener;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.SimpleChannelInboundHandler;, +import io.netty.handler.codec.http.DefaultFullHttpResponse;, +import io.netty.handler.codec.http.FullHttpRequest;, +import io.netty.handler.codec.http.FullHttpResponse;, +import io.netty.handler.codec.http.HttpHeaderUtil;, +import io.netty.handler.codec.http.HttpHeaderValues;, +, +public class HelloWorldHttp1Handler extends SimpleChannelInboundHandler<FullHttpRequest> {, + public void channelRead0(ChannelHandlerContext ctx, FullHttpRequest req) throws Exception {, +++ b/example/src/main/java/io/netty/example/http2/helloworld/server/HelloWorldHttp1Handler.java, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.ByteBufUtil;, +import io.netty.channel.ChannelFutureListener;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.SimpleChannelInboundHandler;, +import io.netty.handler.codec.http.DefaultFullHttpResponse;, +import io.netty.handler.codec.http.FullHttpRequest;, +import io.netty.handler.codec.http.FullHttpResponse;, +import io.netty.handler.codec.http.HttpHeaderUtil;, +import io.netty.handler.codec.http.HttpHeaderValues;, +, +public class HelloWorldHttp1Handler extends SimpleChannelInboundHandler<FullHttpRequest> {, + public void channelRead0(ChannelHandlerContext ctx, FullHttpRequest req) throws Exception {, +++ b/example/src/main/java/io/netty/example/http2/helloworld/server/Http2ServerInitializer.java, +import io.netty.handler.codec.http.HttpObjectAggregator;, + private final int maxHttpContentLength;, + this(sslCtx, 16 *
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + directMemoryCacheAlignment = cacheAlignment;, + directMemoryCacheAlignmentMask = cacheAlignment - 1;, + q100 = new PoolChunkList<T>(this, null, 100, Integer.MAX_VALUE, chunkSize);, + q075 = new PoolChunkList<T>(this, q100, 75, 100, chunkSize);, + q050 = new PoolChunkList<T>(this, q075, 50, 100, chunkSize);, + q025 = new PoolChunkList<T>(this, q050, 25, 75, chunkSize);, + q000 = new PoolChunkList<T>(this, q025, 1, 50, chunkSize);, + qInit = new PoolChunkList<T>(this, q000, Integer.MIN_VALUE, 25, chunkSize);, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + directMemoryCacheAlignment = cacheAlignment;, + directMemoryCacheAlignmentMask = cacheAlignment - 1;, + q100 = new PoolChunkList<T>(this, null, 100, Integer.MAX_VALUE, chunkSize);, + q075 = new PoolChunkList<T>(this, q100, 75, 100, chunkSize);, + q050 =
[+++ b/handler/src/test/java/io/netty/handler/ssl/ParameterizedSslHandlerTest.java, + promise.trySuccess(null);]
[+++ b/microbench/src/main/java/io/netty/microbench/buffer/ByteBufBenchmark.java, +/*, +* Copyright 2015 The Netty Project, +*, +* The Netty Project licenses this file to you under the Apache License,, +* version 2.0 (the "License"); you may not use this file except in compliance, +* with the License. You may obtain a copy of the License at:, +*, +* http://www.apache.org/licenses/LICENSE-2.0, +*, +* Unless required by applicable law or agreed to in writing, software, +* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, +* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, +* License for the specific language governing
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoder.java, + final String[] labels = name.split("\\.");, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoder.java, + final String[] labels = name.split("\\.");, +++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java, + String[] parts = header.split(" ");, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoder.java, + final String[] labels = name.split("\\.");, +++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java, + String[] parts = header.split(" ");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + String[] portList = value.split(",");, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoder.java, + final String[] labels = name.split("\\.");, +++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java, + String[] parts = header.split(" ");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + String[] portList = value.split(",");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, + for (String encoding : acceptEncoding.split(",")) {, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordEncoder.java, + final String[] labels = name.split("\\.");, +++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java, + String[] parts = header.split(" ");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + String[]
[+++ b/codec-stomp/pom.xml, + <version>5.0.0.Alpha2-SNAPSHOT</version>, +++ b/codec-stomp/pom.xml, + <version>5.0.0.Alpha2-SNAPSHOT</version>, +++ /dev/null, +++ b/codec-stomp/pom.xml, + <version>5.0.0.Alpha2-SNAPSHOT</version>, +++ /dev/null, +++ /dev/null, +++ b/codec-stomp/pom.xml, + <version>5.0.0.Alpha2-SNAPSHOT</version>, +++ /dev/null, +++ /dev/null, +++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultLastStompContentSubframe.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequest.java, + * Gets the {@link HttpMethod} of this {@link HttpRequest}., + *, + * @return The {@link HttpMethod} of this {@link HttpRequest}, + * Sets the {@link HttpMethod} of this {@link HttpRequest}., + *, + * @param The {@link HttpMethod} to set, + * Gets the requested URI (or alternatively, path), + *, + * @return The URI being requested, + * Sets the URI (or alternatively, path) being requested., + *, + * @param uri The URI being requested]
[+++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java, + if (ctx.getPipeline().isAttached()) {, + // channelOpen event has been fired already, which means, + // this.channelOpen() will not be invoked., + // We have to initialize here instead., + } else {, + // channelOpen event has not been fired yet., + // this.channelOpen() will be invoked and initialization will occur there., + }, + public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e), + throws Exception {, + // This method will be invoked only if this handler was added, + // before channelOpen event is fired. If a user adds this handler, + // after the channelOpen
[+++ b/pom.xml, + <groupId>com.google.inject</groupId>, + <version>2.0</version>, + <version>2.5.6.SEC01</version>, + <version>1.5.10</version>, + <version>2.1.1.GA</version>, + <version>2.5.2</version>, + <version>1.5.10</version>, + <version>2.1</version>, + <version>2.5</version>, + <version>2.2-beta-5</version>, + <version>2.5</version>]
[+++ b/transport/src/main/java/io/netty/channel/CompleteChannelFuture.java, +import java.util.concurrent.TimeUnit;, +, + public void addListener(final ChannelFutureListener listener) {, + if (channel().eventLoop().inEventLoop()) {, + notifyListener(listener);, + } else {, + channel().eventLoop().execute(new Runnable() {, + @Override, + public void run() {, + notifyListener(listener);, + }, + });, + }, + }, +, + private void notifyListener(ChannelFutureListener listener) {, +++ b/transport/src/main/java/io/netty/channel/CompleteChannelFuture.java, +import java.util.concurrent.TimeUnit;, +, + public void addListener(final ChannelFutureListener listener) {, + if (channel().eventLoop().inEventLoop()) {, + notifyListener(listener);, + } else {, + channel().eventLoop().execute(new Runnable() {, + @Override, + public void run() {, + notifyListener(listener);, + }, + });, + }, + }, +, + private void notifyListener(ChannelFutureListener listener)
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + public boolean isPooled() {, + return false;, + }, +, + @Override, + return ByteBufs.EMPTY_BUFFER;, + return ByteBufs.decodeString(nioBuffer, charset);, + return ByteBufs.indexOf(this, fromIndex, toIndex, value);, + return ByteBufs.indexOf(this, fromIndex, toIndex, indexFinder);, + return ByteBufs.hashCode(this);, + return ByteBufs.equals(this, (ByteBuf) o);, + return ByteBufs.compare(this, that);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + public boolean isPooled() {, + return false;, + }, +, + @Override, + return ByteBufs.EMPTY_BUFFER;, + return ByteBufs.decodeString(nioBuffer, charset);, + return ByteBufs.indexOf(this, fromIndex, toIndex, value);, + return ByteBufs.indexOf(this, fromIndex, toIndex, indexFinder);, + return ByteBufs.hashCode(this);, + return ByteBufs.equals(this, (ByteBuf) o);, + return ByteBufs.compare(this, that);, +++ b/buffer/src/main/java/io/netty/buffer/BigEndianHeapByteBuf.java, + * A big-endian Java
[+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompHeaders.java, +import java.util.LinkedHashMap;, + private final Map<String, List<String>> headers = new LinkedHashMap<String, List<String>>();, +++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompHeaders.java, +import java.util.LinkedHashMap;, + private final Map<String, List<String>> headers = new LinkedHashMap<String, List<String>>();, +++ b/codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompSubframeEncoderTest.java, + headers.set(StompHeaders.ACCEPT_VERSION, "1.1,1.2");]
[+++ b/pom.xml, + <tcnative.version>2.0.10.Final</tcnative.version>]
[+++ b/src/docbook/module/start.xml, + this chapter are just two; the latest version of Netty and JDK 1.5 or, + above. The latest version of Netty is available in, + <ulink url="&Downloads;">the project download page</ulink>. To get the, + right version of JDK, please refer to your preferred JDK vendor's web, + site. ]
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioChannel.java, + * The {@link SelectorEventLoop}., + private final SelectorEventLoop worker;, + protected AbstractNioChannel(Integer id, Channel parent, ChannelFactory factory, ChannelPipeline pipeline, ChannelSink sink, SelectorEventLoop worker, JdkChannel ch) {, + ChannelPipeline pipeline, ChannelSink sink, SelectorEventLoop worker, JdkChannel ch) {, + * Return the {@link SelectorEventLoop} that handle the IO of the {@link AbstractNioChannel}, + public SelectorEventLoop getWorker() {, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioChannel.java, + * The {@link SelectorEventLoop}., + private final SelectorEventLoop worker;, + protected AbstractNioChannel(Integer id, Channel parent, ChannelFactory factory, ChannelPipeline pipeline, ChannelSink sink, SelectorEventLoop worker, JdkChannel ch) {, + ChannelPipeline pipeline, ChannelSink sink, SelectorEventLoop worker, JdkChannel ch) {, + *
[+++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, + private static void doBind0(, + ChannelFuture initFuture, Channel channel, SocketAddress localAddress, ChannelPromise promise) {, +]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, + char id = (char) payload.readUnsignedShort();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, + char id = (char) payload.readUnsignedShort();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, +, +import io.netty.util.collection.CharObjectMap;, + ByteBuf buf = ctx.alloc().buffer(DATA_FRAME_HEADER_LENGTH);, + for (CharObjectMap.Entry<Long> entry : settings.entries()) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, + char id = (char) payload.readUnsignedShort();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, +, +import io.netty.util.collection.CharObjectMap;, + ByteBuf buf = ctx.alloc().buffer(DATA_FRAME_HEADER_LENGTH);, + for (CharObjectMap.Entry<Long> entry : settings.entries()) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ClientUpgradeCodec.java, +, +import io.netty.util.collection.CharObjectHashMap;, + for (CharObjectHashMap.Entry<Long> entry : settings.entries()) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, + char id = (char) payload.readUnsignedShort();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, +, +import io.netty.util.collection.CharObjectMap;, + ByteBuf buf = ctx.alloc().buffer(DATA_FRAME_HEADER_LENGTH);, + for (CharObjectMap.Entry<Long> entry : settings.entries()) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ClientUpgradeCodec.java, +, +import
[+++ b/common/src/main/java/io/netty/util/concurrent/ImmediateEventExecutor.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/pom.xml, + <id>noUnsafe</id>, + <properties>, + <argLine.noUnsafe>-Dio.netty.noUnsafe</argLine.noUnsafe>, + </properties>, + </profile>, + <profile>, + <argLine.noUnsafe>-D_</argLine.noUnsafe> <!-- Overridden when 'noUnsafe' profile is active -->, + <argLine>${argLine.common} ${argLine.alpnAgent} ${argLine.leak} ${argLine.coverage} ${argLine.noUnsafe}</argLine>]
[+++ b/pom.xml, + <jetty.alpn.version>8.1.6.v20151105</jetty.alpn.version>, + <id>alpn-8u65</id>, + <activation>, + <property>, + <name>java.version</name>, + <value>1.8.0_65</value>, + </property>, + </activation>, + <properties>, + <jetty.alpn.version>8.1.6.v20151105</jetty.alpn.version>, + </properties>, + </profile>, + <profile>, + <scope>provided</scope> <!-- Provided by alpn-boot -->]
[+++ b/common/src/main/java/io/netty/util/internal/InternalThreadLocalMap.java, + @SuppressWarnings("unchecked"), + arrayList = new ArrayList<Object>(minCapacity);, + return (ArrayList<E>) arrayList;, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, + public boolean acceptOutboundMessage(Object msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, + public boolean acceptOutboundMessage(Object msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java, + public boolean acceptOutboundMessage(Object msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, + public boolean acceptOutboundMessage(Object msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java, + public boolean acceptOutboundMessage(Object msg) throws Exception {, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, + public void flush(ChannelHandlerContext ctx, I msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, + public boolean acceptOutboundMessage(Object msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java, + public boolean acceptOutboundMessage(Object msg) throws Exception {, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, + public void flush(ChannelHandlerContext ctx, I msg) throws Exception {, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, + public final
[+++ b/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java, + protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {, + /**, + * Create a frame out of the {@link ByteBuf} and return it., + *, + * @param ctx the {@link ChannelHandlerContext} which this {@link ByteToMessageDecoder} belongs to, + * @param buffer the {@link ByteBuf} from which to read data, + * @return frame the {@link ByteBuf} which represent the frame or {@code null} if no frame could, + * be created., + */, +++ b/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java, + protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {, + /**, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsHandlerTest.java, + final FullHttpRequest request = optionsRequest("http://localhost:8888", "content-type, xheader1");, + channel.writeInbound(optionsRequest(origin, requestHeaders));, + private static FullHttpRequest optionsRequest(final String origin, final String requestHeaders) {]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + checkReadableBytes(length);, + checkReadableBytes(length);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + checkReadableBytes(length);, + checkReadableBytes(length);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, + @Test(expected = IndexOutOfBoundsException.class), + public void testReadSliceOutOfBounds() {, + testReadSliceOutOfBounds(false);, + }, +, + @Test(expected = IndexOutOfBoundsException.class), + public void testReadRetainedSliceOutOfBounds() {, + testReadSliceOutOfBounds(true);, + }, +, + private void testReadSliceOutOfBounds(boolean retainedSlice) {, + ByteBuf buf = newBuffer(100);, + try {, + buf.writeZero(50);, + if (retainedSlice) {, + buf.readRetainedSlice(51);, + } else {, + buf.readSlice(51);, + }, + fail();, + } finally {, + buf.release();, + }, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + checkReadableBytes(length);, + checkReadableBytes(length);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, + @Test(expected = IndexOutOfBoundsException.class), + public
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + checkUnfreed();, + checkUnfreed();, + protected final void checkIndex(int index) {, + checkUnfreed();, + if (index < 0 || index >= capacity()) {, + throw new IndexOutOfBoundsException(String.format(, + "index: %d (expected: range(0, %d))", index, capacity()));, + }, + }, +, + protected final void checkIndex(int index, int fieldLength) {, + checkUnfreed();, + if (index < 0 || index > capacity() - fieldLength) {, + throw new IndexOutOfBoundsException(String.format(, + "index: %d, length: %d (expected: range(0, %d))", index, fieldLength, capacity()));, + }, + }, +, + protected final void checkReadableBytes(int minimumReadableBytes) {, + checkUnfreed();, +, + protected final void
[+++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, + if (secondArg == null) {, + return format(ctx, eventName, firstArg);, + }, +]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java, + // TODO: Optimize me.]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpStatusClass.java, + /**, + * Returns the class of the specified HTTP status code., + * @param code Just the numeric portion of the http status code., + */, + public static HttpStatusClass valueOf(CharSequence code) {, + if (code != null && code.length() == 3) {, + char c0 = code.charAt(0);, + return isDigit(c0) && isDigit(code.charAt(1)) && isDigit(code.charAt(2)) ? valueOf(digit(c0) * 100), + : UNKNOWN;, + }, + return UNKNOWN;, + }, +, + private static int digit(char c) {, + return c - '0';, + }, +, + private static boolean isDigit(char c) {, + return c
[+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java, + private final boolean sessionPresent;, +, + public MqttConnAckVariableHeader(MqttConnectReturnCode connectReturnCode, boolean sessionPresent) {, + this.sessionPresent = sessionPresent;, + public boolean isSessionPresent() { return sessionPresent; }, +, + .append(", sessionPresent=").append(sessionPresent), +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java, + private final boolean sessionPresent;, +, + public MqttConnAckVariableHeader(MqttConnectReturnCode connectReturnCode, boolean sessionPresent) {, + this.sessionPresent = sessionPresent;, + public boolean isSessionPresent() { return sessionPresent; }, +, + .append(", sessionPresent=").append(sessionPresent), +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java, + final boolean sessionPresent = (buffer.readUnsignedByte() & 0x01) == 0x01;, + new MqttConnAckVariableHeader(MqttConnectReturnCode.valueOf(returnCode), sessionPresent);, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java, + private final boolean sessionPresent;, +, + public MqttConnAckVariableHeader(MqttConnectReturnCode connectReturnCode, boolean sessionPresent) {, + this.sessionPresent = sessionPresent;, + public
[+++ b/pom.xml, + <version>1.18</version>]
[+++ b/pom.xml, + -d ${project.build.directory}/apidocs, + <groupId>org.jboss.maven.plugins</groupId>, + <artifactId>maven-jdocbook-plugin</artifactId>, + <version>2.0.0</version>, + <executions>, + <execution>, + <id>generate-docbook</id>, + <phase>package</phase>, + <goals>, + <goal>resources</goal>, + <goal>generate</goal>, + </goals>, + </execution>, + </executions>, + <dependencies>, + <dependency>, + <groupId>org.jboss</groupId>, + <artifactId>jbossorg-docbook-xslt</artifactId>, + <version>1.0.0</version>, + </dependency>, + <dependency>, + <groupId>org.jboss</groupId>, + <artifactId>jbossorg-jdocbook-style</artifactId>, + <version>1.0.0</version>, + <type>jdocbook-style</type>, + </dependency>, + </dependencies>, + <configuration>, + <sourceDocumentName>master.xml</sourceDocumentName>, + <sourceDirectory>${basedir}/src/docbook</sourceDirectory>, + <imageResource>, + <directory>${basedir}/src/docbook</directory>, + <includes>, + <include>image/**/*</include>, + </includes>, + </imageResource>, + <formats>, + <format>, + <formatName>pdf</formatName>, + <stylesheetResource>classpath:/xslt/org/jboss/main-pdf.xsl</stylesheetResource>, + <finalName>${project.artifactId}.pdf</finalName>, + </format>, + <format>, + <formatName>html</formatName>, + <stylesheetResource>classpath:/xslt/org/jboss/main-html.xsl</stylesheetResource>, + <finalName>index.html</finalName>, + </format>, + <format>,
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2SecurityUtil.java, + *, + * According to the <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html">, + * JSSE documentation</a> "the names mentioned in the TLS RFCs prefixed with TLS_ are functionally equivalent, + * to the JSSE cipher suites prefixed with SSL_"., + * Both variants are used to support JVMs supporting the one or the other., + /* openssl = ECDHE-ECDSA-AES256-GCM-SHA384 */, + "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",, + "SSL_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",, + /* openssl = ECDHE-ECDSA-AES128-GCM-SHA256 */, + "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",, + "SSL_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",, + /* openssl = ECDHE-RSA-AES256-GCM-SHA384 */, + "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",, + "SSL_ECDHE_RSA_WITH_AES_256_GCM_SHA384",, +, + /* openssl = ECDHE-RSA-AES128-GCM-SHA256 */, + "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",, + "SSL_ECDHE_RSA_WITH_AES_128_GCM_SHA256",, +, + /* openssl =
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java, + final int inputLength = in.readableBytes();, + if (inputLength == 0) {, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java, + final int inputLength = in.readableBytes();, + if (inputLength == 0) {, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java, + int readableBytes = in.readableBytes();, + if (readableBytes == 0) {, + if (readableBytes < 2) {, + boolean nowrap = !looksLikeZlib(in.getShort(in.readerIndex()));, + // Some bytes may have been consumed, and so we must re-set the number of readable bytes., + readableBytes = in.readableBytes();, + inflater.setInput(in.array(), in.arrayOffset() + in.readerIndex(), readableBytes);, + byte[] array = new byte[readableBytes];]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + // The behavior here should mirror that in FlowControlledHeaders, +, + promise = promise.unvoid();, + if (endOfStream) {, + // Must handle calling onError before calling closeStreamLocal, otherwise the error handler will, + // incorrectly think the stream no longer exists and so may not send RST_STREAM or perform similar, + // appropriate action., + lifecycleManager.closeStreamLocal(stream, future);, + }, +, + promise = promise.unvoid();, + super(stream, padding, endOfStream, promise.unvoid());, + // The code is currently requiring adding this listener before writing, in order to call onError() before, + // closeStreamLocal()., +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + // The behavior
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + ensureAccessible();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + ensureAccessible();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractUnsafeSwappedByteBuf.java, + wrapped.checkIndex(index, 4);, + wrapped.checkIndex(index, 2);, + wrapped.checkIndex(index, 2);, + wrapped.checkIndex(index, 4);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + ensureAccessible();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractUnsafeSwappedByteBuf.java, + wrapped.checkIndex(index, 4);, + wrapped.checkIndex(index, 2);, + wrapped.checkIndex(index, 2);, + wrapped.checkIndex(index, 4);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledHeapByteBuf.java, +import io.netty.util.internal.EmptyArrays;, + array = EmptyArrays.EMPTY_BYTES;]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java, +import io.netty.channel.SimpleChannelInboundHandler;, + private static class CustomTextFrameHandler extends SimpleChannelInboundHandler<TextWebSocketFrame> {, + public void messageReceived(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java, +import io.netty.channel.SimpleChannelInboundHandler;, + private static class CustomTextFrameHandler extends SimpleChannelInboundHandler<TextWebSocketFrame> {, + public void messageReceived(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception {, +++ b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java, +import io.netty.channel.SimpleChannelInboundHandler;, + private static final class DiscardServerHandler extends SimpleChannelInboundHandler<ByteBuf> {, + public void messageReceived(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java, +import io.netty.channel.SimpleChannelInboundHandler;, + private static class CustomTextFrameHandler extends SimpleChannelInboundHandler<TextWebSocketFrame> {, + public
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufProcessor.java, + * @deprecated Use {@link ByteProcessor#FIND_NUL}., +++ b/buffer/src/main/java/io/netty/buffer/ByteBufProcessor.java, + * @deprecated Use {@link ByteProcessor#FIND_NUL}., +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + * Create a copy of the underlying storage from {@code buf} into a byte array., + * Create a copy of the underlying storage from {@code buf} into a byte array., + * Return an array of the underlying storage from {@code buf} into a byte array., +++ b/buffer/src/main/java/io/netty/buffer/ByteBufProcessor.java, + * @deprecated Use {@link ByteProcessor#FIND_NUL}., +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + * Create a copy of the underlying storage from {@code buf} into a byte array., + * Create a copy of the
[+++ b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/FullMemcacheMessageRequestTest.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandler.java, +import io.netty.channel.ChannelStateHandler;, + *, + * To know once a handshake was done you can intercept the, + * {@link ChannelStateHandler#userEventTriggered(ChannelHandlerContext, Object)} and check if the event was of type, + * {@link ClientHandshakeStateEvent#HANDSHAKE_ISSUED} or {@link ClientHandshakeStateEvent#HANDSHAKE_COMPLETE}., + * Events that are fired to notify about handshake status, + */, + public enum ClientHandshakeStateEvent {, + /**, + * The Handshake was started but the server did not response yet to the request, + */, + HANDSHAKE_ISSUED,, +, + /**, + * The Handshake was complete succesful and so the channel was upgraded to websockets, + */,
[+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java, + final Result<?> decodedVariableHeader = decodeVariableHeader(buffer, mqttFixedHeader);, + variableHeader = decodedVariableHeader.value;, + return MqttMessageFactory.newInvalidMessage(mqttFixedHeader, variableHeader, cause);, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java, + final Result<?> decodedVariableHeader = decodeVariableHeader(buffer, mqttFixedHeader);, + variableHeader = decodedVariableHeader.value;, + return MqttMessageFactory.newInvalidMessage(mqttFixedHeader, variableHeader, cause);, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageFactory.java, + public static MqttMessage newInvalidMessage(MqttFixedHeader mqttFixedHeader, Object variableHeader,, + Throwable cause) {, + return new MqttMessage(mqttFixedHeader, variableHeader, null, DecoderResult.failure(cause));, + }, +, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java, + final Result<?> decodedVariableHeader = decodeVariableHeader(buffer, mqttFixedHeader);, + variableHeader = decodedVariableHeader.value;, + return MqttMessageFactory.newInvalidMessage(mqttFixedHeader, variableHeader, cause);, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageFactory.java, + public static MqttMessage newInvalidMessage(MqttFixedHeader mqttFixedHeader, Object variableHeader,, + Throwable cause) {, + return new MqttMessage(mqttFixedHeader, variableHeader, null, DecoderResult.failure(cause));,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, + msg instanceof SpdyHeadersFrame ||, + msg instanceof SpdyPingFrame;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, + msg instanceof SpdyHeadersFrame ||, + msg instanceof SpdyPingFrame;, +++ b/codec/src/main/java/io/netty/handler/codec/CodecUtil.java, +import io.netty.channel.NoSuchBufferException;, + try {, + ctx.nextInboundMessageBuffer().add(msg);, + } catch (NoSuchBufferException e) {, + if (msg instanceof ChannelBuffer) {, + try {, + ctx.nextOutboundMessageBuffer().add(msg);, + } catch (NoSuchBufferException e) {, + if (msg instanceof ChannelBuffer) {, + throw new NoSuchBufferException();, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, + msg instanceof SpdyHeadersFrame ||, + msg instanceof SpdyPingFrame;, +++ b/codec/src/main/java/io/netty/handler/codec/CodecUtil.java, +import io.netty.channel.NoSuchBufferException;, + try {, + ctx.nextInboundMessageBuffer().add(msg);, + } catch (NoSuchBufferException e) {, + if (msg instanceof ChannelBuffer) {, + try {,
[+++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ /dev/null, +++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +, + // If the list is empty we need to assign a new one because, + // we get a List that is immutable. , + //, + // See https://github.com/netty/netty/issues/325, + if (list.isEmpty()) {, + list = new ArrayList<ChannelBuffer>(1);, + }, + ,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, + return ctx.alloc().ioBuffer();, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, + return ctx.alloc().ioBuffer();, +++ b/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java, + return ctx.alloc().ioBuffer(frameLength);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, + return ctx.alloc().ioBuffer();, +++ b/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java, + return ctx.alloc().ioBuffer(frameLength);, +++ b/example/src/main/java/io/netty/example/discard/DiscardServerHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, + return ctx.alloc().ioBuffer();, +++ b/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java, + return ctx.alloc().ioBuffer(frameLength);, +++ b/example/src/main/java/io/netty/example/discard/DiscardServerHandler.java, +++ b/example/src/main/java/io/netty/example/echo/EchoClientHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, + return ctx.alloc().ioBuffer();, +++ b/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java, + return ctx.alloc().ioBuffer(frameLength);, +++ b/example/src/main/java/io/netty/example/discard/DiscardServerHandler.java, +++ b/example/src/main/java/io/netty/example/echo/EchoClientHandler.java, +++ b/example/src/main/java/io/netty/example/echo/EchoServerHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, + return ctx.alloc().ioBuffer();, +++ b/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java, + return ctx.alloc().ioBuffer(frameLength);, +++ b/example/src/main/java/io/netty/example/discard/DiscardServerHandler.java, +++ b/example/src/main/java/io/netty/example/echo/EchoClientHandler.java, +++ b/example/src/main/java/io/netty/example/echo/EchoServerHandler.java, +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClientHandler.java, + return ctx.alloc().ioBuffer(, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, + return ctx.alloc().ioBuffer();, +++ b/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java, + return ctx.alloc().ioBuffer(frameLength);, +++ b/example/src/main/java/io/netty/example/discard/DiscardServerHandler.java, +++ b/example/src/main/java/io/netty/example/echo/EchoClientHandler.java, +++ b/example/src/main/java/io/netty/example/echo/EchoServerHandler.java, +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClientHandler.java, + return ctx.alloc().ioBuffer(,
[+++ b/pom.xml, +++ b/pom.xml, +++ b/src/assembly/default.xml]
[+++ b/codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompSubframeAggregatorTest.java, +, +, +, + frame.release();, +, +, + frame.release();, +, +, + frame.release();, +, + frame.release();, +, + frame.release();, +]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + handshakeFuture = ctx.newFuture();, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + handshakeFuture = ctx.newFuture();, +++ /dev/null, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + handshakeFuture = ctx.newFuture();, +++ /dev/null, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + *
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + if (remaining == 0) {, + // We must skip empty buffers as BIO_write will return 0 if asked to write something, + // with length 0., + srcsOffset ++;, + continue;, + }]
[+++ b/NOTICE.txt, + * https://github.com/akka/akka/blob/master/akka-actor/src/main/java/akka/dispatch/AbstractNodeQueue.java, + * https://github.com/y-256/libdivsufsort, + * https://github.com/google/protobuf, + * https://github.com/google/snappy, + * https://github.com/google/caliper, +++ b/NOTICE.txt, + * https://github.com/akka/akka/blob/master/akka-actor/src/main/java/akka/dispatch/AbstractNodeQueue.java, + * https://github.com/y-256/libdivsufsort, + * https://github.com/google/protobuf, + * https://github.com/google/snappy, + * https://github.com/google/caliper, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Lz4FrameDecoder.java, + * See original <a href="https://github.com/Cyan4973/lz4">LZ4 Github project</a>, + * <a href="https://github.com/Cyan4973/xxHash">Github</a>., +++ b/NOTICE.txt, + * https://github.com/akka/akka/blob/master/akka-actor/src/main/java/akka/dispatch/AbstractNodeQueue.java, + * https://github.com/y-256/libdivsufsort, + * https://github.com/google/protobuf, + * https://github.com/google/snappy, + * https://github.com/google/caliper, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Lz4FrameDecoder.java, + * See original <a href="https://github.com/Cyan4973/lz4">LZ4 Github project</a>, + * <a href="https://github.com/Cyan4973/xxHash">Github</a>., +++ b/codec/src/main/java/io/netty/handler/codec/compression/Lz4FrameEncoder.java, + * See original <a href="https://github.com/Cyan4973/lz4">LZ4 Github project</a>, + * <a href="https://github.com/Cyan4973/xxHash">Github</a>., + * <a href="https://github.com/Cyan4973/xxHash">Github</a>., +++ b/NOTICE.txt,
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, + * The SOMAXCONN value of the current machine. If failed to get the value, {@code 200} is used as a, + * default value for Windows or {@code 128} for others.]
[+++ b/transport/src/main/java/io/netty/channel/ChannelFlushFutureNotifier.java, +/**, + * This implementation allows to register {@link ChannelFuture} instances which will get notified once some amount of, + * data was written and so a checkpoint was reached., + */, +++ b/transport/src/main/java/io/netty/channel/ChannelFlushFutureNotifier.java, +/**, + * This implementation allows to register {@link ChannelFuture} instances which will get notified once some amount of, + * data was written and so a checkpoint was reached., + */, +++ b/transport/src/main/java/io/netty/channel/ChannelFuture.java, +import io.netty.bootstrap.Bootstrap;, +, +, + * public void messageReceived({@link ChannelHandlerContext} ctx, GoodByeMessage msg) {, + * {@link ChannelFuture} future = ctx.channel().close();, + * public void messageReceived({@link ChannelHandlerContext} ctx, GoodByeMessage
[+++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, + private final ReplayingDecoderByteBuf replayable = new ReplayingDecoderByteBuf();, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, + private final ReplayingDecoderByteBuf replayable = new ReplayingDecoderByteBuf();, +++ /dev/null, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, + private final ReplayingDecoderByteBuf replayable = new ReplayingDecoderByteBuf();, +++ /dev/null, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoderByteBuf.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless
[+++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, + return checkLength(src.readableBytes());, +++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, + return checkLength(src.readableBytes());, +++ b/buffer/src/test/java/io/netty/buffer/EmptyByteBufTest.java, + public void testWriteEmptyByteBuf() {, + EmptyByteBuf empty = new EmptyByteBuf(UnpooledByteBufAllocator.DEFAULT);, + empty.writeBytes(Unpooled.EMPTY_BUFFER); // Ok, + ByteBuf nonEmpty = UnpooledByteBufAllocator.DEFAULT.buffer().writeBoolean(false);, + try {, + empty.writeBytes(nonEmpty);, + fail();, + } catch (IndexOutOfBoundsException ignored) {, + // Ignore., + }, + }, +, + @Test]
[+++ /dev/null, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/example/http/HttpTunnelingClientExample.java, +/*, + * JBoss, Home of Professional Open Source, + * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors, + * by the @authors tag. See the copyright.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version., +
[+++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, + String className = checkNotNull(clazz, "clazz").getName();, + int start;, + int last;, + last = indexOfLastNonOwsChar(value, start, length);, + } else {, + start = 0;, + last = length - 1;, + }, + if (start > last) {, +, + int firstUnescapedSpecial = -1;, + boolean quoted = false;, + if (isDoubleQuote(value.charAt(start))) {, + quoted = isDoubleQuote(value.charAt(last)) && last > start;, + if (quoted) {, + start++;, + last--;, + } else {, + firstUnescapedSpecial = start;, + if (firstUnescapedSpecial < 0) {, + if (quoted) {, + if (isDoubleQuote(value.charAt(i))) {, + if (i ==
[+++ b/all/.gitignore, +src, +++ b/all/.gitignore, +src, +++ b/all/pom.xml, + <id>clean-src</id>, + <phase>clean</phase>, + <goals>, + <goal>clean</goal>, + </goals>, + <configuration>, + <filesets>, + <fileset>, + <directory>${project.basedir}/src</directory>, + <followSymlinks>false</followSymlinks>, + <useDefaultExcludes>false</useDefaultExcludes>, + </fileset>, + <fileset>, + <directory>${project.basedir}/target</directory>, + <followSymlinks>false</followSymlinks>, + </fileset>, + </filesets>, + </configuration>, + </execution>, + <execution>, + <id>clean-all</id>, + <configuration>, + <filesets>, + <fileset>, + <directory>${project.basedir}/src</directory>, + <followSymlinks>false</followSymlinks>, + <useDefaultExcludes>false</useDefaultExcludes>, + </fileset>, + <fileset>, + <directory>${project.basedir}/target</directory>, + <followSymlinks>false</followSymlinks>, + </fileset>, + </filesets>, + </configuration>, + <phase>generate-resources</phase>, + <includeGroupIds>io.netty</includeGroupIds>, + <outputDirectory>${project.basedir}/src/main/java</outputDirectory>, + <overWriteReleases>false</overWriteReleases>, + <overWriteSnapshots>true</overWriteSnapshots>, + <phase>generate-resources</phase>, + <overWriteReleases>false</overWriteReleases>, + <overWriteSnapshots>true</overWriteSnapshots>, + <id>fullbuild</id>, +++ b/all/.gitignore, +src, +++ b/all/pom.xml,
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +jint _write(JNIEnv* env, jclass clazz, jint fd, void* buffer, jint pos, jint limit) {, + return -err;, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_write0(JNIEnv* env, jclass clazz, jint fd, jobject jbuffer, jint pos, jint limit) {, + return _write(env, clazz, fd, buffer, pos, limit);, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_writeAddress0(JNIEnv* env, jclass clazz, jint fd, jlong address, jint pos, jint limit) {, + return _write(env, clazz, fd, (void*) address, pos, limit);, +jint _sendTo(JNIEnv* env, jint fd, void* buffer, jint pos, jint limit ,jbyteArray address, jint scopeId, jint port) {, + return -err;, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_sendTo0(JNIEnv* env, jclass clazz, jint fd, jobject
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/example/http/file/HttpStaticFileServerHandler.java, + if (ifModifiedSinceDate.getTime() == file.lastModified()), + {, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/example/http/file/HttpStaticFileServerHandler.java, + if (ifModifiedSinceDate.getTime() == file.lastModified()), + {, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/example/http/file/HttpStaticFileServerHandler.java, + if (ifModifiedSinceDate.getTime() == file.lastModified()), + {, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null,
[+++ b/pom.xml]
[+++ b/transport/src/main/java/io/netty/channel/ChannelPropertyAccess.java, + * it for {@link ChannelOutboundInvoker#write(Object, ChannelPromise)}., +++ b/transport/src/main/java/io/netty/channel/ChannelPropertyAccess.java, + * it for {@link ChannelOutboundInvoker#write(Object, ChannelPromise)}., +++ b/transport/src/main/java/io/netty/channel/group/ChannelGroupException.java, + failed = Collections.unmodifiableCollection(causes);]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + }, + if (va < vb) {, + }, + if (va < vb) {, + }, + if (va < vb) {, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + }, + if (va < vb) {, + }, + if (va < vb) {, + }, + if (va < vb) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + }, + if (msg instanceof HttpMessage) {, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + }, + if (va < vb) {, + }, + if (va < vb) {, + }, + if (va < vb) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + }, + if (msg instanceof HttpMessage) {, +++
[+++ b/codec/src/main/java/io/netty/handler/codec/MessageAggregator.java, + CompositeByteBuf content = ctx.alloc().compositeBuffer(maxCumulationBufferComponents);]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + "minWritableBytes: %d (expected: >= 0)", minWritableBytes));, + "writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d)",, + writerIndex, minWritableBytes, maxCapacity));]
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketShutdownOutputBySelfTest.java, +import io.netty.channel.ChannelInboundHandlerAdapter;, + @Test(timeout = 30000), + public void testShutdownOutputSoLingerNoAssertError() throws Throwable {, + run();, + }, +, + public void testShutdownOutputSoLingerNoAssertError(Bootstrap cb) throws Throwable {, + testShutdownSoLingerNoAssertError0(cb, true);, + }, +, + @Test(timeout = 30000), + public void testShutdownSoLingerNoAssertError() throws Throwable {, + run();, + }, +, + public void testShutdownSoLingerNoAssertError(Bootstrap cb) throws Throwable {, + testShutdownSoLingerNoAssertError0(cb, false);, + }, +, + private void testShutdownSoLingerNoAssertError0(Bootstrap cb, boolean output) throws Throwable {, + ServerSocket ss = new ServerSocket();, + Socket s = null;, +, + ChannelFuture cf = null;, + try {, + ss.bind(newSocketAddress());, + cf =
[+++ b/example/pom.xml, + <dependency>, + <groupId>org.jctools</groupId>, + <artifactId>jctools-core</artifactId>, + <!-- Need runtime scope as otherwise idea is not able to run the examples -->, + <!-- This is most likely a bug in idea -->, + <scope>runtime</scope>, + <optional>true</optional>, + </dependency>]
[+++ b/src/docbook/module/start.xml, + which generates and sends a &ChannelEvent;. In this example,, + &MessageEvent; and sends it to the previous &ChannelDownstreamHandler;]
[+++ b/LICENSE.jsr166y.txt, +The person or persons who have associated work with this document (the, +"Dedicator" or "Certifier") hereby either (a) certifies that, to the best of, +his knowledge, the work of authorship identified is in the public domain of, +the country from which the work is published, or (b) hereby dedicates whatever, +copyright the dedicators holds in the work of authorship identified below (the, +"Work") to the public domain. A certifier, moreover, dedicates any copyright, +interest he may have in the associated work, and for these purposes, is, +described as a "dedicator" below., +, +A certifier has taken reasonable
[+++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, +import io.netty.channel.ChannelInboundHandler;, +import io.netty.channel.ChannelStateHandlerAdapter;, +public abstract class MessageToMessageDecoder<I, O> extends ChannelStateHandlerAdapter implements ChannelInboundHandler<I> {, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, +import io.netty.channel.ChannelInboundHandler;, +import io.netty.channel.ChannelStateHandlerAdapter;, +public abstract class MessageToMessageDecoder<I, O> extends ChannelStateHandlerAdapter implements ChannelInboundHandler<I> {, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, +import io.netty.channel.ChannelOperationHandlerAdapter;, +import io.netty.channel.ChannelOutboundHandler;, +public abstract class MessageToMessageEncoder<I, O>, + extends ChannelOperationHandlerAdapter implements ChannelOutboundHandler<I> {, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageDecoder.java, +import io.netty.channel.ChannelInboundHandler;, +import io.netty.channel.ChannelStateHandlerAdapter;, +public abstract class MessageToMessageDecoder<I, O> extends ChannelStateHandlerAdapter implements ChannelInboundHandler<I> {, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, +import io.netty.channel.ChannelOperationHandlerAdapter;, +import io.netty.channel.ChannelOutboundHandler;, +public abstract class MessageToMessageEncoder<I, O>, + extends ChannelOperationHandlerAdapter implements ChannelOutboundHandler<I> {, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToStreamEncoder.java, +import io.netty.channel.ChannelOperationHandlerAdapter;, +import io.netty.channel.ChannelOutboundHandler;, +public abstract class MessageToStreamEncoder<I>, + extends ChannelOperationHandlerAdapter implements ChannelOutboundHandler<I> {, +++
[+++ /dev/null, +++ /dev/null, +++ b/handler/src/main/java/io/netty/handler/ssl/Java8SslUtils.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeaderTableListSize.java, + // Over 2^31 - 1 (minus in integer) size is set to the maximun value, + maxHeaderListSize = Integer.MAX_VALUE;, + } else {, + }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeaderTableListSize.java, + // Over 2^31 - 1 (minus in integer) size is set to the maximun value, + maxHeaderListSize = Integer.MAX_VALUE;, + } else {, + }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Settings.java, + Integer value = getIntValue(SETTINGS_MAX_HEADER_LIST_SIZE);, +, + // Over 2^31 - 1 (minus in integer) size is set to the maximun value, + if (value != null && value < 0) {, + value = Integer.MAX_VALUE;, + }, +, + return
[+++ b/handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java, + ctx.fireUserEventTriggered(new SniCompletionEvent(e));, + fireSniCompletionEvent(ctx, hostname, future);, + fireSniCompletionEvent(ctx, hostname, future);, + private void fireSniCompletionEvent(ChannelHandlerContext ctx, String hostname, Future<T> future) {, + Throwable cause = future.cause();, + if (cause == null) {, + ctx.fireUserEventTriggered(new SniCompletionEvent(hostname));, + } else {, + ctx.fireUserEventTriggered(new SniCompletionEvent(hostname, cause));, + }, + }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java, + ctx.fireUserEventTriggered(new SniCompletionEvent(e));, + fireSniCompletionEvent(ctx, hostname, future);, + fireSniCompletionEvent(ctx, hostname, future);, + private void fireSniCompletionEvent(ChannelHandlerContext ctx, String hostname, Future<T> future) {, + Throwable cause = future.cause();, + if (cause == null) {, + ctx.fireUserEventTriggered(new SniCompletionEvent(hostname));, + } else {, + ctx.fireUserEventTriggered(new SniCompletionEvent(hostname, cause));, + }, + },
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + selectedSubprotocol = requestedSubprotocol;, + @Deprecated, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + selectedSubprotocol = requestedSubprotocol;, + @Deprecated, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + selectedSubprotocol = requestedSubprotocol;, + @Deprecated, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + selectedSubprotocol = requestedSubprotocol;, + @Deprecated, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + selectedSubprotocol = requestedSubprotocol;, + @Deprecated, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterialManager.java, + // Only try to set the keymaterial if we have a match. This is also consistent with what OpenJDK does:, + // http://hg.openjdk.java.net/jdk/jdk11/file/76072a077ee1/, + // src/java.base/share/classes/sun/security/ssl/CertificateRequest.java#l362, + if (alias != null) {, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterialManager.java, + // Only try to set the keymaterial if we have a match. This is also consistent with what OpenJDK does:, + // http://hg.openjdk.java.net/jdk/jdk11/file/76072a077ee1/, + // src/java.base/share/classes/sun/security/ssl/CertificateRequest.java#l362, + if (alias != null) {, + }, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslKeyMaterialManagerTest.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache
[+++ b/microbench/pom.xml, + <dependency>, + <groupId>uk.co.real-logic</groupId>, + <artifactId>Agrona</artifactId>, + <version>0.1</version>, + </dependency>, +++ b/microbench/pom.xml, + <dependency>, + <groupId>uk.co.real-logic</groupId>, + <artifactId>Agrona</artifactId>, + <version>0.1</version>, + </dependency>, +++ b/microbench/src/test/java/io/netty/microbenchmark/common/IntObjectHashMapBenchmark.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the, + * "License"); you may not use this file except in compliance with the License. You may obtain a, + * copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +, + /**, + * Synchronize on the head. This is needed as {@link PoolSubpage#allocate()} and, + * {@link PoolSubpage#free(int)} may modify the doubly linked list as well., + */, + synchronized (head) {, + }, + private synchronized void allocateNormal(PooledByteBuf<T> buf, int reqCapacity, int normCapacity) {, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +, + /**, + * Synchronize on the head. This is needed as {@link PoolSubpage#allocate()} and, + * {@link PoolSubpage#free(int)} may modify the doubly linked list as well., + */, + synchronized (head) {, + }, + private synchronized void allocateNormal(PooledByteBuf<T> buf, int reqCapacity, int normCapacity) {, +++
[+++ b/buffer/src/test/java/io/netty/buffer/ReadOnlyDirectByteBufferBufTest.java, +import org.junit.After;, +import java.util.ArrayDeque;, +import java.util.Queue;, + private final Queue<ByteBuf> buffers = new ArrayDeque<ByteBuf>();, + @After, + public void dispose() {, + for (;;) {, + ByteBuf buf = buffers.poll();, + if (buf == null) {, + break;, + }, + buf.release();, + }, + }, +, + buffers.add(buffer(allocate(1)));, + buffers.add(buf);, + buffers.add(buf);, +, + buffers.add(buf);, + buffers.add(buf);, + buffers.add(buf);, + buffers.add(buf);, + buffers.add(buf);, + buffers.add(buf);, + buf.release();, + buffers.add(buf);, +, + buffers.add(buf);, +, + buffers.add(buf);, +, + buffers.add(buf);, +, + buffers.add(buf);, + ByteBuf copy = buf.copy();, + buffers.add(copy);, +, + Assert.assertEquals(buf, copy);, + buffers.add(buf);, +, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +import static io.netty.handler.codec.http2.Http2Exception.closedStreamError;, + // For manually created client-side streams, 1 is reserved for HTTP upgrade, so start at 3., + // This check must be after all id validated checks, but before the max streams check because it may be, + // recoverable to some degree for handling frames which can be sent on closed streams., + if (streamId < nextStreamId) {, + throw closedStreamError(PROTOCOL_ERROR, "Request stream %d is behind the next expected stream %d",, + streamId, nextStreamId);, + }, + if (!canCreateStream()) {, + throw connectionError(REFUSED_STREAM, "Maximum streams exceeded for this endpoint.");, + }, +++
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + public Http2Stream stream(int streamId) {, + return streamMap.get(streamId);, + public boolean streamMayHaveExisted(int streamId) {, + return remoteEndpoint.mayHaveCreatedStream(streamId) || localEndpoint.mayHaveCreatedStream(streamId);, + if (stream.id() > lastKnownStream && localEndpoint.isValidStreamId(stream.id())) {, + if (stream.id() > lastKnownStream && remoteEndpoint.isValidStreamId(stream.id())) {, + return localEndpoint.isValidStreamId(id) ? localEndpoint : remoteEndpoint;, + return localEndpoint.isValidStreamId(id);, + public boolean isValidStreamId(int streamId) {, + return streamId > 0 && server == even;, + }, +, + @Override, + public boolean mayHaveCreatedStream(int streamId) {, + return isValidStreamId(streamId) && streamId <= lastStreamCreated;, + if (!isValidStreamId(streamId)) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + public Http2Stream stream(int streamId) {, + return streamMap.get(streamId);, + public boolean
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslContext.java, + KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());, + final KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());, + return buildKeyManagerFactory(certChain, KeyManagerFactory.getDefaultAlgorithm(), key, keyPassword, kmf);]
[+++ b/testsuite/src/main/java/io/netty/testsuite/util/TestUtils.java, + final LZMA2Options options = new LZMA2Options(LZMA2Options.PRESET_DEFAULT);, + } catch (Throwable t) {, + logger.warn("Failed to compress the heap dump: {}", xzFilename, t);]
[+++ b/common/src/main/java/io/netty/util/concurrent/ImmediateEventExecutor.java, +/**, + * {@link AbstractEventExecutor} which execute tasks in the callers thread., + */, +public final class ImmediateEventExecutor extends AbstractEventExecutor {, + public static final ImmediateEventExecutor INSTANCE = new ImmediateEventExecutor();, +, + private ImmediateEventExecutor() {, + // use static instance, + }, + @Override, + public <V> ProgressivePromise<V> newProgressivePromise() {, + return new ImmediateProgressivePromise<V>(this);, + }, +, +, + static class ImmediateProgressivePromise<V> extends DefaultProgressivePromise<V> {, + ImmediateProgressivePromise(EventExecutor executor) {, + super(executor);, + }, +, + @Override, + protected void checkDeadLock() {, + // No check, + }, + }, +++ b/common/src/main/java/io/netty/util/concurrent/ImmediateEventExecutor.java, +/**, + * {@link AbstractEventExecutor} which
[+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java, + if (mqttVersion == MqttVersion.MQTT_3_1_1) {, + final boolean zeroReservedFlag = (b1 & 0x01) == 0x0;, + if (!zeroReservedFlag) {, + // MQTT v3.1.1: The Server MUST validate that the reserved flag in the CONNECT Control Packet is, + // set to zero and disconnect the Client if it is not zero., + // See http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc385349230, + throw new DecoderException("non-zero reserved flag");, + }, + }, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java, + if (mqttVersion == MqttVersion.MQTT_3_1_1) {, + final boolean zeroReservedFlag = (b1 & 0x01) == 0x0;, + if (!zeroReservedFlag) {, + // MQTT v3.1.1: The Server MUST validate that
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java, + logger.debug(, + "WebSocket version 07 client handshake key: {}, expected response: {}",, + key, expectedChallengeResponseString);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java, + logger.debug(, + "WebSocket version 07 client handshake key: {}, expected response: {}",, + key, expectedChallengeResponseString);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + logger.debug(, + "WebSocket version 08 client handshake key: {}, expected response: {}",, + key, expectedChallengeResponseString);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java, + logger.debug(, + "WebSocket version 07 client handshake key: {}, expected response: {}",, + key, expectedChallengeResponseString);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + logger.debug(, + "WebSocket version 08 client handshake key: {}, expected response: {}",, + key, expectedChallengeResponseString);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java, + logger.debug(, + "WebSocket version 13 client
[+++ b/codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java, + discardedBytes += buffer.readableBytes();]
[+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, + private volatile Runnable fireChannelWritabilityChangedTask;, + ChannelOutboundBuffer(AbstractChannel channel) {, + incrementPendingOutboundBytes(size, false);, + decrementPendingOutboundBytes(pending, false, true);, + void incrementPendingOutboundBytes(long size) {, + incrementPendingOutboundBytes(size, true);, + }, +, + private void incrementPendingOutboundBytes(long size, boolean invokeLater) {, + setUnwritable(invokeLater);, + void decrementPendingOutboundBytes(long size) {, + decrementPendingOutboundBytes(size, true, true);, + }, +, + private void decrementPendingOutboundBytes(long size, boolean invokeLater, boolean notifyWritability) {, + if (notifyWritability && (newWriteBufferSize == 0, + || newWriteBufferSize <= channel.config().getWriteBufferLowWaterMark())) {, + setWritable(invokeLater);, + decrementPendingOutboundBytes(size, false, true);, + decrementPendingOutboundBytes(size, false, notifyWritability);, + fireChannelWritabilityChanged(true);, + fireChannelWritabilityChanged(true);, + private void setWritable(boolean invokeLater) {, + if (oldValue != 0
[+++ /dev/null, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, + , + , + // Check if we exceeded the maximum size of 2gb if this is the case then , + // newCapacity == 0, + //, + // https://github.com/netty/netty/issues/258,
[+++ b/pom.xml, + <version>3.0.0.CR3-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/pom.xml, + <tagNameFormat>netty-@{project.version}</tagNameFormat>]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (fromIndex < 0 || fromIndex > toIndex || toIndex > capacity()) {, + "fromIndex: %d, toIndex: %d (expected: 0 <= fromIndex <= toIndex <= capacity(%d))",, +, + if (fromIndex == toIndex) {, + return -1;, + }, +, + @Override, + public int forEachByteDesc(ByteBufProcessor processor) {, + return forEachByteDesc0(readerIndex, writerIndex, processor);, + @Override, + public int forEachByteDesc(int toIndex, int fromIndex, ByteBufProcessor processor) {, + if (toIndex < 0 || toIndex > fromIndex || fromIndex > capacity()) {, + throw new IndexOutOfBoundsException(String.format(, + "toIndex: %d, fromIndex: %d (expected: 0 <= toIndex <= fromIndex <= capacity(%d))",, +
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java]
[+++ b/src/docbook/master.xml, + <xi:include href="module/start.xml", +++ b/src/docbook/master.xml, + <xi:include href="module/start.xml", +++ /dev/null, +++ b/src/docbook/master.xml, + <xi:include href="module/start.xml", +++ /dev/null, +++ b/src/docbook/module/start.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.docbook.org/xml/4.5/docbookx.dtd">, +<chapter id="start">, + <title>Getting Started</title>, + <para>To be written...</para>, +</chapter>]
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider();, + private static DatagramChannel newSocket(SelectorProvider provider) {, + return provider.openDatagramChannel();, + private static DatagramChannel newSocket(SelectorProvider provider, InternetProtocolFamily ipFamily) {, + return newSocket(provider);, + return provider.openDatagramChannel(ProtocolFamilyConverter.convert(ipFamily));, + this(newSocket(DEFAULT_SELECTOR_PROVIDER));, + }, +, + /**, + * Create a new instance using the given {@link SelectorProvider}, + * which will use the Operation Systems default {@link InternetProtocolFamily}., + */, + public NioDatagramChannel(SelectorProvider provider) {, + this(newSocket(provider));, + this(newSocket(DEFAULT_SELECTOR_PROVIDER, ipFamily));, + }, +, + /**, + * Create a new instance using the given {@link SelectorProvider} and {@link InternetProtocolFamily}., + * If {@link
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import static java.lang.Math.max;, +import static java.lang.Math.min;, + private static final int MAX_ENCRYPTION_OVERHEAD_DIFF = Integer.MAX_VALUE - MAX_ENCRYPTION_OVERHEAD_LENGTH;, +, + final int len = min(MAX_ENCRYPTED_PACKET_LENGTH, limit - pos);, + int endOffset = offset + length;, + int srcsLen = 0;, +, + for (int i = offset; i < endOffset; ++i) {, + final ByteBuffer src = srcs[i];, + if (src == null) {, + throw new IllegalArgumentException("srcs[" + i + "] is null");, + }, + if (srcsLen == MAX_PLAINTEXT_LENGTH) {, + continue;, + }, +, + srcsLen += src.remaining();, + if (srcsLen > MAX_PLAINTEXT_LENGTH || srcsLen <
[+++ b/all/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-memcache/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-memcache/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-memcache/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Alpha1-SNAPSHOT</version>, +++ b/codec-memcache/pom.xml, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/JettyNpnSslSession.java, + if (applicationProtocol != null) {, + applicationProtocol = applicationProtocol.replace(':', '_');, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/JettyNpnSslSession.java, + if (applicationProtocol != null) {, + applicationProtocol = applicationProtocol.replace(':', '_');, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + this.applicationProtocol = applicationProtocol.replace(':', '_');]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + private static final ThreadLocal<StringBuilder> BUILDERS = new ThreadLocal<StringBuilder>() {, + @Override, + protected StringBuilder initialValue() {, + return new StringBuilder(512);, + }, +, + @Override, + public StringBuilder get() {, + StringBuilder builder = super.get();, + builder.setLength(0);, + return builder;, + }, + };, +, +, + StringBuilder line = readLine(buffer, maxInitialLineLength);, + int chunkSize = getChunkSize(line.toString());, + StringBuilder line = readHeader(buffer);, + if (line.length() > 0) {, + value = value + ' ' + line.toString().trim();, + } while (line.length() > 0);, + StringBuilder line = readHeader(buffer);, + if (line.length() > 0) {, + String
[+++ b/handler/src/main/java/io/netty/handler/ssl/SniHandler.java, +import io.netty.util.ReferenceCountUtil;, +import javax.net.ssl.SSLEngine;, +, + SSLEngine sslEngine = null;, + try {, + sslEngine = selection.context.newEngine(ctx.alloc());, + ctx.pipeline().replace(this, SslHandler.class.getName(), selection.context.newHandler(sslEngine));, + } catch (Throwable cause) {, + this.selection = EMPTY_SELECTION;, + // Since the SslHandler was not inserted into the pipeline the ownership of the SSLEngine was not, + // transferred to the SslHandler., + // See https://github.com/netty/netty/issues/5678, + ReferenceCountUtil.safeRelease(sslEngine);, + ctx.fireExceptionCaught(cause);, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/SniHandler.java, +import io.netty.util.ReferenceCountUtil;, +import javax.net.ssl.SSLEngine;, +, + SSLEngine sslEngine = null;, + try {, + sslEngine = selection.context.newEngine(ctx.alloc());, + ctx.pipeline().replace(this, SslHandler.class.getName(), selection.context.newHandler(sslEngine));, + } catch (Throwable cause) {, + this.selection =
[+++ b/tarball/pom.xml, + <artifactId>netty-all</artifactId>]
[+++ b/transport-native-epoll/src/main/c/netty_unix_socket.c, + int err = errno;, + if (err == EBADF) {, + netty_unix_errors_throwClosedChannelException(env);, + } else {, + netty_unix_errors_throwChannelExceptionErrorNo(env, "setsockopt() failed: ", err);, + }, + int err = errno;, + if (err == EBADF) {, + netty_unix_errors_throwClosedChannelException(env);, + } else {, + netty_unix_errors_throwChannelExceptionErrorNo(env, "setsockopt() failed: ", err);, + }, +++ b/transport-native-epoll/src/main/c/netty_unix_socket.c, + int err = errno;, + if (err == EBADF) {, + netty_unix_errors_throwClosedChannelException(env);, + } else {, + netty_unix_errors_throwChannelExceptionErrorNo(env, "setsockopt() failed: ", err);, + }, + int err = errno;, + if (err == EBADF) {, + netty_unix_errors_throwClosedChannelException(env);, + } else {, + netty_unix_errors_throwChannelExceptionErrorNo(env, "setsockopt()
[+++ b/pom.xml, + <jetty.alpnAgent.version>1.0.1.Final</jetty.alpnAgent.version>]
[+++ b/microbench/src/main/java/io/netty/microbench/util/AbstractMicrobenchmarkBase.java, + "-XX:+HeapDumpOnOutOfMemoryError", "-Dio.netty.leakDetection.level=disabled"};]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + ChannelHandlerContext ctx = p.context(HttpResponseDecoder.class);, + } else {, + if (p.get(HttpRequestEncoder.class) != null) {, + p.remove(HttpRequestEncoder.class);, + }, + p.replaceAndForward(ctx.name(),, + "ws-decoder", newWebsocketDecoder());, + }]
[+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java, + public boolean isSessionPresent() {, + return sessionPresent;, + }, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java, + public boolean isSessionPresent() {, + return sessionPresent;, + }, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectReturnCode.java, + private static final Map<Byte, MqttConnectReturnCode> VALUE_TO_CODE_MAP;, + VALUE_TO_CODE_MAP = Collections.unmodifiableMap(valueMap);, + if (VALUE_TO_CODE_MAP.containsKey(b)) {, + return VALUE_TO_CODE_MAP.get(b);]
[+++ b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java, +import org.junit.After;, + @After, + public void teardown() throws Exception {, + channel.finish();, + }, +, + written.release();, + written.release();, + written.release();, + written.release();, + written.release();, +, + written.release();, + channel.writeOutbound(new DefaultBinaryMemcacheRequest(new DefaultBinaryMemcacheRequestHeader()));]
[+++ b/all/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta1-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + private static final class Component {, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + private static final class Component {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseDecoder.java, + new HttpResponseStatus(Integer.parseInt(initialLine[1]), initialLine[2]), validateHeaders);, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + private static final class Component {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseDecoder.java, + new HttpResponseStatus(Integer.parseInt(initialLine[1]), initialLine[2]), validateHeaders);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskAttribute.java, + final long newDefinedSize = size + buffer.readableBytes();, + checkSize(newDefinedSize);, + if (definedSize > 0 && definedSize < newDefinedSize) {, + definedSize = newDefinedSize;, +, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + private static final class Component {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseDecoder.java, + new HttpResponseStatus(Integer.parseInt(initialLine[1]), initialLine[2]), validateHeaders);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskAttribute.java, + final long newDefinedSize = size + buffer.readableBytes();, + checkSize(newDefinedSize);, + if (definedSize
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + StringBuilder buf = new StringBuilder();, + buf.append(getClass().getSimpleName());, + buf.append("(ridx: ");, + buf.append(readerIndex);, + buf.append(", widx: ");, + buf.append(writerIndex);, + buf.append(", cap: ");, + buf.append(capacity());, +, + ByteBuf unwrapped = unwrap();, + if (unwrapped != null) {, + buf.append(", unwrapped: ");, + buf.append(unwrapped);, + }, + buf.append(')');, + return buf.toString();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + StringBuilder buf = new StringBuilder();, + buf.append(getClass().getSimpleName());, + buf.append("(ridx: ");, + buf.append(readerIndex);, + buf.append(", widx: ");, + buf.append(writerIndex);, + buf.append(", cap: ");, + buf.append(capacity());, +, + ByteBuf unwrapped = unwrap();, + if (unwrapped != null) {, + buf.append(", unwrapped: ");, + buf.append(unwrapped);, + },
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + String staticLibName = "netty_tcnative";, +, + libNames.add(staticLibName + "_" + os + '_' + arch);, + libNames.add(staticLibName + "_" + os + '_' + arch + "_fedora");, + libNames.add(staticLibName + "_" + arch);, + libNames.add(staticLibName);]
[+++ b/all/pom.xml, + <version>4.1.2.Final</version>, +++ b/all/pom.xml, + <version>4.1.2.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.2.Final</version>, +++ b/all/pom.xml, + <version>4.1.2.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.2.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.2.Final</version>, +++ b/all/pom.xml, + <version>4.1.2.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.2.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.2.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.2.Final</version>, +++ b/all/pom.xml, + <version>4.1.2.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.2.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.2.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.2.Final</version>, +++ b/codec-http/pom.xml, + <version>4.1.2.Final</version>, +++ b/all/pom.xml, + <version>4.1.2.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.2.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.2.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.2.Final</version>, +++ b/codec-http/pom.xml, + <version>4.1.2.Final</version>, +++ b/codec-http2/pom.xml, + <version>4.1.2.Final</version>, +++ b/all/pom.xml, + <version>4.1.2.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.2.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.2.Final</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/pom.xml, + <version>1.0-beta-4</version>, + <revisionOnScmFailure>-1</revisionOnScmFailure>]
[+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageBuilders.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java, +import io.netty.handler.codec.http.HttpHeaderValues;, + if (!response.headers().contains(HttpHeaderNames.CONTENT_LENGTH)) {, + response.headers().set(HttpHeaderNames.CONTENT_LENGTH, HttpHeaderValues.ZERO);, + }, + HttpResponse response = new DefaultFullHttpResponse(request.protocolVersion(), FORBIDDEN);, + response.headers().set(HttpHeaderNames.CONTENT_LENGTH, HttpHeaderValues.ZERO);, + respond(ctx, request, response);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java, +import io.netty.handler.codec.http.HttpHeaderValues;, + if (!response.headers().contains(HttpHeaderNames.CONTENT_LENGTH)) {, + response.headers().set(HttpHeaderNames.CONTENT_LENGTH, HttpHeaderValues.ZERO);, + }, + HttpResponse response = new DefaultFullHttpResponse(request.protocolVersion(), FORBIDDEN);, + response.headers().set(HttpHeaderNames.CONTENT_LENGTH, HttpHeaderValues.ZERO);, + respond(ctx, request, response);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsHandlerTest.java, + assertThat(response.headers().get(CONTENT_LENGTH), is("0"));, + assertThat(response.headers().get(CONTENT_LENGTH), is("0"));]
[+++ b/codec/src/main/java/io/netty/handler/codec/CharSequenceValueConverter.java, + AsciiString asciiString = (AsciiString) value;, + return asciiString.contentEqualsIgnoreCase("true");, + }, + if (value.length() != 4) {, + return false;, +++ b/codec/src/main/java/io/netty/handler/codec/CharSequenceValueConverter.java, + AsciiString asciiString = (AsciiString) value;, + return asciiString.contentEqualsIgnoreCase("true");, + }, + if (value.length() != 4) {, + return false;, +++ b/codec/src/test/java/io/netty/handler/codec/DefaultHeadersTest.java, +import io.netty.util.AsciiString;, +, + @Test, + public void testGetBooleanInvalidValue() {, + TestDefaultHeaders headers = newInstance();, + headers.set("name1", "invalid");, + headers.set("name2", new AsciiString("invalid"));, + headers.set("name3", new StringBuilder("invalid"));, +, + assertFalse(headers.getBoolean("name1", false));, + assertFalse(headers.getBoolean("name2", false));, + assertFalse(headers.getBoolean("name3", false));, + }, +, + @Test, + public void testGetBooleanFalseValue() {, + TestDefaultHeaders headers = newInstance();, + headers.set("name1",
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + int newCapacity = alloc().calculateNewCapacity(writerIndex + minWritableBytes, maxCapacity);, + int newCapacity = alloc().calculateNewCapacity(writerIndex + minWritableBytes, maxCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + int newCapacity = alloc().calculateNewCapacity(writerIndex + minWritableBytes, maxCapacity);, + int newCapacity = alloc().calculateNewCapacity(writerIndex + minWritableBytes, maxCapacity);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +, + @Override, + public int calculateNewCapacity(int minNewCapacity, int maxCapacity) {, + if (minNewCapacity < 0) {, + throw new IllegalArgumentException("minNewCapacity: " + minNewCapacity + " (expectd: 0+)");, + }, + if (minNewCapacity > maxCapacity) {, + throw new IllegalArgumentException(String.format(, + "minNewCapacity: %d (expected: not greater than maxCapacity(%d)",, + minNewCapacity, maxCapacity));, + }, + final int threshold = 1048576 * 4;
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java, + *, + * @deprecated is part of {@link ChannelInboundHandler}, + @Deprecated]
[+++ b/transport/src/test/java/io/netty/channel/nio/NioEventLoopTest.java, +import org.junit.Ignore;, + @Ignore]
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +extern int pipe2(int pipefd[2], int flags) __attribute__((weak));, +, +JNIEXPORT jlong JNICALL Java_io_netty_channel_epoll_Native_pipe0(JNIEnv* env, jclass clazz) {, + int fd[2];, + if (pipe2) {, + // we can just use pipe2 and so save extra syscalls;, + if (pipe2(fd, O_NONBLOCK) != 0) {, + return -errno;, + }, + } else {, + if (pipe(fd) == 0) {, + if (fcntl(fd[0], F_SETFD, O_NONBLOCK) < 0) {, + int err = errno;, + close(fd[0]);, + close(fd[1]);, + return -err;, + }, + if (fcntl(fd[1], F_SETFD, O_NONBLOCK) < 0) {, + int err = errno;, + close(fd[0]);, + close(fd[1]);, +
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + * Skeletal {@link ByteBufAllocator} implementation to extend., +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + * Skeletal {@link ByteBufAllocator} implementation to extend., +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * the number of the underlying {@link ByteBuffer}s if this buffer has at least one underlying, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + * Skeletal {@link ByteBufAllocator} implementation to extend., +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * the number of the underlying {@link ByteBuffer}s if this buffer has at least one underlying, +++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, + * Creates a new big-endian direct buffer with reasonably small initial capacity, which, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + * Skeletal {@link ByteBufAllocator} implementation to extend., +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * the
[+++ b/common/src/main/java/io/netty/util/SocketAddresses.java, +import java.net.NetworkInterface;, +import java.net.SocketException;, + public static final NetworkInterface LOOPBACK_IF;, +, + NetworkInterface loopbackIf;, + try {, + loopbackIf = NetworkInterface.getByInetAddress(LOCALHOST);, + } catch (SocketException e) {, + loopbackIf = null;, + }, +, + // check if the NetworkInterface is null, this is the case on my ubuntu dev machine but not on osx and windows., + // if so fail back the the first interface, + if (loopbackIf == null) {, + // use nextElement() as NetWorkInterface.getByIndex(0) returns null, + try {, + loopbackIf = NetworkInterface.getNetworkInterfaces().nextElement();, + } catch (SocketException e) {, + logger.error("Failed to
[+++ b/transport-native-kqueue/pom.xml, + <!-- support for __attribute__((weak_import)) by the linker was added in 10.2 (but 10.6 is the minimum we can use on 10.14) so ensure we, + <arg>MACOSX_DEPLOYMENT_TARGET=10.6</arg>]
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, + if (isSharable()) {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, + if (isSharable()) {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + if (isSharable()) {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, + if (isSharable()) {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + if (isSharable()) {, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java, +import java.util.Map;, +import java.util.WeakHashMap;, +, + /**, + * Cache the result of {@link Sharable} annotation detection to workaround a condition. We use a, + * {@link ThreadLocal} and {@link WeakHashMap} to eliminate the volatile write/reads. Using different, + * {@link WeakHashMap} instances per {@link Thread} is good enough for us and the number of, + * {@link Thread}s are quite limited anyway., + *, + *
[+++ b/transport/src/main/java/io/netty/channel/aio/AbstractAioChannel.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + final boolean unaligned;, + int version = javaVersion();, + if (version >= 9) {, + // Java9/10 use all lowercase and later versions all uppercase., + String fieldName = version >= 11 ? "UNALIGNED" : "unaligned";, + // On Java9 and later we try to directly access the field as we can do this without, + // adjust the accessible levels., + try {, + Field unalignedField = bitsClass.getDeclaredField(fieldName);, + if (unalignedField.getType() == boolean.class) {, + long offset = UNSAFE.staticFieldOffset(unalignedField);, + Object object = UNSAFE.staticFieldBase(unalignedField);, + return UNSAFE.getBoolean(object, offset);, + }, + // There is something
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpChunk.java, +public class DefaultHttpChunk extends DefaultHttpObject implements HttpChunk {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpChunk.java, +public class DefaultHttpChunk extends DefaultHttpObject implements HttpChunk {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpChunkTrailer.java, +public class DefaultHttpChunkTrailer extends DefaultHttpObject implements HttpChunkTrailer {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpChunk.java, +public class DefaultHttpChunk extends DefaultHttpObject implements HttpChunk {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpChunkTrailer.java, +public class DefaultHttpChunkTrailer extends DefaultHttpObject implements HttpChunkTrailer {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java, +public class DefaultHttpMessage extends DefaultHttpObject implements HttpMessage {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpChunk.java, +public class DefaultHttpChunk extends DefaultHttpObject implements HttpChunk {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpChunkTrailer.java, +public class DefaultHttpChunkTrailer extends DefaultHttpObject implements HttpChunkTrailer {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java, +public class DefaultHttpMessage extends DefaultHttpObject implements HttpMessage {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpObject.java, +/*, + * Copyright 2012 The Netty
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameCodecTest.java, + @Test(timeout = 5000)]
[+++ b/all/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/codec/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/codec/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/common/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta3</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdRequestDecoderTest.java, +, +import java.net.InetAddress;, +import java.net.UnknownHostException;, + public void testCmdRequestDecoderIPv6() throws UnknownHostException {, + String[] hosts = {SocksCommonUtils.ipv6toStr(InetAddress.getByName("::1").getAddress())};, +++ b/codec-socks/src/test/java/io/netty/handler/codec/socks/SocksCmdRequestDecoderTest.java, +, +import java.net.InetAddress;, +import java.net.UnknownHostException;, + public void testCmdRequestDecoderIPv6() throws UnknownHostException {, + String[] hosts = {SocksCommonUtils.ipv6toStr(InetAddress.getByName("::1").getAddress())};, +++ b/codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/Socks5CommandRequestDecoderTest.java, +import java.net.InetAddress;, +import java.net.UnknownHostException;, + public void testCmdRequestDecoderIPv6() throws UnknownHostException {, + NetUtil.bytesToIpAddress(InetAddress.getByName("::1").getAddress()) };]
[+++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, + // Duplicate the buffer so we not adjust the position during our get operation., + // See https://github.com/netty/netty/issues/3896, + ByteBuffer duplicate = buffer.duplicate();, + duplicate.get(copy);, + return wrappedBuffer(copy).order(duplicate.order());, + // Duplicate the buffer so we not adjust the position during our get operation., + // See https://github.com/netty/netty/issues/3896, + ByteBuffer b = buffers[i].duplicate();]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, + buf.append((char) HttpConstants.SP);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, + buf.append((char) HttpConstants.SP);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoderUtil.java, + buf.setLength(buf.length() - 2);, + sb.append((char) HttpConstants.SP);, + sb.append((char) HttpConstants.SP);, + sb.append((char) HttpConstants.SP);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, + buf.append((char) HttpConstants.SP);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoderUtil.java, + buf.setLength(buf.length() - 2);, + sb.append((char) HttpConstants.SP);, + sb.append((char) HttpConstants.SP);, + sb.append((char) HttpConstants.SP);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ServerCookieEncoder.java, + buf.append((char) HttpConstants.SP);, + buf.append((char) HttpConstants.SP);, + buf.append((char) HttpConstants.SP);, + buf.append((char) HttpConstants.SP);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, + buf.append((char) HttpConstants.SP);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoderUtil.java, + buf.setLength(buf.length() - 2);, + sb.append((char) HttpConstants.SP);, + sb.append((char) HttpConstants.SP);, + sb.append((char) HttpConstants.SP);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ServerCookieEncoder.java, + buf.append((char) HttpConstants.SP);, + buf.append((char) HttpConstants.SP);, + buf.append((char) HttpConstants.SP);, + buf.append((char) HttpConstants.SP);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/CookieEncoderTest.java]
[+++ b/pom.xml, +, + <!-- Workaround for the 'M2E plugin execution not covered' problem., + See: http://wiki.eclipse.org/M2E_plugin_execution_not_covered -->, + <pluginManagement>, + <plugins>, + <plugin>, + <groupId>org.eclipse.m2e</groupId>, + <artifactId>lifecycle-mapping</artifactId>, + <version>1.0.0</version>, + <configuration>, + <lifecycleMappingMetadata>, + <pluginExecutions>, + <pluginExecution>, + <pluginExecutionFilter>, + <groupId>org.apache.maven.plugins</groupId>, + <artifactId>maven-checkstyle-plugin</artifactId>, + <versionRange>[1.0,)</versionRange>, + <goals>, + <goal>check</goal>, + </goals>, + </pluginExecutionFilter>, + <action>, + <ignore />, + </action>, + </pluginExecution>, + </pluginExecutions>, + </lifecycleMappingMetadata>, + </configuration>, + </plugin>, + </plugins>, + </pluginManagement>]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + static final int MAX_ENCRYPTION_OVERHEAD_LENGTH = MAX_ENCRYPTED_PACKET_LENGTH - MAX_PLAINTEXT_LENGTH;, +, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + static final int MAX_ENCRYPTION_OVERHEAD_LENGTH = MAX_ENCRYPTED_PACKET_LENGTH - MAX_PLAINTEXT_LENGTH;, +, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + /**, + * {@code true} if and only if {@link SSLEngine#wrap(ByteBuffer, ByteBuffer)} requires the output buffer, + * to be always as large as {@link #maxPacketBufferSize} even if the input buffer contains small amount of data., + * <p>, + * If this flag is {@code false}, we allocate a smaller output buffer., + * </p>, + */, + private final boolean needsLargeOutNetBuf;, + needsLargeOutNetBuf = !(engine instanceof OpenSslEngine);, +, + if
[+++ b/all/pom.xml, + <version>4.0.0.CR2</version>, +++ b/all/pom.xml, + <version>4.0.0.CR2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR2</version>, +++ b/all/pom.xml, + <version>4.0.0.CR2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR2</version>, +++ b/all/pom.xml, + <version>4.0.0.CR2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR2</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR2</version>, +++ b/all/pom.xml, + <version>4.0.0.CR2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR2</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR2</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR2</version>, +++ b/all/pom.xml, + <version>4.0.0.CR2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR2</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR2</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR2</version>, +++ b/common/pom.xml, + <version>4.0.0.CR2</version>, +++ b/all/pom.xml, + <version>4.0.0.CR2</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR2</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR2</version>, +++ b/codec-socks/pom.xml, +
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java, +import io.netty.channel.ChannelOption;, + run();, + cb.option(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION, true);, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java, +import io.netty.channel.ChannelOption;, + run();, + cb.option(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION, true);, +++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, + @Deprecated, + public static final ChannelOption<Boolean> DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION =, + new ChannelOption<Boolean>("DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION");, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java, +import io.netty.channel.ChannelOption;, + run();, + cb.option(ChannelOption.DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION, true);, +++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, + @Deprecated, + public static final ChannelOption<Boolean> DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION =, + new ChannelOption<Boolean>("DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION");, +++ b/transport/src/main/java/io/netty/channel/socket/DefaultDatagramChannelConfig.java, + private volatile boolean activeOnOpen;, + IP_MULTICAST_ADDR, IP_MULTICAST_IF, IP_MULTICAST_TTL, IP_TOS, DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION);, + if (option == DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION) {, + return (T) Boolean.valueOf(activeOnOpen);, + }, + } else if (option == DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION) {, + setActiveOnOpen((Boolean) value);, + private void setActiveOnOpen(boolean activeOnOpen) {, + if
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsEntry.java, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsEntry.java, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuestion.java, +, + if (name.isEmpty()) {, + throw new IllegalArgumentException("name must not be left blank.");, + }, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsEntry.java, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuestion.java, +, + if (name.isEmpty()) {, + throw new IllegalArgumentException("name must not be left blank.");, + }, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseDecoder.java, + return "";, +, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsEntry.java, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsQuestion.java, +, + if (name.isEmpty()) {, + throw new IllegalArgumentException("name must not be left blank.");, + }, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DnsResponseDecoder.java, + return "";, +, +++ b/codec-dns/src/test/java/io/netty/handler/codec/dns/DnsResponseTest.java, + {, + 0, 1, -127, -128, 0, 1, 0, 1, 0, 0, 0, 0, 3, 119, 119, 119, 7, 101, 120, 97,
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, + * Handles an I/O event or intercepts an I/O operation, and forwards it to its next handler in, + * its {@link ChannelPipeline}., + * {@link ChannelHandler} itself does not provide many methods, but you usually have to implement one of its subtypes:, + * <li>{@link ChannelInboundHandler} to handle inbound I/O events, and</li>, + * <li>{@link ChannelOutboundHandler} to handle outbound I/O operations.</li>, + * </p>, + * <p>, + * Alternatively, the following adapter classes are provided for your convenience:, + * <ul>, + * <li>{@link ChannelInboundHandlerAdapter} to handle inbound I/O events,</li>, + * <li>{@link ChannelOutboundHandlerAdapter}
[+++ b/common/src/main/java/io/netty/util/internal/EmptyArrays.java, +import java.security.cert.Certificate;, + public static final Certificate[] EMPTY_CERTIFICATES = new Certificate[0];, + public static final javax.security.cert.X509Certificate[] EMPTY_JAVAX_X509_CERTIFICATES =, + new javax.security.cert.X509Certificate[0];, +++ b/common/src/main/java/io/netty/util/internal/EmptyArrays.java, +import java.security.cert.Certificate;, + public static final Certificate[] EMPTY_CERTIFICATES = new Certificate[0];, + public static final javax.security.cert.X509Certificate[] EMPTY_JAVAX_X509_CERTIFICATES =, + new javax.security.cert.X509Certificate[0];, +++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, + public static final String EMPTY_STRING = "";, +++ b/common/src/main/java/io/netty/util/internal/EmptyArrays.java, +import java.security.cert.Certificate;, + public static final Certificate[] EMPTY_CERTIFICATES = new Certificate[0];, + public static final javax.security.cert.X509Certificate[] EMPTY_JAVAX_X509_CERTIFICATES =, + new javax.security.cert.X509Certificate[0];, +++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, + public static final String EMPTY_STRING = "";, +++ b/example/src/main/java/io/netty/example/http2/client/Http2Client.java, +import io.netty.handler.ssl.OpenSsl;, + SslProvider provider = OpenSsl.isAlpnSupported() ?
[+++ b/codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java, +, + long discard = frameLength - in.readableBytes();, + tooLongFrameLength = frameLength;, +, + if (discard < 0) {, + // buffer contains more bytes then the frameLength so we can discard all now, + in.skipBytes((int) frameLength);, + } else {, + bytesToDiscard = discard;, + }, +++ b/codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java, +, + long discard = frameLength - in.readableBytes();, + tooLongFrameLength = frameLength;, +, + if (discard < 0) {, + // buffer contains more bytes then the frameLength so we can discard all now, + in.skipBytes((int) frameLength);, + } else {, + bytesToDiscard = discard;, + }, +++
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * By contrast, this method guarantees that it never, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * By contrast, this method guarantees that it never, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessage.java, + * @return The protocol version, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * By contrast, this method guarantees that it never, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessage.java, + * @return The protocol version, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * By contrast, this method guarantees that it never, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessage.java, + * @return The protocol version, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/Attribute.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * By contrast, this method guarantees that it never, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessage.java, + * @return The protocol version, +++
[+++ b/pom.xml, + <phase>validate</phase>, + <echo message="// DO NOT MODIFY - WILL BE OVERWRITTEN DURING THE BUILD PROCESS${line.separator}package org.jboss.netty.util;${line.separator}/** Provides the version information of Netty. */${line.separator}public final class Version {${line.separator} /** The version identifier. */${line.separator} public static final String ID = &quot;${project.version}-r${buildNumber}&quot;;${line.separator} private Version() { super(); }${line.separator}}${line.separator}" file="${basedir}/src/main/java/org/jboss/netty/util/Version.java" />]
[+++ b/example/pom.xml, + <properties>, + <npn.version>1.1.6.v20130911</npn.version>, + </properties>, + <version>${npn.version}</version>]
[+++ b/common/src/main/java/io/netty/util/UniqueName.java, + public final int id() {, + return id;, + }, +, +++ b/common/src/main/java/io/netty/util/UniqueName.java, + public final int id() {, + return id;, + }, +, +++ b/example/src/main/java/io/netty/example/objectecho/ObjectEchoClientHandler.java, + // Echo back the received object to the server., +++ b/common/src/main/java/io/netty/util/UniqueName.java, + public final int id() {, + return id;, + }, +, +++ b/example/src/main/java/io/netty/example/objectecho/ObjectEchoClientHandler.java, + // Echo back the received object to the server., +++ b/pom.xml, + <ignore>java.nio.channels.InterruptedByTimeoutException</ignore>, +++ b/common/src/main/java/io/netty/util/UniqueName.java, + public final int id() {, + return id;, + }, +, +++ b/example/src/main/java/io/netty/example/objectecho/ObjectEchoClientHandler.java, + // Echo back the received object to the server., +++ b/pom.xml, +
[+++ b/pom.xml, + <version>2.3.2</version>]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + private final class PropertyKeyRegistry {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + private final class PropertyKeyRegistry {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ServerUpgradeCodec.java]
[+++ b/common/src/main/java/io/netty/util/AttributeKey.java]
[+++ b/pom.xml, + <version>3.0.0.CR1</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.0.0.CR1</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.0.0.CR1</developerConnection>]
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/CompositeBufferGatheringWriteTest.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, +import io.netty.channel.ChannelInboundHandlerContext;, +import io.netty.handler.codec.MessageToMessageDecoder;, +import java.util.List;, +import java.util.Map.Entry;, +, +public class HttpChunkAggregator extends MessageToMessageDecoder<Object, HttpMessage> {, + @Override, + public HttpMessage decode(ChannelInboundHandlerContext<Object> ctx, Object msg) throws Exception {, + ctx.write(CONTINUE.duplicate());, + m.setContent(ChannelBuffers.dynamicBuffer());, + return null;, + return m;, + // All done, + return currentMessage;, + } else {, + return null;, + throw new IllegalStateException(, + "Only " + HttpMessage.class.getSimpleName() + " and " +, + HttpChunk.class.getSimpleName() + " are accepted: " + msg.getClass().getName());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, +import io.netty.channel.ChannelInboundHandlerContext;, +import io.netty.handler.codec.MessageToMessageDecoder;, +import java.util.List;, +import java.util.Map.Entry;, +, +public class HttpChunkAggregator extends MessageToMessageDecoder<Object, HttpMessage> {, + @Override, + public
[+++ b/pom.xml, + <version>3.1.0.BETA4-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, + *, + * @deprecated Will be removed in the future and only {@link ChannelInboundHandler} will receive, + * exceptionCaught events. For {@link ChannelOutboundHandler} the {@link ChannelPromise}, + * must be failed., + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, + *, + * @deprecated Will be removed in the future and only {@link ChannelInboundHandler} will receive, + * exceptionCaught events. For {@link ChannelOutboundHandler} the {@link ChannelPromise}, + * must be failed., + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java, + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, + *, + * @deprecated Will be removed in the future and only {@link ChannelInboundHandler} will receive, + * exceptionCaught events.
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractMessageBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractMessageBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/FilteredMessageBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractMessageBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/FilteredMessageBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/MessageBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractMessageBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/FilteredMessageBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/MessageBuf.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import io.netty.buffer.FilteredMessageBuf;, +, + protected void decode(, + ChannelHandlerContext ctx, ByteBuf buffer, MessageBuf<Object> out) throws Exception {, + return;, + out.add(buffer.readBytes(readable));, + out = new FilteredMessageBuf(out) {, + @Override, + protected Object filter(Object msg) {, + };, + }, + super.decode(ctx, buffer, out);, + }, +++ b/buffer/src/main/java/io/netty/buffer/AbstractMessageBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/FilteredMessageBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/MessageBuf.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import io.netty.buffer.FilteredMessageBuf;, +, + protected void decode(, + ChannelHandlerContext ctx, ByteBuf buffer, MessageBuf<Object> out) throws Exception {, + return;, + out.add(buffer.readBytes(readable));, + out = new FilteredMessageBuf(out)
[+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java, + private static final int MINIMUM_HEADER_SIZE = 24;, + ByteBuf buf = ctx.alloc().buffer(MINIMUM_HEADER_SIZE + msg.extrasLength(), + + msg.keyLength());]
[+++ b/pom.xml, + <exec, + executable="git" outputproperty="gitOutput.lastCommit" resultproperty="gitExitCode.lastCommit", + failonerror="false" failifexecutionfails="false">, + <arg value="--format=format:%h %H %cd" />, + <propertyregex, + property="shortCommitHash" input="${gitOutput.lastCommit}", + regexp="^([0-9a-f]+) .*$" select="\1" casesensitive="true", + defaultValue="0" />, + <propertyregex, + property="longCommitHash" input="${gitOutput.lastCommit}", + regexp="^[0-9a-f]+ ([0-9a-f]{40}) .*$" select="\1" casesensitive="true", + defaultValue="0000000000000000000000000000000000000000" />, + <propertyregex, + property="commitDate" input="${gitOutput.lastCommit}", + regexp="^[0-9a-f]+ [0-9a-f]{40} (.*)$" select="\1" casesensitive="true", + defaultValue="1970-01-01 00:00:00 +0000" />, + <!-- Get the information abount whether the repository is clean or dirty -->, + <exec, + executable="git" outputproperty="gitOutput.repoStatus" resultproperty="gitExitCode.repoStatus", + failonerror="false" failifexecutionfails="false">]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterialManager.java, + SSL.setCertificateChainBio(ssl, keyCertChainBio2, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterialManager.java, + SSL.setCertificateChainBio(ssl, keyCertChainBio2, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, + SSLContext.setCertificateChainBio(ctx, keyCertChainBio2, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterialManager.java, + SSL.setCertificateChainBio(ssl, keyCertChainBio2, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, + SSLContext.setCertificateChainBio(ctx, keyCertChainBio2, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, + private final OpenSslSession session;, + if (chain == null || chain.length == 0) {, + if (clientCert == null || clientCert.length == 0) {, + peerCerts = EmptyArrays.EMPTY_CERTIFICATES;, + x509PeerCerts = EmptyArrays.EMPTY_JAVAX_X509_CERTIFICATES;, + peerCerts = new Certificate[1];, + x509PeerCerts = new X509Certificate[1];, + peerCerts[0] = new OpenSslX509Certificate(clientCert);, + x509PeerCerts[0] = new OpenSslJavaxX509Certificate(clientCert);, + } else if (clientCert == null || clientCert.length == 0) {, + peerCerts
[+++ b/src/main/java/io/netty/handler/execution/ChannelDownstreamEventRunnable.java, +/*, + * Copyright 2011 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import io.netty.channel.SimpleChannelInboundHandler;, +import io.netty.handler.codec.http.HttpObjectAggregator;, +import io.netty.handler.codec.http.HttpResponse;, +import io.netty.util.ReferenceCountUtil;, +import io.netty.util.internal.EmptyArrays;, +import java.nio.channels.ClosedChannelException;, + private static final ClosedChannelException CLOSED_CHANNEL_EXCEPTION = new ClosedChannelException();, +, + static {, + CLOSED_CHANNEL_EXCEPTION.setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);, + }, + // Remove aggregator if present before, + HttpObjectAggregator aggregator = p.get(HttpObjectAggregator.class);, + if (aggregator != null) {, + p.remove(aggregator);, + }, +, + * Process the opening handshake initiated by {@link #handshake}}., + *, + * @param channel, + * Channel, + * @param response, + * HTTP response containing the closing handshake details, + * @return future, + * the {@link ChannelFuture}which is notified once the
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, +import io.netty.channel.Channel;, +import io.netty.handler.codec.http.HttpServerCodec;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(SpdyOrHttpChooser.class);, +, + HTTP_1_0("http/1.0");, + * @param name the protocol name, + * @return the selected protocol or {@code null} if there is no match, + return null;, + protected SpdyOrHttpChooser() { }, + if (configurePipeline(ctx)) {, + private boolean configurePipeline(ChannelHandlerContext ctx) {, + throw new IllegalStateException("cannot find a SslHandler in the pipeline (required for SPDY)");, + if (!handler.handshakeFuture().isDone()) {, + }, +, + SelectedProtocol protocol;, + try {, + protocol = selectProtocol(handler);, + } catch (Exception e) {, + throw new
[+++ b/all/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/example/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha6-SNAPSHOT</version>, +++ b/codec/pom.xml, +
[+++ b/all/pom.xml, + <version>4.1.32.Final</version>, +++ b/all/pom.xml, + <version>4.1.32.Final</version>, +++ b/bom/pom.xml, + <version>4.1.32.Final</version>, + <tag>netty-4.1.32.Final</tag>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, +++ b/all/pom.xml, + <version>4.1.32.Final</version>, +++ b/bom/pom.xml, + <version>4.1.32.Final</version>, + <tag>netty-4.1.32.Final</tag>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, + <version>4.1.32.Final</version>, +
[+++ b/example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java, + // Connect with V13 (RFC 6455 aka HyBi-17). You can change it to V08 or V00., +++ b/example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java, + // Connect with V13 (RFC 6455 aka HyBi-17). You can change it to V08 or V00., +++ /dev/null]
[+++ b/common/src/main/java/io/netty/util/internal/logging/LocationAwareSlf4JLogger.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return BufUtil.decodeString(nioBuffer, charset);, + return BufUtil.indexOf(this, fromIndex, toIndex, value);, + return BufUtil.indexOf(this, fromIndex, toIndex, indexFinder);, + return BufUtil.hashCode(this);, + return BufUtil.equals(this, (ByteBuf) o);, + return BufUtil.compare(this, that);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return BufUtil.decodeString(nioBuffer, charset);, + return BufUtil.indexOf(this, fromIndex, toIndex, value);, + return BufUtil.indexOf(this, fromIndex, toIndex, indexFinder);, + return BufUtil.hashCode(this);, + return BufUtil.equals(this, (ByteBuf) o);, + return BufUtil.compare(this, that);, +++ b/buffer/src/main/java/io/netty/buffer/BufUtil.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + int offset = first.offset;, + setIndex(readerIndex - offset, writerIndex - offset);, + adjustMarkers(offset);, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + int offset = first.offset;, + setIndex(readerIndex - offset, writerIndex - offset);, + adjustMarkers(offset);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, +, + // See https://github.com/netty/netty/issues/1976, + @Test, + public void testDiscardSomeReadBytes() {, + CompositeByteBuf cbuf = freeLater(compositeBuffer());, + int len = 8 * 4;, + for (int i = 0; i < len; i += 4) {, + ByteBuf buf = Unpooled.buffer().writeInt(i);, + cbuf.capacity(cbuf.writerIndex()).addComponent(buf).writerIndex(i + 4);, + }, + cbuf.writeByte(1);, +, + byte[] me = new byte[len];, + cbuf.readBytes(me);, + cbuf.readByte();, +, + cbuf.discardSomeReadBytes();, + }]
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java, + private DnsServerAddresses nameServerAddresses = DnsServerAddresses.defaultAddresses();, + * @param channelType the type, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java, + private DnsServerAddresses nameServerAddresses = DnsServerAddresses.defaultAddresses();, + * @param channelType the type, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddresses.java, + * uncached {@link DnsNameResolver#resolve(String)}or {@link DnsNameResolver#resolveAll(String)}.]
[+++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2OutboundFrameLogger.java, + if (ack) {, + logger.logPingAck(OUTBOUND, data);, + } else {, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostBodyUtil.java, + /**, + * @param buffer buffer with a backing byte array, + */, + SeekAheadOptimize(ByteBuf buffer) {, + throw new IllegalArgumentException("buffer hasn't backing byte array");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostBodyUtil.java, + /**, + * @param buffer buffer with a backing byte array, + */, + SeekAheadOptimize(ByteBuf buffer) {, + throw new IllegalArgumentException("buffer hasn't backing byte array");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, +import static io.netty.util.internal.ObjectUtil.*;, + this.request = checkNotNull(request, "request");, + this.charset = checkNotNull(charset, "charset");, + this.factory = checkNotNull(factory, "factory");, + this.discardThreshold = checkPositiveOrZero(discardThreshold, "discardThreshold");, + loadFieldMultipart(undecodedChunk, multipartDataBoundary, currentAttribute);, + private static void skipControlCharacters(ByteBuf undecodedChunk) {, + if (!undecodedChunk.hasArray()) {, + skipControlCharactersStandard(undecodedChunk);, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerKeepAliveHandler.java, + * <li>See <a href="https://tools.ietf.org/html/rfc7230#section-3.3.2"/></li>, + isInformational(response) || response.status().code() == HttpResponseStatus.NO_CONTENT.code();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerKeepAliveHandler.java, + * <li>See <a href="https://tools.ietf.org/html/rfc7230#section-3.3.2"/></li>, + isInformational(response) || response.status().code() == HttpResponseStatus.NO_CONTENT.code();, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpServerKeepAliveHandlerTest.java, +import static io.netty.handler.codec.http.HttpHeaderValues.CLOSE;, +import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;, +import static io.netty.handler.codec.http.HttpHeaderValues.MULTIPART_MIXED;, +import static io.netty.handler.codec.http.HttpResponseStatus.NO_CONTENT;, +import static io.netty.handler.codec.http.HttpResponseStatus.OK;, +import static io.netty.handler.codec.http.HttpUtil.isContentLengthSet;, +import static io.netty.handler.codec.http.HttpUtil.isKeepAlive;, +import static io.netty.handler.codec.http.HttpUtil.setContentLength;, +import static io.netty.handler.codec.http.HttpUtil.setKeepAlive;, +import static io.netty.handler.codec.http.HttpUtil.setTransferEncodingChunked;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertTrue;, + private final HttpResponseStatus responseStatus;, + { true, HttpVersion.HTTP_1_0, OK, REQUEST_KEEP_ALIVE, SET_RESPONSE_LENGTH, KEEP_ALIVE }, // 0, + { true, HttpVersion.HTTP_1_0, OK, REQUEST_KEEP_ALIVE, SET_MULTIPART, KEEP_ALIVE }, // 1, + { false, HttpVersion.HTTP_1_0, OK,
[+++ b/all/pom.xml, + <id>clean-src</id>, + <phase>clean</phase>, + <goals>, + <goal>clean</goal>, + </goals>, + <configuration>, + <filesets>, + <fileset>, + <directory>${project.basedir}/src</directory>, + <followSymlinks>false</followSymlinks>, + <useDefaultExcludes>false</useDefaultExcludes>, + </fileset>, + <fileset>, + <directory>${project.basedir}/target</directory>, + <followSymlinks>false</followSymlinks>, + </fileset>, + </filesets>, + </configuration>, + </execution>, + <execution>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + private String actualSubprotocol = null;]
[+++ b/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java, + private final AtomicBoolean readInProgress = new AtomicBoolean();, + // prevent ReadPendingException, + if (!readInProgress.compareAndSet(false, true)) {, + return;, + }, +, + // see beginRead, + channel.readInProgress.set(false);, +, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioSocketChannel.java, + private final AtomicBoolean readInProgress = new AtomicBoolean();, + // prevent ReadPendingException, + if (!readInProgress.compareAndSet(false, true)) {, + return;, + }, +, + // see beginRead, + channel.readInProgress.set(false);, +, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + private volatile boolean connected;, +, + connected = true;]
[+++ b/pom.xml, + <version>3.2.0.ALPHA1-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageEncoder.java, + if (sizeMinusOne == 0) {, + ctx.write(out.get(0), promise);, + } else if (sizeMinusOne > 0) {, + // Check if we can use a voidPromise for our extra writes to reduce GC-Pressure, + // See https://github.com/netty/netty/issues/2525, + ChannelPromise voidPromise = ctx.voidPromise();, + boolean isVoidPromise = promise == voidPromise;, + ChannelPromise p;, + if (isVoidPromise) {, + p = voidPromise;, + } else {, + p = ctx.newPromise();, + }, + ctx.write(out.get(i), p);]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerSocketChannelConfig.java, +, + // Use SO_REUSEADDR by default as java.nio does the same., + //, + // See https://github.com/netty/netty/issues/2605, + setReuseAddress(true);]
[+++ b/pom.xml, + <id>alpn-8u31</id>, + <activation>, + <property>, + <name>java.version</name>, + <value>1.8.0_31</value>, + </property>, + </activation>, + <properties>, + <jetty.alpn.version>8.1.3.v20150130</jetty.alpn.version>, + </properties>, + </profile>, + <profile>, + Profiles that assigns proper Jetty npn-boot and alpn-boot version., + See: http://www.eclipse.org/jetty/documentation/current/alpn-chapter.html#alpn-versions, + <id>npn-alpn-7u40</id>, + <id>npn-alpn-7u45</id>, + <id>npn-alpn-7u51</id>, + <id>npn-alpn-7u75</id>, + <activation>, + <property>, + <name>java.version</name>, + <value>1.7.0_75</value>, + </property>, + </activation>, + <properties>, + <jetty.npn.version>1.1.10.v20150130</jetty.npn.version>, + <jetty.alpn.version>7.1.3.v20150130</jetty.alpn.version>, + </properties>, + </profile>, + <profile>, + <id>npn-alpn-7u76</id>, + <activation>, + <property>, + <name>java.version</name>, + <value>1.7.0_76</value>, + </property>, + </activation>, + <properties>, + <jetty.npn.version>1.1.10.v20150130</jetty.npn.version>, + <jetty.alpn.version>7.1.3.v20150130</jetty.alpn.version>, + </properties>, + </profile>, + <profile>, + <jetty.npn.version>1.1.10.v20150130</jetty.npn.version>,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, + @Override, + public boolean isDecodable(Object msg) throws Exception {, + return msg instanceof HttpMessage || msg instanceof HttpChunk;, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, + @Override, + public boolean isDecodable(Object msg) throws Exception {, + return msg instanceof HttpMessage || msg instanceof HttpChunk;, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + public boolean isDecodable(Object msg) throws Exception {, + return msg instanceof HttpMessage || msg instanceof HttpChunk;, + }, +, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, + @Override, + public boolean isDecodable(Object msg) throws Exception {, + return msg instanceof HttpMessage || msg instanceof HttpChunk;, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + public boolean isDecodable(Object
[+++ b/COPYRIGHT.txt, +The Netty Project - Copyright 2009 Red Hat, Inc, and is licensed under the, +Apache License version 2.0 as published by the Apache Software Foundation., +* JBoss is a registered trademark of Red Hat, Inc., +++ b/COPYRIGHT.txt, +The Netty Project - Copyright 2009 Red Hat, Inc, and is licensed under the, +Apache License version 2.0 as published by the Apache Software Foundation., +* JBoss is a registered trademark of Red Hat, Inc., +++ b/LICENSE.txt, + Apache License, + Version 2.0, January 2004, + http://www.apache.org/licenses/, + TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION, + 1. Definitions., +
[+++ b/all/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.4.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java, + new HttpObjectAggregator(-1);]
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteDecoder.java, + callDecode(ctx, in);, + callDecode(ctx, in);, + ByteBuf out = ctx.nextInboundByteBuffer();, + private void callDecode(ChannelHandlerContext ctx, ByteBuf in) {, + ByteBuf out = ctx.nextInboundByteBuffer();, +, + ByteBuf buf = ctx.nextInboundByteBuffer();, + if (out != buf) {, + // user changed handlers in the pipeline need to trigger fireInboundBufferUpdated maybe ?, + if (out.readableBytes() > oldOutSize) {, + ctx.fireInboundBufferUpdated();, + }, + out = ctx.nextInboundByteBuffer();, + oldOutSize = out.readableBytes();, + }, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteDecoder.java, + callDecode(ctx, in);, + callDecode(ctx, in);, + ByteBuf out = ctx.nextInboundByteBuffer();, + private void callDecode(ChannelHandlerContext ctx, ByteBuf in) {, + ByteBuf out = ctx.nextInboundByteBuffer();, +,
[+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteCodec.java, + * This can be thought of as a combination of {@link ByteToByteDecoder} and {@link ByteToByteEncoder}., +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteCodec.java, + * This can be thought of as a combination of {@link ByteToByteDecoder} and {@link ByteToByteEncoder}., +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java, + * This can be thought of as a combination of {@link MessageToMessageDecoder} and {@link MessageToMessageEncoder}.]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2Decoder.java, + // fall through, + // fall through, + // fall through, + // fall through, + // fall through, + // fall through, + // fall through, + // fall through, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2Decoder.java, + // fall through, + // fall through, + // fall through, + // fall through, + // fall through, + // fall through, + // fall through, + // fall through, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2Encoder.java, + // fall through, + // fall through, + // fall through, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2Decoder.java, + // fall through, + // fall through, + // fall through, + // fall
[+++ b/pom.xml, + <conscrypt.version>1.1.3</conscrypt.version>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestDecoder.java, + return new DefaultFullHttpRequest(HttpVersion.HTTP_1_0, HttpMethod.GET, "/bad-request", validateHeaders);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestDecoder.java, + return new DefaultFullHttpRequest(HttpVersion.HTTP_1_0, HttpMethod.GET, "/bad-request", validateHeaders);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseDecoder.java, + return new DefaultFullHttpResponse(HttpVersion.HTTP_1_0, UNKNOWN_STATUS, validateHeaders);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestDecoder.java, + return new DefaultFullHttpRequest(HttpVersion.HTTP_1_0, HttpMethod.GET, "/bad-request", validateHeaders);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseDecoder.java, + return new DefaultFullHttpResponse(HttpVersion.HTTP_1_0, UNKNOWN_STATUS, validateHeaders);, +++ b/codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspRequestDecoder.java, +import io.netty.handler.codec.http.DefaultFullHttpRequest;, + return new DefaultFullHttpRequest(RtspVersions.RTSP_1_0, RtspMethods.OPTIONS, "/bad-request", validateHeaders);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestDecoder.java, + return new DefaultFullHttpRequest(HttpVersion.HTTP_1_0, HttpMethod.GET, "/bad-request", validateHeaders);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseDecoder.java, + return new DefaultFullHttpResponse(HttpVersion.HTTP_1_0, UNKNOWN_STATUS, validateHeaders);, +++ b/codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspRequestDecoder.java, +import io.netty.handler.codec.http.DefaultFullHttpRequest;, + return new DefaultFullHttpRequest(RtspVersions.RTSP_1_0, RtspMethods.OPTIONS, "/bad-request", validateHeaders);, +++ b/codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspResponseDecoder.java, +import io.netty.handler.codec.http.DefaultFullHttpResponse;, + return new DefaultFullHttpResponse(RtspVersions.RTSP_1_0, UNKNOWN_STATUS, validateHeaders);]
[+++ b/handler/pom.xml, +++ b/handler/pom.xml, +++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, +++ b/handler/pom.xml, +++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +++ b/handler/pom.xml, +++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutException.java, +public final class ReadTimeoutException extends TimeoutException {, +++ b/handler/pom.xml, +++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutException.java, +public final class ReadTimeoutException extends TimeoutException {, +++ b/handler/src/main/java/io/netty/handler/timeout/TimeoutException.java, +++ b/handler/pom.xml, +++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutException.java, +public final class ReadTimeoutException extends TimeoutException {, +++ b/handler/src/main/java/io/netty/handler/timeout/TimeoutException.java, +++ b/handler/src/main/java/io/netty/handler/timeout/WriteTimeoutException.java, +public final class WriteTimeoutException extends TimeoutException {]
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java, + return new Bootstrap().group(new NioEventLoopGroup()).channelFactory(new ChannelFactory<Channel>() {, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java, + return new Bootstrap().group(new NioEventLoopGroup()).channelFactory(new ChannelFactory<Channel>() {, +++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtProvider.java, +public final class NioUdtProvider implements ChannelFactory<UdtChannel> {, + public static final ChannelFactory<UdtChannel> BYTE_ACCEPTOR = new NioUdtProvider(, + public static final ChannelFactory<UdtChannel> BYTE_CONNECTOR = new NioUdtProvider(, + public static final ChannelFactory<UdtChannel> BYTE_RENDEZVOUS = new NioUdtProvider(, + public static final ChannelFactory<UdtChannel> MESSAGE_ACCEPTOR = new NioUdtProvider(, + public static final ChannelFactory<UdtChannel> MESSAGE_CONNECTOR = new NioUdtProvider(, + public static final ChannelFactory<UdtChannel> MESSAGE_RENDEZVOUS = new NioUdtProvider(, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java, + return new Bootstrap().group(new NioEventLoopGroup()).channelFactory(new ChannelFactory<Channel>() {, +++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtProvider.java, +public final class NioUdtProvider implements ChannelFactory<UdtChannel> {,
[+++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, + private volatile int readTimeout = 1000;, + if (option == READ_TIMEOUT) {, + return (T) Integer.valueOf(getReadTimeout());, + }, + } else if (option == READ_TIMEOUT) {, + setReadTimeout((Integer) value);, + public RxtxChannelConfig setReadTimeout(int readTimeout) {, + if (readTimeout < 0) {, + throw new IllegalArgumentException("readTime must be >= 0");, + }, + this.readTimeout = readTimeout;, + return this;, + }, +, + @Override, + public int getReadTimeout() {, + return readTimeout;, + }, +, + @Override, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, + private volatile int readTimeout = 1000;, + if (option == READ_TIMEOUT) {, + return (T) Integer.valueOf(getReadTimeout());, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerExpectContinueHandler.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/transport-native-epoll/src/main/c/netty_epoll_linuxsocket.c, +#include <sys/sendfile.h>, +static jfieldID fileChannelFieldId = NULL;, +static jfieldID transferredFieldId = NULL;, +static jfieldID fdFieldId = NULL;, +static jfieldID fileDescriptorFieldId = NULL;, +, +, +static jlong netty_epoll_linuxsocket_sendFile(JNIEnv* env, jclass clazz, jint fd, jobject fileRegion, jlong base_off, jlong off, jlong len) {, + jobject fileChannel = (*env)->GetObjectField(env, fileRegion, fileChannelFieldId);, + if (fileChannel == NULL) {, + netty_unix_errors_throwRuntimeException(env, "failed to get DefaultFileRegion.file");, + return -1;, + }, + jobject fileDescriptor = (*env)->GetObjectField(env, fileChannel, fileDescriptorFieldId);, + if (fileDescriptor == NULL) {, + netty_unix_errors_throwRuntimeException(env, "failed to get FileChannelImpl.fd");, + return -1;, + }, + jint srcFd = (*env)->GetIntField(env, fileDescriptor, fdFieldId);, +
[+++ b/src/docbook/module/architecture.xml, +, +, +, +, +, + Traditional I/O APIs in Java provided different types and methods for, + different transport types. For example,, + <classname>java.net.Socket</classname> and, + <classname>java.net.DatagramSocket</classname> do not have any common, + super type and therefore they have very different ways to perform socket, + I/O., + </para>, + <para>, + This mismatch makes porting a network application from one transport to, + the other. The lack of portability between transports becomes a problem, + when you need to support more transports not rewriting the network layer, + of the application. Logically, many protocols can
[+++ b/pom.xml, + <tcnative.version>1.1.33.Fork16</tcnative.version>]
[+++ b/pom.xml, + <repositories>, + <repository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </repository>, + </repositories>, +, + <pluginRepositories>, + <pluginRepository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </pluginRepository>, + </pluginRepositories>, +, +++ b/pom.xml, + <repositories>, + <repository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </repository>, + </repositories>, +, + <pluginRepositories>, + <pluginRepository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </pluginRepository>, + </pluginRepositories>, +, +++ b/src/main/java/org/jboss/netty/channel/socket/sctp/DefaultNioSctpChannelConfig.java, +/*, + * Copyright 2009 Red Hat, Inc., + *, + * Red Hat licenses this file to you under the Apache License, version 2.0, + * (the "License"); you may not use this file except in compliance with the, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + private final SpdyHeaderBlockDecompressor headerBlockDecompressor =, + SpdyHeaderBlockDecompressor.newInstance();, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + private final SpdyHeaderBlockDecompressor headerBlockDecompressor =, + SpdyHeaderBlockDecompressor.newInstance();, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, + private final SpdyHeaderBlockCompressor headerBlockCompressor;, + headerBlockCompressor = SpdyHeaderBlockCompressor.newInstance(compressionLevel, windowBits, memLevel);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + private final SpdyHeaderBlockDecompressor headerBlockDecompressor =, + SpdyHeaderBlockDecompressor.newInstance();, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, + private final SpdyHeaderBlockCompressor headerBlockCompressor;, + headerBlockCompressor = SpdyHeaderBlockCompressor.newInstance(compressionLevel, windowBits, memLevel);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockCompressor.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + *
[+++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, + protected LocalChannel(LocalServerChannel parent, LocalChannel peer) {, +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, + protected LocalChannel(LocalServerChannel parent, LocalChannel peer) {, +++ b/transport/src/main/java/io/netty/channel/local/LocalServerChannel.java, + final LocalChannel child = newLocalChannel(peer);, + /**, + * A factory method for {@link LocalChannel}s. Users may override it, + * to create custom instances of {@link LocalChannel}s., + */, + protected LocalChannel newLocalChannel(LocalChannel peer) {, + return new LocalChannel(this, peer);, + }, +]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +, + HttpMessage ret = message;, + message = null;, + return ret;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +, + HttpMessage ret = message;, + message = null;, + return ret;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/LastHttpContent.java, +, + @Override, + public String toString() {, + return "EmptyLastHttpContent";, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +, + HttpMessage ret = message;, + message = null;, + return ret;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/LastHttpContent.java, +, + @Override, + public String toString() {, + return "EmptyLastHttpContent";, + }, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseDecoderTest.java, +, + @Test, + public void testGarbageHeaders() {, + // A response without headers - from https://github.com/netty/netty/issues/2103, + byte[] data = ("<html>\r\n"
[+++ b/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverClientSubnetTest.java, + .optResourceEnabled(false), + .ndots(1);, +++ b/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverClientSubnetTest.java, + .optResourceEnabled(false), + .ndots(1);, +++ b/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java, + .optResourceEnabled(false), + .ndots(1);, + .optResourceEnabled(false), + .ndots(1);, + .optResourceEnabled(false), + .ndots(1);, +++ b/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverClientSubnetTest.java, + .optResourceEnabled(false), + .ndots(1);, +++ b/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java, + .optResourceEnabled(false), + .ndots(1);, + .optResourceEnabled(false), + .ndots(1);, + .optResourceEnabled(false), + .ndots(1);, +++ b/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java, + .optResourceEnabled(false), + .ndots(1);]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (minWritableBytes < 0) {, + throw new IllegalArgumentException(String.format(, + "minWritableBytes: %d (expected: >= 0)", minWritableBytes));, + }, +, + throw new IndexOutOfBoundsException(String.format(, + "writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d)",, + writerIndex, minWritableBytes, maxCapacity));, + @Override, + public int ensureWritableBytes(int minWritableBytes, boolean force) {, + if (minWritableBytes < 0) {, + throw new IllegalArgumentException(String.format(, + "minWritableBytes: %d (expected: >= 0)", minWritableBytes));, + }, +, + if (minWritableBytes <= writableBytes()) {, + return 0;, + }, +, + if (minWritableBytes > maxCapacity - writerIndex) {, + if (force) {, + if (capacity() == maxCapacity()) {, + return 1;,
[+++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + int componentId = toComponentIndex(index);, + int i = componentId;, + int componentId = toComponentIndex(index);, +, + int i = componentId;, + int componentId = toComponentIndex(index);, +, + int i = componentId;, + int componentId = toComponentIndex(index);, + int i = componentId;, + int componentId = toComponentIndex(index);, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + int componentId = toComponentIndex(index);, + int i = componentId;, + int componentId = toComponentIndex(index);, +, + int i = componentId;, + int componentId = toComponentIndex(index);, +, + int i = componentId;, + int componentId = toComponentIndex(index);, + int i = componentId;, + int componentId = toComponentIndex(index);, +++
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java, + resetRefCnt();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java, + resetRefCnt();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +import io.netty.util.internal.ReferenceCountUpdater;, + private static final long REFCNT_FIELD_OFFSET =, + ReferenceCountUpdater.getUnsafeOffset(AbstractReferenceCountedByteBuf.class, "refCnt");, + private static final AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> AIF_UPDATER =, + private static final ReferenceCountUpdater<AbstractReferenceCountedByteBuf> updater =, + new ReferenceCountUpdater<AbstractReferenceCountedByteBuf>() {, + @Override, + protected AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> updater() {, + return AIF_UPDATER;, + }, + @Override, + protected long unsafeOffset() {, + return REFCNT_FIELD_OFFSET;, + }, + };, +, + // Value might not equal "real" reference count, all access should be via the updater, + private volatile int refCnt = updater.initialValue();, + return updater.isLiveNonVolatile(this);, + return updater.refCnt(this);, + protected final
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + if (out.last() instanceof LastHttpContent) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + if (out.last() instanceof LastHttpContent) {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java, + assertThat(chunk, is(instanceOf(HttpContent.class)));, + chunk = (HttpContent) ch.readOutbound();, + assertThat(chunk, is(instanceOf(LastHttpContent.class)));, + assertThat(chunk.content().isReadable(), is(false));, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + if (out.last() instanceof LastHttpContent) {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java, + assertThat(chunk, is(instanceOf(HttpContent.class)));, + chunk = (HttpContent) ch.readOutbound();, + assertThat(chunk, is(instanceOf(LastHttpContent.class)));, + assertThat(chunk.content().isReadable(), is(false));, +, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentEncoderTest.java, + chunk = (HttpContent) ch.readOutbound();, + assertThat(chunk.content().isReadable(), is(false));, + assertThat(chunk, is(instanceOf(HttpContent.class)));, + chunk = (HttpContent) ch.readOutbound();, + assertThat(chunk.content().isReadable(), is(false));, +, + HttpContent c = (HttpContent) ch.readOutbound();, + LastHttpContent last = (LastHttpContent) ch.readOutbound();, + assertThat(last.content().readableBytes(), is(0));, + assertThat(chunk, is(instanceOf(HttpContent.class)));, +,
[+++ b/buffer/src/test/java/io/netty/buffer/UnpooledTest.java, + try {, + } finally {, + buf.release();, + }]
[+++ b/handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRule.java, + /**, + * Perform the shift on a long and downcast it to int afterwards., + * This is necessary to handle a cidrPrefix of zero correctly., + * The left shift operator on an int only uses the five least, + * significant bits of the right-hand operand. Thus -1 << 32 evaluates, + * to -1 instead of 0. The left shift operator applied on a long, + * uses the six least significant bits., + *, + * Also see https://github.com/netty/netty/issues/2767, + */, + return (int) ((-1L << 32 - cidrPrefix) & 0xffffffff);,
[+++ b/all/pom.xml, + <artifactId>netty-codec-stomp</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/all/pom.xml, + <artifactId>netty-codec-stomp</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/codec-stomp/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<!--, + ~ Copyright 2014 The Netty Project, + ~, + ~ The Netty Project licenses this file to you under the Apache License,, + ~ version 2.0 (the "License"); you may not use this file except in compliance, + ~ with the License. You may obtain a copy of the License at:, + ~, + ~ http://www.apache.org/licenses/LICENSE-2.0, + ~, + ~
[+++ b/all/pom.xml, + <version>4.1.3.Final</version>, +++ b/all/pom.xml, + <version>4.1.3.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.3.Final</version>, +++ b/all/pom.xml, + <version>4.1.3.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.3.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.3.Final</version>, +++ b/all/pom.xml, + <version>4.1.3.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.3.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.3.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.3.Final</version>, +++ b/all/pom.xml, + <version>4.1.3.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.3.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.3.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.3.Final</version>, +++ b/codec-http/pom.xml, + <version>4.1.3.Final</version>, +++ b/all/pom.xml, + <version>4.1.3.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.3.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.3.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.3.Final</version>, +++ b/codec-http/pom.xml, + <version>4.1.3.Final</version>, +++ b/codec-http2/pom.xml, + <version>4.1.3.Final</version>, +++ b/all/pom.xml, + <version>4.1.3.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.3.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.3.Final</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannelConfig.java, + Class<?> networkChannelClass = null;, + networkChannelClass = Class.forName("java.nio.channels.NetworkChannel", true, classLoader);, + } catch (Throwable ignore) {, + // Not Java 7+, + }, +, + if (networkChannelClass == null) {, + getOption = null;, + setOption = null;, + } else {, + try {, + getOption = networkChannelClass.getDeclaredMethod("getOption", socketOptionType);, + setOption = networkChannelClass.getDeclaredMethod("setOption", socketOptionType, Object.class);, + }, + if (GET_OPTION == null) {, + if (SET_OPTION == null) {]
[+++ b/all/pom.xml, + <version>4.1.19.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.19.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.19.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.19.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.19.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, + <version>4.1.19.Final-SNAPSHOT</version>, +
[+++ b/src/main/java/org/jboss/netty/channel/ChannelLocal.java, +import org.jboss.netty.util.ConcurrentIdentityWeakHashMap;, + private final ConcurrentMap<Channel, T> map =, + new ConcurrentIdentityWeakHashMap<Channel, T>();, +++ b/src/main/java/org/jboss/netty/channel/ChannelLocal.java, +import org.jboss.netty.util.ConcurrentIdentityWeakHashMap;, + private final ConcurrentMap<Channel, T> map =, + new ConcurrentIdentityWeakHashMap<Channel, T>();, +++ b/src/main/java/org/jboss/netty/channel/group/ChannelGroupFactory.java, +import org.jboss.netty.util.ConcurrentHashMap;, +, +++ b/src/main/java/org/jboss/netty/channel/ChannelLocal.java, +import org.jboss.netty.util.ConcurrentIdentityWeakHashMap;, + private final ConcurrentMap<Channel, T> map =, + new ConcurrentIdentityWeakHashMap<Channel, T>();, +++ b/src/main/java/org/jboss/netty/channel/group/ChannelGroupFactory.java, +import org.jboss.netty.util.ConcurrentHashMap;, +, +++ b/src/main/java/org/jboss/netty/channel/group/DefaultChannelGroup.java, +import org.jboss.netty.util.ConcurrentHashMap;, +++ b/src/main/java/org/jboss/netty/channel/ChannelLocal.java, +import org.jboss.netty.util.ConcurrentIdentityWeakHashMap;, + private final ConcurrentMap<Channel, T> map =, + new ConcurrentIdentityWeakHashMap<Channel, T>();, +++ b/src/main/java/org/jboss/netty/channel/group/ChannelGroupFactory.java, +import org.jboss.netty.util.ConcurrentHashMap;, +, +++ b/src/main/java/org/jboss/netty/channel/group/DefaultChannelGroup.java, +import org.jboss.netty.util.ConcurrentHashMap;, +++ b/src/main/java/org/jboss/netty/handler/execution/DefaultObjectSizeEstimator.java, +import org.jboss.netty.util.ConcurrentHashMap;, +++ b/src/main/java/org/jboss/netty/channel/ChannelLocal.java, +import org.jboss.netty.util.ConcurrentIdentityWeakHashMap;, + private final ConcurrentMap<Channel, T> map =, +
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, + , + , + // Check if we exceeded the maximum size of 2gb if this is the case then , + // newCapacity == 0, + //, + // https://github.com/netty/netty/issues/258, + if (newCapacity == 0) {, + throw new IllegalStateException("Maximum size of 2gb exceeded");, + }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + final int length = bytes.length();, + final int remainingBytes = length & 7;, + if (length >= 32) {, + for (int i = length - 8; i >= remainingBytes; i -= 8) {, + } else if (length >= 8) {, + hash = hashCodeAsciiCompute(bytes, length - 8, hash);, + if (length >= 16) {, + hash = hashCodeAsciiCompute(bytes, length - 16, hash);, + if (length >= 24) {, + hash = hashCodeAsciiCompute(bytes, length - 24, hash);, + }, + }, + if (remainingBytes == 0) {, + int offset = 0;, + if (remainingBytes
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerUpgradeHandler.java, + // After writing the upgrade response we immediately prepare the, + // pipeline for the next protocol to avoid a race between completion, + // of the write future and receiving data before the pipeline is, + // restructured., + final ChannelFuture writeComplete = ctx.writeAndFlush(upgradeResponse);, + upgradeCodec.upgradeTo(ctx, request);, +, + // Remove this handler from the pipeline., + ctx.pipeline().remove(HttpServerUpgradeHandler.this);, + // Add the listener last to avoid firing upgrade logic after, + // the channel is already closed since the listener may fire, + // immediately if the write failed eagerly., + writeComplete.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerUpgradeHandler.java, +
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + ((ChannelInboundHandler<Object>) ctx.handler).channelRegistered(ctx);, + ((ChannelInboundHandler<Object>) ctx.handler).channelUnregistered(ctx);, + ((ChannelInboundHandler<Object>) ctx.handler).channelActive(ctx);, + ((ChannelInboundHandler<Object>) ctx.handler).channelInactive(ctx);, + ((ChannelInboundHandler<Object>) ctx.handler).inboundBufferUpdated(ctx);, + if (inByteBridge != null) {, + ChannelBuffer buf = ctx.in.byteBuffer();, + if (!buf.readable()) {, + buf.discardReadBytes();, + }, + boolean canHandleInbound = handler instanceof ChannelInboundHandler;, + boolean canHandleOutbound = handler instanceof ChannelOutboundHandler;, + return in != null;, + return out != null;, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + ((ChannelInboundHandler<Object>) ctx.handler).channelRegistered(ctx);, + ((ChannelInboundHandler<Object>) ctx.handler).channelUnregistered(ctx);, + ((ChannelInboundHandler<Object>) ctx.handler).channelActive(ctx);, + ((ChannelInboundHandler<Object>) ctx.handler).channelInactive(ctx);, + ((ChannelInboundHandler<Object>) ctx.handler).inboundBufferUpdated(ctx);, + if (inByteBridge != null) {, + ChannelBuffer buf = ctx.in.byteBuffer();, + if (!buf.readable()) {, + buf.discardReadBytes();, + }, + boolean canHandleInbound
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + protected boolean readPending;, + public void beginRead() {, + // Channel.read() or ChannelHandlerContext.read() was called, + readPending = true;, + super.beginRead();, + }, +, + @Override, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + protected boolean readPending;, + public void beginRead() {, + // Channel.read() or ChannelHandlerContext.read() was called, + readPending = true;, + super.beginRead();, + }, +, + @Override, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerSocketChannel.java, +, + try {, + readPending = false;, + } finally {, + // Check if there is a readPending which was not processed yet., + // This could be for two reasons:, + // * The user called
[+++ b/codec/src/main/java/io/netty/handler/codec/xml/XmlFrameDecoder.java, + // found </, we must check if it is enclosed, + int peekFurtherAheadIndex = i + 2;, + while (peekFurtherAheadIndex <= bufferLength - 1) {, + //if we have </ and enclosing > we can decrement openBracketsCount, + if (in.getByte(peekFurtherAheadIndex) == '>') {, + break;, + }, + peekFurtherAheadIndex++;, + }, + int xmlElementLength = length - readerIndex;, + if (openBracketsCount == 0 && xmlElementLength > 0) {, + if (readerIndex + xmlElementLength >= bufferLength) {, + xmlElementLength = in.readableBytes();, + extractFrame(in, readerIndex + leadingWhiteSpaceCount, xmlElementLength - leadingWhiteSpaceCount);, + in.skipBytes(xmlElementLength);, +++ b/codec/src/main/java/io/netty/handler/codec/xml/XmlFrameDecoder.java, + // found </,
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioChannel.java, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioChannel.java, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + return Channels.write(this, message, remoteAddress);, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioChannel.java, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + return Channels.write(this, message, remoteAddress);, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java, +import io.netty.channel.ChannelFuture;, +import java.net.SocketAddress;, + , +, + @Override, + public ChannelFuture write(Object message, SocketAddress remoteAddress) {, + if (remoteAddress == null || remoteAddress.equals(getRemoteAddress())) {, + return super.write(message, null);, + } else {, + return getUnsupportedOperationFuture();, + }, + }, + ]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java, + * The size threshold for gathering writes. Non-Masked messages bigger than this size will be be sent fragmented as]
[+++ b/NOTICE.txt, +This product contains a modified version of Robert Harder's Public Domain, +Base64 Encoder and Decoder, which can be obtained at:]
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + ByteBuf slice = c.slice;, + if (slice != null) {, + // We must replace the cached slice with a derived one to ensure that, + // it can later be released properly in the case of PooledSlicedByteBuf., + c.slice = slice.slice(0, c.length());, + }, + int trimmedBytes = readerIndex - c.offset;, + ByteBuf slice = c.slice;, + if (slice != null) {, + // We must replace the cached slice with a derived one to ensure that, + // it can later be released properly in the case of PooledSlicedByteBuf., + c.slice = slice.slice(trimmedBytes, c.length());,
[+++ b/src/docbook/module/start.xml, + &ChannelHandler;. &SimpleChannelHandler; provides various event, + handler methods that you can override. For now, it's just enough, + to extend &SimpleChannelHandler; rather than to implement, + the handler interfaces by yourself.]
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/StreamBufferingEncoderTest.java, +import static io.netty.buffer.Unpooled.EMPTY_BUFFER;, +import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_MAX_FRAME_SIZE;, +import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_PRIORITY_WEIGHT;, +import static io.netty.handler.codec.http2.Http2CodecUtil.SMALLEST_MAX_CONCURRENT_STREAMS;, +import static io.netty.handler.codec.http2.Http2Error.CANCEL;, +import static io.netty.handler.codec.http2.Http2Stream.State.HALF_CLOSED_LOCAL;, +import static org.junit.Assert.assertEquals;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyBoolean;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.anyLong;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.never;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, +import io.netty.util.ReferenceCountUtil;, +import io.netty.util.ReferenceCounted;, +import org.junit.After;, + when(writer.writeData(eq(ctx), anyInt(), any(ByteBuf.class), anyInt(), anyBoolean(),, + eq(promise))).thenAnswer(successAnswer());, + when(ctx.newPromise()).thenReturn(promise);, + @After, + public void teardown() {, + // Close and release any buffered frames., + encoder.close();, + }, +, + encoder.writeData(ctx, 3, EMPTY_BUFFER, 0, false, promise);, + encoder.writeData(ctx,
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractInboundHttp2ToHttpAdapterBuilder.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the, + * "License"); you may not use this file except in compliance with the License. You may obtain a, + * copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express, + *
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + zerooutAndRelease(encodedBuf);, + zerooutAndRelease(wrappedBuf);, + // Zero out the buffer and so the private key it held., + zerooutAndRelease(buffer);, + private static void zerooutAndRelease(ByteBuf buffer) {, + buffer.setZero(0, buffer.capacity());, + buffer.release();, + }, +]
[+++ b/all/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/codec-memcache/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta3-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServer.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/NioSctpChannelConfig.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServer.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/NioSctpChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannel.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServer.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/NioSctpChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannel.java, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketClientBootstrapTest.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServer.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/NioSctpChannelConfig.java, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannel.java, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketClientBootstrapTest.java, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/sctp/SctpMultiStreamingEchoTest.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServer.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServer.java, +++
[+++ b/all/pom.xml, +++ b/all/pom.xml, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, +++ b/all/pom.xml, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, +++ b/pom.xml, + <artifactId>maven-clean-plugin</artifactId>, + <version>2.5</version>, + </plugin>, + <plugin>, + <artifactId>maven-resources-plugin</artifactId>, + <version>2.5</version>, + </plugin>, + <plugin>, + <artifactId>maven-jar-plugin</artifactId>, + <version>2.4</version>, + </plugin>, + <plugin>, + <artifactId>maven-dependency-plugin</artifactId>, + <version>2.4</version>, + </plugin>, + <plugin>, + <artifactId>maven-assembly-plugin</artifactId>, + <version>2.3</version>, + </plugin>, + <plugin>, + <artifactId>maven-jxr-plugin</artifactId>, + <version>2.2</version>, + </plugin>, + <plugin>, + <groupId>org.codehaus.mojo</groupId>, + <artifactId>build-helper-maven-plugin</artifactId>, + <version>1.7</version>, + </plugin>, +, + <!-- Workaround for the 'M2E plugin execution not covered' problem., + See: http://wiki.eclipse.org/M2E_plugin_execution_not_covered -->, + <plugin>, +++ b/all/pom.xml, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, +++ b/pom.xml, + <artifactId>maven-clean-plugin</artifactId>, + <version>2.5</version>, + </plugin>, +
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, + buffer.writeBytes(releaseLater(copiedBuffer("Hello, World!", CharsetUtil.ISO_8859_1)));, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, + buffer.writeBytes(releaseLater(copiedBuffer("Hello, World!", CharsetUtil.ISO_8859_1)));, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + CompositeByteBuf buf = releaseLater((CompositeByteBuf) wrappedBuffer(new byte[]{1, 2, 3, 4, 5},, + new byte[]{4, 5, 6, 7, 8, 9, 26}));, + CompositeByteBuf buf = releaseLater(compositeBuffer(2));, + CompositeByteBuf buf = releaseLater(compositeBuffer(3));, + ByteBuf header = releaseLater(buffer(12)).order(order);, + ByteBuf payload = releaseLater(buffer(512)).order(order);, + ByteBuf buffer = releaseLater(wrappedBuffer(header, payload));, + a = releaseLater(wrappedBuffer(new byte[] { 1 })).order(order);, + b = releaseLater(wrappedBuffer(wrappedBuffer(new byte[] { 1 }, new byte[1])).order(order));, + b.writeBytes(releaseLater(wrappedBuffer(new byte[] { 2 })).order(order));, + a = releaseLater(wrappedBuffer(new byte[] { 1, 2, 3 })).order(order);, + b = releaseLater(wrappedBuffer(releaseLater(wrappedBuffer(new byte[]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpVersion.java, + throw new IllegalArgumentException("text is empty (possibly HTTP/0.9)");]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + private boolean closeInitiated;, + public void close(final ChannelPromise promise) {, + if (closeInitiated) {, + // Closed already., + promise.setSuccess();, + } else if (!(promise instanceof VoidChannelPromise)) { // Only needed if no VoidChannelPromise., + // This means close() was called before so we just register a listener and return, + closePromise.addListener(new ChannelFutureListener() {, + @Override, + public void operationComplete(ChannelFuture future) throws Exception {, + promise.setSuccess();, + }, + });, + }, + closeInitiated = true;, +, + promise.setSuccess();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + private boolean closeInitiated;, + public void close(final ChannelPromise promise) {, + if (closeInitiated) {,
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +import io.netty.handler.codec.dns.DnsRecord;, + * Sends a DNS query with the specified question with additional records., + */, + public Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> query(, + DnsQuestion question, Iterable<DnsRecord> additional) {, + return query(nextNameServerAddress(), question, additional);, + }, +, + /**, + return query(nextNameServerAddress(), question, Collections.<DnsRecord>emptyList(), promise);, + return query0(nameServerAddr, question, Collections.<DnsRecord>emptyList(),, + ch.eventLoop().<AddressedEnvelope<? extends DnsResponse, InetSocketAddress>>newPromise());, + }, +, + /**, + * Sends a DNS query with the specified question with additional records using the specified name server list., + */, + public Future<AddressedEnvelope<DnsResponse, InetSocketAddress>> query(, + InetSocketAddress nameServerAddr, DnsQuestion question, Iterable<DnsRecord> additional) {, +, + return query0(nameServerAddr,
[+++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(SystemPropertyUtil.class);, + logger.warn("Unable to retrieve a system property '{}'; default values will be used.", key, e);, + logger.warn(, + "Unable to parse the boolean system property '{}':{} - using the default value: {}",, + key, value, def, + );, + logger.warn(, + "Unable to parse the integer system property '{}':{} - using the default value: {}",, + key, value, def, + );, + logger.warn(, + "Unable to parse the long integer system property '{}':{} - using the default value: {}",, + key, value, def, + );]
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + } catch (NoSuchMethodException e) {, + logger.debug("sun.misc.Unsafe.copyMemory: unavailable");, + throw e;]
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +import java.net.ConnectException;, +import java.util.concurrent.ScheduledFuture;, +import java.util.concurrent.TimeUnit;, + private final ChannelFuture voidFuture = new VoidChannelFuture(AbstractChannel.this);, + private ScheduledFuture<?> connectTimeoutFuture;, + private ConnectException connectTimeoutException;, +, +, + // Schedule connect timeout., + int connectTimeoutMillis = config().getConnectTimeoutMillis();, + if (connectTimeoutMillis > 0) {, + connectTimeoutFuture = eventLoop().schedule(new Runnable() {, + @Override, + public void run() {, + if (connectTimeoutException == null) {, + connectTimeoutException = new ConnectException("connection timed out");, + }, + ChannelFuture connectFuture = AbstractChannel.this.connectFuture;, + if (connectFuture == null) {, + return;, + } else {, + if (connectFuture.setFailure(connectTimeoutException)) {, + pipeline().fireExceptionCaught(connectTimeoutException);, + close(voidFuture());, + }, + },
[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorChooserFactory.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/pom.xml, + <version>15</version>]
[+++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + ssc.bind(new InetSocketAddress(port), ssc.newFuture()).awaitUninterruptibly().rethrowIfFailed();, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + ssc.bind(new InetSocketAddress(port), ssc.newFuture()).awaitUninterruptibly().rethrowIfFailed();, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +import java.io.IOException;, + boolean closed = false;, + closed = true;, + if (closed) {, + close(newFuture());, + if (t instanceof IOException) {, + close(newFuture());, + }, + close(newVoidFuture());, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + ssc.bind(new InetSocketAddress(port), ssc.newFuture()).awaitUninterruptibly().rethrowIfFailed();, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +import java.io.IOException;, + boolean closed = false;, + closed = true;, + if (closed) {, + close(newFuture());, + if (t instanceof IOException) {, + close(newFuture());, + }, + close(newVoidFuture());, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelFuture.java, + throw new IllegalStateException("not done yet");, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + ssc.bind(new InetSocketAddress(port), ssc.newFuture()).awaitUninterruptibly().rethrowIfFailed();, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +import java.io.IOException;, +
[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java, + validateScheduled(delay, unit);, +, + validateScheduled(delay, unit);, +, + validateScheduled(initialDelay, unit);, + validateScheduled(period, unit);, + validateScheduled(initialDelay, unit);, + validateScheduled(delay, unit);, +, + /**, + * Sub-classes may override this to restrict the maximal amount of time someone can use to schedule a task., + */, + protected void validateScheduled(long amount, TimeUnit unit) {, + // NOOP, + }, +, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java, + validateScheduled(delay, unit);, +, + validateScheduled(delay, unit);, +, + validateScheduled(initialDelay, unit);, + validateScheduled(period, unit);, + validateScheduled(initialDelay, unit);, + validateScheduled(delay, unit);, +, + /**, + * Sub-classes may override this to restrict the maximal amount of time
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + private final int bufferMaxCapacity;, + protected AbstractByteBufAllocator(int bufferMaxCapacity) {, + this(bufferMaxCapacity, false);, + protected AbstractByteBufAllocator(int bufferMaxCapacity, boolean directByDefault) {, + if (bufferMaxCapacity <= 0) {, + throw new IllegalArgumentException("bufferMaxCapacity: " + bufferMaxCapacity + " (expected: 1+)");, + }, + this.bufferMaxCapacity = bufferMaxCapacity;, + public int bufferMaxCapacity() {, + return bufferMaxCapacity;, + }, +, + @Override, + return heapBuffer(256, bufferMaxCapacity());, + return heapBuffer(initialCapacity, bufferMaxCapacity());, + validate(initialCapacity, maxCapacity);, + return directBuffer(256, bufferMaxCapacity());, + return directBuffer(initialCapacity, bufferMaxCapacity());, + validate(initialCapacity, maxCapacity);, + @Override, + public CompositeByteBuf compositeBuffer() {, + if (directByDefault) {, + return compositeDirectBuffer();, + }, + return compositeHeapBuffer();,
[+++ b/common/src/main/java/io/netty/util/ConstantPool.java, +, + @Deprecated, + public final int nextId() {, + synchronized (constants) {, + int id = nextId;, + nextId++;, + return id;, + }, + }, +++ b/common/src/main/java/io/netty/util/ConstantPool.java, +, + @Deprecated, + public final int nextId() {, + synchronized (constants) {, + int id = nextId;, + nextId++;, + return id;, + }, + }, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelOption.java, +public final class EpollChannelOption<T> extends ChannelOption<T> {, + @SuppressWarnings("rawtypes"), +, + @SuppressWarnings({ "unused", "deprecation" }), + private EpollChannelOption() {, + super(null);, + }, +++ b/common/src/main/java/io/netty/util/ConstantPool.java, +, + @Deprecated, + public final int nextId() {, + synchronized (constants) {, +
[+++ b/common/src/main/java/io/netty/util/AsciiString.java, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, + * {@link ByteBuffer}. It is often used in conjunction with {@link Headers} that require a {@link CharSequence}., + /**, + * {@inheritDoc}, + * <p>, + * Provides a case-insensitive hash code for Ascii like byte strings., + */, + if (hash == 0) {, + hash = PlatformDependent.hashCodeAscii(value, offset, length);, + return length() == other.length() &&, + hashCode() == other.hashCode() &&, + PlatformDependent.equals(array(), arrayOffset(), other.array(), other.arrayOffset(), length());, + return AsciiString.hashCode(o);, +, + * {@link CharSequence}s into the same headers., + return PlatformDependent.hashCodeAscii(value);, +++ b/common/src/main/java/io/netty/util/AsciiString.java, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, + * {@link ByteBuffer}. It
[+++ b/common/src/main/java/io/netty/util/internal/ObjectUtil.java, +, + /**, + * Resolves a possibly null Integer to a primitive int, using a default value., + * @param wrapper the wrapper, + * @param defaultValue the default value, + * @return the primitive value, + */, + public static int intValue(Integer wrapper, int defaultValue) {, + return wrapper != null ? wrapper.intValue() : defaultValue;, + }, +, + /**, + * Resolves a possibly null Long to a primitive long, using a default value., + * @param wrapper the wrapper, + * @param defaultValue the default value, + * @return the primitive value, +
[+++ b/.travis.yml, +language: java, +jdk:, + - oraclejdk7, + - openjdk7, +]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/CharSequenceMap.java, +import io.netty.util.internal.UnstableApi;, +/**, + * Internal use only!, + */, +@UnstableApi, +public final class CharSequenceMap<V> extends DefaultHeaders<CharSequence, V, CharSequenceMap<V>> {, +, + @SuppressWarnings("unchecked"), + public CharSequenceMap(boolean caseSensitive, ValueConverter<V> valueConverter, int arraySizeHint) {, + super(caseSensitive ? CASE_SENSITIVE_HASHER : CASE_INSENSITIVE_HASHER, valueConverter,, + NameValidator.NOT_NULL, arraySizeHint);, + }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/CharSequenceMap.java, +import io.netty.util.internal.UnstableApi;, +/**, + * Internal use only!, + */, +@UnstableApi, +public final class CharSequenceMap<V> extends DefaultHeaders<CharSequence, V, CharSequenceMap<V>> {, +, + @SuppressWarnings("unchecked"), + public CharSequenceMap(boolean caseSensitive, ValueConverter<V> valueConverter, int arraySizeHint) {, + super(caseSensitive ? CASE_SENSITIVE_HASHER : CASE_INSENSITIVE_HASHER, valueConverter,, + NameValidator.NOT_NULL, arraySizeHint);, + }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java, + this(DEFAULT_MAX_HEADER_SIZE, DEFAULT_HEADER_TABLE_SIZE, validateHeaders, 32);,
[+++ b/all/pom.xml, + <version>4.1.28.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.28.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.28.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.28.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.28.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, + <version>4.1.28.Final-SNAPSHOT</version>, +
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null]
[+++ b/pom.xml, + <version>1.1.30.Fork2</version>]
[+++ b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java, + public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {, + ctx.fireInboundBufferUpdated();, + }, +, + @Override, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java, + public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {, + ctx.fireInboundBufferUpdated();, + }, +, + @Override, +++ b/handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java, + ctx.flush(promise);, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java, + public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {, + ctx.fireInboundBufferUpdated();, + }, +, + @Override, +++ b/handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java, + ctx.flush(promise);, +++ b/transport/src/main/java/io/netty/channel/ChannelDuplexHandler.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java, + public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {, + ctx.fireInboundBufferUpdated();, + }, +, + @Override, +++ b/handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java, + ctx.flush(promise);, +++ b/transport/src/main/java/io/netty/channel/ChannelDuplexHandler.java, +++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, +, + @Override, + public void inboundBufferUpdated(ChannelHandlerContext ctx) throws Exception {, + ctx.fireInboundBufferUpdated();,
[+++ b/all/pom.xml, + -group "Miscellaneous" io.netty.util*, +++ b/all/pom.xml, + -group "Miscellaneous" io.netty.util*, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +import io.netty.util.internal.InternalLogger;, +import io.netty.util.internal.InternalLoggerFactory;, +++ b/all/pom.xml, + -group "Miscellaneous" io.netty.util*, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +import io.netty.util.internal.InternalLogger;, +import io.netty.util.internal.InternalLoggerFactory;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java, +import io.netty.util.internal.InternalLogger;, +import io.netty.util.internal.InternalLoggerFactory;, +++ b/all/pom.xml, + -group "Miscellaneous" io.netty.util*, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +import io.netty.util.internal.InternalLogger;, +import io.netty.util.internal.InternalLoggerFactory;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java, +import io.netty.util.internal.InternalLogger;, +import io.netty.util.internal.InternalLoggerFactory;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java, +import io.netty.util.internal.InternalLogger;, +import io.netty.util.internal.InternalLoggerFactory;, +++ b/all/pom.xml, + -group "Miscellaneous" io.netty.util*, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +import io.netty.util.internal.InternalLogger;, +import io.netty.util.internal.InternalLoggerFactory;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java, +import io.netty.util.internal.InternalLogger;, +import io.netty.util.internal.InternalLoggerFactory;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java, +import io.netty.util.internal.InternalLogger;, +import io.netty.util.internal.InternalLoggerFactory;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, +import io.netty.util.internal.InternalLogger;, +import io.netty.util.internal.InternalLoggerFactory;, +++ b/all/pom.xml, + -group "Miscellaneous" io.netty.util*, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +import
[+++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + return result + ", components=" + components.size() + ')';, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + return result + ", components=" + components.size() + ')';, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, + return key + '=' + value;, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + return result + ", components=" + components.size() + ')';, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, + return key + '=' + value;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + String newUri = rawPath + '?' + uri.getRawQuery();, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + return result + ", components=" + components.size() + ')';, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, + return key + '=' + value;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + String newUri = rawPath + '?' + uri.getRawQuery();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java,
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, + Entry entry = buffer[i];, + int count = entry.count;, + if (count == -1) {, + entry.count = count = buf.nioBufferCount();, + }, + if (count == 1) {, + ByteBuffer nioBuf = entry.buf;, + if (nioBuf == null) {, + // cache ByteBuffer as it may need to create a new ByteBuffer instance if its a, + // derived buffer, + entry.buf = nioBuf = buf.internalNioBuffer(readerIndex, readableBytes);, + }, + nioBuffers[nioBufferCount ++] = nioBuf;, + ByteBuffer[] nioBufs = entry.buffers;, + if (nioBufs == null) {, + // cached ByteBuffers as they
[+++ b/pom.xml]
[+++ b/common/src/main/java/io/netty/util/AbstractConstant.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/pom.xml, + <Main-Class>${project.groupId}.util.Version</Main-Class>]
[+++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, + public static final ChannelOption<MessageSizeEstimator> MESSAGE_SIZE_ESTIMATOR =, + new ChannelOption<MessageSizeEstimator>("MESSAGE_SIZE_ESTIMATOR");, +++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, + public static final ChannelOption<MessageSizeEstimator> MESSAGE_SIZE_ESTIMATOR =, + new ChannelOption<MessageSizeEstimator>("MESSAGE_SIZE_ESTIMATOR");, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java, + WRITE_BUFFER_LOW_WATER_MARK, MESSAGE_SIZE_ESTIMATOR);, + if (option == MESSAGE_SIZE_ESTIMATOR) {, + return (T) getMessageSizeEstimator();, + }, + } else if (option == MESSAGE_SIZE_ESTIMATOR) {, + setMessageSizeEstimator((MessageSizeEstimator) value);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java, + ctx.writeAndFlush(spdyRstStreamFrame);, + return;, + ctx.writeAndFlush(spdyRstStreamFrame);, + return;, + ctx.writeAndFlush(spdyRstStreamFrame);, + return;, + ctx.writeAndFlush(spdyRstStreamFrame);, + ctx.writeAndFlush(spdySynReplyFrame);, + return;, + ctx.writeAndFlush(spdySynReplyFrame);, + ctx.writeAndFlush(spdyRstStreamFrame);, + return;, + ctx.writeAndFlush(spdyRstStreamFrame);]
[+++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/package-info.java, + * <p>04. Install AutoBahn: <tt>sudo easy_install Autobahn</tt>. If you already have Autobahn installed, you may need, + * to upgrade it: <tt>sudo easy_install --upgrade Autobahn</tt>. Make suer v0.4.10 is installed., + * <p>05. Get AutoBahn testsuite source code: <tt>git clone git@github.com:tavendo/AutobahnPython.git</tt>, + * <p>06. Go to AutoBahn directory: <tt>cd AutobahnPython</tt>, + * <p>07. Checkout stable version: <tt>git checkout v0.4.10</tt>, + * <p>10. Run our <tt>AutobahnServer</tt> located in this package. If you are in Eclipse IDE, right click on , + * <tt>AutobahnServer.java</tt> and select Run As > Java Application., + * <p>11. Run the Autobahn test
[+++ b/example/pom.xml, + <dependency>, + <groupId>com.jcraft</groupId>, + <artifactId>jzlib</artifactId>, + </dependency>, +++ b/example/pom.xml, + <dependency>, + <groupId>com.jcraft</groupId>, + <artifactId>jzlib</artifactId>, + </dependency>, +++ b/pom.xml]
[+++ b/pom.xml, + <version>1.1.0</version>, + <version>1.1.0</version>, + <stylesheetResource>classpath:/xslt/org/jboss/xhtml.xsl</stylesheetResource>, + <stylesheetResource>classpath:/xslt/org/jboss/xhtml-single.xsl</stylesheetResource>, +++ b/pom.xml, + <version>1.1.0</version>, + <version>1.1.0</version>, + <stylesheetResource>classpath:/xslt/org/jboss/xhtml.xsl</stylesheetResource>, + <stylesheetResource>classpath:/xslt/org/jboss/xhtml-single.xsl</stylesheetResource>, +++ b/src/docbook/module/start.xml, + <para>, + This chapter tours around the core constructs of Netty with simple, + examples to let you get started with Netty easily. You should be able to, + write a network application on top of Netty right away when you are at the, + end of this chapter., + </para>, + <para>, + If you prefer the top-down approach in learning something, you might want, + to start from <xref linkend="architecture"/> and get back here.,
[+++ b/.gitignore, +.DS_Store, +, +++ b/.gitignore, +.DS_Store, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + if (!buf.isReadable()) {, + continue;, + }, +++ b/.gitignore, +.DS_Store, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + if (!buf.isReadable()) {, + continue;, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, +import static io.netty.handler.codec.http.HttpConstants.*;, +, +++ b/.gitignore, +.DS_Store, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + if (!buf.isReadable()) {, + continue;, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, +import static io.netty.handler.codec.http.HttpConstants.*;, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +import io.netty.buffer.Unpooled;, + ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);, +++ b/.gitignore, +.DS_Store, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + if (!buf.isReadable()) {, + continue;, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, +import static io.netty.handler.codec.http.HttpConstants.*;, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +import io.netty.buffer.Unpooled;, + ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + channel.writeAndFlush(request).addListener(new ChannelFutureListener() {, + return channel.writeAndFlush(frame,
[+++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java, +import io.netty.channel.ChannelId;, + * Create a new instance with an {@link EmbeddedChannelId} and an empty pipeline., + * Create a new instance with the specified ID and an empty pipeline., + *, + * @param channelId the {@link ChannelId} that will be used to identify this channel, + */, + public EmbeddedChannel(ChannelId channelId) {, + this(channelId, EMPTY_HANDLERS);, + }, +, + /**, + * @param handlers the {@link ChannelHandler}s which will be add in the {@link ChannelPipeline}, + this(EmbeddedChannelId.INSTANCE, handlers);, + }, +, + /**, + * Create a new instance with the channel ID set to
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpResponse.java, + buf.append("(decodeResult: ");]
[+++ b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheDecoderTest.java, +import io.netty.util.ReferenceCounted;, +import org.junit.After;, + @After, + public void teardown() throws Exception {, + channel.finish();, + }, +, + request.release();, +, +, + content1.release();, + content2.release();, + request.release();, +, + Object lastContent = channel.readInbound();, + assertThat(lastContent, instanceOf(LastMemcacheContent.class));, + ((ReferenceCounted) lastContent).release();, + request.release();, +, + lastContent = channel.readInbound();, + assertThat(lastContent, instanceOf(LastMemcacheContent.class));, + ((ReferenceCounted) lastContent).release();, + response.release();, + content.release();, + response.release();, + content.release();, + content.release();, + response.release();, + content.release();]
[+++ b/common/src/main/java/io/netty/util/internal/ConcurrentSet.java, +/**, + * @deprecated For removal in Netty 4.2. Please use {@link ConcurrentHashMap#newKeySet()} instead, + */, +@Deprecated]
[+++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +import io.netty.util.internal.EmptyArrays;, + return EmptyArrays.EMPTY_BYTE_BUFFERS;, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +import io.netty.util.internal.EmptyArrays;, + return EmptyArrays.EMPTY_BYTE_BUFFERS;, +++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, +import io.netty.util.internal.EmptyArrays;, + return EmptyArrays.EMPTY_BYTES;, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +import io.netty.util.internal.EmptyArrays;, + return EmptyArrays.EMPTY_BYTE_BUFFERS;, +++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, +import io.netty.util.internal.EmptyArrays;, + return EmptyArrays.EMPTY_BYTES;, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +import static io.netty.util.internal.EmptyArrays.*;, + buffer.getBytes(-1, EMPTY_BYTES);, + buffer.getBytes(-1, EMPTY_BYTES, 0, 0);, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +import io.netty.util.internal.EmptyArrays;, + return EmptyArrays.EMPTY_BYTE_BUFFERS;, +++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, +import io.netty.util.internal.EmptyArrays;, + return EmptyArrays.EMPTY_BYTES;, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +import static io.netty.util.internal.EmptyArrays.*;, + buffer.getBytes(-1, EMPTY_BYTES);, + buffer.getBytes(-1, EMPTY_BYTES, 0, 0);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, +import static io.netty.util.internal.EmptyArrays.*;, + b.readBytes(EMPTY_BYTES);, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +import io.netty.util.internal.EmptyArrays;, + return EmptyArrays.EMPTY_BYTE_BUFFERS;, +++ b/buffer/src/main/java/io/netty/buffer/EmptyByteBuf.java, +import io.netty.util.internal.EmptyArrays;, + return EmptyArrays.EMPTY_BYTES;, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +import
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollChannelOption.java, + public static final ChannelOption<Integer> TCP_KEEPIDLE = ChannelOption.valueOf(T, "TCP_KEEPIDLE");, + public static final ChannelOption<Integer> TCP_KEEPINTVL = ChannelOption.valueOf(T, "TCP_KEEPINTVL");, + public static final ChannelOption<Integer> TCP_KEEPCNT = ChannelOption.valueOf(T, "TCP_KEEPCNT");]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return forEachByteAsc0(readerIndex, writerIndex, processor);, + public int forEachByte(int fromIndex, int toIndex, ByteBufProcessor processor) {, + if (fromIndex < toIndex) {, + return forEachByteAsc(fromIndex, toIndex, processor);, + } else if (fromIndex > toIndex) {, + return forEachByteDesc(fromIndex, toIndex, processor);, + } else {, + checkIndex(fromIndex);, + return -1;, + }, + private int forEachByteAsc(int fromIndex, int toIndex, ByteBufProcessor processor) {, + if (fromIndex < 0 || toIndex > capacity()) {, + throw new IndexOutOfBoundsException(String.format(, + "fromIndex: %d, toIndex: %d (expected: 0 <= fromIndex < toIndex <= capacity(%d))",, + fromIndex, toIndex, capacity()));, + }, + return forEachByteAsc0(fromIndex, toIndex,
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (fieldLength < 0) {, + throw new IllegalArgumentException("length: " + fieldLength + " (expected: >= 0)");, + }, + if (index < 0 || index > capacity() - fieldLength) {]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelId.java, + boolean replace = false;, + // Found a better MAC address., + replace = true;, + // Two MAC addresses are of pretty much same quality., + res = compareAddresses(bestInetAddr, inetAddr);, + if (res < 0) {, + // Found a MAC address with better INET address., + replace = true;, + } else if (res == 0) {, + // Cannot tell the difference. Choose the longer one., + if (bestMacAddr.length < macAddr.length) {, + replace = true;, + }, + }, + }, +, + if (replace) {, + // Prefer globally unique address.,
[+++ b/pom.xml, + <version>12</version>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + if (HttpHeaderValues.IDENTITY.contentEquals(targetContentEncoding)) {]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, +public class SpdyFrameEncoder extends MessageToByteEncoder<Object> {]
[+++ b/transport-udt/pom.xml]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeaders.java, +import java.util.Iterator;, +import java.util.NoSuchElementException;, +import java.util.Map.Entry;, + public Iterator<Map.Entry<String, String>> iterator() {, + return new HeaderIterator();, + }, +, + @Override, + return head == head.after;, + private final class HeaderIterator implements Iterator<Map.Entry<String, String>> {, +, + private HeaderEntry current = head;, +, + @Override, + public boolean hasNext() {, + return current.after != head;, + }, +, + @Override, + public Entry<String, String> next() {, + current = current.after;, +, + if (current == head) {, + throw new NoSuchElementException();, + }, +, + return current;, + }, +, + @Override, + public void remove() {,
[+++ b/all/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/codec-memcache/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta4-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/transport-native-epoll/pom.xml, + <Bundle-NativeCode>META-INF/native/libnetty-transport-native-epoll.so; osname=linux; processor=x86_64,*</Bundle-NativeCode>]
[+++ b/NOTICE.txt, +benchmarking framework, which can be obtained at:, +This product contains a modified portion of 'SLF4J', a simple logging, +facade for Java, which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.slf4j.txt (MIT License), + * HOMEPAGE:, + * http://www.slf4j.org/, +, +++ b/NOTICE.txt, +benchmarking framework, which can be obtained at:, +This product contains a modified portion of 'SLF4J', a simple logging, +facade for Java, which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.slf4j.txt (MIT License), + * HOMEPAGE:, + * http://www.slf4j.org/, +, +++ b/all/pom.xml, +++ b/NOTICE.txt, +benchmarking framework, which can be obtained at:,
[+++ b/handler/src/main/java/io/netty/handler/ssl/SniHandler.java, +import io.netty.util.Mapping;, + private final Mapping<Object, SslContext> mapping;, + * Creates a SNI detection handler with configured {@link SslContext}, + * maintained by {@link Mapping}, + public SniHandler(Mapping<? super String, ? extends SslContext> mapping) {, + this.mapping = (Mapping<Object, SslContext>) mapping;, + * Creates a SNI detection handler with configured {@link SslContext}, + * maintained by {@link DomainNameMapping}, + *, + * @param mapping the mapping of domain name to {@link SslContext}, + */, + public SniHandler(DomainNameMapping<? extends SslContext> mapping) {, + this((Mapping<String, ? extends SslContext>) mapping);, + }, +, + /**, + * @return the selected
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java, + *, + * You <strong>MUST</strong> call {@link #destroy()} after completion to release all resources., + *, +public class HttpPostRequestDecoder {, + private boolean destroyed;, +, + private void checkDestroyed() {, + if (destroyed) {, + throw new IllegalStateException(HttpPostRequestDecoder.class.getSimpleName() + " was destroyed already");, + }, + }, +, + checkDestroyed();, + checkDestroyed();, +, + checkDestroyed();, +, + checkDestroyed();, +, + checkDestroyed();, +, + checkDestroyed();, +, + * Be sure to call {@link InterfaceHttpData#release()} after you are done, + * with processing to make sure to not leak any resources, + *, + checkDestroyed();, +, + *
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, + String svalue = (valueStart >= valueEnd) ? StringUtil.EMPTY_STRING : sb.substring(valueStart, valueEnd);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, + String svalue = (valueStart >= valueEnd) ? StringUtil.EMPTY_STRING : sb.substring(valueStart, valueEnd);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java, +, + // https://github.com/netty/netty/issues/7620, + @Test, + public void testDecodeMalformedEmptyContentTypeFieldParameters() throws Exception {, + final String boundary = "dLV9Wyq26L_-JQxk6ferf-RT153LhOO";, + final DefaultFullHttpRequest req = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST,, + "http://localhost");, + req.headers().add(HttpHeaderNames.CONTENT_TYPE, "multipart/form-data; boundary=" + boundary);, + // Force to use memory-based data., + final DefaultHttpDataFactory inMemoryFactory = new DefaultHttpDataFactory(false);, + final String data = "asdf";, + final String filename = "tmp-0.txt";, + final String body =, + "--" +
[+++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerInitializer.java, + //p.addLast("aggregator", new HttpObjectAggregator(1048576));]
[+++ b/docker/docker-compose.yaml, + command: /bin/bash -cl "./mvnw -P boringssl clean install -Dio.netty.testsuite.badHost=netty.io -Dxml.skip=true", +++ b/docker/docker-compose.yaml, + command: /bin/bash -cl "./mvnw -P boringssl clean install -Dio.netty.testsuite.badHost=netty.io -Dxml.skip=true", +++ b/pom.xml, + <id>boringssl</id>, + <properties>, + <tcnative.artifactId>netty-tcnative-boringssl-static</tcnative.artifactId>, + <tcnative.classifier/>, + </properties>, + </profile>, + <profile>]
[+++ b/buffer/src/test/java/io/netty/buffer/UnpooledTest.java, + ByteBuf buffer = wrappedBuffer(e.getKey());, + ByteBufUtil.hashCode(buffer));, + buffer.release();, + a.release();, + b.release();, + a.release();, + b.release();, + a.release();, + b.release();, + a.release();, + b.release();, + a.release();, + b.release();, + a.release();, + b.release();, + a.release();, + b.release();, + a.release();, + b.release();, + a.release();, + b.release();, + for (ByteBuf buffer: expected) {, + buffer.release();, + }, + assertSameAndRelease(EMPTY_BUFFER, wrappedBuffer(EMPTY_BYTES));, + assertSameAndRelease(EMPTY_BUFFER, wrappedBuffer(new byte[8], 0, 0));, + assertSameAndRelease(EMPTY_BUFFER, wrappedBuffer(new byte[8], 8, 0));, + assertSameAndRelease(EMPTY_BUFFER, wrappedBuffer(ByteBuffer.allocateDirect(0)));, + assertSameAndRelease(EMPTY_BUFFER, wrappedBuffer(EMPTY_BUFFER));, + assertSameAndRelease(EMPTY_BUFFER, wrappedBuffer(EMPTY_BYTES_2D));, + assertSameAndRelease(EMPTY_BUFFER, wrappedBuffer(new byte[][] { EMPTY_BYTES }));, + assertSameAndRelease(EMPTY_BUFFER, wrappedBuffer(EMPTY_BYTE_BUFFERS));, + assertSameAndRelease(EMPTY_BUFFER, wrappedBuffer(new ByteBuffer[] { ByteBuffer.allocate(0) }));, +
[+++ b/pom.xml, + <version>v1.0.1</version>]
[+++ /dev/null, +++ /dev/null, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/AbstractSctpChannelSink.java, +/*
[+++ b/all/pom.xml, + <version>4.0.8.Final</version>, +++ b/all/pom.xml, + <version>4.0.8.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.8.Final</version>, +++ b/all/pom.xml, + <version>4.0.8.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.8.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.8.Final</version>, +++ b/all/pom.xml, + <version>4.0.8.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.8.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.8.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.8.Final</version>, +++ b/all/pom.xml, + <version>4.0.8.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.8.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.8.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.8.Final</version>, +++ b/codec/pom.xml, + <version>4.0.8.Final</version>, +++ b/all/pom.xml, + <version>4.0.8.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.8.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.8.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.8.Final</version>, +++ b/codec/pom.xml, + <version>4.0.8.Final</version>, +++ b/common/pom.xml, + <version>4.0.8.Final</version>, +++ b/all/pom.xml, + <version>4.0.8.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.8.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.8.Final</version>, +++ b/codec-socks/pom.xml, +
[+++ b/pom.xml, + <jetty.alpnAgent.version>2.0.6</jetty.alpnAgent.version>]
[+++ /dev/null, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, + * @deprecated Use {@link HttpUtil#isKeepAlive(HttpMessage)} instead., + return HttpUtil.isKeepAlive(message);, + * @deprecated Use {@link HttpUtil#setKeepAlive(HttpMessage, boolean)} instead., + HttpUtil.setKeepAlive(message, keepAlive);, + * @deprecated Use {@link HttpUtil#getContentLength(HttpMessage)} instead., + return HttpUtil.getContentLength(message);, + * @deprecated Use {@link HttpUtil#getContentLength(HttpMessage, long)} instead., + return HttpUtil.getContentLength(message, defaultValue);, + * @deprecated Use {@link HttpUtil#setContentLength(HttpMessage, long)} instead., + HttpUtil.setContentLength(message, length);, + * @deprecated Use {@link HttpUtil#is100ContinueExpected(HttpMessage)} instead., + return HttpUtil.is100ContinueExpected(message);, + * @deprecated Use {@link HttpUtil#set100ContinueExpected(HttpMessage, boolean)} instead., + HttpUtil.set100ContinueExpected(message, true);, + * @deprecated Use {@link HttpUtil#set100ContinueExpected(HttpMessage, boolean)} instead., + HttpUtil.set100ContinueExpected(message, set);, + * @deprecated Use {@link HttpUtil#isTransferEncodingChunked(HttpMessage)} instead.,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + setHandshakeComplete();, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + setHandshakeComplete();, +, +++ b/handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java, + return bytes * 1000 / limit - interval;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + setHandshakeComplete();, +, +++ b/handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java, + return bytes * 1000 / limit - interval;, +++ b/handler/src/main/java/io/netty/handler/traffic/TrafficCounter.java, + if (checkInterval.get() != newcheckInterval) {, + checkInterval.set(newcheckInterval);, + if (newcheckInterval <= 0) {]
[+++ b/common/src/main/java/io/netty/util/internal/EmptyArrays.java, +import java.security.cert.X509Certificate;, + public static final X509Certificate[] EMPTY_X509_CERTIFICATES = new X509Certificate[0];, +++ b/common/src/main/java/io/netty/util/internal/EmptyArrays.java, +import java.security.cert.X509Certificate;, + public static final X509Certificate[] EMPTY_X509_CERTIFICATES = new X509Certificate[0];, +++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClient.java, +import io.netty.handler.ssl.SslContext;, +import io.netty.handler.ssl.util.InsecureTrustManagerFactory;, + final SslContext sslCtx;, + if (ssl) {, + sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);, + } else {, + sslCtx = null;, + }, + .handler(new HttpSnoopClientInitializer(sslCtx));, +++ b/common/src/main/java/io/netty/util/internal/EmptyArrays.java, +import java.security.cert.X509Certificate;, + public static final X509Certificate[] EMPTY_X509_CERTIFICATES = new X509Certificate[0];, +++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClient.java, +import io.netty.handler.ssl.SslContext;, +import io.netty.handler.ssl.util.InsecureTrustManagerFactory;, + final SslContext sslCtx;, + if (ssl) {, + sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);, + } else {, + sslCtx = null;, + }, +
[+++ b/transport-native-epoll/pom.xml, +++ b/transport-native-epoll/pom.xml, +++ b/transport-native-kqueue/pom.xml]
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java, + static final String BAD_HOST = SystemPropertyUtil.get("io.netty.testsuite.badHost", "198.51.100.254");]
[+++ b/handler/src/test/java/io/netty/handler/ssl/JdkOpenSslEngineInteroptTest.java, + @Test, + public void testSessionAfterHandshakeKeyManagerFactoryMutualAuth() throws Exception {, + checkShouldUseKeyManagerFactory();, + super.testSessionAfterHandshakeKeyManagerFactoryMutualAuth();, + }, +, + @Override, + @Test, + public void testSessionAfterHandshakeKeyManagerFactory() throws Exception {, + checkShouldUseKeyManagerFactory();, + super.testSessionAfterHandshakeKeyManagerFactory();, + }, +, + @Override, +++ b/handler/src/test/java/io/netty/handler/ssl/JdkOpenSslEngineInteroptTest.java, + @Test, + public void testSessionAfterHandshakeKeyManagerFactoryMutualAuth() throws Exception {, + checkShouldUseKeyManagerFactory();, + super.testSessionAfterHandshakeKeyManagerFactoryMutualAuth();, + }, +, + @Override, + @Test, + public void testSessionAfterHandshakeKeyManagerFactory() throws Exception {, + checkShouldUseKeyManagerFactory();, + super.testSessionAfterHandshakeKeyManagerFactory();, + }, +, + @Override, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslJdkSslEngineInteroptTest.java, + @Test, + public void testSessionAfterHandshakeKeyManagerFactoryMutualAuth() throws Exception {, + checkShouldUseKeyManagerFactory();, + super.testSessionAfterHandshakeKeyManagerFactoryMutualAuth();, + }, +, + @Override]
[+++ b/src/docbook/module/start.xml, + &ChannelUpstreamHandler; and &ChannelDownstreamHandler;., + &SimpleChannelHandler; provides various event handler methods that, + you can override. For now, it's just enough to extend, + &SimpleChannelHandler; rather than to implement the handler, + interfaces directly., +public class TimeEncoder implements &SimpleChannelHandler; {, + public void writeRequested(&ChannelHandlerContext; ctx, &MessageEvent;<co id="example.time6.co2"/> e) {, + UnixTime time = (UnixTime) e.getMessage();, + &Channels;.write(ctx, e.getChannel(), e.getFuture(), buf);<co id="example.time6.co3"/>, + An encoder overrides the <methodname>writeRequested</methodname>, + method to intercept a write request. Please note that the, + &MessageEvent; parameter here is the same type which was specified, + in <methodname>messageReceived</methodname> but they are interpreted, +
[+++ b/transport/src/main/java/io/netty/channel/ChannelInboundByteHandlerAdapter.java, + * This implementation is a good starting point for most users., +++ b/transport/src/main/java/io/netty/channel/ChannelInboundByteHandlerAdapter.java, + * This implementation is a good starting point for most users., +++ b/transport/src/main/java/io/netty/channel/ChannelInboundInvoker.java, +/**, + * Interface which is shared by others which need to fire inbound events, + */, +, + /**, + * A {@link Channel} was registered to its {@link EventLoop}., + *, + * This will result in having the {@link ChannelInboundHandler#channelRegistered(ChannelHandlerContext)} method, + * called of the next {@link ChannelInboundHandler} contained in the {@link ChannelPipeline} of the, + * {@link Channel}., + */, +, + /**, +
[+++ b/pom.xml, + Netty must be released from RHEL 6.7 x86_64 or compatible so that:, + Release process must be performed on RHEL 6.7 or its derivatives., + <content>release 6.7</content>]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + DefaultChannelHandlerContext next = findContextInbound(, + DefaultChannelHandlerContext nextCtx = findContextInbound(ctx.next, FLAG_STATE_HANDLER);, + DefaultChannelHandlerContext nextCtx = findContextOutbound(ctx.prev, FLAG_OPERATION_HANDLER);, + return pipeline.findOutboundByteBuffer(prev);, + return pipeline.findOutboundMessageBuffer(prev);, + DefaultChannelHandlerContext next = findContextInbound(this.next, FLAG_STATE_HANDLER);, + DefaultChannelHandlerContext next = findContextInbound(this.next, FLAG_STATE_HANDLER);, + DefaultChannelHandlerContext next = findContextInbound(this.next, FLAG_STATE_HANDLER);, + DefaultChannelHandlerContext next = findContextInbound(this.next, FLAG_STATE_HANDLER);, + DefaultChannelHandlerContext next = findContextInbound(this.next, FLAG_STATE_HANDLER);, + return pipeline.bind(findContextOutbound(prev, FLAG_OPERATION_HANDLER), localAddress, promise);, + return pipeline.connect(, + findContextOutbound(prev, FLAG_OPERATION_HANDLER), remoteAddress, localAddress, promise);, + return pipeline.disconnect(findContextOutbound(prev, FLAG_OPERATION_HANDLER), promise);, + return pipeline.close(findContextOutbound(prev, FLAG_OPERATION_HANDLER), promise);, + return pipeline.deregister(findContextOutbound(prev, FLAG_OPERATION_HANDLER), promise);, + pipeline.read(findContextOutbound(prev, FLAG_OPERATION_HANDLER));, + DefaultChannelHandlerContext prev = findContextOutbound(this.prev, FLAG_OPERATION_HANDLER);, + return pipeline.sendFile(findContextOutbound(prev, FLAG_OPERATION_HANDLER), region,
[+++ /dev/null, +++ /dev/null, +++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, + private void logMessages(ChannelHandlerContext ctx, String eventName, MessageList<Object> msgs) {, + if (size == 0) {, + logger.log(internalLevel, format(ctx, formatEmptyMessageList(eventName)));, + } else {, + logger.log(internalLevel, format(ctx, formatMessage(eventName, i + 1, size, msg)));, +, + protected String formatEmptyMessageList(String eventName) {, + return eventName + "(empty)";, + }, +, + protected String formatMessage(String eventName, int seq, int size, Object msg) {, + if (msg instanceof ByteBuf) {, + return formatByteBuf(eventName, seq, size, (ByteBuf) msg);, + } else {, + return formatNonByteBuf(eventName, seq, size, msg);, + }, + }, +, + protected String formatByteBuf(String eventName,
[+++ b/src/main/java/org/jboss/netty/container/guice/NettyModule.java, +import org.jboss.netty.channel.socket.DatagramChannelFactory;, +import org.jboss.netty.channel.socket.oio.OioDatagramChannelFactory;, + bind(DatagramChannelFactory.class)., + toProvider(OioDatagramChannelFactoryProvider.class)., + in(Scopes.SINGLETON);, +, +, + bind(OioDatagramChannelFactory.class)., + toProvider(OioDatagramChannelFactoryProvider.class)., + in(Scopes.SINGLETON);, +++ b/src/main/java/org/jboss/netty/container/guice/NettyModule.java, +import org.jboss.netty.channel.socket.DatagramChannelFactory;, +import org.jboss.netty.channel.socket.oio.OioDatagramChannelFactory;, + bind(DatagramChannelFactory.class)., + toProvider(OioDatagramChannelFactoryProvider.class)., + in(Scopes.SINGLETON);, +, +, + bind(OioDatagramChannelFactory.class)., + toProvider(OioDatagramChannelFactoryProvider.class)., + in(Scopes.SINGLETON);, +++ b/src/main/java/org/jboss/netty/container/guice/OioDatagramChannelFactoryProvider.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2009, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import io.netty.util.internal.EmptyArrays;, + * Decodes a string generated by {@link #hexDump(byte[])}, + */, + public static byte[] decodeHexDump(CharSequence hexDump) {, + return HexUtil.decodeHexDump(hexDump, 0, hexDump.length());, + }, +, + /**, + private static byte[] decodeHexDump(CharSequence hexDump, int fromIndex, int length) {, + if (length < 0) {, + throw new IllegalArgumentException("length: " + length);, + }, + if (length == 0) {, + return EmptyArrays.EMPTY_BYTES;, + }, +, + int endIndex = fromIndex + length - 1;, + byte[] bytes = new byte[length >>> 1];, +, + for (; fromIndex < endIndex; fromIndex += 2) {, +
[+++ b/codec/src/main/java/io/netty/handler/codec/DateFormatter.java, + char monthChar1 = AsciiString.toLowerCase(txt.charAt(tokenStart));, + char monthChar2 = AsciiString.toLowerCase(txt.charAt(tokenStart + 1));, + char monthChar3 = AsciiString.toLowerCase(txt.charAt(tokenStart + 2));, +, + if (monthChar1 == 'j' && monthChar2 == 'a' && monthChar3 == 'n') {, + } else if (monthChar1 == 'f' && monthChar2 == 'e' && monthChar3 == 'b') {, + } else if (monthChar1 == 'm' && monthChar2 == 'a' && monthChar3 == 'r') {, + } else if (monthChar1 == 'a' && monthChar2 == 'p' && monthChar3 == 'r') {, + } else if (monthChar1 == 'm' && monthChar2 == 'a' && monthChar3 == 'y')
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/ClientCookieEncoder.java, +import io.netty.util.internal.InternalThreadLocalMap;, + List<Cookie> cookiesList = InternalThreadLocalMap.get().arrayList();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/ClientCookieEncoder.java, +import io.netty.util.internal.InternalThreadLocalMap;, + List<Cookie> cookiesList = InternalThreadLocalMap.get().arrayList();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, +import io.netty.util.internal.InternalThreadLocalMap;, + List<String> values = InternalThreadLocalMap.get().arrayList(1);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/ClientCookieEncoder.java, +import io.netty.util.internal.InternalThreadLocalMap;, + List<Cookie> cookiesList = InternalThreadLocalMap.get().arrayList();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, +import io.netty.util.internal.InternalThreadLocalMap;, + List<String> values = InternalThreadLocalMap.get().arrayList(1);, +++ b/common/src/main/java/io/netty/util/AsciiString.java, +import io.netty.util.internal.InternalThreadLocalMap;, + final List<AsciiString> res = InternalThreadLocalMap.get().arrayList();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/ClientCookieEncoder.java, +import io.netty.util.internal.InternalThreadLocalMap;, + List<Cookie> cookiesList = InternalThreadLocalMap.get().arrayList();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, +import io.netty.util.internal.InternalThreadLocalMap;, + List<String> values = InternalThreadLocalMap.get().arrayList(1);, +++ b/common/src/main/java/io/netty/util/AsciiString.java, +import io.netty.util.internal.InternalThreadLocalMap;, + final List<AsciiString> res = InternalThreadLocalMap.get().arrayList();, +++ b/common/src/main/java/io/netty/util/internal/InternalThreadLocalMap.java, +import java.util.ArrayList;, + private static final int DEFAULT_ARRAY_LIST_INITIAL_CAPACITY = 8;, +, + if (arrayList
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, +public class HttpChunkAggregator extends MessageToMessageDecoder<HttpObject> {, + protected Object decode(ChannelHandlerContext ctx, HttpObject msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, +public class HttpChunkAggregator extends MessageToMessageDecoder<HttpObject> {, + protected Object decode(ChannelHandlerContext ctx, HttpObject msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, +public abstract class HttpContentDecoder extends MessageToMessageDecoder<Object> {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, +public class HttpChunkAggregator extends MessageToMessageDecoder<HttpObject> {, + protected Object decode(ChannelHandlerContext ctx, HttpObject msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, +public abstract class HttpContentDecoder extends MessageToMessageDecoder<Object> {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +public abstract class HttpContentEncoder extends MessageToMessageCodec<HttpMessage, Object> {, + protected Object decode(ChannelHandlerContext ctx, HttpMessage msg), +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, +public class HttpChunkAggregator extends MessageToMessageDecoder<HttpObject> {, + protected
[+++ b/all/pom.xml, + <version>4.1.25.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.25.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.25.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.25.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.25.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, + <version>4.1.25.Final-SNAPSHOT</version>, +
[+++ b/codec/src/main/java/io/netty/handler/codec/CodecUtil.java, + static void addToNextOutboundBuffer(ChannelHandlerContext ctx, Object msg) {, + try {, + ctx.nextOutboundMessageBuffer().add(msg);, + } catch (NoSuchBufferException e) {, + NoSuchBufferException newE =, + new NoSuchBufferException(e.getMessage() + " (msg: " + msg + ')');, + newE.setStackTrace(e.getStackTrace());, + throw newE;, + }, + }, +, + static void addToNextInboundBuffer(ChannelHandlerContext ctx, Object msg) {, + try {, + ctx.nextInboundMessageBuffer().add(msg);, + } catch (NoSuchBufferException e) {, + NoSuchBufferException newE =, + new NoSuchBufferException(e.getMessage() + " (msg: " + msg + ')');, + newE.setStackTrace(e.getStackTrace());, + throw newE;, + }, + }, +, +++ b/codec/src/main/java/io/netty/handler/codec/CodecUtil.java, + static void addToNextOutboundBuffer(ChannelHandlerContext ctx, Object msg)
[+++ b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java, +import io.netty.channel.EventLoopGroup;, +import io.netty.channel.socket.SocketChannel;, + private EventLoopGroup bossGroup;, + private EventLoopGroup workerGroup;, + bossGroup = new NioEventLoopGroup();, + workerGroup = new NioEventLoopGroup();, + ServerBootstrap bootstrap = new ServerBootstrap();, + bootstrap.group(bossGroup, workerGroup), + .channel(NioServerSocketChannel.class), + if (bossGroup != null) {, + bossGroup.shutdown();, + }, + if (workerGroup != null) {, + workerGroup.shutdown();, +++ b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java, +import io.netty.channel.EventLoopGroup;, +import io.netty.channel.socket.SocketChannel;, + private EventLoopGroup bossGroup;, + private EventLoopGroup workerGroup;, + bossGroup = new NioEventLoopGroup();, + workerGroup = new NioEventLoopGroup();, + ServerBootstrap bootstrap = new ServerBootstrap();, + bootstrap.group(bossGroup, workerGroup), + .channel(NioServerSocketChannel.class), + if (bossGroup != null) {, + bossGroup.shutdown();, + }, +
[+++ b/pom.xml, + -verbose:gc, + -verbose:gc]
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpServerCodecTest.java, + private static ByteBuf prepareDataChunk(int size) {]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import io.netty.internal.tcnative.Buffer;, +import io.netty.internal.tcnative.Library;, +import io.netty.internal.tcnative.SSL;, +import io.netty.internal.tcnative.SSLContext;, + Class.forName("io.netty.internal.tcnative.SSL", false, OpenSsl.class.getClassLoader());, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import io.netty.internal.tcnative.Buffer;, +import io.netty.internal.tcnative.Library;, +import io.netty.internal.tcnative.SSL;, +import io.netty.internal.tcnative.SSLContext;, + Class.forName("io.netty.internal.tcnative.SSL", false, OpenSsl.class.getClassLoader());, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslCertificateException.java, +import io.netty.internal.tcnative.CertificateVerifier;, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import io.netty.internal.tcnative.Buffer;, +import io.netty.internal.tcnative.Library;, +import io.netty.internal.tcnative.SSL;, +import io.netty.internal.tcnative.SSLContext;, + Class.forName("io.netty.internal.tcnative.SSL", false, OpenSsl.class.getClassLoader());, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslCertificateException.java, +import io.netty.internal.tcnative.CertificateVerifier;, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, +import io.netty.internal.tcnative.SSL;, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import io.netty.internal.tcnative.Buffer;, +import io.netty.internal.tcnative.Library;, +import io.netty.internal.tcnative.SSL;, +import io.netty.internal.tcnative.SSLContext;, + Class.forName("io.netty.internal.tcnative.SSL", false, OpenSsl.class.getClassLoader());, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslCertificateException.java, +import io.netty.internal.tcnative.CertificateVerifier;, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, +import io.netty.internal.tcnative.SSL;, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterialManager.java, +import io.netty.internal.tcnative.CertificateRequestedCallback;, +import io.netty.internal.tcnative.SSL;, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import io.netty.internal.tcnative.Buffer;, +import io.netty.internal.tcnative.Library;, +import io.netty.internal.tcnative.SSL;, +import io.netty.internal.tcnative.SSLContext;, + Class.forName("io.netty.internal.tcnative.SSL", false, OpenSsl.class.getClassLoader());, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslCertificateException.java, +import
[+++ b/transport/src/main/java/io/netty/channel/ChannelPipelineException.java, + * failed to execute an operation., +++ b/transport/src/main/java/io/netty/channel/ChannelPipelineException.java, + * failed to execute an operation., +++ b/transport/src/main/java/io/netty/channel/DefaultChannelFuture.java, + * The default {@link ChannelFuture} implementation. It is recommended to use {@link Channel#newFuture()} to create, + * a new {@link ChannelFuture} rather than calling the constructor explicitly., +++ b/transport/src/main/java/io/netty/channel/ChannelPipelineException.java, + * failed to execute an operation., +++ b/transport/src/main/java/io/netty/channel/DefaultChannelFuture.java, + * The default {@link ChannelFuture} implementation. It is recommended to use {@link Channel#newFuture()} to create, + * a new {@link ChannelFuture} rather than calling the constructor explicitly., +++ b/transport/src/main/java/io/netty/channel/DefaultEventExecutor.java, + /**, + * @see SingleThreadEventExecutor#SingleThreadEventExecutor(EventExecutorGroup, ThreadFactory, ChannelTaskScheduler), + */,
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClient.java, +/*, + * Copyright 2011 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, + * {@link HttpRequestHeader} req = ...;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, + * {@link HttpRequestHeader} req = ...;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + * {@link HttpRequestHeader} req = ...;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, + * {@link HttpRequestHeader} req = ...;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + * {@link HttpRequestHeader} req = ...;, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, + * {@link HttpRequestHeader} req = ...;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + * {@link HttpRequestHeader} req = ...;, +++ /dev/null, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, + * {@link HttpRequestHeader} req = ...;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + * {@link HttpRequestHeader} req = ...;, +++ /dev/null, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpContent.java, +/*, + * Copyright 2012 The
[+++ b/pom.xml, + <doclet>org.jboss.apiviz.APIviz</doclet>, + <groupId>org.jboss.apiviz</groupId>, + <version>1.2.0.GA</version>]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/CompressionException.java, +import io.netty.handler.codec.CodecException;, + * An {@link CodecException} that is raised when compression or decompression, +public class CompressionException extends CodecException {]
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java, +, + // Test that the channel's localAddress is equal to the message's recipient, + assertEquals(ctx.channel().localAddress(), msg.recipient());, +, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java, +, + // Test that the channel's localAddress is equal to the message's recipient, + assertEquals(ctx.channel().localAddress(), msg.recipient());, +, +++ b/transport-native-epoll/src/main/c/netty_epoll_linuxsocket.c, +static void netty_epoll_linuxsocket_setIpRecvOrigDestAddr(JNIEnv* env, jclass clazz, jint fd, jint optval) {, + netty_unix_socket_setOption(env, fd, IPPROTO_IP, IP_RECVORIGDSTADDR, &optval, sizeof(optval));, +}, +, +static jint netty_epoll_linuxsocket_isIpRecvOrigDestAddr(JNIEnv* env, jclass clazz, jint fd) {, + int optval;, + if (netty_unix_socket_getOption(env, fd, IPPROTO_IP, IP_RECVORIGDSTADDR, &optval, sizeof(optval)) == -1) {, + return -1;, + }, + return optval;, +}, +, + { "setIpRecvOrigDestAddr", "(II)V",
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java, + }, + }, +, + DefaultDnsCacheEntry replacedEntry = null;, + for (int i = 0; i < entries.size(); i++) {, + DefaultDnsCacheEntry entry = entries.get(i);, + // Only add old entry if the address is not the same as the one we try to add as well., + // In this case we will skip it and just add the new entry as this may have, + // more up-to-date data and cancel the old after we were able to update the cache., + if (!e.address().equals(entry.address())) {, + newEntries.add(entry);, + } else {, + assert replacedEntry
[+++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java, + if (proxiedProtocol == null) {, + throw new NullPointerException("proxiedProtocol");, + AddressFamily addrFamily = proxiedProtocol.addressFamily();, +++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java, + if (proxiedProtocol == null) {, + throw new NullPointerException("proxiedProtocol");, + AddressFamily addrFamily = proxiedProtocol.addressFamily();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskFileUpload.java, + (file != null ? file.getAbsolutePath() : "null") + " DefaultDeleteAfter: " +, +++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java, + if (proxiedProtocol == null) {, + throw new NullPointerException("proxiedProtocol");, + AddressFamily addrFamily = proxiedProtocol.addressFamily();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskFileUpload.java, + (file != null ? file.getAbsolutePath() : "null") + " DefaultDeleteAfter: " +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java, + this(finalFragment, rsv, Unpooled.buffer(0));, +++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java, + if (proxiedProtocol == null) {, + throw new NullPointerException("proxiedProtocol");,
[+++ b/transport/src/main/java/io/netty/channel/pool/SimpleChannelPool.java, + private void notifyConnect(ChannelFuture future, Promise<Channel> promise) {, + Channel channel = future.channel();, + if (!promise.trySuccess(channel)) {, + // Promise was completed in the meantime (like cancelled), just release the channel again, + release(channel);, + }]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (endianness == order()) {]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, +++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java, +final class SystemPropertyUtil {, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, +++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java, +final class SystemPropertyUtil {, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, +++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java, +final class SystemPropertyUtil {, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, +++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java, +final class SystemPropertyUtil {, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, +++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java, +final
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java, + e.getValue().clearAndCancel();, + return entries != null && entries.clearAndCancel();, + scheduleCacheExpiration(e, ttl, loop);, + private void scheduleCacheExpiration(final DefaultDnsCacheEntry e,, + // We always remove all entries for a hostname once one entry expire. This is not the, + // most efficient to do but this way we can guarantee that if a DnsResolver, + // be configured to prefer one ip family over the other we will not return unexpected, + // results to the enduser if one of the A or AAAA records has different TTL settings., + //, + // As a TTL is just
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + private final boolean inbound;, + private final boolean outbound;, +, + inbound = handler instanceof ChannelInboundHandler;, + outbound = handler instanceof ChannelOutboundHandler;, + } while (!ctx.inbound);, + } while (!ctx.outbound);]
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +import java.util.concurrent.atomic.AtomicInteger;, + // Number of thread caches backed by this arena., + final AtomicInteger numThreadCaches = new AtomicInteger();, +, + public int numThreadCaches() {, + return numThreadCaches.get();, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +import java.util.concurrent.atomic.AtomicInteger;, + // Number of thread caches backed by this arena., + final AtomicInteger numThreadCaches = new AtomicInteger();, +, + public int numThreadCaches() {, + return numThreadCaches.get();, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/PoolArenaMetric.java, + * Returns the number of thread caches backed by this arena., + */, + int numThreadCaches();, +, + /**, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, +import java.util.concurrent.atomic.AtomicInteger;, + // Number
[+++ b/microbench/pom.xml, + <!-- This only be set when run on mac as on other platforms we just want to include the jar without native, + code -->, + <kqueue.classifier />, + <id>mac</id>, + <activation>, + <os>, + <family>mac</family>, + </os>, + </activation>, + <properties>, + <kqueue.classifier>${jni.classifier}</kqueue.classifier>, + </properties>, + <build>, + <plugins>, + <plugin>, + <artifactId>maven-compiler-plugin</artifactId>, + <configuration>, + <includes>, + <include>**/*.java</include>, + </includes>, + </configuration>, + </plugin>, + </plugins>, + </build>, + </profile>, + <profile>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport-native-kqueue</artifactId>, + <version>${project.version}</version>, + <classifier>${kqueue.classifier}</classifier>, + </dependency>, + <dependency>, +++ b/microbench/pom.xml, + <!-- This only be set when run
[+++ b/pom.xml, + <pluginExecution>, + <pluginExecutionFilter>, + <groupId>org.apache.maven.plugins</groupId>, + <artifactId>maven-clean-plugin</artifactId>, + <versionRange>[1.0,)</versionRange>, + <goals>, + <goal>clean</goal>, + </goals>, + </pluginExecutionFilter>, + <action>, + <execute>, + <runOnIncremental>false</runOnIncremental>, + </execute>, + </action>, + </pluginExecution>]
[+++ b/src/main/java/org/jboss/netty/handler/codec/http/Cookie.java, +/*, + * JBoss, Home of Professional Open Source, + * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors, + * by the @authors tag. See the copyright.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version., + *, + * This
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + final boolean msgBuf;, +, + if (message instanceof ByteBuf) {, + if (ctx.hasOutboundByteBuffer()) {, + msgBuf = false;, + executor = ctx.executor();, + break;, + }, +, + ctx = ctx.prev;, + }, + } else {, + msgBuf = true;, + for (;;) {, + if (ctx.hasOutboundMessageBuffer()) {, + ctx0.write0(message, promise, msgBuf);]
[+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java, + case READ_FIXED_HEADER: try {, + } catch (Exception cause) {, + out.add(invalidMessage(cause));, + return;, + }, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java, + case READ_FIXED_HEADER: try {, + } catch (Exception cause) {, + out.add(invalidMessage(cause));, + return;, + }, +++ b/codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java, + @Test, + public void testUnknownMessageType() throws Exception {, +, + final MqttMessage message = createMessageWithFixedHeader(MqttMessageType.PINGREQ);, + ByteBuf byteBuf = MqttEncoder.doEncode(ALLOCATOR, message);, + try {, + // setting an invalid message type (15, reserved and forbidden by MQTT 3.1.1 spec), + byteBuf.setByte(0, 0xF0);, + final List<Object> out = new LinkedList<Object>();, + mqttDecoder.decode(ctx, byteBuf, out);, +, + assertEquals("Expected one object
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java, + private final OpenSslServerSessionContext sessionContext;, + public OpenSslServerSessionContext sessionContext() {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java, + private final OpenSslServerSessionContext sessionContext;, + public OpenSslServerSessionContext sessionContext() {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerSessionContext.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibEncoder.java, + SpdyHeaderBlockZlibEncoder(SpdyVersion spdyVersion, int compressionLevel) {, + super(spdyVersion);, + private int setInput(ByteBuf decompressed) {, + int len = decompressed.readableBytes();, +, + if (decompressed.hasArray()) {, + compressor.setInput(decompressed.array(), decompressed.arrayOffset() + decompressed.readerIndex(), len);, + } else {, + byte[] in = new byte[len];, + decompressed.getBytes(decompressed.readerIndex(), in);, + compressor.setInput(in, 0, in.length);, + }, +, + return len;, + while (compressInto(compressed)) {, + // Although unlikely, it's possible that the compressed size is larger than the decompressed size, + compressed.ensureWritable(compressed.capacity() << 1);, + private boolean compressInto(ByteBuf compressed) {, + byte[] out = compressed.array();, + int off = compressed.arrayOffset() + compressed.writerIndex();, + int
[+++ b/src/main/java/org/jboss/netty/handler/codec/http/CookieDecoder.java, +import org.jboss.netty.util.CaseIgnoringComparator;, +, + private final static String SEMICOLON = ";";, +, + private final static String EQUALS = "=";, +, + private final static String COMMA = ",";, + String[] split = header.split(SEMICOLON);, + for (int i = 0; i < split.length; i++) {, + DefaultCookie theCookie;, + String s = split[i];, + String[] cookie = s.split(EQUALS, 2);, + theCookie = new DefaultCookie(name, value);, + cookies.put(name, theCookie);, + boolean discard = false;, + boolean secure = false;, + String comment = null;, + String commentURL = null;, + String domain = null;, + String path =
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + if (Values.WEBSOCKET.equalsIgnoreCase(upgrade)) {, + if (Values.UPGRADE.equalsIgnoreCase(connection)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + if (Values.WEBSOCKET.equalsIgnoreCase(upgrade)) {, + if (Values.UPGRADE.equalsIgnoreCase(connection)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + if (Values.WEBSOCKET.equalsIgnoreCase(upgrade)) {, + if (Values.UPGRADE.equalsIgnoreCase(connection)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + if (Values.WEBSOCKET.equalsIgnoreCase(upgrade)) {, + if (Values.UPGRADE.equalsIgnoreCase(connection)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + if (Values.WEBSOCKET.equalsIgnoreCase(upgrade)) {, + if (Values.UPGRADE.equalsIgnoreCase(connection)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java, + if (Values.WEBSOCKET.equalsIgnoreCase(upgrade)) {, + if (Values.UPGRADE.equalsIgnoreCase(connection)) {]
[+++ b/.gitignore, +.kdev4/, +*.kdev4]
[+++ b/common/src/main/java/io/netty/util/concurrent/EventExecutor.java, + * Create a new {@link Future} which is marked as succeeded already. So {@link Future#isSuccess()}, + * Create a new {@link Future} which is marked as failed already. So {@link Future#isSuccess()}, +++ b/common/src/main/java/io/netty/util/concurrent/EventExecutor.java, + * Create a new {@link Future} which is marked as succeeded already. So {@link Future#isSuccess()}, + * Create a new {@link Future} which is marked as failed already. So {@link Future#isSuccess()}, +++ b/example/src/main/java/io/netty/example/uptime/UptimeClient.java, +import io.netty.channel.socket.SocketChannel;, +++ b/common/src/main/java/io/netty/util/concurrent/EventExecutor.java, + * Create a new {@link Future} which is marked as succeeded already. So {@link Future#isSuccess()}, + * Create a new {@link Future} which is
[+++ b/resolver/src/main/java/io/netty/resolver/AbstractAddressResolver.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/resolver/src/main/java/io/netty/resolver/AbstractAddressResolver.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/resolver/src/main/java/io/netty/resolver/AddressResolver.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/resolver/src/main/java/io/netty/resolver/AbstractAddressResolver.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/resolver/src/main/java/io/netty/resolver/AddressResolver.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/resolver/src/main/java/io/netty/resolver/AddressResolverGroup.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/resolver/src/main/java/io/netty/resolver/AbstractAddressResolver.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/resolver/src/main/java/io/netty/resolver/AddressResolver.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/resolver/src/main/java/io/netty/resolver/AddressResolverGroup.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/resolver/src/main/java/io/netty/resolver/CompositeNameResolver.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/resolver/src/main/java/io/netty/resolver/AbstractAddressResolver.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/resolver/src/main/java/io/netty/resolver/AddressResolver.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/resolver/src/main/java/io/netty/resolver/AddressResolverGroup.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/resolver/src/main/java/io/netty/resolver/CompositeNameResolver.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/resolver/src/main/java/io/netty/resolver/DefaultAddressResolverGroup.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/resolver/src/main/java/io/netty/resolver/AbstractAddressResolver.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/resolver/src/main/java/io/netty/resolver/AddressResolver.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/resolver/src/main/java/io/netty/resolver/AddressResolverGroup.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/resolver/src/main/java/io/netty/resolver/CompositeNameResolver.java, +import io.netty.util.internal.UnstableApi;, +@UnstableApi, +++ b/resolver/src/main/java/io/netty/resolver/DefaultAddressResolverGroup.java, +import io.netty.util.internal.UnstableApi;,
[+++ b/common/pom.xml, + <!-- Need compile scope to be taken into account by shade plugin -->, + <scope>compile</scope>, +++ b/common/pom.xml, + <!-- Need compile scope to be taken into account by shade plugin -->, + <scope>compile</scope>, +++ b/pom.xml, +, + <!-- Provided dependency for tests inside IDEs -->, + <dependency>, + <groupId>org.jctools</groupId>, + <artifactId>jctools-core</artifactId>, + <scope>provided</scope>, + </dependency>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, +public class HttpChunkAggregator extends MessageToMessageDecoder<HttpObject, HttpMessage> {, + super(HttpObject.class);, + public HttpMessage decode(ChannelHandlerContext ctx, HttpObject msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, +public class HttpChunkAggregator extends MessageToMessageDecoder<HttpObject, HttpMessage> {, + super(HttpObject.class);, + public HttpMessage decode(ChannelHandlerContext ctx, HttpObject msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + super(HttpObject.class);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, +public class HttpChunkAggregator extends MessageToMessageDecoder<HttpObject, HttpMessage> {, + super(HttpObject.class);, + public HttpMessage decode(ChannelHandlerContext ctx, HttpObject msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + super(HttpObject.class);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + new Class<?>[] { HttpObject.class });, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkAggregator.java, +public class HttpChunkAggregator extends MessageToMessageDecoder<HttpObject, HttpMessage> {, + super(HttpObject.class);, + public HttpMessage decode(ChannelHandlerContext ctx, HttpObject msg) throws Exception
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + final OpenSslEngine engine = new OpenSslEngine(ctx, alloc, isClient(), sessionContext(), apn, engineMap,, + rejectRemoteInitiatedRenegotiation, peerHost, peerPort);, + engineMap.add(engine);, + return engine;, + * Returns a new server-side {@link SSLEngine} with the current configuration., + return newEngine(alloc, null, -1);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + final OpenSslEngine engine = new OpenSslEngine(ctx, alloc, isClient(), sessionContext(), apn, engineMap,, + rejectRemoteInitiatedRenegotiation, peerHost, peerPort);, + engineMap.add(engine);, + return engine;, + * Returns a new server-side {@link SSLEngine} with the current configuration., + return newEngine(alloc, null, -1);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +import javax.net.ssl.SSLParameters;, + private volatile String endPointIdentificationAlgorithm;, + // Store as object as AlgorithmConstraints only exists since
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + submitWriteTask(next, executor, msg, false, promise);, + submitWriteTask(next, executor, msg, true, promise);, + }, +, + return promise;, + }, +, + private void submitWriteTask(DefaultChannelHandlerContext next, EventExecutor executor,, + Object msg, boolean flush, ChannelPromise promise) {, + executor.execute(WriteTask.newInstance(next, msg, size, flush, promise));]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshakerFactory.java, +import io.netty.handler.codec.http.DefaultFullHttpResponse;, +import io.netty.handler.codec.http.HttpHeaderUtil;, + HttpResponse res = new DefaultFullHttpResponse(, + HttpHeaderUtil.setContentLength(res, 0);, + return channel.writeAndFlush(res, promise);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshakerFactory.java, +import io.netty.handler.codec.http.DefaultFullHttpResponse;, +import io.netty.handler.codec.http.HttpHeaderUtil;, + HttpResponse res = new DefaultFullHttpResponse(, + HttpHeaderUtil.setContentLength(res, 0);, + return channel.writeAndFlush(res, promise);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshakerFactoryTest.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterialManager.java, + keyCertChainBio = toBIO(ByteBufAllocator.DEFAULT, encoded.retain());, + keyCertChainBio2 = toBIO(ByteBufAllocator.DEFAULT, encoded.retain());, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterialManager.java, + keyCertChainBio = toBIO(ByteBufAllocator.DEFAULT, encoded.retain());, + keyCertChainBio2 = toBIO(ByteBufAllocator.DEFAULT, encoded.retain());, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, + keyCertChainBio = toBIO(ByteBufAllocator.DEFAULT, encoded.retain());, + keyCertChainBio2 = toBIO(ByteBufAllocator.DEFAULT, encoded.retain());, + static long toBIO(ByteBufAllocator allocator, PemEncoded pem) throws Exception {, + private static long newBIO(ByteBuf buffer) throws Exception {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterialManager.java, + keyCertChainBio = toBIO(ByteBufAllocator.DEFAULT, encoded.retain());, + keyCertChainBio2 = toBIO(ByteBufAllocator.DEFAULT, encoded.retain());, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, + keyCertChainBio = toBIO(ByteBufAllocator.DEFAULT, encoded.retain());, + keyCertChainBio2 = toBIO(ByteBufAllocator.DEFAULT, encoded.retain());, + static long toBIO(ByteBufAllocator allocator, PemEncoded pem) throws Exception {, + private static long newBIO(ByteBuf buffer) throws Exception {, +++
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java, + setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + setBinaryData(binaryData);, + setFinalFragment(finalFragment);, + setRsv(rsv);, + setBinaryData(binaryData);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java, + setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + setBinaryData(binaryData);, + setFinalFragment(finalFragment);, + setRsv(rsv);, + setBinaryData(binaryData);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java, + setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + setFinalFragment(finalFragment);, + setRsv(rsv);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java, + setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + setBinaryData(binaryData);, + setFinalFragment(finalFragment);, + setRsv(rsv);, + setBinaryData(binaryData);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java, + setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + setFinalFragment(finalFragment);, + setRsv(rsv);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/ContinuationWebSocketFrame.java, + setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + setBinaryData(binaryData);, + setFinalFragment(finalFragment);, + setRsv(rsv);, + setBinaryData(binaryData);, + setFinalFragment(finalFragment);, + setRsv(rsv);, + setBinaryData(binaryData);, + setFinalFragment(finalFragment);, + setRsv(rsv);, + setText(text);, + if (getBinaryData() == null) {, + return getBinaryData().toString(CharsetUtil.UTF_8);, + setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + setBinaryData(ChannelBuffers.copiedBuffer(text, CharsetUtil.UTF_8));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java, + setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + setBinaryData(binaryData);, + setFinalFragment(finalFragment);, +
[+++ b/all/pom.xml, + <version>4.1.16.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.16.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.16.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.16.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.16.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, + <version>4.1.16.Final-SNAPSHOT</version>, +
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, + uint32_t events = (flags & EPOLL_EDGE) ? EPOLLET : 0;, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, + uint32_t events = (flags & EPOLL_EDGE) ? EPOLLET : 0;, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +#define EPOLL_RDHUP 0x04, +#define EPOLL_EDGE 0x08, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, + uint32_t events = (flags & EPOLL_EDGE) ? EPOLLET : 0;, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +#define EPOLL_RDHUP 0x04, +#define EPOLL_EDGE 0x08, +, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + protected int flags = Native.EPOLLET;, +, + void setFlag(int flag) {, + if (!isFlagSet(flag)) {, + flags |= flag;, + modifyEvents();, + }, + }, +, + void clearFlag(int flag) {, + if (isFlagSet(flag)) {, + flags &= ~flag;,
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractJdkChannel.java, +/*
[+++ b/common/src/main/java/io/netty/util/internal/logging/InternalLoggerFactory.java, +package io.netty.util.internal.logging;, + private static volatile InternalLoggerFactory defaultFactory;, + if (defaultFactory == null) {, + defaultFactory = newDefaultFactory(InternalLoggerFactory.class.getName());, + }, +]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + ensureAccessible();, + ensureAccessible();, + if (refCnt() == 0) {, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + protected final void ensureAccessible() {, + if (refCnt() <= 0) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + ensureAccessible();, + ensureAccessible();, + if (refCnt() == 0) {, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + protected final void ensureAccessible() {, + if (refCnt() <= 0) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteDecoder.java, + private boolean removed;, + while (!removed && in.readable()) {, +, + @Override, + public void afterRemove(ChannelHandlerContext ctx) throws Exception {, + super.afterRemove(ctx);, + removed = true;, + }, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteDecoder.java, + private boolean removed;, + while (!removed && in.readable()) {, +, + @Override, + public void afterRemove(ChannelHandlerContext ctx) throws Exception {, + super.afterRemove(ctx);, + removed = true;, + }, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteEncoder.java, + private boolean removed;, + while (!removed && in.readable()) {, +, + @Override, + public void afterRemove(ChannelHandlerContext ctx) throws Exception {, + super.afterRemove(ctx);, + removed = true;, + }, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteDecoder.java, + private boolean removed;,
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + for (PoolSubpage<?> head : pages) {, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + for (PoolSubpage<?> head : pages) {, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, + for (PoolArena<?> arena : arenas) {, + total += arena.numThreadCaches.get();, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + for (PoolSubpage<?> head : pages) {, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, + for (PoolArena<?> arena : arenas) {, + total += arena.numThreadCaches.get();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Error.java, + for (Http2Error error : errors) {, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + for (PoolSubpage<?> head : pages) {, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, + for (PoolArena<?> arena : arenas) {, + total += arena.numThreadCaches.get();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Error.java, + for (Http2Error error : errors) {, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2BlockCompressor.java, + for (boolean isCondensedInUse
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsQueryDecoder.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpDataFactory.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpDataFactory.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DiskFileUpload.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpDataFactory.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DiskFileUpload.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/MemoryFileUpload.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpDataFactory.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DiskFileUpload.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/MemoryFileUpload.java, +++ b/handler/src/main/java/io/netty/handler/ipfilter/PatternRule.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpDataFactory.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DiskFileUpload.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/MemoryFileUpload.java, +++ b/handler/src/main/java/io/netty/handler/ipfilter/PatternRule.java, +++ b/handler/src/main/java/io/netty/handler/region/package-info.java, +/*, + * Copyright 2011 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpRequest.java, + buf.append("(decodeResult: ");]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import java.util.concurrent.atomic.AtomicLong;, +import io.netty.channel.ChannelStateEvent;, +import io.netty.handler.codec.PrematureChannelClosureException;, + * , + * If the {@link Channel} gets closed and there are requests missing for a response, + * a {@link PrematureChannelClosureException} is thrown., + * , + private final AtomicLong requestResponseCounter = new AtomicLong(0);, + if (msg instanceof HttpRequest) {, + if (!done) {, + requestResponseCounter.incrementAndGet();, + } else if (msg instanceof HttpChunk) {, + , + // increment only if its the last chunk , + if (((HttpChunk) msg).isLast()) {, + requestResponseCounter.incrementAndGet();, + }, + }, + Object msg = super.decode(ctx, channel, buffer, state);, + , +
[+++ b/all/pom.xml, + <outputDirectory>${project.build.directory}/src</outputDirectory>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, +import static io.netty.buffer.Unpooled.*;, + private static final ByteBuf CRLF_BUF = unreleasableBuffer(directBuffer(ZERO_CRLF.length).writeBytes(ZERO_CRLF));, + private static final ByteBuf ZERO_CRLF_CRLF_BUF = unreleasableBuffer(directBuffer(ZERO_CRLF_CRLF.length), + .writeBytes(ZERO_CRLF_CRLF));, + // IllegalStateException will be thrown, + out.add(EMPTY_BUFFER);, + out.add(CRLF_BUF.duplicate());, + out.add(ZERO_CRLF_CRLF_BUF.duplicate());, + out.add(EMPTY_BUFFER);]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + } else if (channel.isRegistered()) {, + this.executor = channel.eventLoop();]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java, +import java.util.Queue;, +import java.util.concurrent.ConcurrentLinkedQueue;, + private final Queue<Object> pendingWriteQueue = new ConcurrentLinkedQueue<Object>();, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java, +import java.util.Queue;, +import java.util.concurrent.ConcurrentLinkedQueue;, + private final Queue<Object> pendingWriteQueue = new ConcurrentLinkedQueue<Object>();, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +import java.util.Queue;, +import java.util.concurrent.ConcurrentLinkedQueue;, + final Queue<Object[]> exchangeBuf = new ConcurrentLinkedQueue<Object[]>();, + final Queue<ByteBuf> exchangeBuf = new ConcurrentLinkedQueue<ByteBuf>();, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java, +import java.util.Queue;, +import java.util.concurrent.ConcurrentLinkedQueue;, + private final Queue<Object> pendingWriteQueue = new ConcurrentLinkedQueue<Object>();, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +import java.util.Queue;, +import java.util.concurrent.ConcurrentLinkedQueue;, + final Queue<Object[]> exchangeBuf = new ConcurrentLinkedQueue<Object[]>();, + final Queue<ByteBuf> exchangeBuf = new ConcurrentLinkedQueue<ByteBuf>();, +++ b/transport/src/main/java/io/netty/channel/SingleThreadEventExecutor.java, +import java.util.concurrent.LinkedBlockingQueue;, + private final BlockingQueue<Runnable> taskQueue = new LinkedBlockingQueue<Runnable>();, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySession.java, +import java.util.Queue;, +import
[+++ b/handler/src/test/java/io/netty/handler/ssl/JdkSslEngineTest.java, + setupHandlers(apn);, + setupHandlers(serverApn, clientApn);, + setupHandlers(serverApn, clientApn);, + setupHandlers(serverApn, clientApn);, + setupHandlers(apn);, + setupHandlers(serverApn, clientApn);, + setupHandlers(serverApn, clientApn);, + setupHandlers(serverApn, clientApn);, + setupHandlers(serverSslCtx, clientSslCtx);, +++ b/handler/src/test/java/io/netty/handler/ssl/JdkSslEngineTest.java, + setupHandlers(apn);, + setupHandlers(serverApn, clientApn);, + setupHandlers(serverApn, clientApn);, + setupHandlers(serverApn, clientApn);, + setupHandlers(apn);, + setupHandlers(serverApn, clientApn);, + setupHandlers(serverApn, clientApn);, + setupHandlers(serverApn, clientApn);, + setupHandlers(serverSslCtx, clientSslCtx);, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, +import org.junit.Test;, +, +import io.netty.handler.ssl.ApplicationProtocolConfig.Protocol;, +import io.netty.handler.ssl.ApplicationProtocolConfig.SelectedListenerFailureBehavior;, +import io.netty.handler.ssl.ApplicationProtocolConfig.SelectorFailureBehavior;, +, +import static org.junit.Assert.assertNull;, + private static final String PREFERRED_APPLICATION_LEVEL_PROTOCOL = "my-protocol-http2";, + private static final String FALLBACK_APPLICATION_LEVEL_PROTOCOL = "my-protocol-http1_1";, +, + @Test, + public void testNpn() throws Exception {, + assumeTrue(OpenSsl.isAvailable());, + ApplicationProtocolConfig
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java, + // package-private for testing only, + static void setHttp2Authority(String authority, Http2Headers out) {, + if (authority.isEmpty()) {, + out.authority(EMPTY_STRING);, + int start = authority.indexOf('@') + 1;, + int length = authority.length() - start;, + if (length == 0) {, + out.authority(new AsciiString(authority, start, length));, + }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java, + // package-private for testing only, + static void setHttp2Authority(String authority, Http2Headers out) {, + if (authority.isEmpty()) {, + out.authority(EMPTY_STRING);, + int start = authority.indexOf('@') + 1;, + int length = authority.length() - start;, + if (length == 0) {, + out.authority(new AsciiString(authority, start, length));, + }, +++
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (charset.equals(CharsetUtil.US_ASCII) || charset.equals(CharsetUtil.ISO_8859_1)) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (charset.equals(CharsetUtil.US_ASCII) || charset.equals(CharsetUtil.ISO_8859_1)) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractUnpooledSlicedByteBuf.java, + if (charset.equals(CharsetUtil.US_ASCII) || charset.equals(CharsetUtil.ISO_8859_1)) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (charset.equals(CharsetUtil.US_ASCII) || charset.equals(CharsetUtil.ISO_8859_1)) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractUnpooledSlicedByteBuf.java, + if (charset.equals(CharsetUtil.US_ASCII) || charset.equals(CharsetUtil.ISO_8859_1)) {, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + buffer._setByte(writerIndex++, AsciiString.c2b(seq.charAt(i)));, + * Copies the all content of {@code src} to a {@link ByteBuf} using {@link ByteBuf#writeBytes(byte[], int, int)}., + * @param src The source of the data to copy., + * @param dst the destination byte array., + */, + public static void copy(AsciiString src, ByteBuf dst) {, + copy(src, 0, dst, src.length());, +
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +import io.netty.util.internal.StringUtil;, +, + @Override, + public String toString() {, + return StringUtil.simpleClassName(this) + "(directByDefault: " + directByDefault + ')';, + }, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +import io.netty.util.internal.StringUtil;, +, + @Override, + public String toString() {, + return StringUtil.simpleClassName(this) + "(directByDefault: " + directByDefault + ')';, + }, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +// Too noisy at the moment., +//, +// public String toString() {, +// StringBuilder buf = new StringBuilder();, +// buf.append(heapArenas.length);, +// buf.append(" heap arena(s):");, +// buf.append(StringUtil.NEWLINE);, +// for (PoolArena<byte[]> a: heapArenas) {, +// buf.append(a);, +// }, +// buf.append(directArenas.length);, +// buf.append(" direct arena(s):");, +// buf.append(StringUtil.NEWLINE);, +// for (PoolArena<ByteBuffer> a: directArenas)
[+++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java, + ChannelPipeline remove(ChannelHandler handler);, + ChannelPipeline replace(ChannelHandler oldHandler, String newName, ChannelHandler newHandler);, +++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java, + ChannelPipeline remove(ChannelHandler handler);, + ChannelPipeline replace(ChannelHandler oldHandler, String newName, ChannelHandler newHandler);, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, + public ChannelPipeline remove(ChannelHandler handler) {, + return this;, + public ChannelPipeline replace(ChannelHandler oldHandler, String newName, ChannelHandler newHandler) {, + return this;]
[+++ b/pom.xml]
[+++ b/all/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-memcache/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta1</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, + List<String> list = PlatformDependent.isWindows(), + ? getSearchDomainsHack(), + : UnixResolverDnsServerAddressStreamProvider.parseEtcResolverSearchDomains();, + @SuppressWarnings("unchecked"), + private static List<String> getSearchDomainsHack() throws Exception {, + // This code on Java 9+ yields a warning about illegal reflective access that will be denied in, + // a future release. There doesn't seem to be a better way to get search domains for Windows yet., + Class<?> configClass = Class.forName("sun.net.dns.ResolverConfiguration");, + Method open = configClass.getMethod("open");, + Method nameservers = configClass.getMethod("searchlist");, + Object instance = open.invoke(null);, +, + return (List<String>) nameservers.invoke(instance);, + }, +, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, + List<String> list = PlatformDependent.isWindows(), + ?
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeadersEncoder.java, + static void encoderHeader(CharSequence name, CharSequence value, ByteBuf buf) throws Exception {]
[+++ b/buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java, + int localLength = Math.min(length, s.readableBytes() - (index - adjustment));, + int localLength = Math.min(length, s.readableBytes() - (index - adjustment));, + int localLength = Math.min(length, s.readableBytes() - (index - adjustment));, + int localLength = Math.min(length, s.readableBytes() - (index - adjustment));, +++ b/buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java, + int localLength = Math.min(length, s.readableBytes() - (index - adjustment));, + int localLength = Math.min(length, s.readableBytes() - (index - adjustment));, + int localLength = Math.min(length, s.readableBytes() - (index - adjustment));, + int localLength = Math.min(length, s.readableBytes() - (index - adjustment));, +++ b/buffer/src/test/java/io/netty/buffer/FixedCompositeByteBufTest.java, +import java.nio.charset.Charset;, +, + @Test, + public void testCopyingToOtherBuffer() {, + ByteBuf buf1
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CombinedHttpHeaders.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java, + protected String pristineHostname;, + nextContext.pristineHostname = hostname;, + buf.append("failed to resolve '");, + if (pristineHostname != null) {, + buf.append(pristineHostname);, + } else {, + buf.append(hostname);, + }, + buf.append('\'');, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java, + protected String pristineHostname;, + nextContext.pristineHostname = hostname;, + buf.append("failed to resolve '");, + if (pristineHostname != null) {, + buf.append(pristineHostname);, + } else {, + buf.append(hostname);, + }, + buf.append('\'');, +++ b/resolver-dns/src/test/java/io/netty/resolver/dns/SearchDomainTest.java, +import java.net.UnknownHostException;, +import static org.junit.Assert.assertThat;, +import static org.hamcrest.Matchers.not;, +import static org.hamcrest.core.StringContains.containsString;, +, + @Test, + public void testExceptionMsgNoSearchDomain() throws Exception {, + Set<String> domains = new HashSet<String>();, +, + TestDnsServer.MapRecordStoreA store
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +, + // If the list is empty we need to assign a new one because, + // we get a List that is immutable. , + //, + // See https://github.com/netty/netty/issues/325, + if (list.isEmpty()) {, + list = new ArrayList<ChannelBuffer>(1);, + }, + , +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +, + // If the list is empty we need to assign a new one because, + // we get a List that is immutable. , + //, + // See https://github.com/netty/netty/issues/325, + if (list.isEmpty()) {, + list = new ArrayList<ChannelBuffer>(1);, + }, + , +++ b/buffer/src/test/java/io/netty/buffer/AbstractChannelBufferTest.java, + , +
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return this == o || (o instanceof ByteBuf && ByteBufUtil.equals(this, (ByteBuf) o));, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return this == o || (o instanceof ByteBuf && ByteBufUtil.equals(this, (ByteBuf) o));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, + return o instanceof DefaultHttpHeaders, + && headers.equals(((DefaultHttpHeaders) o).headers, CASE_SENSITIVE_HASHER);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + return this == o || (o instanceof ByteBuf && ByteBufUtil.equals(this, (ByteBuf) o));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, + return o instanceof DefaultHttpHeaders, + && headers.equals(((DefaultHttpHeaders) o).headers, CASE_SENSITIVE_HASHER);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/ClientCookieDecoder.java, + int nameEnd;, + int valueBegin;, + int valueEnd;, + for (;;) {, + break;, + break;, + break;, + CookieBuilder(DefaultCookie cookie, String header) {, + Cookie cookie()
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java, + * See <a href="https://github.com/netty/netty/issues/2289">#2289</a>.]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + String query = wsURL.getRawQuery();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + String query = wsURL.getRawQuery();, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshakerTest.java, + @Test, + public void testRawPathWithQuery() {, + URI uri = URI.create("ws://localhost:9999/path%20with%20ws?a=b%20c");, + WebSocketClientHandshaker handshaker = newHandshaker(uri);, + FullHttpRequest request = handshaker.newHandshakeRequest();, + try {, + assertEquals("/path%20with%20ws?a=b%20c", request.uri());, + } finally {, + request.release();, + }, + }, +]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java, +import io.netty.channel.nio.AbstractNioByteChannel;, + if (channel instanceof ServerChannel || channel instanceof AbstractNioByteChannel) {, + // Server channels: Accept as many incoming connections as possible., + // NIO byte channels: Implemented to reduce unnecessary system calls even if it's > 1., + // See https://github.com/netty/netty/issues/2079, + // TODO: Add some property to ChannelMetadata so we can remove the ugly instanceof]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +import javax.net.ssl.SSLEngineResult.HandshakeStatus;, + private enum HandshakeState {, + * Not started yet., + NOT_STARTED,, + /**, + * Started via unwrap/wrap., + */, + STARTED_IMPLICITLY,, + /**, + * Started via {@link #beginHandshake()}., + */, + STARTED_EXPLICITLY,, +, + /**, + * Handshake is finished., + */, + FINISHED, + }, +, + private HandshakeState handshakeState = HandshakeState.NOT_STARTED;, + if (handshakeState != HandshakeState.NOT_STARTED) {, +, + // On shutdown clear all errors, + SSL.clearError();, + return sslWrote;, + final int netWrote;, + netWrote = SSL.writeToBIO(networkBIO, addr, len);, + netWrote = SSL.writeToBIO(networkBIO, addr, len);, + return netWrote;, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, + if (p.get(HttpChunkAggregator.class) != null) {, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, + if (p.get(HttpChunkAggregator.class) != null) {, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java, + if (p.get(HttpChunkAggregator.class) != null) {, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, + if (p.get(HttpChunkAggregator.class) != null) {, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java, + if (p.get(HttpChunkAggregator.class) != null) {, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java, + if (p.get(HttpChunkAggregator.class) != null) {, + }, +]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + final boolean isClient = !connection().isServer();, + if (isClient) {, +, + if (isClient) {, + ctx.fireUserEventTriggered(, + Http2ConnectionPrefaceAndSettingsFrameWrittenEvent.INSTANCE);, + }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + final boolean isClient = !connection().isServer();, + if (isClient) {, +, + if (isClient) {, + ctx.fireUserEventTriggered(, + Http2ConnectionPrefaceAndSettingsFrameWrittenEvent.INSTANCE);, + }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionPrefaceAndSettingsFrameWrittenEvent.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the, + * "License"); you may not use this file except in compliance with the License. You may obtain a, + * copy of the
[+++ b/handler/src/main/java/io/netty/handler/ssl/ApplicationProtocolAccessor.java, + String getNegotiatedApplicationProtocol();, +++ b/handler/src/main/java/io/netty/handler/ssl/ApplicationProtocolAccessor.java, + String getNegotiatedApplicationProtocol();, +++ b/handler/src/main/java/io/netty/handler/ssl/Java9SslEngine.java, + void setNegotiatedApplicationProtocol(String applicationProtocol) {, + public String getNegotiatedApplicationProtocol() {, + String protocol = getApplicationProtocol();, + if (protocol != null) {, + return protocol.isEmpty() ? null : protocol;, + }, + return protocol;, + public String getApplicationProtocol() {, + return Java9SslUtils.getApplicationProtocol(getWrappedEngine());, + }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/ApplicationProtocolAccessor.java, + String getNegotiatedApplicationProtocol();, +++ b/handler/src/main/java/io/netty/handler/ssl/Java9SslEngine.java, + void setNegotiatedApplicationProtocol(String applicationProtocol) {, + public String getNegotiatedApplicationProtocol() {, + String protocol = getApplicationProtocol();, + if (protocol != null) {, + return protocol.isEmpty() ? null : protocol;, + }, + return protocol;, + public String
[+++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java, + boolean readingChunks = HttpUtil.isTransferEncodingChunked(request);]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/ByteBufChecksum.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/NOTICE.txt, +++ b/NOTICE.txt, +++ /dev/null, +++ b/NOTICE.txt, +++ /dev/null, +++ b/pom.xml, + <version>4.10</version>, +++ b/NOTICE.txt, +++ /dev/null, +++ b/pom.xml, + <version>4.10</version>, +++ b/src/main/java/org/jboss/netty/channel/ChannelLocal.java, + public ChannelLocal() {, + super();, + protected T initialValue(@SuppressWarnings("unused") Channel channel) {, + return map.put(channel, value);, + return map.putIfAbsent(channel, value);, +++ b/NOTICE.txt, +++ /dev/null, +++ b/pom.xml, + <version>4.10</version>, +++ b/src/main/java/org/jboss/netty/channel/ChannelLocal.java, + public ChannelLocal() {, + super();, + protected T initialValue(@SuppressWarnings("unused") Channel channel) {, + return map.put(channel, value);, + return map.putIfAbsent(channel, value);, +++ /dev/null, +++ b/NOTICE.txt, +++ /dev/null, +++ b/pom.xml, + <version>4.10</version>, +++ b/src/main/java/org/jboss/netty/channel/ChannelLocal.java, + public ChannelLocal() {, + super();, + protected T initialValue(@SuppressWarnings("unused") Channel
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelId.java, + if (addr.isAnyLocalAddress() || addr.isLoopbackAddress()) {]
[+++ b/common/src/main/java/io/netty/util/internal/LegacyLinkedTransferQueue.java, + // Explicit cast, see http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6302954, + // Explicit cast, see http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6302954, + return (E) LegacyLinkedTransferQueue.cast(item);, + // Explicit cast, see http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6302954, + return (E) LegacyLinkedTransferQueue.cast(item);, + // Explicit cast, see http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6302954, + return (E) LegacyLinkedTransferQueue.cast(item);, + // Explicit cast, see http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6302954, + nextItem = (E) LegacyLinkedTransferQueue.cast(item);, +++ b/common/src/main/java/io/netty/util/internal/LegacyLinkedTransferQueue.java, + // Explicit cast, see http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6302954, + // Explicit cast, see http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6302954, + return (E) LegacyLinkedTransferQueue.cast(item);, + // Explicit cast, see http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6302954, + return (E) LegacyLinkedTransferQueue.cast(item);, + // Explicit cast, see http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6302954, + return (E) LegacyLinkedTransferQueue.cast(item);, + // Explicit cast, see http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6302954, + nextItem = (E) LegacyLinkedTransferQueue.cast(item);, +++
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/AuthoritativeDnsServerCache.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/all/pom.xml, + <version>4.0.2.Final</version>, +++ b/all/pom.xml, + <version>4.0.2.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.2.Final</version>, +++ b/all/pom.xml, + <version>4.0.2.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.2.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.2.Final</version>, +++ b/all/pom.xml, + <version>4.0.2.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.2.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.2.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.2.Final</version>, +++ b/all/pom.xml, + <version>4.0.2.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.2.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.2.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.2.Final</version>, +++ b/codec/pom.xml, + <version>4.0.2.Final</version>, +++ b/all/pom.xml, + <version>4.0.2.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.2.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.2.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.2.Final</version>, +++ b/codec/pom.xml, + <version>4.0.2.Final</version>, +++ b/common/pom.xml, + <version>4.0.2.Final</version>, +++ b/all/pom.xml, + <version>4.0.2.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.2.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.2.Final</version>, +++ b/codec-socks/pom.xml, +
[+++ b/pom.xml, + <!-- Needed because of https://issues.apache.org/jira/browse/MENFORCER-275 -->, + <enforcer.plugin.version>3.0.0-M1</enforcer.plugin.version>, + <enforcer.plugin.version>1.4.1</enforcer.plugin.version>, + <version>${enforcer.plugin.version}</version>, +++ b/pom.xml, + <!-- Needed because of https://issues.apache.org/jira/browse/MENFORCER-275 -->, + <enforcer.plugin.version>3.0.0-M1</enforcer.plugin.version>, + <enforcer.plugin.version>1.4.1</enforcer.plugin.version>, + <version>${enforcer.plugin.version}</version>, +++ b/resolver-dns/pom.xml, + <exclusions>, + <!--, + We need to use commons-lang 2.6 to be able to run the tests with java9, + See https://github.com/apache/bookkeeper/issues/385, + -->, + <exclusion>, + <groupId>commons-lang</groupId>, + <artifactId>commons-lang</artifactId>, + </exclusion>, + </exclusions>, + </dependency>, + <dependency>, + <groupId>commons-lang</groupId>, + <artifactId>commons-lang</artifactId>, + <version>2.6</version>, + <scope>test</scope>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java, + if (name.isEmpty()) {, + if (value.isEmpty()) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java, + if (name.isEmpty()) {, + if (value.isEmpty()) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, + if (line.isEmpty()) {, + } while (!line.isEmpty());, + if (!line.isEmpty()) {, + if (!current.isEmpty()) {, + } while (!line.isEmpty());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java, + if (name.isEmpty()) {, + if (value.isEmpty()) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, + if (line.isEmpty()) {, + } while (!line.isEmpty());, + if (!line.isEmpty()) {, + if (!current.isEmpty()) {, + } while (!line.isEmpty());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMethod.java, + if (name.isEmpty()) {, + if (name.isEmpty()) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java, + if (name.isEmpty()) {, + if (value.isEmpty()) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, + if (line.isEmpty())
[+++ b/pom.xml, + <version>2.2</version>, + <groupId>org.eclipse.wst.css</groupId>, + <artifactId>core</artifactId>, + <version>1.1.101-v200705302225</version>, + <exclusions>, + <exclusion>, + <groupId>org.apache</groupId>, + <artifactId>xerces</artifactId>, + </exclusion>, + <exclusion>, + <groupId>com.ibm</groupId>, + <artifactId>icu</artifactId>, + </exclusion>, + </exclusions>, + </dependency>, + <dependency>, + <groupId>org.eclipse.wst.sse</groupId>, + <artifactId>core</artifactId>, + <version>1.1.202-v200709061102</version>, + <exclusions>, + <exclusion>, + <groupId>org.apache</groupId>, + <artifactId>xerces</artifactId>, + </exclusion>, + <exclusion>, + <groupId>com.ibm</groupId>, + <artifactId>icu</artifactId>, + </exclusion>, + </exclusions>, + </dependency>, + <dependency>]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslCertificateException.java, + // Call OpenSsl.isAvailable() to ensure we try to load the native lib as CertificateVerifier.isValid(...), + // will depend on it. If loading fails we will just skip the validation., + if (OpenSsl.isAvailable() && !CertificateVerifier.isValid(errorCode)) {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslCertificateException.java, + // Call OpenSsl.isAvailable() to ensure we try to load the native lib as CertificateVerifier.isValid(...), + // will depend on it. If loading fails we will just skip the validation., + if (OpenSsl.isAvailable() && !CertificateVerifier.isValid(errorCode)) {, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslCertificateExceptionTest.java, + Assume.assumeTrue(OpenSsl.isAvailable());, + Assume.assumeTrue(OpenSsl.isAvailable());, +, + @Test, + public void testCanBeInstancedWhenOpenSslIsNotAvailable() {, + Assume.assumeFalse(OpenSsl.isAvailable());, + new OpenSslCertificateException(0);, + }]
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpClientCodecTest.java, +/*, + * Copyright 2011 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + * See <a href="https://github.com/netty/netty/issues/2308">#2308</a>., +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + * See <a href="https://github.com/netty/netty/issues/2308">#2308</a>., +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java, + * See <a href="https://github.com/netty/netty/issues/2308">#2308</a>., +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + * See <a href="https://github.com/netty/netty/issues/2308">#2308</a>., +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioServerSocketChannel.java, + * See <a href="https://github.com/netty/netty/issues/2308">#2308</a>., +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioSocketChannel.java, + * See <a href="https://github.com/netty/netty/issues/2308">#2308</a>.]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + throw new IllegalStateException("Stream " + stream.id() + " in unexpected state " + stream.state());, + try {, + } catch (Http2Exception cause) {, + if (connection.remote().mayHaveCreatedStream(streamId)) {, + promise.tryFailure(new IllegalStateException("Stream no longer exists: " + streamId, cause));, + return promise;, + }, + throw cause;, + }, + throw new IllegalStateException("Stream " + stream.id() + " in unexpected state " +, + stream.state());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + throw new IllegalStateException("Stream " + stream.id() + " in unexpected state " + stream.state());, + try {, + } catch (Http2Exception cause) {, + if (connection.remote().mayHaveCreatedStream(streamId)) {, + promise.tryFailure(new IllegalStateException("Stream
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioChannel.java, + /**, + * Return the {@link AbstractNioWorker} that handle the IO of the {@link AbstractNioChannel}, + * , + * @return worker, + */, + public AbstractNioWorker getWorker() {, + return worker;, + }, + , + , +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioChannel.java, + /**, + * Return the {@link AbstractNioWorker} that handle the IO of the {@link AbstractNioChannel}, + * , + * @return worker, + */, + public AbstractNioWorker getWorker() {, + return worker;, + }, + , + , +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + public NioDatagramWorker getWorker() {, + return (NioDatagramWorker) super.getWorker();, + }, +, + @Override, +++
[+++ b/src/docbook/module/start.xml, + In this chapter, we had a quick tour of Netty so that you can start to]
[+++ b/common/src/main/java/io/netty/util/internal/logging/CommonsLoggerFactory.java, + public static final InternalLoggerFactory INSTANCE = new CommonsLoggerFactory();, +, + /**, + * @deprecated Use {@link #INSTANCE} instead., + */, + @Deprecated, + public CommonsLoggerFactory() {, + }, +++ b/common/src/main/java/io/netty/util/internal/logging/CommonsLoggerFactory.java, + public static final InternalLoggerFactory INSTANCE = new CommonsLoggerFactory();, +, + /**, + * @deprecated Use {@link #INSTANCE} instead., + */, + @Deprecated, + public CommonsLoggerFactory() {, + }, +++ b/common/src/main/java/io/netty/util/internal/logging/InternalLoggerFactory.java, + * {@link InternalLoggerFactory}.setDefaultFactory({@link Log4JLoggerFactory}.INSTANCE);, + f = Log4JLoggerFactory.INSTANCE;, + f = JdkLoggerFactory.INSTANCE;, +++ b/common/src/main/java/io/netty/util/internal/logging/CommonsLoggerFactory.java, + public static final InternalLoggerFactory INSTANCE = new CommonsLoggerFactory();, +, + /**, + * @deprecated Use {@link #INSTANCE} instead., +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + public void deactivate(Http2Stream stream) {, + deactivateInternal((DefaultStream) stream);, + }, +, + @Override, + private void activateInternal(DefaultStream stream) {, + private void deactivateInternal(DefaultStream stream) {, + if (activeStreams.remove(stream)) {, + // Update the number of active streams initiated by the endpoint., + stream.createdBy().numActiveStreams--;, +, + // Notify the listeners., + for (Listener listener : listeners) {, + listener.streamInactive(stream);, + }, +, + // Mark this stream for removal., + removalPolicy.markForRemoval(stream);, + }, + }, +, + activateInternal(this);, + deactivateInternal(this);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + public void deactivate(Http2Stream stream) {, + deactivateInternal((DefaultStream) stream);, + }, +, + @Override, +
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + * <p>, + * It behaves like {@link #reserveAndWriteUtf8(ByteBuf, CharSequence, int)} with {@code reserveBytes}, + * computed by {@link #utf8MaxBytes(CharSequence)}.<br>, + return reserveAndWriteUtf8(buf, seq, utf8MaxBytes(seq));, + }, +, + /**, + * Encode a {@link CharSequence} in <a href="http://en.wikipedia.org/wiki/UTF-8">UTF-8</a> and write, + * it into {@code reserveBytes} of a {@link ByteBuf}., + * <p>, + * The {@code reserveBytes} must be computed (ie eagerly using {@link #utf8MaxBytes(CharSequence)}, + * or exactly with {@link #utf8Bytes(CharSequence)}) to ensure this method to not fail: for performance reasons, + * the index checks will be performed using just {@code reserveBytes}.<br>,
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, + if (remote == null) {, + // Remote address not know, try to get it now., + InetSocketAddress address = Native.remoteAddress(fd);, + if (address != null) {, + remote = address;, + }, + return address;, + }, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, + if (remote == null) {, + // Remote address not know, try to get it now., + InetSocketAddress address = Native.remoteAddress(fd);, + if (address != null) {, + remote = address;, + }, + return address;, + }, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java, + // addr may be null if getpeername failed., + // See https://github.com/netty/netty/issues/3328, + if
[+++ b/.fbfilter.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<FindBugsFilter>, + <!-- Tests -->, + <Match>, + <Class name="~.*Test(\$[^\$]+)*"/>, + </Match>, + <!-- Generated code -->, + <Match>, + <Class name="~.*\.LocalTimeProtocol(\$[^\$]+)*"/>, + </Match>, + <!-- Noise -->, + <Match>, + <Bug code="Co,SF", + category="I18N", + pattern="REC_CATCH_EXCEPTION,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,DB_DUPLICATE_SWITCH_CLAUSES,VO_VOLATILE_REFERENCE_TO_ARRAY" />, + </Match>, + <!-- Known false positives -->, + <Match>, + <Class name="~.*Channel(Group)?Future"/>, + <Method name="~await.*"/>, + <Bug pattern="PS_PUBLIC_SEMAPHORES"/>, + </Match>, + <Match>, + <Class name="~.*SelectorLoop"/>, + <Method name="run"/>, + <Bug code="ESync"/>, + </Match>, + <!-- Known issues that don't matter -->, + <Match>, + <Or>, + <Class name="~.*\.util\.Concurrent[A-Za-z]*HashMap(\$[^\$]+)*"/>, + <Class name="~.*\.util\..*TransferQueue(\$[^\$]+)*"/>, + <Class name="~.*\.util\.MapBackedSet"/>, +
[+++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ /dev/null, +++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ b/all/pom.xml, + <groupId>io.netty</groupId>, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +, + // If the list is empty we need to assign a new one because, + // we get a List that is immutable. , + //, + // See https://github.com/netty/netty/issues/325, + if (list.isEmpty()) {, + list = new ArrayList<ChannelBuffer>(1);, + }, + ,
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + readPending = false;, + readPending = false;, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + readPending = false;, + readPending = false;, +++ b/transport-native-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueStreamChannel.java, + readPending = false;, + readPending = false;, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + readPending = false;, + readPending = false;, +++ b/transport-native-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueStreamChannel.java, + readPending = false;, + readPending = false;, +++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + readPending = false;, + readPending = false;, +++ b/transport-native-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueStreamChannel.java, + readPending = false;, + readPending = false;, +++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java, +++ b/transport/src/main/java/io/netty/channel/oio/AbstractOioByteChannel.java, + readPending = false;, + // In OIO we should set readPending to false even if the read was not successful so we
[+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpChannel.java, + protected boolean doWriteMessage(Object msg) throws Exception {, + SctpMessage packet = (SctpMessage) msg;, + if (dataLen == 0) {, + return true;, + }, +, + return writtenBytes > 0;, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpChannel.java, + protected boolean doWriteMessage(Object msg) throws Exception {, + SctpMessage packet = (SctpMessage) msg;, + if (dataLen == 0) {, + return true;, + }, +, + return writtenBytes > 0;, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpServerChannel.java, + protected boolean doWriteMessage(Object msg) throws Exception {, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpChannel.java, + protected boolean doWriteMessage(Object msg) throws Exception {, + SctpMessage packet = (SctpMessage) msg;, + if (dataLen == 0) {, +
[+++ b/pom.xml, + <asm.version>6.0_BETA</asm.version>]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, + if (inIndex >= maxIndex - 4) {, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, + if (inIndex >= maxIndex - 4) {, +++ b/codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedEncoderTest.java, + , + /**, + * This test asserts that if we have a remainder after emitting a copy that, + * is less than 4 bytes (ie. the minimum required for a copy), we should, + * emit a literal rather than trying to see if we can emit another copy., + */, + @Test, + public void testInputBufferOverseek() throws Exception {, + ByteBuf in = Unpooled.wrappedBuffer(new byte[] {, + 11, 0, // literal, + 0,
[+++ b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java, +import io.netty.buffer.BufUtil;, + if (message == null) {, + throw new NullPointerException("message");, +, + Map<Integer, ChannelFuture> futures = new LinkedHashMap<Integer, ChannelFuture>(size());, + BufUtil.retain(message);, +, + BufUtil.release(message);]
[+++ b/pom.xml, + <exclude>**/TestUtil*</exclude>, +++ b/pom.xml, + <exclude>**/TestUtil*</exclude>, +++ b/src/test/java/org/jboss/netty/bootstrap/AbstractSocketClientBootstrapTest.java, +import org.jboss.netty.util.TestUtil;, + TestUtil.getLocalHost(),, + TestUtil.getLocalHost(),, + bootstrap.connect(new InetSocketAddress(TestUtil.getLocalHost(), 1));, +++ b/pom.xml, + <exclude>**/TestUtil*</exclude>, +++ b/src/test/java/org/jboss/netty/bootstrap/AbstractSocketClientBootstrapTest.java, +import org.jboss.netty.util.TestUtil;, + TestUtil.getLocalHost(),, + TestUtil.getLocalHost(),, + bootstrap.connect(new InetSocketAddress(TestUtil.getLocalHost(), 1));, +++ b/src/test/java/org/jboss/netty/bootstrap/AbstractSocketServerBootstrapTest.java, +import org.jboss.netty.util.TestUtil;, + TestUtil.getLocalHost(),, + bootstrap.connect(new InetSocketAddress(TestUtil.getLocalHost(), 1));, +++ b/pom.xml, + <exclude>**/TestUtil*</exclude>, +++ b/src/test/java/org/jboss/netty/bootstrap/AbstractSocketClientBootstrapTest.java, +import org.jboss.netty.util.TestUtil;, + TestUtil.getLocalHost(),, + TestUtil.getLocalHost(),, + bootstrap.connect(new InetSocketAddress(TestUtil.getLocalHost(), 1));, +++ b/src/test/java/org/jboss/netty/bootstrap/AbstractSocketServerBootstrapTest.java, +import org.jboss.netty.util.TestUtil;, + TestUtil.getLocalHost(),, + bootstrap.connect(new InetSocketAddress(TestUtil.getLocalHost(), 1));, +++ b/src/test/java/org/jboss/netty/channel/socket/AbstractSocketEchoTest.java, +import org.jboss.netty.util.TestUtil;, + ChannelFuture ccf = cb.connect(new InetSocketAddress(TestUtil.getLocalHost(), port));, +++ b/pom.xml, + <exclude>**/TestUtil*</exclude>, +++ b/src/test/java/org/jboss/netty/bootstrap/AbstractSocketClientBootstrapTest.java, +import org.jboss.netty.util.TestUtil;, + TestUtil.getLocalHost(),, + TestUtil.getLocalHost(),, + bootstrap.connect(new InetSocketAddress(TestUtil.getLocalHost(), 1));,
[+++ b/pom.xml, + <version>1.5.11</version>, + <version>4.8.1</version>, + <version>1.5.11</version>, + <version>2.4.2</version>, + <version>2.2.1</version>, + <version>2.0</version>, + <version>2.8</version>, + <url>scm:svn:https://svn.jboss.org/repos/repository.jboss.org/maven2</url>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + public static final String SUB_PROTOCOL_WILDCARD = "*";]
[+++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.handler.ssl.SslContextBuilder;, + sslCtx = SslContextBuilder.forClient(), + .trustManager(InsecureTrustManagerFactory.INSTANCE).build();, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.handler.ssl.SslContextBuilder;, + sslCtx = SslContextBuilder.forClient(), + .trustManager(InsecureTrustManagerFactory.INSTANCE).build();, +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, +import io.netty.handler.ssl.SslContextBuilder;, + sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.handler.ssl.SslContextBuilder;, + sslCtx = SslContextBuilder.forClient(), + .trustManager(InsecureTrustManagerFactory.INSTANCE).build();, +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, +import io.netty.handler.ssl.SslContextBuilder;, + sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.handler.ssl.SslContextBuilder;, + sslCtx = SslContextBuilder.forClient(), + .trustManager(InsecureTrustManagerFactory.INSTANCE).build();, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.handler.ssl.SslContextBuilder;, + sslCtx = SslContextBuilder.forClient(), + .trustManager(InsecureTrustManagerFactory.INSTANCE).build();, +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, +import io.netty.handler.ssl.SslContextBuilder;, + sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.handler.ssl.SslContextBuilder;, + sslCtx = SslContextBuilder.forClient(), + .trustManager(InsecureTrustManagerFactory.INSTANCE).build();, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, +import io.netty.handler.ssl.SslContextBuilder;, + sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + List<ByteBuf> buffers = new ArrayList<ByteBuf>();, + ByteBuf buffer = wrappedBuffer(Integer.MAX_VALUE, buffers.toArray(new ByteBuf[buffers.size()])).order(order);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + List<ByteBuf> buffers = new ArrayList<ByteBuf>();, + ByteBuf buffer = wrappedBuffer(Integer.MAX_VALUE, buffers.toArray(new ByteBuf[buffers.size()])).order(order);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractPooledByteBufTest.java, + ByteBuf buffer = alloc(length);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + List<ByteBuf> buffers = new ArrayList<ByteBuf>();, + ByteBuf buffer = wrappedBuffer(Integer.MAX_VALUE, buffers.toArray(new ByteBuf[buffers.size()])).order(order);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractPooledByteBufTest.java, + ByteBuf buffer = alloc(length);, +++ b/buffer/src/test/java/io/netty/buffer/BigEndianDirectByteBufTest.java, + ByteBuf buffer = newDirectBuffer(length);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + List<ByteBuf> buffers = new ArrayList<ByteBuf>();, + ByteBuf buffer = wrappedBuffer(Integer.MAX_VALUE, buffers.toArray(new ByteBuf[buffers.size()])).order(order);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractPooledByteBufTest.java, + ByteBuf buffer = alloc(length);, +++
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + // When deactivate is called the stream state has already been set to CLOSE however, + // it is possible that since this job has been queued other circumstances have caused, + // it to be removed from the priority tree and thus have a null parent (i.e. reprioritization)., + // If the parent is null this means it has already been removed from active streams and we, + // should not process the removal any further as this will lead to a NPE., + if (stream.parent() == null) {, + return;, + }, + },
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + this.uri = rawPath + (uri.getRawQuery() == null? "" : '?' + uri.getRawQuery());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + this.uri = rawPath + (uri.getRawQuery() == null? "" : '?' + uri.getRawQuery());, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/QueryStringDecoderTest.java, +import java.net.URISyntaxException;, + public void testBasicUris() throws URISyntaxException {, + QueryStringDecoder d = new QueryStringDecoder(new URI("http://localhost/path"));, + Assert.assertEquals(0, d.parameters().size());, + }, +, + @Test]
[+++ b/buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java, + switch (buffers.length) {, + case 0:, + return true;, + case 1:, + return buffer(0).hasArray();, + default:, + }, + switch (buffers.length) {, + case 0:, + return EmptyArrays.EMPTY_BYTES;, + case 1:, + return buffer(0).array();, + default:, + }, + switch (buffers.length) {, + case 0:, + return 0;, + case 1:, + return buffer(0).arrayOffset();, + default:, + }, + switch (buffers.length) {, + case 0:, + return Unpooled.EMPTY_BUFFER.hasMemoryAddress();, + case 1:, + return buffer(0).hasMemoryAddress();, + default:, + }, + switch (buffers.length) {, + case 0:, + return Unpooled.EMPTY_BUFFER.memoryAddress();, + case 1:, + return buffer(0).memoryAddress();, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + // Upgraded requests are ineligible for stream control. We add the null check, + // in case the stream has been deregistered., + if (stream != null && streamId == Http2CodecUtil.HTTP_UPGRADE_STREAM_ID) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + // Upgraded requests are ineligible for stream control. We add the null check, + // in case the stream has been deregistered., + if (stream != null && streamId == Http2CodecUtil.HTTP_UPGRADE_STREAM_ID) {, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameCodecTest.java, + public void flowControlShouldBeResilientToMissingStreams() throws Http2Exception {, + Http2Connection conn = new DefaultHttp2Connection(true);, + Http2ConnectionEncoder enc = new DefaultHttp2ConnectionEncoder(conn, new DefaultHttp2FrameWriter());, + Http2ConnectionDecoder dec = new DefaultHttp2ConnectionDecoder(conn,
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java, + out.writeByte(checksum >>> 8 & 0x0ff);, + out.writeByte(checksum >>> 16 & 0x0ff);, + out.writeByte(checksum >>> 24);, +++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java, + out.writeByte(checksum >>> 8 & 0x0ff);, + out.writeByte(checksum >>> 16 & 0x0ff);, + out.writeByte(checksum >>> 24);, +++ b/codec/src/test/java/io/netty/handler/codec/compression/SnappyIntegrationTest.java, +import static org.hamcrest.Matchers.*;, + testEncoderDecoderIdentity(in);, + testEncoderDecoderIdentity(in);, + }, +, + private static void testEncoderDecoderIdentity(ByteBuf in) {, + EmbeddedByteChannel encoder = new EmbeddedByteChannel(new SnappyFramedEncoder());, + EmbeddedByteChannel decoder = new EmbeddedByteChannel(new SnappyFramedDecoder());, +, + encoder.writeOutbound(in.copy());, + ByteBuf compressed = encoder.readOutbound();, + assertThat(compressed, is(not(in)));, + decoder.writeInbound(compressed);, + assertFalse(compressed.isReadable());, + ByteBuf decompressed = (ByteBuf) decoder.readInbound();, + assertEquals(in, decompressed);]
[+++ b/common/src/main/java/io/netty/util/DomainNameMapping.java, + @Override]
[+++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java, +import java.util.logging.Level;, +import java.util.logging.Logger;, + private static boolean initializedLogger;, + private static boolean loggedException;, + initializedLogger = true;, + return get(key) != null;, + if (key.length() == 0) {, + throw new IllegalArgumentException("key must not be empty.");, + }, + String value = null;, + try {, + value = System.getProperty(key);, + } catch (Exception e) {, + if (!loggedException) {, + log("Unable to retrieve a system property '" + key + "'; default values will be used.", e);, + loggedException = true;, + }, + }, +, + String value = get(key);, + log(, + String
[+++ b/codec/src/main/java/io/netty/handler/codec/CodecUtil.java, + System.arraycopy(acceptedMsgTypes, 0, newAllowedMsgTypes, 0, numElem);, +++ b/codec/src/main/java/io/netty/handler/codec/CodecUtil.java, + System.arraycopy(acceptedMsgTypes, 0, newAllowedMsgTypes, 0, numElem);, +++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java, + buf.append("VERSION: ").append(request.getProtocolVersion()).append("\r\n");, + buf.append("HOSTNAME: ").append(getHost(request, "unknown")).append("\r\n");, + buf.append("REQUEST_URI: ").append(request.getUri()).append("\r\n\r\n");, + String key = h.getKey();, + String value = h.getValue();, + buf.append("HEADER: ").append(key).append(" = ").append(value).append("\r\n");, + buf.append("PARAM: ").append(key).append(" = ").append(val).append("\r\n");, + buf.append("CONTENT: ");, + buf.append(content.toString(CharsetUtil.UTF_8));, + buf.append("\r\n");, + buf.append("TRAILING HEADER: ");, + buf.append(name).append(" = ").append(value).append("\r\n");, + buf.append("CHUNK: ");, + buf.append(chunk.getContent().toString(CharsetUtil.UTF_8)).append("\r\n");, +++ b/codec/src/main/java/io/netty/handler/codec/CodecUtil.java, + System.arraycopy(acceptedMsgTypes, 0, newAllowedMsgTypes, 0, numElem);, +++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java, + buf.append("VERSION: ").append(request.getProtocolVersion()).append("\r\n");, + buf.append("HOSTNAME: ").append(getHost(request, "unknown")).append("\r\n");, + buf.append("REQUEST_URI: ").append(request.getUri()).append("\r\n\r\n");, + String key = h.getKey();, + String value = h.getValue();, +
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractClientSocketTest.java, + return SocketTestPermutation.INSTANCE.clientSocket();, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractClientSocketTest.java, + return SocketTestPermutation.INSTANCE.clientSocket();, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java, + return SocketTestPermutation.INSTANCE.datagram();, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractClientSocketTest.java, + return SocketTestPermutation.INSTANCE.clientSocket();, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java, + return SocketTestPermutation.INSTANCE.datagram();, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractServerSocketTest.java, + return SocketTestPermutation.INSTANCE.serverSocket();, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractClientSocketTest.java, + return SocketTestPermutation.INSTANCE.clientSocket();, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java, + return SocketTestPermutation.INSTANCE.datagram();, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractServerSocketTest.java, + return SocketTestPermutation.INSTANCE.serverSocket();, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractSocketTest.java, + return SocketTestPermutation.INSTANCE.socket();, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractClientSocketTest.java, + return SocketTestPermutation.INSTANCE.clientSocket();, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java, + return SocketTestPermutation.INSTANCE.datagram();, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractServerSocketTest.java, + return SocketTestPermutation.INSTANCE.serverSocket();, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractSocketTest.java, + return SocketTestPermutation.INSTANCE.socket();, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java, +import io.netty.bootstrap.AbstractBootstrap;, +import java.util.Arrays;, +public class SocketTestPermutation {, + static final SocketTestPermutation INSTANCE = new SocketTestPermutation();, +, + protected static final int BOSSES = 2;, + protected
[+++ b/NOTICE.txt, + * NOTICE:, + * license/NOTICE.harmony.txt, +++ b/NOTICE.txt, + * NOTICE:, + * license/NOTICE.harmony.txt, +++ b/license/NOTICE.harmony.txt, +Apache Harmony, +, +Copyright 2006, 2010 The Apache Software Foundation., +, +This product includes software developed at, +The Apache Software Foundation (http://www.apache.org/).]
[+++ b/license/LICENSE.webbit.txt, +(BSD License: http://www.opensource.org/licenses/bsd-license), +, +Copyright (c) 2011, Joe Walnes, Aslak Hellesy and contributors, +All rights reserved., +, +Redistribution and use in source and binary forms, with or , +without modification, are permitted provided that the , +following conditions are met:, +, +* Redistributions of source code must retain the above , + copyright notice, this list of conditions and the , + following disclaimer., +, +* Redistributions in binary form must reproduce the above, + copyright notice, this list of conditions and the , + following disclaimer in the documentation and/or other, + materials provided with the
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + assert readStatus != ReadStatus.IDLE;]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + * Returns the maximum age of this {@link Cookie} in seconds or {@link Long#MIN_VALUE} if unspecified, + * If {@link Long#MIN_VALUE} is specified, this {@link Cookie} will be removed when the, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + * Returns the maximum age of this {@link Cookie} in seconds or {@link Long#MIN_VALUE} if unspecified, + * If {@link Long#MIN_VALUE} is specified, this {@link Cookie} will be removed when the, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java, + private long maxAge = Long.MIN_VALUE;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + * Returns the maximum age of this {@link Cookie} in seconds or {@link Long#MIN_VALUE} if unspecified, + * If {@link
[+++ b/common/src/main/java/io/netty/util/internal/AppendableCharSequence.java, + if (length < 1) {, + throw new IllegalArgumentException("length: " + length + " (length: >= 1)");, + }]
[+++ b/pom.xml, + <requireJavaVersion>, + <!-- Enforce JDK 1.7 (and not 1.8+) for compilation. -->, + <!-- See: https://github.com/netty/netty/issues/3548 -->, + <version>[1.7.0, 1.8.0)</version>, + </requireJavaVersion>, + <!-- Enforce JDK 1.7+ for compilation. -->, + <!-- This is needed because of java.util.zip.Deflater and NIO UDP multicast. -->]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + private static final SSLEngineResult NEED_UNWRAP_OK = new SSLEngineResult(OK, NEED_UNWRAP, 0, 0);, + private static final SSLEngineResult NEED_UNWRAP_CLOSED = new SSLEngineResult(CLOSED, NEED_UNWRAP, 0, 0);, + private static final SSLEngineResult NEED_WRAP_OK = new SSLEngineResult(OK, NEED_WRAP, 0, 0);, + private static final SSLEngineResult NEED_WRAP_CLOSED = new SSLEngineResult(CLOSED, NEED_WRAP, 0, 0);, + private static final SSLEngineResult CLOSED_NOT_HANDSHAKING = new SSLEngineResult(CLOSED, NOT_HANDSHAKING, 0, 0);, +, + return CLOSED_NOT_HANDSHAKING;, + if (handshakeStatus == NEED_UNWRAP) {, + if (!handshakeFinished) {, + return NEED_UNWRAP_OK;, + }, + if (engineClosed) {, + return NEED_UNWRAP_CLOSED;, + }, + return CLOSED_NOT_HANDSHAKING;, + if (handshakeStatus == NEED_WRAP) {,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, + payloadBuffer = null;, + payloadBuffer = null;, + framePayload = null;, + framePayload = null;, + framePayload = null;, + framePayload = null;, + framePayload = null;, + framePayload = null;, +, + @Override, + public void channelInactive(ChannelHandlerContext ctx) throws Exception {, + super.channelInactive(ctx);, +, + // release all not complete frames data to prevent leaks., + // https://github.com/netty/netty/issues/1874, + if (framePayload != null) {, + framePayload.release();, + }, + if (payloadBuffer != null) {, + payloadBuffer.release();, + }, + }]
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, + logger.warn("Failed to enumerate network interfaces", e);]
[+++ b/src/main/java/org/jboss/netty/channel/group/CombinedIterator.java, +/*, + * Copyright 2009 Red Hat, Inc., + *, + * Red Hat licenses this file to you under the Apache License, version 2.0, + * (the "License"); you may not use this file except in compliance with the, + * License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or
[+++ b/pom.xml, + <mkdir dir="${project.build.directory}" />, + <echo message="${project.version}, r${buildNumber}" file="${project.build.directory}/version.txt" />]
[+++ b/common/src/test/java/io/netty/util/AsciiStringCharacterTest.java, +, + @Test, + public void testSubStringHashCode() {, + //two "123"s, + assertEquals(AsciiString.hashCode("123"), AsciiString.hashCode("a123".substring(1)));, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyJZlibDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyJZlibDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyJZlibEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyJZlibDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyJZlibEncoder.java, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyJZlibDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyJZlibEncoder.java, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyZlibEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyJZlibDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyJZlibEncoder.java, +++ /dev/null, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyZlibEncoder.java, +++ b/handler/src/main/java/io/netty/handler/execution/ExecutionHandler.java, + private final boolean handleUpstream;, + * Creates a new instance with the specified {@link Executor} which only handles upstream events., + this(executor, false, true);, + }, + , + /**, + * Use {@link #ExecutionHandler(Executor, boolean, boolean)}, + * , + * {@link Deprecated}, + */, + @Deprecated, + public ExecutionHandler(Executor executor, boolean handleDownstream) {, +
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeChannelBufferTest.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeChannelBufferTest.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + * Gets the maximum length for any frame's payload., + *, + * @return The maximum length for a frame's payload]
[+++ /dev/null, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/example/http/HttpClientPipelineFactory.java, +/*, + * JBoss, Home of Professional Open Source, + * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors, + * by the @authors tag. See the copyright.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version., +
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslServerContext.java, +, + X509Certificate[] issuers = manager.getAcceptedIssuers();, + if (issuers != null && issuers.length > 0) {, + long bio = 0;, + try {, + bio = toBIO(issuers);, + if (!SSLContext.setCACertificateBio(ctx, bio)) {, + throw new SSLException("unable to setup accepted issuers for trustmanager " + manager);, + }, + } finally {, + freeBio(bio);, + }, + }, + } catch (SSLException e) {, + throw e;, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslServerContext.java, +, + X509Certificate[] issuers = manager.getAcceptedIssuers();, + if (issuers != null && issuers.length > 0) {, + long bio = 0;, + try {, + bio = toBIO(issuers);,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + private File file;, + if (!file.createNewFile()) {, + throw new IOException("file exists already: " + file);, + }, + setCompleted();, + setCompleted();, + setCompleted();, + if (!file.delete()) {, + logger.warn("Failed to delete: {}", file);, + }, + setCompleted();, + if (!file.delete()) {, + logger.warn("Failed to delete: {}", file);, + }, + if (!file.delete()) {, + logger.warn("Failed to delete: {}", file);, + }, + if (!dest.delete()) {, + logger.warn("Failed to delete: {}", dest);, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + private File file;, + if (!file.createNewFile()) {, + throw new IOException("file exists already: " + file);, + }, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + } catch (IOException e) {, + logger.warn("Failed to close a file.", e);]
[+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObjectAggregator.java]
[+++ b/pom.xml, + <version>1.4.1.Final</version>]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java, +import static io.netty.handler.codec.http2.Http2Error.*;, +import static io.netty.handler.codec.http2.Http2Exception.*;, +import static io.netty.util.AsciiString.*;, +, + public boolean contains(CharSequence name, CharSequence value, boolean caseInsensitive) {, + return contains(name, value, caseInsensitive? CASE_INSENSITIVE_HASHER : CASE_SENSITIVE_HASHER);, + }, +, + @Override, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java, +import static io.netty.handler.codec.http2.Http2Error.*;, +import static io.netty.handler.codec.http2.Http2Exception.*;, +import static io.netty.util.AsciiString.*;, +, + public boolean contains(CharSequence name, CharSequence value, boolean caseInsensitive) {, + return contains(name, value, caseInsensitive? CASE_INSENSITIVE_HASHER : CASE_SENSITIVE_HASHER);, + }, +, + @Override, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/EmptyHttp2Headers.java, +, + @Override, + public boolean contains(CharSequence name, CharSequence value, boolean caseInsensitive) {, + return false;, + }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java, +import static io.netty.handler.codec.http2.Http2Error.*;, +import static io.netty.handler.codec.http2.Http2Exception.*;, +import
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/nio/oio/NioOioDatagramMulticastTest.java, +/*, + * Copyright 2011 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF
[+++ b/testsuite-osgi/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + final boolean isWritable(DefaultHttp2FrameStream stream) {, + Http2Stream s = stream.stream;, + return s != null && connection().remote().flowController().isWritable(s);, + }, +, + volatile Http2Stream stream;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + final boolean isWritable(DefaultHttp2FrameStream stream) {, + Http2Stream s = stream.stream;, + return s != null && connection().remote().flowController().isWritable(s);, + }, +, + volatile Http2Stream stream;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + Http2MultiplexCodecStream s = (Http2MultiplexCodecStream) stream;, +, + if (s.channel != null) {, + ChannelFuture future = ctx.channel().eventLoop().register(new DefaultHttp2StreamChannel(s, false));, + DefaultHttp2StreamChannel channel = s.channel;, + private boolean initialWritability(DefaultHttp2FrameStream stream) {, + // If the stream id is not valid yet we will
[+++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java, + // We never try to free the buffer if it was provided by the end-user as we not know if this is an duplicate or, + // an slice. This is done to prevent an IllegalArgumentException when using Java9 as Unsafe.invokeCleaner(...), + // will check if the given buffer is either an duplicate or slice and in this case throw an, + // IllegalArgumentException., + //, + // See http://hg.openjdk.java.net/jdk9/hs-demo/jdk/file/0d2ab72ba600/src/jdk.unsupported/share/classes/, + // sun/misc/Unsafe.java#l1250, + //, + // We also call slice() explicitly here to preserve behaviour with previous netty releases., + this(alloc, initialBuffer.slice(), maxCapacity, false);, +
[+++ b/buffer/src/main/java/io/netty/buffer/IllegalBufferAccessException.java, + * {@link Buf#release()} } already., +++ b/buffer/src/main/java/io/netty/buffer/IllegalBufferAccessException.java, + * {@link Buf#release()} } already., +++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java, +import io.netty.handler.codec.http.DefaultHttpContent;, +import io.netty.handler.codec.http.DefaultHttpRequest;, +import io.netty.handler.codec.http.HttpHeaders;, +import io.netty.handler.codec.http.HttpMethod;, +import io.netty.handler.codec.http.HttpVersion;, +import static org.junit.Assert.*;, + final String body =, + "--" + boundary + "\r\n" +, +++ b/buffer/src/main/java/io/netty/buffer/IllegalBufferAccessException.java, + * {@link Buf#release()} } already., +++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java, +import io.netty.handler.codec.http.DefaultHttpContent;, +import io.netty.handler.codec.http.DefaultHttpRequest;, +import io.netty.handler.codec.http.HttpHeaders;, +import io.netty.handler.codec.http.HttpMethod;, +import io.netty.handler.codec.http.HttpVersion;, +import static org.junit.Assert.*;, + final String body =, + "--" + boundary + "\r\n" +, +++ b/example/src/main/java/io/netty/example/udt/util/UtilThreadFactory.java, + return new Thread(runnable, name + '-' + counter.getAndIncrement());, +++ b/buffer/src/main/java/io/netty/buffer/IllegalBufferAccessException.java, + * {@link Buf#release()} } already., +++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java,
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + doRegister();, + * Sub-classes may override this method, + protected void doRegister() throws Exception {, + // NOOP, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + doRegister();, + * Sub-classes may override this method, + protected void doRegister() throws Exception {, + // NOOP, +++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java, + protected void doRegister() throws Exception {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + doRegister();, + * Sub-classes may override this method, + protected void doRegister() throws Exception {, + // NOOP, +++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java, + protected void doRegister() throws Exception {, +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, + protected void doRegister() throws Exception {, + // Always call peer.eventLoop().execute() even if peer.eventLoop().inEventLoop() is
[+++ b/common/src/main/java/io/netty/util/DomainNameMapping.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, + return memory.duplicate();]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpObject.java, +import io.netty.handler.codec.DecoderResult;, + private DecoderResult decodeResult = DecoderResult.SUCCESS;, + public DecoderResult getDecodeResult() {, + public void setDecodeResult(DecoderResult result) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpObject.java, +import io.netty.handler.codec.DecoderResult;, + private DecoderResult decodeResult = DecoderResult.SUCCESS;, + public DecoderResult getDecodeResult() {, + public void setDecodeResult(DecoderResult result) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunk.java, +import io.netty.handler.codec.DecoderResult;, + public DecoderResult getDecodeResult() {, + return DecoderResult.SUCCESS;, + public void setDecodeResult(DecoderResult result) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpObject.java, +import io.netty.handler.codec.DecoderResult;, + private DecoderResult decodeResult = DecoderResult.SUCCESS;, + public DecoderResult getDecodeResult() {, + public void setDecodeResult(DecoderResult result) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunk.java, +import io.netty.handler.codec.DecoderResult;, + public DecoderResult getDecodeResult() {, + return DecoderResult.SUCCESS;, + public void setDecodeResult(DecoderResult result) {,
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, +import io.netty.buffer.ChannelBuf;, + @Override, + public void freeInboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {, + decoder.freeInboundBuffer(ctx, buf);, + }, +, + @Override, + public void freeOutboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {, + encoder.freeOutboundBuffer(ctx, buf);, + }, +, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, +import io.netty.buffer.ChannelBuf;, + @Override, + public void freeInboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {, + decoder.freeInboundBuffer(ctx, buf);, + }, +, + @Override, + public void freeOutboundBuffer(ChannelHandlerContext ctx, ChannelBuf buf) throws Exception {, + encoder.freeOutboundBuffer(ctx, buf);, + }, +, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java, + buf.unsafe().free();, + buf.unsafe().free();]
[+++ b/codec/src/test/java/io/netty/handler/codec/compression/Bzip2DecoderTest.java, + msg.release();, + uncompressed.release();]
[+++ b/example/pom.xml, +<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance", + xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">, +]
[+++ b/all/pom.xml, + <artifactId>maven-jxr-plugin</artifactId>, + <executions>, + <execution>, + <id>generate-xref</id>, + <phase>package</phase>, + <goals>, + <goal>jxr</goal>, + </goals>, + </execution>, + </executions>, + <configuration>, + <skip>${quickbuild}</skip>, + <linkJavadoc>true</linkJavadoc>, + <destDir>${project.build.directory}/xref</destDir>, + <javadocDir>${project.build.directory}/api</javadocDir>, + <docTitle>Netty Source Xref (${project.version})</docTitle>, + <windowTitle>Netty Source Xref (${project.version})</windowTitle>, + </configuration>, + <dependencies>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-build</artifactId>, + <version>10</version>, + </dependency>, + </dependencies>, + </plugin>, + <plugin>]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +import io.netty.channel.ChannelConfig;, + protected final void doBeginRead() throws Exception {, + AbstractEpollUnsafe unsafe = (AbstractEpollUnsafe) unsafe();, + unsafe.readPending = true;, +, + // If EPOLL ET mode is enabled and auto read was toggled off on the last read loop then we may not be notified, + // again if we didn't consume all the data. So we force a read operation here if there maybe more data., + if (unsafe.maybeMoreDataToRead) {, + unsafe.epollInReady();, + }, + protected boolean maybeMoreDataToRead;, + final void epollInReadAttempted() {, + readPending = maybeMoreDataToRead = false;, + }, +, + final void
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java, +import io.netty.channel.ChannelInboundConsumingHandler;, + private static class CustomTextFrameHandler extends ChannelInboundConsumingHandler<TextWebSocketFrame> {, + public void consume(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception {, + assertNull(content);, + content = "processed: " + msg.text();, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java, +import io.netty.channel.ChannelInboundConsumingHandler;, + private static class CustomTextFrameHandler extends ChannelInboundConsumingHandler<TextWebSocketFrame> {, + public void consume(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception {, + assertNull(content);, + content = "processed: " + msg.text();, +++ b/example/src/main/java/io/netty/example/applet/AppletDiscardServer.java, +import io.netty.channel.ChannelInboundConsumingHandler;, + private static final class DiscardServerHandler extends ChannelInboundConsumingHandler<ByteBuf> {, + public void consume(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {, + System.out.println("Received: " + msg.toString(CharsetUtil.UTF_8));, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandlerTest.java, +import io.netty.channel.ChannelInboundConsumingHandler;, + private static class CustomTextFrameHandler
[+++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + public boolean isFreed() {, + return freed;, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + public boolean isFreed() {, + return freed;, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java, + public boolean isFreed() {, + return buffer.isFreed();, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + public boolean isFreed() {, + return freed;, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java, + public boolean isFreed() {, + return buffer.isFreed();, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java, + public boolean isFreed() {, + return buffer.isFreed();, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, + public boolean isFreed() {, + return freed;, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java,
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, + if (inputLength == 0 || in.readerIndex() - inIndex + in.readableBytes() < maxLength - 5) {, + length = in.readUnsignedByte();, + length = in.readUnsignedByte(), + | (in.readUnsignedByte() << 8);, + length = in.readUnsignedByte(), + | (in.readUnsignedByte() << 8), + | (in.readUnsignedByte() << 16);, + length = in.readUnsignedByte(), + | (in.readUnsignedByte() << 8), + | (in.readUnsignedByte() << 16), + | (in.readUnsignedByte() << 24);, + int length = 4 + ((tag & 0x01c) >> 2);, + int offset = 1 + ((tag & 0x0e0) << 8 | in.readUnsignedByte());, + int offset = 1 + (in.readUnsignedByte() | in.readUnsignedByte() << 8);,
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + void forwardBufferContentAndRemove(, + final DefaultChannelHandlerContext forwardPrev, final DefaultChannelHandlerContext forwardNext) {, + try {, + } finally {, + flags |= FLAG_REMOVED;, +, + // Free all buffers before completing removal., + if (!channel.isRegistered()) {, + freeHandlerBuffersAfterRemoval();, + }, + }, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + void forwardBufferContentAndRemove(, + final DefaultChannelHandlerContext forwardPrev, final DefaultChannelHandlerContext forwardNext) {, + try {, + } finally {, + flags |= FLAG_REMOVED;, +, + // Free all buffers before completing removal., + if (!channel.isRegistered()) {, + freeHandlerBuffersAfterRemoval();, + }, + }, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, + ctx.forwardBufferContentAndRemove(ctxPrev, ctxNext);]
[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultThreadFactory.java, +import io.netty.util.internal.ObjectUtil;, + private final ThreadGroup threadGroup;, + public DefaultThreadFactory(String poolName, boolean daemon, int priority, ThreadGroup threadGroup) {, + this.threadGroup = ObjectUtil.checkNotNull(threadGroup, "threadGroup");, + }, +, + public DefaultThreadFactory(String poolName, boolean daemon, int priority) {, + this(poolName, daemon, priority, Thread.currentThread().getThreadGroup());, + // TODO: Once we can break the API we should add ThreadGroup to the arguments of this method., + return new FastThreadLocalThread(threadGroup, r, name);]
[+++ b/codec/src/main/java/io/netty/handler/codec/redis/Command.java, + public static final byte[] ARGS_PREFIX = "*".getBytes();, + public static final byte[] CRLF = "\r\n".getBytes();, + public static final byte[] BYTES_PREFIX = "$".getBytes();, + public static final byte[] EMPTY_BYTES = new byte[0];, + public static final byte[] NEG_ONE_AND_CRLF = convertWithCRLF(-1);, +++ b/codec/src/main/java/io/netty/handler/codec/redis/Command.java, + public static final byte[] ARGS_PREFIX = "*".getBytes();, + public static final byte[] CRLF = "\r\n".getBytes();, + public static final byte[] BYTES_PREFIX = "$".getBytes();, + public static final byte[] EMPTY_BYTES = new byte[0];, + public static final byte[] NEG_ONE_AND_CRLF = convertWithCRLF(-1);, +++ b/codec/src/main/java/io/netty/handler/codec/redis/RedisDecoder.java, + * @return content , + * , + * @param
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramUnicastTest.java, + Channel sc = null;, + Channel cc = null;, +, + try {, + sc = setupServerChannel(sb, bytes, latch);, + } finally {, + // release as we used buf.retain() before, + buf.release();, + closeChannel(cc);, + closeChannel(sc);, + }, + try {, + } finally {, + }, + Channel sc = null;, + final CountDownLatch latch = new CountDownLatch(count);, + sc = setupServerChannel(sb, bytes, latch);, + assertTrue("NotYetConnectedException expected, got: " + future.cause(),, + future.cause() instanceof NotYetConnectedException);, + closeChannel(cc);, + closeChannel(sc);, +, + private static void closeChannel(Channel channel) throws Exception {, + if (channel != null)
[+++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, + private final byte[] memoryMap;, + private final byte[] depthMap;, + memoryMap = new byte[maxSubpageAllocs << 1];, + depthMap = new byte[memoryMap.length];, + memoryMap[memoryMapIndex] = (byte) d;, + depthMap[memoryMapIndex] = (byte) d;, + memoryMapIndex ++;, + depthMap = null;, + final int freeBytes = this.freeBytes;, + int d = maxOrder - (log2(normCapacity) - pageShifts);, +, + final PoolSubpage<T>[] subpages = this.subpages;, + final int pageSize = this.pageSize;, +, + return memoryMap[id];, + memoryMap[id] = val;, + return depthMap[id];]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + private static final boolean SUPPORTS_OCSP;, + SUPPORTS_OCSP = doesSupportOcsp();, + SUPPORTS_OCSP = false;, + private static boolean doesSupportOcsp() {, + boolean supportsOcsp = false;, + if (version() >= 0x10002000L) {, + long sslCtx = -1;, + try {, + sslCtx = SSLContext.make(SSL.SSL_PROTOCOL_TLSV1_2, SSL.SSL_MODE_SERVER);, + SSLContext.enableOcsp(sslCtx, false);, + supportsOcsp = true;, + } catch (Exception ignore) {, + // ignore, + } finally {, + if (sslCtx != -1) {, + SSLContext.free(sslCtx);, + }, + }, + }, + return supportsOcsp;, + }, + return SUPPORTS_OCSP;]
[+++ b/example/src/main/java/io/netty/example/filetransfer/FileServer.java, + ctx.writeAndFlush("Not a file: " + file + '\n');, + ctx.writeAndFlush("\n");, + ctx.writeAndFlush("File not found: " + file + '\n');, +++ b/example/src/main/java/io/netty/example/filetransfer/FileServer.java, + ctx.writeAndFlush("Not a file: " + file + '\n');, + ctx.writeAndFlush("\n");, + ctx.writeAndFlush("File not found: " + file + '\n');, +++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClient.java, + ch.writeAndFlush(request);, +++ b/example/src/main/java/io/netty/example/filetransfer/FileServer.java, + ctx.writeAndFlush("Not a file: " + file + '\n');, + ctx.writeAndFlush("\n");, + ctx.writeAndFlush("File not found: " + file + '\n');, +++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClient.java, + ch.writeAndFlush(request);, +++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadClient.java, + } else {, + channel.flush();, + } else {, + channel.flush();, +++ b/example/src/main/java/io/netty/example/filetransfer/FileServer.java, + ctx.writeAndFlush("Not a file: " + file + '\n');,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultLastHttpContent.java, +import io.netty.handler.codec.AsciiString;, + if (AsciiString.equalsIgnoreCase(HttpHeaders.Names.CONTENT_LENGTH, name) ||, + AsciiString.equalsIgnoreCase(HttpHeaders.Names.TRANSFER_ENCODING, name) ||, + AsciiString.equalsIgnoreCase(HttpHeaders.Names.TRAILER, name)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultLastHttpContent.java, +import io.netty.handler.codec.AsciiString;, + if (AsciiString.equalsIgnoreCase(HttpHeaders.Names.CONTENT_LENGTH, name) ||, + AsciiString.equalsIgnoreCase(HttpHeaders.Names.TRANSFER_ENCODING, name) ||, + AsciiString.equalsIgnoreCase(HttpHeaders.Names.TRAILER, name)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, +import io.netty.handler.codec.AsciiString;, + !AsciiString.equalsIgnoreCase(HttpHeaders.Values.IDENTITY, contentEncoding)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultLastHttpContent.java, +import io.netty.handler.codec.AsciiString;, + if (AsciiString.equalsIgnoreCase(HttpHeaders.Names.CONTENT_LENGTH, name) ||, + AsciiString.equalsIgnoreCase(HttpHeaders.Names.TRANSFER_ENCODING, name) ||, + AsciiString.equalsIgnoreCase(HttpHeaders.Names.TRAILER, name)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, +import io.netty.handler.codec.AsciiString;, + !AsciiString.equalsIgnoreCase(HttpHeaders.Values.IDENTITY, contentEncoding)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, + if (connection != null && AsciiString.equalsIgnoreCase(CLOSE_ENTITY, connection)) {, + return !AsciiString.equalsIgnoreCase(CLOSE_ENTITY, connection);, + return AsciiString.equalsIgnoreCase(KEEP_ALIVE_ENTITY, connection);, + if (AsciiString.equalsIgnoreCase(CONTINUE_ENTITY, value)) {, + if (AsciiString.equalsIgnoreCase(value, CHUNKED_ENTITY)) {, + * @deprecated
[+++ b/pom.xml, + <artifactId>maven-gpg-plugin</artifactId>, + <version>1.4</version>, + <executions>, + <execution>, + <id>sign-artifacts</id>, + <phase>verify</phase>, + <goals>, + <goal>sign</goal>, + </goals>, + </execution>, + </executions>, + </plugin>, + <plugin>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java, + int wsPort = wsURL.getPort();, + .add(Names.HOST, wsURL.getHost() + ':' + wsPort);]
[+++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, +import io.netty.channel.ChannelPromise;, + ChannelPromise initPromise = init(channel);, + if (initPromise.cause() != null) {, + return initPromise;, + ChannelPromise initPromise = init(channel);, + if (initPromise.cause() != null) {, + return initPromise;, + private ChannelPromise init(Channel channel) {, + ChannelPromise promise = channel.newPromise();, + try {, + group().register(channel, promise);, + } catch (Throwable t) {, + promise.setFailure(t);, + }, +, + if (promise.cause() != null) {, + if (channel.isRegistered()) {, + channel.close();, + } else {, + channel.unsafe().closeForcibly();, + }, + }, +, + // If we are here and the promise is not failed, it's one of the
[+++ b/example/pom.xml, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport-rxtx</artifactId>, + <version>${project.version}</version>, + </dependency>, +++ b/example/pom.xml, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport-rxtx</artifactId>, + <version>${project.version}</version>, + </dependency>, +++ b/example/src/main/java/io/netty/example/rxtx/RxtxClient.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software,
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java, + private final DnsNameResolverBuilder dnsResolverBuilder;, + public DnsAddressResolverGroup(DnsNameResolverBuilder dnsResolverBuilder) {, + this.dnsResolverBuilder = dnsResolverBuilder.copy();, + }, +, + this(new DnsNameResolverBuilder());, + dnsResolverBuilder.channelType(channelType).nameServerProvider(nameServerProvider);, + this(new DnsNameResolverBuilder());, + dnsResolverBuilder.channelFactory(channelFactory).nameServerProvider(nameServerProvider);, + // we don't really need to pass channelFactory and nameServerProvider separately,, + // but still keep this to ensure backward compatibility with (potentially) override methods, + return newResolver((EventLoop) executor,, + dnsResolverBuilder.channelFactory(),, + dnsResolverBuilder.nameServerProvider());, + // once again, channelFactory and nameServerProvider are most probably set in builder already,, + // but I do reassign them again to avoid corner cases with override methods, + return dnsResolverBuilder.eventLoop(eventLoop), +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java, + private
[+++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + return (ByteBuffer) buffer.duplicate().position(index).limit(index + length);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + return (ByteBuffer) buffer.duplicate().position(index).limit(index + length);, +++ b/buffer/src/test/java/io/netty/buffer/BigEndianDirectByteBufTest.java, + buffer = newDirectBuffer(length);, +, + protected ByteBuf newDirectBuffer(int length) {, + return new UnpooledDirectByteBuf(UnpooledByteBufAllocator.DEFAULT, length, Integer.MAX_VALUE);, + }, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + return (ByteBuffer) buffer.duplicate().position(index).limit(index + length);, +++ b/buffer/src/test/java/io/netty/buffer/BigEndianDirectByteBufTest.java, + buffer = newDirectBuffer(length);, +, + protected ByteBuf newDirectBuffer(int length) {, + return new UnpooledDirectByteBuf(UnpooledByteBufAllocator.DEFAULT, length, Integer.MAX_VALUE);, + }, +++ b/buffer/src/test/java/io/netty/buffer/BigEndianUnsafeDirectByteBufTest.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you
[+++ b/common/src/main/java/io/netty/util/NetworkConstants.java, +import java.io.BufferedReader;, +import java.io.FileReader;, + * The SOMAXCONN value of the current machine. If failed to get the value, 3072 is used as a, + * default value., + */, + public static final int SOMAXCONN;, +, + /**, +, + int somaxconn = 3072;, + BufferedReader in = null;, + try {, + in = new BufferedReader(new FileReader("/proc/sys/net/core/somaxconn"));, + somaxconn = Integer.parseInt(in.readLine());, + } catch (Exception e) {, + // Failed to get SOMAXCONN, + } finally {, + if (in != null) {, + try {, + in.close();, + } catch (Exception e) {, +
[+++ b/src/docbook/module/architecture.xml, + expanded on demand, just like <classname>StringBuffer</classname>.]
[+++ b/handler/src/main/java/io/netty/handler/ssl/util/BouncyCastleSelfSignedCertGenerator.java, +import java.util.Date;, +import static io.netty.handler.ssl.util.SelfSignedCertificate.newSelfSignedCertificate;, + static String[] generate(String fqdn, KeyPair keypair, SecureRandom random, Date notBefore, Date notAfter), + throws Exception {, + owner, new BigInteger(64, random), notBefore, notAfter, owner, keypair.getPublic());, +++ b/handler/src/main/java/io/netty/handler/ssl/util/BouncyCastleSelfSignedCertGenerator.java, +import java.util.Date;, +import static io.netty.handler.ssl.util.SelfSignedCertificate.newSelfSignedCertificate;, + static String[] generate(String fqdn, KeyPair keypair, SecureRandom random, Date notBefore, Date notAfter), + throws Exception {, + owner, new BigInteger(64, random), notBefore, notAfter, owner, keypair.getPublic());, +++ b/handler/src/main/java/io/netty/handler/ssl/util/OpenJdkSelfSignedCertGenerator.java, +import java.util.Date;, + static String[] generate(String fqdn, KeyPair keypair, SecureRandom random, Date notBefore, Date notAfter), + throws Exception {, + info.set(X509CertInfo.VALIDITY, new CertificateValidity(notBefore, notAfter));, +++ b/handler/src/main/java/io/netty/handler/ssl/util/BouncyCastleSelfSignedCertGenerator.java, +import java.util.Date;, +import static io.netty.handler.ssl.util.SelfSignedCertificate.newSelfSignedCertificate;,
[+++ b/pom.xml, + <testJavaHome>${env.JAVA_HOME}</testJavaHome>, + <jvm>${testJavaHome}/bin/java</jvm>]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2BitReader.java, + * arbitrary length (up to 32 bits), and bit aligned 32-bit integers. A single byte, + * Maximum count of possible readable bytes to check., + */, + private static final int MAX_COUNT_OF_READABLE_BYTES = Integer.MAX_VALUE >>> 3;, +, + /**, + * The {@link ByteBuf} from which to read data., + */, + private ByteBuf in;, +, + /**, + private long bitBuffer;, + * Set the {@link ByteBuf} from which to read data., + */, + void setByteBuf(ByteBuf in) {, + this.in = in;, + }, +, + /**, + * Reads up to 32
[+++ b/common/src/main/java/io/netty/util/internal/logging/CommonsLogger.java, + *, + * @deprecated Please use {@link Log4J2Logger} or {@link Log4JLogger} or, + * {@link Slf4JLogger}., +@Deprecated, +++ b/common/src/main/java/io/netty/util/internal/logging/CommonsLogger.java, + *, + * @deprecated Please use {@link Log4J2Logger} or {@link Log4JLogger} or, + * {@link Slf4JLogger}., +@Deprecated, +++ b/common/src/main/java/io/netty/util/internal/logging/CommonsLoggerFactory.java, + *, + * @deprecated Please use {@link Log4J2LoggerFactory} or {@link Log4JLoggerFactory} or, + * {@link Slf4JLoggerFactory}., +@Deprecated]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + private volatile int refCnt = 1;]
[+++ b/pom.xml, +, +, + <!-- Used for NIO. 2 -->, +++ b/pom.xml, +, +, + <!-- Used for NIO. 2 -->, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + private boolean inFlushNow;, + public final void flushNow() {, + doFlushByteBuffer(out);, +, + protected void doFlushByteBuffer(ByteBuf buf) throws Exception {, + private void notifyFlushFutures() {, + private void notifyFlushFutures(Throwable cause) {, +++ b/pom.xml, +, +, + <!-- Used for NIO. 2 -->, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + private boolean inFlushNow;, + public final void flushNow() {, + doFlushByteBuffer(out);, +, + protected void doFlushByteBuffer(ByteBuf buf) throws Exception {, + private void notifyFlushFutures() {, + private void notifyFlushFutures(Throwable
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, + // used as a return value to indicate that we haven't yet read our full preamble, + private static final int PREAMBLE_NOT_FULL = -1;, +, + private State state = State.READY;, + private byte tag;, +, + private static enum State {, + READY,, + READING_PREAMBLE,, + READING_TAG,, + READING_LITERAL,, + READING_COPY, + }, + state = State.READY;, + tag = 0;, + public void decode(ByteBuf in, ByteBuf out) {, + while (in.isReadable()) {, + switch (state) {, + case READY:, + state = State.READING_PREAMBLE;, + case READING_PREAMBLE:, + int uncompressedLength = readPreamble(in);, + if (uncompressedLength
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, +import io.netty.util.ReferenceCounted;, +, + private boolean closed;, + /**, + * To preserve backwards compatibility (which didn't transfer ownership) we support a conditional flag which, + * indicates if {@link #buffer} should be released when this {@link InputStream} is closed., + * However in future releases ownership should always be transferred and callers of this class should call, + * {@link ReferenceCounted#retain()} if necessary., + */, + private boolean releaseOnClose;, + * @param buffer The buffer which provides the content for this {@link InputStream}., + * @param buffer The buffer which provides the content for this {@link
[+++ b/transport/src/main/java/io/netty/channel/nio/SelectedSelectionKeySet.java, +import java.util.NoSuchElementException;, + return new Iterator<SelectionKey>() {, + private int idx;, +, + @Override, + public boolean hasNext() {, + return idx < size;, + }, +, + @Override, + public SelectionKey next() {, + if (!hasNext()) {, + throw new NoSuchElementException();, + }, + return keys[idx++];, + }, + };, +++ b/transport/src/main/java/io/netty/channel/nio/SelectedSelectionKeySet.java, +import java.util.NoSuchElementException;, + return new Iterator<SelectionKey>() {, + private int idx;, +, + @Override, + public boolean hasNext() {, + return idx < size;, + }, +, + @Override, + public SelectionKey next() {, + if (!hasNext()) {, + throw new NoSuchElementException();, + },
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java, + setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + setBinaryData(binaryData);, + setFinalFragment(finalFragment);, + setRsv(rsv);, + setBinaryData(binaryData);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java, + setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + setBinaryData(binaryData);, + setFinalFragment(finalFragment);, + setRsv(rsv);, + setBinaryData(binaryData);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java, + setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + setFinalFragment(finalFragment);, + setRsv(rsv);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java, + setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + setBinaryData(binaryData);, + setFinalFragment(finalFragment);, + setRsv(rsv);, + setBinaryData(binaryData);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java, + setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + setFinalFragment(finalFragment);, + setRsv(rsv);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/ContinuationWebSocketFrame.java, + setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + setBinaryData(binaryData);, + setFinalFragment(finalFragment);, + setRsv(rsv);, + setBinaryData(binaryData);, + setFinalFragment(finalFragment);, + setRsv(rsv);, + setBinaryData(binaryData);, + setFinalFragment(finalFragment);, + setRsv(rsv);, + setText(text);, + if (getBinaryData() == null) {, + return getBinaryData().toString(CharsetUtil.UTF_8);, + setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + setBinaryData(ChannelBuffers.copiedBuffer(text, CharsetUtil.UTF_8));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java, + setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + setBinaryData(binaryData);, + setFinalFragment(finalFragment);, +
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java, + * Be aware this <strong>won't</strong> be called with timeout / cancel / transport exceptions., + *, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsCache.java, + * Be aware this <strong>won't</strong> be called with timeout / cancel / transport exceptions., + *, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, + /**, + * Returns {@code true} if the {@link Throwable} was caused by an timeout or transport error., + * These methods can be used on the {@link Future#cause()} that is returned by the various methods exposed by this, + * {@link DnsNameResolver}., + */, + public static boolean isTransportOrTimeoutError(Throwable cause) {, + return cause != null &&
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java, + *, + * Note that by default, validation of the checksum header in each chunk is, + * DISABLED for performance improvements. If performance is less of an issue,, + * or if you would prefer the safety that checksum validation brings, please, + * use the {@link #SnappyFramedDecoder(boolean)} constructor with the argument, + * set to {@code true}., + * turned OFF. To turn checksum validation on, please use the alternate, + * {@link #SnappyFramedDecoder(boolean)} constructor.]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterialManager.java, +import io.netty.buffer.ByteBufAllocator;, +import static io.netty.handler.ssl.ReferenceCountedOpenSslContext.freeBio;, +import static io.netty.handler.ssl.ReferenceCountedOpenSslContext.newBIO;, +import static io.netty.handler.ssl.ReferenceCountedOpenSslContext.toBIO;, +, + long keyCertChainBio2 = 0;, +, + // Only encode one time, + PemEncoded encoded = PemX509Certificate.toPEM(ByteBufAllocator.DEFAULT, true, certificates);, + try {, + keyCertChainBio = newBIO(encoded.content().retainedSlice());, + keyCertChainBio2 = newBIO(encoded.content().retainedSlice());, +, + keyBio = toBIO(key);, + SSL.setCertificateChainBio(ssl, keyCertChainBio2, false);, + } finally {, + encoded.release();, + }, + freeBio(keyBio);, + freeBio(keyCertChainBio);, + freeBio(keyCertChainBio2);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslKeyMaterialManager.java, +import io.netty.buffer.ByteBufAllocator;, +import static io.netty.handler.ssl.ReferenceCountedOpenSslContext.freeBio;, +import static io.netty.handler.ssl.ReferenceCountedOpenSslContext.newBIO;, +import static io.netty.handler.ssl.ReferenceCountedOpenSslContext.toBIO;, +, + long keyCertChainBio2 = 0;, +, + // Only encode one time, + PemEncoded encoded = PemX509Certificate.toPEM(ByteBufAllocator.DEFAULT, true,
[+++ b/example/src/main/java/io/netty/example/http/cors/OkResponseHandler.java, +import io.netty.handler.codec.http.DefaultFullHttpResponse;, +import io.netty.handler.codec.http.FullHttpResponse;, + final FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + private final boolean chunkedSupported;, + this(4096, 8192, 8192, true);, + int maxInitialLineLength, int maxHeaderSize, int maxChunkSize, boolean chunkedSupported) {, + this.chunkedSupported = chunkedSupported;, + if (!chunkedSupported) {, + throw new IllegalArgumentException("Chunked messages not supported");, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + private final boolean chunkedSupported;, + this(4096, 8192, 8192, true);, + int maxInitialLineLength, int maxHeaderSize, int maxChunkSize, boolean chunkedSupported) {, + this.chunkedSupported = chunkedSupported;, + if (!chunkedSupported) {, + throw new IllegalArgumentException("Chunked messages not supported");, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestDecoder.java, + super(maxInitialLineLength, maxHeaderSize, maxChunkSize, true);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + private final boolean chunkedSupported;, + this(4096, 8192, 8192, true);, + int
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientUpgradeHandler.java, + builder.append(HttpHeaderValues.UPGRADE);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientUpgradeHandler.java, + builder.append(HttpHeaderValues.UPGRADE);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderValues.java, + * {@code "upgrade"}, + public static final AsciiString UPGRADE = new AsciiString("upgrade");]
[+++ b/pom.xml, + <argLine.java9.extras />, + <!-- Export some stuff which is used during our tests -->, + <argLine.java9>--illegal-access=deny ${argLine.java9.extras}</argLine.java9>, + <argLine.java9.extras />, + <!-- Export some stuff which is used during our tests -->, + <argLine.java9>--illegal-access=deny ${argLine.java9.extras}</argLine.java9>, + <argLine.java9.extras />, + <!-- Export some stuff which is used during our tests -->, + <argLine.java9>--illegal-access=deny --add-modules java.xml.bind ${argLine.java9.extras}</argLine.java9>, + <argLine.java9>--illegal-access=deny --add-modules java.xml.bind ${argLine.java9.extras}</argLine.java9>]
[+++ b/transport/src/main/java/io/netty/channel/ChannelDuplexHandler.java, + /**, + * Calls {@link ChannelHandlerContext#read()} to forward, + * to the next {@link ChannelOutboundHandler} in the {@link ChannelPipeline}., + *, + * Sub-classes may override this method to change behavior., + */, + /**, + * Calls {@link ChannelHandlerContext#write(Object, ChannelPromise)} to forward, + * to the next {@link ChannelOutboundHandler} in the {@link ChannelPipeline}., + *, + * Sub-classes may override this method to change behavior., + */, + /**, + * Calls {@link ChannelHandlerContext#flush()} to forward, + * to the next {@link ChannelOutboundHandler} in the {@link ChannelPipeline}., + *, + * Sub-classes may override this
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/handler/stream/ChunkedFile.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2009, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License,
[+++ b/pom.xml, + <tcnative.version>1.1.33.Fork19</tcnative.version>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, + long maxAge = Integer.MIN_VALUE;]
[+++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, + * group that are matched by the given {@link ChannelMatcher}. If the specified {@code message} is an instance of, + * Writes the specified {@code message} to all {@link Channel}s in this, + * group that are matched by the given {@link ChannelMatcher}. If the specified {@code message} is an instance of, + * {@link ByteBuf}, it is automatically, + * {@linkplain ByteBuf#duplicate() duplicated} to avoid a race, + * condition. The same is true for {@link ByteBufHolder}. Please note that this operation is asynchronous as, + * {@link Channel#write(Object)} is., + *, + * If
[+++ b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufDecoder.java, + private static final boolean HAS_PARSER;, +, + static {, + boolean hasParser = false;, + try {, + // MessageLite.getParsetForType() is not available until protobuf 2.5.0., + MessageLite.class.getDeclaredMethod("getParserForType");, + hasParser = true;, + } catch (Throwable t) {, + // Ignore, + }, +, + HAS_PARSER = hasParser;, + }, +, + final byte[] array;, + final int offset;, + final int length = msg.readableBytes();, + array = msg.array();, + offset = msg.arrayOffset() + msg.readerIndex();, + array = new byte[length];, + msg.getBytes(msg.readerIndex(), array, 0, length);, + offset = 0;, + }, +, + if (extensionRegistry ==
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelId.java, + StringBuilder buf = new StringBuilder(2 * data.length + 5);]
[+++ b/buffer/src/test/java/io/netty/buffer/ByteBufStreamTest.java, + ByteBuf buf = Unpooled.buffer(0, 65536);, + buf.release();]
[+++ b/pom.xml, + <netty.build.version>22</netty.build.version>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-build</artifactId>, + <version>${netty.build.version}</version>, + <scope>test</scope>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-build</artifactId>, + <scope>test</scope>, + </dependency>, + <dependency>, + <version>${netty.build.version}</version>, + <properties>, + <property>, + <name>listener</name>, + <value>io.netty.build.junit.TimedOutTestsListener</value>, + </property>, + </properties>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + * Returns the raw value of this {@link Cookie},, + * as it was set in original Set-Cookie header., + *, + * @return The raw value of this {@link Cookie}, + */, + String rawValue();, +, + /**, + * Sets the raw value of this {@link Cookie}., + *, + * @param value The raw value to set, + */, + void setRawValue(String rawValue);, +, + /**, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + * Returns the raw value of this {@link Cookie},, + * as it was set in original Set-Cookie header., + *, + * @return
[+++ b/pom.xml, + <version>[3.0.5,)</version>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/common/src/main/java/io/netty/util/ByteString.java, +, +import io.netty.util.internal.PlatformDependent;, + ByteString other = (ByteString) obj;, + return hashCode() == other.hashCode() &&, + PlatformDependent.equals(array(), 0, array().length, other.array(), 0, other.array().length);, +++ b/common/src/main/java/io/netty/util/ByteString.java, +, +import io.netty.util.internal.PlatformDependent;, + ByteString other = (ByteString) obj;, + return hashCode() == other.hashCode() &&, + PlatformDependent.equals(array(), 0, array().length, other.array(), 0, other.array().length);, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + private static final long ARRAY_BASE_OFFSET = PlatformDependent0.arrayBaseOffset();, + * Compare two {@code byte} arrays for equality. For performance reasons no bounds checking on the, + * parameters is performed., + *, + * @param bytes1 the first byte array., + * @param startPos1 the position (inclusive) to start
[+++ b/.fbfilter.xml, + ~ Copyright 2012 The Netty Project, +++ b/.fbfilter.xml, + ~ Copyright 2012 The Netty Project, +++ b/all/assembly.xml, +<!--, + ~ Copyright 2012 The Netty Project, + ~, + ~ The Netty Project licenses this file to you under the Apache License,, + ~ version 2.0 (the "License"); you may not use this file except in compliance, + ~ with the License. You may obtain a copy of the License at:, + ~, + ~ http://www.apache.org/licenses/LICENSE-2.0, + ~, + ~ Unless required by applicable law or agreed to in writing, software, + ~ distributed under the License
[+++ b/buffer/src/main/java/io/netty/buffer/ChannelBufferInputStream.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBufferInputStream.java, +++ b/transport/src/main/java/io/netty/bootstrap/package-info.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +import io.netty.util.ResourceLeakTracker;, + ResourceLeakTracker<ByteBuf> leak;, + leak = AbstractByteBuf.leakDetector.track(buf);, + leak = AbstractByteBuf.leakDetector.track(buf);, + ResourceLeakTracker<ByteBuf> leak;, + leak = AbstractByteBuf.leakDetector.track(buf);, + leak = AbstractByteBuf.leakDetector.track(buf);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +import io.netty.util.ResourceLeakTracker;, + ResourceLeakTracker<ByteBuf> leak;, + leak = AbstractByteBuf.leakDetector.track(buf);, + leak = AbstractByteBuf.leakDetector.track(buf);, + ResourceLeakTracker<ByteBuf> leak;, + leak = AbstractByteBuf.leakDetector.track(buf);, + leak = AbstractByteBuf.leakDetector.track(buf);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java, + // Called from within SimpleLeakAwareByteBuf and AdvancedLeakAwareByteBuf., + final void parent(ByteBuf newParent) {, + assert newParent instanceof SimpleLeakAwareByteBuf;, + parent = newParent;, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +import io.netty.util.ResourceLeakTracker;, + ResourceLeakTracker<ByteBuf> leak;, + leak = AbstractByteBuf.leakDetector.track(buf);, + leak = AbstractByteBuf.leakDetector.track(buf);, + ResourceLeakTracker<ByteBuf> leak;, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + throw streamError(streamId, REFUSED_STREAM,, + "Cannot create stream %d since this endpoint has received a GOAWAY frame with last stream id %d.",, + streamId, localEndpoint.lastStreamKnownByPeer());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + throw streamError(streamId, REFUSED_STREAM,, + "Cannot create stream %d since this endpoint has received a GOAWAY frame with last stream id %d.",, + streamId, localEndpoint.lastStreamKnownByPeer());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + if (!outbound || connection().local().mayHaveCreatedStream(streamId)) {, + }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + throw streamError(streamId, REFUSED_STREAM,, + "Cannot create stream %d since this endpoint has received a GOAWAY frame with last stream id %d.",, + streamId, localEndpoint.lastStreamKnownByPeer());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + if (!outbound || connection().local().mayHaveCreatedStream(streamId)) {,
[+++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, +++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, +++ b/transport/src/main/java/io/netty/channel/group/ChannelGroupFuture.java, +, +import java.util.Iterator;, +import java.util.concurrent.TimeUnit;, +++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, +++ b/transport/src/main/java/io/netty/channel/group/ChannelGroupFuture.java, +, +import java.util.Iterator;, +import java.util.concurrent.TimeUnit;, +++ b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java, + channel.addClosureListener(remover);, + c = serverChannels.remove(c.id());, + c = nonServerChannels.remove(c.id());, + c.removeClosureListener(remover);, + ChannelFuture f = c.newFuture();, + c.close(f);, + futures.put(c.id(), f.awaitUninterruptibly());, + ChannelFuture f = c.newFuture();, + c.close(f);, + futures.put(c.id(), f);, + ChannelFuture f = c.newFuture();, + c.disconnect(f);, + futures.put(c.id(), f.awaitUninterruptibly());, + ChannelFuture f = c.newFuture();, + c.disconnect(f);, + futures.put(c.id(), f);, + ChannelFuture f = c.newFuture();, + c.write(buf.duplicate(), f);, + futures.put(c.id(), f);, + ChannelFuture f = c.newFuture();, + c.write(message, f);, + futures.put(c.id(), f);]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * while (buffer.maxWritableBytes() >= 4) {]
[+++ b/src/docbook/en-US/module/architecture.xml, + technology (e.g. <ulink url="http://en.wikipedia.org/wiki/Comet_%28programming%29">Comet</ulink>, + and <ulink url="http://en.wikipedia.org/wiki/WebSockets">WebSockets</ulink>)]
[+++ b/transport/src/main/java/io/netty/channel/ChannelConfig.java, + * write failure. The default is {@code true}., + * The default is {@code true}., +++ b/transport/src/main/java/io/netty/channel/ChannelConfig.java, + * write failure. The default is {@code true}., + * The default is {@code true}., +++ b/transport/src/main/java/io/netty/channel/ChannelOption.java]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java, + setHttp2Authority(inHeaders,, + (host == null || host.isEmpty()) ? requestTargetUri.getAuthority() : host, out);, + HttpHeaderNames.HOST);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java, + setHttp2Authority(inHeaders,, + (host == null || host.isEmpty()) ? requestTargetUri.getAuthority() : host, out);, + HttpHeaderNames.HOST);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandlerTest.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java, + setHttp2Authority(inHeaders,, + (host == null || host.isEmpty()) ? requestTargetUri.getAuthority() : host, out);, + HttpHeaderNames.HOST);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandlerTest.java, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapterTest.java, + httpHeaders.set(HttpHeaderNames.HOST, "example.org");, + httpHeaders2.set(HttpHeaderNames.HOST, "example.org");]
[+++ b/all/.gitignore, +src, +++ b/all/.gitignore, +src, +++ b/all/pom.xml, + <id>clean-src</id>, + <phase>clean</phase>, + <goals>, + <goal>clean</goal>, + </goals>, + <configuration>, + <filesets>, + <fileset>, + <directory>${project.basedir}/src</directory>, + <followSymlinks>false</followSymlinks>, + <useDefaultExcludes>false</useDefaultExcludes>, + </fileset>, + <fileset>, + <directory>${project.basedir}/target</directory>, + <followSymlinks>false</followSymlinks>, + </fileset>, + </filesets>, + </configuration>, + </execution>, + <execution>, + <id>clean-all</id>, + <configuration>, + <filesets>, + <fileset>, + <directory>${project.basedir}/src</directory>, + <followSymlinks>false</followSymlinks>, + <useDefaultExcludes>false</useDefaultExcludes>, + </fileset>, + <fileset>, + <directory>${project.basedir}/target</directory>, + <followSymlinks>false</followSymlinks>, + </fileset>, + </filesets>, + </configuration>, + <includeGroupIds>io.netty</includeGroupIds>, + <outputDirectory>${project.basedir}/src/main/java</outputDirectory>, + <overWriteReleases>false</overWriteReleases>, + <overWriteSnapshots>true</overWriteSnapshots>, + <overWriteReleases>false</overWriteReleases>, + <overWriteSnapshots>true</overWriteSnapshots>, + <artifactId>maven-jxr-plugin</artifactId>, + <version>2.2</version>, + <id>generate-xref</id>, + <phase>package</phase>, + <goal>jxr</goal>, +
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, + ipAddressString = ipAddressString.substring(1, ipAddressString.length() - 1);, + StringTokenizer tokenizer = new StringTokenizer(ipAddressString, ":.", true);, + ipByteArray[i + 12] = (byte) (Integer.parseInt(decStrings.get(i)) & 255);, + private static void convertToBytes(String hexWord, byte[] ipByteArray, int byteIndex) {, + if (numberOfColons == 7 && ipAddress.charAt(offset) != ':' &&, + ipAddress.charAt(1 + offset) != ':') {, + if (word.length() == 0 && ipAddress.charAt(length - 1 - offset) == ':' &&, + ipAddress.charAt(length - 2 - offset) != ':') {, + return c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' &&
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java, + if (id < 0 || id > SpdyCodecUtil.SPDY_SETTINGS_MAX_ID) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java, + if (id < 0 || id > SpdyCodecUtil.SPDY_SETTINGS_MAX_ID) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java, + if (id < 0 || id > SpdyCodecUtil.SPDY_SETTINGS_MAX_ID) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, + private final int minorVersion;, + minorVersion = version.getMinorVersion();, + int settingsMinorVersion = spdySettingsFrame.getValue(SpdySettingsFrame.SETTINGS_MINOR_VERSION);, + if (settingsMinorVersion >= 0 && settingsMinorVersion != minorVersion) {, + // Settings frame had the wrong minor version, + issueSessionError(ctx, SpdySessionStatus.PROTOCOL_ERROR);, + return;, + }, +, + int settingsMinorVersion = spdySettingsFrame.getValue(SpdySettingsFrame.SETTINGS_MINOR_VERSION);, + if (settingsMinorVersion >= 0 && settingsMinorVersion != minorVersion) {, +
[+++ b/common/src/main/java/io/netty/util/internal/RecyclableArrayList.java, +import java.util.Collection;, + @Override, + public boolean addAll(Collection<?> c) {, + for (Object element: c) {, + if (element == null) {, + throw new IllegalArgumentException("c contains null values");, + }, + }, + return super.addAll(c);, + }, +, + @Override, + public boolean addAll(int index, Collection<?> c) {, + for (Object element: c) {, + if (element == null) {, + throw new IllegalArgumentException("c contains null values");, + }, + }, + return super.addAll(index, c);, + }, +, + @Override, + public boolean add(Object element) {, + if (element == null) {, + throw new NullPointerException("element");,
[+++ b/all/assembly.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<assembly xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2", + xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance", + xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2 http://maven.apache.org/xsd/assembly-1.1.2.xsd">, +, + <id>all-in-one</id>, + <formats>, + <format>jar</format>, + </formats>, + <includeBaseDirectory>false</includeBaseDirectory>, +, + <dependencySets>, + <dependencySet>, + <scope>test</scope>, + <unpack>true</unpack>, + <useStrictFiltering>true</useStrictFiltering>, + <useProjectArtifact>false</useProjectArtifact>, + <useTransitiveFiltering>true</useTransitiveFiltering>, + <includes>, + <include>${project.groupId}:*</include>, + </includes>, + <unpackOptions>, + <includes>, + <include>io/netty/**</include>, + </includes>, + </unpackOptions>, + </dependencySet>, + </dependencySets>, +</assembly>, +++ b/all/assembly.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<assembly xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2", + xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance", + xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2 http://maven.apache.org/xsd/assembly-1.1.2.xsd">, +, + <id>all-in-one</id>, + <formats>, + <format>jar</format>, + </formats>, + <includeBaseDirectory>false</includeBaseDirectory>, +, + <dependencySets>, + <dependencySet>, + <scope>test</scope>, + <unpack>true</unpack>, + <useStrictFiltering>true</useStrictFiltering>, + <useProjectArtifact>false</useProjectArtifact>, + <useTransitiveFiltering>true</useTransitiveFiltering>, + <includes>,
[+++ b/transport/src/main/java/io/netty/channel/pool/ChannelPool.java, + *, + * <strong>Its important that an acquired is always released to the pool again, even if the {@link Channel}, + * is explicitly closed..</strong>, + *, + * <strong>Its important that an acquired is always released to the pool again, even if the {@link Channel}, + * is explicitly closed..</strong>]
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, + "SSL_RSA_WITH_3DES_EDE_CBC_SHA");, + if (ciphers.isEmpty()) {, + for (String cipher : engine.getEnabledCipherSuites()) {, + if (cipher.contains("_RC4_")) {, + continue;, + ciphers.add(cipher);, + }, + }, + DEFAULT_CIPHERS = Collections.unmodifiableList(ciphers);, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, + "SSL_RSA_WITH_3DES_EDE_CBC_SHA");, + if (ciphers.isEmpty()) {, + for (String cipher : engine.getEnabledCipherSuites()) {, + if (cipher.contains("_RC4_")) {, + continue;, + ciphers.add(cipher);, + }, + }, + DEFAULT_CIPHERS = Collections.unmodifiableList(ciphers);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + "DES-CBC3-SHA");, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, + "SSL_RSA_WITH_3DES_EDE_CBC_SHA");, + if (ciphers.isEmpty()) {, + for (String cipher : engine.getEnabledCipherSuites()) {, + if (cipher.contains("_RC4_")) {, + continue;, + ciphers.add(cipher);, + }, + }, + DEFAULT_CIPHERS = Collections.unmodifiableList(ciphers);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java,
[+++ b/.gitignore, +dependency-reduced-pom.xml, +++ b/.gitignore, +dependency-reduced-pom.xml, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + channel.eventLoop().execute(new Runnable() {, + channel.eventLoop().execute(new Runnable() {, +++ b/.gitignore, +dependency-reduced-pom.xml, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + channel.eventLoop().execute(new Runnable() {, + channel.eventLoop().execute(new Runnable() {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamChannel.java, + preferredExecutor.execute(new Runnable() {, + eventLoop().execute(new Runnable() {, +++ b/.gitignore, +dependency-reduced-pom.xml, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + channel.eventLoop().execute(new Runnable() {, + channel.eventLoop().execute(new Runnable() {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamChannel.java, + preferredExecutor.execute(new Runnable() {, + eventLoop().execute(new Runnable() {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + timeoutTask = ctx.executor().schedule(new Runnable() {, +++ b/.gitignore, +dependency-reduced-pom.xml, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + channel.eventLoop().execute(new Runnable() {, + channel.eventLoop().execute(new Runnable() {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamChannel.java, + preferredExecutor.execute(new Runnable() {, + eventLoop().execute(new Runnable() {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + timeoutTask = ctx.executor().schedule(new
[+++ b/pom.xml, + <!--, + ~ This workaround prevents Maven from executing the 'generate-sources' phase twice., + ~ See http://jira.codehaus.org/browse/MSOURCES-13, + ~ and http://blog.peterlynch.ca/2010/05/maven-how-to-prevent-generate-sources.html, + -->, + <phase>invalid</phase>, + <execution>, + <id>attach-sources-no-fork</id>, + <phase>package</phase>, + <goals>, + <goal>jar-no-fork</goal>, + </goals>, + </execution>]
[+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java, +import io.netty.util.NetUtil;, + String host = NetUtil.intToIpAddress(byteBuf.readInt());, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java, +import io.netty.util.NetUtil;, + String host = NetUtil.intToIpAddress(byteBuf.readInt());, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponseDecoder.java, +import io.netty.util.NetUtil;, + String host = NetUtil.intToIpAddress(byteBuf.readInt());, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java, +import io.netty.util.NetUtil;, + String host = NetUtil.intToIpAddress(byteBuf.readInt());, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdResponseDecoder.java, +import io.netty.util.NetUtil;, + String host = NetUtil.intToIpAddress(byteBuf.readInt());, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCommonUtils.java]
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsRecord.java, +import java.net.IDN;, +, + // Convert to ASCII which will also check that the length is not too big., + // See:, + // - https://github.com/netty/netty/issues/4937, + // - https://github.com/netty/netty/issues/4935, + this.name = IDN.toASCII(checkNotNull(name, "name"));, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsRecord.java, +import java.net.IDN;, +, + // Convert to ASCII which will also check that the length is not too big., + // See:, + // - https://github.com/netty/netty/issues/4937, + // - https://github.com/netty/netty/issues/4935, + this.name = IDN.toASCII(checkNotNull(name, "name"));, +++ b/codec-dns/src/test/java/io/netty/handler/codec/dns/AbstractDnsRecordTest.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + // Calling malloc with capacity of 0 may return a null ptr or a memory address that can be used., + // Just use 1 to make it safe to use in all cases:, + // See: http://pubs.opengroup.org/onlinepubs/009695399/functions/malloc.html, + return newDirectBuffer(UNSAFE.allocateMemory(Math.max(1, capacity)), capacity);, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + // Calling malloc with capacity of 0 may return a null ptr or a memory address that can be used., + // Just use 1 to make it safe to use in all cases:, + // See: http://pubs.opengroup.org/onlinepubs/009695399/functions/malloc.html, + return newDirectBuffer(UNSAFE.allocateMemory(Math.max(1, capacity)), capacity);, +++ b/common/src/test/java/io/netty/util/internal/PlatformDependentTest.java, +import java.nio.ByteBuffer;, +import static org.junit.Assert.*;,
[+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpNotificationHandler.java, + sctpChannel.worker.close(sctpChannel, Channels.succeededFuture(sctpChannel));, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpNotificationHandler.java, + sctpChannel.worker.close(sctpChannel, Channels.succeededFuture(sctpChannel));, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpSendBufferPool.java, + return ch.send(buffer, messageInfo);, + return ch.send(buffer, messageInfo);, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpNotificationHandler.java, + sctpChannel.worker.close(sctpChannel, Channels.succeededFuture(sctpChannel));, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpSendBufferPool.java, + return ch.send(buffer, messageInfo);, + return ch.send(buffer, messageInfo);, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpWorker.java, + messageReceived = messageInfo != null;, + if (channel.channel.isBlocking() && !messageReceived) {]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java, + private final HttpHeaders trailingHeader;, + this(httpVersion, method, uri, content, true);, + }, +, + public DefaultFullHttpRequest(HttpVersion httpVersion, HttpMethod method, String uri,, + ByteBuf content, boolean validateHeaders) {, + super(httpVersion, method, uri, validateHeaders);, + trailingHeader = new DefaultHttpHeaders(validateHeaders);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java, + private final HttpHeaders trailingHeader;, + this(httpVersion, method, uri, content, true);, + }, +, + public DefaultFullHttpRequest(HttpVersion httpVersion, HttpMethod method, String uri,, + ByteBuf content, boolean validateHeaders) {, + super(httpVersion, method, uri, validateHeaders);, + trailingHeader = new DefaultHttpHeaders(validateHeaders);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java, + private final HttpHeaders trailingHeaders;, + this(version, status, content, true);, + }, +, + public DefaultFullHttpResponse(HttpVersion version,
[+++ b/transport/src/main/java/io/netty/channel/ReflectiveChannelFactory.java, +import io.netty.util.internal.ObjectUtil;, +import java.lang.reflect.Constructor;, +, + private final Constructor<? extends T> constructor;, + ObjectUtil.checkNotNull(clazz, "clazz");, + try {, + this.constructor = clazz.getConstructor();, + } catch (NoSuchMethodException e) {, + throw new IllegalArgumentException("Class " + StringUtil.simpleClassName(clazz) +, + " does not have a public non-arg constructor", e);, + return constructor.newInstance();, + throw new ChannelException("Unable to create Channel from class " + constructor.getDeclaringClass(), t);, + return StringUtil.simpleClassName(ReflectiveChannelFactory.class) +, + '(' + StringUtil.simpleClassName(constructor.getDeclaringClass()) + ".class)";]
[+++ b/LICENSE.base64.txt, +The person or persons who have associated work with this document (the, +"Dedicator" or "Certifier") hereby either (a) certifies that, to the best of, +his knowledge, the work of authorship identified is in the public domain of, +the country from which the work is published, or (b) hereby dedicates whatever, +copyright the dedicators holds in the work of authorship identified below (the, +"Work") to the public domain. A certifier, moreover, dedicates any copyright, +interest he may have in the associated work, and for these purposes, is, +described as a "dedicator" below., +, +A certifier has taken reasonable
[+++ b/all/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR3-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java]
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + static final int HASH_CODE_C1 = 0xcc9e2d51;]
[+++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, + * {@link ByteBuf} buf, List&lt;Object&gt; out) throws Exception {, + * if (buf.readableBytes() &lt; 4) {, + * buf.markReaderIndex();, + * int length = buf.readInt();, + * if (buf.readableBytes() &lt; length) {, + * buf.resetReaderIndex();, + * out.add(buf.readBytes(length));, + * public void decode(.., {@link ByteBuf} buf, List&lt;Object&gt; out) throws Exception {, + * values.offer(buf.readInt());, + * values.offer(buf.readInt());, + * public void decode(.., {@link ByteBuf} buf, List&lt;Object&gt; out) throws Exception {, + * values.offer(buf.readInt());, + * values.offer(buf.readInt());, + * {@link ByteBuf} buf, List&lt;Object&gt; out) throws Exception {, + * {@link ByteBuf} buf, List&lt;Object&gt; out) throws Exception {,
[+++ b/pom.xml, + <!--, + <module>testsuite-osgi</module>, + <module>microbench</module>, + -->, +++ b/pom.xml, + <!--, + <module>testsuite-osgi</module>, + <module>microbench</module>, + -->, +++ b/testsuite-osgi/.gitignore, +, +target/, +reports/, +++ b/pom.xml, + <!--, + <module>testsuite-osgi</module>, + <module>microbench</module>, + -->, +++ b/testsuite-osgi/.gitignore, +, +target/, +reports/, +++ b/testsuite-osgi/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<!--, + ~ Copyright 2013 The Netty Project, + ~, + ~ The Netty Project licenses this file to you under the Apache License,, + ~ version 2.0 (the "License"); you may not use this file except in compliance, + ~ with the License. You may obtain a copy of the License at:, +
[+++ b/transport-udt/src/test/java/io/netty/test/udt/nio/NioUdtMessageRendezvousChannelTest.java, +import org.junit.Ignore;, + *, + * FIXME: Re-enable after making it pass on Windows without unncessary tight loop., + * https://github.com/netty/netty/issues/2853, + @Ignore]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + String rawPath = uri.getRawPath();, + if (rawPath != null) {, + hasPath = true;, + } else {, + rawPath ="";, + hasPath = false;, + }, + // Also take care of cut of things like "http://localhost" , + String newUri = rawPath + "?" + uri.getRawQuery();, +, + this.uri = newUri.replace(';', '&');, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + String rawPath = uri.getRawPath();, + if (rawPath != null) {, + hasPath = true;, + } else {, + rawPath ="";, + hasPath = false;, + }, + // Also take care of cut of things like "http://localhost"
[+++ b/handler/src/main/java/io/netty/handler/ssl/util/SelfSignedCertificate.java, + this("example.com", notBefore, notAfter);]
[+++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketChannelFactory.java, +import org.jboss.netty.util.ExecutorUtil;, + ExecutorUtil.terminate(bossExecutor, workerExecutor);, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketChannelFactory.java, +import org.jboss.netty.util.ExecutorUtil;, + ExecutorUtil.terminate(bossExecutor, workerExecutor);, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketChannelFactory.java, +import org.jboss.netty.util.ExecutorUtil;, + ExecutorUtil.terminate(bossExecutor, workerExecutor);, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketChannelFactory.java, +import org.jboss.netty.util.ExecutorUtil;, + ExecutorUtil.terminate(bossExecutor, workerExecutor);, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketChannelFactory.java, +import org.jboss.netty.util.ExecutorUtil;, + ExecutorUtil.terminate(bossExecutor, workerExecutor);, +++ b/src/main/java/org/jboss/netty/channel/socket/oio/OioClientSocketChannelFactory.java, +import org.jboss.netty.util.ExecutorUtil;, + ExecutorUtil.terminate(workerExecutor);, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketChannelFactory.java, +import org.jboss.netty.util.ExecutorUtil;, + ExecutorUtil.terminate(bossExecutor, workerExecutor);, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketChannelFactory.java, +import org.jboss.netty.util.ExecutorUtil;, + ExecutorUtil.terminate(bossExecutor, workerExecutor);, +++ b/src/main/java/org/jboss/netty/channel/socket/oio/OioClientSocketChannelFactory.java, +import org.jboss.netty.util.ExecutorUtil;, + ExecutorUtil.terminate(workerExecutor);, +++ b/src/main/java/org/jboss/netty/channel/socket/oio/OioServerSocketChannelFactory.java, +import org.jboss.netty.util.ExecutorUtil;, + ExecutorUtil.terminate(bossExecutor, workerExecutor);, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioClientSocketChannelFactory.java, +import org.jboss.netty.util.ExecutorUtil;, + ExecutorUtil.terminate(bossExecutor, workerExecutor);, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/NioServerSocketChannelFactory.java, +import org.jboss.netty.util.ExecutorUtil;, + ExecutorUtil.terminate(bossExecutor, workerExecutor);, +++ b/src/main/java/org/jboss/netty/channel/socket/oio/OioClientSocketChannelFactory.java, +import org.jboss.netty.util.ExecutorUtil;, + ExecutorUtil.terminate(workerExecutor);, +++ b/src/main/java/org/jboss/netty/channel/socket/oio/OioServerSocketChannelFactory.java, +import org.jboss.netty.util.ExecutorUtil;, + ExecutorUtil.terminate(bossExecutor, workerExecutor);, +++ b/src/main/java/org/jboss/netty/container/guice/NettyModule.java, +import org.jboss.netty.util.ExecutorUtil;,
[+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCommonUtils.java, +import io.netty.util.internal.StringUtil;, +, + /**, + /**, + * Converts numeric IPv6 to standard (non-compressed) format., + private static void ipv6toStr(StringBuilder sb, byte[] src, int fromHextet, int toHextet) {, + int i;, + toHextet --;, + for (i = fromHextet; i < toHextet; i++) {, + appendHextet(sb, src, i);, +, + appendHextet(sb, src, i);, +, + private static void appendHextet(StringBuilder sb, byte[] src, int i) {, + StringUtil.toHexString(sb, src, i << 1, 2);, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCommonUtils.java, +import io.netty.util.internal.StringUtil;, +, + /**, + /**, + * Converts numeric IPv6 to standard (non-compressed) format., + private static void ipv6toStr(StringBuilder sb,
[+++ b/common/src/main/java/io/netty/util/ConstantPool.java, + T c;, + if (exists(name)) {, + c = constants.get(name);, + } else {, + c = newInstance0(name);, + }, + checkNotNullAndNotEmpty(name);, + if (exists(name)) {, + throw new IllegalArgumentException(String.format("'%s' is already in use", name));, + T c = newInstance0(name);, +, + return c;, + }, +, + // Be careful that this dose not check whether the argument is null or empty., + private T newInstance0(String name) {, + synchronized (constants) {, + T c = newConstant(nextId, name);, + constants.put(name, c);, + nextId++;, + return c;, + }, + }, +, + private String checkNotNullAndNotEmpty(String
[+++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, +++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AbstractAioChannel.java, + protected AsynchronousChannel ch;, + protected AbstractAioChannel(Channel parent, Integer id, AsynchronousChannel ch) {, + if (ch == null) {, + throw new IllegalStateException("Try to access Channel before eventLoop was registered");, + }, + if (ch == null) {, + return true;, + }, +++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AbstractAioChannel.java, + protected AsynchronousChannel ch;, + protected AbstractAioChannel(Channel parent, Integer id, AsynchronousChannel ch) {, + if (ch == null) {, + throw new IllegalStateException("Try to access Channel before eventLoop was registered");, + }, + if (ch == null) {, + return true;, + }, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AioServerSocketChannel.java, +
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + int dataLen = data.readableBytes();, + nioData = ByteBuffer.allocate(dataLen);, + if (writtenBytes <= 0 && dataLen > 0) {]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/WeightedFairQueueByteDistributor.java, + pState.activeCountChangeForTree(state.activeCountForTree);, + pState.activeCountChangeForTree(-state.activeCountForTree);, + if (state.isActive()) {, + childState.setDistributing();, + "nextChildState[" + nextChildState.stream.id() + "].pseudoTime(" + nextChildState.pseudoTimeToWrite +, + ") < " + " childState[" + childState.stream.id() + "].pseudoTime(" + childState.pseudoTimeToWrite + ")";, + childState.unsetDistributing();, + // Do in finally to ensure the internal flags is not corrupted if an exception is thrown., + private static final int STATE_IS_ACTIVE = 0x1;, + private static final int STATE_IS_DISTRIBUTING = 0x2;, + * Count of nodes rooted at this sub tree with {@link #isActive()} equal to {@code true}., + * A pseudo time maintained for immediate children to
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java]
[+++ b/pom.xml, + <version>1.2.3.Final</version>]
[+++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, +++ b/handler/src/test/java/io/netty/handler/ssl/SSLEngineTest.java, + serverChannel = sb.bind(new InetSocketAddress(0)).sync().channel();]
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + /**, + * Returns the {@link ByteBuf} portion of this {@link CompositeByteBuf} that, + * contains the specified {@code index}. This is an expert method!, + *, + * <p>, + * Please note that since a {@link CompositeByteBuf} is made up of, + * multiple {@link ByteBuf}s, this does <em>not</em> return the full buffer., + * Instead, it only returns a portion of the composite buffer where the, + * index is located, + * </p>, + *, + * @param index The {@code index} to search for and include in the returned {@link ByteBuf},
[+++ b/handler-proxy/pom.xml, + <properties>, + <!-- Needed for SelfSignedCertificate -->, + <argLine.java9.extras>--add-exports java.base/sun.security.x509=ALL-UNNAMED</argLine.java9.extras>, + </properties>, +, +++ b/handler-proxy/pom.xml, + <properties>, + <!-- Needed for SelfSignedCertificate -->, + <argLine.java9.extras>--add-exports java.base/sun.security.x509=ALL-UNNAMED</argLine.java9.extras>, + </properties>, +, +++ b/pom.xml, + <!-- Skip as maven plugin not works with Java9 yet --> , + <skipOsgiTestsuite>true</skipOsgiTestsuite>, + <!-- Skip as jython not works with Java9 yet -->, + <skipAutobahnTestsuite>true</skipAutobahnTestsuite>, + <skipOsgiTestsuite>false</skipOsgiTestsuite>, + <skipAutobahnTestsuite>false</skipAutobahnTestsuite>, +++ b/handler-proxy/pom.xml, + <properties>, + <!-- Needed for SelfSignedCertificate -->, + <argLine.java9.extras>--add-exports java.base/sun.security.x509=ALL-UNNAMED</argLine.java9.extras>, + </properties>, +, +++ b/pom.xml, + <!-- Skip as maven plugin not works with Java9 yet --> , + <skipOsgiTestsuite>true</skipOsgiTestsuite>,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java, + this(version, status, content, false);, + this(version, status, Unpooled.buffer(0), validateHeaders, false);, + }, +, + public DefaultFullHttpResponse(HttpVersion version, HttpResponseStatus status, boolean validateHeaders,, + boolean singleFieldHeaders) {, + this(version, status, Unpooled.buffer(0), validateHeaders, singleFieldHeaders);, + ByteBuf content, boolean singleFieldHeaders) {, + this(version, status, content, true, singleFieldHeaders);, + }, +, + public DefaultFullHttpResponse(HttpVersion version, HttpResponseStatus status,, + ByteBuf content, boolean validateHeaders, boolean singleFieldHeaders) {, + super(version, status, validateHeaders, singleFieldHeaders);, + trailingHeaders = new DefaultHttpHeaders(validateHeaders, singleFieldHeaders);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java, + this(version, status, content, false);, + this(version, status, Unpooled.buffer(0), validateHeaders, false);, + }, +, + public DefaultFullHttpResponse(HttpVersion version, HttpResponseStatus status, boolean validateHeaders,, +
[+++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageDecoder.java, +import io.netty.handler.codec.ProtocolDetectionResult;, + private static final byte[] TEXT_PREFIX = {, + (byte) 'P',, + (byte) 'R',, + (byte) 'O',, + (byte) 'X',, + (byte) 'Y',, + };, +, + * {@link ProtocolDetectionResult} for {@link HAProxyProtocolVersion#V1}., + */, + private static final ProtocolDetectionResult<HAProxyProtocolVersion> DETECTION_RESULT_V1 =, + ProtocolDetectionResult.detected(HAProxyProtocolVersion.V1);, +, + /**, + * {@link ProtocolDetectionResult} for {@link HAProxyProtocolVersion#V2}., + */, + private static final ProtocolDetectionResult<HAProxyProtocolVersion> DETECTION_RESULT_V2 =, + ProtocolDetectionResult.detected(HAProxyProtocolVersion.V2);, +, + /**, + return match(BINARY_PREFIX, buffer, idx) ? buffer.getByte(idx + BINARY_PREFIX_LENGTH) : 1;, +, + /**, + * Returns the {@link ProtocolDetectionResult} for the given {@link ByteBuf}., + */,
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + try {, + } finally {, + // We must release in in all cases as otherwise it may produce a leak if writeBytes(...) throw, + // for whatever release (for example because of OutOfMemoryError), + in.release();, + }, + try {, + // Expand cumulation (by replace it) when the refCnt is greater then 1 which may happen when the, + // user use slice().retain() or duplicate().retain()., + in = null;, + } finally {, + if (in != null) {, + // We must release if the ownership was not transfered as otherwise it
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + logger.debug("netty-tcnative using native library: {}", SSL.versionString());, +]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerKeepAliveHandler.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, + EventLoop loop = new MultithreadEventLoop(SelectorEventLoop.FACTORY);, + //s.pipeline().addLast("logger", new LoggingHandler(InternalLogLevel.INFO));, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, + EventLoop loop = new MultithreadEventLoop(SelectorEventLoop.FACTORY);, + //s.pipeline().addLast("logger", new LoggingHandler(InternalLogLevel.INFO));, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + final EventLoop loop = new MultithreadEventLoop(SelectorEventLoop.FACTORY);, + //s.pipeline().addLast("logger", new LoggingHandler(InternalLogLevel.INFO));, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, + EventLoop loop = new MultithreadEventLoop(SelectorEventLoop.FACTORY);, + //s.pipeline().addLast("logger", new LoggingHandler(InternalLogLevel.INFO));, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + final EventLoop loop = new MultithreadEventLoop(SelectorEventLoop.FACTORY);, + //s.pipeline().addLast("logger", new LoggingHandler(InternalLogLevel.INFO));, +++ b/transport/src/main/java/io/netty/channel/EventLoopFactory.java, +package io.netty.channel;, +, +import java.util.concurrent.ThreadFactory;, +, +public interface EventLoopFactory<T extends EventLoop> {, + T newEventLoop(ThreadFactory threadFactory) throws Exception;, +}, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, + EventLoop loop = new MultithreadEventLoop(SelectorEventLoop.FACTORY);, + //s.pipeline().addLast("logger", new LoggingHandler(InternalLogLevel.INFO));, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + final
[+++ b/codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java, + this.idx = in.readerIndex() + (idx - lastReaderIndex);, +++ b/codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java, + this.idx = in.readerIndex() + (idx - lastReaderIndex);, +++ b/codec/src/test/java/io/netty/handler/codec/json/JsonObjectDecoderTest.java, + public void testMultipleJsonObjectsOverMultipleWrites() {, + EmbeddedChannel ch = new EmbeddedChannel(new JsonObjectDecoder());, +, + String objectPart1 = "{\"name\":\"Jo";, + String objectPart2 = "hn\"}{\"name\":\"John\"}{\"name\":\"Jo";, + String objectPart3 = "hn\"}";, +, + ch.writeInbound(Unpooled.copiedBuffer(objectPart1, CharsetUtil.UTF_8));, + ch.writeInbound(Unpooled.copiedBuffer(objectPart2, CharsetUtil.UTF_8));, + ch.writeInbound(Unpooled.copiedBuffer(objectPart3, CharsetUtil.UTF_8));, +, + for (int i = 0; i < 3; i++) {, + ByteBuf res = ch.readInbound();, + assertEquals("{\"name\":\"John\"}", res.toString(CharsetUtil.UTF_8));, + res.release();, + }, +, + assertFalse(ch.finish());, + }, +, + @Test]
[+++ b/pom.xml, + <arguments>-P release,full</arguments>, + <localCheckout>true</localCheckout>]
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionTest.java, + assertTrue(latch.await(5, TimeUnit.SECONDS));, + assertTrue(latch.await(5, TimeUnit.SECONDS));, + assertTrue(latch.await(5, TimeUnit.SECONDS));, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionTest.java, + assertTrue(latch.await(5, TimeUnit.SECONDS));, + assertTrue(latch.await(5, TimeUnit.SECONDS));, + assertTrue(latch.await(5, TimeUnit.SECONDS));, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2CodecTest.java, + assertTrue(serverChannelLatch.await(5, TimeUnit.SECONDS));, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionTest.java, + assertTrue(latch.await(5, TimeUnit.SECONDS));, + assertTrue(latch.await(5, TimeUnit.SECONDS));, + assertTrue(latch.await(5, TimeUnit.SECONDS));, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2CodecTest.java, + assertTrue(serverChannelLatch.await(5, TimeUnit.SECONDS));, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionRoundtripTest.java, + assertTrue(requestLatch.await(5, SECONDS));, + assertTrue(serverInitLatch.await(5, TimeUnit.SECONDS));, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionTest.java, + assertTrue(latch.await(5, TimeUnit.SECONDS));, + assertTrue(latch.await(5, TimeUnit.SECONDS));, + assertTrue(latch.await(5, TimeUnit.SECONDS));, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2CodecTest.java, + assertTrue(serverChannelLatch.await(5, TimeUnit.SECONDS));, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionRoundtripTest.java, + assertTrue(requestLatch.await(5, SECONDS));, + assertTrue(serverInitLatch.await(5, TimeUnit.SECONDS));, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/InboundHttp2ToHttpAdapterTest.java, + assertTrue(settingsLatch.await(5, SECONDS));, + assertTrue(serverChannelLatch.await(5, SECONDS));, + assertTrue(serverLatch.await(5, SECONDS));, + assertTrue(clientLatch.await(5, SECONDS));, + assertTrue(serverLatch2.await(5, SECONDS));, + assertTrue(clientLatch2.await(5, SECONDS));]
[+++ b/pom.xml]
[+++ b/pom.xml, + <exec executable="git" outputproperty="buildNumber">, + <arg value="log"/>, + <arg value="-1"/>, + <arg value="--format=format:%h"/>, + </exec>, + <echo message="${project.version}" file="${project.build.directory}/version.txt" />, + <echo message="// DO NOT MODIFY - WILL BE OVERWRITTEN DURING THE BUILD PROCESS${line.separator}package org.jboss.netty.util;${line.separator}/**${line.separator} * Provides the version information of Netty.${line.separator} * @apiviz.landmark${line.separator} */${line.separator}public final class Version {${line.separator} /** The version identifier. */${line.separator} public static final String ID = &quot;${project.version}-${buildNumber}&quot;;${line.separator} /** Prints out the version identifier to stdout. */${line.separator} public static void main(String[] args) { System.out.println(ID); }${line.separator} private Version() { super(); }${line.separator}}${line.separator}" file="${basedir}/src/main/java/org/jboss/netty/util/Version.java" />, + <zip destfile="${project.build.directory}/${project.build.finalName}.jar">, + <include name="META-INF/MANIFEST.MF" />, + </zipfileset>, + <zipfileset filemode="644"
[+++ b/pom.xml, + <version>3.1.0.BETA3-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, + leak = leakDetection ? leakDetector.track(this) : null;, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, + leak = leakDetection ? leakDetector.track(this) : null;, +++ b/handler/src/test/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngineTest.java, +import io.netty.handler.ssl.util.InsecureTrustManagerFactory;, +import org.junit.Test;, +, + @Test(expected = NullPointerException.class), + public void testNotLeakOnException() throws Exception {, + clientSslCtx = SslContextBuilder.forClient(), + .trustManager(InsecureTrustManagerFactory.INSTANCE), + .sslProvider(sslClientProvider()), + .build();, +, + clientSslCtx.newEngine(null);, + }]
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_tcpInfo0(JNIEnv* env, jclass clazz, jint fd, jintArray array) {, + struct tcp_info tcp_info;, + if (getOption(env, fd, SOL_TCP, TCP_INFO, &tcp_info, sizeof(tcp_info)) == -1) {, + return;, + }, + unsigned int cArray[32];, + cArray[0] = tcp_info.tcpi_state;, + cArray[1] = tcp_info.tcpi_ca_state;, + cArray[2] = tcp_info.tcpi_retransmits;, + cArray[3] = tcp_info.tcpi_probes;, + cArray[4] = tcp_info.tcpi_backoff;, + cArray[5] = tcp_info.tcpi_options;, + cArray[6] = tcp_info.tcpi_snd_wscale;, + cArray[7] = tcp_info.tcpi_rcv_wscale;, + cArray[8] = tcp_info.tcpi_rto;, + cArray[9] = tcp_info.tcpi_ato;, + cArray[10] = tcp_info.tcpi_snd_mss;, + cArray[11] = tcp_info.tcpi_rcv_mss;, + cArray[12] = tcp_info.tcpi_unacked;, + cArray[13] = tcp_info.tcpi_sacked;, + cArray[14] = tcp_info.tcpi_lost;, + cArray[15]
[+++ b/all/pom.xml, + <version>4.0.0.Final</version>, +++ b/all/pom.xml, + <version>4.0.0.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Final</version>, +++ b/all/pom.xml, + <version>4.0.0.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Final</version>, +++ b/all/pom.xml, + <version>4.0.0.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Final</version>, +++ b/all/pom.xml, + <version>4.0.0.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Final</version>, +++ b/codec/pom.xml, + <version>4.0.0.Final</version>, +++ b/all/pom.xml, + <version>4.0.0.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Final</version>, +++ b/codec/pom.xml, + <version>4.0.0.Final</version>, +++ b/common/pom.xml, + <version>4.0.0.Final</version>, +++ b/all/pom.xml, + <version>4.0.0.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Final</version>, +++ b/codec-socks/pom.xml, +
[+++ b/common/src/main/templates/io/netty/util/collection/KObjectHashMap.template, + // The array lengths are always a power of two, so we can use a bitmask to stay inside the array bounds., + * Get the next sequential index after {@code index} and wraps if necessary., + */, + private int probeNext(int index) {, + // The array lengths are always a power of two, so we can use a bitmask to stay inside the array bounds., + return (index + 1) & mask;, + }, +, + /**, +++ b/common/src/main/templates/io/netty/util/collection/KObjectHashMap.template, + // The array lengths are always a power of two, so we can use
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java, + } else if (status.code() == HttpResponseStatus.RESET_CONTENT.code()) {, +, + // Stripping Transfer-Encoding:, + msg.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);, +, + // Set Content-Length: 0, + // https://httpstatuses.com/205, + msg.headers().setInt(HttpHeaderNames.CONTENT_LENGTH, 0);, + status.code() == HttpResponseStatus.NOT_MODIFIED.code() ||, + status.code() == HttpResponseStatus.RESET_CONTENT.code();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseEncoder.java, + } else if (status.code() == HttpResponseStatus.RESET_CONTENT.code()) {, +, + // Stripping Transfer-Encoding:, + msg.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);, +, + // Set Content-Length: 0, + // https://httpstatuses.com/205, + msg.headers().setInt(HttpHeaderNames.CONTENT_LENGTH, 0);, + status.code() == HttpResponseStatus.NOT_MODIFIED.code() ||, + status.code() == HttpResponseStatus.RESET_CONTENT.code();, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseEncoderTest.java, +, + @Test, + public void testStatusResetContentTransferContentLength() {, + testStatusResetContentTransferContentLength0(HttpHeaderNames.CONTENT_LENGTH, Unpooled.buffer().writeLong(8));, + }, +, + @Test, + public void testStatusResetContentTransferEncoding() {,
[+++ b/all/pom.xml, + <version>4.1.0.CR7</version>, +++ b/all/pom.xml, + <version>4.1.0.CR7</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR7</version>, +++ b/all/pom.xml, + <version>4.1.0.CR7</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR7</version>, +++ b/all/pom.xml, + <version>4.1.0.CR7</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR7</version>, +++ b/all/pom.xml, + <version>4.1.0.CR7</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR7</version>, +++ b/all/pom.xml, + <version>4.1.0.CR7</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.CR7</version>, +++ b/all/pom.xml, + <version>4.1.0.CR7</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR7</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, + ChannelFuture future = channel.write(res);, +, + future.addListener(new ChannelFutureListener() {, + @Override, + public void operationComplete(ChannelFuture future) {, + ChannelPipeline p = future.channel().pipeline();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, + ChannelFuture future = channel.write(res);, +, + future.addListener(new ChannelFutureListener() {, + @Override, + public void operationComplete(ChannelFuture future) {, + ChannelPipeline p = future.channel().pipeline();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, + ChannelFuture future = channel.write(res);, +, + future.addListener(new ChannelFutureListener() {, + @Override, + public void operationComplete(ChannelFuture future) {, + ChannelPipeline p = future.channel().pipeline();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java, + @Override]
[+++ b/microbench/pom.xml, + <dependencies>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport-native-epoll</artifactId>, + <version>${project.version}</version>, + <classifier>${epoll.classifier}</classifier>, + </dependency>, + </dependencies>, + <build>, + <plugins>, + <plugin>, + <artifactId>maven-compiler-plugin</artifactId>, + <configuration>, + <includes>, + <include>**/*.java</include>, + </includes>, + </configuration>, + </plugin>, + </plugins>, + </build>, + <artifactId>maven-compiler-plugin</artifactId>, + <configuration>, + <excludes>, + <exclude>**/Http2FrameWriterBenchmark.java</exclude>, + </excludes>, + </configuration>, + </plugin>, + <plugin>]
[+++ b/pom.xml, + <url>http://fisheye.jboss.org/browse/Netty</url>]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollServerChannelConfig.java]
[+++ b/codec-mqtt/pom.xml, + <name>Netty/Codec/MQTT</name>]
[+++ b/pom.xml, + <jetty.npn.version>1.1.11.v20150415</jetty.npn.version>, + <id>alpn-8u51</id>, + <activation>, + <property>, + <name>java.version</name>, + <value>1.8.0_51</value>, + </property>, + </activation>, + <properties>, + <jetty.alpn.version>8.1.4.v20150727</jetty.alpn.version>, + </properties>, + </profile>, + <profile>, + <jetty.npn.version.latest>1.1.11.v20150415</jetty.npn.version.latest>, + <jetty.alpn.version.latest8>8.1.4.v20150727</jetty.alpn.version.latest8>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + DecoderResult.failure(chunk.getDecoderResult().cause()));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + DecoderResult.failure(chunk.getDecoderResult().cause()));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + message.setDecoderResult(DecoderResult.failure(cause));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + DecoderResult.failure(chunk.getDecoderResult().cause()));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + message.setDecoderResult(DecoderResult.failure(cause));, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpInvalidMessageTest.java, + assertFalse(dr.isFailure());, + assertTrue(dr.isFailure());, + assertFalse(dr.isFailure());, + assertTrue(dr.isFailure());, + assertFalse(dr.isFailure());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + DecoderResult.failure(chunk.getDecoderResult().cause()));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + message.setDecoderResult(DecoderResult.failure(cause));, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpInvalidMessageTest.java, + assertFalse(dr.isFailure());, + assertTrue(dr.isFailure());, + assertFalse(dr.isFailure());, + assertTrue(dr.isFailure());, + assertFalse(dr.isFailure());, +++ b/codec/src/main/java/io/netty/handler/codec/DecoderResult.java, +import io.netty.util.Signal;, +, + protected static final Signal SIGNAL_UNFINISHED = new Signal(DecoderResult.class.getName() + ".UNFINISHED");, + protected static final Signal SIGNAL_SUCCESS = new Signal(DecoderResult.class.getName() + ".SUCCESS");, +, + public static final DecoderResult UNFINISHED = new DecoderResult(SIGNAL_UNFINISHED);, + public static final DecoderResult SUCCESS = new DecoderResult(SIGNAL_SUCCESS);, +
[+++ b/handler/pom.xml, + <scope>test</scope>]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, + // We used all possible ints in the past ( 1 - Integer.MAX_VALUE), time to scrub the stored channels, + // and re-assign ids., + AbstractEpollChannel[] channels = ids.values(AbstractEpollChannel.class);, + ids.clear();, +, +, + for (AbstractEpollChannel ch: channels) {, + id++;, + ch.id = id;, + ids.put(ch.id, ch);, + if (id == Integer.MAX_VALUE) {, + throw new IllegalStateException("Could not scrub ids");]
[+++ b/all/pom.xml, + <version>4.1.25.Final</version>, +++ b/all/pom.xml, + <version>4.1.25.Final</version>, +++ b/bom/pom.xml, + <version>4.1.25.Final</version>, + <tag>netty-4.1.25.Final</tag>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, +++ b/all/pom.xml, + <version>4.1.25.Final</version>, +++ b/bom/pom.xml, + <version>4.1.25.Final</version>, + <tag>netty-4.1.25.Final</tag>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, + <version>4.1.25.Final</version>, +
[+++ b/all/pom.xml, + <version>4.1.0.CR1</version>, +++ b/all/pom.xml, + <version>4.1.0.CR1</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR1</version>, +++ b/all/pom.xml, + <version>4.1.0.CR1</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR1</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR1</version>, +++ b/all/pom.xml, + <version>4.1.0.CR1</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR1</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR1</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR1</version>, +++ b/all/pom.xml, + <version>4.1.0.CR1</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR1</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR1</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR1</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR1</version>, +++ b/all/pom.xml, + <version>4.1.0.CR1</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR1</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR1</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR1</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR1</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.CR1</version>, +++ b/all/pom.xml, + <version>4.1.0.CR1</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR1</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR1</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServer.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerUpgradeHandler.java, +import static io.netty.util.AsciiString.containsAllContentEqualsIgnoreCase;, +import static io.netty.util.AsciiString.containsContentEqualsIgnoreCase;, +import static io.netty.util.internal.StringUtil.COMMA;, + List<String> connectionHeaderValues = request.headers().getAll(HttpHeaderNames.CONNECTION);, +, + if (connectionHeaderValues == null) {, + final StringBuilder concatenatedConnectionValue = new StringBuilder(connectionHeaderValues.size() * 10);, + for (CharSequence connectionHeaderValue : connectionHeaderValues) {, + concatenatedConnectionValue.append(connectionHeaderValue).append(COMMA);, + }, + concatenatedConnectionValue.setLength(concatenatedConnectionValue.length() - 1);, +, + List<CharSequence> values = splitHeader(concatenatedConnectionValue);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerUpgradeHandler.java, +import static io.netty.util.AsciiString.containsAllContentEqualsIgnoreCase;, +import static io.netty.util.AsciiString.containsContentEqualsIgnoreCase;, +import static io.netty.util.internal.StringUtil.COMMA;, + List<String> connectionHeaderValues = request.headers().getAll(HttpHeaderNames.CONNECTION);, +, + if (connectionHeaderValues == null) {, + final StringBuilder concatenatedConnectionValue = new StringBuilder(connectionHeaderValues.size() * 10);, + for (CharSequence connectionHeaderValue : connectionHeaderValues) {, + concatenatedConnectionValue.append(connectionHeaderValue).append(COMMA);, + }, + concatenatedConnectionValue.setLength(concatenatedConnectionValue.length() -
[+++ b/common/src/main/java/io/netty/util/ConstantPool.java, +import io.netty.util.internal.PlatformDependent;, +import java.util.concurrent.ConcurrentMap;, +import java.util.concurrent.atomic.AtomicInteger;, + private final ConcurrentMap<String, T> constants = PlatformDependent.newConcurrentHashMap();, + private AtomicInteger nextId = new AtomicInteger(1);, + checkNotNullAndNotEmpty(name);, + return getOrCreate(name);, + }, + /**, + * Get existing constant by name or creates new one if not exists. Threadsafe, + *, + * @param name the name of the {@link Constant}, + */, + private T getOrCreate(String name) {, + T constant = constants.get(name);, + if (constant == null) {, + final T tempConstant = newConstant(nextId(), name);, + constant = constants.putIfAbsent(name, tempConstant);, + if (constant == null) {, + return tempConstant;,
[+++ b/common/src/main/java/io/netty/util/concurrent/UnorderedThreadPoolEventExecutor.java, +import static java.util.concurrent.TimeUnit.NANOSECONDS;, +, + return runnable instanceof NonNotifyRunnable ?, + task : new RunnableScheduledFutureTask<V>(this, runnable, task);, + @Override, + public void execute(Runnable command) {, + super.schedule(new NonNotifyRunnable(command), 0, NANOSECONDS);, + }, +, +, + // This is a special wrapper which we will be used in execute(...) to wrap the submitted Runnable. This is needed as, + // ScheduledThreadPoolExecutor.execute(...) will delegate to submit(...) which will then use decorateTask(...)., + // The problem with this is that decorateTask(...) needs to ensure we only do our own decoration if we not call, + // from execute(...) as otherwise
[+++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollDomainSocketSslClientRenegotiateTest.java, +/*, + * Copyright 2019 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java, + assert dataLength >= 0;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java, + assert dataLength >= 0;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2LocalFlowController.java, + * @throws Http2Exception if the number of bytes returned exceeds the {@link #unconsumedBytes}, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java, + assert dataLength >= 0;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2LocalFlowController.java, + * @throws Http2Exception if the number of bytes returned exceeds the {@link #unconsumedBytes}, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoderTest.java, + decode().onDataRead(ctx, STREAM_ID, data, padding, true);, + // Verify that the event was absorbed and not propagated to the observer., + @Test, + public void emptyDataFrameShouldApplyFlowControl() throws Exception {, + final ByteBuf data = EMPTY_BUFFER;, + int padding = 0;, + int processedBytes =
[+++ b/common/src/main/java/io/netty/util/Signal.java, + private final UniqueName uname;, + uname = new UniqueName(map, name);, +++ b/common/src/main/java/io/netty/util/Signal.java, + private final UniqueName uname;, + uname = new UniqueName(map, name);, +++ b/common/src/main/java/io/netty/util/UniqueKey.java, + public UniqueKey(ConcurrentMap<String, Boolean> map, String name, Class<T> valueType) {, +++ b/common/src/main/java/io/netty/util/Signal.java, + private final UniqueName uname;, + uname = new UniqueName(map, name);, +++ b/common/src/main/java/io/netty/util/UniqueKey.java, + public UniqueKey(ConcurrentMap<String, Boolean> map, String name, Class<T> valueType) {, +++ b/common/src/main/java/io/netty/util/UniqueName.java, + public UniqueName(ConcurrentMap<String, Boolean> map, String name, Object... args) {, +++ b/common/src/main/java/io/netty/util/Signal.java, + private final UniqueName uname;, + uname = new UniqueName(map, name);, +++ b/common/src/main/java/io/netty/util/UniqueKey.java, + public UniqueKey(ConcurrentMap<String, Boolean> map, String name, Class<T> valueType)
[+++ b/example/pom.xml, + <scope>runtime</scope>, + </dependency>, + <dependency>, + <groupId>org.javassist</groupId>, + <artifactId>javassist</artifactId>, + <scope>runtime</scope>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + request.addHeader(Names.SEC_WEBSOCKET_ORIGIN, originValue);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + request.addHeader(Names.SEC_WEBSOCKET_ORIGIN, originValue);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java, + request.addHeader(Names.SEC_WEBSOCKET_ORIGIN, originValue);]
[+++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxyInitializer.java, +import io.netty.handler.logging.LoggingHandler;, + new LoggingHandler(LogLevel.INFO),]
[+++ b/src/main/java/org/jboss/netty/example/http/file/HttpStaticFileServerHandler.java, +import org.jboss.netty.handler.stream.ChunkedOioFile;, + ChannelFuture writeFuture = ch.write(new ChunkedOioFile(raf, 0, fileLength, 8192));, +++ b/src/main/java/org/jboss/netty/example/http/file/HttpStaticFileServerHandler.java, +import org.jboss.netty.handler.stream.ChunkedOioFile;, + ChannelFuture writeFuture = ch.write(new ChunkedOioFile(raf, 0, fileLength, 8192));, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/example/http/file/HttpStaticFileServerHandler.java, +import org.jboss.netty.handler.stream.ChunkedOioFile;, + ChannelFuture writeFuture = ch.write(new ChunkedOioFile(raf, 0, fileLength, 8192));, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/handler/stream/ChunkedOioFile.java, +/*, + * Copyright 2009 Red Hat, Inc., + *, + * Red Hat licenses this file to you under the Apache License, version 2.0, + * (the "License"); you may not use this file except in compliance with the, + * License. You may obtain a copy of the License at:, + *,
[+++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, + * Gets called after the {@link ChannelHandler} was added to the actual context and it's ready to handle events., + * Gets called after the {@link ChannelHandler} was removed from the actual context and it doesn't handle events, + * anymore., +++ b/transport/src/main/java/io/netty/channel/ChannelHandler.java, + * Gets called after the {@link ChannelHandler} was added to the actual context and it's ready to handle events., + * Gets called after the {@link ChannelHandler} was removed from the actual context and it doesn't handle events, + * anymore., +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, + ctx.forwardBufferContentAndRemove(ctxPrev, ctxNext);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskFileUpload.java, + return FileUploadUtil.hashCode(this);, + return o instanceof FileUpload && FileUploadUtil.equals(this, (FileUpload) o);, + return FileUploadUtil.compareTo(this, o);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskFileUpload.java, + return FileUploadUtil.hashCode(this);, + return o instanceof FileUpload && FileUploadUtil.equals(this, (FileUpload) o);, + return FileUploadUtil.compareTo(this, o);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/FileUploadUtil.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, +
[+++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, +, + if (resolveFuture.isDone()) {]
[+++ b/transport/src/main/java/io/netty/channel/nio/SelectedSelectionKeySet.java, +, + @Override, + public void remove() {, + throw new UnsupportedOperationException();, + }, +++ b/transport/src/main/java/io/netty/channel/nio/SelectedSelectionKeySet.java, +, + @Override, + public void remove() {, + throw new UnsupportedOperationException();, + }, +++ b/transport/test.log]
[+++ b/common/src/test/java/io/netty/util/HashedWheelTimerTest.java, + int maxTimeout = tickDuration + timeout + tickDuration;, + assertTrue("Timeout + " + scheduledTasks + " delay " + delay + " must be " + timeout + " < " + maxTimeout,, + delay >= timeout && delay < maxTimeout);]
[+++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/AbstractStringRedisMessage.java, +import io.netty.util.internal.StringUtil;, +, + @Override, + public String toString() {, + return new StringBuilder(StringUtil.simpleClassName(this)), + .append('['), + .append("content="), + .append(content), + .append(']').toString();, + }, +, +++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/AbstractStringRedisMessage.java, +import io.netty.util.internal.StringUtil;, +, + @Override, + public String toString() {, + return new StringBuilder(StringUtil.simpleClassName(this)), + .append('['), + .append("content="), + .append(content), + .append(']').toString();, + }, +, +++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/ArrayRedisMessage.java, +++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/AbstractStringRedisMessage.java, +import io.netty.util.internal.StringUtil;, +, + @Override, + public String toString() {, + return new StringBuilder(StringUtil.simpleClassName(this)), + .append('['), + .append("content="), + .append(content), + .append(']').toString();, + }, +, +++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/ArrayRedisMessage.java, +++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/ErrorRedisMessage.java, +++ b/codec-redis/src/main/java/io/netty/handler/codec/redis/AbstractStringRedisMessage.java, +import io.netty.util.internal.StringUtil;, +, + @Override, + public String toString() {,
[+++ b/example/pom.xml, + <groupId>org.eclipse.jetty.npn</groupId>, + <artifactId>npn-api</artifactId>, + </dependency>, + <dependency>, + <properties>, + <exampleClass>io.netty.example.spdy.server.SpdyServer</exampleClass>, + </properties>, + <properties>, + <exampleClass>io.netty.example.spdy.client.SpdyClient</exampleClass>, + </properties>, + </profile>, + </profiles>, +, + <commandlineArgs>, + ${argLine.common}, + ${argLine.leak}, + ${argLine.coverage}, + -classpath %classpath, + ${exampleClass}, + </commandlineArgs>, +++ b/example/pom.xml, + <groupId>org.eclipse.jetty.npn</groupId>, + <artifactId>npn-api</artifactId>, + </dependency>, + <dependency>, + <properties>, + <exampleClass>io.netty.example.spdy.server.SpdyServer</exampleClass>, + </properties>, + <properties>, + <exampleClass>io.netty.example.spdy.client.SpdyClient</exampleClass>, + </properties>, + </profile>, + </profiles>, +, + <commandlineArgs>, + ${argLine.common}, + ${argLine.leak}, + ${argLine.coverage}, + -classpath %classpath, + ${exampleClass}, + </commandlineArgs>, +++ b/example/src/main/java/io/netty/example/spdy/server/SpdyServer.java, +import io.netty.handler.ssl.SslProvider;, + SslContext sslCtx = SslContext.newServerContext(SslProvider.JDK, ssc.certificate(), ssc.privateKey());, +++ b/example/pom.xml, + <groupId>org.eclipse.jetty.npn</groupId>,
[+++ b/src/docbook/en-US/module/architecture.xml, + to represent a sequence of bytes. This approach has significant advantages, + &ChannelBuffer; has been designed from the ground up to address the problems, + You can define your own buffer type if necessary., + Transparent zero copy is achieved by a built-in composite buffer type., + Traditional I/O APIs in Java provide different types and methods for, + another tedious and difficult. The lack of portability between, + transports becomes a problem when you need to support additional, + transports, as this often entails rewriting the network layer of the, + application. Logically, many protocols
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + private static final String LEGACY_PROP_CHECK_ACCESSIBLE = "io.netty.buffer.bytebuf.checkAccessible";, + private static final String PROP_CHECK_ACCESSIBLE = "io.netty.buffer.checkAccessible";, + private static final String PROP_CHECK_BOUNDS = "io.netty.buffer.checkBounds";, + private static final boolean checkBounds;, + if (SystemPropertyUtil.contains(PROP_CHECK_ACCESSIBLE)) {, + checkAccessible = SystemPropertyUtil.getBoolean(PROP_CHECK_ACCESSIBLE, true);, + } else {, + checkAccessible = SystemPropertyUtil.getBoolean(LEGACY_PROP_CHECK_ACCESSIBLE, true);, + }, + checkBounds = SystemPropertyUtil.getBoolean(PROP_CHECK_BOUNDS, true);, + logger.debug("-D{}: {}", PROP_CHECK_ACCESSIBLE, checkAccessible);, + logger.debug("-D{}: {}", PROP_CHECK_BOUNDS, checkBounds);, + private static void checkIndexBounds(final int readerIndex, final int writerIndex, final int capacity) {, + if (readerIndex < 0 || readerIndex > writerIndex || writerIndex > capacity) {, + throw new IndexOutOfBoundsException(String.format(,
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, +import static io.netty.handler.codec.http2.Http2Error.STREAM_CLOSED;, + state(stream).cancel(STREAM_CLOSED, null);, + if (HALF_CLOSED_LOCAL == stream.state()) {, + state(stream).cancel(STREAM_CLOSED, null);, + cancel(INTERNAL_ERROR, cause);, + * @param error the {@link Http2Error} to use., + void cancel(Http2Error error, Throwable cause) {, + final Http2Exception exception = streamError(stream.id(), error, cause,, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, +import static io.netty.handler.codec.http2.Http2Error.STREAM_CLOSED;, + state(stream).cancel(STREAM_CLOSED, null);, + if (HALF_CLOSED_LOCAL == stream.state()) {, + state(stream).cancel(STREAM_CLOSED, null);, + cancel(INTERNAL_ERROR, cause);, + * @param error the {@link Http2Error} to use., + void cancel(Http2Error error, Throwable cause) {, + final Http2Exception exception = streamError(stream.id(), error, cause,, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + private boolean outboundClosed;, + outboundClosed = true;, +
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java, + return new DefaultDnsPtrRecord(name, dnsClass, timeToLive, decodeName0(in));, + protected String decodeName0(ByteBuf in) {, + return decodeName(in);, + }, +, + /**, + * Retrieves a domain name given a buffer containing a DNS packet. If the, + * name contains a pointer, the position of the buffer will be set to, + * directly after the pointer's index after the name has been read., + *, + * @param in the byte buffer containing the DNS packet, + * @return the domain name for an entry, + */, + public static String decodeName(ByteBuf in) {, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java,
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketGatheringWriteTest.java, +import org.junit.AfterClass;, +import org.junit.Rule;, +import org.junit.rules.Timeout;, + @Rule, + public final Timeout globalTimeout = new Timeout(60000);, +, + @AfterClass, + public static void compressHeapDumps() throws Exception {, + TestUtils.compressHeapDumps();, + }, +, + @Test, + @Test, + @Test, + @Test, + @Test, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketGatheringWriteTest.java, +import org.junit.AfterClass;, +import org.junit.Rule;, +import org.junit.rules.Timeout;, + @Rule, + public final Timeout globalTimeout = new Timeout(60000);, +, + @AfterClass, + public static void compressHeapDumps() throws Exception {, + TestUtils.compressHeapDumps();, + }, +, + @Test, + @Test, + @Test, + @Test, + @Test, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java, +import org.junit.AfterClass;, + @AfterClass, + public static void compressHeapDumps()
[+++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, + public RxtxChannelConfig setAutoClose(boolean autoClose) {, + super.setAutoClose(autoClose);, + return this;, + }, +, + @Override, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, + public RxtxChannelConfig setAutoClose(boolean autoClose) {, + super.setAutoClose(autoClose);, + return this;, + }, +, + @Override, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java, + RxtxChannelConfig setAutoClose(boolean autoClose);, +, + @Override, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, + public RxtxChannelConfig setAutoClose(boolean autoClose) {, + super.setAutoClose(autoClose);, + return this;, + }, +, + @Override, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelConfig.java, + RxtxChannelConfig setAutoClose(boolean autoClose);, +, + @Override, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java, + public SctpChannelConfig setAutoClose(boolean autoClose) {, + super.setAutoClose(autoClose);, + return this;, + }, +, + @Override, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, + public RxtxChannelConfig setAutoClose(boolean autoClose) {, +
[+++ b/common/src/main/java/io/netty/util/AttributeMap.java, + <T> Attribute<T> attr(AttributeKey<T> key);]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +import java.util.concurrent.RejectedExecutionException;, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(DefaultHttp2StreamChannel.class);, +, + final boolean wasActive = isActive();, +, + fireChannelInactiveAndDeregister(voidPromise(), wasActive);, + fireChannelInactiveAndDeregister(promise, false);, + }, +, + private void fireChannelInactiveAndDeregister(final ChannelPromise promise,, + final boolean fireChannelInactive) {, +, + if (!registered) {, + return;, + }, +, + // As a user may call deregister() from within any method while doing processing in the ChannelPipeline,, + // we need to ensure we do the actual deregister operation later. This is necessary to preserve the, + // behavior of the AbstractChannel, which always
[+++ b/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentClient.java, +import io.netty.buffer.ChannelBuffers;, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelBootstrap;, +import io.netty.channel.ChannelInitializer;, +import io.netty.channel.ChannelOption;, +import io.netty.channel.socket.DatagramPacket;, +import io.netty.channel.socket.nio.NioDatagramChannel;, +import io.netty.channel.socket.nio.SelectorEventLoop;, +import java.net.InetSocketAddress;, +, + public void run() throws Exception {, + ChannelBootstrap b = new ChannelBootstrap();, + try {, + b.eventLoop(new SelectorEventLoop()), + .channel(new NioDatagramChannel()), + .localAddress(new InetSocketAddress(0)), + .option(ChannelOption.SO_BROADCAST, true), + .initializer(new ChannelInitializer() {, + @Override, + public void initChannel(Channel ch) throws Exception {, + ch.pipeline().addLast(new QuoteOfTheMomentClientHandler());, + Channel ch = b.bind().sync().channel();, + ch.write(new DatagramPacket(, + ChannelBuffers.copiedBuffer("QOTM?", CharsetUtil.UTF_8),, + new InetSocketAddress("255.255.255.255", port)));, + if (!ch.closeFuture().await(5000)) {, + } finally {, + b.shutdown();, + }, +++ b/example/src/main/java/io/netty/example/qotm/QuoteOfTheMomentClient.java, +import io.netty.buffer.ChannelBuffers;, +import io.netty.channel.Channel;,
[+++ b/example/src/main/java/io/netty/example/telnet/TelnetServer.java, + .childHandler(new TelnetServerInitializer());, +++ b/example/src/main/java/io/netty/example/telnet/TelnetServer.java, + .childHandler(new TelnetServerInitializer());, +++ b/example/src/main/java/io/netty/example/telnet/TelnetServerInitializer.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT,
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + Socket fd = fileDescriptor;, + if (!fd.isShutdown()) {, + fd().shutdown();, + if (edgeTriggered && !fd().isInputShutdown()) {, + if (!fd().isInputShutdown()) {, + if (fd().isOutputShutdown()) {, + return;, + }, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + Socket fd = fileDescriptor;, + if (!fd.isShutdown()) {, + fd().shutdown();, + if (edgeTriggered && !fd().isInputShutdown()) {, + if (!fd().isInputShutdown()) {, + if (fd().isOutputShutdown()) {, + return;, + }, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollServerChannel.java, + if (fd().isInputShutdown()) {, + return;, + }, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + Socket fd = fileDescriptor;, + if (!fd.isShutdown()) {, + fd().shutdown();, + if (edgeTriggered && !fd().isInputShutdown()) {, + if (!fd().isInputShutdown()) {, + if (fd().isOutputShutdown()) {,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientUpgradeHandler.java, + CharSequence protocol();, + Collection<CharSequence> setUpgradeHeaders(ChannelHandlerContext ctx, HttpRequest upgradeRequest);, + Set<CharSequence> connectionParts = new LinkedHashSet<CharSequence>(2);, + for (CharSequence part : connectionParts) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientUpgradeHandler.java, + CharSequence protocol();, + Collection<CharSequence> setUpgradeHeaders(ChannelHandlerContext ctx, HttpRequest upgradeRequest);, + Set<CharSequence> connectionParts = new LinkedHashSet<CharSequence>(2);, + for (CharSequence part : connectionParts) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderValues.java, + * {@code "0"}, + */, + public static final AsciiString ZERO = new AsciiString("0");, + /**, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientUpgradeHandler.java, + CharSequence protocol();, + Collection<CharSequence> setUpgradeHeaders(ChannelHandlerContext ctx, HttpRequest upgradeRequest);, + Set<CharSequence> connectionParts = new LinkedHashSet<CharSequence>(2);, + for (CharSequence part : connectionParts) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderValues.java, + * {@code "0"}, + */,
[+++ b/all/pom.xml, + <version>4.1.13.Final</version>, +++ b/all/pom.xml, + <version>4.1.13.Final</version>, +++ b/bom/pom.xml, + <version>4.1.13.Final</version>, + <tag>netty-4.1.13.Final</tag>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, +++ b/all/pom.xml, + <version>4.1.13.Final</version>, +++ b/bom/pom.xml, + <version>4.1.13.Final</version>, + <tag>netty-4.1.13.Final</tag>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, + <version>4.1.13.Final</version>, +
[+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, +import io.netty.util.concurrent.EventExecutor;, +import io.netty.util.internal.ThreadExecutorMap;, +import java.util.concurrent.TimeUnit;, + private static final long DEFAULT_CACHE_TRIM_INTERVAL_MILLIS;, + private final Runnable trimTask = new Runnable() {, + @Override, + public void run() {, + PooledByteBufAllocator.this.trimCurrentThreadCache();, + }, + };, +, + DEFAULT_CACHE_TRIM_INTERVAL_MILLIS = SystemPropertyUtil.getLong(, + "io.netty.allocation.cacheTrimIntervalMillis", 0);, +, + logger.debug("-Dio.netty.allocator.cacheTrimIntervalMillis: {}", DEFAULT_CACHE_TRIM_INTERVAL_MILLIS);, + final Thread current = Thread.currentThread();, + final PoolThreadCache cache = new PoolThreadCache(, +, + if (DEFAULT_CACHE_TRIM_INTERVAL_MILLIS > 0) {, + final EventExecutor executor = ThreadExecutorMap.currentExecutor();, + if (executor != null) {, + executor.scheduleAtFixedRate(trimTask, DEFAULT_CACHE_TRIM_INTERVAL_MILLIS,, + DEFAULT_CACHE_TRIM_INTERVAL_MILLIS, TimeUnit.MILLISECONDS);, + }, + }, + return cache;, + * Trim thread local
[+++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtAcceptorChannel.java, +import com.barchart.udt.nio.SocketChannelUDT;, +import io.netty.channel.ChannelMetadata;, +import io.netty.channel.udt.UdtChannel;, +import java.util.List;, + private static final ChannelMetadata METADATA = new ChannelMetadata(false);, +, + @Override, + public ChannelMetadata metadata() {, + return METADATA;, + }, +, + @Override, + protected int doReadMessages(List<Object> buf) throws Exception {, + final SocketChannelUDT channelUDT = javaChannel().accept();, + if (channelUDT == null) {, + return 0;, + } else {, + buf.add(newConnectorChannel(channelUDT));, + return 1;, + }, + }, +, + protected abstract UdtChannel newConnectorChannel(SocketChannelUDT channelUDT);, +++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtAcceptorChannel.java, +import com.barchart.udt.nio.SocketChannelUDT;, +import io.netty.channel.ChannelMetadata;, +import io.netty.channel.udt.UdtChannel;, +import java.util.List;, + private static final ChannelMetadata METADATA = new ChannelMetadata(false);, +, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockJZlibEncoder.java, + return Unpooled.EMPTY_BUFFER;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockJZlibEncoder.java, + return Unpooled.EMPTY_BUFFER;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibEncoder.java, +, + return Unpooled.EMPTY_BUFFER;]
[+++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Throwable e) {, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Throwable e) {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +import io.netty.channel.socket.DatagramChannel;, +import io.netty.channel.socket.ServerSocketChannel;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.channel.socket.nio.NioSocketChannelConfig;, +, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Throwable e) {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +import io.netty.channel.socket.DatagramChannel;, +import io.netty.channel.socket.ServerSocketChannel;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.channel.socket.nio.NioSocketChannelConfig;, +, +++ /dev/null, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Throwable e) {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +import io.netty.channel.socket.DatagramChannel;, +import io.netty.channel.socket.ServerSocketChannel;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.channel.socket.nio.NioSocketChannelConfig;, +, +++ /dev/null, +++ /dev/null, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Throwable e) {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +import io.netty.channel.socket.DatagramChannel;, +import io.netty.channel.socket.ServerSocketChannel;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.channel.socket.nio.NioSocketChannelConfig;, +, +++ /dev/null, +++ /dev/null, +++ b/transport/src/main/java/io/netty/channel/socket/Worker.java, +/*
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, +import io.netty.channel.ChannelInboundHandlerContext;, +import io.netty.handler.codec.MessageToMessageDecoder;, +public abstract class HttpContentDecoder extends MessageToMessageDecoder<Object, Object> {, + public Object decode(ChannelInboundHandlerContext<Object> ctx, Object msg) throws Exception {, + return msg;, + return new Object[] { new DefaultHttpChunk(lastProduct), c };, + }, + }, + }, + // Because HttpMessage and HttpChunk is a mutable object, we can simply forward it., + return msg;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, +import io.netty.channel.ChannelInboundHandlerContext;, +import io.netty.handler.codec.MessageToMessageDecoder;, +public abstract class HttpContentDecoder extends MessageToMessageDecoder<Object, Object> {, + public Object decode(ChannelInboundHandlerContext<Object> ctx, Object msg) throws Exception {, + return msg;, + return new Object[] { new DefaultHttpChunk(lastProduct), c };, + }, +
[+++ b/NOTICE.txt, +This product optionally depends on 'lz4', a LZ4 Java compression, +and decompression library written by Adrien Grand. It can be obtained at:, +, + * LICENSE:, + * license/LICENSE.lz4.txt (Apache License 2.0), + * HOMEPAGE:, + * https://github.com/jpountz/lz4-java, +, +++ b/NOTICE.txt, +This product optionally depends on 'lz4', a LZ4 Java compression, +and decompression library written by Adrien Grand. It can be obtained at:, +, + * LICENSE:, + * license/LICENSE.lz4.txt (Apache License 2.0), + * HOMEPAGE:, + * https://github.com/jpountz/lz4-java, +, +++ b/codec/pom.xml, + <dependency>, + <groupId>net.jpountz.lz4</groupId>, + <artifactId>lz4</artifactId>, + <optional>true</optional>, + </dependency>, +++ b/NOTICE.txt, +This product optionally
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + * Return the reason (if any) why {@code sun.misc.Unsafe} was not available., + */, + public static Throwable getUnsafeUnavailabilityCause() {, + return PlatformDependent0.getUnsafeUnavailabilityCause();, + }, +, + /**, + } catch (Throwable t) {, + logger.trace("Could not determine if Unsafe is available", t);, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + * Return the reason (if any) why {@code sun.misc.Unsafe} was not available., + */, + public static Throwable getUnsafeUnavailabilityCause() {, + return PlatformDependent0.getUnsafeUnavailabilityCause();, + }, +, + /**, + } catch (Throwable t) {, + logger.trace("Could not determine if Unsafe is available", t);, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + private static final Throwable
[+++ b/pom.xml, + -link http://docs.jboss.org/xnio/latest/api/]
[+++ /dev/null, +++ /dev/null, +++ b/transport-native-unix-common/src/main/java/io/netty/channel/unix/UnixChannelUtil.java, + return isBufferCopyNeededForWrite(byteBuf, IOV_MAX);, + }, +, + static boolean isBufferCopyNeededForWrite(ByteBuf byteBuf, int iovMax) {, + return !byteBuf.hasMemoryAddress() && (!byteBuf.isDirect() || byteBuf.nioBufferCount() > iovMax);, +++ /dev/null, +++ b/transport-native-unix-common/src/main/java/io/netty/channel/unix/UnixChannelUtil.java, + return isBufferCopyNeededForWrite(byteBuf, IOV_MAX);, + }, +, + static boolean isBufferCopyNeededForWrite(ByteBuf byteBuf, int iovMax) {, + return !byteBuf.hasMemoryAddress() && (!byteBuf.isDirect() || byteBuf.nioBufferCount() > iovMax);, +++ b/transport-native-unix-common/src/test/java/io/netty/channel/unix/UnixChannelUtilTest.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyDataFrame.java, + * Copyright 2013 The Netty Project, +import io.netty.buffer.IllegalBufferAccessException;, +public class DefaultSpdyDataFrame extends DefaultSpdyStreamFrame implements SpdyDataFrame {, + private final ByteBuf data;, + super(streamId);, + if (data == null) {, + throw new NullPointerException("data");, + }, + this.data = validate(data);, + super.setStreamId(streamId);, + super.setLast(last);, + public ByteBuf content() {, + if (data.refCnt() <= 0) {, + throw new IllegalBufferAccessException();, + }, + return data;, + }, +, + @Override, + public SpdyDataFrame copy() {, + SpdyDataFrame frame = new DefaultSpdyDataFrame(getStreamId(), content().copy());, + public int refCnt() {, + return data.refCnt();, + }, +, + @Override, + data.retain();, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponse.java, + * <h3>Accessing Cookies</h3>, + * Gets the status of this {@link HttpResponse}., + *, + * @return The {@link HttpResponseStatus} of this {@link HttpResponse}, + * Sets the status of this {@link HttpResponse}, + *, + * @param status The {@link HttpResponseStatus} to use]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java, + return !message.headers().containsValue(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE, true) &&, + (message.protocolVersion().isKeepAliveDefault() ||, + message.headers().containsValue(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE, true));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java, + return !message.headers().containsValue(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE, true) &&, + (message.protocolVersion().isKeepAliveDefault() ||, + message.headers().containsValue(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE, true));, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpUtilTest.java, +, + @Test, + public void testKeepAliveIfConnectionHeaderMultipleValues() {, + HttpMessage http11Message = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET,, + "http:localhost/http_1_1");, + http11Message.headers().set(, + HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE + ", " + HttpHeaderValues.CLOSE);, + assertFalse(HttpUtil.isKeepAlive(http11Message));, +, + http11Message.headers().set(, + HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE + ", Close");, + assertFalse(HttpUtil.isKeepAlive(http11Message));, +, + http11Message.headers().set(, + HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE + ", " + HttpHeaderValues.UPGRADE);, + assertFalse(HttpUtil.isKeepAlive(http11Message));, +, + http11Message.headers().set(, + HttpHeaderNames.CONNECTION, HttpHeaderValues.UPGRADE + ", " + HttpHeaderValues.KEEP_ALIVE);, + assertTrue(HttpUtil.isKeepAlive(http11Message));, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + if (msg instanceof LastHttpContent) {, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + if (msg instanceof LastHttpContent) {, + }, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java, + HttpContent chunk4 = LastHttpContent.EMPTY_LAST_CONTENT;, + assertFalse(embedder.writeInbound(chunk4.copy()));, + assertFalse(embedder.writeInbound(chunk4.copy()));]
[+++ b/example/pom.xml]
[+++ b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java, + private final boolean stayClosed;, + private volatile boolean closed;, + this(executor, false);, + this(name, executor, false);, + }, +, + /**, + * Creates a new group with a generated name and the provided {@link EventExecutor} to notify the, + * {@link ChannelGroupFuture}s. {@code stayClosed} defines whether or not, this group can be closed, + * more than once. Adding channels to a closed group will immediately close them, too. This makes it, + * easy, to shutdown server and child channels at once., + */, + public DefaultChannelGroup(EventExecutor executor, boolean stayClosed) {, + this("group-0x" +
[+++ b/pom.xml, + <version>3.0.0.CR5-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/pom.xml, + <version>1.2.5.GA</version>]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + if (activeStreams.add(this)) {, + // Update the number of active streams initiated by the endpoint., + createdBy().numActiveStreams++;, +, + // Notify the listeners., + for (Listener listener : listeners) {, + listener.streamActive(this);, + }, + }, + if (activeStreams.remove(this)) {, + try {, + // Update the number of active streams initiated by the endpoint., + createdBy().numActiveStreams--;, +, + // Notify the listeners., + for (Listener listener : listeners) {, + listener.streamClosed(this);, + }, + } finally {, + // Mark this stream for removal., + removalPolicy.markForRemoval(this);, + }, + }, + private int maxActiveStreams;, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java, + SslUtils.notifyHandshakeFailure(ctx, e, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java, + SslUtils.notifyHandshakeFailure(ctx, e, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + private boolean handshakeStarted;, + * {@link #setHandshakeFailure(ChannelHandlerContext, Throwable, boolean, boolean)} or, + setHandshakeFailure(ctx, CHANNEL_CLOSED, !outboundClosed, handshakeStarted);, + setHandshakeFailure(ctx, cause, true, true);, + private void setHandshakeFailure(ChannelHandlerContext ctx, Throwable cause, boolean closeInbound, boolean notify) {, + notifyHandshakeFailure(cause, notify);, + private void notifyHandshakeFailure(Throwable cause, boolean notify) {, + SslUtils.notifyHandshakeFailure(ctx, cause, notify);, + startHandshakeProcessing();, + }, + }, +, + private void startHandshakeProcessing() {, + handshakeStarted = true;, + notifyHandshakeFailure(HANDSHAKE_TIMED_OUT, true);, + startHandshakeProcessing();, +++ b/handler/src/main/java/io/netty/handler/ssl/AbstractSniHandler.java, + SslUtils.notifyHandshakeFailure(ctx, e, true);, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + private boolean handshakeStarted;, + * {@link
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + if (HttpUtil.isUnsupportedExpectation(start)) {, + // if the request contains an unsupported expectation, we return 417, + pipeline.fireUserEventTriggered(HttpExpectationFailedEvent.INSTANCE);, + return EXPECTATION_FAILED.retainedDuplicate();, + } else if (HttpUtil.is100ContinueExpected(start)) {, + // if the request contains 100-continue but the content-length is too large, we return 413, + return TOO_LARGE.retainedDuplicate();, +, + if (msg instanceof HttpResponse) {, + final HttpResponse httpResponse = (HttpResponse) msg;, + return httpResponse.status().codeClass().equals(HttpStatusClass.CLIENT_ERROR);, + }, + return false;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + if (HttpUtil.isUnsupportedExpectation(start)) {, + // if the request contains an unsupported expectation, we return 417, + pipeline.fireUserEventTriggered(HttpExpectationFailedEvent.INSTANCE);, + return EXPECTATION_FAILED.retainedDuplicate();, + } else if (HttpUtil.is100ContinueExpected(start)) {,
[+++ b/pom.xml, + <version>3.0.0.CR2-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/testsuite/pom.xml, + <skipAutobahnTestsuite>false</skipAutobahnTestsuite>, + <skipAutobahnTestsuite>true</skipAutobahnTestsuite>, + <version>0.1.3</version>, + <case>*</case>, + <skip>${skipAutobahnTestsuite}</skip>]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + libNames.add("netty_tcnative_" + os + '_' + arch);, + libNames.add("netty_tcnative_" + os + '_' + arch + "_fedora");]
[+++ b/NOTICE.txt, +++ b/NOTICE.txt, +++ b/codec/src/test/java/io/netty/handler/codec/compression/JZlibTest.java, +++ b/NOTICE.txt, +++ b/codec/src/test/java/io/netty/handler/codec/compression/JZlibTest.java, +++ /dev/null]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, + @SuppressWarnings("StatementWithEmptyBody"), +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, + @SuppressWarnings("StatementWithEmptyBody"), +++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, + Method method = helper.getMethod("loadLibrary", String.class, boolean.class);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, + @SuppressWarnings("StatementWithEmptyBody"), +++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, + Method method = helper.getMethod("loadLibrary", String.class, boolean.class);, +++ b/common/src/main/java/io/netty/util/internal/ObjectUtil.java, + return wrapper != null ? wrapper : defaultValue;, + return wrapper != null ? wrapper : defaultValue;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, + @SuppressWarnings("StatementWithEmptyBody"), +++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, + Method method = helper.getMethod("loadLibrary", String.class, boolean.class);, +++ b/common/src/main/java/io/netty/util/internal/ObjectUtil.java, + return wrapper != null ? wrapper : defaultValue;, + return wrapper != null ? wrapper : defaultValue;, +++ b/example/src/main/java/io/netty/example/http/websocketx/benchmarkserver/WebSocketServerHandler.java]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/FastLz.java, + ref = anchor + (3 - 1);, +++ b/codec/src/main/java/io/netty/handler/codec/compression/FastLz.java, + ref = anchor + (3 - 1);, +++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, + for (int i = 0; i < BYTE2HEX_PAD.length; i++) {, + BYTE2HEX_PAD[i] = i > 0xf ? str : ('0' + str);, + return c - ('A' - 0xA);, + return c - ('a' - 0xA);]
[+++ b/transport/src/main/java/io/netty/channel/SimpleChannelInboundHandler.java, + * protected void channelRead0({@link ChannelHandlerContext} ctx, {@link String} message)]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java, +, + @Override, + public BinaryWebSocketFrame retain() {, + super.retain();, + return this;, + }, +, + @Override, + public BinaryWebSocketFrame retain(int increment) {, + super.retain(increment);, + return this;, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java, +, + @Override, + public BinaryWebSocketFrame retain() {, + super.retain();, + return this;, + }, +, + @Override, + public BinaryWebSocketFrame retain(int increment) {, + super.retain(increment);, + return this;, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java, +, + @Override, + public CloseWebSocketFrame retain() {, + super.retain();, + return this;, + }, +, + @Override, + public CloseWebSocketFrame retain(int increment) {, + super.retain(increment);, + return this;, + },
[+++ b/pom.xml, + <!-- 1.4.x does not work in Java10+ -->, + <jboss.marshalling.version>2.0.5.Final</jboss.marshalling.version>, + <jboss.marshalling.version>1.4.11.Final</jboss.marshalling.version>]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, + headersEncoder.encodeHeaders(streamId, headers, headerBlock);, + headersEncoder.encodeHeaders(streamId, headers, headerBlock);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, + headersEncoder.encodeHeaders(streamId, headers, headerBlock);, + headersEncoder.encodeHeaders(streamId, headers, headerBlock);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java, + public void encodeHeaders(int streamId, Http2Headers headers, ByteBuf buffer) throws Http2Exception {, + encoder.encodeHeaders(streamId, buffer, headers, sensitivityDetector);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, + headersEncoder.encodeHeaders(streamId, headers, headerBlock);, + headersEncoder.encodeHeaders(streamId, headers, headerBlock);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java, + public void encodeHeaders(int streamId, Http2Headers headers, ByteBuf buffer) throws Http2Exception {, + encoder.encodeHeaders(streamId, buffer, headers, sensitivityDetector);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2HeadersEncoder.java, + * @param streamId the identifier of the stream for which the headers are encoded., + void encodeHeaders(int streamId, Http2Headers headers, ByteBuf buffer) throws Http2Exception;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, + headersEncoder.encodeHeaders(streamId,
[+++ b/codec/pom.xml, + <!-- Test dependency for Bzip2 compression codec -->, +++ b/codec/pom.xml, + <!-- Test dependency for Bzip2 compression codec -->, +++ b/codec/src/test/java/io/netty/handler/codec/compression/AbstractCompressionTest.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + *
[+++ b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.ByteBufHolder;, + futures.put(c.id(), c.write(safeDuplicate(message)));, + int size = messages.size();, + MessageList<Object> messageCopy = MessageList.newInstance(size);, + for (int i = 0 ; i < size; i++) {, + messageCopy.add(safeDuplicate(messages.get(i)));, + }, + futures.put(c.id(), c.write(messageCopy));, + // Create a safe duplicate of the message to write it to a channel but not affect other writes., + // See https://github.com/netty/netty/issues/1461, + private static Object safeDuplicate(Object message) {, + if (message instanceof ByteBuf) {, + return ((ByteBuf) message).duplicate().retain();, + } else if (message instanceof ByteBufHolder) {, + return ((ByteBufHolder) message).copy();, + } else {, + return ReferenceCountUtil.retain(message);, +
[+++ b/all/pom.xml, + <version>4.0.4.Final</version>, +++ b/all/pom.xml, + <version>4.0.4.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.4.Final</version>, +++ b/all/pom.xml, + <version>4.0.4.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.4.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.4.Final</version>, +++ b/all/pom.xml, + <version>4.0.4.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.4.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.4.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.4.Final</version>, +++ b/all/pom.xml, + <version>4.0.4.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.4.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.4.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.4.Final</version>, +++ b/codec/pom.xml, + <version>4.0.4.Final</version>, +++ b/all/pom.xml, + <version>4.0.4.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.4.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.4.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.4.Final</version>, +++ b/codec/pom.xml, + <version>4.0.4.Final</version>, +++ b/common/pom.xml, + <version>4.0.4.Final</version>, +++ b/all/pom.xml, + <version>4.0.4.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.4.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.4.Final</version>, +++ b/codec-socks/pom.xml, +
[+++ b/src/main/java/org/jboss/netty/channel/socket/DefaultServerSocketChannelConfig.java, +import org.jboss.netty.util.ConversionUtil;, + setReceiveBufferSize(ConversionUtil.toInt(value));, + setReuseAddress(ConversionUtil.toBoolean(value));, + setBacklog(ConversionUtil.toInt(value));, +++ b/src/main/java/org/jboss/netty/channel/socket/DefaultServerSocketChannelConfig.java, +import org.jboss.netty.util.ConversionUtil;, + setReceiveBufferSize(ConversionUtil.toInt(value));, + setReuseAddress(ConversionUtil.toBoolean(value));, + setBacklog(ConversionUtil.toInt(value));, +++ b/src/main/java/org/jboss/netty/channel/socket/DefaultSocketChannelConfig.java, +import org.jboss.netty.util.ConversionUtil;, + setReceiveBufferSize(ConversionUtil.toInt(value));, + setSendBufferSize(ConversionUtil.toInt(value));, + setTcpNoDelay(ConversionUtil.toBoolean(value));, + setKeepAlive(ConversionUtil.toBoolean(value));, + setReuseAddress(ConversionUtil.toBoolean(value));, + setSoLinger(ConversionUtil.toInt(value));, + setTrafficClass(ConversionUtil.toInt(value));, + setWriteTimeoutMillis(ConversionUtil.toInt(value));, + setConnectTimeoutMillis(ConversionUtil.toInt(value));, +++ b/src/main/java/org/jboss/netty/channel/socket/DefaultServerSocketChannelConfig.java, +import org.jboss.netty.util.ConversionUtil;, + setReceiveBufferSize(ConversionUtil.toInt(value));, + setReuseAddress(ConversionUtil.toBoolean(value));, + setBacklog(ConversionUtil.toInt(value));, +++ b/src/main/java/org/jboss/netty/channel/socket/DefaultSocketChannelConfig.java, +import org.jboss.netty.util.ConversionUtil;, + setReceiveBufferSize(ConversionUtil.toInt(value));, + setSendBufferSize(ConversionUtil.toInt(value));, + setTcpNoDelay(ConversionUtil.toBoolean(value));, + setKeepAlive(ConversionUtil.toBoolean(value));, + setReuseAddress(ConversionUtil.toBoolean(value));, + setSoLinger(ConversionUtil.toInt(value));, + setTrafficClass(ConversionUtil.toInt(value));, + setWriteTimeoutMillis(ConversionUtil.toInt(value));, + setConnectTimeoutMillis(ConversionUtil.toInt(value));, +++ b/src/main/java/org/jboss/netty/channel/socket/nio/DefaultNioSocketChannelConfig.java, +import org.jboss.netty.util.ConversionUtil;, + setReadWriteFair(ConversionUtil.toBoolean(value));, + setWriteSpinCount(ConversionUtil.toInt(value));, +++ b/src/main/java/org/jboss/netty/channel/socket/DefaultServerSocketChannelConfig.java, +import org.jboss.netty.util.ConversionUtil;, + setReceiveBufferSize(ConversionUtil.toInt(value));, + setReuseAddress(ConversionUtil.toBoolean(value));, + setBacklog(ConversionUtil.toInt(value));, +++ b/src/main/java/org/jboss/netty/channel/socket/DefaultSocketChannelConfig.java, +import org.jboss.netty.util.ConversionUtil;, + setReceiveBufferSize(ConversionUtil.toInt(value));, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkedInput.java, +, + @Override, + public long length() {, + return input.length();, + }, +, + @Override, + public long progress() {, + return input.progress();, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkedInput.java, +, + @Override, + public long length() {, + return input.length();, + }, +, + @Override, + public long progress() {, + return input.progress();, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, + /**, + * Global Transfer progress, + */, + private long globalProgress;, + HttpContent nextChunk = nextChunk();, + globalProgress += nextChunk.content().readableBytes();, + return nextChunk;, + @Override, + public long length() {, + return isMultipart? globalBodySize : globalBodySize - 1;, +
[+++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, + @Deprecated, + @Deprecated]
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + if (!hasUnsafe() || !PlatformDependent0.unalignedAccess()) {, + } else if (PlatformDependent0.hasCharArray(bytes)) {, + return PlatformDependent0.hashCodeAscii(PlatformDependent0.charArray(bytes));, + } else if (PlatformDependent0.hasByteArray(bytes)) {, + return PlatformDependent0.hashCodeAscii(PlatformDependent0.byteArray(bytes));, + return hashCodeAsciiSafe(bytes);, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, + if (!hasUnsafe() || !PlatformDependent0.unalignedAccess()) {, + } else if (PlatformDependent0.hasCharArray(bytes)) {, + return PlatformDependent0.hashCodeAscii(PlatformDependent0.charArray(bytes));, + } else if (PlatformDependent0.hasByteArray(bytes)) {, + return PlatformDependent0.hashCodeAscii(PlatformDependent0.byteArray(bytes));, + return hashCodeAsciiSafe(bytes);, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + private static final long STRING_CHAR_VALUE_FIELD_OFFSET;, + private static final long STRING_BYTE_VALUE_FIELD_OFFSET;, + STRING_CHAR_VALUE_FIELD_OFFSET = STRING_BYTE_VALUE_FIELD_OFFSET = -1;, +, + if (stringValueField == null) {, + STRING_CHAR_VALUE_FIELD_OFFSET = STRING_BYTE_VALUE_FIELD_OFFSET = -1;, + } else {, + long stringValueFieldOffset =
[+++ b/all/pom.xml, + <version>4.1.0.Beta4</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta4</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta4</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta4</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta4</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta4</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta4</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta4</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta4</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta4</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta4</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta4</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta4</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta4</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta4</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta4</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta4</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta4</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta4</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta4</version>, +++ b/codec-http2/pom.xml, +<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">, + <version>4.1.0.Beta4</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta4</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta4</version>, +++ b/codec-dns/pom.xml,
[+++ b/all/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR4-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpHeadersTest.java, +, + @Test(expected = IllegalArgumentException.class), + public void testAddSelf() {, + HttpHeaders headers = new DefaultHttpHeaders(false);, + headers.add(headers);, + }, +, + @Test(expected = IllegalArgumentException.class), + public void testSetSelf() {, + HttpHeaders headers = new DefaultHttpHeaders(false);, + headers.set(headers);, + }, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpHeadersTest.java, +, + @Test(expected = IllegalArgumentException.class), + public void testAddSelf() {, + HttpHeaders headers = new DefaultHttpHeaders(false);, + headers.add(headers);, + }, +, + @Test(expected = IllegalArgumentException.class), + public void testSetSelf() {, + HttpHeaders headers = new DefaultHttpHeaders(false);, + headers.set(headers);, + }, +++ b/codec/src/main/java/io/netty/handler/codec/DefaultHeaders.java, + throw new IllegalArgumentException("can't add to itself.");, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpHeadersTest.java, +, + @Test(expected =
[+++ b/build/pom.xml, + <groupId>org.sonatype.oss</groupId>, + <artifactId>oss-parent</artifactId>, + <version>7</version>, + <relativePath></relativePath>, + <version>1-SNAPSHOT</version>, + <url>http://netty.io/</url>, + <description>, + Resources required to build Netty, + </description>, +, + <organization>, + <name>The Netty Project</name>, + <url>http://netty.io/</url>, + </organization>, +, + <licenses>, + <license>, + <name>Apache License, Version 2.0</name>, + <url>http://www.apache.org/licenses/LICENSE-2.0</url>, + </license>, + </licenses>, + <inceptionYear>2008</inceptionYear>, +, + <scm>, + <url>https://github.com/netty/netty</url>, + <connection>scm:git:git://github.com/netty/netty.git</connection>, + <developerConnection>scm:git:ssh://git@github.com/netty/netty.git</developerConnection>, + </scm>, +, + <developers>, + <developer>, + <id>netty.io</id>, + <name>The Netty Project Contributors</name>, + <email>netty@googlegroups.com</email>, + <url>http://netty.io/</url>, + <organization>The Netty Project</organization>, + <organizationUrl>http://netty.io/</organizationUrl>, + </developer>, + </developers>, +, +++ b/build/pom.xml, + <groupId>org.sonatype.oss</groupId>, + <artifactId>oss-parent</artifactId>, + <version>7</version>,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {, + super.handlerRemoved(ctx);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {, + super.handlerRemoved(ctx);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {, + super.handlerRemoved(ctx);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {, + super.handlerRemoved(ctx);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {, + super.handlerRemoved(ctx);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + public void handlerAdded(ChannelHandlerContext ctx) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {, + super.handlerRemoved(ctx);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {, + super.handlerRemoved(ctx);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + public void
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + doDeregister();, + protected void doDeregister() throws Exception {, + // NOOP, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + doDeregister();, + protected void doDeregister() throws Exception {, + // NOOP, +++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + doDeregister();, + protected void doDeregister() throws Exception {, + // NOOP, +++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java, +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, + protected void doDeregister() throws Exception {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + doDeregister();, + protected void doDeregister() throws Exception {, + // NOOP, +++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java, +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, + protected void doDeregister() throws Exception {, +++ b/transport/src/main/java/io/netty/channel/local/LocalServerChannel.java, + protected void doDeregister() throws Exception {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + doDeregister();, + protected void doDeregister() throws Exception
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, + * (can be null, if so, will try to default to the underlying platform ones), + this.searchDomains = searchDomains != null ? searchDomains.clone() : DEFAULT_SEARCH_DOMAINS;, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, + * (can be null, if so, will try to default to the underlying platform ones), + this.searchDomains = searchDomains != null ? searchDomains.clone() : DEFAULT_SEARCH_DOMAINS;, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java, + private String[] searchDomains;]
[+++ b/all/pom.xml, + <version>4.0.0.CR9</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR9</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR9</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR9</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR9</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR9</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR9</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR9</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR9</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR9</version>, +++ b/common/pom.xml, + <version>4.0.0.CR9</version>, +++ b/all/pom.xml, + <version>4.0.0.CR9</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR9</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR9</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec/src/test/java/io/netty/handler/codec/compression/Bzip2DecoderTest.java, + BZip2CompressorOutputStream bZip2Os = new BZip2CompressorOutputStream(os, randomBlockSize());, + BZip2CompressorOutputStream bZip2Os = new BZip2CompressorOutputStream(os, randomBlockSize());, +, + private static int randomBlockSize() {, + return rand.nextInt(MIN_BLOCK_SIZE, MAX_BLOCK_SIZE + 1);, + }, +++ b/codec/src/test/java/io/netty/handler/codec/compression/Bzip2DecoderTest.java, + BZip2CompressorOutputStream bZip2Os = new BZip2CompressorOutputStream(os, randomBlockSize());, + BZip2CompressorOutputStream bZip2Os = new BZip2CompressorOutputStream(os, randomBlockSize());, +, + private static int randomBlockSize() {, + return rand.nextInt(MIN_BLOCK_SIZE, MAX_BLOCK_SIZE + 1);, + }, +++ b/codec/src/test/java/io/netty/handler/codec/compression/Bzip2EncoderTest.java, + final EmbeddedChannel channel = new EmbeddedChannel(new Bzip2Encoder(randomBlockSize()));, + final EmbeddedChannel channel = new EmbeddedChannel(new Bzip2Encoder(randomBlockSize()));, +, + private static int randomBlockSize() {, + return rand.nextInt(MIN_BLOCK_SIZE, MAX_BLOCK_SIZE + 1);, + }]
[+++ b/buffer/src/main/java/io/netty/buffer/DefaultMessageBuf.java, +import java.util.Iterator;, + public void addFirst(T t) {, + ensureValid();, + super.addFirst(t);, + }, +, + @Override, + public void addLast(T t) {, + ensureValid();, + super.addLast(t);, + }, +, + @Override, + public T pollFirst() {, + ensureValid();, + return super.pollFirst();, + }, +, + @Override, + public T pollLast() {, + ensureValid();, + return super.pollLast();, + }, +, + @Override, + public T getFirst() {, + ensureValid();, + return super.getFirst();, + }, +, + @Override, + public T getLast() {, + ensureValid();, + return super.getLast();, + }, +, + @Override, + public T peekFirst() {,
[+++ b/transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpOutboundByteStreamHandler.java, + out.add(new SctpMessage(protocolIdentifier, streamIdentifier, unordered, msg.retain()));]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java, + public long definedLength() {, + return definedSize;, + }, +, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java, + public long definedLength() {, + return definedSize;, + }, +, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DefaultHttpDataFactory.java, + @Override, + public Attribute createAttribute(HttpRequest request, String name, long definedSize) {, + if (useDisk) {, + Attribute attribute = new DiskAttribute(name, definedSize, charset);, + attribute.setMaxSize(maxSize);, + List<HttpData> fileToDelete = getList(request);, + fileToDelete.add(attribute);, + return attribute;, + }, + if (checkSize) {, + Attribute attribute = new MixedAttribute(name, definedSize, minSize, charset);, + attribute.setMaxSize(maxSize);, + List<HttpData> fileToDelete = getList(request);, + fileToDelete.add(attribute);, + return attribute;, + }, + MemoryAttribute
[+++ b/src/docbook/module/appendix.xml, +<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.docbook.org/xml/4.5/docbookx.dtd">, +<appendix id="appendix">, +</appendix>, +++ b/src/docbook/module/appendix.xml, +<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.docbook.org/xml/4.5/docbookx.dtd">, +<appendix id="appendix">, +</appendix>, +++ b/src/docbook/module/architecture.xml, +<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.docbook.org/xml/4.5/docbookx.dtd">, +++ b/src/docbook/module/appendix.xml, +<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.docbook.org/xml/4.5/docbookx.dtd">, +<appendix id="appendix">, +</appendix>, +++ b/src/docbook/module/architecture.xml, +<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.docbook.org/xml/4.5/docbookx.dtd">, +++ b/src/docbook/module/codec.xml, +<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.docbook.org/xml/4.5/docbookx.dtd">, +++ b/src/docbook/module/appendix.xml, +<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.docbook.org/xml/4.5/docbookx.dtd">, +<appendix id="appendix">, +</appendix>, +++ b/src/docbook/module/architecture.xml, +<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.docbook.org/xml/4.5/docbookx.dtd">, +++ b/src/docbook/module/codec.xml, +<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook
[+++ b/transport/src/main/java/io/netty/channel/ChannelConfig.java, + ChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis);, + ChannelConfig setWriteSpinCount(int writeSpinCount);, + /**, + * Returns {@link ByteBufAllocator} which is used for the channel, + * to allocate buffers., + */, +, + /**, + * Set the {@link ByteBufAllocator} which is used for the channel, + * to allocate buffers., + */, + ChannelConfig setAllocator(ByteBufAllocator allocator);, +++ b/transport/src/main/java/io/netty/channel/ChannelConfig.java, + ChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis);, + ChannelConfig setWriteSpinCount(int writeSpinCount);, + /**, + * Returns {@link ByteBufAllocator} which is used for the channel, + * to allocate buffers., + */, +, + /**, + * Set the {@link ByteBufAllocator} which is used for
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import io.netty.util.AsciiString;, + if (seq instanceof AsciiString) {, + AsciiString asciiString = (AsciiString) seq;, + buf.writeBytes(asciiString.array(), asciiString.arrayOffset(), asciiString.length());, + } else if (buf instanceof AbstractByteBuf) {, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import io.netty.util.AsciiString;, + if (seq instanceof AsciiString) {, + AsciiString asciiString = (AsciiString) seq;, + buf.writeBytes(asciiString.array(), asciiString.arrayOffset(), asciiString.length());, + } else if (buf instanceof AbstractByteBuf) {, +++ b/buffer/src/test/java/io/netty/buffer/ByteBufUtilTest.java, +, +import io.netty.util.AsciiString;, +, + @Test, + public void testWriteUsAsciiString() {, + AsciiString usAscii = new AsciiString("NettyRocks");, + ByteBuf buf = ReferenceCountUtil.releaseLater(Unpooled.buffer(16));, + buf.writeBytes(usAscii.toString().getBytes(CharsetUtil.US_ASCII));, + ByteBuf buf2 = ReferenceCountUtil.releaseLater(Unpooled.buffer(16));, + ByteBufUtil.writeAscii(buf2, usAscii);, +, + Assert.assertEquals(buf, buf2);, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java, + CompositeByteBuf cbb = compositeBuffer(Integer.MAX_VALUE);, + byteBuf = wrappedBuffer(Integer.MAX_VALUE, byteBuffer);]
[+++ b/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoopGroup.java, + terminationFuture.trySuccess(null);, +++ b/transport/src/main/java/io/netty/channel/ThreadPerChannelEventLoopGroup.java, + terminationFuture.trySuccess(null);, +++ b/transport/src/test/java/io/netty/channel/ThreadPerChannelEventLoopGroupTest.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + *
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicLong;, +, + // We use 5 minutes which is the same as what OpenJDK is using in sun.net.dns.ResolverConfigurationImpl., + private static final long REFRESH_INTERVAL = TimeUnit.MINUTES.toNanos(5);, +, + new DnsServerAddressStreamProvider() {, + private volatile DnsServerAddressStreamProvider currentProvider = provider();, + private final AtomicLong lastRefresh = new AtomicLong(System.nanoTime());, +, + @Override, + public DnsServerAddressStream nameServerAddressStream(String hostname) {, + long last = lastRefresh.get();, + DnsServerAddressStreamProvider current = currentProvider;, + if (System.nanoTime() - last > REFRESH_INTERVAL) {, + // This is slightly racy which means it will be possible still use the old configuration for a small,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, + private static final int ST_CONTENT_ALWAYS_EMPTY = 3;, + state = isContentAlwaysEmpty(m) ? ST_CONTENT_ALWAYS_EMPTY :, + HttpUtil.isTransferEncodingChunked(m) ? ST_CONTENT_CHUNK : ST_CONTENT_NON_CHUNK;, + switch (state) {, + case ST_INIT:, + case ST_CONTENT_ALWAYS_EMPTY:, + out.add(EMPTY_BUFFER);, + if (msg instanceof LastHttpContent) {, + state = ST_INIT;, + return;, + case ST_CONTENT_NON_CHUNK:, + return;, + case ST_CONTENT_CHUNK:, + encodeChunkedContent(ctx, msg, contentLength(msg), out);, + return;, + default:, + boolean isContentAlwaysEmpty(@SuppressWarnings("unused") H msg) {, + return false;, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, + private static final int ST_CONTENT_ALWAYS_EMPTY = 3;, + state = isContentAlwaysEmpty(m) ? ST_CONTENT_ALWAYS_EMPTY :, + HttpUtil.isTransferEncodingChunked(m) ? ST_CONTENT_CHUNK : ST_CONTENT_NON_CHUNK;,
[+++ /dev/null, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/channel/socket/sctp/SctpChannelImpl.java, +class SctpChannelImpl extends AbstractChannel implements SctpChannel {, + final com.sun.nio.sctp.SctpChannel underlayingChannel;, + public SctpChannelImpl(Channel parent, ChannelFactory factory, ChannelPipeline pipeline, ChannelSink sink,, + com.sun.nio.sctp.SctpChannel underlayingChannel, SctpWorker worker) {, + this.underlayingChannel = underlayingChannel;, + config = new DefaultNioSctpChannelConfig(underlayingChannel);, + final Iterator<SocketAddress> iterator = underlayingChannel.getAllLocalAddresses().iterator();, + final Set<SocketAddress> allLocalAddresses = underlayingChannel.getAllLocalAddresses();, + final Iterator<SocketAddress> iterator = underlayingChannel.getRemoteAddresses().iterator();, + final Set<SocketAddress> allLocalAddresses = underlayingChannel.getRemoteAddresses();, + return underlayingChannel.association();, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/channel/socket/sctp/SctpChannelImpl.java, +class SctpChannelImpl extends AbstractChannel implements SctpChannel {, + final com.sun.nio.sctp.SctpChannel underlayingChannel;, + public SctpChannelImpl(Channel parent, ChannelFactory factory, ChannelPipeline pipeline, ChannelSink sink,, + com.sun.nio.sctp.SctpChannel underlayingChannel, SctpWorker worker)
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import io.netty.util.ReferenceCountUtil;, +import io.netty.util.ReferenceCounted;, +, + static void releaseIfNeeded(ReferenceCounted counted) {, + if (counted.refCnt() > 0) {, + ReferenceCountUtil.safeRelease(counted);, + }, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import io.netty.util.ReferenceCountUtil;, +import io.netty.util.ReferenceCounted;, +, + static void releaseIfNeeded(ReferenceCounted counted) {, + if (counted.refCnt() > 0) {, + ReferenceCountUtil.safeRelease(counted);, + }, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + OpenSsl.releaseIfNeeded(this);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import io.netty.util.ReferenceCountUtil;, +import io.netty.util.ReferenceCounted;, +, + static void releaseIfNeeded(ReferenceCounted counted) {, + if (counted.refCnt() > 0) {, + ReferenceCountUtil.safeRelease(counted);, + }, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + OpenSsl.releaseIfNeeded(this);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + OpenSsl.releaseIfNeeded(this);]
[+++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + ssc.bind(new InetSocketAddress(port)).awaitUninterruptibly().rethrowIfFailed();, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + ssc.bind(new InetSocketAddress(port)).awaitUninterruptibly().rethrowIfFailed();, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + return pipeline().bind(localAddress, newFuture());, + return pipeline().connect(remoteAddress, newFuture());, + return pipeline().connect(remoteAddress, localAddress, newFuture());, + return pipeline().disconnect(newFuture());, + return pipeline().close(newFuture());, + return pipeline().deregister(newFuture());, + return pipeline().flush(newFuture());, + return pipeline().write(message, newFuture());, + private final ChannelFuture voidFuture = new VoidChannelFuture(AbstractChannel.this);, +, + public ChannelFuture voidFuture() {, + return voidFuture;, + }, +, + @Override, + deregister(voidFuture());, + close(voidFuture());, + close(voidFuture());, + close(voidFuture());, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + ssc.bind(new InetSocketAddress(port)).awaitUninterruptibly().rethrowIfFailed();, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + return pipeline().bind(localAddress, newFuture());, + return pipeline().connect(remoteAddress, newFuture());, + return pipeline().connect(remoteAddress, localAddress, newFuture());, + return pipeline().disconnect(newFuture());, + return pipeline().close(newFuture());, + return
[+++ b/all/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/codec-http2/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.5.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + , + public ByteBuf getBufferFor(int index) throws IOException {, + if (index < 0 || index > capacity()) {, + throw new IndexOutOfBoundsException("Invalid index: " + index, + + " - Bytes needed: " + (index) + ", maximum is ", + + capacity());, + }, + , + List<ByteBuf> components = decompose(index, 1);, + switch (components.size()) {, + case 0:, + return Unpooled.EMPTY_BUFFER;, + case 1:, + return components.get(0);, + default:, + throw new IOException("Index " + index + " is part of " + components.size() + " buffers!");, + }, + }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java,
[+++ b/pom.xml, + <version>1.1.3</version>, + <version>1.0.3</version>, + <version>1.3.0</version>, + <version>1.9</version>]
[+++ b/pom.xml, + <scope>test</scope>, + </dependency>, +, + <!-- Test dependency for generating a compressed heap dump file -->, + <dependency>, + <groupId>org.tukaani</groupId>, + <artifactId>xz</artifactId>, + <version>1.5</version>, +++ b/pom.xml, + <scope>test</scope>, + </dependency>, +, + <!-- Test dependency for generating a compressed heap dump file -->, + <dependency>, + <groupId>org.tukaani</groupId>, + <artifactId>xz</artifactId>, + <version>1.5</version>, +++ b/testsuite/pom.xml, +, + <dependency>, + <groupId>org.tukaani</groupId>, + <artifactId>xz</artifactId>, + <scope>test</scope>, + </dependency>, +++ b/pom.xml, + <scope>test</scope>, + </dependency>, +, + <!-- Test dependency for generating a compressed heap dump file -->, + <dependency>, + <groupId>org.tukaani</groupId>, + <artifactId>xz</artifactId>, + <version>1.5</version>, +++ b/testsuite/pom.xml, +, + <dependency>,
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +, + static void throwException(Throwable cause) {, + // JVM has been observed to crash when passing a null argument. See https://github.com/netty/netty/issues/4131., + UNSAFE.throwException(checkNotNull(cause, "cause"));]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + public ByteBuf readerIndex(int readerIndex) {, + return this;, + public ByteBuf writerIndex(int writerIndex) {, + return this;, + public ByteBuf setIndex(int readerIndex, int writerIndex) {, + return this;, + public ByteBuf clear() {, + return this;, + public ByteBuf markReaderIndex() {, + return this;, + public ByteBuf resetReaderIndex() {, + return this;, + public ByteBuf markWriterIndex() {, + return this;, + public ByteBuf resetWriterIndex() {, + return this;, + public ByteBuf discardReadBytes() {, + return this;, + return this;, + public ByteBuf ensureWritableBytes(int minWritableBytes) {, + return this;, + return this;, + public ByteBuf getBytes(int index,
[+++ b/src/main/java/org/jboss/netty/handler/timeout/DefaultIdleStateEvent.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2009, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version., + *, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import java.util.List;, + ChannelHandlerContext ctx, HttpObject msg, List<Object> out) throws Exception {, + ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import java.util.List;, + ChannelHandlerContext ctx, HttpObject msg, List<Object> out) throws Exception {, + ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, +import java.util.List;, +, + protected void decode(ChannelHandlerContext ctx, HttpObject msg, List<Object> out) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import java.util.List;, + ChannelHandlerContext ctx, HttpObject msg, List<Object> out) throws Exception {, + ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, +import java.util.List;, +, + protected void decode(ChannelHandlerContext ctx,
[+++ b/handler/src/main/java/io/netty/handler/ssl/util/SelfSignedCertificate.java, + "See debug log for the root cause.", t2);, + // TODO: consider using Java 7 addSuppressed to append t]
[+++ b/transport/src/test/java/io/netty/channel/nio/NioEventLoopTest.java, +import java.util.concurrent.CountDownLatch;, + public void testRebuildSelector() {, +, + @Test, + public void testInterruptEventLoopThread() throws Exception {, + EventLoopGroup group = new NioEventLoopGroup(1);, + final NioEventLoop loop = (NioEventLoop) group.next();, + try {, + Selector selector = loop.unwrappedSelector();, + assertTrue(selector.isOpen());, +, + loop.submit(new Runnable() {, + @Override, + public void run() {, + // Interrupt the thread which should not end-up in a busy spin and, + // so the selector should not have been rebuild., + Thread.currentThread().interrupt();, + }, + }).syncUninterruptibly();, +, + assertTrue(selector.isOpen());, +, + final CountDownLatch latch = new CountDownLatch(2);, + loop.submit(new Runnable() {,
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + ByteBuf dst = allocBuffer(length);, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + ByteBuf dst = allocBuffer(length);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + @Test, + public void testAllocatorIsSameWhenCopy() {, + testAllocatorIsSameWhenCopy(false);, + }, +, + @Test, + public void testAllocatorIsSameWhenCopyUsingIndexAndLength() {, + testAllocatorIsSameWhenCopy(true);, + }, +, + private void testAllocatorIsSameWhenCopy(boolean withIndexAndLength) {, + ByteBuf buffer = newBuffer(8);, + buffer.writeZero(4);, + ByteBuf copy = withIndexAndLength ? buffer.copy(0, 4) : buffer.copy();, + assertEquals(buffer, copy);, + assertEquals(buffer.isDirect(), copy.isDirect());, + assertSame(buffer.alloc(), copy.alloc());, + buffer.release();, + copy.release();, + }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + ByteBuf dst = allocBuffer(length);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + @Test, + public void testAllocatorIsSameWhenCopy() {, + testAllocatorIsSameWhenCopy(false);, + }, +,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/MixedFileUpload.java, +, + ByteBuf data = fileUpload.getByteBuf();, + if (data != null && data.isReadable()) {, + diskFileUpload.addContent(data.retain(), false);, + // release old upload, + fileUpload.release();, +, + FileUpload memoryUpload = fileUpload;, + fileUpload = new DiskFileUpload(memoryUpload, + .getName(), memoryUpload.getFilename(), memoryUpload, + .getContentType(), memoryUpload, + .getContentTransferEncoding(), memoryUpload.getCharset(),, +, + // release old upload, + memoryUpload.release();, + FileUpload memoryUpload = fileUpload;, +, + fileUpload = new DiskFileUpload(memoryUpload, + .getName(), memoryUpload.getFilename(), memoryUpload, + .getContentType(), memoryUpload, + .getContentTransferEncoding(), memoryUpload.getCharset(),, +, + // release old upload, + memoryUpload.release();, + FileUpload memoryUpload = fileUpload;, +, +, + // release old upload, + memoryUpload.release();]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderNames.java, + * {@code "content-security-policy"}, + */, + public static final CharSequence CONTENT_SECURITY_POLICY = new AsciiString("content-security-policy");, + /**, + /**, + * {@code "x-frame-options"}, + */, + public static final CharSequence X_FRAME_OPTIONS = new AsciiString("x-frame-options");]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Epoll.java, + private static final Throwable UNAVAILABILITY_CAUSE;, + Throwable cause = null;, + } catch (Throwable t) {, + cause = t;, +, + if (cause != null) {, + UNAVAILABILITY_CAUSE = cause;, + } else {, + UNAVAILABILITY_CAUSE = null;, + }, + * <a href="http://netty.io/wiki/native-transports.html">{@code netty-transport-native-epoll}</a> is available., + return UNAVAILABILITY_CAUSE == null;, + }, +, + /**, + * Ensure that <a href="http://netty.io/wiki/native-transports.html">{@code netty-transport-native-epoll}</a> is, + * available., + *, + * @throws UnsatisfiedLinkError if unavailable, + */, + public static void ensureAvailability() {, + if (UNAVAILABILITY_CAUSE != null) {, + throw (Error) new UnsatisfiedLinkError(,
[+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompSubframeDecoder.java, +import java.util.List;, +import java.util.Locale;, +, + private final boolean validateHeaders;, + public StompSubframeDecoder(boolean validateHeaders) {, + this(DEFAULT_MAX_LINE_LENGTH, DEFAULT_CHUNK_SIZE, validateHeaders);, + }, +, + this(maxLineLength, maxChunkSize, false);, + }, +, + public StompSubframeDecoder(int maxLineLength, int maxChunkSize, boolean validateHeaders) {, + this.validateHeaders = validateHeaders;, + if (contentLength >= 0) {, + } else if (validateHeaders) {, + throw new IllegalArgumentException("a header value or name contains a prohibited character ':'" +, + ", " + line);, + contentLength = getContentLength(headers, 0);, + if (contentLength == 0) {, +++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/StompSubframeDecoder.java, +import java.util.List;, +import java.util.Locale;, +, + private final boolean validateHeaders;, +
[+++ b/pom.xml, + <echo message="// DO NOT MODIFY - WILL BE OVERWRITTEN DURING THE BUILD PROCESS${line.separator}package org.jboss.netty.util;${line.separator}/** Provides the version information of Netty. */${line.separator}public final class Version {${line.separator} /** The version identifier. */${line.separator} public static final String ID = &quot;${project.version}-r${buildNumber}&quot;;${line.separator} /** Prints out the version identifier to stdout. */${line.separator} public static void main(String[] args) { System.out.println(ID); }${line.separator} private Version() { super(); }${line.separator}}${line.separator}" file="${basedir}/src/main/java/org/jboss/netty/util/Version.java" />]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +, + cookies.add(c);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +, + cookies.add(c);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java, + if (getPath() == null) {, + if (that.getPath() != null) {, + } else if (that.getPath() == null) {, + return false;, + } else if (!getPath().equals(that.getPath())) {, + if (getDomain() == null) {, + if (that.getDomain() != null) {, + } else if (that.getDomain() == null) {, + return false;, + } else {, + return true;, + }, +, + if (getPath() == null) {, + if (c.getPath() != null) {, + } else if (c.getPath() == null) {, + return 1;, + }
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + public ByteBuffer nioBuffer() {, + return nioBuffer(readerIndex, readableBytes());, + ByteBuffer nioBuffer;, + if (hasNioBuffer()) {, + nioBuffer = nioBuffer(index, length);, + } else {, + nioBuffer = ByteBuffer.allocate(length);, + getBytes(index, nioBuffer);, + nioBuffer.flip();, + }, +, + return ChannelBuffers.decodeString(nioBuffer, charset);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + public ByteBuffer nioBuffer() {, + return nioBuffer(readerIndex, readableBytes());, + ByteBuffer nioBuffer;, + if (hasNioBuffer()) {, + nioBuffer = nioBuffer(index, length);, + } else {, + nioBuffer = ByteBuffer.allocate(length);, + getBytes(index, nioBuffer);, + nioBuffer.flip();, + }, +, + return ChannelBuffers.decodeString(nioBuffer, charset);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufferBackedChannelBuffer.java, + if (src == tmpBuf) {, + src = src.duplicate();, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + ByteBufAllocator allocator = ByteBufAllocator.DEFAULT;, + PemEncoded pem = PemPrivateKey.toPEM(allocator, true, key);, + try {, + return toBIO(allocator, pem.retain());, + } finally {, + pem.release();, + }, +, + if (certChain.length == 0) {, + throw new IllegalArgumentException("certChain can't be empty");, + }, +, + ByteBufAllocator allocator = ByteBufAllocator.DEFAULT;, + PemEncoded pem = PemX509Certificate.toPEM(allocator, true, certChain);, + return toBIO(allocator, pem.retain());, + pem.release();, + }, +, + private static long toBIO(ByteBufAllocator allocator, PemEncoded pem) throws Exception {, + try {, + // We can turn direct buffers straight into BIOs. No need to, + // make a yet
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import javax.net.ssl.SNIHostName;, + // Mark as volatile as accessed by checkSniHostnameMatch(...), + private volatile Collection<SNIMatcher> matchers;, +, +, + sslParameters.setSNIMatchers(matchers);, + matchers = sslParameters.getSNIMatchers();, + final boolean checkSniHostnameMatch(String hostname) {, + Collection<SNIMatcher> matchers = this.matchers;, + if (matchers != null && !matchers.isEmpty()) {, + SNIHostName name = new SNIHostName(hostname);, + for (SNIMatcher matcher: matchers) {, + // type 0 is for hostname, + if (matcher.getType() == 0 && matcher.matches(name)) {, + return true;, + }, + }, + return false;, + } else {, + return true;, + }, + }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import javax.net.ssl.SNIHostName;, +
[+++ b/.gitignore, +/*.geany, +++ b/.gitignore, +/*.geany, +++ b/pom.xml, + <version>2.4.1</version>, + <version>1.6.4</version>, + <version>4.10</version>, + <version>3.1</version>, + <version>3.1</version>, + <version>1.6.4</version>, + <pluginManagement>, + <plugins>, + <!--This plugin's configuration is used to store Eclipse m2e settings only. , + It has no influence on the Maven build itself. -->, + <plugin>, + <groupId>org.eclipse.m2e</groupId>, + <artifactId>lifecycle-mapping</artifactId>, + <version>1.0.0</version>, + <configuration>, + <lifecycleMappingMetadata>, + <pluginExecutions>, + <pluginExecution>, + <pluginExecutionFilter>, + <groupId>org.apache.maven.plugins</groupId>, + <artifactId>maven-antrun-plugin</artifactId>, + <versionRange>[1.7,)</versionRange>, + <goals>, + <goal>run</goal>, + </goals>, + </pluginExecutionFilter>, + <action>, + <ignore />, + </action>, + </pluginExecution>, + </pluginExecutions>, + </lifecycleMappingMetadata>, + </configuration>, + </plugin>, + </plugins>,
[+++ b/microbench/pom.xml, + <version>1.7.1</version>, + <version>1.7.1</version>, +++ b/microbench/pom.xml, + <version>1.7.1</version>, + <version>1.7.1</version>, +++ b/microbench/src/test/java/io/netty/microbench/http2/Http2FrameWriterBenchmark.java, +import org.openjdk.jmh.annotations.TearDown;, + EMBEDDED_POOLED(NIO_POOLED_PARAMS), EMBEDDED_UNPOOLED(NIO_UNPOOLED_PARAMS),, + NIO_POOLED(NIO_POOLED_PARAMS), NIO_UNPOOLED(NIO_UNPOOLED_PARAMS),, + EPOLL_POOLED(EPOLL_POOLED_PARAMS), EPOLL_UNPOOLED(EPOLL_UNPOOLED_PARAMS),, + OIO_POOLED(OIO_POOLED_PARAMS), OIO_UNPOOLED(OIO_UNPOOLED_PARAMS);, +, + private final EnvironmentParameters params;, +, + private EnvironmentType(EnvironmentParameters params) {, + this.params = params;, + }, +, + public EnvironmentParameters params() {, + return params;, + }, + switch (environmentType) {, + case EMBEDDED_POOLED:, + case EMBEDDED_UNPOOLED:, + environment = boostrapEmbeddedEnv(environmentType);, + break;, + default:, + environment = boostrapEnvWithTransport(environmentType);, + break;, + }, + payload = createPayload(dataType);, + }, +, + @TearDown(Level.Trial), + public void teardown() throws Exception {,
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import java.nio.channels.FileChannel;, + public int readBytes(FileChannel out, long position, int length), + throws IOException {, + checkReadableBytes(length);, + int readBytes = getBytes(readerIndex, out, position, length);, + readerIndex += readBytes;, + return readBytes;, + }, +, + @Override, + public int writeBytes(FileChannel in, long position, int length) throws IOException {, + ensureAccessible();, + ensureWritable(length);, + int writtenBytes = setBytes(writerIndex, in, position, length);, + if (writtenBytes > 0) {, + writerIndex += writtenBytes;, + }, + return writtenBytes;, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, +import java.nio.channels.FileChannel;, + public int readBytes(FileChannel out, long position, int length), + throws IOException
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/example/pom.xml, + <artifactId>netty-transport-sctp</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/example/pom.xml, + <artifactId>netty-transport-sctp</artifactId>, + <version>${project.version}</version>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/example/src/main/java/io/netty/example/sctp/NioSctpEchoClient.java, +import io.netty.channel.socket.sctp.SctpChannel;, +import io.netty.channel.socket.sctp.nio.NioSctpChannel;, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/example/pom.xml, + <artifactId>netty-transport-sctp</artifactId>, + <version>${project.version}</version>, + </dependency>, +
[+++ b/.gitignore, +, +# JVM crash logs, +hs_err_pid*.log, +]
[+++ b/pom.xml, + <repositories>, + <repository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </repository>, + </repositories>, +, + <pluginRepositories>, + <pluginRepository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </pluginRepository>, + </pluginRepositories>, +, + <version>2.3.0</version>, + <version>1.6.1</version>, + <version>4.8.2</version>, + <version>2.5.2</version>, + <version>2.5.2</version>, + <version>1.6.1</version>, + <version>1.0</version>, + <version>2.4.3</version>, + <version>2.7.2</version>, + <version>1.6</version>, + <version>2.7</version>, + <version>2.2</version>, + <version>2.1</version>, + <plugin>, + <groupId>org.codehaus.mojo</groupId>, + <artifactId>exec-maven-plugin</artifactId>, + <version>1.2.1</version>, + </plugin>, +++ b/pom.xml, + <repositories>, + <repository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </repository>, + </repositories>, +, + <pluginRepositories>, + <pluginRepository>, + <id>JBoss-Public</id>, + <url>http://repository.jboss.org/nexus/content/groups/public-jboss/</url>, + </pluginRepository>, + </pluginRepositories>, +, + <version>2.3.0</version>, + <version>1.6.1</version>, + <version>4.8.2</version>, +
[+++ b/codec/src/main/java/io/netty/handler/codec/LengthFieldBasedFrameDecoder.java, + if (!failFast || firstDetectionOfTooLongFrame) {]
[+++ b/all/pom.xml, + <includeGroupIds>${project.groupId}</includeGroupIds>, +++ b/all/pom.xml, + <includeGroupIds>${project.groupId}</includeGroupIds>, +++ b/pom.xml, +++ b/all/pom.xml, + <includeGroupIds>${project.groupId}</includeGroupIds>, +++ b/pom.xml, +++ b/tarball/assembly.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<assembly, + xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2", + xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance", + xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2 http://maven.apache.org/xsd/assembly-1.1.2.xsd">, + <id>tarball</id>, + <formats>, + <format>tar.bz2</format>, + </formats>, + <includeBaseDirectory>false</includeBaseDirectory>, + <fileSets>, + <fileSet>, + <directory>${project.basedir}/..</directory>, + <outputDirectory/>, + <includes>, + <include>*.txt</include>, + <include>*.md</include>, + </includes>, + </fileSet>, + <fileSet>, + <directory>${project.basedir}/..</directory>, + <outputDirectory/>, + <includes>, + <include>license/**/*.txt</include>, + <include>license/**/*.md</include>, + </includes>, + </fileSet>, + <fileSet>, + <directory>target/jars</directory>, + <outputDirectory>jar</outputDirectory>, + <includes>, + <include>**/*.jar</include>, + </includes>, + </fileSet>, + <fileSet>, + <directory>target/jars-all</directory>, + <outputDirectory>jar/all-in-one</outputDirectory>, + <includes>, + <include>**/*.jar</include>, + </includes>,
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + private boolean decodeWasNull;, + decodeWasNull = size == 0;, + if (decodeWasNull) {, + decodeWasNull = false;, + if (!ctx.channel().config().isAutoRead()) {, + ctx.read();, + }, + }, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + private boolean decodeWasNull;, + decodeWasNull = size == 0;, + if (decodeWasNull) {, + decodeWasNull = false;, + if (!ctx.channel().config().isAutoRead()) {, + ctx.read();, + }, + }, +++ b/codec/src/test/java/io/netty/handler/codec/ByteToMessageDecoderTest.java, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + private boolean decodeWasNull;, + decodeWasNull = size == 0;, + if (decodeWasNull) {, + decodeWasNull = false;, + if (!ctx.channel().config().isAutoRead()) {, + ctx.read();, + }, + }, +++ b/codec/src/test/java/io/netty/handler/codec/ByteToMessageDecoderTest.java, +++ b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +
[+++ b/all/pom.xml, +++ b/all/pom.xml, +++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E> {, +, + public ObjectArray(E[] array, int offset, int length) {, + super(array, offset, length);, + }, +, + @Override, + public E[] array() {, + return (E[]) super.array();, + }, +}, +++ b/all/pom.xml, +++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E> {, +, + public ObjectArray(E[] array, int offset, int length) {, + super(array, offset, length);, + }, +, + @Override, + public E[] array() {, + return (E[]) super.array();, + }, +}, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + throw new IndexOutOfBoundsException();, +
[+++ b/.gitignore, +/*.iml, +/*.ipr, +/*.iws]
[+++ b/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServerHandler.java, + private static final byte[] CONTENT = { 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd' };, + FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, OK, Unpooled.wrappedBuffer(CONTENT));]
[+++ b/buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java, + AllocationThread(ByteBufAllocator allocator) {, +++ b/buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java, + AllocationThread(ByteBufAllocator allocator) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CombinedHttpHeaders.java, + CombinedHttpHeadersImpl(HashingStrategy<CharSequence> nameHashingStrategy,, +++ b/buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java, + AllocationThread(ByteBufAllocator allocator) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CombinedHttpHeaders.java, + CombinedHttpHeadersImpl(HashingStrategy<CharSequence> nameHashingStrategy,, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java, +, + HttpServerRequestDecoder(int maxInitialLineLength, int maxHeaderSize, int maxChunkSize) {, + HttpServerRequestDecoder(int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,, + HttpServerRequestDecoder(int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,, +, +++ b/buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java, + AllocationThread(ByteBufAllocator allocator) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CombinedHttpHeaders.java, + CombinedHttpHeadersImpl(HashingStrategy<CharSequence> nameHashingStrategy,, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java, +, + HttpServerRequestDecoder(int maxInitialLineLength, int maxHeaderSize, int maxChunkSize) {, + HttpServerRequestDecoder(int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,, + HttpServerRequestDecoder(int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java, + public long getMaxSize() {, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, + SSLContext.setOptions(ctx, SSLContext.getOptions(ctx) |, + SSL.SSL_OP_NO_SSLv2 |, + SSL.SSL_OP_NO_SSLv3 |, + SSL.SSL_OP_CIPHER_SERVER_PREFERENCE |, + SSL.SSL_OP_NO_COMPRESSION |, + SSL.SSL_OP_NO_TICKET);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, + SSLContext.setOptions(ctx, SSLContext.getOptions(ctx) |, + SSL.SSL_OP_NO_SSLv2 |, + SSL.SSL_OP_NO_SSLv3 |, + SSL.SSL_OP_CIPHER_SERVER_PREFERENCE |, + SSL.SSL_OP_NO_COMPRESSION |, + SSL.SSL_OP_NO_TICKET);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, + if (sslError == SSL.SSL_ERROR_ZERO_RETURN) {, + } else if (sslError == SSL.SSL_ERROR_WANT_READ) {, + } else if (sslError == SSL.SSL_ERROR_WANT_WRITE) {, + } else {, + if (sslError == SSL.SSL_ERROR_WANT_READ || sslError == SSL.SSL_ERROR_WANT_WRITE) {, + } else if (sslError == SSL.SSL_ERROR_ZERO_RETURN) {, + } else {, + if (sslErr
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + private boolean headersSent;, + public Http2Stream headersSent() {, + headersSent = true;, + return this;, + }, +, + @Override, + public boolean isHeadersSent() {, + return headersSent;, + }, +, + @Override, +, + @Override, + public Http2Stream headersSent() {, + throw new UnsupportedOperationException();, + }, +, + @Override, + public boolean isHeadersSent() {, + throw new UnsupportedOperationException();, + }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + private boolean headersSent;, + public Http2Stream headersSent() {, + headersSent = true;, + return this;, + }, +, + @Override, + public boolean isHeadersSent() {, + return headersSent;, + }, +, +
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressDecoder.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspRequestEncoder.java, +import static io.netty.handler.codec.http.HttpConstants.*;, +, + private static final byte[] CRLF = { CR, LF };, + encodeAscii(request.getMethod().toString(), buf);, + buf.writeByte(SP);, + buf.writeByte(SP);, + encodeAscii(request.getProtocolVersion().toString(), buf);, + buf.writeBytes(CRLF);, +++ b/codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspRequestEncoder.java, +import static io.netty.handler.codec.http.HttpConstants.*;, +, + private static final byte[] CRLF = { CR, LF };, + encodeAscii(request.getMethod().toString(), buf);, + buf.writeByte(SP);, + buf.writeByte(SP);, + encodeAscii(request.getProtocolVersion().toString(), buf);, + buf.writeBytes(CRLF);, +++ b/codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspResponseEncoder.java, +import static io.netty.handler.codec.http.HttpConstants.*;, +, + private static final byte[] CRLF = { CR, LF };, + encodeAscii(response.getProtocolVersion().toString(), buf);, + buf.writeByte(SP);, + buf.writeByte(SP);, + encodeAscii(String.valueOf(response.getStatus().reasonPhrase()), buf);, + buf.writeBytes(CRLF);]
[+++ b/pom.xml, + <version>0.7.1.201405082137</version>]
[+++ b/transport/src/main/java/io/netty/channel/ChannelDuplexHandler.java, + * Calls {@link ChannelHandlerContext#deregister(ChannelPromise)} to forward]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, + private final int windowBits;, + private final int memLevel;, + * Creates a new handler with the default compression level (<tt>6</tt>),, + * default window size (<tt>15</tt>) and default memory level (<tt>8</tt>)., + * Creates a new handler with the specified compression level, default, + * window size (<tt>15</tt>) and default memory level (<tt>8</tt>)., + this(compressionLevel, 15, 8);, + }, +, + /**, + * Creates a new handler with the specified compression level, window size,, + * and memory level.., + *, + * @param compressionLevel, + * {@code 1} yields the fastest compression and
[+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheDecoder.java, +import io.netty.buffer.Unpooled;, +import io.netty.handler.codec.DecoderResult;, +import io.netty.handler.codec.memcache.MemcacheMessage;, + case READ_HEADER: try {, + } catch (Exception e) {, + out.add(invalidMessage(e));, + return;, + }, + case READ_EXTRAS: try {, + } catch (Exception e) {, + out.add(invalidMessage(e));, + return;, + }, + case READ_KEY: try {, + state = State.READ_CONTENT;, + } catch (Exception e) {, + out.add(invalidMessage(e));, + return;, + }, + case READ_CONTENT: try {, + } catch (Exception e) {, + out.add(invalidChunk(e));, + return;, + }, + case BAD_MESSAGE:, + in.skipBytes(actualReadableBytes());, + return;, + * Helper method to create a message indicating a invalid decoding
[+++ b/src/main/java/org/jboss/netty/channel/DefaultChannelConfig.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2008, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version., + *, +
[+++ b/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java, + switch (addrFamily) {, + case AF_UNSPEC:, + if (address != null) {, + return;, + case AF_UNIX:, + if (address == null) {, + throw new NullPointerException("address");, + switch (addrFamily) {, + case AF_IPv4:, + if (!NetUtil.isValidIpV4Address(address)) {, + throw new HAProxyProtocolException("invalid IPv4 address: " + address);, + }, + break;, + case AF_IPv6:, + if (!NetUtil.isValidIpV6Address(address)) {, + throw new HAProxyProtocolException("invalid IPv6 address: " + address);, + }, + break;, + default:, + throw new Error();]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + // Use Sec-WebSocket-Origin, + // See https://github.com/netty/netty/issues/264, + request.addHeader(Names.SEC_WEBSOCKET_ORIGIN, originValue);]
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeChannelBufferTest.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeChannelBufferTest.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + * An interface defining an, + * <a href="http://en.wikipedia.org/wiki/HTTP_cookie">HTTP cookie</a>., + * Returns the name of this {@link Cookie}., + *, + * @return The name of this {@link Cookie}, + * Returns the value of this {@link Cookie}., + *, + * @return The value of this {@link Cookie}, + * Sets the value of this {@link Cookie}., + *, + * @param value The value to set, + * Returns the domain of this {@link Cookie}., + *, + * @return The domain of
[+++ b/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServerHandler.java, +import io.netty.channel.SimpleChannelInboundHandler;, +import io.netty.handler.codec.http.HttpObject;, +, +public class HttpHelloWorldServerHandler extends SimpleChannelInboundHandler<HttpObject> {, + public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {]
[+++ b/transport-native-epoll/src/main/c/netty_epoll_linuxsocket.c, +// TCP_FASTOPEN_CONNECT is defined in linux 4.11. We define this here so older kernels can compile., +#ifndef TCP_FASTOPEN_CONNECT, +#define TCP_FASTOPEN_CONNECT 30, +#endif, +, +static void netty_epoll_linuxsocket_setTcpFastOpenConnect(JNIEnv* env, jclass clazz, jint fd, jint optval) {, + netty_unix_socket_setOption(env, fd, IPPROTO_TCP, TCP_FASTOPEN_CONNECT, &optval, sizeof(optval));, +}, +, +static jint netty_epoll_linuxsocket_isTcpFastOpenConnect(JNIEnv* env, jclass clazz, jint fd) {, + int optval;, + if (netty_unix_socket_getOption(env, fd, IPPROTO_TCP, TCP_FASTOPEN_CONNECT, &optval, sizeof(optval)) == -1) {, + return -1;, + }, + return optval;, +}, +, + { "setTcpFastOpenConnect", "(II)V", (void *) netty_epoll_linuxsocket_setTcpFastOpenConnect },, + { "isTcpFastOpenConnect", "(I)I", (void *) netty_epoll_linuxsocket_isTcpFastOpenConnect },, +++ b/transport-native-epoll/src/main/c/netty_epoll_linuxsocket.c, +// TCP_FASTOPEN_CONNECT is
[+++ b/all/pom.xml, + <version>4.0.14.Final</version>, +++ b/all/pom.xml, + <version>4.0.14.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final</version>, +++ b/all/pom.xml, + <version>4.0.14.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final</version>, +++ b/all/pom.xml, + <version>4.0.14.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Final</version>, +++ b/all/pom.xml, + <version>4.0.14.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec/pom.xml, + <version>4.0.14.Final</version>, +++ b/all/pom.xml, + <version>4.0.14.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec/pom.xml, + <version>4.0.14.Final</version>, +++ b/common/pom.xml, + <version>4.0.14.Final</version>, +++ b/all/pom.xml, + <version>4.0.14.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-socks/pom.xml, +
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + static final int DEFAULT_MAX_COMPONENTS = 16;, + protected static CompositeByteBuf toLeakAwareBuffer(CompositeByteBuf buf) {, + ResourceLeak leak;, + switch (ResourceLeakDetector.getLevel()) {, + case SIMPLE:, + leak = AbstractByteBuf.leakDetector.open(buf);, + if (leak != null) {, + buf = new SimpleLeakAwareCompositeByteBuf(buf, leak);, + }, + break;, + case ADVANCED:, + case PARANOID:, + leak = AbstractByteBuf.leakDetector.open(buf);, + if (leak != null) {, + buf = new AdvancedLeakAwareCompositeByteBuf(buf, leak);, + }, + break;, + default:, + break;, + }, + return buf;, + }, +, + return toLeakAwareBuffer(new CompositeByteBuf(this, false, maxNumComponents));, + return toLeakAwareBuffer(new CompositeByteBuf(this, true, maxNumComponents));, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, +
[+++ b/transport/src/main/java/io/netty/channel/CoalescingBufferQueue.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the, + * "License"); you may not use this file except in compliance with the License. You may obtain a, + * copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express, + *
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + this(4096, 8192, 8192);, + return super.encode(ctx, channel, msg);, + return super.decode(ctx, channel, buffer, state);, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + this(4096, 8192, 8192);, + return super.encode(ctx, channel, msg);, + return super.decode(ctx, channel, buffer, state);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, + private final int maxFrameSize;, + public WebSocket00FrameDecoder(int maxFrameSize) {, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieEncoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, + this(4096, 8192, 8192);, + return super.encode(ctx, channel, msg);, + return super.decode(ctx, channel, buffer, state);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, + private final int
[+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java, + public DecoderResult decoderResult() {, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java, + public DecoderResult decoderResult() {, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java, + "(data: " + content() + ", decoderResult: " + decoderResult() + ')';, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java, + public DecoderResult decoderResult() {, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java, + "(data: " + content() + ", decoderResult: " + decoderResult() + ')';, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java, + public DecoderResult decoderResult() {, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java, + public DecoderResult decoderResult() {, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/DefaultMemcacheContent.java, + "(data: " + content() + ", decoderResult: " + decoderResult() + ')';, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/LastMemcacheContent.java, + public DecoderResult decoderResult() {, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/MemcacheObject.java, +import io.netty.handler.codec.DecoderResultProvider;, +public interface MemcacheObject extends DecoderResultProvider { }, +++
[+++ b/codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java, + private static final int ST_CORRUPTED = -1;, + private static final int ST_INIT = 0;, + private static final int ST_DECODING_NORMAL = 1;, + private static final int ST_DECODING_ARRAY_STREAM = 2;, +, + private int state;, + if (state == ST_CORRUPTED) {, + in.skipBytes(in.readableBytes());, + return;, + }, +, + if (state == ST_DECODING_NORMAL) {, + } else if (state == ST_DECODING_ARRAY_STREAM) {, + if (state == ST_DECODING_ARRAY_STREAM) {, + state = ST_CORRUPTED;, + throw new CorruptedFrameException(, + "invalid JSON received at byte position " + idx + ": " + ByteBufUtil.hexDump(in));, + if (openingBrace ==
[+++ b/pom.xml, + <tcnative.version>2.0.3.Final</tcnative.version>]
[+++ b/codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java, + } else {, + int backslashCount = 0;, + idx--;, + while (idx >= 0) {, + if (in.getByte(idx) == '\\') {, + backslashCount++;, + idx--;, + } else {, + break;, + }, + }, + // The double quote isn't escaped only if there are even "\"s., + if (backslashCount % 2 == 0) {, + // Since the double quote isn't escaped then this is the end of a string., + }, +++ b/codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java, + } else {, + int backslashCount = 0;, + idx--;, + while (idx >= 0) {, + if
[+++ b/pom.xml, + <tcnative.version>2.0.0.Beta6</tcnative.version>]
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketConditionalWritabilityTest.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/pom.xml, + <version>3.2.1.Final</version>, + <url>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.2.1.Final</url>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.2.1.Final</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.2.1.Final</developerConnection>]
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + private static final byte STATE_INIT = 0;, + private static final byte STATE_CALLING_CHILD_DECODE = 1;, + private static final byte STATE_HANDLER_REMOVED_PENDING = 2;, +, + /**, + * A bitmask where the bits are defined as, + * <ul>, + * <li>{@link #STATE_INIT}</li>, + * <li>{@link #STATE_CALLING_CHILD_DECODE}</li>, + * <li>{@link #STATE_HANDLER_REMOVED_PENDING}</li>, + * </ul>, + */, + private byte decodeState = STATE_INIT;, + if (decodeState == STATE_CALLING_CHILD_DECODE) {, + decodeState = STATE_HANDLER_REMOVED_PENDING;, + return;, + }, + decodeRemovalReentryProtection(ctx, in, out);, + * Decode the from one {@link ByteBuf} to an other. This method will be called
[+++ b/pom.xml]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java, + uri.startsWith(".") || uri.endsWith(".") ||, + uri.matches(".*[<>&\"].*")) {, + String dirPath = dir.getPath();, + buf.append(dirPath);, + buf.append(dirPath);, + if (!name.matches("[A-Za-z0-9][-_A-Za-z0-9\\.]*")) {, + continue;, + }, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java, + uri.startsWith(".") || uri.endsWith(".")
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + private static final boolean IS_BORINGSSL;, + IS_BORINGSSL = "BoringSSL".equals(versionString());, +, + !tlsv13Supported && isTLSv13Cipher(c)) {, + if (IS_BORINGSSL) {, + // Currently BoringSSL does not include these when calling SSL.getCiphers() even when these, + // are supported., + Collections.addAll(availableOpenSslCipherSuites,, + "TLS_AES_128_GCM_SHA256",, + "TLS_AES_256_GCM_SHA384" ,, + "TLS_CHACHA20_POLY1305_SHA256");, + }, + if (!isTLSv13Cipher(cipher)) {, + IS_BORINGSSL = false;, +, + static boolean isBoringSSL() {, + return IS_BORINGSSL;, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + private static final boolean IS_BORINGSSL;, + IS_BORINGSSL = "BoringSSL".equals(versionString());, +, + !tlsv13Supported && isTLSv13Cipher(c)) {, + if (IS_BORINGSSL) {, + // Currently BoringSSL does not include
[+++ b/src/main/resources/org/jboss/netty/container/spring/beans.xml, + name="org.jboss.netty.channel.socket.nio.NioDatagramChannelFactory", + class="org.jboss.netty.channel.socket.nio.NioDatagramChannelFactory">, + <constructor-arg ref="org.jboss.netty.internal.ChannelFactoryExecutor"/>, + </bean>, + , + <bean lazy-init="true" scope="singleton"]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, +, + if (uri.length() == 0) {, + uri += SLASH;, + } else {, + if (start != -1 && uri.charAt(0) != SLASH) {, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, +, + if (uri.length() == 0) {, + uri += SLASH;, + } else {, + if (start != -1 && uri.charAt(0) != SLASH) {, + }, +, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpRequestEncoderTest.java, +, + @Test, + public void testAbsPath() throws Exception {, + HttpRequestEncoder encoder = new HttpRequestEncoder();, + ByteBuf buffer = Unpooled.buffer(64);, + encoder.encodeInitialLine(buffer, new DefaultHttpRequest(HttpVersion.HTTP_1_1,, + HttpMethod.GET, "/"));, + String req = buffer.toString(Charset.forName("US-ASCII"));, + assertEquals("GET / HTTP/1.1\r\n",
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + * Will schedule a {@link #epollInReady()} call on the event loop if necessary., + * @param edgeTriggered {@code true} if the channel is using ET mode. {@code false} otherwise., + */, + final void checkResetEpollIn(boolean edgeTriggered) {, + if (edgeTriggered && !isInputShutdown0()) {, + // trigger a read again as there may be something left to read and because of epoll ET we, + // will not get notified again until we read everything from the socket, + eventLoop().execute(new OneTimeTask() {, + @Override, + public void run() {, + epollInReady();, + }, + });, + },
[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, +/**, + * Abstract base class for {@link EventExecutor} implementations that use a {@link TaskScheduler} to support, + * scheduling tasks., + */, +public abstract class AbstractEventExecutor extends AbstractEventExecutorWithoutScheduler {, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, +/**, + * Abstract base class for {@link EventExecutor} implementations that use a {@link TaskScheduler} to support, + * scheduling tasks., + */, +public abstract class AbstractEventExecutor extends AbstractEventExecutorWithoutScheduler {, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutorWithoutScheduler.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not
[+++ b/pom.xml, + <version>0.11.0</version>, +++ b/pom.xml, + <version>0.11.0</version>, +++ b/testsuite-osgi/src/test/java/io/netty/osgitests/OsgiBundleTest.java, + options.add(mavenBundle("com.twitter", "hpack").versionAsInProject());]
[+++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java, +import java.util.Collection;, +import java.util.concurrent.Callable;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.TimeoutException;, + @Override, + public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {, + throwIfInEventLoop("invokeAny");, + return super.invokeAny(tasks);, + }, +, + @Override, + public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit), + throws InterruptedException, ExecutionException, TimeoutException {, + throwIfInEventLoop("invokeAny");, + return super.invokeAny(tasks, timeout, unit);, + }, +, + @Override, + public <T> List<java.util.concurrent.Future<T>> invokeAll(Collection<? extends Callable<T>> tasks), + throws InterruptedException {, + throwIfInEventLoop("invokeAll");, + return super.invokeAll(tasks);, + }, +, + @Override, + public <T> List<java.util.concurrent.Future<T>> invokeAll(, + Collection<? extends Callable<T>> tasks, long timeout, TimeUnit
[+++ b/transport/src/main/java/io/netty/channel/VoidChannelPromise.java, + fireException(cause);, + fireException(cause);, + fireException(new CancellationException());, +, + private void fireException(Throwable cause) {, + // Only fire the exception if the channel is open and registered, + // if not the pipeline is not setup and so it would hit the tail, + // of the pipeline., + // See https://github.com/netty/netty/issues/1517, + if (fireException && channel.isRegistered()) {, + channel.pipeline().fireExceptionCaught(cause);, + }, + }]
[+++ b/all/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.12.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, + * @deprecated Use {@link #writeAndFlush(Object)} instead., + */, + @Deprecated, + ChannelGroupFuture flushAndWrite(Object message);, +, + /**, + * @deprecated Use {@link #writeAndFlush(Object, ChannelMatcher)} instead., + */, + @Deprecated, + ChannelGroupFuture flushAndWrite(Object message, ChannelMatcher matcher);, +, + /**, + * @deprecated This method will be removed in the next major feature release., + *, + * @deprecated This method will be removed in the next major feature release., + *, +++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, + * @deprecated Use {@link #writeAndFlush(Object)} instead., + */, + @Deprecated, + ChannelGroupFuture flushAndWrite(Object message);, +, + /**, + * @deprecated Use {@link #writeAndFlush(Object,
[+++ b/handler/src/main/java/io/netty/handler/flush/FlushConsolidationHandler.java, + resetReadAndFlushIfNeeded(ctx);, + resetReadAndFlushIfNeeded(ctx);, + resetReadAndFlushIfNeeded(ctx);, + resetReadAndFlushIfNeeded(ctx);, + flushIfNeeded(ctx);, + flushIfNeeded(ctx);, + private void resetReadAndFlushIfNeeded(ChannelHandlerContext ctx) {, + flushIfNeeded(ctx);, +, + private void flushIfNeeded(ChannelHandlerContext ctx) {]
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, +import java.net.Inet4Address;, +import java.net.Inet6Address;, + * The {@link Inet4Address} that represents the IPv4 loopback address '127.0.0.1', + */, + public static final Inet4Address LOCALHOST4;, +, + /**, + * The {@link Inet6Address} that represents the IPv6 loopback address '::1', + */, + public static final Inet6Address LOCALHOST6;, +, + /**, + * The {@link InetAddress} that represents the loopback address. If IPv6 stack is available, it will refer to, + * {@link #LOCALHOST6}. Otherwise, {@link #LOCALHOST4}., + // Create IPv4 loopback address., + Inet4Address localhost4 = null;, + localhost4 = (Inet4Address) InetAddress.getByAddress(new byte[]{127, 0, 0, 1});, +
[+++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Final-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + protected void doPreClose() throws Exception {, + // NOOP by default, + }, +, + private final class CloseFuture extends DefaultChannelFuture implements ChannelFuture.Unsafe {, + try {, + doPreClose();, + } catch (Exception e) {, + logger.warn("doPreClose() raised an exception.", e);, + }, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + protected void doPreClose() throws Exception {, + // NOOP by default, + }, +, + private final class CloseFuture extends DefaultChannelFuture implements ChannelFuture.Unsafe {, + try {, + doPreClose();, + } catch (Exception e) {, + logger.warn("doPreClose() raised an exception.", e);, + }, +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, +import io.netty.channel.ChannelBufferType;, + protected void
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockCompressor.java, +import io.netty.util.internal.DetectionUtil;, + if (DetectionUtil.javaVersion() >= 7) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockCompressor.java, +import io.netty.util.internal.DetectionUtil;, + if (DetectionUtil.javaVersion() >= 7) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockJZlibDecompressor.java, + loop: for (;;) {, + // Decompress 'in' into 'out', + if (z.next_out_index > 0) {, + decompressed.writeBytes(out, 0, z.next_out_index);, + z.avail_out = out.length;, + }, + z.next_out_index = 0;, + switch (resultCode) {, + case JZlib.Z_NEED_DICT:, + throw new CompressionException("failed to set the dictionary: " + resultCode);, + break;, + case JZlib.Z_STREAM_END:, + // Do not decode anymore., + z.inflateEnd();, + break loop;, + case JZlib.Z_OK:, + break;, + case JZlib.Z_BUF_ERROR:, + if (z.avail_in <=
[+++ b/all/pom.xml, + <version>4.1.34.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.34.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.34.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.34.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.34.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, + <version>4.1.34.Final-SNAPSHOT</version>, +
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + @Deprecated, + @Deprecated, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + @Deprecated, + @Deprecated, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufProcessor.java, +@Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + @Deprecated, + @Deprecated, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufProcessor.java, +@Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, +++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, +@Deprecated, +++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + @Deprecated, + @Deprecated, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufProcessor.java, +@Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, + @Deprecated, +++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, +@Deprecated,
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + default:, + break;, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + default:, + break;, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + default:, + break;, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + default:, + break;, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + default:, + break;, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +++ /dev/null, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +import io.netty.channel.RecvByteBufAllocator;, + private static final ChannelMetadata METADATA = new ChannelMetadata(false);, + return METADATA;, + unsafe().recvBufAllocHandle().attemptedBytesRead(byteBuf.writableBytes());, + private EpollRecvByteAllocatorHandle allocHandle;, + public EpollRecvByteAllocatorHandle recvBufAllocHandle() {, + if (allocHandle == null) {, + allocHandle = newEpollHandle(super.recvBufAllocHandle());, + }, + return allocHandle;, + }, +, + /**, + * Create a
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java, + private Http2Settings initialSettings = Http2Settings.defaultSettings();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java, + private Http2Settings initialSettings = Http2Settings.defaultSettings();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Codec.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java, + private Http2Settings initialSettings = Http2Settings.defaultSettings();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Codec.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecBuilder.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed
[+++ /dev/null, +++ /dev/null, +++ b/handler/src/main/java/io/netty/handler/ipfilter/AbstractRemoteAddressFilter.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF
[+++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, + int rowStartIndex = (row << 4) + startIndex;, + int rowStartIndex = (fullRows << 4) + startIndex;]
[+++ b/NOTICE.txt, +This product optionally depends on 'lzma-java', a LZMA Java compression, +and decompression library, which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.lzma-java.txt (Apache License 2.0), + * HOMEPAGE:, + * https://github.com/jponge/lzma-java, +, +++ b/NOTICE.txt, +This product optionally depends on 'lzma-java', a LZMA Java compression, +and decompression library, which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.lzma-java.txt (Apache License 2.0), + * HOMEPAGE:, + * https://github.com/jponge/lzma-java, +, +++ b/codec/pom.xml, + <dependency>, + <groupId>com.github.jponge</groupId>, + <artifactId>lzma-java</artifactId>, + <optional>true</optional>, + </dependency>, +++ b/NOTICE.txt, +This product optionally depends on 'lzma-java', a LZMA Java compression, +and
[+++ b/all/pom.xml, + <version>4.1.1.Final</version>, +++ b/all/pom.xml, + <version>4.1.1.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.1.Final</version>, +++ b/all/pom.xml, + <version>4.1.1.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.1.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.1.Final</version>, +++ b/all/pom.xml, + <version>4.1.1.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.1.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.1.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.1.Final</version>, +++ b/all/pom.xml, + <version>4.1.1.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.1.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.1.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.1.Final</version>, +++ b/codec-http/pom.xml, + <version>4.1.1.Final</version>, +++ b/all/pom.xml, + <version>4.1.1.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.1.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.1.Final</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.1.Final</version>, +++ b/codec-http/pom.xml, + <version>4.1.1.Final</version>, +++ b/codec-http2/pom.xml, + <version>4.1.1.Final</version>, +++ b/all/pom.xml, + <version>4.1.1.Final</version>, +++ b/buffer/pom.xml, + <version>4.1.1.Final</version>, +++ b/codec-dns/pom.xml, + <version>4.1.1.Final</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslContext.java, + return new JdkSslClientContext(, + trustCertChainFile, trustManagerFactory, keyCertChainFile, keyFile, keyPassword,, + trustCertChainFile, trustManagerFactory, ciphers, apn, sessionCacheSize, sessionTimeout);]
[+++ b/handler/src/test/java/io/netty/handler/ssl/JdkOpenSslEngineInteroptTest.java, +, + public JdkOpenSslEngineInteroptTest(BufferType type) {, + super(type);, + }, +, +++ b/handler/src/test/java/io/netty/handler/ssl/JdkOpenSslEngineInteroptTest.java, +, + public JdkOpenSslEngineInteroptTest(BufferType type) {, + super(type);, + }, +, +++ b/handler/src/test/java/io/netty/handler/ssl/JdkSslEngineTest.java, + public JdkSslEngineTest(BufferType type) {, + super(type);, + }, +, +++ b/handler/src/test/java/io/netty/handler/ssl/JdkOpenSslEngineInteroptTest.java, +, + public JdkOpenSslEngineInteroptTest(BufferType type) {, + super(type);, + }, +, +++ b/handler/src/test/java/io/netty/handler/ssl/JdkSslEngineTest.java, + public JdkSslEngineTest(BufferType type) {, + super(type);, + }, +, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, + public OpenSslEngineTest(BufferType type) {, + super(type);, + }, +, + public void testWrapBuffersNoWritePendingError() throws Exception {, + ByteBuffer src = allocateBuffer(1024 * 10);, + byte[] data = new byte[src.capacity()];, + ThreadLocalRandom.current().nextBytes(data);, + src.put(data).flip();,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java, + try {, + } catch (NumberFormatException ignore) {, + return defaultValue;, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java, + try {, + } catch (NumberFormatException ignore) {, + return defaultValue;, + }, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpUtilTest.java, +, + @Test, + public void testGetContentLengthDefaultValue() {, + HttpMessage message = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);, + assertNull(message.headers().get(HttpHeaderNames.CONTENT_LENGTH));, + message.headers().set(HttpHeaderNames.CONTENT_LENGTH, "bar");, + assertEquals("bar", message.headers().get(HttpHeaderNames.CONTENT_LENGTH));, + assertEquals(1L, HttpUtil.getContentLength(message, 1L));, + }]
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + q100 = new PoolChunkList<T>(null, 100, Integer.MAX_VALUE, chunkSize);, + q075 = new PoolChunkList<T>(q100, 75, 100, chunkSize);, + q050 = new PoolChunkList<T>(q075, 50, 100, chunkSize);, + q025 = new PoolChunkList<T>(q050, 25, 75, chunkSize);, + q000 = new PoolChunkList<T>(q025, 1, 50, chunkSize);, + qInit = new PoolChunkList<T>(q000, Integer.MIN_VALUE, 25, chunkSize);, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + q100 = new PoolChunkList<T>(null, 100, Integer.MAX_VALUE, chunkSize);, + q075 = new PoolChunkList<T>(q100, 75, 100, chunkSize);, + q050 = new PoolChunkList<T>(q075, 50, 100, chunkSize);, + q025 = new PoolChunkList<T>(q050, 25, 75, chunkSize);, + q000 = new PoolChunkList<T>(q025, 1, 50, chunkSize);, + qInit = new PoolChunkList<T>(q000, Integer.MIN_VALUE, 25,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessage.java, + * @apiviz.has io.netty.handler.codec.http.HttpContent oneway - - is followed by, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessage.java, + * @apiviz.has io.netty.handler.codec.http.HttpContent oneway - - is followed by, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + * @apiviz.has io.netty.handler.codec.http.HttpContent oneway - - filters out]
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java, + // DNS message compression means that domain names may contain "pointers" to other positions in the packet, + // to build a full message. This means the indexes are meaningful and we need the ability to reference the, + // indexes un-obstructed, and thus we cannot use a slice here., + // See https://www.ietf.org/rfc/rfc1035 [4.1.4. Message compression], + return new DefaultDnsPtrRecord(, + name, dnsClass, timeToLive, decodeName0(in.duplicate().setIndex(offset, offset + length)));, + name, type, dnsClass, timeToLive, in.retainedDuplicate().setIndex(offset, offset + length));, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java, + // DNS message compression means that domain names may contain "pointers" to other positions in
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Headers.java, + /**, + * Create a new instance., + * @param validate {@code true} to validate header names according to, + * <a href="https://tools.ietf.org/html/rfc7540">rfc7540</a>. {@code false} to not validate header names., + * @param arraySizeHint A hint as to how large the hash data structure should be., + * The next positive power of two will be used. An upper bound may be enforced., + */, + @SuppressWarnings("unchecked"), + public DefaultHttp2Headers(boolean validate, int arraySizeHint) {, + // Case sensitive compare is used because it is cheaper, and header validation can be used to catch invalid, + //
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + /**, + * Performs the closing handshake, + *, + * @param channel, + * Channel, + * @param frame, + * Closing Frame that was received, + */, + public ChannelFuture close(Channel channel, CloseWebSocketFrame frame) {, + if (channel == null) {, + throw new NullPointerException("channel");, + }, + return close(channel, frame, channel.newPromise());, + }, +, + /**, + * Performs the closing handshake, + *, + * @param channel, + * Channel, + * @param frame, + * Closing Frame that was received, + * @param promise, + * the {@link ChannelPromise} to be
[+++ b/testsuite-osgi/pom.xml, + <skipOsgiTestsuite>false</skipOsgiTestsuite>, + <profiles>, + <profile>, + <id>skipTests</id>, + <activation>, + <property>, + <name>skipTests</name>, + </property>, + </activation>, + <properties>, + <skipOsgiTestsuite>true</skipOsgiTestsuite>, + </properties>, + </profile>, + </profiles>, +, + <plugin>, + <artifactId>maven-surefire-plugin</artifactId>, + <configuration>, + <skip>${skipOsgiTestsuite}</skip>, + </configuration>, + </plugin>]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelId.java, + if (processId < 0) {, + if (pid < 0) {, + pid = ThreadLocalRandom.current().nextInt();]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OptionalSslHandler.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/pom.xml, + <!-- JDK10 -->, + <profile>, + <id>java10</id>, + <activation>, + <jdk>10</jdk>, + </activation>, + <properties>, + <!-- Not use alpn agent as Java10 supports alpn out of the box -->, + <argLine.alpnAgent />, + <forbiddenapis.skip>true</forbiddenapis.skip>, + <!-- Needed because of https://issues.apache.org/jira/browse/MENFORCER-275 -->, + <enforcer.plugin.version>3.0.0-M1</enforcer.plugin.version>, + </properties>, + </profile>, +, + <jboss.marshalling.version>2.0.5.Final</jboss.marshalling.version>, + <version>2.18.3</version>, +++ b/pom.xml, + <!-- JDK10 -->, + <profile>, + <id>java10</id>, + <activation>, + <jdk>10</jdk>, + </activation>, + <properties>, + <!-- Not use alpn agent as Java10 supports alpn out of the box -->, + <argLine.alpnAgent />, + <forbiddenapis.skip>true</forbiddenapis.skip>, + <!-- Needed because of
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + closeFuture.setClosed();, + closeFuture.setClosed();, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + closeFuture.setClosed();, + closeFuture.setClosed();, +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, + protected void doClose() throws Exception {, + if (state <= 2) {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + closeFuture.setClosed();, + closeFuture.setClosed();, +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, + protected void doClose() throws Exception {, + if (state <= 2) {, +++ b/transport/src/main/java/io/netty/channel/local/LocalServerChannel.java, + protected void doClose() throws Exception {, + if (state <= 1) {]
[+++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.channel.ChannelBootstrap;, + ChannelBootstrap b = new ChannelBootstrap();, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.channel.ChannelBootstrap;, + ChannelBootstrap b = new ChannelBootstrap();, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, +import io.netty.channel.ServerChannelBootstrap;, + ServerChannelBootstrap b = new ServerChannelBootstrap();, + try {, + b.eventLoop(new SelectorEventLoop(), new SelectorEventLoop()), + .channel(new NioServerSocketChannel()), + .option(ChannelOption.SO_BACKLOG, 100), + b.shutdown();, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.channel.ChannelBootstrap;, + ChannelBootstrap b = new ChannelBootstrap();, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, +import io.netty.channel.ServerChannelBootstrap;, + ServerChannelBootstrap b = new ServerChannelBootstrap();, + try {, + b.eventLoop(new SelectorEventLoop(), new SelectorEventLoop()), + .channel(new NioServerSocketChannel()), + .option(ChannelOption.SO_BACKLOG, 100), + b.shutdown();, +++ b/transport/src/main/java/io/netty/channel/ChannelBootstrap.java, +package io.netty.channel;, +, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, +, +import java.net.SocketAddress;, +import java.nio.channels.ClosedChannelException;, +import java.util.LinkedHashMap;, +import
[+++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, + logger.log(level, format(ctx, String.format("BIND(%s)", localAddress)));, + logger.log(level, format(ctx, String.format("CONNECT(%s, %s)", remoteAddress, localAddress)));, + logger.log(level, format(ctx, "DISCONNECT()"));, + logger.log(level, format(ctx, "CLOSE()"));, + logger.log(level, format(ctx, "DEREGISTER()"));, + logger.log(level, format(ctx, formatBuffer("OUTBUF", ctx.prevOut())));, + ctx.flush(future);]
[+++ b/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java, +import static org.junit.Assert.assertSame;, +, + @Test, + public void testCacheFailed() throws Exception {, + InetAddress addr1 = InetAddress.getByAddress(new byte[] { 10, 0, 0, 1 });, + InetAddress addr2 = InetAddress.getByAddress(new byte[] { 10, 0, 0, 2 });, + EventLoopGroup group = new DefaultEventLoopGroup(1);, +, + try {, + EventLoop loop = group.next();, + final DefaultDnsCache cache = new DefaultDnsCache(1, 100, 100);, + cache.cache("netty.io", null, addr1, 10000, loop);, + cache.cache("netty.io", null, addr2, 10000, loop);, +, + List<? extends DnsCacheEntry> entries = cache.get("netty.io", null);, + assertEquals(2, entries.size());, + assertEntry(entries.get(0), addr1);, + assertEntry(entries.get(1), addr2);, +, + Exception exception = new
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketShutdownOutputByPeerTest.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java, + assertEquals("unexpected hostname: " + next, expectedHostname, next.getHostString());]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CombinedHttpHeaders.java, +import static io.netty.handler.codec.http.HttpHeaderNames.SET_COOKIE;, + if (!itr.hasNext() || cannotBeCombined(name)) {, + if (values.isEmpty() || cannotBeCombined(name)) {, + private static boolean cannotBeCombined(CharSequence name) {, + return SET_COOKIE.contentEqualsIgnoreCase(name);, + }, +, + if (currentValue == null || cannotBeCombined(name)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CombinedHttpHeaders.java, +import static io.netty.handler.codec.http.HttpHeaderNames.SET_COOKIE;, + if (!itr.hasNext() || cannotBeCombined(name)) {, + if (values.isEmpty() || cannotBeCombined(name)) {, + private static boolean cannotBeCombined(CharSequence name) {, + return SET_COOKIE.contentEqualsIgnoreCase(name);, + }, +, + if (currentValue == null || cannotBeCombined(name)) {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/CombinedHttpHeadersTest.java, +import static io.netty.handler.codec.http.HttpHeaderNames.SET_COOKIE;, +import static org.hamcrest.Matchers.hasSize;, +import static org.junit.Assert.assertThat;, + public void dontCombineSetCookieHeaders() {, + final CombinedHttpHeaders headers = newCombinedHttpHeaders();, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, +import io.netty.tcnative.jni.CertificateVerifier;, +import io.netty.tcnative.jni.SSL;, +import io.netty.tcnative.jni.SSLContext;, +import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;, +, + private static final int DEFAULT_BIO_NON_APPLICATION_BUFFER_SIZE =, + AccessController.doPrivileged(new PrivilegedAction<Integer>() {, + @Override, + public Integer run() {, + return Math.max(1,, + SystemPropertyUtil.getInt("io.netty.handler.ssl.openssl.bioNonApplicationBufferSize",, + 2048));, + }, + });, +, + private volatile boolean rejectRemoteInitiatedRenegotiation;, + private volatile int bioNonApplicationBufferSize = DEFAULT_BIO_NON_APPLICATION_BUFFER_SIZE;, + // We do not support compression at the moment so we should explicitly disable it., + * Returns if remote initiated renegotiation is supported or not., + */, + public boolean getRejectRemoteInitiatedRenegotiation() {, + return rejectRemoteInitiatedRenegotiation;, + }, +, + /**, + * Set
[+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java, + String s = buffer.toString(buffer.readerIndex(), size, CharsetUtil.UTF_8);, + buffer.skipBytes(size);, + return new Result<String>(s, numberOfBytesConsumed);, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java, + String s = buffer.toString(buffer.readerIndex(), size, CharsetUtil.UTF_8);, + buffer.skipBytes(size);, + return new Result<String>(s, numberOfBytesConsumed);, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java, + username = SocksCommonUtils.readUsAscii(byteBuf, fieldLength);, + password = SocksCommonUtils.readUsAscii(byteBuf, fieldLength);, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java, + String s = buffer.toString(buffer.readerIndex(), size, CharsetUtil.UTF_8);, + buffer.skipBytes(size);, + return new Result<String>(s, numberOfBytesConsumed);, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java, + username = SocksCommonUtils.readUsAscii(byteBuf, fieldLength);, + password = SocksCommonUtils.readUsAscii(byteBuf, fieldLength);, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksCmdRequestDecoder.java, + host = SocksCommonUtils.readUsAscii(byteBuf, fieldLength);, + byte[] bytes = new byte[16];, + byteBuf.readBytes(bytes);, + host = SocksCommonUtils.ipv6toStr(bytes);, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java, + String s = buffer.toString(buffer.readerIndex(), size,
[+++ /dev/null, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, + return lineBuf.length() > 0 ? lineBuf.toString() : null;, + if (buffer.isReadable() && (char) buffer.getUnsignedByte(buffer.readerIndex()) == '\n') {, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, + return lineBuf.length() > 0 ? lineBuf.toString() : null;, + if (buffer.isReadable() && (char) buffer.getUnsignedByte(buffer.readerIndex()) == '\n') {, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, + return lineBuf.length() > 0 ? lineBuf.toString() : null;, + if (buffer.isReadable() && (char) buffer.getUnsignedByte(buffer.readerIndex()) == '\n') {, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java, + FixedCompositeByteBuf(ByteBufAllocator allocator, ByteBuf... buffers) {, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufInputStream.java, + return lineBuf.length()
[+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, + private final Runnable fireChannelWritabilityChangedTask;, + ChannelOutboundBuffer(final AbstractChannel channel) {, + fireChannelWritabilityChangedTask = new ChannelWritabilityChangedTask(channel);, + incrementPendingOutboundBytes(size, true);, + decrementPendingOutboundBytes(pending, true);, + void incrementPendingOutboundBytes(long size, boolean notifyWritability) {, + setUnwritable(notifyWritability);, + void decrementPendingOutboundBytes(long size, boolean notifyWritability) {, + if (newWriteBufferSize == 0, + || newWriteBufferSize <= channel.config().getWriteBufferLowWaterMark()) {, + setWritable(notifyWritability);, + decrementPendingOutboundBytes(size, true);, + decrementPendingOutboundBytes(size, notifyWritability);, + fireChannelWritabilityChanged();, + fireChannelWritabilityChanged();, + private void setWritable(boolean notify) {, + if (notify && oldValue != 0 && newValue == 0) {, + fireChannelWritabilityChanged();, + private void setUnwritable(boolean notify) {, + if (notify && oldValue == 0 && newValue != 0)
[+++ b/transport-native-epoll/src/main/c/netty_unix_socket.c, +static void netty_unix_socket_setTcpDeferAccept(JNIEnv* env, jclass clazz, jint fd, jint optval) {, + netty_unix_socket_setOption(env, fd, IPPROTO_TCP, TCP_DEFER_ACCEPT, &optval, sizeof(optval));, +}, +, +static void netty_unix_socket_setTcpQuickAck(JNIEnv* env, jclass clazz, jint fd, jint optval) {, + netty_unix_socket_setOption(env, fd, IPPROTO_TCP, TCP_QUICKACK, &optval, sizeof(optval));, +}, +, +, +static jint netty_unix_socket_getTcpDeferAccept(JNIEnv* env, jclass clazz, jint fd) {, + int optval;, + if (netty_unix_socket_getOption(env, fd, IPPROTO_TCP, TCP_DEFER_ACCEPT, &optval, sizeof(optval)) == -1) {, + return -1;, + }, + return optval;, +}, +, +static jint netty_unix_socket_isTcpQuickAck(JNIEnv* env, jclass clazz, jint fd) {, + int optval;, + if (netty_unix_socket_getOption(env, fd, IPPROTO_TCP, TCP_QUICKACK, &optval, sizeof(optval)) == -1) {,
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelPromise.java, +import io.netty.util.Signal;, + private static final Signal SUCCESS = new Signal(DefaultChannelPromise.class.getName() + ".SUCCESS");, +, + private Object listeners; // Can be ChannelFutureListener or DefaultChannelPromiseListeners, + return cause != null;, + return cause == SUCCESS;, + public Throwable cause() {, + Throwable cause;, + synchronized (this) {, + cause = this.cause;, + }, + return cause == SUCCESS? null : cause;, + if (cause != null) {, + if (listeners == null) {, + listeners = listener;, + if (listeners instanceof DefaultChannelPromiseListeners) {, + ((DefaultChannelPromiseListeners) listeners).add(listener);, + } else {, + listeners = new DefaultChannelPromiseListeners((ChannelFutureListener) listeners, listener);, +
[+++ b/transport-http/pom.xml, +, + <!-- Servlet API - completely optional -->, + <!-- Used for HTTP tunneling transport -->, + <dependency>, + <groupId>javax.servlet</groupId>, + <artifactId>servlet-api</artifactId>, + <optional>true</optional>, + </dependency>, +++ b/transport-http/pom.xml, +, + <!-- Servlet API - completely optional -->, + <!-- Used for HTTP tunneling transport -->, + <dependency>, + <groupId>javax.servlet</groupId>, + <artifactId>servlet-api</artifactId>, + <optional>true</optional>, + </dependency>, +++ b/transport-http/src/main/java/io/netty/channel/socket/http/HttpTunnelingServlet.java, +/*, + * Copyright 2011 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance,
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + throw new IndexOutOfBoundsException(String.format(, + "readerIndex: %d (expected: 0 <= readerIndex <= writerIndex(%d))", readerIndex, writerIndex));, + throw new IndexOutOfBoundsException(String.format(, + "writerIndex: %d (expected: readerIndex(%d) <= writerIndex <= capacity(%d))",, + writerIndex, readerIndex, capacity()));, + throw new IndexOutOfBoundsException(String.format(, + "readerIndex: %d, writerIndex: %d (expected: 0 <= readerIndex <= writerIndex <= capacity(%d))",, + readerIndex, writerIndex, capacity()));, + "writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s",, + writerIndex, minWritableBytes, maxCapacity, this));, + checkIndex(index, length);, + if (dst == null) {, + throw new NullPointerException("dst");, + }, +, + throw new IndexOutOfBoundsException(String.format(, + "length(%d) exceeds dst.writableBytes(%d) where dst is: %s", length, dst.writableBytes(), dst));, +
[+++ b/codec/src/test/java/io/netty/handler/codec/json/JsonObjectDecoderTest.java, + res.release();]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameEncoder.java, + // Close frame, needs to call duplicate to allow multiple writes., + // See https://github.com/netty/netty/issues/2768, + out.add(_0XFF_0X00.duplicate());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameEncoder.java, + // Close frame, needs to call duplicate to allow multiple writes., + // See https://github.com/netty/netty/issues/2768, + out.add(_0XFF_0X00.duplicate());, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameEncoderTest.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *
[+++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, +import io.netty.channel.PreferHeapByteBufAllocator;, + setAllocator(new PreferHeapByteBufAllocator(getAllocator()));, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/DefaultRxtxChannelConfig.java, +import io.netty.channel.PreferHeapByteBufAllocator;, + setAllocator(new PreferHeapByteBufAllocator(getAllocator()));, +++ b/transport/src/main/java/io/netty/channel/PreferHeapByteBufAllocator.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + * Gets the maximum length for any frame's payload., + *, + * @return The maximum length for a frame's payload]
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + if (maxNumComponents < 1) {, + "maxNumComponents: " + maxNumComponents + " (expected: >= 1)");, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + if (maxNumComponents < 1) {, + "maxNumComponents: " + maxNumComponents + " (expected: >= 1)");, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + private static final ByteBufAllocator ALLOC = UnpooledByteBufAllocator.DEFAULT;, +, + @Test, + public void testComponentsLessThanLowerBound() {, + try {, + new CompositeByteBuf(ALLOC, true, 0);, + fail();, + } catch (IllegalArgumentException e) {, + assertEquals("maxNumComponents: 0 (expected: >= 1)", e.getMessage());, + }, + }, +, + @Test, + public void testComponentsEqualToLowerBound() {, + assertCompositeBufCreated(1);, + }, +, + @Test, + public void
[+++ /dev/null, +++ /dev/null, +++ b/all/pom.xml, + <id>clean-first</id>, + <includeGroupIds>${project.groupId}</includeGroupIds>, + <outputDirectory>${project.build.directory}/src</outputDirectory>, + <groupId>org.codehaus.mojo</groupId>, + <artifactId>build-helper-maven-plugin</artifactId>, + <version>1.7</version>, + <id>add-source</id>, + <phase>generate-sources</phase>, + <goal>add-source</goal>, + <sources>, + <source>target/src</source>, + </sources>, +, + <profiles>, + <profile>, + <id>full</id>, + <build>, + <plugins>, + <plugin>, + <artifactId>maven-jxr-plugin</artifactId>, + <version>2.2</version>, + <executions>, + <execution>, + <id>generate-xref</id>, + <phase>package</phase>, + <goals>, + <goal>jxr</goal>, + </goals>, + </execution>, + </executions>, + <configuration>, + <inputEncoding>UTF-8</inputEncoding>, + <outputEncoding>UTF-8</outputEncoding>, + <linkJavadoc>true</linkJavadoc>, + <destDir>${project.build.directory}/xref</destDir>, + <javadocDir>${project.build.directory}/api</javadocDir>, + <docTitle>Netty Source Xref (${project.version})</docTitle>, + <windowTitle>Netty Source Xref (${project.version})</windowTitle>, + </configuration>, + </plugin>, + <plugin>, + <artifactId>maven-javadoc-plugin</artifactId>, + <version>2.8.1</version>, + <executions>,
[+++ b/common/src/main/java/io/netty/util/DefaultAttributeMap.java, + return attr;, + } else {, + curr = next;, +++ b/common/src/main/java/io/netty/util/DefaultAttributeMap.java, + return attr;, + } else {, + curr = next;, +++ b/common/src/test/java/io/netty/util/DefaultAttributeMapTest.java, +, + // See https://github.com/netty/netty/issues/2523, + @Test, + public void testSetRemove() {, + AttributeKey<Integer> key = AttributeKey.valueOf("key");, +, + map.attr(key).set(1);, + assertSame(1, map.attr(key).getAndRemove());, +, + map.attr(key).set(2);, + assertSame(2, map.attr(key).get());, + }]
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Exception e) {, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Exception e) {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +import java.io.IOException;, +import java.net.InetSocketAddress;, +import java.net.SocketAddress;, +import java.nio.channels.NotYetConnectedException;, +import java.nio.channels.SelectionKey;, +, + EventLoop eventLoop();, +, +, + ChannelFuture deregister();, + void deregister(ChannelFuture future);, +, + Unsafe unsafe();, +, + public interface Unsafe {, + void setEventLoop(EventLoop eventLoop);, + void clearEventLoop();, + java.nio.channels.Channel ch();, +, + void bind(SocketAddress local) throws IOException;, + void connect(SocketAddress remote) throws IOException;, + boolean finishConnect() throws IOException;, + boolean read() throws IOException;, + boolean write() throws IOException;, +
[+++ b/testsuite-osgi/pom.xml, +, + <profile>, + <id>linux</id>, + <activation>, + <os>, + <family>linux</family>, + </os>, + </activation>, + <dependencies>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport-native-epoll</artifactId>, + <version>${project.version}</version>, + <scope>test</scope>, + </dependency>, + </dependencies>, + </profile>, +, + <profile>, + <id>mac</id>, + <activation>, + <os>, + <family>mac</family>, + </os>, + </activation>, + <dependencies>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-transport-native-kqueue</artifactId>, + <version>${project.version}</version>, + <scope>test</scope>, + </dependency>, + </dependencies>, + </profile>, + <groupId>org.apache.felix</groupId>, + <artifactId>org.apache.felix.configadmin</artifactId>, + <version>1.9.14</version>, + </dependency>, + <dependency>, + <groupId>org.apache.felix</groupId>, + <artifactId>org.apache.felix.framework</artifactId>, + <version>6.0.2</version>, + <artifactId>pax-exam-container-native</artifactId>, + <artifactId>pax-exam-link-assembly</artifactId>, + <groupId>com.github.veithen.alta</groupId>, + <artifactId>alta-maven-plugin</artifactId>, + <version>0.6.2</version>, + <goal>generate-test-resources</goal>, + <configuration>, +
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + final void ensureWritable0(int minWritableBytes) {, + ensureAccessible();, + ensureAccessible();, + ensureWritable0(ByteBufUtil.utf8MaxBytes(sequence));, + ensureWritable0(len);, + ensureWritable0(bytes.length);, + ensureWritable0(length);, + checkIndex0(wIndex, length);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + final void ensureWritable0(int minWritableBytes) {, + ensureAccessible();, + ensureAccessible();, + ensureWritable0(ByteBufUtil.utf8MaxBytes(sequence));, + ensureWritable0(len);, + ensureWritable0(bytes.length);, + ensureWritable0(length);, + checkIndex0(wIndex, length);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractUnsafeSwappedByteBuf.java, + wrapped.ensureWritable0(2);, + wrapped.ensureWritable0(4);, + wrapped.ensureWritable0(8);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + final void ensureWritable0(int minWritableBytes) {, + ensureAccessible();, + ensureAccessible();, + ensureWritable0(ByteBufUtil.utf8MaxBytes(sequence));, + ensureWritable0(len);, + ensureWritable0(bytes.length);, + ensureWritable0(length);, + checkIndex0(wIndex, length);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractUnsafeSwappedByteBuf.java, + wrapped.ensureWritable0(2);, + wrapped.ensureWritable0(4);, + wrapped.ensureWritable0(8);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + byteBuf.ensureWritable0(utf8MaxBytes(seq));, + byteBuf.ensureWritable0(len);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + final void ensureWritable0(int minWritableBytes) {,
[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java, + validateScheduled0(delay, unit);, + validateScheduled0(delay, unit);, + validateScheduled0(initialDelay, unit);, + validateScheduled0(period, unit);, + validateScheduled0(initialDelay, unit);, + validateScheduled0(delay, unit);, + @SuppressWarnings("deprecation"), + private void validateScheduled0(long amount, TimeUnit unit) {, + validateScheduled(amount, unit);, + }, +, + *, + * @deprecated will be removed in the future., + @Deprecated, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java, + validateScheduled0(delay, unit);, + validateScheduled0(delay, unit);, + validateScheduled0(initialDelay, unit);, + validateScheduled0(period, unit);, + validateScheduled0(initialDelay, unit);, + validateScheduled0(delay, unit);, + @SuppressWarnings("deprecation"), + private void validateScheduled0(long amount, TimeUnit unit) {, + validateScheduled(amount, unit);, + }, +, + *, + * @deprecated will be removed in the future., + @Deprecated, +++
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoderTest.java, + CharsetUtil.UTF_8, -1);, + CharsetUtil.UTF_8, -1);, + checkNextChunkSize(encoder, 8080);, + checkNextChunkSize(encoder, 8080);, + checkNextChunkSize(encoder, 8080);, + private static void checkNextChunkSize(HttpPostRequestEncoder encoder, int sizeWithoutDelimiter) throws Exception {, + // 16 bytes as HttpPostRequestEncoder uses Long.toHexString(...) to generate a hex-string which will be between, + // 2 and 16 bytes., + // See https://github.com/netty/netty/blob/4.1/codec-http/src/main/java/io/netty/handler/, + // codec/http/multipart/HttpPostRequestEncoder.java#L291, + int expectedSizeMin = sizeWithoutDelimiter + 2;, + int expectedSizeMax = sizeWithoutDelimiter + 16;, +, +, + int readable = httpContent.content().readableBytes();, + boolean expectedSize = readable >= expectedSizeMin && readable <= expectedSizeMax;, + assertTrue("Chunk size is not in expected range (" +
[+++ b/handler/src/main/java/io/netty/handler/ssl/CipherSuiteConverter.java, +import java.util.Collections;, +import static java.util.Collections.singletonMap;, +, + private static final Map<String, String> j2oTls13;, + private static final Map<String, Map<String, String>> o2jTls13;, +, + static {, + Map<String, String> j2oTls13Map = new HashMap<String, String>();, + j2oTls13Map.put("TLS_AES_128_GCM_SHA256", "AEAD-AES128-GCM-SHA256");, + j2oTls13Map.put("TLS_AES_256_GCM_SHA384", "AEAD-AES256-GCM-SHA384");, + j2oTls13Map.put("TLS_CHACHA20_POLY1305_SHA256", "AEAD-CHACHA20-POLY1305-SHA256");, + j2oTls13 = Collections.unmodifiableMap(j2oTls13Map);, +, + Map<String, Map<String, String>> o2jTls13Map = new HashMap<String, Map<String, String>>();, + o2jTls13Map.put("TLS_AES_128_GCM_SHA256", singletonMap("TLS", "TLS_AES_128_GCM_SHA256"));, + o2jTls13Map.put("TLS_AES_256_GCM_SHA384", singletonMap("TLS", "TLS_AES_256_GCM_SHA384"));, + o2jTls13Map.put("TLS_CHACHA20_POLY1305_SHA256", singletonMap("TLS", "TLS_CHACHA20_POLY1305_SHA256"));, + o2jTls13Map.put("AEAD-AES128-GCM-SHA256", singletonMap("TLS", "TLS_AES_128_GCM_SHA256"));, + o2jTls13Map.put("AEAD-AES256-GCM-SHA384", singletonMap("TLS", "TLS_AES_256_GCM_SHA384"));, + o2jTls13Map.put("AEAD-CHACHA20-POLY1305-SHA256", singletonMap("TLS", "TLS_CHACHA20_POLY1305_SHA256"));, + o2jTls13 = Collections.unmodifiableMap(o2jTls13Map);, + }, +, + static String toOpenSsl(String javaCipherSuite, boolean boringSSL) {, +
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/HpackTest.java, +import io.netty.util.internal.ResourcesUtil;, + File[] files = ResourcesUtil.getFile(HpackTest.class, TEST_DIR).listFiles();, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/HpackTest.java, +import io.netty.util.internal.ResourcesUtil;, + File[] files = ResourcesUtil.getFile(HpackTest.class, TEST_DIR).listFiles();, +++ b/common/src/main/java/io/netty/util/internal/ResourcesUtil.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the, + * "License"); you may not use this file except in compliance with the License. You may obtain a, + * copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, + if (isNotWebSocketPath(req)) {, + private boolean isNotWebSocketPath(FullHttpRequest req) {, + return checkStartsWith ? !req.uri().startsWith(websocketPath) : !req.uri().equals(websocketPath);, + }, +, + String host = req.headers().get(HttpHeaderNames.HOST);, + return protocol + "://" + host + path;]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, + /* Load the certificate chain. We must NOT skip the first cert when client mode */, + if (!SSLContext.setCertificateChainFile(ctx, trustCertChainFile.getPath(), false)) {]
[+++ b/codec-redis/src/test/java/io/netty/handler/codec/redis/RedisEncoderTest.java, + read.release();]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandler.java, +import io.netty.handler.codec.http.EmptyHttpHeaders;, + writeHeaders(ctx, encoder, currentStreamId, httpMsg.headers(), http2Headers,, + endStream, promiseAggregator);, + HttpHeaders trailers = EmptyHttpHeaders.INSTANCE;, + Http2Headers http2Trailers = EmptyHttp2Headers.INSTANCE;, + trailers = lastContent.trailingHeaders();, + http2Trailers = HttpConversionUtil.toHttp2Headers(trailers, validateHeaders);, + writeHeaders(ctx, encoder, currentStreamId, trailers, http2Trailers, true, promiseAggregator);, +, + private static void writeHeaders(ChannelHandlerContext ctx, Http2ConnectionEncoder encoder, int streamId,, + HttpHeaders headers, Http2Headers http2Headers, boolean endStream,, + SimpleChannelPromiseAggregator promiseAggregator) {, + int dependencyId = headers.getInt(, + HttpConversionUtil.ExtensionHeaderNames.STREAM_DEPENDENCY_ID.text(), 0);, + short weight = headers.getShort(, + HttpConversionUtil.ExtensionHeaderNames.STREAM_WEIGHT.text(), Http2CodecUtil.DEFAULT_PRIORITY_WEIGHT);, + encoder.writeHeaders(ctx, streamId, http2Headers, dependencyId, weight, false,, + 0, endStream, promiseAggregator.newPromise());, + }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandler.java, +import io.netty.handler.codec.http.EmptyHttpHeaders;, + writeHeaders(ctx, encoder, currentStreamId,
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, + static void encodeLiteral(ByteBuf in, ByteBuf out, int length) {, + static int decodeLiteral(byte tag, ByteBuf in, ByteBuf out) {, + case 63:, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, + static void encodeLiteral(ByteBuf in, ByteBuf out, int length) {, + static int decodeLiteral(byte tag, ByteBuf in, ByteBuf out) {, + case 63:, +++ b/codec/src/test/java/io/netty/handler/codec/compression/SnappyTest.java, +, + @Test, + public void testEncodeLiteralAndDecodeLiteral() {, + int[] lengths = new int[] {, + 0x11, // default, + 0x100, // case 60, + 0x1000, // case 61, + 0x100000, // case 62, + 0x1000001 // case 63, + };, + for (int len : lengths)
[+++ b/transport/src/main/java/io/netty/channel/ChannelConfig.java, + * @deprecated From version 5.0, {@link Channel} will not be closed on write failure., + *, + @Deprecated, + * @deprecated From version 5.0, {@link Channel} will not be closed on write failure., + *, + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/ChannelConfig.java, + * @deprecated From version 5.0, {@link Channel} will not be closed on write failure., + *, + @Deprecated, + * @deprecated From version 5.0, {@link Channel} will not be closed on write failure., + *, + @Deprecated, +++ b/transport/src/main/java/io/netty/channel/ChannelOption.java, + * @deprecated From version 5.0, {@link Channel} will not be closed on write failure., + *,
[+++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java, + * channel.pipeline().addLast("readTimeoutHandler", new {@link ReadTimeoutHandler}(30);, + * channel.pipeline().addLast("myHandler", new MyHandler());, +++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java, + * channel.pipeline().addLast("readTimeoutHandler", new {@link ReadTimeoutHandler}(30);, + * channel.pipeline().addLast("myHandler", new MyHandler());, +++ b/handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java, + * channel.pipeline().addLast("writeTimeoutHandler", new {@link WriteTimeoutHandler}(30);, + * channel.pipeline().addLast("myHandler", new MyHandler());, +++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java, + * channel.pipeline().addLast("readTimeoutHandler", new {@link ReadTimeoutHandler}(30);, + * channel.pipeline().addLast("myHandler", new MyHandler());, +++ b/handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java, + * channel.pipeline().addLast("writeTimeoutHandler", new {@link WriteTimeoutHandler}(30);, + * channel.pipeline().addLast("myHandler", new MyHandler());, +++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, + * <pre>, + *, + * public class MyChannelInitializer extends {@link ChannelInitializer} {, + * public void initChannel({@link Channel} channel) {, + * channel.pipeline().addLast("myHandler", new MyHandler());, + * }, + *
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_WEIGHT;, +import static io.netty.handler.codec.http2.Http2CodecUtil.MIN_WEIGHT;, + // It is assumed there are all validated at a higher level. For example in the Http2FrameReader., + assert weight >= MIN_WEIGHT && weight <= MAX_WEIGHT : "Invalid weight";, + assert childStreamId != parentStreamId : "A stream cannot depend on itself";, + assert childStreamId > 0 && parentStreamId >= 0 : "childStreamId must be > 0. parentStreamId must be >= 0.";, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2RemoteFlowController.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_WEIGHT;, +import static io.netty.handler.codec.http2.Http2CodecUtil.MIN_WEIGHT;, + // It is assumed there are all validated at a higher level. For example in the Http2FrameReader., + assert
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_HEADER_TABLE_SIZE;, +import static io.netty.handler.codec.http2.Http2CodecUtil.MIN_HEADER_TABLE_SIZE;, + public void maxHeaderTableSize(long max) throws Http2Exception {, + if (max < MIN_HEADER_TABLE_SIZE || max > MAX_HEADER_TABLE_SIZE) {, + throw connectionError(PROTOCOL_ERROR, "Header Table Size must be >= %d and <= %d but was %d",, + MIN_HEADER_TABLE_SIZE, MAX_HEADER_TABLE_SIZE, max);, + public long maxHeaderTableSize() {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_HEADER_TABLE_SIZE;, +import static io.netty.handler.codec.http2.Http2CodecUtil.MIN_HEADER_TABLE_SIZE;, + public void maxHeaderTableSize(long max) throws Http2Exception {, + if (max < MIN_HEADER_TABLE_SIZE || max > MAX_HEADER_TABLE_SIZE) {, + throw connectionError(PROTOCOL_ERROR, "Header Table Size must be >= %d and <= %d but was %d",, + MIN_HEADER_TABLE_SIZE, MAX_HEADER_TABLE_SIZE, max);, + public
[+++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, +import io.netty.buffer.ByteBufHolder;, + * condition. The same is true for {@link ByteBufHolder}. Please note that this operation is asynchronous as, + * Writes the specified {@code message} to all {@link Channel}s in this, + * group that match the given {@link ChannelGroupMatcher}. If the specified {@code message} is an instance of, + * {@link ByteBuf}, it is automatically, + * {@linkplain ByteBuf#duplicate() duplicated} to avoid a race, + * condition. The same is true for {@link ByteBufHolder}. Please note that this operation is asynchronous as, + * {@link Channel#write(Object)} is., + *, + * @return the {@link
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, + * The assumed minimum value for {@code SETTINGS_MAX_CONCURRENT_STREAMS} as, + * recommended by the HTTP/2 spec., + */, + public static final int SMALLEST_MAX_CONCURRENT_STREAMS = 100;, +, + /**, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, + * The assumed minimum value for {@code SETTINGS_MAX_CONCURRENT_STREAMS} as, + * recommended by the HTTP/2 spec., + */, + public static final int SMALLEST_MAX_CONCURRENT_STREAMS = 100;, +, + /**, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/StreamBufferingEncoder.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the, + * "License"); you may not
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelId.java, +import io.netty.util.internal.MacAddressUtil;, + final ClassLoader loader = PlatformDependent.getClassLoader(DefaultChannelId.class);, + Method getName = runtimeMxBeanType.getMethod("getName", EmptyArrays.EMPTY_CLASSES);]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, +import io.netty.channel.ChannelOption;, +import io.netty.channel.socket.ChannelInputShutdownEvent;, + private volatile boolean inputShutdown;, + protected final boolean isInputShutdown0() {, + return inputShutdown;, + }, +, + final void epollRdHupReady() {, + if (isActive()) {, + // If it is still active, we need to call epollInReady as otherwise we may miss to, + // read pending data from the underlying file descriptor., + // See https://github.com/netty/netty/issues/3709, + epollInReady();, +, + // Clear the EPOLLRDHUP flag to prevent continuously getting woken up on this event., + clearEpollRdHup();, + }, + // epollInReady may call this, but we should ensure that it gets
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + if (!Values.WEBSOCKET.equalsIgnoreCase(upgrade)) {, + + upgrade);, + if (!Values.UPGRADE.equalsIgnoreCase(connection)) {, + + connection);]
[+++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.channel.socket.nio.NioEventLoopGroup;, + b.group(new NioEventLoopGroup()), +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.channel.socket.nio.NioEventLoopGroup;, + b.group(new NioEventLoopGroup()), +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, +import io.netty.channel.socket.nio.NioEventLoopGroup;, + b.group(new NioEventLoopGroup(), new NioEventLoopGroup()), +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.channel.socket.nio.NioEventLoopGroup;, + b.group(new NioEventLoopGroup()), +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, +import io.netty.channel.socket.nio.NioEventLoopGroup;, + b.group(new NioEventLoopGroup(), new NioEventLoopGroup()), +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.channel.socket.nio.NioEventLoopGroup;, + b.group(new NioEventLoopGroup()), +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.channel.socket.nio.NioEventLoopGroup;, + b.group(new NioEventLoopGroup()), +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, +import io.netty.channel.socket.nio.NioEventLoopGroup;, + b.group(new NioEventLoopGroup(), new NioEventLoopGroup()), +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.channel.socket.nio.NioEventLoopGroup;, + b.group(new NioEventLoopGroup()), +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, +import io.netty.channel.socket.nio.NioEventLoopGroup;, + b.group(new NioEventLoopGroup(), new NioEventLoopGroup()), +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.channel.socket.nio.NioEventLoopGroup;, + b.group(new NioEventLoopGroup()), +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, +import io.netty.channel.socket.nio.NioEventLoopGroup;, + b.group(new NioEventLoopGroup(), new NioEventLoopGroup()), +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.channel.socket.nio.NioEventLoopGroup;, +
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +import java.util.ArrayDeque;, +import java.util.Queue;, + private static final Queue<ByteBuf> freeLaterQueue = new ArrayDeque<ByteBuf>();, +, + protected ByteBuf freeLater(ByteBuf buf) {, + freeLaterQueue.add(buf);, + return buf;, + }, +, +, + for (;;) {, + ByteBuf buf = freeLaterQueue.poll();, + if (buf == null) {, + break;, + }, +, + if (buf.refCnt() > 0) {, + buf.release(buf.refCnt());, + }, + }, + ByteBuf value = freeLater(directBuffer(BLOCK_SIZE * 2));, + ByteBuf expectedValue = freeLater(directBuffer(BLOCK_SIZE * 2));, + ByteBuf value = freeLater(directBuffer(BLOCK_SIZE * 2));, + ByteBuf expectedValue = freeLater(wrappedBuffer(expectedValueContent));, + ByteBuf value = freeLater(directBuffer(BLOCK_SIZE * 2));, + ByteBuf expectedValue
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + decoder.decode(buf.nioBuffer(index, length));, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + decoder.decode(buf.nioBuffer(index, length));, +++ b/buffer/src/test/java/io/netty/buffer/ByteBufUtilTest.java, +import java.nio.Buffer;, +import java.util.ArrayList;, +import java.util.List;, +import java.util.concurrent.atomic.AtomicInteger;, +import java.util.concurrent.atomic.AtomicReference;, +, + @Test, + public void testIsTextMultiThreaded() throws Throwable {, + final ByteBuf buffer = Unpooled.copiedBuffer("Hello, World!", CharsetUtil.ISO_8859_1);, +, + try {, + final AtomicInteger counter = new AtomicInteger(60000);, + final AtomicReference<Throwable> errorRef = new AtomicReference<Throwable>();, + List<Thread> threads = new ArrayList<Thread>();, + for (int i = 0; i < 10; i++) {, + Thread thread = new Thread(new Runnable() {, + @Override, + public void run() {, + try {, + while (errorRef.get() == null &&
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + * {@link ByteBuf} has nothing to read when return from this method or till nothing was read from the input, + * {@link ByteBuf}., +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + * {@link ByteBuf} has nothing to read when return from this method or till nothing was read from the input, + * {@link ByteBuf}., +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, + * protected void decode({@link ChannelHandlerContext} ctx,]
[+++ b/example/src/main/java/io/netty/example/spdy/client/SpdyClient.java, + * You may also use the {@code run-example.sh} script to start the client from the command line:, + * ./run-example spdy-client, +++ b/example/src/main/java/io/netty/example/spdy/client/SpdyClient.java, + * You may also use the {@code run-example.sh} script to start the client from the command line:, + * ./run-example spdy-client, +++ b/example/src/main/java/io/netty/example/spdy/client/package-info.java, + * You may also use the {@code run-example.sh} script to start the server and the client from the command line:, + * ./run-example spdy-server, + * <pre>, + * ./run-example spdy-client, + * </pre>, +++ b/example/src/main/java/io/netty/example/spdy/client/SpdyClient.java, + * You may also use the {@code run-example.sh} script to start
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java, + "SSL_RSA_WITH_3DES_EDE_CBC_SHA",]
[+++ b/testsuite/pom.xml, + </plugins>, + </build>, +, + <profiles>, + <profile>, + <!-- Only run the autobahntestsuite if it is not disabled -->, + <id>autobahntestsuite</id>, + <activation>, + <property>, + <name>!skipAutobahnTestsuite</name>, + </property>, + </activation>, + <build>, + <plugins>, + </profile>, + </profiles>]
[+++ b/all/pom.xml, + <version>4.0.10.Final</version>, +++ b/all/pom.xml, + <version>4.0.10.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.10.Final</version>, +++ b/all/pom.xml, + <version>4.0.10.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.10.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.10.Final</version>, +++ b/all/pom.xml, + <version>4.0.10.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.10.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.10.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.10.Final</version>, +++ b/all/pom.xml, + <version>4.0.10.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.10.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.10.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.10.Final</version>, +++ b/codec/pom.xml, + <version>4.0.10.Final</version>, +++ b/all/pom.xml, + <version>4.0.10.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.10.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.10.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.10.Final</version>, +++ b/codec/pom.xml, + <version>4.0.10.Final</version>, +++ b/common/pom.xml, + <version>4.0.10.Final</version>, +++ b/all/pom.xml, + <version>4.0.10.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.10.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.10.Final</version>, +++ b/codec-socks/pom.xml, +
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java, + final boolean useEtcResolverFiles = etcResolverFiles != null && etcResolverFiles.length != 0;, + domainToNameServerStreamMap = useEtcResolverFiles ? parse(etcResolverFiles) : etcResolvConfMap;, + if (useEtcResolverFiles) {, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProvider.java, + final boolean useEtcResolverFiles = etcResolverFiles != null && etcResolverFiles.length != 0;, + domainToNameServerStreamMap = useEtcResolverFiles ? parse(etcResolverFiles) : etcResolvConfMap;, + if (useEtcResolverFiles) {, +++ b/resolver-dns/src/test/java/io/netty/resolver/dns/UnixResolverDnsServerAddressStreamProviderTest.java, + @Test, + public void emptyEtcResolverDirectoryDoesNotThrow() throws IOException {, + File f = buildFile("domain linecorp.local\n" +, + "nameserver 127.0.0.2\n" +, + "nameserver 127.0.0.3\n");, + UnixResolverDnsServerAddressStreamProvider p =, + new UnixResolverDnsServerAddressStreamProvider(f, folder.newFolder().listFiles());, +, + DnsServerAddressStream stream = p.nameServerAddressStream("somehost");, + assertHostNameEquals("127.0.0.2", stream.next());, + }, +]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import java.util.concurrent.atomic.AtomicLong;, +import io.netty.channel.ChannelStateEvent;, +import io.netty.handler.codec.PrematureChannelClosureException;, + * , + * If the {@link Channel} gets closed and there are requests missing for a response, + * a {@link PrematureChannelClosureException} is thrown., + * , + private final AtomicLong requestResponseCounter = new AtomicLong(0);, +, + Object obj = super.encode(ctx, channel, msg);, + , + // check if the request is chunked if so do not increment, + if (msg instanceof HttpRequest && !((HttpRequest) msg).isChunked()) {, + requestResponseCounter.incrementAndGet();, + } else if (msg instanceof HttpChunk && ((HttpChunk) msg).isLast()) {, + // increment as its the last chunk, +
[+++ b/transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpInboundByteStreamHandler.java, + public final boolean acceptInboundMessage(Object msg) throws Exception {, + return acceptInboundMessage((SctpMessage) msg);, + protected boolean acceptInboundMessage(SctpMessage msg) {]
[+++ b/example/src/main/java/io/netty/example/localecho/LocalEcho.java, + sb.group(new LocalEventLoopGroup()), + cb.group(new NioEventLoopGroup()) // NIO event loops are also OK, +++ b/example/src/main/java/io/netty/example/localecho/LocalEcho.java, + sb.group(new LocalEventLoopGroup()), + cb.group(new NioEventLoopGroup()) // NIO event loops are also OK, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java, + group(loop)., +++ b/example/src/main/java/io/netty/example/localecho/LocalEcho.java, + sb.group(new LocalEventLoopGroup()), + cb.group(new NioEventLoopGroup()) // NIO event loops are also OK, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java, + group(loop)., +++ b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java, + public ServerBootstrap group(EventLoopGroup group) {, + if (group == null) {, + throw new NullPointerException("group");, + }, + if (parentGroup != null) {, + throw new IllegalStateException("parentGroup set already");, + }, + parentGroup = group;, + childGroup = group;, + return this;, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2SecurityUtil.java, + * href="https://wiki.mozilla.org/Security/Server_Side_TLS#Modern_compatibility">Mozilla Modern Cipher, + /**, + * <a href="https://wiki.mozilla.org/Security/Server_Side_TLS#Modern_compatibility">Mozilla Modern Cipher, + * Suites</a> minus the following cipher suites that are black listed by the, + * <a href="https://tools.ietf.org/html/rfc7540#appendix-A">HTTP/2 RFC</a>., + */, + private static final List<String> CIPHERS_JAVA_MOZILLA_MODERN_SECURITY = Collections.unmodifiableList(Arrays, + /* openssl = ECDHE-ECDSA-CHACHA20-POLY1305 */, + "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",, + "SSL_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",, + /* openssl = ECDHE-RSA-CHACHA20-POLY1305 */, + "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256",, + "SSL_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256",, + /* openssl = ECDHE-ECDSA-AES128-GCM-SHA256 */, + "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",, + "SSL_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",, + "SSL_ECDHE_RSA_WITH_AES_128_GCM_SHA256", + CIPHERS = Collections.unmodifiableList(new ArrayList<String>(CIPHERS_JAVA_MOZILLA_MODERN_SECURITY));]
[+++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, +import java.util.ArrayList;, +import java.util.List;, + List<Throwable> suppressed = new ArrayList<Throwable>();, + suppressed.add(t);, + IllegalArgumentException iae =, + new IllegalArgumentException("Failed to load any of the given libraries: " + Arrays.toString(names));, + ThrowableUtil.addSuppressedAndClear(iae, suppressed);, + throw iae;, + List<Throwable> suppressed = new ArrayList<Throwable>();, + suppressed.add(ex);, + FileNotFoundException fnf = new FileNotFoundException(fileName);, + ThrowableUtil.addSuppressedAndClear(fnf, suppressed);, + throw fnf;, + FileNotFoundException fnf = new FileNotFoundException(path);, + ThrowableUtil.addSuppressedAndClear(fnf, suppressed);, + throw fnf;, + suppressed.add(t);, + ThrowableUtil.addSuppressedAndClear(e, suppressed);, + UnsatisfiedLinkError ule = new UnsatisfiedLinkError("could not load a native library: " + name);, + ule.initCause(e);, + ThrowableUtil.addSuppressedAndClear(ule, suppressed);, + throw ule;, + Throwable suppressed
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketMultipleConnectTest.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyControlFrame.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/NOTICE.txt, +This product optionally depends on 'Aalto XML', an ultra-high performance, +non-blocking XML processor, which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.aalto-xml.txt (Apache License 2.0), + * HOMEPAGE:, + * http://wiki.fasterxml.com/AaltoHome, +, +++ b/NOTICE.txt, +This product optionally depends on 'Aalto XML', an ultra-high performance, +non-blocking XML processor, which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.aalto-xml.txt (Apache License 2.0), + * HOMEPAGE:, + * http://wiki.fasterxml.com/AaltoHome, +, +++ b/codec-xml/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<!--, + ~ Copyright 2014 The Netty Project, + ~, + ~ The Netty Project licenses this file to you
[+++ b/pom.xml, + <releases>, + <updatePolicy>interval:10080</updatePolicy>, + </releases>, +++ b/pom.xml, + <releases>, + <updatePolicy>interval:10080</updatePolicy>, + </releases>, +++ b/src/docbook/custom.dtd, +<!ENTITY ChannelEvent "<ulink url='&API;channel/ChannelEvent.html'><interfacename>ChannelEvent</interfacename></ulink>">, +<!-- Types in the channel.socket package -->, +, +<!ENTITY ServerSocketChannel "<ulink url='&API;channel/socket/ServerSocketChannel.html'><classname>ServerSocketChannel</classname></ulink>">, +, +++ b/pom.xml, + <releases>, + <updatePolicy>interval:10080</updatePolicy>, + </releases>, +++ b/src/docbook/custom.dtd, +<!ENTITY ChannelEvent "<ulink url='&API;channel/ChannelEvent.html'><interfacename>ChannelEvent</interfacename></ulink>">, +<!-- Types in the channel.socket package -->, +, +<!ENTITY ServerSocketChannel "<ulink url='&API;channel/socket/ServerSocketChannel.html'><classname>ServerSocketChannel</classname></ulink>">, +, +++ b/src/docbook/module/start.xml, + <literal>"all"</literal>., + &ChannelFactory; factory =, + new &NioServerSocketChannelFactory;<co id="example.discard2.co1" />(, + &ServerBootstrap; bootstrap = new &ServerBootstrap;<co id="example.discard2.co2" />(factory);, + pipeline.addLast("handler", handler);<co id="example.discard2.co3" />, + bootstrap.setOption("child.tcpNoDelay", true);<co id="example.discard2.co4" />, + bootstrap.bind(new InetSocketAddress(8080));<co id="example.discard2.co5" />, +
[+++ b/pom.xml, + <version>1.2.4.GA</version>, +]
[+++ b/pom.xml, + <source>1.6</source>, + <target>1.6</target>]
[+++ b/NOTICE.txt, +, +This product contains a modified version of Roland Kuhn's ASL2, +AbstractNodeQueue, which is based on Dmitriy Vyukov's non-intrusive MPSC queue., +It can be obtained at:, +, + * LICENSE:, + * license/LICENSE.abstractnodequeue.txt (Public Domain), + * HOMEPAGE:, + * https://github.com/akka/akka/blob/wip-2.2.3-for-scala-2.11/akka-actor/src/main/java/akka/dispatch/AbstractNodeQueue.java, +++ b/NOTICE.txt, +, +This product contains a modified version of Roland Kuhn's ASL2, +AbstractNodeQueue, which is based on Dmitriy Vyukov's non-intrusive MPSC queue., +It can be obtained at:, +, + * LICENSE:, + * license/LICENSE.abstractnodequeue.txt (Public Domain), + * HOMEPAGE:, + * https://github.com/akka/akka/blob/wip-2.2.3-for-scala-2.11/akka-actor/src/main/java/akka/dispatch/AbstractNodeQueue.java, +++ b/common/src/main/java/io/netty/util/internal/MpscLinkedQueue.java, +/*, + * Copyright 2014 The Netty Project, + *, +
[+++ /dev/null, +++ /dev/null, +++ b/example/src/main/java/io/netty/example/stdio/StdioLogger.java, +/*, + * Copyright 2011 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF
[+++ b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java, + request.release();]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + final int nextCnt = refCnt + 1;, +, + // Ensure we not resurrect (which means the refCnt was 0) and also that we encountered an overflow., + if (nextCnt <= 1) {, + if (refCntUpdater.compareAndSet(this, refCnt, nextCnt)) {, + final int nextCnt = refCnt + increment;, +, + // Ensure we not resurrect (which means the refCnt was 0) and also that we encountered an overflow., + if (nextCnt <= increment) {, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + final int nextCnt = refCnt + 1;, +, + // Ensure we not resurrect (which means the refCnt was 0)
[+++ b/buffer/src/main/java/io/netty/buffer/QueueBackedMessageBuf.java, + if (e == null) {, + throw new NullPointerException("e");, + }, +++ b/buffer/src/main/java/io/netty/buffer/QueueBackedMessageBuf.java, + if (e == null) {, + throw new NullPointerException("e");, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import io.netty.buffer.MessageBuf;, +import io.netty.channel.ChannelInboundByteHandler;, +import io.netty.channel.ChannelOutboundMessageHandler;, +import io.netty.channel.CombinedChannelDuplexHandler;, +public final class HttpClientCodec, + extends CombinedChannelDuplexHandler, + implements ChannelInboundByteHandler, ChannelOutboundMessageHandler<HttpObject> {, + private final Queue<HttpMethod> queue = new ArrayDeque<HttpMethod>();, + private volatile boolean done;, + public HttpClientCodec(int maxInitialLineLength, int maxHeaderSize, int maxChunkSize) {, + int maxInitialLineLength, int maxHeaderSize, int maxChunkSize, boolean failOnMissingResponse) {, + init(new Decoder(maxInitialLineLength, maxHeaderSize, maxChunkSize), new Encoder());, + private Decoder decoder() {, + return (Decoder) stateHandler();, +
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, + , + , + // Check if we exceeded the maximum size of 2gb if this is the case then , + // newCapacity == 0, + //, + // https://github.com/netty/netty/issues/258, + if (newCapacity == 0) {, + throw new IllegalStateException("Maximum size of 2gb exceeded");, + }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return
[+++ b/codec/src/test/java/io/netty/handler/codec/compression/AbstractDecoderTest.java, +import org.junit.After;, + @After, + public void destroyChannel() {, + if (channel != null) {, + channel.finishAndReleaseAll();, + channel = null;, + }, + }, +, +++ b/codec/src/test/java/io/netty/handler/codec/compression/AbstractDecoderTest.java, +import org.junit.After;, + @After, + public void destroyChannel() {, + if (channel != null) {, + channel.finishAndReleaseAll();, + channel = null;, + }, + }, +, +++ b/codec/src/test/java/io/netty/handler/codec/compression/AbstractEncoderTest.java, +import org.junit.After;, + @After, + public void destroyChannel() {, + if (channel != null) {, + channel.finishAndReleaseAll();, + channel = null;, + }, + }, +, +++ b/codec/src/test/java/io/netty/handler/codec/compression/AbstractDecoderTest.java, +import org.junit.After;, + @After, + public void destroyChannel() {, + if (channel !=
[+++ b/transport/src/main/java/io/netty/channel/ChannelBufferHolder.java, + return ctx.hasNextInboundMessageBuffer();, + return ctx.hasNextOutboundMessageBuffer();, + return ctx.hasNextInboundByteBuffer();, + return ctx.hasNextOutboundByteBuffer();, +++ b/transport/src/main/java/io/netty/channel/ChannelBufferHolder.java, + return ctx.hasNextInboundMessageBuffer();, + return ctx.hasNextOutboundMessageBuffer();, + return ctx.hasNextInboundByteBuffer();, + return ctx.hasNextOutboundByteBuffer();, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, + boolean hasNextInboundByteBuffer();, + boolean hasNextInboundMessageBuffer();, + boolean hasNextOutboundByteBuffer();, + boolean hasNextOutboundMessageBuffer();, +++ b/transport/src/main/java/io/netty/channel/ChannelBufferHolder.java, + return ctx.hasNextInboundMessageBuffer();, + return ctx.hasNextOutboundMessageBuffer();, + return ctx.hasNextInboundByteBuffer();, + return ctx.hasNextOutboundByteBuffer();, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, + boolean hasNextInboundByteBuffer();, + boolean hasNextInboundMessageBuffer();, + boolean hasNextOutboundByteBuffer();, + boolean hasNextOutboundMessageBuffer();, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + public boolean hasNextInboundByteBuffer() {, + return DefaultChannelPipeline.hasNextInboundByteBuffer(next);, + }, +, + @Override, + public boolean hasNextInboundMessageBuffer() {, + return DefaultChannelPipeline.hasNextInboundMessageBuffer(next);, + }, +, + @Override, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/DelegatingSslContext.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + private void validatePromise(ChannelPromise promise, boolean allowVoidPromise) {, +, + if (promise.getClass() == DefaultChannelPromise.class) {, + return;, + }, +, + if (!allowVoidPromise && promise instanceof VoidChannelPromise) {, +, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + private void validatePromise(ChannelPromise promise, boolean allowVoidPromise) {, +, + if (promise.getClass() == DefaultChannelPromise.class) {, + return;, + }, +, + if (!allowVoidPromise && promise instanceof VoidChannelPromise) {, +, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPromise.java]
[+++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollTest.java, +import io.netty.channel.unix.FileDescriptor;, +import java.util.concurrent.atomic.AtomicReference;, +, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertNull;, +import static org.junit.Assert.assertTrue;, +, + assertTrue(Epoll.isAvailable());, + }, +, + // Testcase for https://github.com/netty/netty/issues/8444, + @Test(timeout = 5000), + public void testEpollWaitWithTimeOutMinusOne() throws Exception {, + final EpollEventArray eventArray = new EpollEventArray(8);, + try {, + final FileDescriptor epoll = Native.newEpollCreate();, + final FileDescriptor timerFd = Native.newTimerFd();, + final FileDescriptor eventfd = Native.newEventFd();, + Native.epollCtlAdd(epoll.intValue(), timerFd.intValue(), Native.EPOLLIN);, + Native.epollCtlAdd(epoll.intValue(), eventfd.intValue(), Native.EPOLLIN);, +, + final AtomicReference<Throwable> ref = new AtomicReference<Throwable>();, + Thread t = new Thread(new Runnable() {, + @Override, + public void run() {, + try
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseStatus.java, + * 428 Precondition Required (RFC6585), + */, + public static final HttpResponseStatus PRECONDITION_REQUIRED = new HttpResponseStatus(428, "Precondition Required");, +, + /**, + * 429 Too Many Requests (RFC6585), + */, + public static final HttpResponseStatus TOO_MANY_REQUESTS = new HttpResponseStatus(429, "Too Many Requests");, +, + /**, + * 511 Network Authentication Required (RFC6585), + */, + public static final HttpResponseStatus NETWORK_AUTHENTICATION_REQUIRED =, + new HttpResponseStatus(511, "Network Authentication Required");, +, + /**, + case 428:, + return PRECONDITION_REQUIRED;, + case 429:, + return TOO_MANY_REQUESTS;, + case 431:, + return REQUEST_HEADER_FIELDS_TOO_LARGE;, + case 511:, + return NETWORK_AUTHENTICATION_REQUIRED;]
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, + private static final int[] OPENSSL_OP_NO_PROTOCOLS = {, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, + private static final int[] OPENSSL_OP_NO_PROTOCOLS = {, +++ b/handler/src/main/java/io/netty/handler/ssl/SslContext.java, + * @see #newHandler(ByteBufAllocator), + * @see #newHandler(ByteBufAllocator, String, int, boolean), +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, + private static final int[] OPENSSL_OP_NO_PROTOCOLS = {, +++ b/handler/src/main/java/io/netty/handler/ssl/SslContext.java, + * @see #newHandler(ByteBufAllocator), + * @see #newHandler(ByteBufAllocator, String, int, boolean), +++ b/handler/src/main/java/io/netty/handler/ssl/SslUtils.java, + static final String[] DEFAULT_CIPHER_SUITES = {]
[+++ b/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java, + if (index < 0 || index > buffer.capacity() - length) {, + throw new IndexOutOfBoundsException(buffer.toString() + ".slice(" + index + ", " + length + ')');]
[+++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, + checkIndex(index, src.remaining());, +++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, + checkIndex(index, src.remaining());, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, + checkIndex(index, src.remaining());, +++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, + checkIndex(index, src.remaining());, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, + checkIndex(index, src.remaining());, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +import io.netty.util.internal.EmptyArrays;, +, + buffer.writeBytes(ByteBuffer.wrap(EmptyArrays.EMPTY_BYTES));]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + void initHeadHandler() {, + // Must be called for the head handler., + HeadHandler h = (HeadHandler) handler;, + if (h.initialized) {, + return;, +, + assert executor().inEventLoop();, +, + h.init(this);, + h.initialized = true;, + outByteBuf = h.byteSink;, + outMsgBuf = h.msgSink;, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + void initHeadHandler() {, + // Must be called for the head handler., + HeadHandler h = (HeadHandler) handler;, + if (h.initialized) {, + return;, +, + assert executor().inEventLoop();, +, + h.init(this);, + h.initialized = true;, + outByteBuf = h.byteSink;, + outMsgBuf = h.msgSink;, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPipeline.java, + head.initHeadHandler();, + head.initHeadHandler();, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslCloseCompletionEvent.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, + if (contentEncoding != null) {, + // Content-Encoding was set, either as something specific or as the IDENTITY encoding, + // Therefore, we should NOT encode here, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, + if (contentEncoding != null) {, + // Content-Encoding was set, either as something specific or as the IDENTITY encoding, + // Therefore, we should NOT encode here, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java, + @Test, + public void testCustomEncoding() throws Exception {, + EmbeddedChannel ch = new EmbeddedChannel(new HttpContentCompressor());, + assertTrue(ch.writeInbound(newRequest()));, +, + FullHttpResponse res = new DefaultFullHttpResponse(, + HttpVersion.HTTP_1_1, HttpResponseStatus.OK,, + Unpooled.copiedBuffer("Hello, World", CharsetUtil.US_ASCII));, + int len = res.content().readableBytes();,
[+++ b/codec-http/pom.xml, +++ b/codec-http/pom.xml, +++ b/pom.xml, + <source>1.6</source>, + <target>1.6</target>, +++ b/codec-http/pom.xml, +++ b/pom.xml, + <source>1.6</source>, + <target>1.6</target>, +++ b/testsuite/pom.xml, +++ b/codec-http/pom.xml, +++ b/pom.xml, + <source>1.6</source>, + <target>1.6</target>, +++ b/testsuite/pom.xml, +++ b/transport/pom.xml]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +, + activeStreams.incrementPendingIterations();, + try {, + // modify the streamMap. Pass the iterator in so that remove will be called to prevent, + // concurrent modification exceptions., + } finally {, + activeStreams.decrementPendingIterations();, + }, + } catch (Throwable cause) {, + logger.error("Caught Throwable from listener onGoAwayReceived.", cause);, + } catch (Throwable cause) {, + logger.error("Caught Throwable from listener onGoAwaySent.", cause);, + * Remove a stream from the {@link #streamMap}., + * @param stream the stream to remove., + * @param itr an iterator that may be pointing to the stream during iteration and {@link Iterator#remove()}
[+++ b/common/src/main/java/io/netty/util/internal/MathUtil.java, + * Compares two {@code int} values., + *, + * @param x the first {@code int} to compare, + * @param y the second {@code int} to compare, + * @return the value {@code 0} if {@code x == y};, + * {@code -1} if {@code x < y}; and, + * {@code 1} if {@code x > y}, + */, + public static int compare(final int x, final int y) {, + // do not subtract for comparison, it could overflow, + return x < y ? -1 : (x > y ? 1 :
[+++ b/transport-sctp/pom.xml, + <name>Netty/Transport/SCTP</name>]
[+++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, +import io.netty.buffer.ChannelBuffer;, +import java.util.Queue;, + private static final String NEWLINE = String.format("%n");, + this(DEFAULT_LEVEL);, + this(clazz, DEFAULT_LEVEL);, + protected String format(ChannelHandlerContext ctx, String message) {, + protected String formatBuffer(String bufName, ChannelBufferHolder<Object> holder) {, + String content;, + int size;, + String elemType;, + if (holder.hasByteBuffer()) {, + ChannelBuffer buf = holder.byteBuffer();, + size = buf.readableBytes();, + elemType = "Byte";, + content = hexdump(buf);, + } else {, + Queue<Object> buf = holder.messageBuffer();, + content = buf.toString();, + size = buf.size();, + elemType = "Object";, + }, +, + return String.format("%s[%s](%d): %s", bufName, elemType, size, content);, + },
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + }]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + promise.setFailure(wrapStreamClosedError(cause));, + promise.setFailure(error);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + promise.setFailure(wrapStreamClosedError(cause));, + promise.setFailure(error);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexCodecTest.java, +import java.util.ArrayDeque;, +import java.util.Queue;, +import io.netty.util.ReferenceCountUtil;, + assertFalse(channelActive.get());, + assertFalse(channelActive.get());, + assertFalse(childChannel.isActive());, + }, +, + @Test, + public void channelClosedWhenWriteFutureFails() {, + final Queue<ChannelPromise> writePromises = new ArrayDeque<ChannelPromise>();, + writer = new Writer() {, + @Override, + void write(Object msg, ChannelPromise promise) {, + ReferenceCountUtil.release(msg);, + writePromises.offer(promise);, + }, + };, +, + LastInboundHandler inboundHandler = streamActiveAndWriteHeaders(inboundStream);, + Http2StreamChannel childChannel = (Http2StreamChannel) inboundHandler.channel();, +, + assertTrue(childChannel.isOpen());, + assertTrue(childChannel.isActive());, +, + final AtomicBoolean channelOpen = new AtomicBoolean(true);, + final AtomicBoolean channelActive = new AtomicBoolean(true);, +,
[+++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +import org.jboss.netty.logging.InternalLogger;, + private static InternalLogger logger = InternalLogger.getLogger(Bootstrap.class);, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +import org.jboss.netty.logging.InternalLogger;, + private static InternalLogger logger = InternalLogger.getLogger(Bootstrap.class);, +++ b/src/main/java/org/jboss/netty/channel/CompleteChannelFuture.java, +import org.jboss.netty.logging.InternalLogger;, + private static final InternalLogger logger =, + InternalLogger.getLogger(CompleteChannelFuture.class);, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +import org.jboss.netty.logging.InternalLogger;, + private static InternalLogger logger = InternalLogger.getLogger(Bootstrap.class);, +++ b/src/main/java/org/jboss/netty/channel/CompleteChannelFuture.java, +import org.jboss.netty.logging.InternalLogger;, + private static final InternalLogger logger =, + InternalLogger.getLogger(CompleteChannelFuture.class);, +++ b/src/main/java/org/jboss/netty/channel/DefaultChannelFuture.java, +import org.jboss.netty.logging.InternalLogger;, + private static final InternalLogger logger =, + InternalLogger.getLogger(DefaultChannelFuture.class);, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +import org.jboss.netty.logging.InternalLogger;, + private static InternalLogger logger = InternalLogger.getLogger(Bootstrap.class);, +++ b/src/main/java/org/jboss/netty/channel/CompleteChannelFuture.java, +import org.jboss.netty.logging.InternalLogger;, + private static final InternalLogger logger =, + InternalLogger.getLogger(CompleteChannelFuture.class);, +++ b/src/main/java/org/jboss/netty/channel/DefaultChannelFuture.java, +import
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, + for (Listener listener : listeners) {, + listener.onGoAwayReceived(lastKnownStream, errorCode, debugData);, + }, +, + Http2Stream[] streams = new Http2Stream[numActiveStreams()];, + for (Http2Stream stream : activeStreams().toArray(streams)) {, + if (stream.id() > lastKnownStream && localEndpoint.createdStreamId(stream.id())) {, + stream.close();, + for (Listener listener : listeners) {, + listener.onGoAwaySent(lastKnownStream, errorCode, debugData);, + }, +, + Http2Stream[] streams = new Http2Stream[numActiveStreams()];, + for (Http2Stream stream : activeStreams().toArray(streams)) {, + if (stream.id() > lastKnownStream && remoteEndpoint.createdStreamId(stream.id())) {, + stream.close();, + return lastKnownStream;, + if (goAwayReceived() && streamId > localEndpoint.lastKnownStream()) {, + throw connectionError(PROTOCOL_ERROR, "Cannot create stream %d since this endpoint has received
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +import io.netty.util.internal.StringUtil;, + throw new IllegalArgumentException("promise already done");, + throw new IllegalArgumentException(, + StringUtil.simpleClassName(VoidChannelPromise.class) + " not allowed for this operation");, + throw new IllegalArgumentException(, + StringUtil.simpleClassName(AbstractChannel.CloseFuture.class) + " not allowed in a pipeline");]
[+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java, + * A {@link MessageToByteEncoder} that encodes binary memcache messages into bytes., +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java, + * A {@link MessageToByteEncoder} that encodes binary memcache messages into bytes., +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java, + * @param opaque the opaque value to use., +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheEncoder.java, + * A {@link MessageToByteEncoder} that encodes binary memcache messages into bytes., +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheMessage.java, + * @param opaque the opaque value to use., +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheServerCodec.java, + * Use this codec if you need to implement a server that speaks the memcache binary protocol.]
[+++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, + * group that match the given {@link ChannelMatcher}. If the specified {@code message} is an instance of, + ChannelGroupFuture write(Object message, ChannelMatcher matcher);, + * Flush all {@link Channel}s in this group that match the given {@link ChannelMatcher}., + ChannelGroup flush(ChannelMatcher matcher);, + * {@link Channel}s that match the {@link ChannelMatcher}., + ChannelGroupFuture flushAndWrite(Object message, ChannelMatcher matcher);, + * that match the given {@link ChannelMatcher}., + ChannelGroupFuture disconnect(ChannelMatcher matcher);, + * Closes all {@link Channel}s in this group that match the given {@link ChannelMatcher}., + ChannelGroupFuture close(ChannelMatcher matcher);, + * {@link ChannelMatcher}. Please note that this
[+++ b/common/src/test/java/io/netty/util/HashedWheelTimerTest.java, + int maxTimeout = 2 * (tickDuration + timeout);]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + private final FileDescriptor fileDescriptor;, + fd.close();, + return fileDescriptor.isOpen();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + private final FileDescriptor fileDescriptor;, + fd.close();, + return fileDescriptor.isOpen();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java, + return fd().isOpen() &&, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + private final FileDescriptor fileDescriptor;, + fd.close();, + return fileDescriptor.isOpen();, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java, + return fd().isOpen() &&, +++ b/transport-native-epoll/src/main/java/io/netty/channel/unix/FileDescriptor.java, + private volatile boolean open = true;, + open = false;, + /**, + * Returns {@code true} if the file descriptor is open., + */, + public boolean isOpen() {, + return open;, + }, +, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + private final FileDescriptor fileDescriptor;, + fd.close();, + return fileDescriptor.isOpen();,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java, +import io.netty.util.NetUtil;, +import java.net.InetSocketAddress;, +, + /**, + * Formats the host string of an address so it can be used for computing an HTTP component, + * such as an URL or a Host header, + * @param addr the address, + * @return the formatted String, + */, + public static String formatHostnameForHttp(InetSocketAddress addr) {, + String hostString = NetUtil.getHostname(addr);, + if (NetUtil.isValidIpV6Address(hostString)) {, + if (!addr.isUnresolved()) {, + hostString = NetUtil.toAddressString(addr.getAddress());, + }, + return "[" + hostString + "]";, + }, + return hostString;, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java, +import io.netty.util.NetUtil;, +import java.net.InetSocketAddress;, +,
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, + , + , + // Check if we exceeded the maximum size of 2gb if this is the case then , + // newCapacity == 0, + //, + // https://github.com/netty/netty/issues/258, + if (newCapacity == 0) {, + throw
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, + boolean wasRead = read;, +, + channelReadComplete(ctx, wasRead);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, + boolean wasRead = read;, +, + channelReadComplete(ctx, wasRead);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + channelReadComplete(ctx, !decodeWasNull);, + }, +, + protected final void channelReadComplete(ChannelHandlerContext ctx, boolean readData) throws Exception {, + if (readData) {, + ctx.fireChannelReadComplete();, + } else if (!ctx.channel().config().isAutoRead()) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameCodec.java, + boolean wasRead = read;, +, + channelReadComplete(ctx, wasRead);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + channelReadComplete(ctx, !decodeWasNull);, + }, +, + protected final void channelReadComplete(ChannelHandlerContext ctx, boolean readData) throws Exception {, + if (readData) {, + ctx.fireChannelReadComplete();, + } else if (!ctx.channel().config().isAutoRead()) {, +++ b/codec/src/test/java/io/netty/handler/codec/ByteToMessageDecoderTest.java, +import java.util.concurrent.atomic.AtomicBoolean;,
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, + Native.epollWait(epollFd, events, 0);, + Collection<AbstractEpollChannel> channels = new ArrayList<AbstractEpollChannel>(ids.size());, + for (AbstractEpollChannel ch: ids.values()) {, + channels.add(ch);]
[+++ /dev/null, +++ /dev/null, +++ b/all/pom.xml, + <artifactId>maven-dependency-plugin</artifactId>, + <version>2.4</version>, + <id>unpack-dependencies</id>, + <phase>generate-resources</phase>, + <goal>unpack-dependencies</goal>, + <includes>io/netty/**</includes>, + <excludes>io/netty/example/**</excludes>, + <outputDirectory>${project.build.directory}/classes, + </outputDirectory>, + <overWriteReleases>false</overWriteReleases>, + <overWriteSnapshots>true</overWriteSnapshots>, + <!-- Disable animal sniffer -->, + <plugin>, + <groupId>org.codehaus.mojo</groupId>, + <artifactId>animal-sniffer-maven-plugin</artifactId>, + <executions>, + <execution>, + <id>default</id>, + <phase>none</phase>, + </execution>, + </executions>, + </plugin>, + <!-- Disable checkstyle -->, + <plugin>, + <artifactId>maven-checkstyle-plugin</artifactId>, + <executions>, + <execution>, + <id>check-style</id>, + <phase>none</phase>, + </execution>, + </executions>, + </plugin>, + <version>2.5</version>]
[+++ b/all/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.16.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java, + private final String charsetName;, + private final StringBuilder uriBuilder;, + private boolean hasParams;, + uriBuilder = new StringBuilder(uri);, + charsetName = charset.name();, + if (hasParams) {, + uriBuilder.append('&');, + } else {, + uriBuilder.append('?');, + hasParams = true;, + }, + appendComponent(name, charsetName, uriBuilder);, + if (value != null) {, + uriBuilder.append('=');, + appendComponent(value, charsetName, uriBuilder);, + }, + return uriBuilder.toString();, + private static void appendComponent(String s, String charset, StringBuilder sb) {, + s = URLEncoder.encode(s, charset);, + throw new UnsupportedCharsetException(charset);, + // replace all '+' with "%20", + int idx = s.indexOf('+');, + if (idx
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +import static io.netty.util.internal.ObjectUtil.checkPositive;, +import static io.netty.util.internal.StringUtil.EMPTY_STRING;, +, + checkNotNull(uri, "uri");, + checkNotNull(charset, "charset");, + checkPositive(maxParams, "maxParams");, + checkNotNull(uri, "uri");, + checkNotNull(charset, "charset");, + checkPositive(maxParams, "maxParams");, + rawPath = EMPTY_STRING;, + this.uri = uri.getRawQuery() == null? rawPath : rawPath + '?' + uri.getRawQuery();, + path = EMPTY_STRING;, + path = decodeComponent(pathEndPos < 0 ? uri : uri.substring(0, pathEndPos), charset);, + if (!addParam(params, decodeComponent(s.substring(pos, i), charset), EMPTY_STRING)) {, + addParam(params, decodeComponent(s.substring(pos, i), charset), EMPTY_STRING);, + return EMPTY_STRING;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +import static io.netty.util.internal.ObjectUtil.checkPositive;, +import static io.netty.util.internal.StringUtil.EMPTY_STRING;, +, + checkNotNull(uri, "uri");, + checkNotNull(charset, "charset");, +
[+++ b/pom.xml, + <module>testsuite-shading</module>, +++ b/pom.xml, + <module>testsuite-shading</module>, +++ b/testsuite-shading/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<!--, + ~ Copyright 2018 The Netty Project, + ~, + ~ The Netty Project licenses this file to you under the Apache License,, + ~ version 2.0 (the "License"); you may not use this file except in compliance, + ~ with the License. You may obtain a copy of the License at:, + ~, + ~ http://www.apache.org/licenses/LICENSE-2.0, + ~, + ~ Unless required by applicable law or agreed to in writing, software, + ~ distributed under the License is distributed on an "AS IS" BASIS,
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, + length = in.readShortLE();, + length = in.readUnsignedMediumLE();, + length = in.readIntLE();, + int offset = in.readShortLE();, + int offset = in.readIntLE();, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, + length = in.readShortLE();, + length = in.readUnsignedMediumLE();, + length = in.readIntLE();, + int offset = in.readShortLE();, + int offset = in.readIntLE();, +++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFrameDecoder.java, + final int chunkLength = in.getUnsignedMediumLE(idx + 1);, + int checksum = in.readIntLE();, + int checksum = in.readIntLE();, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, + length = in.readShortLE();, + length = in.readUnsignedMediumLE();, + length = in.readIntLE();, + int offset = in.readShortLE();, + int offset = in.readIntLE();, +++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFrameDecoder.java, + final int chunkLength =
[+++ b/all/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Beta2-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + @SuppressWarnings("deprecation"), + @Override, + public ByteBuf asReadOnly() {, + if (isReadOnly()) {, + return this;, + }, + return Unpooled.unmodifiableBuffer(this);, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + @SuppressWarnings("deprecation"), + @Override, + public ByteBuf asReadOnly() {, + if (isReadOnly()) {, + return this;, + }, + return Unpooled.unmodifiableBuffer(this);, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java, + public ByteBuf asReadOnly() {, + recordLeakNonRefCountingOperation(leak);, + return new AdvancedLeakAwareByteBuf(super.asReadOnly(), leak);, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + @SuppressWarnings("deprecation"), + @Override, + public ByteBuf asReadOnly() {, + if (isReadOnly()) {, + return this;, + }, + return Unpooled.unmodifiableBuffer(this);, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, + private State readHeaders(ByteBuf buffer) {, + private HttpChunkTrailer readTrailingHeaders(ByteBuf buffer) {, + private String readHeader(ByteBuf buffer) {, + private static String readLine(ByteBuf buffer, int maxLineLength) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, + private State readHeaders(ByteBuf buffer) {, + private HttpChunkTrailer readTrailingHeaders(ByteBuf buffer) {, + private String readHeader(ByteBuf buffer) {, + private static String readLine(ByteBuf buffer, int maxLineLength) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, + private WebSocketFrame decodeBinaryFrame(byte type, ByteBuf buffer) {, + private WebSocketFrame decodeTextFrame(ByteBuf buffer) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java, + private State readHeaders(ByteBuf buffer) {, + private HttpChunkTrailer readTrailingHeaders(ByteBuf buffer) {, + private String readHeader(ByteBuf buffer) {, + private static String readLine(ByteBuf
[+++ b/pom.xml, + <version>3.1.0.CR1</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.1.0.CR1</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.1.0.CR1</developerConnection>]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, +import io.netty.handler.codec.UnsupportedMessageTypeException;, +import io.netty.handler.codec.http.HttpServerUpgradeHandler.UpgradeEvent;, +import static io.netty.handler.codec.http2.Http2CodecUtil.isStreamIdValid;, + Http2FrameStream frameStream = frame.stream();, + // It is legit to send a WINDOW_UPDATE frame for the connection stream. The parent channel doesn't attempt, + // to set the Http2FrameStream so we assume if it is null the WINDOW_UPDATE is for the connection stream., + try {, + if (frameStream == null) {, + increaseInitialConnectionWindow(frame.windowSizeIncrement());, + } else {, + consumeBytes(frameStream.id(), frame.windowSizeIncrement());, + }, + promise.setSuccess();, + } catch (Throwable t) {, + promise.setFailure(t);, + }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, +import io.netty.handler.codec.UnsupportedMessageTypeException;, +import io.netty.handler.codec.http.HttpServerUpgradeHandler.UpgradeEvent;, +import static io.netty.handler.codec.http2.Http2CodecUtil.isStreamIdValid;, + Http2FrameStream frameStream = frame.stream();,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketServerExtension.java, + //TODO: after migrating to JDK 8 rename this to 'newResponseData()' and mark old as deprecated with default method]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + try {, + } finally {, + // Ensure the file descriptor is closed in all cases., + }, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + try {, + } finally {, + // Ensure the file descriptor is closed in all cases., + }, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + if (isActive()) {, + // If it is still active, we need to call epollInReady as otherwise we may miss to, + // read pending data from the underyling file descriptor., + // See https://github.com/netty/netty/issues/3709, + epollInReady();, + } else {, + }, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollChannel.java, + try {, + } finally {,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, + private final int maxFramePayloadLength;, + this(websocketPath, subprotocols, allowExtensions, 65536);, + }, +, + public WebSocketServerProtocolHandler(String websocketPath, String subprotocols,, + boolean allowExtensions, int maxFrameSize) {, + this.maxFramePayloadLength = maxFrameSize;, + new WebSocketServerProtocolHandshakeHandler(websocketPath, subprotocols,, + allowExtensions, maxFramePayloadLength));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, + private final int maxFramePayloadLength;, + this(websocketPath, subprotocols, allowExtensions, 65536);, + }, +, + public WebSocketServerProtocolHandler(String websocketPath, String subprotocols,, + boolean allowExtensions, int maxFrameSize) {, + this.maxFramePayloadLength = maxFrameSize;, + new WebSocketServerProtocolHandshakeHandler(websocketPath, subprotocols,, + allowExtensions, maxFramePayloadLength));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, + private final int maxFramePayloadSize;, + boolean allowExtensions, int maxFrameSize) {, + this.maxFramePayloadSize = maxFrameSize;, + getWebSocketLocation(ctx.pipeline(), req, websocketPath), subprotocols,, +
[+++ b/src/main/java/org/jboss/netty/container/microcontainer/NettyResourceFactory.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2009, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version., + *, +
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolver.java, +import io.netty.util.concurrent.EventExecutor;, + private void doResolveAllUncached(final String hostname,, + final DnsRecord[] additionals,, + final Promise<List<InetAddress>> promise,, + final DnsCache resolveCache) {, + // Call doResolveUncached0(...) in the EventLoop as we may need to submit multiple queries which would need, + // to submit multiple Runnable at the end if we are not already on the EventLoop., + EventExecutor executor = executor();, + if (executor.inEventLoop()) {, + doResolveAllUncached0(hostname, additionals, promise, resolveCache);, + } else {, + executor.execute(new Runnable() {, + @Override, + public void run() {, + doResolveAllUncached0(hostname, additionals, promise, resolveCache);, + }, + });, + }, +
[+++ b/microbench/pom.xml, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>${tcnative.artifactId}</artifactId>, + <classifier>${tcnative.classifier}</classifier>, + <optional>false</optional>, + </dependency>, +++ b/microbench/pom.xml, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>${tcnative.artifactId}</artifactId>, + <classifier>${tcnative.classifier}</classifier>, + <optional>false</optional>, + </dependency>, +++ b/microbench/src/main/java/io/netty/microbench/handler/ssl/AbstractSslEngineBenchmark.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/CookieUtil.java, + private static final BitSet VALID_COOKIE_NAME_OCTETS = validCookieNameOctets();, + // cookie-octet = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E, + BitSet bits = new BitSet();, + bits.set(0x21);, + for (int i = 0x23; i <= 0x2B; i++) {, + for (int i = 0x2D; i <= 0x3A; i++) {, + bits.set(i);, + }, + for (int i = 0x3C; i <= 0x5B; i++) {, + bits.set(i);, + }, + for (int i = 0x5D; i <= 0x7E; i++) {, + bits.set(i);, + }, + private static BitSet validCookieNameOctets() {, + BitSet bits = new BitSet();,
[+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/AbstractMemcacheObject.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, + !HttpHeaders.equalsIgnoreCase(HttpHeaders.Values.IDENTITY, contentEncoding)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, + !HttpHeaders.equalsIgnoreCase(HttpHeaders.Values.IDENTITY, contentEncoding)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, +class WebSocketServerProtocolHandshakeHandler extends ChannelInboundHandlerAdapter {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, + !HttpHeaders.equalsIgnoreCase(HttpHeaders.Values.IDENTITY, contentEncoding)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, +class WebSocketServerProtocolHandshakeHandler extends ChannelInboundHandlerAdapter {, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, + !HttpHeaders.equalsIgnoreCase(HttpHeaders.Values.IDENTITY, contentEncoding)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, +class WebSocketServerProtocolHandshakeHandler extends ChannelInboundHandlerAdapter {, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java, +++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, +@SuppressWarnings({ "StringConcatenationInsideStringBufferAppend", "StringBufferReplaceableByString" }), + ctx.fireChannelUnregistered();, + ctx.deregister(promise);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, + !HttpHeaders.equalsIgnoreCase(HttpHeaders.Values.IDENTITY, contentEncoding)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, +class WebSocketServerProtocolHandshakeHandler extends ChannelInboundHandlerAdapter {, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheClientCodec.java, +++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, +@SuppressWarnings({ "StringConcatenationInsideStringBufferAppend", "StringBufferReplaceableByString" }), + ctx.fireChannelUnregistered();, + ctx.deregister(promise);, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java, +public class ChunkedWriteHandler extends ChannelDuplexHandler {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, + !HttpHeaders.equalsIgnoreCase(HttpHeaders.Values.IDENTITY, contentEncoding)) {, +++
[+++ b/common/src/main/java/io/netty/util/internal/logging/FormattingTuple.java, +final class FormattingTuple {, + FormattingTuple(String message, Throwable throwable) {, +++ b/common/src/main/java/io/netty/util/internal/logging/FormattingTuple.java, +final class FormattingTuple {, + FormattingTuple(String message, Throwable throwable) {, +++ b/common/src/main/java/io/netty/util/internal/logging/MessageFormatter.java, +import java.util.HashSet;, +import java.util.Set;, + private static final String DELIM_STR = "{}";, + if (argArray == null || argArray.length == 0) {, + return new FormattingTuple(messagePattern, null);, + }, + int lastArrIdx = argArray.length - 1;, + Object lastEntry = argArray[lastArrIdx];, + Throwable throwable = lastEntry instanceof Throwable? (Throwable) lastEntry : null;, + return new FormattingTuple(null, throwable);, + int j = messagePattern.indexOf(DELIM_STR);, + // this is a simple string, + return new FormattingTuple(messagePattern,
[+++ b/example/src/main/java/io/netty/example/http2/helloworld/client/Http2Client.java, +import static io.netty.buffer.Unpooled.wrappedBuffer;, + responseHandler.put(streamId, channel.write(request), channel.newPromise());, + wrappedBuffer(URL2DATA.getBytes(CharsetUtil.UTF_8)));, + responseHandler.put(streamId, channel.write(request), channel.newPromise());, + channel.flush();, +++ b/example/src/main/java/io/netty/example/http2/helloworld/client/Http2Client.java, +import static io.netty.buffer.Unpooled.wrappedBuffer;, + responseHandler.put(streamId, channel.write(request), channel.newPromise());, + wrappedBuffer(URL2DATA.getBytes(CharsetUtil.UTF_8)));, + responseHandler.put(streamId, channel.write(request), channel.newPromise());, + channel.flush();, +++ b/example/src/main/java/io/netty/example/http2/helloworld/client/HttpResponseHandler.java, +import io.netty.util.internal.PlatformDependent;, +import java.util.Map;, + private Map<Integer, Entry<ChannelFuture, ChannelPromise>> streamidPromiseMap;, + // Use a concurrent map because we add and iterate from the main thread (just for the purposes of the example),, + // but Netty also does a get on the map when messages are received in a EventLoop thread., + streamidPromiseMap = PlatformDependent.newConcurrentHashMap();]
[+++ b/transport-native-kqueue/src/main/c/netty_kqueue_eventarray.c, +static void netty_kqueue_eventarray_evSet(JNIEnv* env, jclass clzz, jlong keventAddress, jint ident, jshort filter, jshort flags, jint fflags) {, + EV_SET((struct kevent*) keventAddress, ident, filter, flags, fflags, 0, NULL);, + { "evSet", "(JISSI)V", (void *) netty_kqueue_eventarray_evSet }, + fixed_method_table,, + fixed_method_table_size) != 0) {, +++ b/transport-native-kqueue/src/main/c/netty_kqueue_eventarray.c, +static void netty_kqueue_eventarray_evSet(JNIEnv* env, jclass clzz, jlong keventAddress, jint ident, jshort filter, jshort flags, jint fflags) {, + EV_SET((struct kevent*) keventAddress, ident, filter, flags, fflags, 0, NULL);, + { "evSet", "(JISSI)V", (void *) netty_kqueue_eventarray_evSet }, + fixed_method_table,, + fixed_method_table_size) != 0) {, +++ b/transport-native-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueChannel.java, +, + ((KQueueEventLoop) eventLoop()).add(this);, +, +++ b/transport-native-kqueue/src/main/c/netty_kqueue_eventarray.c, +static void
[+++ b/pom.xml, + <name>JBoss, by Red Hat</name>]
[+++ b/all/pom.xml, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-example</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + p.replaceAndForward(HttpResponseDecoder.class,, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + p.replaceAndForward(HttpResponseDecoder.class,, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java, + p.replaceAndForward(HttpResponseDecoder.class,, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + p.replaceAndForward(HttpResponseDecoder.class,, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java, + p.replaceAndForward(HttpResponseDecoder.class,, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + p.replaceAndForward(HttpResponseDecoder.class,, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + p.replaceAndForward(HttpResponseDecoder.class,, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java, + p.replaceAndForward(HttpResponseDecoder.class,, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + p.replaceAndForward(HttpResponseDecoder.class,, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java, + p.replaceAndForward(HttpResponseDecoder.class,, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + p.replaceAndForward(HttpResponseDecoder.class,, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java, + p.replaceAndForward(HttpResponseDecoder.class,, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + p.replaceAndForward(HttpResponseDecoder.class,, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java, + p.replaceAndForward(HttpResponseDecoder.class,, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, + p.replaceAndForward(HttpRequestDecoder.class, "wsdecoder",, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + p.replaceAndForward(HttpResponseDecoder.class,, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java, + p.replaceAndForward(HttpResponseDecoder.class,, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + p.replaceAndForward(HttpResponseDecoder.class,, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java, + p.replaceAndForward(HttpResponseDecoder.class,, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, + p.replaceAndForward(HttpRequestDecoder.class, "wsdecoder",, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java, + p.replaceAndForward(HttpRequestDecoder.class, "wsdecoder",, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + p.replaceAndForward(HttpResponseDecoder.class,, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java, + p.replaceAndForward(HttpResponseDecoder.class,, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + p.replaceAndForward(HttpResponseDecoder.class,,
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + copyAndCompose(alloc, cumulation, next);, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + copyAndCompose(alloc, cumulation, next);, +++ b/transport/src/main/java/io/netty/channel/AbstractCoalescingBufferQueue.java, +import static io.netty.util.ReferenceCountUtil.safeRelease;, +import static io.netty.util.internal.PlatformDependent.throwException;, + safeRelease(entryBuffer);, + safeRelease(toReturn);, + throwException(cause);, + safeRelease(next);, + throwException(cause);, + * Compose {@code cumulation} and {@code next} into a new {@link ByteBufAllocator#ioBuffer()}., + * @param alloc The allocator to use to allocate the new buffer., + * @param cumulation The current cumulation., + * @param next The next buffer., + * @return The result of {@code cumulation + next}., + */, + protected final ByteBuf copyAndCompose(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf next) {, + ByteBuf newCumulation = alloc.ioBuffer(cumulation.readableBytes() +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/CompressorHttp2ConnectionEncoder.java, + try {, + // Determine if compression is required and sanitize the headers., + EmbeddedChannel compressor = newCompressor(headers, endStream);, +, + // Write the headers and create the stream object., + ChannelFuture future = super.writeHeaders(ctx, streamId, headers, padding, endStream, promise);, +, + // After the stream object has been created, then attach the compressor as a property for data compression., + bindCompressorToStream(compressor, streamId);, +, + return future;, + } catch (Throwable e) {, + promise.tryFailure(e);, + }, + return promise;, + try {, + // Determine if compression is required and sanitize the headers., + EmbeddedChannel
[+++ b/codec/src/main/java/io/netty/handler/codec/DelimiterBasedFrameDecoder.java, + /** Set only when decoding with "\n" and "\r\n" as the delimiter. */, + private final LineBasedFrameDecoder lineBasedDecoder;, + this(maxFrameLength, stripDelimiter, failFast, new ByteBuf[] {, + delimiter.slice(delimiter.readerIndex(), delimiter.readableBytes())});, + } else if (isLineBased(delimiters) && !isSubclass()) {, + lineBasedDecoder = new LineBasedFrameDecoder(maxFrameLength, stripDelimiter, failFast);, + this.delimiters = null;, + } else {, + lineBasedDecoder = null;, + }, +, + /** Returns true if the delimiters are "\n" and "\r\n". */, + private static boolean isLineBased(final ByteBuf[] delimiters) {, + if (delimiters.length != 2) {, + return false;, + }, + ByteBuf a = delimiters[0];, + ByteBuf
[+++ b/all/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.11.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/pom.xml, + <argLine>-XX:+AggressiveOpts -XX:+UseFastAccessorMethods -XX:+OptimizeStringConcat -XX:+HeapDumpOnOutOfMemoryError</argLine>]
[+++ b/README.md, +- __3.2__ branch contains code for Netty 3.x, +++ b/README.md, +- __3.2__ branch contains code for Netty 3.x, +++ /dev/null, +++ b/README.md, +- __3.2__ branch contains code for Netty 3.x, +++ /dev/null, +++ b/all/pom.xml, + <id>clean-first</id>, + <includeGroupIds>${project.groupId}</includeGroupIds>, + <outputDirectory>${project.build.directory}/src</outputDirectory>, + <groupId>org.codehaus.mojo</groupId>, + <artifactId>build-helper-maven-plugin</artifactId>, + <version>1.7</version>, + <id>add-source</id>, + <phase>generate-sources</phase>, + <goal>add-source</goal>, + <sources>, + <source>target/src</source>, + </sources>, +, + <profiles>, + <profile>, + <id>full</id>, + <build>, + <plugins>, + <plugin>, + <artifactId>maven-jxr-plugin</artifactId>, + <version>2.2</version>, + <executions>, + <execution>, + <id>generate-xref</id>, + <phase>package</phase>, + <goals>, + <goal>jxr</goal>, + </goals>, + </execution>, + </executions>, + <configuration>, + <inputEncoding>UTF-8</inputEncoding>,
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + byte[] v = PlatformDependent.allocateUninitializedArray(length);, + byte[] tmp = PlatformDependent.allocateUninitializedArray(length);, + getBytes(buffer, tmp, 0, chunkLen, out, length);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + byte[] v = PlatformDependent.allocateUninitializedArray(length);, + byte[] tmp = PlatformDependent.allocateUninitializedArray(length);, + getBytes(buffer, tmp, 0, chunkLen, out, length);, +++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, +import io.netty.util.internal.PlatformDependent;, + byte[] tmp = PlatformDependent.allocateUninitializedArray(length);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + byte[] v = PlatformDependent.allocateUninitializedArray(length);, + byte[] tmp = PlatformDependent.allocateUninitializedArray(length);, + getBytes(buffer, tmp, 0, chunkLen, out, length);, +++ b/buffer/src/main/java/io/netty/buffer/PooledDirectByteBuf.java, +import io.netty.util.internal.PlatformDependent;, + byte[] tmp = PlatformDependent.allocateUninitializedArray(length);, +++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java, +import io.netty.util.internal.PlatformDependent;, + byte[] tmp = PlatformDependent.allocateUninitializedArray(length);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + byte[] v = PlatformDependent.allocateUninitializedArray(length);, + byte[] tmp = PlatformDependent.allocateUninitializedArray(length);, + getBytes(buffer, tmp,
[+++ b/all/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/example/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha2-SNAPSHOT</version>, +++ b/codec/pom.xml, +
[+++ b/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java, + ByteBuf duplicate = buffer.slice(adjustment, length);, + return buffer.slice(index + adjustment, length);, + //new SlicedByteBuf(buffer, index + adjustment, length);, +++ b/buffer/src/main/java/io/netty/buffer/SlicedByteBuf.java, + ByteBuf duplicate = buffer.slice(adjustment, length);, + return buffer.slice(index + adjustment, length);, + //new SlicedByteBuf(buffer, index + adjustment, length);, +++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, + return buf.unwrap();]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + p.replace(ctx.name(), "ws-decoder", newWebsocketDecoder());, + p.replace(ctx.name(),, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + p.replace(ctx.name(), "ws-decoder", newWebsocketDecoder());, + p.replace(ctx.name(),, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java, + ctx.pipeline().remove(this);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + p.replace(ctx.name(), "ws-decoder", newWebsocketDecoder());, + p.replace(ctx.name(),, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java, + ctx.pipeline().remove(this);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + p.replace(ctx.name(), "wsdecoder", newWebSocketEncoder());, + p.replace(ctx.name(), "wsdecoder", newWebsocketDecoder());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + p.replace(ctx.name(), "ws-decoder", newWebsocketDecoder());, + p.replace(ctx.name(),, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java, + ctx.pipeline().remove(this);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + p.replace(ctx.name(), "wsdecoder", newWebSocketEncoder());, + p.replace(ctx.name(), "wsdecoder", newWebsocketDecoder());, +++ b/example/src/main/java/io/netty/example/portunification/PortUnificationServerHandler.java, + p.remove(this);, + p.remove(this);, + p.remove(this);, + p.remove(this);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + p.replace(ctx.name(), "ws-decoder", newWebsocketDecoder());, + p.replace(ctx.name(),, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientProtocolHandshakeHandler.java, + ctx.pipeline().remove(this);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + p.replace(ctx.name(), "wsdecoder", newWebSocketEncoder());, + p.replace(ctx.name(), "wsdecoder", newWebsocketDecoder());, +++ b/example/src/main/java/io/netty/example/portunification/PortUnificationServerHandler.java, +
[+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java, + List<Integer> minMax = (List<Integer>) value;, + setInitMaxStreams(SctpStandardSocketOptions.InitMaxStreams.create(minMax.get(0), minMax.get(1)));]
[+++ b/handler/src/main/java/io/netty/handler/stream/ChunkedFile.java, + ByteBuf buf = ctx.alloc().heapBuffer(chunkSize);, + boolean release = true;, + try {, + file.readFully(buf.array(), buf.arrayOffset(), chunkSize);, + buf.writerIndex(chunkSize);, + release = false;, + return buf;, + } finally {, + if (release) {, + buf.release();, + }, + }]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java, + } else if (type == (byte) 0xff) {, +++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java, + } else if (type == (byte) 0xff) {, +++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java, + (byte) 0xff, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59, +++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java, + } else if (type == (byte) 0xff) {, +++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java, + (byte) 0xff, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59, +++ b/codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedDecoderTest.java, + (byte) 0xff, 0x06, 0x00, 0x00, 's', 'n', 'e', 't', 't', 'y', + (byte) 0xff, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,, + (byte) 0xff, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,,
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + if (handler instanceof ChannelInboundHandler) {, + ((ChannelInboundHandler) handler).freeInboundBuffer(this);, + }, + if (handler instanceof ChannelOutboundHandler) {, + ((ChannelOutboundHandler) handler).freeOutboundBuffer(this);, + }]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + ChannelFutureListener closeListener = Http2ConnectionHandler.this.closeListener;, + // This method could be called multiple times, + // and we don't want to notify the closeListener multiple times, + Http2ConnectionHandler.this.closeListener = null;, + public ChannelFuture writeRstStream(final ChannelHandlerContext ctx, int streamId, long errorCode,, + final ChannelPromise promise) {, + final Http2Stream stream = connection().stream(streamId);, + if (stream == null || stream.isResetSent()) {, + // Don't write a RST_STREAM frame if we are not aware of the stream, or if we have already written one., + return promise.setSuccess();, + }, +, + // Synchronously set the resetSent flag to prevent any
[+++ b/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java, + @Test, + @Test]
[+++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSocketTcpMd5Test.java, +import io.netty.channel.ChannelOption;, + .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 1000)]
[+++ b/common/src/main/java/io/netty/util/internal/InternalThreadLocalMap.java, + final int stringBuilderCapacity = 1024;, + if (stringBuilder == null) {, + stringBuilder = new StringBuilder(stringBuilderCapacity);, + if (stringBuilder.capacity() > stringBuilderCapacity) {, + stringBuilder.setLength(stringBuilderCapacity);, + stringBuilder.trimToSize();, + stringBuilder.setLength(0);, + }, + return stringBuilder;]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java, + private static boolean looksLikeZlib(short cmf_flg) {, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java, + private static boolean looksLikeZlib(short cmf_flg) {, +++ b/codec/src/test/java/io/netty/handler/codec/compression/ZlibTest.java, + try {, + } finally {, + // close channel to prevent any leak even on exception, + chDecoderGZip.close();, + }, + EmbeddedChannel chDecoderZlib = new EmbeddedChannel(createDecoder(decoderWrapper));, + try {, + } finally {, + // close channels in all cases to guard against leak when exception was thrown, + chEncoder.close();, + chDecoderZlib.close();, + }, + EmbeddedChannel chDecoderZlib = new EmbeddedChannel(createDecoder(decoderWrapper));, + try {, + boolean decoded = false;, + decoded = true;, + assertFalse("should decode nothing", decoded);,
[+++ b/codec/src/main/java/io/netty/handler/codec/bytes/ByteArrayEncoder.java, +import io.netty.buffer.BufType;, +import io.netty.channel.ChannelOutboundMessageHandlerAdapter;, +import io.netty.channel.ChannelPromise;, +public class ByteArrayEncoder extends ChannelOutboundMessageHandlerAdapter<byte[]> {, + private final BufType nextBufferType;, +, + public ByteArrayEncoder(BufType nextBufferType) {, + if (nextBufferType == null) {, + throw new NullPointerException("nextBufferType");, + }, + this.nextBufferType = nextBufferType;, + public void flush(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {, + MessageBuf<Object> in = ctx.outboundMessageBuffer();, + MessageBuf<Object> msgOut = ctx.nextOutboundMessageBuffer();, + ByteBuf byteOut = ctx.nextOutboundByteBuffer();, +, + try {, + for (;;) {, + Object m = in.poll();, + if (m == null) {, + break;, + if (!(m instanceof byte[])) {, + msgOut.add(m);, + continue;, +, +
[+++ b/transport-native-unix-common/src/main/c/netty_unix_errors.c, +static jint netty_unix_errors_errnoENOENT(JNIEnv* env, jclass clazz) {, + return ENOENT;, +}, +, + { "errnoENOENT", "()I", (void *) netty_unix_errors_errnoENOENT },, +++ b/transport-native-unix-common/src/main/c/netty_unix_errors.c, +static jint netty_unix_errors_errnoENOENT(JNIEnv* env, jclass clazz) {, + return ENOENT;, +}, +, + { "errnoENOENT", "()I", (void *) netty_unix_errors_errnoENOENT },, +++ b/transport-native-unix-common/src/main/java/io/netty/channel/unix/Errors.java, +import java.io.FileNotFoundException;, + public static final int ERRNO_ENOENT_NEGATIVE = -errnoENOENT();, + if (err == ERRNO_ENOENT_NEGATIVE) {, + throw new FileNotFoundException();, + }, + if (err == ERRNO_ENOENT_NEGATIVE) {, + throw new FileNotFoundException();, + }, +++ b/transport-native-unix-common/src/main/c/netty_unix_errors.c, +static jint netty_unix_errors_errnoENOENT(JNIEnv* env, jclass clazz) {, + return ENOENT;, +}, +, + { "errnoENOENT", "()I", (void
[+++ b/transport-native-unix-common-tests/src/main/java/io/netty/channel/unix/tests/SocketTest.java, + // IPTOS_THROUGHPUT, + final int value = 0x08;, +++ b/transport-native-unix-common-tests/src/main/java/io/netty/channel/unix/tests/SocketTest.java, + // IPTOS_THROUGHPUT, + final int value = 0x08;, +++ b/transport-native-unix-common/src/main/c/netty_unix_socket.c, + if (socketType == AF_INET6) {, + // This call will put an exception on the stack to be processed once the JNI calls completes if, + // setsockopt failed and return a negative value., + int rc = netty_unix_socket_setOption(env, fd, IPPROTO_IPV6, IPV6_TCLASS, &optval, sizeof(optval));, + if (rc >= 0) {, + // Previous call successful now try to set also for ipv4, + if (netty_unix_socket_setOption0(fd, IPPROTO_IP, IP_TOS, &optval, sizeof(optval)) == -1) {, + if
[+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + boolean sameThread = initThread == Thread.currentThread();, + initThread = null;, + chunk.arena.free(chunk, handle, maxLength, sameThread);]
[+++ b/handler/src/main/java/io/netty/handler/ssl/Java8SslParametersUtils.java, +import java.util.Collections;, + if (names == null || names.isEmpty()) {, + return Collections.emptyList();, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/Java8SslParametersUtils.java, +import java.util.Collections;, + if (names == null || names.isEmpty()) {, + return Collections.emptyList();, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + private static final boolean SUPPORTS_HOSTNAME_VALIDATION;, + boolean supportsHostNameValidation = false;, + SSL.setHostNameValidation(ssl, 0, "netty.io");, + supportsHostNameValidation = true;, + } catch (Throwable ignore) {, + logger.debug("Hostname Verification not supported.");, + }, + try {, + SUPPORTS_HOSTNAME_VALIDATION = supportsHostNameValidation;, + SUPPORTS_HOSTNAME_VALIDATION = false;, + /**, + * Returns {@code true} if <a href="https://wiki.openssl.org/index.php/Hostname_validation">Hostname Validation</a>, + * is supported when using OpenSSL., + */,
[+++ b/transport/src/main/java/io/netty/channel/socket/DefaultDatagramChannelConfig.java, + } else if (option == UDP_RECEIVE_PACKET_SIZE) {, + setReceivePacketSize((Integer) value);]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoopGroup.java, + {, + // Ensure JNI is initialized by the time this class is loaded., +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoopGroup.java, + {, + // Ensure JNI is initialized by the time this class is loaded., +++ b/transport-native-kqueue/src/main/java/io/netty/channel/kqueue/KQueueEventLoopGroup.java, + {]
[+++ b/transport/src/main/java/io/netty/channel/ChannelFlushPromiseNotifier.java, + if (newWriteCounter >= 0x8000000000L) {, +++ b/transport/src/main/java/io/netty/channel/ChannelFlushPromiseNotifier.java, + if (newWriteCounter >= 0x8000000000L) {, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPromise.java, + * The first 24 bits of this field represents the number of waiters waiting for this promise with await*()., + * The other 40 bits of this field represents the flushCheckpoint used by ChannelFlushPromiseNotifier and, + * AbstractChannel.Unsafe.flush()., + */, + incWaiters();, + decWaiters();, + incWaiters();, + decWaiters();, + incWaiters();, + decWaiters();, + if (hasWaiters()) {, + return flushCheckpoint & 0x000000FFFFFFFFFFL;, + if ((checkpoint & 0xFFFFFF0000000000L) != 0) {, + throw new IllegalStateException("flushCheckpoint overflow");, + }, + flushCheckpoint = flushCheckpoint
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + // Set the content length to 0., + res.headers().remove(Names.TRANSFER_ENCODING);, + res.headers().set(Names.CONTENT_LENGTH, "0");, + final Result result = beginEncode(res, acceptEncoding);, + // As an unchunked response, + res.headers().remove(Names.TRANSFER_ENCODING);, + res.headers().set(Names.CONTENT_LENGTH, ((ByteBufHolder) res).data().readableBytes());, + // As a chunked response, + res.headers().remove(Names.CONTENT_LENGTH);, + res.headers().set(Names.TRANSFER_ENCODING, Values.CHUNKED);, +, + if (newContent.isReadable()) {, + return new HttpContent[] {, + new DefaultHttpContent(newContent), new DefaultLastHttpContent(lastProduct)};, + } else {, + return new HttpContent[] { new DefaultLastHttpContent(lastProduct) };, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + // Set the content length to 0., + res.headers().remove(Names.TRANSFER_ENCODING);, + res.headers().set(Names.CONTENT_LENGTH, "0");, + final Result result = beginEncode(res, acceptEncoding);, + // As
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractPooledByteBufTest.java, +, + // Testing if the writerIndex and readerIndex are correct when allocate and also after we reset the mark., + assertEquals(0, buffer.writerIndex());, + assertEquals(0, buffer.readerIndex());, + buffer.resetReaderIndex();, + buffer.resetWriterIndex();, +++ b/buffer/src/test/java/io/netty/buffer/AbstractPooledByteBufTest.java, +, + // Testing if the writerIndex and readerIndex are correct when allocate and also after we reset the mark., + assertEquals(0, buffer.writerIndex());, + assertEquals(0, buffer.readerIndex());, + buffer.resetReaderIndex();, + buffer.resetWriterIndex();, +++ b/common/src/main/java/io/netty/util/Recycler.java, +import static io.netty.util.internal.MathUtil.findNextPositivePowerOfTwo;, + private static final int RATIO;, + LINK_CAPACITY = findNextPositivePowerOfTwo(, + // By default we allow one push to a Recycler for each 8th try on handles that were never
[+++ b/all/pom.xml, + -link https://developers.google.com/protocol-buffers/docs/reference/java/, +++ b/all/pom.xml, + -link https://developers.google.com/protocol-buffers/docs/reference/java/, +++ b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32FrameDecoder.java, + * <a href="https://developers.google.com/protocol-buffers/docs/encoding#varints">Base, +++ b/all/pom.xml, + -link https://developers.google.com/protocol-buffers/docs/reference/java/, +++ b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufVarint32FrameDecoder.java, + * <a href="https://developers.google.com/protocol-buffers/docs/encoding#varints">Base, +++ b/codec/src/main/java/io/netty/handler/codec/protobuf/package-info.java, + * <a href="https://github.com/google/protobuf">Google Protocol Buffers</a>]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/handler/timeout/ChannelReadTimeoutException.java, +/*, + * JBoss, Home of Professional Open Source,
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + * Synchronize on the head. This is needed as {@link PoolChunk#allocateSubpage(int)} and, + * {@link PoolChunk#free(long)} may modify the doubly linked list as well., +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + * Synchronize on the head. This is needed as {@link PoolChunk#allocateSubpage(int)} and, + * {@link PoolChunk#free(long)} may modify the doubly linked list as well., +++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, + // Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it., + // This is need as we may add it back and so alter the linked-list structure., + PoolSubpage<T> head = arena.findSubpagePoolHead(normCapacity);, + synchronized
[+++ b/pom.xml, + <excludes>, + <exclude>**/package-info.java</exclude>, + </excludes>]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + /**, + * Encode the given {@link CharBuffer} using the given {@link Charset} into a new {@link ByteBuf} which, + * is allocated via the {@link ByteBufAllocator}., + */, + public static ByteBuf encodeString(ByteBufAllocator alloc, CharBuffer src, Charset charset) {, + int length = (int) ((double) src.remaining() * encoder.maxBytesPerChar());, + boolean release = true;, + final ByteBuf dst = alloc.buffer(length);, + final ByteBuffer dstBuf = dst.internalNioBuffer(0, length);, + final int pos = dstBuf.position();, + CoderResult cr = encoder.encode(src, dstBuf, true);, + cr = encoder.flush(dstBuf);, + dst.writerIndex(dst.writerIndex() + (dstBuf.position() - pos));, + release = false;, + return
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpClientCodecTest.java, + sb.config().group().shutdownGracefully();, + sb.config().childGroup().shutdownGracefully();, + cb.config().group().shutdownGracefully();, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpClientCodecTest.java, + sb.config().group().shutdownGracefully();, + sb.config().childGroup().shutdownGracefully();, + cb.config().group().shutdownGracefully();, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DataCompressionHttp2Test.java, + Future<?> serverGroup = sb.config().group().shutdownGracefully(0, 0, MILLISECONDS);, + Future<?> serverChildGroup = sb.config().childGroup().shutdownGracefully(0, 0, MILLISECONDS);, + Future<?> clientGroup = cb.config().group().shutdownGracefully(0, 0, MILLISECONDS);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpClientCodecTest.java, + sb.config().group().shutdownGracefully();, + sb.config().childGroup().shutdownGracefully();, + cb.config().group().shutdownGracefully();, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DataCompressionHttp2Test.java, + Future<?> serverGroup = sb.config().group().shutdownGracefully(0, 0, MILLISECONDS);, + Future<?> serverChildGroup = sb.config().childGroup().shutdownGracefully(0, 0, MILLISECONDS);, + Future<?> clientGroup = cb.config().group().shutdownGracefully(0, 0, MILLISECONDS);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionRoundtripTest.java, + Future<?> serverGroup = sb.config().group().shutdownGracefully(0, 0, MILLISECONDS);, + Future<?> serverChildGroup = sb.config().childGroup().shutdownGracefully(0, 0, MILLISECONDS);, + Future<?> clientGroup = cb.config().group().shutdownGracefully(0, 0, MILLISECONDS);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpClientCodecTest.java, + sb.config().group().shutdownGracefully();, + sb.config().childGroup().shutdownGracefully();,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequest.java, + * Gets the {@link HttpMethod} of this {@link HttpRequest}., + *, + * @return The {@link HttpMethod} of this {@link HttpRequest}, + * Sets the {@link HttpMethod} of this {@link HttpRequest}., + *, + * @param The {@link HttpMethod} to set, + * Gets the requested URI (or alternatively, path), + *, + * @return The URI being requested, + * Sets the URI (or alternatively, path) being requested., + *, + * @param uri The URI being requested]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpConversionUtil.java, +import io.netty.handler.codec.UnsupportedValueConverter;, +import java.util.List;, +import java.util.Set;, +import static io.netty.util.ByteProcessor.FIND_COMMA;, + private static CharSequenceMap<AsciiString> toLowercaseMap(List<String> values) {, + UnsupportedValueConverter<AsciiString> valueConverter = UnsupportedValueConverter.<AsciiString>instance();, + CharSequenceMap<AsciiString> result =, + new CharSequenceMap<AsciiString>(true, valueConverter, values.size());, +, + // we iterate because the underlying list is probably a linked list, + for (CharSequence value : values) {, + AsciiString lowerCased = AsciiString.of(value).toLowerCase();, + try {, + int index = lowerCased.forEachByte(FIND_COMMA);, + if (index != -1) {, + int start = 0;, + do {, + result.add(lowerCased.subSequence(start, index, false).trim(), EMPTY_STRING);, + start = index + 1;, + } while (start < lowerCased.length() &&, +
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelId.java, +import java.lang.reflect.Method;, + String value;, + try {, + ClassLoader loader = ClassLoader.getSystemClassLoader();, + Class<?> mgmtFactoryType = Class.forName("java.lang.management.ManagementFactory", true, loader);, + Class<?> runtimeMxBeanType = Class.forName("java.lang.management.RuntimeMXBean", true, loader);, +, + Method getRuntimeMXBean = mgmtFactoryType.getMethod("getRuntimeMXBean", null);, + Object bean = getRuntimeMXBean.invoke(null, null);, + Method getName = runtimeMxBeanType.getDeclaredMethod("getName");, + value = (String) getName.invoke(bean, null);, + } catch (Exception e) {, + logger.debug("Could not invoke ManagementFactory.getRuntimeMXBean().getName(); Android?", e);, + value = "";, + }, +, + // value did not contain an integer., + logger.warn("Failed to find the current process ID from '{}'; using a random value: {}", value, pid);]
[+++ b/pom.xml, + <version>2.2.2</version>]
[+++ b/pom.xml, + <version>3.1.3.GA</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.1.3.GA</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.1.3.GA</developerConnection>]
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, +import java.nio.ByteOrder;, + private static final boolean BIG_ENDIAN = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN;, +, + } else if (BIG_ENDIAN) {, + } else {, + return (short) (getByte(address + 1) << 8 | getByte(address) & 0xff);, + } else if (BIG_ENDIAN) {, + } else {, + return getByte(address + 3) << 24 |, + (getByte(address + 2) & 0xff) << 16 |, + (getByte(address + 1) & 0xff) << 8 |, + getByte(address) & 0xff;, + } else if (BIG_ENDIAN) {, + } else {, + return (long) getByte(address + 7) << 56 |, + ((long) getByte(address
[+++ b/handler/src/main/java/io/netty/handler/stream/ChunkedFile.java, + public long startOffset() {, + public long endOffset() {, + public long currentOffset() {, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedFile.java, + public long startOffset() {, + public long endOffset() {, + public long currentOffset() {, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedNioFile.java, + public long startOffset() {, + public long endOffset() {, + public long currentOffset() {, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedFile.java, + public long startOffset() {, + public long endOffset() {, + public long currentOffset() {, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedNioFile.java, + public long startOffset() {, + public long endOffset() {, + public long currentOffset() {, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedNioStream.java, + public long transferredBytes() {, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedFile.java, + public long startOffset() {,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ServerCookieEncoder.java, + * Note that multiple cookies must be sent as separate "Set-Cookie" headers., + * {@link HttpResponse} res = ...;, + * res.setHeader("Set-Cookie", {@link ServerCookieEncoder}.encode("JSESSIONID", "1234"));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/ServerCookieEncoder.java, + * Note that multiple cookies must be sent as separate "Set-Cookie" headers., + * {@link HttpResponse} res = ...;, + * res.setHeader("Set-Cookie", {@link ServerCookieEncoder}.encode("JSESSIONID", "1234"));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/ServerCookieEncoder.java, +import io.netty.handler.codec.http.HttpResponse;, + * Note that multiple cookies must be sent as separate "Set-Cookie" headers., + * {@link HttpResponse} res = ...;, + * res.setHeader("Set-Cookie", {@link ServerCookieEncoder}.encode("JSESSIONID", "1234"));]
[+++ b/NOTICE.txt, + * license/LICENSE.jsr166y.txt (Public Domain)]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import io.netty.buffer.ByteBuf;, +import org.apache.tomcat.jni.Buffer;, + static long memoryAddress(ByteBuf buf) {, + assert buf.isDirect();, + return buf.hasMemoryAddress() ? buf.memoryAddress() : Buffer.address(buf.nioBuffer());, + }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import io.netty.buffer.ByteBuf;, +import org.apache.tomcat.jni.Buffer;, + static long memoryAddress(ByteBuf buf) {, + assert buf.isDirect();, + return buf.hasMemoryAddress() ? buf.memoryAddress() : Buffer.address(buf.nioBuffer());, + }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + if (SSL.writeToBIO(bio, OpenSsl.memoryAddress(buffer), readable) != readable) {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import io.netty.buffer.ByteBuf;, +import org.apache.tomcat.jni.Buffer;, + static long memoryAddress(ByteBuf buf) {, + assert buf.isDirect();, + return buf.hasMemoryAddress() ? buf.memoryAddress() : Buffer.address(buf.nioBuffer());, + }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + if (SSL.writeToBIO(bio, OpenSsl.memoryAddress(buffer), readable) != readable) {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +import static io.netty.handler.ssl.OpenSsl.memoryAddress;]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + } else if (msg instanceof Http2UnknownFrame) {, + Http2UnknownFrame unknownFrame = (Http2UnknownFrame) msg;, + encoder().writeFrame(ctx, unknownFrame.frameType(), unknownFrame.stream().id(),, + unknownFrame.flags(), unknownFrame.content(), promise);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + } else if (msg instanceof Http2UnknownFrame) {, + Http2UnknownFrame unknownFrame = (Http2UnknownFrame) msg;, + encoder().writeFrame(ctx, unknownFrame.frameType(), unknownFrame.stream().id(),, + unknownFrame.flags(), unknownFrame.content(), promise);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameCodecTest.java, + public void writeUnknownFrame() {, + final Http2FrameStream stream = frameCodec.newStream();, +, + ByteBuf buffer = Unpooled.buffer().writeByte(1);, + DefaultHttp2UnknownFrame unknownFrame = new DefaultHttp2UnknownFrame(, + (byte) 20, new Http2Flags().ack(true), buffer);, + unknownFrame.stream(stream);, + channel.write(unknownFrame);, +, + verify(frameWriter).writeFrame(eq(http2HandlerCtx), eq(unknownFrame.frameType()),, + eq(unknownFrame.stream().id()), eq(unknownFrame.flags()), eq(buffer), any(ChannelPromise.class));, + }, +, + @Test]
[+++ b/src/main/java/org/jboss/netty/channel/ChannelFutureAggregator.java, +/*, + * Copyright 2009 Red Hat, Inc., + *, + * Red Hat licenses this file to you under the Apache License, version 2.0, + * (the "License"); you may not use this file except in compliance with the, + * License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or
[+++ b/common/src/main/java/io/netty/util/DomainNameMapping.java, + unmodifiableMap = map != null ? Collections.unmodifiableMap(map), + : null;]
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +import io.netty.util.internal.RecyclableArrayList;, + RecyclableArrayList out = RecyclableArrayList.newInstance();, + RecyclableArrayList out = RecyclableArrayList.newInstance();, + protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, RecyclableArrayList out) {, + * @param out the {@link List} to which decoded messages should be added, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +import io.netty.util.internal.RecyclableArrayList;, + RecyclableArrayList out = RecyclableArrayList.newInstance();, + RecyclableArrayList out = RecyclableArrayList.newInstance();, + protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, RecyclableArrayList out) {, + * @param out the {@link List} to which decoded messages should be added, +++ /dev/null, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +import io.netty.util.internal.RecyclableArrayList;, + RecyclableArrayList out = RecyclableArrayList.newInstance();, + RecyclableArrayList out = RecyclableArrayList.newInstance();, + protected void callDecode(ChannelHandlerContext ctx, ByteBuf in,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + if (file != null && file.exists()) {, + file = null;, + if (file == null) {, + throw new IOException("No file defined so cannot be renamed");, + }]
[+++ b/all/pom.xml, + <version>4.1.15.Final</version>, +++ b/all/pom.xml, + <version>4.1.15.Final</version>, +++ b/bom/pom.xml, + <version>4.1.15.Final</version>, + <tag>netty-4.1.15.Final</tag>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, +++ b/all/pom.xml, + <version>4.1.15.Final</version>, +++ b/bom/pom.xml, + <version>4.1.15.Final</version>, + <tag>netty-4.1.15.Final</tag>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, + <version>4.1.15.Final</version>, +
[+++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, +import io.netty.handler.logging.LoggingHandler;, +import io.netty.logging.InternalLogLevel;, + ssc.pipeline().addLast("logger", new LoggingHandler(InternalLogLevel.INFO));, + s.pipeline().addLast("logger", new LoggingHandler(InternalLogLevel.INFO));, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, +import io.netty.handler.logging.LoggingHandler;, +import io.netty.logging.InternalLogLevel;, + ssc.pipeline().addLast("logger", new LoggingHandler(InternalLogLevel.INFO));, + s.pipeline().addLast("logger", new LoggingHandler(InternalLogLevel.INFO));, +++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, +import io.netty.channel.ChannelBufferHolder;, +import io.netty.channel.ChannelBufferHolders;, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelHandlerAdapter;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelInboundHandlerContext;, +import io.netty.channel.ChannelOutboundHandlerContext;, +import java.net.SocketAddress;, +, +public class LoggingHandler extends ChannelHandlerAdapter<Object, Object> {, + protected String message(ChannelHandlerContext ctx, String message) {, + String chStr = ctx.channel().toString();, + StringBuilder buf = new StringBuilder(chStr.length() + message.length() + 1);, + buf.append(chStr);, + buf.append(' ');, + buf.append(message);, + return buf.toString();, + }, +, + @Override, + public ChannelBufferHolder<Object> newOutboundBuffer(, + ChannelOutboundHandlerContext<Object> ctx)
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/HttpToHttp2ConnectionHandlerTest.java, + private static final int WAIT_TIME_SECONDS = 5;]
[+++ b/src/main/java/org/jboss/netty/channel/UpstreamChannelNotificationEvent.java, +package org.jboss.netty.channel;, +/*, + * Copyright 2009 Red Hat, Inc., + *, + * Red Hat licenses this file to you under the Apache License, version 2.0, + * (the "License"); you may not use this file except in compliance with the, + * License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + //, + // That said we will set dataSize and padding to 0 in the write(...) method if we cleared the queue, + // because of an error., + if (queue.isEmpty()) {, + // When the queue is empty it means we did clear it because of an error(...) call, + // (as otherwise we will have at least 1 entry in there), which will happen either when called, + // explicit or when the write itself fails. In this case just set dataSize and padding to 0, + // which will signal back that the
[+++ b/README.md, +[The 'master' branch](https://github.com/netty/netty/tree/master) is where the development of the latest major version lives on. The development of all other versions takes place in each branch whose name is identical to `<majorVersion>.<minorVersion>`. For example, the development of 3.9 and 4.0 resides in [the branch '3.9'](https://github.com/netty/netty/tree/3.9) and [the branch '4.0'](https://github.com/netty/netty/tree/4.0) respectively., +, +++ b/README.md, +[The 'master' branch](https://github.com/netty/netty/tree/master) is where the development of the latest major version lives on. The development of all other versions takes place in each branch whose name is identical to `<majorVersion>.<minorVersion>`. For example, the development of 3.9 and 4.0 resides in [the branch '3.9'](https://github.com/netty/netty/tree/3.9) and
[+++ b/pom.xml, + <compilerArguments>, + <Xlint:unchecked/>, + <Xlint:deprecation/>, + </compilerArguments>]
[+++ b/codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java, + if (state == ST_DECODING_ARRAY_STREAM) {, + insideString = false;, + openBraces = 1;, + }, +++ b/codec/src/main/java/io/netty/handler/codec/json/JsonObjectDecoder.java, + if (state == ST_DECODING_ARRAY_STREAM) {, + insideString = false;, + openBraces = 1;, + }, +++ b/codec/src/test/java/io/netty/handler/codec/json/JsonObjectDecoderTest.java, + public void testStreamJsonArrayOverMultipleWrites1() {, + String[] array = new String[] {, + " [{\"test",, + "case\" : \"\\\"}]Escaped dou\\\"ble quotes \\\" in JSON str\\\"ing\"",, + " }\n\n , ",, + "{\"testcase\" : \"Streaming string me",, + "ssage\"} ] ", + };, + String[] result = new String[] {, + "{\"testcase\" : \"\\\"}]Escaped dou\\\"ble quotes \\\" in JSON str\\\"ing\" }",, +
[+++ b/README.md, +- __3__ branch contains code for Netty 3.x, +++ b/README.md, +- __3__ branch contains code for Netty 3.x, +++ b/all/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/README.md, +- __3__ branch contains code for Netty 3.x, +++ b/all/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/README.md, +- __3__ branch contains code for Netty 3.x, +++ b/all/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-handler</artifactId>, + <version>${project.version}</version>, + </dependency>, +++ b/README.md, +- __3__ branch contains code for Netty 3.x, +++ b/all/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha5-SNAPSHOT</version>, + <dependency>, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + * Copyright 2013 The Netty Project, + byte ID_flags = buffer.getByte(buffer.readerIndex());, + int ID = getUnsignedMedium(buffer, buffer.readerIndex() + 1);, + int value = getSignedInt(buffer, buffer.readerIndex() + 4);, + buffer.skipBytes(8);, + if (buffer.readableBytes() < 8) {, + statusCode = getSignedInt(buffer, buffer.readerIndex() + 4);, + buffer.skipBytes(8);, + if (buffer.readableBytes() < 10) {, + if (buffer.readableBytes() < 4) {, + return length >= 10;, + return length >= 4;, + return length == 8;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + * Copyright 2013 The Netty Project, + byte ID_flags = buffer.getByte(buffer.readerIndex());, + int ID = getUnsignedMedium(buffer, buffer.readerIndex() + 1);, + int value
[+++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +, + @Override, + public ByteBuf setZero(int index, int length) {, + UnsafeByteBufUtil.setZero(this, addr(index), index, length);, + return this;, + }, +, + @Override, + public ByteBuf writeZero(int length) {, + ensureWritable(length);, + int wIndex = writerIndex;, + setZero(wIndex, length);, + writerIndex = wIndex + length;, + return this;, + }, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +, + @Override, + public ByteBuf setZero(int index, int length) {, + UnsafeByteBufUtil.setZero(this, addr(index), index, length);, + return this;, + }, +, + @Override, + public ByteBuf writeZero(int length) {, + ensureWritable(length);, + int wIndex = writerIndex;, + setZero(wIndex, length);, + writerIndex = wIndex
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, + || statusCode >= 1015 && statusCode <= 2999) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, + || statusCode >= 1015 && statusCode <= 2999) {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoderTest.java, +import io.netty.buffer.ByteBuf;, +import io.netty.buffer.UnpooledByteBufAllocator;, +import io.netty.channel.Channel;, +import static org.junit.Assert.*;, +import java.util.ArrayList;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Set;, +, +, + @Test, + public void supportIanaStatusCodes() throws Exception {, + Set<Integer> forbiddenIanaCodes = new HashSet<Integer>();, + forbiddenIanaCodes.add(1004);, + forbiddenIanaCodes.add(1005);, + forbiddenIanaCodes.add(1006);, + Set<Integer> validIanaCodes = new HashSet<Integer>();, + for (int i = 1000; i < 1015; i++) {, + validIanaCodes.add(i);, + }, + validIanaCodes.removeAll(forbiddenIanaCodes);, +, + ChannelHandlerContext ctx = Mockito.mock(ChannelHandlerContext.class);, + Mockito.when(ctx.alloc()).thenReturn(UnpooledByteBufAllocator.DEFAULT);, +, +
[+++ b/all/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.13.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/transport/src/main/java/io/netty/channel/Channel.java, +import java.io.IOException;, +import java.net.InetSocketAddress;, +import java.net.SocketAddress;, +import java.nio.channels.NotYetConnectedException;, +import java.nio.channels.SelectionKey;, +, + EventLoop eventLoop();, +, +, + ChannelFuture deregister();, + void deregister(ChannelFuture future);, +, + Unsafe unsafe();, +, + public interface Unsafe {, + void setEventLoop(EventLoop eventLoop);, + void clearEventLoop();, + java.nio.channels.Channel ch();, +, + void bind(SocketAddress local) throws IOException;, + void connect(SocketAddress remote) throws IOException;, + boolean finishConnect() throws IOException;, + boolean read() throws IOException;, + boolean write() throws IOException;, + void unbind() throws IOException;, + void disconnect() throws IOException;, + void close() throws IOException;, + }, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +import java.io.IOException;, +import java.net.InetSocketAddress;, +import java.net.SocketAddress;, +import
[+++ b/buffer/src/main/java/io/netty/buffer/PoolSubpage.java, +, + if (numAvail != maxNumElems) {, + // Subpage not in use (numAvail == maxNumElems), + if (prev == next) {, + // Do not remove if this subpage is the only one left in the pool., + return true;, + }, +, + // Remove this subpage from the pool if there are other subpages left in the pool.]
[+++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopServerHandler.java, + FullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, CONTINUE);]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +import static java.lang.Math.min;, +, + connection.local().maxActiveStreams((int) min(maxConcurrentStreams, Integer.MAX_VALUE));, + outboundHeaderTable.maxHeaderTableSize((int) min(headerTableSize, Integer.MAX_VALUE));, + int queuedData = queue.readableBytes();, + if (!endOfStream && (queuedData == 0 || allowedBytes == 0)) {, +, + // Determine how much data to write., + int writeableData = min(queuedData, allowedBytes);, + ChannelPromise writePromise = ctx.newPromise().addListener(this);, + // Determine how much padding to write., + int writeablePadding = min(allowedBytes - writeableData, padding);, +, + // Write the frame(s)., +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, +import static java.lang.Math.min;, +, + connection.local().maxActiveStreams((int) min(maxConcurrentStreams, Integer.MAX_VALUE));, + outboundHeaderTable.maxHeaderTableSize((int) min(headerTableSize, Integer.MAX_VALUE));, + int queuedData = queue.readableBytes();, + if (!endOfStream && (queuedData == 0
[+++ /dev/null, +++ /dev/null, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +#include "netty_unix_filedescriptor.h", +#include "netty_unix_socket.h", +#include "netty_unix_errors.h", +// TCP_FASTOPEN is defined in linux 3.7. We define this here so older kernels can compile., + if (netty_unix_errors_JNI_OnLoad(env) == JNI_ERR) {, + if (netty_unix_filedescriptor_JNI_OnLoad(env) == JNI_ERR) {, + if (netty_unix_socket_JNI_OnLoad(env) == JNI_ERR) {, + netty_unix_errors_throwRuntimeException(env, "failed to get field ID: DefaultFileRegion.file");, + netty_unix_errors_throwRuntimeException(env, "failed to get field ID: DefaultFileRegion.transfered");, + netty_unix_errors_throwRuntimeException(env, "failed to get field ID: FileChannelImpl.fd");, + netty_unix_errors_throwRuntimeException(env, "failed to get field ID: FileDescriptor.fd");, + netty_unix_errors_throwRuntimeException(env, "failed to get field ID: NativeDatagramPacket.addr");, + netty_unix_errors_throwRuntimeException(env, "failed to get field ID: NativeDatagramPacket.scopeId");, + netty_unix_errors_throwRuntimeException(env, "failed to get
[+++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, + short dd = (short) (d << BYTE_LENGTH | d);, + id <<= 1;, + id ^= 1;, + assert value == d && (id & initial) == 1 << d : String.format("val = %d, id & initial = %d, d = %d",, + memoryMap[id] = (short) (memoryMap[id] & UPPER_BYTE_MASK | val);, + private static int log2(int val) {, + return 1 << log2ChunkSize - depth(id);, + int shift = id ^ 1 << depth(id);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java, + if (version == null) {, + throw new NullPointerException("version");, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java, + if (version == null) {, + throw new NullPointerException("version");, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpRequest.java, + if (method == null) {, + throw new NullPointerException("method");, + }, + if (uri == null) {, + throw new NullPointerException("method");, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java, + if (version == null) {, + throw new NullPointerException("version");, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpRequest.java, + if (method == null) {, + throw new NullPointerException("method");, + }, + if (uri == null) {, + throw new NullPointerException("method");, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpResponse.java, + if (status
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import java.util.Collections;, + // Use SNI if peerHost was specified and a valid hostname, + if (clientMode && SslUtils.isValidHostNameForSNI(peerHost)) {, + sniHostNames = Collections.singletonList(peerHost);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import java.util.Collections;, + // Use SNI if peerHost was specified and a valid hostname, + if (clientMode && SslUtils.isValidHostNameForSNI(peerHost)) {, + sniHostNames = Collections.singletonList(peerHost);, +++ b/handler/src/main/java/io/netty/handler/ssl/SslUtils.java, +import io.netty.util.NetUtil;, + /**, + * Validate that the given hostname can be used in SNI extension., + */, + static boolean isValidHostNameForSNI(String hostname) {, + return hostname != null &&, + hostname.indexOf('.') > 0 &&, + !hostname.endsWith(".") &&, + !NetUtil.isValidIpV4Address(hostname) &&, + !NetUtil.isValidIpV6Address(hostname);, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + // We return the bytes in consumeBytes() once the stream channel consumed the bytes., +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + // We return the bytes in consumeBytes() once the stream channel consumed the bytes., +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ServerUpgradeCodec.java, +import io.netty.channel.ChannelHandlerAdapter;, + /**, + * Creates the codec using a default name for the connection handler when adding to the, + * pipeline., + *, + * @param http2Codec the HTTP/2 frame handler., + * @param handlers the handlers that will handle the {@link Http2Frame}s., + */, + public Http2ServerUpgradeCodec(final Http2FrameCodec http2Codec, final ChannelHandler... handlers) {, + this(null, http2Codec.connectionHandler(), new ChannelHandlerAdapter() {,
[+++ /dev/null, +++ /dev/null, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, +import io.netty.util.Signal;, + static final Signal REPLAY = new Signal(ReplayingDecoder.class.getName() + ".REPLAY");, +, + } catch (Signal replay) {, + replay.expect(REPLAY);, + } catch (Signal replay) {, + replay.expect(REPLAY);, +++ /dev/null, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, +import io.netty.util.Signal;, + static final Signal REPLAY = new Signal(ReplayingDecoder.class.getName() + ".REPLAY");, +, + } catch (Signal replay) {, + replay.expect(REPLAY);, + } catch (Signal replay) {, + replay.expect(REPLAY);, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoderBuffer.java, +import io.netty.buffer.ChannelBuffer;, +import io.netty.buffer.ChannelBufferFactory;, +import io.netty.buffer.ChannelBufferIndexFinder;, +import io.netty.buffer.ChannelBuffers;, +import io.netty.util.Signal;, +, + private static final Signal REPLAY = ReplayingDecoder.REPLAY;, +++ /dev/null, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, +import io.netty.util.Signal;, + static final Signal
[+++ /dev/null, +++ /dev/null, +++ b/all/pom.xml, + <id>clean-first</id>, + <includeGroupIds>${project.groupId}</includeGroupIds>, + <outputDirectory>${project.build.directory}/src</outputDirectory>, + <groupId>org.codehaus.mojo</groupId>, + <artifactId>build-helper-maven-plugin</artifactId>, + <version>1.7</version>, + <id>add-source</id>, + <phase>generate-sources</phase>, + <goal>add-source</goal>, + <sources>, + <source>target/src</source>, + </sources>, +, + <profiles>, + <profile>, + <id>full</id>, + <build>, + <plugins>, + <plugin>, + <artifactId>maven-jxr-plugin</artifactId>, + <version>2.2</version>, + <executions>, + <execution>, + <id>generate-xref</id>, + <phase>package</phase>, + <goals>, + <goal>jxr</goal>, + </goals>, + </execution>, + </executions>, + <configuration>, + <inputEncoding>UTF-8</inputEncoding>, + <outputEncoding>UTF-8</outputEncoding>, + <linkJavadoc>true</linkJavadoc>, + <destDir>${project.build.directory}/xref</destDir>, + <javadocDir>${project.build.directory}/api</javadocDir>, + <docTitle>Netty Source Xref (${project.version})</docTitle>, + <windowTitle>Netty Source Xref (${project.version})</windowTitle>, + </configuration>, + </plugin>, + <plugin>, + <artifactId>maven-javadoc-plugin</artifactId>, + <version>2.8.1</version>, + <executions>,
[+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java, +++ b/transport/src/main/java/io/netty/channel/IncompleteFlushException.java, + * @deprecated, +@Deprecated]
[+++ b/example/pom.xml, +, + <!-- Needed on Java11 and later -->, + <dependency>, + <groupId>com.sun.activation</groupId>, + <artifactId>javax.activation</artifactId>, + </dependency>, +++ b/example/pom.xml, +, + <!-- Needed on Java11 and later -->, + <dependency>, + <groupId>com.sun.activation</groupId>, + <artifactId>javax.activation</artifactId>, + </dependency>, +++ b/pom.xml, + <!-- JDK11 -->, + <profile>, + <id>java11</id>, + <activation>, + <jdk>11</jdk>, + </activation>, + <properties>, + <!-- Not use alpn agent as Java11 supports alpn out of the box -->, + <argLine.alpnAgent />, + <forbiddenapis.skip>true</forbiddenapis.skip>, + <!-- Needed because of https://issues.apache.org/jira/browse/MENFORCER-275 -->, + <enforcer.plugin.version>3.0.0-M1</enforcer.plugin.version>, + <!-- 1.4.x does not work in Java10+ -->, + <jboss.marshalling.version>2.0.5.Final</jboss.marshalling.version>, + </properties>, +
[+++ b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + private short callDepth;, + private short flags;, +, + if (!isOutboundFreed()) {, + }, +, + if (!isInboundFreed()) {, + }, +, +, + freeAllIfRemoved();, + private boolean isInboundFreed() {, + return (flags & FLAG_FREED_INBOUND) != 0;, + }, +, + private boolean isOutboundFreed() {, + return (flags & FLAG_FREED_OUTBOUND) != 0;, + }, +, + private void freeAllIfRemoved() {, + if (callDepth != 0) {, + // Free only when the current context's handler is not being called., + return;, + }, +, + final int flags = this.flags;, + safeFree(inByteBuf);,
[+++ b/codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java, + // We skip everything in the buffer, we need to set the offset to 0 again., + offset = 0;, +++ b/codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java, + // We skip everything in the buffer, we need to set the offset to 0 again., + offset = 0;, +++ b/codec/src/test/java/io/netty/handler/codec/LineBasedFrameDecoderTest.java, +, + @Test, + public void testNotFailFast() throws Exception {, + EmbeddedChannel ch = new EmbeddedChannel(new LineBasedFrameDecoder(2, false, false));, + assertFalse(ch.writeInbound(wrappedBuffer(new byte[] { 0, 1, 2 })));, + assertFalse(ch.writeInbound(wrappedBuffer(new byte[]{ 3, 4 })));, + try {, + ch.writeInbound(wrappedBuffer(new byte[] { '\n' }));, + fail();, + } catch (TooLongFrameException expected) {, +
[+++ b/pom.xml, + <jetty.alpnAgent.version>2.0.7</jetty.alpnAgent.version>]
[+++ b/pom.xml, + <version>3.0.1.GA-SNAPSHOT</version>]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + while (out.maxCapacity() != out.writerIndex()) {]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/TextWebSocketFrame.java, + * Web Socket text frame, + * the content of the frame., + * the content of the frame., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/TextWebSocketFrame.java, + * Web Socket text frame, + * the content of the frame., + * the content of the frame., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/Utf8FrameValidator.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:,
[+++ b/transport/src/main/java/io/netty/channel/pool/SimpleChannelPool.java, + promise.tryFailure(cause);, + promise.tryFailure(future.cause());, + promise.tryFailure(cause);]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + session = new OpenSslSession(sessionContext);, + private long creationTime;, + OpenSslSession(OpenSslSessionContext sessionContext) {, + synchronized (OpenSslEngine.this) {, + if (creationTime == 0 && !isDestroyed()) {, + creationTime = SSL.getTime(ssl) * 1000L;, + }, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + session = new OpenSslSession(sessionContext);, + private long creationTime;, + OpenSslSession(OpenSslSessionContext sessionContext) {, + synchronized (OpenSslEngine.this) {, + if (creationTime == 0 && !isDestroyed()) {, + creationTime = SSL.getTime(ssl) * 1000L;, + }, + }, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, + public void testGetCreationTime() throws Exception {, + assumeTrue(OpenSsl.isAvailable());, + super.testGetCreationTime();, + }, +, + @Override, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + session = new OpenSslSession(sessionContext);,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java, +import io.netty.buffer.CompositeByteBuf;, + } else if (byteBuf instanceof CompositeByteBuf) {, + CompositeByteBuf cbb = (CompositeByteBuf) byteBuf;, + cbb.addComponent(buffer);, + cbb.writerIndex(cbb.writerIndex() + buffer.readableBytes());, + CompositeByteBuf cbb = compositeBuffer();, + cbb.addComponent(buffer);, + cbb.writerIndex(buffer.readableBytes());, + byteBuf = cbb;]
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + ByteBuf buf = cumulation;, + if (buf != null) {, + // Directly set this to null so we are sure we not access it in any other method here anymore., + cumulation = null;, +, +, + }, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + ByteBuf buf = cumulation;, + if (buf != null) {, + // Directly set this to null so we are sure we not access it in any other method here anymore., + cumulation = null;, +, +, + }, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + private final MessageBuf<Object> inMsgBuf;, + private final ByteBuf inByteBuf;, + } else {, + inByteBuf = null;, + inMsgBuf = null;, + inByteBuf = null;, + inMsgBuf = null;]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import java.util.Locale;, + private static final String HTTP_SCHEME_PREFIX = HttpScheme.HTTP + "://";, + private static final String HTTPS_SCHEME_PREFIX = HttpScheme.HTTPS + "://";, +, + static CharSequence websocketOriginValue(URI wsURL) {, + String scheme = wsURL.getScheme();, + final String schemePrefix;, + int port = wsURL.getPort();, + final int defaultPort;, + if (WebSocketScheme.WSS.name().contentEquals(scheme), + || HttpScheme.HTTPS.name().contentEquals(scheme), + || (scheme == null && port == WebSocketScheme.WSS.port())) {, +, + schemePrefix = HTTPS_SCHEME_PREFIX;, + defaultPort = WebSocketScheme.WSS.port();, + } else {, + schemePrefix = HTTP_SCHEME_PREFIX;, + defaultPort = WebSocketScheme.WS.port();, + }, +, + // Convert uri-host to lower case (by RFC 6454,
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2HuffmanAllocator.java, + int temp = i + k >>> 1;, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2HuffmanAllocator.java, + int temp = i + k >>> 1;, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java, + * @throws DecompressionException if failed to initialize zlib, + * @throws DecompressionException if failed to initialize zlib, + * @throws DecompressionException if failed to initialize zlib, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2HuffmanAllocator.java, + int temp = i + k >>> 1;, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java, + * @throws DecompressionException if failed to initialize zlib, + * @throws DecompressionException if failed to initialize zlib, + * @throws DecompressionException if failed to initialize zlib, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibEncoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2HuffmanAllocator.java, + int temp =
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioByteChannel.java, + private final class NioByteUnsafe extends AbstractNioUnsafe {, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioByteChannel.java, + private final class NioByteUnsafe extends AbstractNioUnsafe {, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioMessageChannel.java, + private final class NioMessageUnsafe extends AbstractNioUnsafe {, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioByteChannel.java, + private final class NioByteUnsafe extends AbstractNioUnsafe {, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioMessageChannel.java, + private final class NioMessageUnsafe extends AbstractNioUnsafe {, +++ b/transport/src/main/java/io/netty/channel/socket/oio/AbstractOioByteChannel.java, + protected OioByteUnsafe newUnsafe() {, + return new OioByteUnsafe();, + }, + private final class OioByteUnsafe extends AbstractOioUnsafe {, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioByteChannel.java, + private final class NioByteUnsafe extends AbstractNioUnsafe {, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioMessageChannel.java, + private final class NioMessageUnsafe extends AbstractNioUnsafe {, +++ b/transport/src/main/java/io/netty/channel/socket/oio/AbstractOioByteChannel.java, + protected OioByteUnsafe newUnsafe() {, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + /**, + * Returns the raw path string of the URI., + */, + public String rawPath() {, + return uri.substring(0, pathEndIdx());, + }, +, + /**, + * Returns raw query string of the URI., + */, + public String rawQuery() {, + int start = pathEndIdx() + 1;, + return start < uri.length() ? uri.substring(start) : EMPTY_STRING;, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + /**, + * Returns the raw path string of the URI., + */, + public String rawPath() {, + return uri.substring(0, pathEndIdx());, + }, +, + /**, + * Returns raw
[+++ b/docker/docker-compose.centos-6.112.yaml, + java_version : "openjdk@1.12.0-22", +++ b/docker/docker-compose.centos-6.112.yaml, + java_version : "openjdk@1.12.0-22", +++ b/docker/docker-compose.centos-7.112.yaml, + java_version : "openjdk@1.12.0-22", +++ b/docker/docker-compose.centos-6.112.yaml, + java_version : "openjdk@1.12.0-22", +++ b/docker/docker-compose.centos-7.112.yaml, + java_version : "openjdk@1.12.0-22", +++ b/pom.xml, + <!-- pax-exam does not work on latest Java12 EA 22 build -->, + <skipOsgiTestsuite>true</skipOsgiTestsuite>, +++ b/docker/docker-compose.centos-6.112.yaml, + java_version : "openjdk@1.12.0-22", +++ b/docker/docker-compose.centos-7.112.yaml, + java_version : "openjdk@1.12.0-22", +++ b/pom.xml, + <!-- pax-exam does not work on latest Java12 EA 22 build -->, + <skipOsgiTestsuite>true</skipOsgiTestsuite>, +++ b/testsuite-osgi/pom.xml, + <exam.version>4.13.0</exam.version>]
[+++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, + chStr.length() + 1 + eventName.length() + 2 + arg1Str.length() + 2 + arg2Str.length());, +++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, + chStr.length() + 1 + eventName.length() + 2 + arg1Str.length() + 2 + arg2Str.length());, +++ b/handler/src/test/java/io/netty/handler/logging/LoggingHandlerTest.java, + verify(appender).doAppend(argThat(new RegexLogMatcher(, + "^\\[id: 0xembedded, L:embedded - R:embedded\\] CONNECT: 0.0.0.0/0.0.0.0:80, 0.0.0.0/0.0.0.0:81$")));]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java, + return PATTERN.matcher(URLEncoder.encode(s, charset.name())).replaceAll("%20");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringEncoder.java, + return PATTERN.matcher(URLEncoder.encode(s, charset.name())).replaceAll("%20");, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/QueryStringEncoderTest.java, +, + @Test, + public void testWhitespaceEncoding() throws Exception {, + QueryStringEncoder e = new QueryStringEncoder("/foo");, + e.addParam("a", "b c");, + Assert.assertEquals("/foo?a=b%20c", e.toString());, + Assert.assertEquals(new URI("/foo?a=b%20c"), e.toUri());, + }]
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, + // The known defaults:, + // - Windows NT Server 4.0+: 200, + // - Linux and Mac OS X: 128, + int somaxconn = PlatformDependent.isWindows() ? 200 : 128;]
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + enum SizeClass {, + Tiny,, + Small,, + Normal, + }, +, + q100 = new PoolChunkList<T>(null, 100, Integer.MAX_VALUE);, + q075 = new PoolChunkList<T>(q100, 75, 100);, + q050 = new PoolChunkList<T>(q075, 50, 100);, + q025 = new PoolChunkList<T>(q050, 25, 75);, + q000 = new PoolChunkList<T>(q025, 1, 50);, + qInit = new PoolChunkList<T>(q000, Integer.MIN_VALUE, 25);, + q100.prevList(q075);, + q075.prevList(q050);, + q050.prevList(q025);, + q025.prevList(q000);, + q000.prevList(null);, + qInit.prevList(qInit);, + SizeClass sizeClass = sizeClass(normCapacity);, + PoolThreadCache cache = parent.threadCache();, + if (cache.add(this, chunk, handle, normCapacity, sizeClass)) {, + freeChunk(chunk, handle, sizeClass);, + }, + }, + private SizeClass sizeClass(int
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java, +import io.netty.buffer.ChannelBuffer;, +import io.netty.util.CharsetUtil;, + * Creates a new empty close frame with closing status code and reason text, + * , + * @param statusCode, + * Integer status code as per <a href="http://tools.ietf.org/html/rfc6455#section-7.4">RFC 6455</a>. For, + * example, <tt>1000</tt> indicates normal closure., + * @param reasonText, + * Reason text. Set to null if no text., + */, + public CloseWebSocketFrame(int statusCode, String reasonText) {, + this(true, 0, statusCode, reasonText);, + }, +, + /**, + * Creates a new close frame with no losing status code and no reason text, + this(finalFragment, rsv, null);,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + resetRequested = false;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + resetRequested = false;, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentDecoderTest.java, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelInboundHandlerAdapter;, +import java.util.concurrent.atomic.AtomicReference;, +import static org.hamcrest.CoreMatchers.instanceOf;, +import static org.hamcrest.CoreMatchers.is;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertNotNull;, +import static org.junit.Assert.assertNull;, +import static org.junit.Assert.assertThat;, +import static org.junit.Assert.assertTrue;, + public void testExpectContinueResetHttpObjectDecoder() {, + // request with header "Expect: 100-continue" must be replied with one "100 Continue" response, + // case 5: Test that HttpObjectDecoder correctly resets its internal state after a failed expectation., + HttpRequestDecoder decoder = new HttpRequestDecoder();, + final int maxBytes = 10;, + HttpObjectAggregator aggregator = new HttpObjectAggregator(maxBytes);, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java, + return headers.getHeader(name);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java, + return headers.getHeader(name);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeaderBlock.java, + return headers.getHeader(name);]
[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, +import io.netty.util.internal.ReusableIterator;, +import io.netty.util.internal.SharedResourceMisuseDetector;, +, +import java.util.concurrent.ConcurrentHashMap;, + wheel[i] = Collections.newSetFromMap(, + new ConcurrentHashMap<HashedWheelTimeout, Boolean>(16, 0.95f, 4));, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, +import io.netty.util.internal.ReusableIterator;, +import io.netty.util.internal.SharedResourceMisuseDetector;, +, +import java.util.concurrent.ConcurrentHashMap;, + wheel[i] = Collections.newSetFromMap(, + new ConcurrentHashMap<HashedWheelTimeout, Boolean>(16, 0.95f, 4));, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, +import io.netty.util.internal.ReusableIterator;, +import io.netty.util.internal.SharedResourceMisuseDetector;, +, +import java.util.concurrent.ConcurrentHashMap;, + wheel[i] = Collections.newSetFromMap(, + new ConcurrentHashMap<HashedWheelTimeout, Boolean>(16, 0.95f, 4));, +++ /dev/null, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, +import io.netty.util.internal.ReusableIterator;, +import io.netty.util.internal.SharedResourceMisuseDetector;, +, +import java.util.concurrent.ConcurrentHashMap;, + wheel[i] = Collections.newSetFromMap(, + new ConcurrentHashMap<HashedWheelTimeout, Boolean>(16, 0.95f, 4));, +++
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, + logger.debug("Failed to get SOMAXCONN", e);, +++ b/common/src/main/java/io/netty/util/NetUtil.java, + logger.debug("Failed to get SOMAXCONN", e);, +++ b/common/src/main/java/io/netty/util/Recycler.java, + if (end == LINK_CAPACITY && head.next != null) {, +++ b/common/src/main/java/io/netty/util/NetUtil.java, + logger.debug("Failed to get SOMAXCONN", e);, +++ b/common/src/main/java/io/netty/util/Recycler.java, + if (end == LINK_CAPACITY && head.next != null) {, +++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java, + * @return {@code true} if the write operation did add something to the inbound buffer, + * @return bufferReadable returns {@code true} if the write operation did add something to the outbound buffer]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/Utf8FrameValidator.java, + checkUTF8String(frame.content());, + checkUTF8String(frame.content());, + checkUTF8String(frame.content());, + private void checkUTF8String(ByteBuf buffer) {, + @Override, + public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {, + if (cause instanceof CorruptedFrameException && ctx.channel().isOpen()) {, + ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);, + }, + super.exceptionCaught(ctx, cause);, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/Utf8FrameValidator.java, + checkUTF8String(frame.content());, + checkUTF8String(frame.content());, + checkUTF8String(frame.content());, + private void checkUTF8String(ByteBuf buffer) {, + @Override, + public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {, + if (cause instanceof CorruptedFrameException && ctx.channel().isOpen()) {, + ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);, + }, + super.exceptionCaught(ctx, cause);, + }, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketUtf8FrameValidatorTest.java, +/*, + * Copyright 2019 The Netty Project, + *, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, + uri = new StringBuilder(uri).insert(index, SLASH).toString();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, + uri = new StringBuilder(uri).insert(index, SLASH).toString();, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpRequestEncoderTest.java, + buffer.release();, + buffer.release();, + }, +, + @Test, + public void testUriWithEmptyPath() throws Exception {, + HttpRequestEncoder encoder = new HttpRequestEncoder();, + ByteBuf buffer = Unpooled.buffer(64);, + encoder.encodeInitialLine(buffer, new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET,, + "http://localhost:9999/?p1=v1"));, + String req = buffer.toString(Charset.forName("US-ASCII"));, + assertEquals("GET http://localhost:9999/?p1=v1 HTTP/1.1\r\n", req);, + buffer.release();, + buffer.release();, + buffer.release();, + buffer.release();, + buffer.release();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, + uri = new StringBuilder(uri).insert(index, SLASH).toString();, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpRequestEncoderTest.java, + buffer.release();, + buffer.release();, + }, +, + @Test, + public void testUriWithEmptyPath() throws Exception {, +
[+++ b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java, + ChannelPipeline pipeline = ch.pipeline();, + ChannelHandler handler = handler();, + if (handler != null) {, + pipeline.addLast(handler);, + }, + pipeline.addLast(new ServerBootstrapAcceptor(, +++ b/transport/src/main/java/io/netty/bootstrap/ServerBootstrap.java, + ChannelPipeline pipeline = ch.pipeline();, + ChannelHandler handler = handler();, + if (handler != null) {, + pipeline.addLast(handler);, + }, + pipeline.addLast(new ServerBootstrapAcceptor(, +++ b/transport/src/test/java/io/netty/bootstrap/ServerBootstrapTest.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, + public void discardInboundReadBytes(ChannelHandlerContext ctx) throws Exception {, + // No need to discard anything because this handler will be replaced with something else very quickly., + }, +, + @Override, + public void freeInboundBuffer(ChannelHandlerContext ctx) throws Exception {, + ctx.inboundByteBuffer().free();, + }, +, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, + public void discardInboundReadBytes(ChannelHandlerContext ctx) throws Exception {, + // No need to discard anything because this handler will be replaced with something else very quickly., + }, +, + @Override, + public void freeInboundBuffer(ChannelHandlerContext ctx) throws Exception {, + ctx.inboundByteBuffer().free();, + }, +, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +
[+++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, + * @return itself, + */, + ChannelGroup write(Object message);, +, + /**, + * Flush all {@link Channel}s in this, + * group. Please note that this operation is asynchronous as, + * {@link Channel#flush()} is., + *, + ChannelGroupFuture flush();, +, + /**, + * Shortcut for calling {@link #write(Object)} and {@link #flush()}., + */, + ChannelGroupFuture flushAndWrite(Object message);, +++ b/transport/src/main/java/io/netty/channel/group/ChannelGroup.java, + * @return itself, + */, + ChannelGroup write(Object message);, +, + /**, + * Flush all {@link Channel}s in this, + * group. Please note that this operation is asynchronous as, + *
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + availableCipherSuites.addAll(AVAILABLE_OPENSSL_CIPHER_SUITES);, + availableCipherSuites.addAll(AVAILABLE_JAVA_CIPHER_SUITES);, +, + return isAvailable() ? SSL.version() : -1;, + return isAvailable() ? SSL.versionString() : null;]
[+++ b/transport/src/main/java/io/netty/channel/group/DefaultChannelGroup.java, + * Creates a new group with a generated name and the provided {@link EventExecutor} to notify the]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java, + checkKeyManagerFactory(keyManagerFactory);, + checkKeyManagerFactory(keyManagerFactory);, +, + private static void checkKeyManagerFactory(KeyManagerFactory keyManagerFactory) {, + if (keyManagerFactory != null) {, + throw new IllegalArgumentException(, + "KeyManagerFactory is currently not supported with OpenSslServerContext");, + }, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + out.add(toFullMessage(m));, +, + private static FullHttpMessage toFullMessage(HttpMessage msg) {, + if (msg instanceof FullHttpMessage) {, + return ((FullHttpMessage) msg).retain();, + }, +, + FullHttpMessage fullMsg;, + if (msg instanceof HttpRequest) {, + HttpRequest req = (HttpRequest) msg;, + fullMsg = new DefaultFullHttpRequest(, + req.getProtocolVersion(), req.getMethod(), req.getUri(), Unpooled.EMPTY_BUFFER, false);, + } else if (msg instanceof HttpResponse) {, + HttpResponse res = (HttpResponse) msg;, + fullMsg = new DefaultFullHttpResponse(, + res.getProtocolVersion(), res.getStatus(), Unpooled.EMPTY_BUFFER, false);, + } else {, + throw new IllegalStateException();, + }, +, + return fullMsg;, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + out.add(toFullMessage(m));, +, + private static
[+++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, + * @param <S>, +public abstract class ReplayingDecoder<O, S extends Enum<S>> extends StreamToMessageDecoder<O> {, + if (unfoldAndAdd(ctx, ctx.nextIn(), decodeLast(ctx, replayable))) {, + result = decode(ctx, replayable);]
[+++ b/all/pom.xml, + <!-- The example depends on (almost) all modules either directly or transitively -->, + <!-- The only module netty-example does NOT depend on -->, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-metrics-yammer</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + -link http://metrics.codahale.com/maven/apidocs/, + -group "Miscellaneous" io.netty.logging*:io.netty.util*:io.netty.monitor:io.netty.monitor.spi, + -group "Yammer monitoring support" io.netty.monitor.yammer*, +++ b/all/pom.xml, + <!-- The example depends on (almost) all modules either directly or transitively -->, + <!-- The only module netty-example does NOT depend on -->, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-metrics-yammer</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + -link http://metrics.codahale.com/maven/apidocs/, +
[+++ b/pom.xml, + <!-- Enforce JDK 1.8+ for compilation. -->, + <version>[1.8.0,)</version>]
[+++ /dev/null, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return readableBytes() > 0;, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, + , + , + // Check if we exceeded the maximum size of 2gb if this is the case then , + // newCapacity == 0, + //, + // https://github.com/netty/netty/issues/258,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + int readableBytes = actualReadableBytes();, + if (readableBytes > 0) {, + // Keep on consuming as otherwise we may trigger an DecoderException,, + // other handler will replace this codec with the upgraded protocol codec to, + // take the traffic over at some point then., + // See https://github.com/netty/netty/issues/2173, + out.add(buffer.readBytes(actualReadableBytes()));, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + int readableBytes = actualReadableBytes();, + if (readableBytes > 0) {, + // Keep on consuming as otherwise we may trigger an DecoderException,, + // other handler will replace this codec with the upgraded protocol codec to, + // take
[+++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor);, + return new NioServerSocketChannelFactory(executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor);, + return new NioServerSocketChannelFactory(executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioOioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor);, + return new NioServerSocketChannelFactory(executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioOioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/OioNioSocketSpdyEchoTest.java, + return new NioServerSocketChannelFactory(executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor);, + return new NioServerSocketChannelFactory(executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioOioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/OioNioSocketSpdyEchoTest.java, + return new NioServerSocketChannelFactory(executor);, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor);, + return new NioServerSocketChannelFactory(executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioOioSocketSpdyEchoTest.java, + return new NioClientSocketChannelFactory(executor);, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/OioNioSocketSpdyEchoTest.java, + return new NioServerSocketChannelFactory(executor);, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, +++
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/ClientCookieEncoder.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Native.java, + try {, + // First, try calling a side-effect free JNI method to see if the library was already, + // loaded by the application., + offsetofEpollData();, + } catch (UnsatisfiedLinkError ignore) {, + // The library was not previously loaded, load it now., + loadNativeLibrary();, +, +, + private static void loadNativeLibrary() {, + String name = SystemPropertyUtil.get("os.name").toLowerCase(Locale.UK).trim();, + if (!name.startsWith("linux")) {, + throw new IllegalStateException("Only supported on Linux");, + }, + NativeLibraryLoader.load(SystemPropertyUtil.get("io.netty.packagePrefix", "").replace('.', '-') +, + "netty-transport-native-epoll", PlatformDependent.getClassLoader(Native.class));, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, +import io.netty.util.CharsetUtil;, + buf.writeBytes(request.getMethod().toString().getBytes(CharsetUtil.US_ASCII));, + buf.writeBytes(request.getUri().getBytes(CharsetUtil.UTF_8));, + buf.writeBytes(request.getProtocolVersion().toString().getBytes(CharsetUtil.US_ASCII));]
[+++ b/testsuite-autobahn/pom.xml, + <version>0.1.5</version>]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +import io.netty.util.Recycler;, + executor.execute(WriteTask.newInstance(next, msg, promise));, +, + static final class WriteTask implements Runnable {, + private DefaultChannelHandlerContext ctx;, + private Object msg;, + private ChannelPromise promise;, +, + private static final Recycler<WriteTask> RECYCLER = new Recycler<WriteTask>() {, + @Override, + protected WriteTask newObject(Handle handle) {, + return new WriteTask(handle);, + }, + };, +, + private static WriteTask newInstance(DefaultChannelHandlerContext ctx, Object msg, ChannelPromise promise) {, + WriteTask task = RECYCLER.get();, + task.ctx = ctx;, + task.msg = msg;, + task.promise = promise;, + return task;, + }, +, + private final Recycler.Handle handle;, +, + private
[+++ b/pom.xml, + <!-- Common test dependencies -->, + <dependency>, + <groupId>junit</groupId>, + <artifactId>junit</artifactId>, + <version>4.11</version>, + <scope>test</scope>, + </dependency>, + <dependency>, + <groupId>org.easymock</groupId>, + <artifactId>easymock</artifactId>, + <version>3.2</version>, + <scope>test</scope>, + </dependency>, + <dependency>, + <groupId>org.easymock</groupId>, + <artifactId>easymockclassextension</artifactId>, + <version>3.2</version>, + <scope>test</scope>, + </dependency>, + <dependency>, + <groupId>org.jmock</groupId>, + <artifactId>jmock-junit4</artifactId>, + <version>2.6.0</version>, + <scope>test</scope>, + </dependency>, + <dependency>, + <groupId>ch.qos.logback</groupId>, + <artifactId>logback-classic</artifactId>, + <version>1.0.13</version>, + <scope>test</scope>, + </dependency>, +, +++ b/pom.xml, + <!-- Common test dependencies -->, + <dependency>, + <groupId>junit</groupId>, + <artifactId>junit</artifactId>, + <version>4.11</version>, + <scope>test</scope>, + </dependency>, + <dependency>, + <groupId>org.easymock</groupId>, + <artifactId>easymock</artifactId>, + <version>3.2</version>, + <scope>test</scope>,
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT void Java_io_netty_channel_epoll_Native_setTcpUserTimeout(JNIEnv* env, jclass clazz, jint fd, jint optval) {, + setOption(env, fd, IPPROTO_TCP, TCP_USER_TIMEOUT, &optval, sizeof(optval));, +}, +, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_getTcpUserTimeout(JNIEnv* env, jclass clazz, jint fd) {, + int optval;, + if (getOption(env, fd, IPPROTO_TCP, TCP_USER_TIMEOUT, &optval, sizeof(optval)) == -1) {, + return -1;, + }, + return optval;, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT void Java_io_netty_channel_epoll_Native_setTcpUserTimeout(JNIEnv* env, jclass clazz, jint fd, jint optval) {, + setOption(env, fd, IPPROTO_TCP, TCP_USER_TIMEOUT, &optval, sizeof(optval));, +}, +, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_getTcpUserTimeout(JNIEnv* env, jclass clazz, jint fd) {, + int optval;, + if (getOption(env, fd, IPPROTO_TCP, TCP_USER_TIMEOUT, &optval, sizeof(optval))
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamChannelId.java, + return id * 31 + parentId.hashCode();]
[+++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java]
[+++ b/bom/pom.xml, + <artifactId>netty-transport-native-unix-common</artifactId>, + <version>4.1.14.Final-SNAPSHOT</version>, + <artifactId>netty-transport-native-unix-common</artifactId>, + <version>4.1.14.Final-SNAPSHOT</version>]
[+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + init0(chunk, handle, offset, length, maxLength, cache);, + }, +, + void initUnpooled(PoolChunk<T> chunk, int length) {, + init0(chunk, 0, chunk.offset, length, length, null);, + }, +, + private void init0(PoolChunk<T> chunk, long handle, int offset, int length, int maxLength, PoolThreadCache cache) {, + this.cache = cache;, + this.handle = handle;, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, + init0(chunk, handle, offset, length, maxLength, cache);, + }, +, + void initUnpooled(PoolChunk<T> chunk, int length) {, + init0(chunk, 0, chunk.offset, length, length, null);, + }, +, + private void init0(PoolChunk<T> chunk, long handle, int offset, int length, int maxLength, PoolThreadCache cache) {, +
[+++ b/pom.xml, + <exclusions>, + <exclusion>, + <groupId>org.apache.felix</groupId>, + <artifactId>javax.servlet</artifactId>, + </exclusion>, + <exclusion>, + <groupId>org.apache.felix</groupId>, + <artifactId>org.osgi.foundation</artifactId>, + </exclusion>, + </exclusions>]
[+++ b/transport-native-epoll/pom.xml, + <replacement>CFLAGS=-O3 -DIO_NETTY_SENDMMSG_NOT_FOUND</replacement>, + <replacement>CFLAGS=-O3</replacement>]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Bzip2BitReader.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + public BufType type() {, + return BufType.BYTE;, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + public BufType type() {, + return BufType.BYTE;, +++ b/buffer/src/main/java/io/netty/buffer/Buf.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under
[+++ b/handler/src/main/java/io/netty/handler/ssl/DefaultOpenSslKeyMaterial.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslX509KeyManagerFactory.java, + if (value == null) {, + // There is no keymaterial for the requested alias, return null, + return null;, + }, + throw (Exception) value;, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslX509KeyManagerFactory.java, + if (value == null) {, + // There is no keymaterial for the requested alias, return null, + return null;, + }, + throw (Exception) value;, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslCachingKeyMaterialProviderTest.java, + protected OpenSslKeyMaterialProvider newMaterialProvider(KeyManagerFactory factory, String password) {, + return new OpenSslCachingKeyMaterialProvider(ReferenceCountedOpenSslContext.chooseX509KeyManager(, + factory.getKeyManagers()), password);, + OpenSslKeyMaterialProvider provider = newMaterialProvider(newKeyManagerFactory(), PASSWORD);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslX509KeyManagerFactory.java, + if (value == null) {, + // There is no keymaterial for the requested alias,
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (minWritableBytes <= writableBytes()) {, + return;, + }, +, + throw new IndexOutOfBoundsException(String.format(, + @Override, + public int ensureWritableBytes(int minWritableBytes, boolean force) {, + if (minWritableBytes < 0) {, + throw new IllegalArgumentException(String.format(, + "minWritableBytes: %d (expected: >= 0)", minWritableBytes));, + }, +, + if (minWritableBytes <= writableBytes()) {, + return 0;, + }, +, + if (minWritableBytes > maxCapacity - writerIndex) {, + if (force) {, + if (capacity() == maxCapacity()) {, + return 1;, + }, +, + capacity(maxCapacity());, + return 3;, + }, + }, +, + // Normalize the current capacity
[+++ b/handler/src/main/java/io/netty/handler/ssl/CipherSuiteConverter.java]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + ByteBuf buf = decoder.readOutbound();, + ByteBuf buf = decoder.readInbound();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + ByteBuf buf = decoder.readOutbound();, + ByteBuf buf = decoder.readInbound();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + ByteBuf buf = encoder.readOutbound();, + ByteBuf buf = encoder.readOutbound();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + ByteBuf buf = decoder.readOutbound();, + ByteBuf buf = decoder.readInbound();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + ByteBuf buf = encoder.readOutbound();, + ByteBuf buf = encoder.readOutbound();, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java, + HttpResponse res = ch.readOutbound();, + chunk = ch.readOutbound();, + chunk = ch.readOutbound();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + ByteBuf buf = decoder.readOutbound();, + ByteBuf buf = decoder.readInbound();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + ByteBuf buf = encoder.readOutbound();, + ByteBuf buf = encoder.readOutbound();,
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + if (connection.goAwayReceived() && connection.local().lastStreamKnownByPeer() < lastStreamId) {, + throw connectionError(PROTOCOL_ERROR, "lastStreamId MUST NOT increase. Current value: %d new value: %d",, + connection.local().lastStreamKnownByPeer(), lastStreamId);, + }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + if (connection.goAwayReceived() && connection.local().lastStreamKnownByPeer() < lastStreamId) {, + throw connectionError(PROTOCOL_ERROR, "lastStreamId MUST NOT increase. Current value: %d new value: %d",, + connection.local().lastStreamKnownByPeer(), lastStreamId);, + }, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoderTest.java, + public void goawayIncreasedLastStreamIdShouldThrow() throws Exception {, + when(local.lastStreamKnownByPeer()).thenReturn(1);, + when(connection.goAwayReceived()).thenReturn(true);, + decode().onGoAwayRead(ctx, 3, 2L, EMPTY_BUFFER);, + }, +, + @Test(expected = Http2Exception.class)]
[+++ b/transport/src/main/java/io/netty/channel/ChannelInitializer.java, + protected abstract void initChannel(C ch) throws Exception;]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + * Writes a big-endian 16-bit short integer to the buffer., + */, + @SuppressWarnings("deprecation"), + public static ByteBuf writeShortBE(ByteBuf buf, int shortValue) {, + return buf.order() == ByteOrder.BIG_ENDIAN? buf.writeShort(shortValue) : buf.writeShortLE(shortValue);, + }, +, + /**, + * Sets a big-endian 16-bit short integer to the buffer., + */, + @SuppressWarnings("deprecation"), + public static ByteBuf setShortBE(ByteBuf buf, int index, int shortValue) {, + return buf.order() == ByteOrder.BIG_ENDIAN? buf.setShort(index, shortValue) : buf.setShortLE(index, shortValue);, + }, +, + /**, + * Writes a big-endian 24-bit medium integer to the buffer., + */, + @SuppressWarnings("deprecation"), + public static ByteBuf
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java]
[+++ b/bom/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<!--, + ~ Copyright 2017 The Netty Project, + ~, + ~ The Netty Project licenses this file to you under the Apache License,, + ~ version 2.0 (the "License"); you may not use this file except in compliance, + ~ with the License. You may obtain a copy of the License at:, + ~, + ~ http://www.apache.org/licenses/LICENSE-2.0, + ~, + ~ Unless required by applicable law or agreed to in writing, software, + ~ distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + ~ WARRANTIES OR CONDITIONS OF ANY
[+++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.bootstrap.Bootstrap;, + Bootstrap b = new Bootstrap();, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.bootstrap.Bootstrap;, + Bootstrap b = new Bootstrap();, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.bootstrap.Bootstrap;, + Bootstrap b = new Bootstrap();, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.bootstrap.Bootstrap;, + Bootstrap b = new Bootstrap();, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.bootstrap.Bootstrap;, + Bootstrap b = new Bootstrap();, +++ b/example/src/main/java/io/netty/example/factorial/FactorialClient.java, +import io.netty.bootstrap.Bootstrap;, + Bootstrap b = new Bootstrap();, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.bootstrap.Bootstrap;, + Bootstrap b = new Bootstrap();, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.bootstrap.Bootstrap;, + Bootstrap b = new Bootstrap();, +++ b/example/src/main/java/io/netty/example/factorial/FactorialClient.java, +import io.netty.bootstrap.Bootstrap;, + Bootstrap b = new Bootstrap();, +++ b/example/src/main/java/io/netty/example/http/snoop/HttpSnoopClient.java, +import io.netty.bootstrap.Bootstrap;, + Bootstrap b = new
[+++ b/pom.xml, + <version>1.1.2</version>]
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/AbstractDnsOptPseudoRrRecord.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + @Override, + public boolean isFreed() {, + if (file == null || !file.exists()) {, + return true;, + }, + return false;, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractDiskHttpData.java, + @Override, + public boolean isFreed() {, + if (file == null || !file.exists()) {, + return true;, + }, + return false;, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractHttpData.java, +import io.netty.buffer.ByteBuf;, +import io.netty.channel.ChannelException;, +import java.io.IOException;, +, + @Override, + public ByteBuf data() {, + try {, + return getByteBuf();, + } catch (IOException e) {, + throw new ChannelException(e);, + }, + }, +, + @Override, + public void free()
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBuf.java, + * buffer's {@link #writerIndex() writerIndex} is increased together.]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexCodecTest.java, + DefaultHttp2GoAwayFrame goAwayFrame =, + new DefaultHttp2GoAwayFrame(1, parentChannel.alloc().buffer().writeLong(8));, +, + Http2GoAwayFrame frame = parentChannel.readInbound();, + assertSame(frame, goAwayFrame);, + assertTrue(frame.release());]
[+++ b/common/src/main/java/io/netty/util/concurrent/FastThreadLocal.java, + InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();, + registerCleaner(threadLocalMap);, + return value;, + }, +, + private void registerCleaner(final InternalThreadLocalMap threadLocalMap) {, + InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();, + boolean alreadySet = threadLocalMap.isIndexedVariableSet(index);, + set(threadLocalMap, value);, +, + if (!alreadySet) {, + registerCleaner(threadLocalMap);, + }, +++ b/common/src/main/java/io/netty/util/concurrent/FastThreadLocal.java, + InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();, + registerCleaner(threadLocalMap);, + return value;, + }, +, + private void registerCleaner(final InternalThreadLocalMap threadLocalMap) {, + InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();, + boolean alreadySet = threadLocalMap.isIndexedVariableSet(index);, + set(threadLocalMap, value);, +, + if (!alreadySet) {, + registerCleaner(threadLocalMap);, + }, +++ b/common/src/test/java/io/netty/util/concurrent/FastThreadLocalTest.java, + public void testOnRemoveCalledForFastThreadLocalGet() throws Exception {, + testOnRemoveCalled(true,
[+++ b/all/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/codec-memcache/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta2</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/AbstractBinaryMemcacheMessage.java, + keyLength = key == null ? 0 : (short) key.readableBytes();, + extrasLength = extras == null ? 0 : (byte) extras.readableBytes();, + totalBodyLength = keyLength + extrasLength;, + short oldKeyLength = keyLength;, + keyLength = key == null ? 0 : (short) key.readableBytes();, + totalBodyLength = totalBodyLength + keyLength - oldKeyLength;, + short oldExtrasLength = extrasLength;, + extrasLength = extras == null ? 0 : (byte) extras.readableBytes();, + totalBodyLength = totalBodyLength + extrasLength - oldExtrasLength;, + /**, + * Set the extras length of the message., + * <p/>, + * This may be 0, since
[+++ b/transport/src/main/java/io/netty/channel/ChannelInboundHandlerAdapter.java, +/**, + * Abstract base class for a {@link ChannelHandler} that handles inbound data., + *, + * Most of the times you either want to extend {@link ChannelInboundByteHandlerAdapter} or, + * {@link ChannelInboundMessageHandlerAdapter}., + */, +++ b/transport/src/main/java/io/netty/channel/ChannelInboundHandlerAdapter.java, +/**, + * Abstract base class for a {@link ChannelHandler} that handles inbound data., + *, + * Most of the times you either want to extend {@link ChannelInboundByteHandlerAdapter} or, + * {@link ChannelInboundMessageHandlerAdapter}., + */, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundByteHandler.java, +/**, + * {@link ChannelOutboundHandler} which operates on bytes which are hold in a {@link ByteBuf}., + */, +++ b/transport/src/main/java/io/netty/channel/ChannelInboundHandlerAdapter.java, +/**,
[+++ b/testsuite-osgi/pom.xml, + <!-- Do not deploy this artifact. -->, +++ b/testsuite-osgi/pom.xml, + <!-- Do not deploy this artifact. -->, +++ b/testsuite-osgi/testsuite-osgi-deps/pom.xml, + <packaging>bundle</packaging>, + , + , + <!-- Include all Netty OSGI bundle release modules. -->, + <!-- File/text conversion utilities. -->, + <!-- Produce Karaf feature.xml -->, + <executions>, + <execution>, + <goals>, + <goal>features-generate-descriptor</goal>, + </goals>, + </execution>, + </executions>, + <!-- Invoke integration tests. -->, + <!-- Do not deploy this artifact. -->, + , +++ b/testsuite-osgi/pom.xml, + <!-- Do not deploy this artifact. -->, +++ b/testsuite-osgi/testsuite-osgi-deps/pom.xml, + <packaging>bundle</packaging>, + , + , +
[+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpChannelConfig.java, + List<Integer> streams = (List<Integer>) value;, + setInitMaxStreams(SctpStandardSocketOptions.InitMaxStreams.create(streams.get(0), streams.get(1)));]
[+++ /dev/null, +++ /dev/null, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamFrameToHttpObjectCodec.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java, + final int oldNextInIndex = z.next_in_index;, + ByteBuf decompressed = ctx.alloc().heapBuffer(inputLength << 1);, + decompressed.ensureWritable(z.avail_in << 1);, + z.avail_out = decompressed.writableBytes();, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JZlibDecoder.java, + final int oldNextInIndex = z.next_in_index;, + ByteBuf decompressed = ctx.alloc().heapBuffer(inputLength << 1);, + decompressed.ensureWritable(z.avail_in << 1);, + z.avail_out = decompressed.writableBytes();, +++ b/codec/src/main/java/io/netty/handler/codec/compression/JdkZlibDecoder.java, + ByteBuf decompressed = ctx.alloc().heapBuffer(inflater.getRemaining() << 1);, + byte[] outArray = decompressed.array();, + int outputLength = inflater.inflate(outArray, outIndex, decompressed.writableBytes());, + } else {, + decompressed.ensureWritable(inflater.getRemaining() << 1);]
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsServerAddressStreamProvider.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseStatus.java, + * 431 Request Header Fields Too Large (RFC6585), + */, + public static final HttpResponseStatus REQUEST_HEADER_FIELDS_TOO_LARGE =, + new HttpResponseStatus(431, "Request Header Fields Too Large");, +, + /**, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseStatus.java, + * 431 Request Header Fields Too Large (RFC6585), + */, + public static final HttpResponseStatus REQUEST_HEADER_FIELDS_TOO_LARGE =, + new HttpResponseStatus(431, "Request Header Fields Too Large");, +, + /**, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeadersFrame.java, +import java.util.Map;, +, + private boolean truncated;, + @Override, + @Override, + public boolean isTruncated() {, + return truncated;, + }, +, + public SpdyHeadersFrame setTruncated() {, + truncated = true;, + return this;, +
[+++ b/codec-redis/src/test/java/io/netty/handler/codec/redis/RedisEncoderTest.java]
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketFrameAggregatorTest.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocketFrameAggregatorTest.java, +++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedChannel.java, + private final Queue<Object> inboundMessages = new ArrayDeque<Object>();, + private final Queue<Object> outboundMessages = new ArrayDeque<Object>();, + * Returns the {@link Queue} which holds all the {@link Object}s that were received by this {@link Channel}., + public Queue<Object> inboundMessages() {, + return inboundMessages;, + * @deprecated use {@link #inboundMessages()}, + @Deprecated, + public Queue<Object> lastInboundBuffer() {, + return inboundMessages();, + }, +, + /**, + * Returns the {@link Queue} which holds all the {@link Object}s that were written by this {@link Channel}., + */, + public Queue<Object> outboundMessages() {, + return outboundMessages;,
[+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java, + static boolean isValidClientId(MqttVersion mqttVersion, String clientId) {, + if (mqttVersion == MqttVersion.MQTT_3_1) {, + } else if (mqttVersion == MqttVersion.MQTT_3_1_1) {, + // In 3.1.3.1 Client Identifier of MQTT 3.1.1 specification, The Server MAY allow ClientIds, + // that contain more than 23 encoded bytes. And, The Server MAY allow zero-length ClientId., + return clientId != null;, + }, + throw new IllegalArgumentException(mqttVersion + " is unknown mqtt version");, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java, + static boolean isValidClientId(MqttVersion mqttVersion, String clientId) {, + if (mqttVersion == MqttVersion.MQTT_3_1) {, + } else if (mqttVersion == MqttVersion.MQTT_3_1_1) {, + // In
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +++ /dev/null, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +++ /dev/null, +++ b/transport/src/main/java/io/netty/channel/ChannelPromise.java, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +++ /dev/null, +++ b/transport/src/main/java/io/netty/channel/ChannelPromise.java, +++ b/transport/src/main/java/io/netty/channel/CompleteChannelPromise.java, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +++ /dev/null, +++ b/transport/src/main/java/io/netty/channel/ChannelPromise.java, +++ b/transport/src/main/java/io/netty/channel/CompleteChannelPromise.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPromise.java, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +++ /dev/null, +++ b/transport/src/main/java/io/netty/channel/ChannelPromise.java, +++ b/transport/src/main/java/io/netty/channel/CompleteChannelPromise.java, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPromise.java, +++ b/transport/src/main/java/io/netty/channel/VoidChannelPromise.java]
[+++ b/example/src/main/java/io/netty/example/http/cors/OkResponseHandler.java, +import io.netty.channel.SimpleChannelInboundHandler;, +public class OkResponseHandler extends SimpleChannelInboundHandler<Object> {, + public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {]
[+++ b/pom.xml, + <!-- XXX: maven-release-plugin complains - MRELEASE-715 -->, + <!--, + -->]
[+++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioMessageChannel.java, + closed = closeOnReadError(exception);, + protected boolean closeOnReadError(Throwable cause) {, + // ServerChannel should not be closed even on IOException because it can often continue, + // accepting incoming connections. (e.g. too many open files), + return cause instanceof IOException &&, + !(cause instanceof PortUnreachableException) &&, + this instanceof ServerChannel;, + }, +, +++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioMessageChannel.java, + closed = closeOnReadError(exception);, + protected boolean closeOnReadError(Throwable cause) {, + // ServerChannel should not be closed even on IOException because it can often continue, + // accepting incoming connections. (e.g. too many open files), + return cause instanceof IOException &&, +
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + protected ThreadLocalUnsafeDirectByteBuf newObject(Handle<ThreadLocalUnsafeDirectByteBuf> handle) {, + private final Handle<ThreadLocalUnsafeDirectByteBuf> handle;, + private ThreadLocalUnsafeDirectByteBuf(Handle<ThreadLocalUnsafeDirectByteBuf> handle) {, + handle.recycle(this);, + protected ThreadLocalDirectByteBuf newObject(Handle<ThreadLocalDirectByteBuf> handle) {, + private final Handle<ThreadLocalDirectByteBuf> handle;, + private ThreadLocalDirectByteBuf(Handle<ThreadLocalDirectByteBuf> handle) {, + handle.recycle(this);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + protected ThreadLocalUnsafeDirectByteBuf newObject(Handle<ThreadLocalUnsafeDirectByteBuf> handle) {, + private final Handle<ThreadLocalUnsafeDirectByteBuf> handle;, + private ThreadLocalUnsafeDirectByteBuf(Handle<ThreadLocalUnsafeDirectByteBuf> handle) {, + handle.recycle(this);, + protected ThreadLocalDirectByteBuf newObject(Handle<ThreadLocalDirectByteBuf> handle) {, + private final Handle<ThreadLocalDirectByteBuf> handle;, + private ThreadLocalDirectByteBuf(Handle<ThreadLocalDirectByteBuf> handle) {, + handle.recycle(this);, +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, + final Handle<Entry<?>> recyclerHandle;, + Entry(Handle<Entry<?>> recyclerHandle) {, + recyclerHandle.recycle(this);, + @SuppressWarnings("unchecked"), + protected Entry newObject(Handle<Entry> handle) {, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/rtsp/RtspDecoder.java, +/*, + * Copyright 2015 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java, + * public class MyChannelInitializer extends {@link ChannelInitializer}&lt;{@link Channel}&gt; {, +++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java, + * public class MyChannelInitializer extends {@link ChannelInitializer}&lt;{@link Channel}&gt; {, +++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java, + * public class MyChannelInitializer extends {@link ChannelInitializer}&lt;{@link Channel}&gt; {, +++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java, + * public class MyChannelInitializer extends {@link ChannelInitializer}&lt;{@link Channel}&gt; {, +++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java, + * public class MyChannelInitializer extends {@link ChannelInitializer}&lt;{@link Channel}&gt; {, +++ b/handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java, + * public class MyChannelInitializer extends {@link ChannelInitializer}&lt;{@link Channel}&gt; {, +++ b/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java, + * public class MyChannelInitializer extends {@link ChannelInitializer}&lt;{@link Channel}&gt; {, +++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java, + * public class MyChannelInitializer extends {@link ChannelInitializer}&lt;{@link Channel}&gt; {, +++ b/handler/src/main/java/io/netty/handler/timeout/WriteTimeoutHandler.java, +
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketClientExtensionHandlerTest.java, +import static org.mockito.Mockito.any;, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketClientExtensionHandlerTest.java, +import static org.mockito.Mockito.any;, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketExtensionTestUtil.java, +import static org.mockito.Mockito.argThat;, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketClientExtensionHandlerTest.java, +import static org.mockito.Mockito.any;, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketExtensionTestUtil.java, +import static org.mockito.Mockito.argThat;, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketClientExtensionHandlerTest.java, +import static org.mockito.Mockito.any;, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketExtensionTestUtil.java, +import static org.mockito.Mockito.argThat;, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DataCompressionHttp2Test.java, +import static org.mockito.Mockito.any;, +import static org.mockito.Mockito.anyBoolean;, +import static org.mockito.Mockito.anyInt;, +import static org.mockito.Mockito.anyShort;, +import static org.mockito.Mockito.eq;, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketClientExtensionHandlerTest.java, +import static org.mockito.Mockito.any;, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/extensions/WebSocketExtensionTestUtil.java, +import static org.mockito.Mockito.argThat;, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdyFrameDecoderTest.java, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DataCompressionHttp2Test.java, +import static org.mockito.Mockito.any;, +import static org.mockito.Mockito.anyBoolean;, +import static org.mockito.Mockito.anyInt;, +import static org.mockito.Mockito.anyShort;, +import static org.mockito.Mockito.eq;, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoderTest.java, +import static org.mockito.Mockito.any;, +import static org.mockito.Mockito.anyBoolean;, +import static org.mockito.Mockito.anyInt;, +import static org.mockito.Mockito.anyLong;,
[+++ b/transport/src/main/java/io/netty/channel/oio/AbstractOioByteChannel.java, + if (msg == null) {, + // nothing left to write, + break;, + }]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2FrameWriter.java, + boolean endStream, ChannelPromise promise) {, + boolean endStream, ChannelPromise promise) {, + Http2Headers headers, int padding, ChannelPromise promise) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DecoratingHttp2FrameWriter.java, + boolean endStream, ChannelPromise promise) {, + boolean endStream, ChannelPromise promise) {, + Http2Headers headers, int padding, ChannelPromise promise) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + // Writing headers may fail during the encode state if they violate HPACK limits., + Throwable failureCause = future.cause();, + if (failureCause == null) {, + } else {, + lifecycleManager.onError(ctx, failureCause);, + }, + // Writing headers may fail during the encode state if they violate HPACK limits., + Throwable failureCause
[+++ b/pom.xml, + <version>2.10</version>, + <version>18</version>]
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriterTest.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the, + * "License"); you may not use this file except in compliance with the License. You may obtain a, + * copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express, + *
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +import java.lang.reflect.InvocationTargetException;, +import java.lang.reflect.Method;, +import java.util.Collections;, + private static final Class<?> SNI_HOSTNAME_CLASS;, + private static final Method GET_SERVER_NAMES_METHOD;, + private static final Method SET_SERVER_NAMES_METHOD;, + private static final Method GET_ASCII_NAME_METHOD;, +, +, + Class<?> sniHostNameClass = null;, + Method getAsciiNameMethod = null;, + Method getServerNamesMethod = null;, + Method setServerNamesMethod = null;, + if (PlatformDependent.javaVersion() >= 8) {, + try {, + sniHostNameClass = Class.forName("javax.net.ssl.SNIHostName", false,, + PlatformDependent.getClassLoader(OpenSslEngine.class));, + Object sniHostName = sniHostNameClass.getConstructor(String.class).newInstance("netty.io");, + getAsciiNameMethod = sniHostNameClass.getDeclaredMethod("getAsciiName");, + @SuppressWarnings("unused"), + String name = (String) getAsciiNameMethod.invoke(sniHostName);, +, + getServerNamesMethod = SSLParameters.class.getDeclaredMethod("getServerNames");, + setServerNamesMethod = SSLParameters.class.getDeclaredMethod("setServerNames", List.class);, + SSLParameters
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, +public class WebSocket00FrameDecoder extends ReplayingDecoder<WebSocketFrame, Void> {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, +public class WebSocket00FrameDecoder extends ReplayingDecoder<WebSocketFrame, Void> {, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, + * <pre> public class MyDecoder extends {@link ReplayingDecoder}&lt;{@link Void}&gt; {, + * <pre> public class MyDecoder extends {@link ReplayingDecoder}&lt;{@link Void}&gt; {, + * extends {@link ReplayingDecoder}&lt;<strong>{@link Void}</strong>&gt; {, + * {@link Void} state) throws Exception {, + * public class FirstDecoder extends {@link ReplayingDecoder}&lt;{@link Void}&gt; {, + * {@link Void} state) {, + * the state type which is usually an {@link Enum}; use {@link Void} if state management is, + * unused, +public abstract class ReplayingDecoder<O, S>
[+++ b/all/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/codec-memcache/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta2-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, + try {, + b.eventLoop(new SelectorEventLoop()), + b.shutdown();]
[+++ b/pom.xml, + <id>noPrintGC</id>, + <properties>, + <argLine.printGC>-D_</argLine.printGC>, + </properties>, + </profile>, + <profile>, + <argLine.printGC>-XX:+PrintGCDetails</argLine.printGC>, + <argLine>${argLine.common} ${argLine.printGC} ${argLine.alpnAgent} ${argLine.leak} ${argLine.coverage} ${argLine.noUnsafe} ${argLine.java9} ${argLine.javaProperties}</argLine>]
[+++ b/pom.xml, +++ b/pom.xml, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/channel/socket/http/AcceptedServerChannelPipelineFactory.java, + @Override, +++ b/pom.xml, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/channel/socket/http/AcceptedServerChannelPipelineFactory.java, + @Override, +++ b/src/main/java/org/jboss/netty/channel/socket/http/ChannelFutureAggregator.java, + @Override, +++ b/pom.xml, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/channel/socket/http/AcceptedServerChannelPipelineFactory.java, + @Override, +++ b/src/main/java/org/jboss/netty/channel/socket/http/ChannelFutureAggregator.java, + @Override, +++ b/src/main/java/org/jboss/netty/channel/socket/http/DefaultTunnelIdGenerator.java, + @Override, +++ b/pom.xml, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/channel/socket/http/AcceptedServerChannelPipelineFactory.java, + @Override, +++ b/src/main/java/org/jboss/netty/channel/socket/http/ChannelFutureAggregator.java, + @Override, +++ b/src/main/java/org/jboss/netty/channel/socket/http/DefaultTunnelIdGenerator.java, + @Override, +++ b/src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelAcceptedChannel.java, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, +++ b/pom.xml, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/channel/socket/http/AcceptedServerChannelPipelineFactory.java, + @Override, +++ b/src/main/java/org/jboss/netty/channel/socket/http/ChannelFutureAggregator.java, + @Override, +++ b/src/main/java/org/jboss/netty/channel/socket/http/DefaultTunnelIdGenerator.java, + @Override, +++ b/src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelAcceptedChannel.java, + @Override, + @Override, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandlerBuilder.java, + public Http2ConnectionHandlerBuilder maxReservedStreams(int maxReservedStreams) {, + return super.maxReservedStreams(maxReservedStreams);, + }, +, + @Override, + public Http2ConnectionHandlerBuilder encoderIgnoreMaxHeaderListSize(boolean encoderIgnoreMaxHeaderListSize) {, + return super.encoderIgnoreMaxHeaderListSize(encoderIgnoreMaxHeaderListSize);, + }, +, + @Override]
[+++ b/pom.xml, + <version>8</version>]
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java, + req.headers().add(HttpHeaderNames.CONTENT_TYPE, "multipart/form-data; boundary=" + boundary);]
[+++ b/src/main/java/org/jboss/netty/channel/AbstractServerChannel.java, +++ b/src/main/java/org/jboss/netty/channel/AbstractServerChannel.java, +++ b/src/main/java/org/jboss/netty/channel/local/AbstractLocalChannel.java, +/*, + * JBoss, Home of Professional Open Source, + * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors, + * by the @authors tag. See the copyright.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version., +
[+++ b/transport/src/main/java/io/netty/channel/SimpleChannelInboundHandler.java, + * <strong>Please keep in mind that this method will be renamed to]
[+++ b/src/docbook/en-US/module/start.xml, + <programlisting> bootstrap.setPipelineFactory(new &ChannelPipelineFactory;() {, + });</programlisting>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, + ByteBuf data = headerBlockEncoder.encode(ctx, spdySynStreamFrame);, + try {, + } finally {, + data.release();, + }, + ByteBuf data = headerBlockEncoder.encode(ctx, spdySynReplyFrame);, + try {, + } finally {, + data.release();, + }, + ByteBuf data = headerBlockEncoder.encode(ctx, spdyHeadersFrame);, + try {, + } finally {, + data.release();, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, + ByteBuf data = headerBlockEncoder.encode(ctx, spdySynStreamFrame);, + try {, + } finally {, + data.release();, + }, + ByteBuf data = headerBlockEncoder.encode(ctx, spdySynReplyFrame);, + try {, + } finally {, + data.release();, + }, + ByteBuf data = headerBlockEncoder.encode(ctx, spdyHeadersFrame);, + try {, +
[+++ b/all/.gitignore, +src, +++ b/all/.gitignore, +src, +++ b/all/pom.xml, + <id>clean-src</id>, + <phase>clean</phase>, + <goals>, + <goal>clean</goal>, + </goals>, + <configuration>, + <filesets>, + <fileset>, + <directory>${project.basedir}/src</directory>, + <followSymlinks>false</followSymlinks>, + <useDefaultExcludes>false</useDefaultExcludes>, + </fileset>, + <fileset>, + <directory>${project.basedir}/target</directory>, + <followSymlinks>false</followSymlinks>, + </fileset>, + </filesets>, + </configuration>, + </execution>, + <execution>, + <id>clean-all</id>, + <configuration>, + <filesets>, + <fileset>, + <directory>${project.basedir}/src</directory>, + <followSymlinks>false</followSymlinks>, + <useDefaultExcludes>false</useDefaultExcludes>, + </fileset>, + <fileset>, + <directory>${project.basedir}/target</directory>, + <followSymlinks>false</followSymlinks>, + </fileset>, + </filesets>, + </configuration>, + <includeGroupIds>io.netty</includeGroupIds>, + <outputDirectory>${project.basedir}/src/main/java</outputDirectory>, + <overWriteReleases>false</overWriteReleases>, + <overWriteSnapshots>true</overWriteSnapshots>, + <overWriteReleases>false</overWriteReleases>, + <overWriteSnapshots>true</overWriteSnapshots>, + <artifactId>maven-jxr-plugin</artifactId>, + <version>2.2</version>, + <id>generate-xref</id>, + <phase>package</phase>, + <goal>jxr</goal>, +
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + try {, + if (size > 0) {, + // Something was read, call fireChannelReadComplete(), + ctx.fireChannelReadComplete();, + }, + } finally {, + // recycle in all cases, + }, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + try {, + if (size > 0) {, + // Something was read, call fireChannelReadComplete(), + ctx.fireChannelReadComplete();, + }, + } finally {, + // recycle in all cases, + }, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, + try {, + if (size > 0) {, + // Something was read, call fireChannelReadComplete(), + ctx.fireChannelReadComplete();, + }, + } finally {, + // recycle in all
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + public synchronized SSLSession getHandshakeSession() {, + // Javadocs state return value should be:, + // null if this instance is not currently handshaking, or if the current handshake has not, + // progressed far enough to create a basic SSLSession. Otherwise, this method returns the, + // SSLSession currently being negotiated., + switch(handshakeState) {, + case NOT_STARTED:, + case FINISHED:, + return null;, + default:, + return needPendingStatus() ? pendingStatus(SSL.pendingWrittenBytesInBIO(networkBIO)) : NOT_HANDSHAKING;, + return needPendingStatus() ? pendingStatus(pending) : NOT_HANDSHAKING;, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + public synchronized SSLSession getHandshakeSession() {, + // Javadocs state return value should be:, +
[+++ b/src/docbook/module/start.xml, + At last but not least, please refer to the API reference whenever you, + want to know more about the classes introduced here. All class names in]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, +import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, +import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/CookieDecoderTest.java, +import static org.junit.Assert.*;, +import org.junit.Test;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, +import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/CookieDecoderTest.java, +import static org.junit.Assert.*;, +import org.junit.Test;, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdySessionHandlerTest.java, +import org.junit.Assert;, +import org.junit.Test;, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, +import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/CookieDecoderTest.java, +import static org.junit.Assert.*;, +import org.junit.Test;, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/SpdySessionHandlerTest.java, +import org.junit.Assert;, +import org.junit.Test;, +, +++ b/codec/src/main/java/io/netty/handler/codec/marshalling/CompatibleMarshallingDecoder.java, +import org.jboss.marshalling.ByteInput;, +import org.jboss.marshalling.Unmarshaller;, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, +import static io.netty.handler.codec.spdy.SpdyCodecUtil.*;, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/CookieDecoderTest.java,
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketRstTest.java, + assertTrue("actual message: " + cause.getMessage(),, + cause.getMessage().contains("reset") || cause.getMessage().contains("closed"));]
[+++ b/.travis.yml, +branches:, + only:, + - master, + - 3, + - 3.5]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +import io.netty.util.internal.StringUtil;, +, + private static final char COMMA = ',';, + String[] portList = StringUtil.split(value, COMMA);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +import io.netty.util.internal.StringUtil;, +, + private static final char COMMA = ',';, + String[] portList = StringUtil.split(value, COMMA);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpCodecUtil.java, +import java.util.regex.Pattern;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +import io.netty.util.internal.StringUtil;, +, + private static final char COMMA = ',';, + String[] portList = StringUtil.split(value, COMMA);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpCodecUtil.java, +import java.util.regex.Pattern;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, +import io.netty.util.internal.StringUtil;, + for (String encoding: StringUtil.split(acceptEncoding, ',')) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +import io.netty.util.internal.StringUtil;, +, + private static final char COMMA = ',';, + String[] portList = StringUtil.split(value, COMMA);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpCodecUtil.java, +import java.util.regex.Pattern;,
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +, + // Use SNI if peerHost was specified, + // See https://github.com/netty/netty/issues/4746, + if (clientMode && peerHost != null) {, + SSL.setTlsExtHostName(ssl, peerHost);, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, +, + // Use SNI if peerHost was specified, + // See https://github.com/netty/netty/issues/4746, + if (clientMode && peerHost != null) {, + SSL.setTlsExtHostName(ssl, peerHost);, + }, +++ b/handler/src/test/java/io/netty/handler/ssl/SniClientTest.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + *
[+++ b/pom.xml, + <dependency>, + <groupId>org.slf4j</groupId>, + <artifactId>slf4j-simple</artifactId>, + <version>1.5.2</version>, + <scope>test</scope>, + </dependency>, +++ b/pom.xml, + <dependency>, + <groupId>org.slf4j</groupId>, + <artifactId>slf4j-simple</artifactId>, + <version>1.5.2</version>, + <scope>test</scope>, + </dependency>, +++ b/src/test/java/org/jboss/netty/channel/CompleteChannelFutureTest.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2008, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, + /**, + * @see MessageToByteEncoder#encode(ChannelHandlerContext, Object, ByteBuf), + */, +, + /**, + * @see ByteToMessageDecoder#decode(ChannelHandlerContext, ByteBuf, MessageList), + */, +, + /**, + * @see ByteToMessageDecoder#decodeLast(ChannelHandlerContext, ByteBuf, MessageList), + */, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, + /**, + * @see MessageToByteEncoder#encode(ChannelHandlerContext, Object, ByteBuf), + */, +, + /**, + * @see ByteToMessageDecoder#decode(ChannelHandlerContext, ByteBuf, MessageList), + */, +, + /**, + * @see ByteToMessageDecoder#decodeLast(ChannelHandlerContext, ByteBuf, MessageList), + */, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java, + /**, + * @see MessageToMessageEncoder#encode(ChannelHandlerContext, Object, MessageList), + */, +, + /**, + * @see MessageToMessageDecoder#decode(ChannelHandlerContext, Object, MessageList), + */]
[+++ b/all/pom.xml, + <packaging>bundle</packaging>, + , + <plugin>, + <groupId>org.apache.felix</groupId>, + <artifactId>maven-bundle-plugin</artifactId>, + <extensions>true</extensions>, + <configuration>, + <instructions>, + <Import-Package>, + !io.netty.*,, + sun.misc;resolution:=optional,, + *, + </Import-Package>, + <Export-Package>, + !io.netty.example.*, , + io.netty.*, + </Export-Package>, + </instructions>, + </configuration>, + </plugin> , +++ b/all/pom.xml, + <packaging>bundle</packaging>, + , + <plugin>, + <groupId>org.apache.felix</groupId>, + <artifactId>maven-bundle-plugin</artifactId>, + <extensions>true</extensions>, + <configuration>, + <instructions>, + <Import-Package>, + !io.netty.*,, + sun.misc;resolution:=optional,, + *, + </Import-Package>, + <Export-Package>, + !io.netty.example.*, , + io.netty.*, + </Export-Package>, + </instructions>, + </configuration>, + </plugin> , +++ b/buffer/pom.xml, + <packaging>bundle</packaging>, + , + <build>, + <plugins>, +
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/pom.xml, + <artifactId>maven-source-plugin</artifactId>, + <version>2.1.1</version>, + <executions>, + <execution>, + <id>attach-source</id>, + <phase>package</phase>, + <goals>, + <goal>jar</goal>, + </goals>, + <configuration>, + <attach>true</attach>, + </configuration>, + </execution>, + </executions>, + </plugin>, + <plugin>]
[+++ b/common/src/main/java/io/netty/util/internal/InternalThreadLocalMap.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(InternalThreadLocalMap.class);, +, + private static final int STRING_BUILDER_INITIAL_SIZE;, + private static final int STRING_BUILDER_MAX_SIZE;, + static {, + STRING_BUILDER_INITIAL_SIZE =, + SystemPropertyUtil.getInt("io.netty.threadLocalMap.stringBuilder.initialSize", 1024);, + logger.debug("-Dio.netty.threadLocalMap.stringBuilder.initialSize: {}", STRING_BUILDER_INITIAL_SIZE);, +, + STRING_BUILDER_MAX_SIZE = SystemPropertyUtil.getInt("io.netty.threadLocalMap.stringBuilder.maxSize", 1024 * 4);, + logger.debug("-Dio.netty.threadLocalMap.stringBuilder.maxSize: {}", STRING_BUILDER_MAX_SIZE);, + }, +, + StringBuilder sb = stringBuilder;, + if (sb == null) {, + return stringBuilder = new StringBuilder(STRING_BUILDER_INITIAL_SIZE);, + if (sb.capacity() > STRING_BUILDER_MAX_SIZE) {, + sb.setLength(STRING_BUILDER_INITIAL_SIZE);, + sb.trimToSize();, + sb.setLength(0);, + return sb;]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamChannel.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the, + * "License"); you may not use this file except in compliance with the License. You may obtain a, + * copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License, + * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express, + *
[+++ b/README.md, +- __3.2__ branch contains code for Netty 3.x, +++ b/README.md, +- __3.2__ branch contains code for Netty 3.x, +++ b/transport/pom.xml, +, + <build>, + <plugins>, + <plugin>, + <artifactId>maven-jar-plugin</artifactId>, + <configuration>, + <excludes>, + <!-- Exclude the com.sun.nio stuff as this is included in the jdk if its supported by the running os -->, + <exclude>**/com/**</exclude>, + </excludes>, + </configuration>, + </plugin>, + </plugins>, + </build>, +++ b/README.md, +- __3.2__ branch contains code for Netty 3.x, +++ b/transport/pom.xml, +, + <build>, + <plugins>, + <plugin>, + <artifactId>maven-jar-plugin</artifactId>, + <configuration>, + <excludes>, + <!-- Exclude the com.sun.nio stuff
[+++ b/testsuite-osgi/testsuite-osgi-deps/pom.xml, + <updatePolicy>interval:43200</updatePolicy> <!-- Update every 30 days -->]
[+++ b/pom.xml, + <tcnative.version>2.0.15.Final</tcnative.version>]
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java, +import io.netty.handler.codec.TooLongFrameException;, + HttpContent chunk1 = new DefaultHttpContent(Unpooled.copiedBuffer("test", CharsetUtil.US_ASCII));, + HttpContent chunk2 = new DefaultHttpContent(Unpooled.copiedBuffer("test2", CharsetUtil.US_ASCII));, + assertFalse(embedder.writeInbound(chunk1));, + assertFalse(embedder.writeInbound(chunk2));, + assertFalse(embedder.writeInbound(chunk3));, + checkOversizedRequest(message);, + checkOversizedRequest(message);, + private static void checkOversizedRequest(HttpRequest message) {, + HttpContent chunk1 = new DefaultHttpContent(Unpooled.copiedBuffer("test", CharsetUtil.US_ASCII));, + embedder.writeInbound(chunk1);, + @Test, + public void testOversizedResponse() {, + EmbeddedChannel embedder = new EmbeddedChannel(new HttpObjectAggregator(4));, + HttpResponse message = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);, + HttpContent chunk1 = new DefaultHttpContent(Unpooled.copiedBuffer("test", CharsetUtil.US_ASCII));, + HttpContent chunk2 = new DefaultHttpContent(Unpooled.copiedBuffer("test2", CharsetUtil.US_ASCII));, +, + assertFalse(embedder.writeInbound(message));, + assertFalse(embedder.writeInbound(chunk1));, +, + try {, + embedder.writeInbound(chunk2);, + fail();, + } catch (TooLongFrameException expected) {, +
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + return unwrap().release();, + return unwrap().release(decrement);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + return unwrap().release();, + return unwrap().release(decrement);, +++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java, + private final ByteBuf buffer;, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + return unwrap().release();, + return unwrap().release(decrement);, +++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java, + private final ByteBuf buffer;, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + return unwrap().release();, + return unwrap().release(decrement);, +++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java, + private final ByteBuf buffer;, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + return unwrap().release();, + return unwrap().release(decrement);, +++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java, + private final ByteBuf buffer;, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, +++ /dev/null, +++ /dev/null, +++ b/buffer/src/main/java/io/netty/buffer/AbstractDerivedByteBuf.java, + return unwrap().release();, + return unwrap().release(decrement);, +++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java, + private final ByteBuf buffer;, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java, +++ /dev/null,
[+++ b/pom.xml, + <version>3.1.0.ALPHA1-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/pom.xml, + <pluginExecution>, + <pluginExecutionFilter>, + <groupId>org.fusesource.hawtjni</groupId>, + <artifactId>maven-hawtjni-plugin</artifactId>, + <versionRange>[1.10,)</versionRange>, + <goals>, + <goal>generate</goal>, + <goal>build</goal>, + </goals>, + </pluginExecutionFilter>, + <action>, + <ignore></ignore>, + </action>, + </pluginExecution>, + <pluginExecution>, + <pluginExecutionFilter>, + <groupId>org.apache.maven.plugins</groupId>, + <artifactId>maven-dependency-plugin</artifactId>, + <versionRange>[2.8,)</versionRange>, + <goals>, + <goal>properties</goal>, + <goal>copy</goal>, + </goals>, + </pluginExecutionFilter>, + <action>, + <ignore></ignore>, + </action>, + </pluginExecution>]
[+++ b/pom.xml, + <version>3.2.0.Final</version>, + <url>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.2.0.Final</url>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.2.0.Final</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.2.0.Final</developerConnection>]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + promise.tryFailure(new ClosedChannelException());]
[+++ b/common/src/test/java/io/netty/logging/InternalLoggerFactoryTest.java, + , + @Test, + public void shouldGetInstance() {, + InternalLoggerFactory.setDefaultFactory(oldLoggerFactory);, + , + String helloWorld = "Hello, world!";, + , + InternalLogger one = InternalLoggerFactory.getInstance("helloWorld");, + InternalLogger two = InternalLoggerFactory.getInstance(helloWorld.getClass());, + , + assertNotNull(one);, + assertNotNull(two);, + assertNotSame(one, two);, + }, +++ b/common/src/test/java/io/netty/logging/InternalLoggerFactoryTest.java, + , + @Test, + public void shouldGetInstance() {, + InternalLoggerFactory.setDefaultFactory(oldLoggerFactory);, + , + String helloWorld = "Hello, world!";, + , + InternalLogger one = InternalLoggerFactory.getInstance("helloWorld");, + InternalLogger two = InternalLoggerFactory.getInstance(helloWorld.getClass());, + , + assertNotNull(one);, + assertNotNull(two);, + assertNotSame(one, two);, + }, +++ b/common/src/test/java/io/netty/util/DefaultAttributeMapTest.java, +/*, + * Copyright 2012 The Netty Project, +
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + (int) CharsetUtil.encoder(CharsetUtil.UTF_8).maxBytesPerChar();, + final CharsetEncoder encoder = CharsetUtil.encoder(charset);, + final CharsetDecoder decoder = CharsetUtil.decoder(charset);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + (int) CharsetUtil.encoder(CharsetUtil.UTF_8).maxBytesPerChar();, + final CharsetEncoder encoder = CharsetUtil.encoder(charset);, + final CharsetDecoder decoder = CharsetUtil.decoder(charset);, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequest.java, + private static final CharsetEncoder asciiEncoder = CharsetUtil.encoder(CharsetUtil.US_ASCII);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + (int) CharsetUtil.encoder(CharsetUtil.UTF_8).maxBytesPerChar();, + final CharsetEncoder encoder = CharsetUtil.encoder(charset);, + final CharsetDecoder decoder = CharsetUtil.decoder(charset);, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequest.java, + private static final CharsetEncoder asciiEncoder = CharsetUtil.encoder(CharsetUtil.US_ASCII);, +++ b/common/src/main/java/io/netty/util/AsciiString.java, + CharsetEncoder encoder = CharsetUtil.encoder(charset);, + CharsetEncoder encoder = CharsetUtil.encoder(charset);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + (int) CharsetUtil.encoder(CharsetUtil.UTF_8).maxBytesPerChar();, + final CharsetEncoder encoder = CharsetUtil.encoder(charset);, + final CharsetDecoder decoder =
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufferBackedChannelBuffer.java, + return in.read(buffer.array(), buffer.arrayOffset() + index, length);, + int readBytes = in.read(tmp);, + }, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufferBackedChannelBuffer.java, + return in.read(buffer.array(), buffer.arrayOffset() + index, length);, + int readBytes = in.read(tmp);, + }, +++ b/buffer/src/main/java/io/netty/buffer/HeapChannelBuffer.java, + return in.read(array, index, length);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufferBackedChannelBuffer.java, + return in.read(buffer.array(), buffer.arrayOffset() + index, length);, + int readBytes = in.read(tmp);, + }, +++ b/buffer/src/main/java/io/netty/buffer/HeapChannelBuffer.java, + return in.read(array, index, length);, +++ b/transport/src/main/java/io/netty/channel/SingleThreadEventLoop.java, + public static SingleThreadEventLoop currentEventLoop() {, + return CURRENT_EVENT_LOOP.get();, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufferBackedChannelBuffer.java, + return in.read(buffer.array(), buffer.arrayOffset() + index, length);, + int readBytes = in.read(tmp);, + }, +++ b/buffer/src/main/java/io/netty/buffer/HeapChannelBuffer.java, + return in.read(array, index, length);,
[+++ b/codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java, + * <p>, + * The byte stream is expected to be in UTF-8 character encoding or ASCII. The current implementation, + * uses direct {@code byte} to {@code char} cast and then compares that {@code char} to a few low range, + * ASCII characters like {@code '\n'} or {@code '\r'}. UTF-8 is not using low range [0..0x7F], + * byte values for multibyte codepoint representations therefore fully supported by this implementation., + * <p>, +++ b/codec/src/main/java/io/netty/handler/codec/LineBasedFrameDecoder.java, + * <p>, + * The byte stream is expected to be in UTF-8 character encoding or ASCII. The
[+++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, + int maxCachedBufferCapacity, int freeSweepAllocationThreshold) {, +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, + int maxCachedBufferCapacity, int freeSweepAllocationThreshold) {, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, + DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);, + // No caching so just use 0 as sizes., + return new PoolThreadCache(heapArena, directArena, 0, 0, 0, 0, 0);, +++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, + int maxCachedBufferCapacity, int freeSweepAllocationThreshold) {, +++ b/buffer/src/main/java/io/netty/buffer/PooledByteBufAllocator.java, + DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);, + // No caching so just use 0 as sizes., + return new PoolThreadCache(heapArena, directArena, 0, 0, 0, 0, 0);, +++ b/buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java, + public void testThreadCacheDestroyedByThreadCleaner() throws InterruptedException {, + testThreadCacheDestroyed(false);, + testThreadCacheDestroyed(true);, + private static void testThreadCacheDestroyed(boolean useRunnable) throws InterruptedException {, + thread.join();, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +, + public Http2Stream forEachActiveStream(Http2StreamVisitor visitor) throws Http2Exception {, + forEachActiveStream(new Http2StreamVisitor() {, + forEachActiveStream(new Http2StreamVisitor() {, + public Http2Stream forEachChild(Http2StreamVisitor visitor) throws Http2Exception {, + for (IntObjectHashMap.Entry<DefaultStream> entry : children.entries()) {, + Http2Stream stream = entry.value();, + if (!visitor.visit(stream)) {, + return stream;, + return null;, + public Http2Stream forEachActiveStream(Http2StreamVisitor visitor) throws Http2Exception {, + return stream;, + return null;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +, + public Http2Stream forEachActiveStream(Http2StreamVisitor visitor) throws Http2Exception {, + forEachActiveStream(new Http2StreamVisitor() {, + forEachActiveStream(new Http2StreamVisitor() {, + public Http2Stream forEachChild(Http2StreamVisitor visitor) throws Http2Exception {, + for (IntObjectHashMap.Entry<DefaultStream> entry : children.entries()) {, + Http2Stream
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, + private static final char QUESTION_MARK = '?';, + // Correctly handle query params., + // See https://github.com/netty/netty/issues/2732, + int index = uri.indexOf(QUESTION_MARK, startIndex);, + if (index == -1) {, + } else {, + if (uri.lastIndexOf(SLASH, index) <= startIndex) {, + int len = uri.length();, + StringBuilder sb = new StringBuilder(len + 1);, + sb.append(uri, 0, index);, + sb.append(SLASH);, + sb.append(uri, index, len);, + uri = sb.toString();, + }, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, + private static final char QUESTION_MARK = '?';, + // Correctly handle query params., + // See https://github.com/netty/netty/issues/2732, + int index = uri.indexOf(QUESTION_MARK,
[+++ b/all/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.6.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec/src/main/java/io/netty/handler/codec/MessageAggregator.java, +import static io.netty.buffer.Unpooled.EMPTY_BUFFER;, +, + /**, + * @deprecated This method will be removed in future releases., + */, + @Deprecated, + currentMessage.release();, + currentMessage = null;, + aggregated = beginAggregation(m, EMPTY_BUFFER);, + currentMessage = beginAggregation(m, content);, + // it is possible that a TooLongFrameException was already thrown but we can still discard data, + // until the begging of the next request/response., + return;, + @SuppressWarnings("unchecked"), + final C m = (C) msg;, + if (content.readableBytes() > maxContentLength - m.content().readableBytes()) {, + appendPartialContent(content, m.content());, + last = isLastContentMessage(m);, + last = isLastContentMessage(m);, + currentMessage = null;,
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java, + out.writeBytes(mask);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java, + out.writeBytes(mask);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteDecoder.java, + callDecode(ctx, in, ctx.nextOutboundByteBuffer());]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, +import io.netty.channel.embedded.EmbeddedByteChannel;, + new EmbeddedByteChannel(, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, +import io.netty.channel.embedded.EmbeddedByteChannel;, + new EmbeddedByteChannel(, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, +import io.netty.channel.embedded.EmbeddedByteChannel;, + private EmbeddedByteChannel decoder;, + protected abstract EmbeddedByteChannel newContentDecoder(String contentEncoding) throws Exception;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, +import io.netty.channel.embedded.EmbeddedByteChannel;, + new EmbeddedByteChannel(, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, +import io.netty.channel.embedded.EmbeddedByteChannel;, + private EmbeddedByteChannel decoder;, + protected abstract EmbeddedByteChannel newContentDecoder(String contentEncoding) throws Exception;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecompressor.java, +import io.netty.channel.embedded.EmbeddedByteChannel;, + protected EmbeddedByteChannel newContentDecoder(String contentEncoding) throws Exception {, + return new EmbeddedByteChannel(new ZlibDecoder(ZlibWrapper.GZIP));, + return new EmbeddedByteChannel(new ZlibDecoder(ZlibWrapper.ZLIB_OR_NONE));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentCompressor.java, +import io.netty.channel.embedded.EmbeddedByteChannel;, + new EmbeddedByteChannel(, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, +import io.netty.channel.embedded.EmbeddedByteChannel;, + private EmbeddedByteChannel decoder;, + protected abstract EmbeddedByteChannel newContentDecoder(String contentEncoding) throws Exception;, +++
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java, +import io.netty.channel.ChannelFuture;, +import io.netty.handler.codec.http.HttpUtil;, + respond(ctx, request, response);, + respond(ctx, request, new DefaultFullHttpResponse(request.protocolVersion(), FORBIDDEN));, + }, +, + private static void respond(, + final ChannelHandlerContext ctx,, + final HttpRequest request,, + final HttpResponse response) {, +, + final boolean keepAlive = HttpUtil.isKeepAlive(request);, +, + HttpUtil.setKeepAlive(response, keepAlive);, +, + final ChannelFuture future = ctx.writeAndFlush(response);, + if (!keepAlive) {, + future.addListener(ChannelFutureListener.CLOSE);, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java, +import io.netty.channel.ChannelFuture;, +import io.netty.handler.codec.http.HttpUtil;, + respond(ctx, request, response);, + respond(ctx, request, new DefaultFullHttpResponse(request.protocolVersion(), FORBIDDEN));, + }, +, + private static void respond(, + final ChannelHandlerContext ctx,, + final HttpRequest request,, + final HttpResponse response)
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + } finally {, + freeInboundBridge();, + } finally {, + freeOutboundBridge();, + private void freeInboundBridge() {, + ByteBridge inByteBridge = this.inByteBridge;, + if (inByteBridge != null) {, + inByteBridge.release();, + }, +, + MessageBridge inMsgBridge = this.inMsgBridge;, + if (inMsgBridge != null) {, + inMsgBridge.release();, + }, + }, +, + private void freeOutboundBridge() {, + ByteBridge outByteBridge = this.outByteBridge;, + if (outByteBridge != null) {, + outByteBridge.release();, + }, +, + MessageBridge outMsgBridge = this.outMsgBridge;, + if (outMsgBridge != null) {, + outMsgBridge.release();, + }, + }, +, + // release it as it was
[+++ b/codec-dns/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<!--, + ~ Copyright 2014 The Netty Project, + ~, + ~ The Netty Project licenses this file to you under the Apache License,, + ~ version 2.0 (the "License"); you may not use this file except in compliance, + ~ with the License. You may obtain a copy of the License at:, + ~, + ~ http://www.apache.org/licenses/LICENSE-2.0, + ~, + ~ Unless required by applicable law or agreed to in writing, software, + ~ distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + ~ WARRANTIES OR CONDITIONS OF ANY
[+++ b/handler/src/main/java/io/netty/handler/flush/FlushConsolidationHandler.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + try {, + } finally {, + }, +, + break;, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + try {, + } finally {, + }, +, + break;, +++ b/codec/src/main/java/io/netty/handler/codec/ReplayingDecoder.java, + try {, + } finally {, + }, +, + break;]
[+++ b/all/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/example/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha7</version>, +++ b/codec/pom.xml, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, + public void channelInactive(ChannelHandlerContext ctx) throws Exception {, + super.channelInactive(ctx);, +, + // release current message if it is not null as it may be a left-over, + if (currentMessage != null) {, + currentMessage.release();, + currentMessage = null;, + }, + }, +, + @Override, +, + @Override, + public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {, + super.handlerRemoved(ctx);, + // release current message if it is not null as it may be a left-over as there is not much more we can do in, + // this case, + if (currentMessage != null) {, + currentMessage.release();,
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelId.java, + if (this == obj) {, + return true;, + }, + if (!(obj instanceof DefaultChannelId)) {, + return false;, + }, + DefaultChannelId other = (DefaultChannelId) obj;, + return hashCode == other.hashCode && Arrays.equals(data, other.data);]
[+++ b/handler/src/main/java/io/netty/handler/ssl/NotSslRecordException.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java, + private static volatile long initialSeedUniquifier;, + initialSeedUniquifier = AccessController.doPrivileged(new PrivilegedAction<Long>() {, + @Override, + public Long run() {, + return Long.getLong("io.netty.initialSeedUniquifier", 0);, + }, + });, +, + return Boolean.getBoolean("java.util.secureRandomSeed");]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, +import io.netty.handler.codec.HeadersUtils;, +, + @Override, + public String toString() {, + return HeadersUtils.toString(getClass(), iteratorCharSequence(), size());, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, +import io.netty.handler.codec.HeadersUtils;, +, + @Override, + public String toString() {, + return HeadersUtils.toString(getClass(), iteratorCharSequence(), size());, + }, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/DefaultHttpHeadersTest.java, + @Test, + public void toStringOnEmptyHeaders() {, + assertEquals("DefaultHttpHeaders[]", newDefaultDefaultHttpHeaders().toString());, + }, +, + @Test, + public void toStringOnSingleHeader() {, + assertEquals("DefaultHttpHeaders[foo: bar]", newDefaultDefaultHttpHeaders(), + .add("foo", "bar"), + .toString());, + }, +, + @Test, + public void toStringOnMultipleHeaders() {, + assertEquals("DefaultHttpHeaders[foo: bar, baz: qix]", newDefaultDefaultHttpHeaders(), + .add("foo", "bar"), + .add("baz", "qix"), + .toString());, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaders.java, +import
[+++ b/NOTICE.txt, +This product optionally depends on 'XNIO', a simplified low-level I/O layer,, +which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.xnio.txt (GNU LGPL 2.1), + * HOMEPAGE:, + * http://www.jboss.org/xnio/, +, +++ b/NOTICE.txt, +This product optionally depends on 'XNIO', a simplified low-level I/O layer,, +which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.xnio.txt (GNU LGPL 2.1), + * HOMEPAGE:, + * http://www.jboss.org/xnio/, +, +++ b/license/LICENSE.xnio.txt, +, + GNU LESSER GENERAL PUBLIC LICENSE, + Version 2.1, February 1999, +, + Copyright (C) 1991, 1999 Free Software Foundation, Inc., + 51 Franklin Street, Fifth
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + safeExecute(executor, new Runnable() {, + }, promise);, + safeExecute(executor, new Runnable() {, + }, promise);, + safeExecute(executor, new Runnable() {, + }, promise);, + safeExecute(executor, new Runnable() {, + }, promise);, + safeExecute(executor, new Runnable() {, + }, promise);, + safeExecute(executor, task, channel.voidPromise());, + safeExecute(executor, WriteTask.newInstance(next, msg, size, flush, promise), promise);, + private static void safeExecute(EventExecutor executor, Runnable runnable, ChannelPromise promise) {, + try {, + executor.execute(runnable);, + } catch (Throwable cause) {, + promise.setFailure(cause);, + }, + }, +]
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java, +import org.jctools.util.UnsafeAccess;, + private static final class Mpsc {, + private static final boolean USE_MPSC_CHUNKED_ARRAY_QUEUE;, +, + private Mpsc() {, + }, +, + static {, + Object unsafe = null;, + if (hasUnsafe()) {, + // jctools goes through its own process of initializing unsafe; of, + // course, this requires permissions which might not be granted to calling code, so we, + // must mark this block as privileged too, + unsafe = AccessController.doPrivileged(new PrivilegedAction<Object>() {, + @Override, + public Object run() {, + // force JCTools to initialize unsafe, + return UnsafeAccess.UNSAFE;, + },
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, + return validIpV4ToBytes(ipAddressString);, + /**, + * Convert ASCII hexadecimal character to the {@code int} value., + * Unlike {@link Character#digit(char, int)}, returns {@code 0} if character is not a HEX-represented., + */, + if (c >= '0' && c <= '9') {, + return c - '0';, + }, + if (c >= 'A' && c <= 'F') {, + // 0xA - a start value in sequence 'A'..'F', + return c - 'A' + 0xA;, + }, + if (c >= 'a' && c <= 'f') {, + // 0xA - a start value in
[+++ b/buffer/src/main/java/io/netty/buffer/DuplicatedByteBuf.java, +]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, + private static final int NOT_ENOUGH_INPUT = -1;, + private int written;, + written = 0;, + int literalWritten = decodeLiteral(tag, in, out);, + if (literalWritten != NOT_ENOUGH_INPUT) {, + written += literalWritten;, + int decodeWritten;, + decodeWritten = decodeCopyWith1ByteOffset(tag, in, out, written);, + if (decodeWritten != NOT_ENOUGH_INPUT) {, + written += decodeWritten;, + decodeWritten = decodeCopyWith2ByteOffset(tag, in, out, written);, + if (decodeWritten != NOT_ENOUGH_INPUT) {, + written += decodeWritten;, + decodeWritten = decodeCopyWith4ByteOffset(tag, in, out, written);, + if (decodeWritten != NOT_ENOUGH_INPUT) {, + written += decodeWritten;, + * @return The number of bytes appended to the
[+++ b/codec/src/main/java/io/netty/handler/codec/serialization/CompatibleObjectEncoder.java, + ObjectOutputStream oos = newObjectOutputStream(new ByteBufOutputStream(out));, + try {, + } finally {, + oos.close();, +++ b/codec/src/main/java/io/netty/handler/codec/serialization/CompatibleObjectEncoder.java, + ObjectOutputStream oos = newObjectOutputStream(new ByteBufOutputStream(out));, + try {, + } finally {, + oos.close();, +++ b/codec/src/test/java/io/netty/handler/codec/serialization/CompatibleObjectEncoderTest.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless
[+++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.channel.ChannelBootstrap;, +import io.netty.channel.ChannelInitializer;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.channel.socket.nio.NioEventLoop;, +import io.netty.channel.socket.nio.NioSocketChannel;, + public void run() throws Exception {, + ChannelBootstrap b = new ChannelBootstrap();, + try {, + b.eventLoop(new NioEventLoop()), + .channel(new NioSocketChannel()), + .remoteAddress(host, port), + .initializer(new ChannelInitializer<SocketChannel>() {, + @Override, + public void initChannel(SocketChannel ch) throws Exception {, + ch.pipeline().addLast(new DiscardClientHandler(firstMessageSize));, + // Make the connection attempt., + ChannelFuture f = b.connect().sync();, + // Wait until the connection is closed., + f.channel().closeFuture().sync();, + } finally {, + b.shutdown();, + }, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.channel.ChannelBootstrap;, +import io.netty.channel.ChannelInitializer;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.channel.socket.nio.NioEventLoop;, +import io.netty.channel.socket.nio.NioSocketChannel;, + public void run()
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + private static byte[] newByteArray(int size) {, + return PlatformDependent.allocateUninitializedArray(size);, + }, +, + return new PoolChunk<byte[]>(this, newByteArray(chunkSize), pageSize, maxOrder, pageShifts, chunkSize, 0);, + return new PoolChunk<byte[]>(this, newByteArray(capacity), capacity, 0);, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + private static byte[] newByteArray(int size) {, + return PlatformDependent.allocateUninitializedArray(size);, + }, +, + return new PoolChunk<byte[]>(this, newByteArray(chunkSize), pageSize, maxOrder, pageShifts, chunkSize, 0);, + return new PoolChunk<byte[]>(this, newByteArray(capacity), capacity, 0);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeHeapByteBuf.java, + byte[] allocateArray(int initialCapacity) {, + return PlatformDependent.allocateUninitializedArray(initialCapacity);, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + private static byte[] newByteArray(int size) {, + return PlatformDependent.allocateUninitializedArray(size);, + }, +, + return new PoolChunk<byte[]>(this, newByteArray(chunkSize),
[+++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java, + ByteBuf dst = src.isDirect() ? alloc().directBuffer(length) : alloc().heapBuffer(length);, + dst.writeBytes(src);, + return dst;, +++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java, + ByteBuf dst = src.isDirect() ? alloc().directBuffer(length) : alloc().heapBuffer(length);, + dst.writeBytes(src);, + return dst;, +++ b/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufferBufTest.java, +import io.netty.util.internal.PlatformDependent;, +import org.junit.Test;, +, +import static org.junit.Assert.assertEquals;, +, +, + @Test, + public void testCopyDirect() {, + testCopy(true);, + }, +, + @Test, + public void testCopyHeap() {, + testCopy(false);, + }, +, + private static void testCopy(boolean direct) {, + byte[] bytes = new byte[1024];, + PlatformDependent.threadLocalRandom().nextBytes(bytes);, +, + ByteBuffer nioBuffer = direct ? ByteBuffer.allocateDirect(bytes.length) : ByteBuffer.allocate(bytes.length);, + nioBuffer.put(bytes).flip();, +, + ByteBuf buf
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + // Just call closeOnRead(). There is no need to trigger a read as this, + // will result in an IOException anyway., + //, + // See https://github.com/netty/netty/issues/3539, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + // Just call closeOnRead(). There is no need to trigger a read as this, + // will result in an IOException anyway., + //, + // See https://github.com/netty/netty/issues/3539, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, + // We need to check if the channel is still open before try to trigger the, + // callbacks., + // See https://github.com/netty/netty/issues/3443, + if ((ev & Native.EPOLLRDHUP) != 0 && ch.isOpen()) {, +
[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, + private long waiters;, + return waiters > 0;, + if (waiters == Long.MAX_VALUE) {, + waiters++;, + waiters--;, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, + private long waiters;, + return waiters > 0;, + if (waiters == Long.MAX_VALUE) {, + waiters++;, + waiters--;, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelProgressivePromise.java, + private long checkpoint;, + return checkpoint;, + this.checkpoint = checkpoint;, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java, + private long waiters;, + return waiters > 0;, + if (waiters == Long.MAX_VALUE) {, + waiters++;, + waiters--;, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelProgressivePromise.java, + private long checkpoint;, + return checkpoint;, + this.checkpoint = checkpoint;, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelPromise.java, + private long checkpoint;, + return checkpoint;, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/JdkAlpnSslEngine.java, +, +import javax.net.ssl.SSLEngine;, +import javax.net.ssl.SSLException;, +import java.util.LinkedHashSet;, +import java.util.List;, +, + public String select(List<String> protocols) throws SSLException {, + } catch (SSLException e) {, + throw e;, + // Ensure that all exceptions are propagated as SSLExceptions, + // so that the SslHandler properly fails the handshake., + throw new SSLException(t);, + public void selected(String protocol) throws SSLException {, + } catch (SSLException e) {, + throw e;, + // Ensure that all exceptions are propagated as SSLExceptions, + // so that the SslHandler properly fails the handshake., + throw new SSLException(t);, +++ b/handler/src/main/java/io/netty/handler/ssl/JdkAlpnSslEngine.java, +, +import javax.net.ssl.SSLEngine;,
[+++ b/pom.xml, + <!-- pax-exam does not work on latest Java11 build -->, + <skipOsgiTestsuite>true</skipOsgiTestsuite>]
[+++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java, + * Triggers an {@link ChannelInboundHandler#channelReadComplete(ChannelHandlerContext)}]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + private static final Method GET_USE_CIPHER_SUITES_ORDER_METHOD;, + private static final Method SET_USE_CIPHER_SUITES_ORDER_METHOD;, + Method getUseCipherSuitesOrderMethod = null;, + Method setUseCipherSuitesOrderMethod = null;, + getUseCipherSuitesOrderMethod = SSLParameters.class.getDeclaredMethod("getUseCipherSuitesOrder");, + SSLParameters parameters = new SSLParameters();, + @SuppressWarnings("unused"), + Boolean order = (Boolean) getUseCipherSuitesOrderMethod.invoke(parameters);, + setUseCipherSuitesOrderMethod = SSLParameters.class.getDeclaredMethod("setUseCipherSuitesOrder",, + boolean.class);, + setUseCipherSuitesOrderMethod.invoke(parameters, true);, + } catch (Throwable ignore) {, + getUseCipherSuitesOrderMethod = null;, + setUseCipherSuitesOrderMethod = null;, + }, + try {, + GET_USE_CIPHER_SUITES_ORDER_METHOD = getUseCipherSuitesOrderMethod;, + SET_USE_CIPHER_SUITES_ORDER_METHOD = setUseCipherSuitesOrderMethod;, + if (version >= 8) {, + if (SET_SERVER_NAMES_METHOD != null && sniHostNames != null) {, + if (SET_USE_CIPHER_SUITES_ORDER_METHOD != null
[+++ b/transport/src/main/java/io/netty/channel/embedded/AbstractEmbeddedChannel.java, +import io.netty.channel.Channel;, +/**, + * Base class for {@link Channel} implementations that are used in an embedded fashion., + *, + * @param <O> the type of data that can be written to this {@link Channel}, + */, +public abstract class AbstractEmbeddedChannel<O> extends AbstractChannel {, + /**, + * Create a new instance, + *, + * @param lastOutboundBuffer the last outbound buffer which will hold all the written data, + * @param handlers the @link ChannelHandler}s which will be add in the {@link ChannelPipeline}, + */, + /**, + * Return the last inbound {@link MessageBuf}
[+++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, + * {@code initialCapacity}, that may grow up to {@code maxCapacity}, + * The new buffer's {@code readerIndex} and {@code writerIndex} are, + * {@code 0}., + * {@code initialCapacity}, that may grow up to {@code maxCapacity}., + * The new buffer's {@code readerIndex} and {@code writerIndex} are, + * {@code 0}.]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2GoAwayFrame.java, + return errorCode == other.errorCode && extraStreamIds == other.extraStreamIds && super.equals(other);, + int hash = super.hashCode();]
[+++ b/pom.xml, +, + <developers>, + <developer>, + <id>trustin</id>, + <name>Trustin Lee</name>, + <email>trustin@gmail.com</email>, + <url>http://gleamynode.net/</url>, + </developer>, + </developers>, +]
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +import static io.netty.util.ReferenceCountUtil.*;, + ByteBuf value = releaseLater(directBuffer(BLOCK_SIZE * 2));, + ByteBuf expectedValue = releaseLater(directBuffer(BLOCK_SIZE * 2));, + ByteBuf value = releaseLater(directBuffer(BLOCK_SIZE * 2));, + ByteBuf expectedValue = releaseLater(wrappedBuffer(expectedValueContent));, + ByteBuf value = releaseLater(directBuffer(BLOCK_SIZE * 2));, + ByteBuf expectedValue = releaseLater(wrappedBuffer(expectedValueContent));, + ByteBuf copy = releaseLater(copiedBuffer(buffer));, + ByteBuf copy = releaseLater(copiedBuffer(buffer));, + ByteBuf copy = releaseLater(buffer.copy());, + ByteBuf elemA = releaseLater(buffer(15));, + ByteBuf elemB = releaseLater(directBuffer(15));, + assertTrue(set.contains(releaseLater(elemA.copy())));, + ByteBuf elemBCopy = releaseLater(elemB.copy());, + ByteBuf buffer = releaseLater(newBuffer(2));, + final ByteBuf buffer = releaseLater(newBuffer(8));, + final ByteBuf buffer = releaseLater(newBuffer(8));, + final ByteBuf buffer = releaseLater(newBuffer(8));, +
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameCodecTest.java, + inboundData.release();, + Http2StreamActiveEvent activeEvent = inboundHandler.readInboundMessageOrUserEvent();, + Http2HeadersFrame actualHeaders = inboundHandler.readInboundMessageOrUserEvent();, + Http2ResetFrame actualRst = inboundHandler.readInboundMessageOrUserEvent();, + Http2StreamClosedEvent closedEvent = inboundHandler.readInboundMessageOrUserEvent();, + assertNull(inboundHandler.readInboundMessageOrUserEvent());, + Http2StreamActiveEvent activeEvent = inboundHandler.readInboundMessageOrUserEvent();, + Http2HeadersFrame headersFrame = inboundHandler.readInboundMessageOrUserEvent();, + Http2StreamClosedEvent closedEvent = inboundHandler.readInboundMessageOrUserEvent();, + assertNull(inboundHandler.readInboundMessageOrUserEvent());, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameCodecTest.java, + inboundData.release();, + Http2StreamActiveEvent activeEvent = inboundHandler.readInboundMessageOrUserEvent();, + Http2HeadersFrame actualHeaders = inboundHandler.readInboundMessageOrUserEvent();, + Http2ResetFrame actualRst = inboundHandler.readInboundMessageOrUserEvent();, + Http2StreamClosedEvent closedEvent = inboundHandler.readInboundMessageOrUserEvent();, + assertNull(inboundHandler.readInboundMessageOrUserEvent());, + Http2StreamActiveEvent activeEvent = inboundHandler.readInboundMessageOrUserEvent();, + Http2HeadersFrame headersFrame = inboundHandler.readInboundMessageOrUserEvent();, + Http2StreamClosedEvent closedEvent = inboundHandler.readInboundMessageOrUserEvent();, + assertNull(inboundHandler.readInboundMessageOrUserEvent());, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/LastInboundHandler.java, +import java.util.ArrayList;, +import java.util.List;, + private final List<Object> queue = new
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (checkAccessible && internalRefCnt() == 0) {, + /**, + * Returns the reference count that is used internally by {@link #ensureAccessible()} to try to guard, + * against using the buffer after it was released (best-effort)., + */, + int internalRefCnt() {, + return refCnt();, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + if (checkAccessible && internalRefCnt() == 0) {, + /**, + * Returns the reference count that is used internally by {@link #ensureAccessible()} to try to guard, + * against using the buffer after it was released (best-effort)., + */, + int internalRefCnt() {, +
[+++ /dev/null, +++ /dev/null, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + * method and check for a {@link SslHandshakeCompletionEvent}., + private static final SslHandshakeCompletionEvent HANDSHAKE_SUCCESS_EVENT = new SslHandshakeCompletionEvent(null);, + ctx.fireUserEventTriggered(new SslHandshakeCompletionEvent(cause));, +++ /dev/null, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandler.java, + * method and check for a {@link SslHandshakeCompletionEvent}., + private static final SslHandshakeCompletionEvent HANDSHAKE_SUCCESS_EVENT = new SslHandshakeCompletionEvent(null);, + ctx.fireUserEventTriggered(new SslHandshakeCompletionEvent(cause));, +++ b/handler/src/main/java/io/netty/handler/ssl/SslHandshakeCompletionEvent.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You
[+++ b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheEncoderTest.java, + written.release();, +]
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractServerSocketTest.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, +++ b/example/src/main/java/io/netty/example/socksproxy/SocksServerConnectHandler.java, + private final Bootstrap b = new Bootstrap();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, +++ b/example/src/main/java/io/netty/example/socksproxy/SocksServerConnectHandler.java, + private final Bootstrap b = new Bootstrap();, +++ b/example/src/main/java/io/netty/example/socksproxy/SocksServerHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, +++ b/example/src/main/java/io/netty/example/socksproxy/SocksServerConnectHandler.java, + private final Bootstrap b = new Bootstrap();, +++ b/example/src/main/java/io/netty/example/socksproxy/SocksServerHandler.java, +++ b/transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpInboundByteStreamHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, +++ b/example/src/main/java/io/netty/example/socksproxy/SocksServerConnectHandler.java, + private final Bootstrap b = new Bootstrap();, +++ b/example/src/main/java/io/netty/example/socksproxy/SocksServerHandler.java, +++ b/transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpInboundByteStreamHandler.java, +++ b/transport-udt/src/test/java/io/netty/test/udt/util/EchoMessageHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java, +++ b/example/src/main/java/io/netty/example/socksproxy/SocksServerConnectHandler.java, + private final Bootstrap b = new Bootstrap();, +++ b/example/src/main/java/io/netty/example/socksproxy/SocksServerHandler.java, +++ b/transport-sctp/src/main/java/io/netty/handler/codec/sctp/SctpInboundByteStreamHandler.java, +++ b/transport-udt/src/test/java/io/netty/test/udt/util/EchoMessageHandler.java, +++ b/transport/src/main/java/io/netty/channel/ChannelInboundMessageHandlerAdapter.java, +import java.lang.reflect.Method;, +import
[+++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +import io.netty.util.internal.PlatformDependent;, + PlatformDependent.freeDirectBuffer(directBuf);, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, +import io.netty.util.internal.PlatformDependent;, + PlatformDependent.freeDirectBuffer(directBuf);, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java]
[+++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, + * @param buffer The buffer to wrap. Reference count ownership of this variable is transfered to this method., + * @return The readable portion of the {@code buffer}, or an empty buffer if there is no readable portion., + * The caller is responsible for releasing this buffer., + buffer.release();, + * @param buffers The buffers to wrap. Reference count ownership of all variables is transfered to this method., + * @return The readable portion of the {@code buffers}. The caller is responsible for releasing this buffer., + * @param maxNumComponents Advisement as to how many
[+++ b/pom.xml, + <additionalparam>, + -charset UTF-8, + -group "Miscellaneous" ${project.groupId}.logging*, + -sourceclasspath ${project.build.outputDirectory}, + </additionalparam>]
[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultThreadFactory.java, + if (t.isDaemon() != daemon) {, + t.setDaemon(daemon);]
[+++ b/codec/src/main/java/io/netty/handler/codec/LengthFieldPrepender.java, + protected void encode(ChannelHandlerContext ctx, ByteBuf msg, ByteBuf out) throws Exception {, + int length = msg.readableBytes() + lengthAdjustment;, + if (lengthIncludesLengthFieldLength) {, + length += lengthFieldLength;, + }, +++ b/codec/src/main/java/io/netty/handler/codec/LengthFieldPrepender.java, + protected void encode(ChannelHandlerContext ctx, ByteBuf msg, ByteBuf out) throws Exception {, + int length = msg.readableBytes() + lengthAdjustment;, + if (lengthIncludesLengthFieldLength) {, + length += lengthFieldLength;, + }, +++ b/codec/src/test/java/io/netty/handler/codec/frame/LengthFieldPrependerTest.java, + * Copyright 2013 The Netty Project, +import static io.netty.buffer.Unpooled.*;, +import static org.hamcrest.core.Is.*;, +import static org.junit.Assert.*;]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerSessionContext.java, +import java.util.concurrent.locks.Lock;, +, + Lock writerLock = context.ctxLock.writeLock();, + writerLock.lock();, + try {, + } finally {, + writerLock.unlock();, + }, + Lock readerLock = context.ctxLock.readLock();, + readerLock.lock();, + try {, + } finally {, + readerLock.unlock();, + }, + Lock writerLock = context.ctxLock.writeLock();, + writerLock.lock();, + try {, + } finally {, + writerLock.unlock();, + }, + Lock readerLock = context.ctxLock.readLock();, + readerLock.lock();, + try {, + } finally {, + readerLock.unlock();, + }, +, + Lock writerLock = context.ctxLock.writeLock();, + writerLock.lock();, + try {, + } finally {, + writerLock.unlock();, + }, + Lock readerLock
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, + boolean handled = false;, + if (msg instanceof SpdySynStreamFrame) {, + // Let the next handlers handle the buffered messages before SYN_STREAM message updates the, + // lastGoodStreamId., + if (handled) {, + ctx.fireInboundBufferUpdated();, + }, +, + handleInboundMessage(ctx, msg);, + handled = true;, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, + boolean handled = false;, + if (msg instanceof SpdySynStreamFrame) {, + // Let the next handlers handle the buffered messages before SYN_STREAM message updates the, + // lastGoodStreamId., + if (handled) {, + ctx.fireInboundBufferUpdated();, + }, +, + handleInboundMessage(ctx, msg);, + handled = true;, + },
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + private static final int CONTINUE_CODE = HttpResponseStatus.CONTINUE.code();, + final int code = res.getStatus().code();, + if (code == CONTINUE_CODE) {, + // We need to not poll the encoding when response with CONTINUE as another response will follow, + // for the issued request. See https://github.com/netty/netty/issues/4079, + acceptEncoding = null;, + } else {, + }, + if (isPassthru(code, acceptEncoding)) {, + private static boolean isPassthru(int code, CharSequence httpMethod) {, + return code < 200 || code == 204 || code == 304 ||, + (httpMethod == ZERO_LENGTH_HEAD || (httpMethod == ZERO_LENGTH_CONNECT && code == 200));, +++
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + CodecOutputList out = CodecOutputList.newInstance();, + if (msgs instanceof CodecOutputList) {, + fireChannelRead(ctx, (CodecOutputList) msgs, numElements);, + } else {, + }, +, + /**, + * Get {@code numElements} out of the {@link CodecOutputList} and forward these through the pipeline., + */, + static void fireChannelRead(ChannelHandlerContext ctx, CodecOutputList msgs, int numElements) {, + for (int i = 0; i < numElements; i ++) {, + ctx.fireChannelRead(msgs.getUnsafe(i));, + }, + }, + CodecOutputList out = CodecOutputList.newInstance();, + // Recycle in all cases, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, + CodecOutputList out = CodecOutputList.newInstance();, + if (msgs instanceof CodecOutputList) {, + fireChannelRead(ctx,
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, + * {@link ChannelInboundHandlerAdapter#inboundBufferUpdated}/{@link ChannelStateHandler#inboundBufferUpdated}, + * {@link ChannelInboundHandlerAdapter#inboundBufferUpdated}/{@link ChannelStateHandler#inboundBufferUpdated}, + * {@link ChannelOutboundHandlerAdapter#flush}/{@link ChannelOperationHandler#flush}, + * {@link ChannelOutboundHandlerAdapter#flush}/{@link ChannelOperationHandler#flush}]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import java.security.AccessController;, +import java.security.PrivilegedAction;, + private static final boolean USE_KEYMANAGER_FACTORY;, + boolean useKeyManagerFactory = false;, + useKeyManagerFactory = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {, + @Override, + public Boolean run() {, + return SystemPropertyUtil.getBoolean(, + "io.netty.handler.ssl.openssl.useKeyManagerFactory", true);, + }, + });, + USE_KEYMANAGER_FACTORY = useKeyManagerFactory;, + USE_KEYMANAGER_FACTORY = false;, + static boolean useKeyManagerFactory() {, + return USE_KEYMANAGER_FACTORY;, + }, +, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import java.security.AccessController;, +import java.security.PrivilegedAction;, + private static final boolean USE_KEYMANAGER_FACTORY;, + boolean useKeyManagerFactory = false;, + useKeyManagerFactory = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {, + @Override, + public Boolean run() {, + return SystemPropertyUtil.getBoolean(, + "io.netty.handler.ssl.openssl.useKeyManagerFactory", true);, + }, + });,
[+++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxy.java, + .childOption(ChannelOption.AUTO_READ, false), + .bind(localPort).sync().channel().closeFuture().sync();, +++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxy.java, + .childOption(ChannelOption.AUTO_READ, false), + .bind(localPort).sync().channel().closeFuture().sync();, +++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxyBackendHandler.java, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelFutureListener;, + ctx.read();, + public void inboundBufferUpdated(final ChannelHandlerContext ctx, ByteBuf in) throws Exception {, + inboundChannel.flush().addListener(new ChannelFutureListener() {, + @Override, + public void operationComplete(ChannelFuture future) throws Exception {, + if (future.isSuccess()) {, + ctx.channel().read();, + } else {, + future.channel().close();, + }, + }, + });, +++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxy.java, + .childOption(ChannelOption.AUTO_READ, false), + .bind(localPort).sync().channel().closeFuture().sync();, +++ b/example/src/main/java/io/netty/example/proxy/HexDumpProxyBackendHandler.java, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelFutureListener;, + ctx.read();, + public void inboundBufferUpdated(final ChannelHandlerContext ctx, ByteBuf in) throws Exception {, + inboundChannel.flush().addListener(new ChannelFutureListener() {, + @Override, + public
[+++ b/all/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR5-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ /dev/null]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + try {, + // This call will create a stream for streamDependency if necessary., + // For this reason it must be done before notifying the listener., + stream.setPriority(streamDependency, weight, exclusive);, + } catch (ClosedStreamCreationException ignored) {, + // It is possible that either the stream for this frame or the parent stream is closed., + // In this case we should ignore the exception and allow the frame to be sent., + }, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, + try {, + // This call will create a stream for streamDependency if necessary., + // For this
[+++ b/all/pom.xml, +++ b/all/pom.xml, +++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E> {, +, + public ObjectArray(E[] array, int offset, int length) {, + super(array, offset, length);, + }, +, + @Override, + public E[] array() {, + return (E[]) super.array();, + }, +}, +++ b/all/pom.xml, +++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E> {, +, + public ObjectArray(E[] array, int offset, int length) {, + super(array, offset, length);, + }, +, + @Override, + public E[] array() {, + return (E[]) super.array();, + }, +}, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return writerIndex > readerIndex;,
[+++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, + switch (val & 3) {, + case ST_UNUSED:, + return allocateRunSimple(normCapacity, curIdx, val);, + case ST_BRANCH:, + final int nextIdxLeft = curIdx << 1;, + final int nextValLeft = memoryMap[nextIdxLeft];, + final boolean recurseLeft;, + switch (nextValLeft & 3) {, + case ST_UNUSED:, + return allocateRunSimple(normCapacity, nextIdxLeft, nextValLeft);, + case ST_BRANCH:, + recurseLeft = true;, + break;, + default:, + recurseLeft = false;, + }, +, + final int nextIdxRight = nextIdxLeft ^ 1;, + final int nextValRight = memoryMap[nextIdxRight];, + final boolean recurseRight;, + switch (nextValRight & 3) {, + case ST_UNUSED:, + return allocateRunSimple(normCapacity,
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, + ByteBuf frameHeader = null;, + Http2Flags flags = new Http2Flags();, + flags.endOfStream(false);, + flags.paddingPresent(false);, + // Fast path to write frames of payload size maxFrameSize first., + if (remainingData > maxFrameSize) {, + frameHeader = ctx.alloc().buffer(FRAME_HEADER_LENGTH);, + writeFrameHeaderInternal(frameHeader, maxFrameSize, DATA, flags, streamId);, + // Write the header., + ctx.write(frameHeader.retainedSlice(), promiseAggregator.newPromise());, +, + // Write the payload., + ctx.write(data.readRetainedSlice(maxFrameSize), promiseAggregator.newPromise());, +, + remainingData -= maxFrameSize;, + // Stop iterating if remainingData == maxFrameSize so we can take care of reference counts below., + } while (remainingData > maxFrameSize);, + }, +, + if (padding == 0) {,
[+++ b/pom.xml, + <version>[3.0.5,)</version>]
[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, + public <V> ProgressivePromise<V> newProgressivePromise(long total) {, + return new DefaultProgressivePromise<V>(this, total);, + }, +, + @Override, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, + public <V> ProgressivePromise<V> newProgressivePromise(long total) {, + return new DefaultProgressivePromise<V>(this, total);, + }, +, + @Override, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, + public <V> ProgressivePromise<V> newProgressivePromise(long total) {, + return new DefaultProgressivePromise<V>(this, total);, + }, +, + @Override, +++ /dev/null, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultFutureListeners.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file
[+++ b/pom.xml, + <test.jvm.argLine>, + -server , + -Dio.netty.resourceLeakDetection, + -dsa -da -ea:io.netty..., + -XX:+AggressiveOpts, + -XX:+TieredCompilation, + -XX:+UseBiasedLocking, + -XX:+UseFastAccessorMethods, + -XX:+UseStringCache, + -XX:+OptimizeStringConcat, + -XX:+HeapDumpOnOutOfMemoryError, + </test.jvm.argLine>, + <argLine>${test.jvm.argLine}</argLine>]
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketConnectTest.java, +import io.netty.testsuite.util.TestUtils;, +import io.netty.util.NetUtil;, + sc = sb.bind(NetUtil.LOCALHOST, TestUtils.getFreePort()).syncUninterruptibly().channel();, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketConnectTest.java, +import io.netty.testsuite.util.TestUtils;, +import io.netty.util.NetUtil;, + sc = sb.bind(NetUtil.LOCALHOST, TestUtils.getFreePort()).syncUninterruptibly().channel();, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketMultipleConnectTest.java, +import io.netty.testsuite.util.TestUtils;, +import io.netty.util.NetUtil;, + sc = sb.bind(NetUtil.LOCALHOST, TestUtils.getFreePort()).syncUninterruptibly().channel();, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketConnectTest.java, +import io.netty.testsuite.util.TestUtils;, +import io.netty.util.NetUtil;, + sc = sb.bind(NetUtil.LOCALHOST, TestUtils.getFreePort()).syncUninterruptibly().channel();, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketMultipleConnectTest.java, +import io.netty.testsuite.util.TestUtils;, +import io.netty.util.NetUtil;, + sc = sb.bind(NetUtil.LOCALHOST, TestUtils.getFreePort()).syncUninterruptibly().channel();, +++ b/transport-native-epoll/src/test/java/io/netty/channel/epoll/EpollSpliceTest.java, +import io.netty.testsuite.util.TestUtils;, +import io.netty.util.NetUtil;, + final Channel sc = bs.bind(NetUtil.LOCALHOST, TestUtils.getFreePort()).syncUninterruptibly().channel();, + Channel pc = bs2.bind(NetUtil.LOCALHOST, TestUtils.getFreePort()).syncUninterruptibly().channel();, + Channel sc = bs.bind(NetUtil.LOCALHOST, TestUtils.getFreePort()).syncUninterruptibly().channel();]
[+++ b/codec/src/main/java/io/netty/handler/codec/marshalling/ContextBoundUnmarshallerProvider.java, + Attribute<Unmarshaller> attr = ctx.channel().attr(UNMARSHALLER);, +++ b/codec/src/main/java/io/netty/handler/codec/marshalling/ContextBoundUnmarshallerProvider.java, + Attribute<Unmarshaller> attr = ctx.channel().attr(UNMARSHALLER);, +++ b/handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java, +import io.netty.channel.Channel;, + Channel channel = ctx.channel();, + ChannelConfig config = channel.config();, + channel.attr(READ_SUSPENDED).set(false);, + channel.attr(READ_SUSPENDED).set(false);, + channel.read();, + Channel channel = ctx.channel();, + channel.attr(READ_SUSPENDED).set(false);, + channel.config().setAutoRead(true);, + Channel channel = ctx.channel();, + ChannelConfig config = channel.config();, + channel.attr(READ_SUSPENDED).set(true);, + Attribute<Runnable> attr = channel.attr(REOPEN_TASK);, + Boolean suspended = ctx.channel().attr(READ_SUSPENDED).get();, +++ b/codec/src/main/java/io/netty/handler/codec/marshalling/ContextBoundUnmarshallerProvider.java, + Attribute<Unmarshaller> attr = ctx.channel().attr(UNMARSHALLER);, +++ b/handler/src/main/java/io/netty/handler/traffic/AbstractTrafficShapingHandler.java, +import io.netty.channel.Channel;, + Channel channel = ctx.channel();, + ChannelConfig config = channel.config();, + channel.attr(READ_SUSPENDED).set(false);, + channel.attr(READ_SUSPENDED).set(false);, + channel.read();, + Channel channel = ctx.channel();, + channel.attr(READ_SUSPENDED).set(false);,
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +// macro to calculate the length of a sockaddr_un struct for a given path length., +// see sys/un.h#SUN_LEN, this is modified to allow nul bytes, +#define _UNIX_ADDR_LENGTH(path_len) (((struct sockaddr_un *) 0)->sun_path) + path_len, +, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_bindDomainSocket(JNIEnv* env, jclass clazz, jint fd, jbyteArray socketPath) {, + const jbyte* socket_path = (*env)->GetByteArrayElements(env, socketPath, 0);, + jint socket_path_len = (*env)->GetArrayLength(env, socketPath);, + if (socket_path_len > sizeof(addr.sun_path)) {, + socket_path_len = sizeof(addr.sun_path);, + }, + memcpy(addr.sun_path, socket_path, socket_path_len);, + int res = bind(fd, (struct sockaddr*) &addr, _UNIX_ADDR_LENGTH(socket_path_len));, + (*env)->ReleaseByteArrayElements(env, socketPath, socket_path, 0);, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_connectDomainSocket(JNIEnv* env, jclass clazz,
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramTest.java, +import io.netty.bootstrap.Bootstrap;, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, +import io.netty.testsuite.transport.socket.SocketTestPermutation.Factory;, +import io.netty.testsuite.util.TestUtils;, +import io.netty.util.SocketAddresses;, +import java.lang.reflect.Method;, +import java.util.List;, +import java.util.Map.Entry;, +import org.junit.Rule;, +import org.junit.rules.TestName;, + private static final List<Entry<Factory<Bootstrap>, Factory<Bootstrap>>> COMBO =, + SocketTestPermutation.datagram();, + @Rule, + public final TestName testName = new TestName();, + protected final InternalLogger logger = InternalLoggerFactory.getInstance(getClass());, +, + protected volatile Bootstrap sb;, + protected volatile Bootstrap cb;, + protected volatile InetSocketAddress addr;, +, + protected void run() throws Exception {, + int i = 0;, + for (Entry<Factory<Bootstrap>, Factory<Bootstrap>> e: COMBO) {, + sb = e.getKey().newInstance();, + cb = e.getValue().newInstance();, + addr = new
[+++ b/transport/src/test/java/io/netty/channel/CoalescingBufferQueueTest.java, +import io.netty.util.CharsetUtil;, + cat = Unpooled.wrappedBuffer("cat".getBytes(CharsetUtil.US_ASCII));, + mouse = Unpooled.wrappedBuffer("mouse".getBytes(CharsetUtil.US_ASCII));, + assertEquals("catmouse", dequeue(8, aggregatePromise));, + assertEquals("catm", dequeue(4, newPromise()));, + assertEquals("ouse", dequeue(4, newPromise()));, + assertEquals("catm", dequeue(4, aggregatePromise));, + assertEquals("ouse", dequeue(Integer.MAX_VALUE, aggregatePromise));, + assertEquals("", dequeue(Integer.MAX_VALUE, aggregatePromise));, + assertEquals("", dequeue(Integer.MAX_VALUE, aggregatePromise));, + ByteBuf empty = Unpooled.buffer(0, 1);, + assertEquals("cat", dequeue(3, aggregatePromise));, + assertEquals("catmouse", dequeue(8, aggregatePromise));, +, + private String dequeue(int numBytes, ChannelPromise aggregatePromise) {, + ByteBuf removed = writeQueue.remove(numBytes, aggregatePromise);, + String result = removed.toString(CharsetUtil.US_ASCII);, + ReferenceCountUtil.safeRelease(removed);, + return result;, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketProtocolHandler.java, + ctx.fireExceptionCaught(cause);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketProtocolHandler.java, + ctx.fireExceptionCaught(cause);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandler.java, + ctx.fireExceptionCaught(cause);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java, + if (byteBuf.nioBufferCount() == 1) {, + ByteBuffer byteBuffer = byteBuf.nioBuffer();, + } else {, + ByteBuffer[] byteBuffers = byteBuf.nioBuffers();, + while (written < length) {, + written += fileChannel.write(byteBuffers);, + }, + }, +]
[+++ b/common/src/main/java/io/netty/util/concurrent/PromiseNotifier.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +, + * @param <V> the type of value returned by the future, + * @param <F> the type of future, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(PromiseNotifier.class);, + checkNotNull(promises, "promises");, + if (!p.trySuccess(result)) {, + logger.warn("Failed to mark a promise as success because it is done already: {}", p);, + }, + if (!p.tryFailure(cause)) {, + logger.warn("Failed to mark a promise as failure because it's done already: {}", p, cause);, + }, +++ b/common/src/main/java/io/netty/util/concurrent/PromiseNotifier.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +, + * @param <V>
[+++ b/all/pom.xml, + <version>4.1.22.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.22.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.22.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.22.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.22.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, + <version>4.1.22.Final-SNAPSHOT</version>, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/package-info.java, + * <h3>How to run the tests on Ubuntu</h3>, + * <p>01. Add <tt>ppa:twisted-dev/ppa</tt> to your system's Software Sources, + * <p>02. Install Twisted V11: <tt>sudo apt-get install python-twisted</tt>, + * <p>03. Intall Python Setup Tools: <tt>sudo apt-get install python-setuptools</tt>, + * <p>04. Install AutoBahn: <tt>sudo easy_install Autobahn</tt>. If you already have Autobahn installed, you may need, + * to upgrade it: <tt>sudo easy_install --upgrade Autobahn</tt>. Make suer v0.4.10 is installed., + * <p>05. Get AutoBahn testsuite source code: <tt>git clone git@github.com:tavendo/AutobahnPython.git</tt>, + * <p>06. Go to AutoBahn directory: <tt>cd AutobahnPython</tt>, + *
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameCodecTest.java, + Assume.assumeTrue(ReflectionUtil.trySetAccessible(constructor, true) == null);, + Assume.assumeTrue(ReflectionUtil.trySetAccessible(constructor, true) == null);, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2FrameCodecTest.java, + Assume.assumeTrue(ReflectionUtil.trySetAccessible(constructor, true) == null);, + Assume.assumeTrue(ReflectionUtil.trySetAccessible(constructor, true) == null);, +++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java, + private static final boolean IS_EXPLICIT_TRY_REFLECTION_SET_ACCESSIBLE = explicitTryReflectionSetAccessible0();, +, + // We always want to try using Unsafe as the access still works on java9 as well and, + // we need it for out native-transports and many optimizations., + Throwable cause = ReflectionUtil.trySetAccessible(unsafeField, false);, + Throwable cause = ReflectionUtil.trySetAccessible(constructor, true);, + Throwable cause = ReflectionUtil.trySetAccessible(unalignedMethod, true);, + private static boolean explicitTryReflectionSetAccessible0() {, + // we disable reflective access, + return SystemPropertyUtil.getBoolean("io.netty.tryReflectionSetAccessible", javaVersion()
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/StreamBufferingEncoderTest.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_MAX_FRAME_SIZE;, +import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_PRIORITY_WEIGHT;, +import static io.netty.handler.codec.http2.Http2CodecUtil.SMALLEST_MAX_CONCURRENT_STREAMS;, +import static io.netty.handler.codec.http2.Http2Error.CANCEL;, +import static io.netty.handler.codec.http2.Http2Stream.State.HALF_CLOSED_LOCAL;, +import static org.junit.Assert.assertEquals;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.anyLong;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.never;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, + for (Object a: invocation.getArguments()) {, + if (a instanceof ByteBuf) {, + ((ByteBuf) a).release();, + }, + }, +]
[+++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, + * Creates a new buffer which wraps the specified memory address. If {@code doFree} is true the, + * memoryAddress will automatically be freed once the reference count of the {@link ByteBuf} reaches {@code 0}., + */, + public static ByteBuf wrappedBuffer(long memoryAddress, int size, boolean doFree) {, + return new WrappedUnpooledUnsafeDirectByteBuf(ALLOC, memoryAddress, size, doFree);, + }, +, + /**, +++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, + * Creates a new buffer which wraps the specified memory address. If {@code doFree} is true the, + * memoryAddress will automatically be freed once the reference count of the {@link ByteBuf} reaches
[+++ b/codec/src/test/java/io/netty/handler/codec/compression/LzmaFrameEncoderTest.java]
[+++ b/handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRule.java, + final InetAddress inetAddress = remoteAddress.getAddress();, + if (inetAddress instanceof Inet4Address) {, + int ipAddress = ipToInt((Inet4Address) inetAddress);, + return false;, + }, + final InetAddress inetAddress = remoteAddress.getAddress();, + if (inetAddress instanceof Inet6Address) {, + BigInteger ipAddress = ipToInt((Inet6Address) inetAddress);, + return false;, + }, +++ b/handler/src/main/java/io/netty/handler/ipfilter/IpSubnetFilterRule.java, + final InetAddress inetAddress = remoteAddress.getAddress();, + if (inetAddress instanceof Inet4Address) {, + int ipAddress = ipToInt((Inet4Address) inetAddress);, + return false;, + }, + final InetAddress inetAddress = remoteAddress.getAddress();, + if (inetAddress instanceof Inet6Address) {, + BigInteger ipAddress = ipToInt((Inet6Address) inetAddress);, + return false;, + }, +++ b/handler/src/test/java/io/netty/handler/ipfilter/IpSubnetFilterTest.java, +
[+++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultNioSctpChannelConfig.java, + * The default {@link NioSctpChannelConfig} implementation for SCTP., +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultNioSctpChannelConfig.java, + * The default {@link NioSctpChannelConfig} implementation for SCTP., +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpServerChannelConfig.java, + * The default {@link SctpServerChannelConfig} implementation for SCTP., +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultNioSctpChannelConfig.java, + * The default {@link NioSctpChannelConfig} implementation for SCTP., +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultSctpServerChannelConfig.java, + * The default {@link SctpServerChannelConfig} implementation for SCTP., +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/NioSctpChannelConfig.java, +import io.netty.channel.ChannelConfig;, + * The {@link SctpChannelConfig} for a NIO SCTP/IP {@link SctpChannel}., + * In addition to the options provided by {@link ChannelConfig} and {@link SctpChannelConfig},, + * {@link NioSctpChannelConfig} allows the following options in the option map:, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/DefaultNioSctpChannelConfig.java, +
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/DefaultHttpHeadersTest.java, +import static org.junit.Assert.*;, + public void testStringKeyRetrievedAsAsciiString() {, + final HttpHeaders headers = new DefaultHttpHeaders(false);, +, + // Test adding String key and retrieving it using a AsciiString key, + final String connection = "keep-alive";, + headers.add("Connection", connection);, +, + // Passes, + final String value = headers.getAsString(HttpHeaderNames.CONNECTION.toString());, + assertNotNull(value);, + assertEquals(connection, value);, +, + // Passes, + final String value2 = headers.getAsString(HttpHeaderNames.CONNECTION);, + assertNotNull(value2);, + assertEquals(connection, value2);, + }, +, + @Test, + public void testAsciiStringKeyRetrievedAsString() {, + final HttpHeaders headers = new DefaultHttpHeaders(false);, +, + // Test adding AsciiString key and retrieving it using a
[+++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java, + int free() {, + return free(tinySubPageDirectCaches) +, + free(smallSubPageDirectCaches) +, + free(normalDirectCaches) +, + free(tinySubPageHeapCaches) +, + free(smallSubPageHeapCaches) +, + private static int free(MemoryRegionCache<?>[] caches) {, + return 0;, + int numFreed = 0;, + for (int i = 0; i < caches.length; i++) {, + numFreed += free(caches[i]);, + return numFreed;, + }, +, + private static int free(MemoryRegionCache<?> cache) {, + if (cache == null) {, + return 0;, + }, + return cache.free();, + public int free() {, + int numFreed = 0;, + if (freeEntry(entries[i])) {, + numFreed++;, + } else {,
[+++ b/license/LICENSE.webbit.txt, +(BSD License: http://www.opensource.org/licenses/bsd-license), +, +Copyright (c) 2011, Joe Walnes, Aslak Hellesy and contributors, +All rights reserved., +, +Redistribution and use in source and binary forms, with or , +without modification, are permitted provided that the , +following conditions are met:, +, +* Redistributions of source code must retain the above , + copyright notice, this list of conditions and the , + following disclaimer., +, +* Redistributions in binary form must reproduce the above, + copyright notice, this list of conditions and the , + following disclaimer in the documentation and/or other, + materials provided with the
[+++ b/pom.xml, + <!-- Servlet API - completely optional -->, + <dependency>, + <groupId>javax.servlet</groupId>, + <artifactId>servlet-api</artifactId>, + <version>2.5</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, +, +++ b/pom.xml, + <!-- Servlet API - completely optional -->, + <dependency>, + <groupId>javax.servlet</groupId>, + <artifactId>servlet-api</artifactId>, + <version>2.5</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, +, +++ b/src/main/java/org/jboss/netty/channel/local/LocalAddress.java, +/*, + * JBoss, Home of Professional Open Source, + * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors, + * by the @authors tag. See the copyright.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is
[+++ b/transport-native-epoll/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>]
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/AbstractSocketShutdownOutputByPeerTest.java, +/*, + * Copyright 2019 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompFrame.java, + return "DefaultStompFrame{" +]
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/SocketSslEchoTest.java, + protected enum RenegotiationType {, + protected static class Renegotiation {, + static final Renegotiation NONE = new Renegotiation(RenegotiationType.NONE, null);, +, + final RenegotiationType type;, + final String cipherSuite;, +, + Renegotiation(RenegotiationType type, String cipherSuite) {, + this.type = type;, + this.cipherSuite = cipherSuite;, + }, +, + @Override, + public String toString() {, + if (type == RenegotiationType.NONE) {, + return "NONE";, + }, +, + return type + "(" + cipherSuite + ')';, + }, + }, +, + Renegotiation r;, + if (rt == RenegotiationType.NONE) {, + r = Renegotiation.NONE;, + } else {,
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + if (close) {, + // There is nothing left to read as we received an EOF., + readPending = false;, + }, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + if (close) {, + // There is nothing left to read as we received an EOF., + readPending = false;, + }, +++ b/transport-native-kqueue/src/main/java/io/netty/channel/kqueue/AbstractKQueueStreamChannel.java, + if (close) {, + // There is nothing left to read as we received an EOF., + readPending = false;, + }, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + if (close) {, + // There is nothing left to read as we received an EOF., + readPending = false;, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java]
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + invokeLater(new Runnable() {, + @Override, + public void run() {, + });, + }, + invokeLater(new Runnable() {, + @Override, + public void run() {, + });, + }, + invokeLater(new Runnable() {, + @Override, + public void run() {, + }, + });, + } catch (final Exception e) {, + invokeLater(new Runnable() {, + @Override, + public void run() {, + pipeline.fireExceptionCaught(e);, + }, + });, + // Flush immediately only when there's no pending flush., + // If there's a pending flush operation, event loop will call flushNow() later,, + // and thus
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + private Runnable invokeReadTask;, + private Runnable invokeFlushTask;, + final DefaultChannelHandlerContext next = this.next;, + EventExecutor executor = next.executor();, + next.invokeExceptionCaught(cause);, + next.invokeExceptionCaught(cause);, +, + return this;, + private void invokeExceptionCaught(final Throwable cause) {, + public ChannelFuture bind(final SocketAddress localAddress, final ChannelPromise promise) {, + final DefaultChannelHandlerContext next = findContextOutbound();, + EventExecutor executor = next.executor();, + next.invokeBind(localAddress, promise);, + next.invokeBind(localAddress, promise);, +, + private void invokeBind(SocketAddress localAddress, ChannelPromise promise) {, + public ChannelFuture connect(, + final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) {, +, + final DefaultChannelHandlerContext next = findContextOutbound();, + EventExecutor executor = next.executor();,
[+++ b/pom.xml, + <jar destfile="${project.build.directory}/${project.build.finalName}.jar">, + </jar>, + <jar destfile="${project.build.directory}/${project.build.finalName}-sources.jar">, + </jar>]
[+++ b/all/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.15.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + /**, + * Allocate a new direct {@link ByteBuffer} with the given initialCapacity., + */, + protected ByteBuffer allocateDirect(int initialCapacity) {, + return ByteBuffer.allocateDirect(initialCapacity);, + }, +, + ByteBuffer newBuffer = allocateDirect(newCapacity);, + ByteBuffer newBuffer = allocateDirect(newCapacity);, + src.isDirect()? allocateDirect(length) : ByteBuffer.allocate(length);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledDirectByteBuf.java, + /**, + * Allocate a new direct {@link ByteBuffer} with the given initialCapacity., + */, + protected ByteBuffer allocateDirect(int initialCapacity) {, + return ByteBuffer.allocateDirect(initialCapacity);, + }, +, + ByteBuffer newBuffer = allocateDirect(newCapacity);, + ByteBuffer newBuffer = allocateDirect(newCapacity);, + src.isDirect()? allocateDirect(length) : ByteBuffer.allocate(length);, +++ b/buffer/src/main/java/io/netty/buffer/UnpooledUnsafeDirectByteBuf.java, + setByteBuffer(allocateDirect(initialCapacity));, + /**, + * Allocate
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import io.netty.util.internal.ThrowableUtil;, + private static final ClosedChannelException CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(, + new ClosedChannelException(), WebSocketClientHandshaker.class, "processHandshake(...)");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import io.netty.util.internal.ThrowableUtil;, + private static final ClosedChannelException CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(, + new ClosedChannelException(), WebSocketClientHandshaker.class, "processHandshake(...)");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +import io.netty.util.internal.ThrowableUtil;, + private static final ClosedChannelException CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(, + new ClosedChannelException(), WebSocketServerHandshaker.class, "handshake(...)");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import io.netty.util.internal.ThrowableUtil;, + private static final ClosedChannelException CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(, + new ClosedChannelException(), WebSocketClientHandshaker.class, "processHandshake(...)");, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, +import io.netty.util.internal.ThrowableUtil;, + private static final ClosedChannelException CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(, + new ClosedChannelException(), WebSocketServerHandshaker.class, "handshake(...)");, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +import io.netty.util.internal.ThrowableUtil;, + private static final SpdyProtocolException PROTOCOL_EXCEPTION = ThrowableUtil.unknownStackTrace(, + new
[+++ b/all/pom.xml, +++ b/all/pom.xml, +++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E> {, +, + public ObjectArray(E[] array, int offset, int length) {, + super(array, offset, length);, + }, +, + @Override, + public E[] array() {, + return (E[]) super.array();, + }, +}, +++ b/all/pom.xml, +++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E> {, +, + public ObjectArray(E[] array, int offset, int length) {, + super(array, offset, length);, + }, +, + @Override, + public E[] array() {, + return (E[]) super.array();, + }, +}, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return writerIndex > readerIndex;,
[+++ b/all/pom.xml, + <artifactId>netty-resolver</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-resolver-dns</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/all/pom.xml, + <artifactId>netty-resolver</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-resolver-dns</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/pom.xml, + <module>resolver</module>, + <module>resolver-dns</module>, +++ b/all/pom.xml, + <artifactId>netty-resolver</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-resolver-dns</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, +++ b/pom.xml, +
[+++ b/README.md, +, +## Usage with JDK 9, +, +Netty can be used in modular JDK9 applications as a collection of automatic modules. The module names follow the, +reverse-DNS style, and are derived from subproject names rather than root packages due to historical reasons. They, +are listed below:, +, + * `io.netty.buffer`, + * `io.netty.codec`, + * `io.netty.codec.dns`, + * `io.netty.codec.haproxy`, + * `io.netty.codec.http`, + * `io.netty.codec.http2`, + * `io.netty.codec.memcache`, + * `io.netty.codec.mqtt`, + * `io.netty.codec.redis`, + * `io.netty.codec.smtp`, + * `io.netty.codec.socks`, + * `io.netty.codec.stomp`, + * `io.netty.codec.xml`, + * `io.netty.common`, + * `io.netty.handler`, + * `io.netty.handler.proxy`, + *
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java, + cleanFiles();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java, + cleanFiles();, +++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadServerHandler.java, + try {, + } finally {, + data.release();, + }]
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + this(alloc, direct, maxNumComponents, buffers, 0, buffers.length);, + }, +, + CompositeByteBuf(, + ByteBufAllocator alloc, boolean direct, int maxNumComponents, ByteBuf[] buffers, int offset, int len) {, + addComponents0(false, 0, buffers, offset, len);, + addComponents0(increaseWriterIndex, components.size(), buffers, 0, buffers.length);, + addComponents0(false, cIndex, buffers, 0, buffers.length);, + private int addComponents0(boolean increaseWriterIndex, int cIndex, ByteBuf[] buffers, int offset, int len) {, + int i = offset;, + while (i < len) {, + for (; i < len; ++i) {, + return addComponents0(increaseIndex, cIndex, col.toArray(new ByteBuf[col.size()]), 0 , col.size());, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + this(alloc, direct, maxNumComponents, buffers, 0, buffers.length);, + },
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + channel.pipeline().get(HttpResponseDecoder.class).setSingleDecode(true);, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + channel.pipeline().get(HttpResponseDecoder.class).setSingleDecode(true);, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java, + channel.pipeline().get(HttpResponseDecoder.class).setSingleDecode(true);, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + channel.pipeline().get(HttpResponseDecoder.class).setSingleDecode(true);, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java, + channel.pipeline().get(HttpResponseDecoder.class).setSingleDecode(true);, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + channel.pipeline().get(HttpResponseDecoder.class).setSingleDecode(true);, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + channel.pipeline().get(HttpResponseDecoder.class).setSingleDecode(true);, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java, + channel.pipeline().get(HttpResponseDecoder.class).setSingleDecode(true);, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + channel.pipeline().get(HttpResponseDecoder.class).setSingleDecode(true);, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java, + channel.pipeline().get(HttpResponseDecoder.class).setSingleDecode(true);, +]
[+++ b/pom.xml, + <tcnative.version>2.0.0.Final</tcnative.version>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketUtil.java, + ByteBuf encoded = Base64.encode(encodedData);, + String encodedString = encoded.toString(CharsetUtil.UTF_8);, + encoded.release();, + return encodedString;]
[+++ b/buffer/src/main/java/io/netty/buffer/WrappedByteBuf.java, +class WrappedByteBuf extends ByteBuf {, +++ b/buffer/src/main/java/io/netty/buffer/WrappedByteBuf.java, +class WrappedByteBuf extends ByteBuf {, +++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java, + final boolean disabled = SystemPropertyUtil.getBoolean("io.netty.noResourceLeakDetection", false);, + logger.debug("-Dio.netty.noResourceLeakDetection: {}", disabled);, + logger.warn(, + "-Dio.netty.noResourceLeakDetection is deprecated. Use '-D{}={}' instead.",, + PROP_LEVEL, DEFAULT_LEVEL.name().toLowerCase());, +, + Level defaultLevel = disabled? Level.DISABLED : DEFAULT_LEVEL;, + String levelStr = SystemPropertyUtil.get(PROP_LEVEL, defaultLevel.name()).trim().toUpperCase();, + * @deprecated Use {@link #setLevel(ResourceLeakDetector.Level)} instead., + */, + @Deprecated, + public static void setEnabled(boolean enabled) {, + setLevel(enabled? Level.SIMPLE : Level.DISABLED);, + }, +, + /**, + * Returns {@code true} if resource leak detection is enabled., + */, + public static boolean
[+++ b/pom.xml, + <version>3.2.0.ALPHA1-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/.gitignore, +, +# /, +/.project, +/.classpath, +/.settings, +/target, +/reports]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java, + } else if (that.getPath() == null && getPath() != null) {, + } else if (that.getDomain() == null && getDomain() != null) {, + } else if (c.getPath() == null && getPath() != null) {, + } else if (c.getDomain() == null && getDomain() != null) {]
[+++ b/src/docbook/master.xml, +++ b/src/docbook/master.xml, +++ b/src/docbook/module/architecture.xml, + For more information, please refer to the, + <ulink url="&API;buffer/package-summary.html#package_description"><literal>org.jboss.netty.buffer</literal> package description</ulink>., +++ b/src/docbook/master.xml, +++ b/src/docbook/module/architecture.xml, + For more information, please refer to the, + <ulink url="&API;buffer/package-summary.html#package_description"><literal>org.jboss.netty.buffer</literal> package description</ulink>., +++ /dev/null, +++ b/src/docbook/master.xml, +++ b/src/docbook/module/architecture.xml, + For more information, please refer to the, + <ulink url="&API;buffer/package-summary.html#package_description"><literal>org.jboss.netty.buffer</literal> package description</ulink>., +++ /dev/null, +++ b/src/main/java/org/jboss/netty/buffer/package-info.java, + * Abstraction of a byte buffer - the fundamental data structure, + * to represent a low-level binary and text message., + *, + * Netty uses its own buffer API instead of NIO {@link java.nio.ByteBuffer} to, + *
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java, + cbb.addComponents(byteBuf, buffer);, + cbb.writerIndex(byteBuf.readableBytes() + buffer.readableBytes());]
[+++ b/common/src/main/java/io/netty/util/AsciiString.java, + if (!equalsIgnoreCase(value[i], rhs.value[j])) {, +++ b/common/src/main/java/io/netty/util/AsciiString.java, + if (!equalsIgnoreCase(value[i], rhs.value[j])) {, +++ b/common/src/test/java/io/netty/util/AsciiStringCharacterTest.java, +, + // Test variations (Ascii + String, Ascii + Ascii, String + Ascii), + assertThat(AsciiString.contentEqualsIgnoreCase(new AsciiString("FoO"), "fOo"), is(true));, + assertThat(AsciiString.contentEqualsIgnoreCase(new AsciiString("FoO"), new AsciiString("fOo")), is(true));, + assertThat(AsciiString.contentEqualsIgnoreCase("FoO", new AsciiString("fOo")), is(true));, +, + // Test variations (Ascii + String, Ascii + Ascii, String + Ascii), + assertThat(AsciiString.contentEqualsIgnoreCase(new AsciiString("FoO"), "bAr"), is(false));, + assertThat(AsciiString.contentEqualsIgnoreCase(new AsciiString("FoO"), new AsciiString("bAr")), is(false));, + assertThat(AsciiString.contentEqualsIgnoreCase("FoO", new AsciiString("bAr")), is(false));]
[+++ b/all/pom.xml, + <version>4.0.0.Final</version>, +++ b/all/pom.xml, + <version>4.0.0.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Final</version>, +++ b/all/pom.xml, + <version>4.0.0.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Final</version>, +++ b/all/pom.xml, + <version>4.0.0.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Final</version>, +++ b/all/pom.xml, + <version>4.0.0.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Final</version>, +++ b/codec/pom.xml, + <version>4.0.0.Final</version>, +++ b/all/pom.xml, + <version>4.0.0.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.Final</version>, +++ b/codec/pom.xml, + <version>4.0.0.Final</version>, +++ b/common/pom.xml, + <version>4.0.0.Final</version>, +++ b/all/pom.xml, + <version>4.0.0.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Final</version>, +++ b/codec-socks/pom.xml, +
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +#include <limits.h>, +, +JNIEXPORT jlong JNICALL Java_io_netty_channel_epoll_Native_ssizeMax(JNIEnv* env, jclass clazz) {, + return SSIZE_MAX;, +}, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +#include <limits.h>, +, +JNIEXPORT jlong JNICALL Java_io_netty_channel_epoll_Native_ssizeMax(JNIEnv* env, jclass clazz) {, + return SSIZE_MAX;, +}, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +jlong Java_io_netty_channel_epoll_Native_ssizeMax(JNIEnv* env, jclass clazz);, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +#include <limits.h>, +, +JNIEXPORT jlong JNICALL Java_io_netty_channel_epoll_Native_ssizeMax(JNIEnv* env, jclass clazz) {, + return SSIZE_MAX;, +}, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.h, +jlong Java_io_netty_channel_epoll_Native_ssizeMax(JNIEnv* env, jclass clazz);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/IovArray.java, + return add(addr, offset, len);, + private boolean add(long addr, int offset, int len) {, + return true;, + if (Native.SSIZE_MAX - len < size) {, + // If the size +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java, + if (numBytes < 0) {, + throw new IllegalArgumentException("numBytes must not be negative");, + }, + if (numBytes == 0) {, + return false;, + }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java, + if (numBytes < 0) {, + throw new IllegalArgumentException("numBytes must not be negative");, + }, + if (numBytes == 0) {, + return false;, + }, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoderTest.java, + mockFlowControl(0);, + // Now we ignore the empty bytes inside consumeBytes method, so it will be called once., + verify(localFlow).consumeBytes(eq(ctx), eq(stream), eq(0));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2LocalFlowController.java, + if (numBytes < 0) {,
[+++ b/example/src/main/java/io/netty/example/http2/helloworld/server/HelloWorldHttp2Handler.java, + try {, + flush(ctx);, + } catch (Throwable cause) {, + onError(ctx, cause);, + }]
[+++ b/pom.xml, + <version>[3.0.5,3.1)</version>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java, + if (buf.writableBytes() >= data.readableBytes()) {, + // merge buffers as this is cheaper then a gathering write if the payload is small enough, + buf.writeBytes(data);, + out.add(buf);, + } else {, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import io.netty.channel.CombinedChannelDuplexHandler;, +public final class HttpClientCodec extends CombinedChannelDuplexHandler<HttpResponseDecoder, HttpRequestEncoder>, + implements HttpClientUpgradeHandler.SourceCodec {, + init(new Decoder(maxInitialLineLength, maxHeaderSize, maxChunkSize, validateHeaders), new Encoder());, + p.remove(this);, + inboundHandler().setSingleDecode(singleDecode);, + return inboundHandler().isSingleDecode();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import io.netty.channel.CombinedChannelDuplexHandler;, +public final class HttpClientCodec extends CombinedChannelDuplexHandler<HttpResponseDecoder, HttpRequestEncoder>, + implements HttpClientUpgradeHandler.SourceCodec {, + init(new Decoder(maxInitialLineLength, maxHeaderSize, maxChunkSize, validateHeaders), new Encoder());, + p.remove(this);, + inboundHandler().setSingleDecode(singleDecode);, + return inboundHandler().isSingleDecode();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerCodec.java, +import io.netty.channel.CombinedChannelDuplexHandler;, +public final class HttpServerCodec extends CombinedChannelDuplexHandler<HttpRequestDecoder, HttpResponseEncoder>, + implements HttpServerUpgradeHandler.SourceCodec {, + ctx.pipeline().remove(this);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import io.netty.channel.CombinedChannelDuplexHandler;, +public final class HttpClientCodec extends CombinedChannelDuplexHandler<HttpResponseDecoder, HttpRequestEncoder>, + implements HttpClientUpgradeHandler.SourceCodec {, + init(new Decoder(maxInitialLineLength, maxHeaderSize, maxChunkSize, validateHeaders), new
[+++ b/src/main/java/org/jboss/netty/channel/socket/http/HttpTunnelingChannelHandler.java, +/*, + * JBoss, Home of Professional Open Source, + * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors, + * by the @authors tag. See the copyright.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version., + *, + * This
[+++ b/transport/src/main/java/io/netty/channel/DefaultFileRegion.java, + *, + * Be aware that the {@link FileChannel} will be automatically closed once {@link #refCnt()} returns, + * {@code 0}.]
[+++ b/transport-native-epoll/pom.xml, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-tcnative</artifactId>, + <classifier>${os.detected.classifier}</classifier>, + <scope>test</scope>, + </dependency>, + <dependency>]
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpHeadersTest.java, +, + @Test(expected = NullPointerException.class), + public void testSetNullHeaderValueValidate() {, + HttpHeaders headers = new DefaultHttpHeaders(true);, + headers.set("test", (CharSequence) null);, + }, +, + @Test(expected = NullPointerException.class), + public void testSetNullHeaderValueNotValidate() {, + HttpHeaders headers = new DefaultHttpHeaders(false);, + headers.set("test", (CharSequence) null);, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + BAD_MESSAGE,, + UPGRADED, + break;, + }, + case UPGRADED: {, + // Do not touch anything read - other handler will replace this codec with the upgraded protocol codec to, + // take the trafic over., + break;, + HttpMessage message = this.message;, + this.message = null;, +, + if (!isDecodingRequest()) {, + HttpResponse res = (HttpResponse) message;, + if (res != null && res.getStatus().code() == 101) {, + checkpoint(State.UPGRADED);, + return;, + }, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, + BAD_MESSAGE,, + UPGRADED, + break;, + }, + case UPGRADED: {, + // Do not
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +import io.netty.channel.ChannelInboundHandler;, +import io.netty.channel.ChannelOutboundHandler;, +public class SpdySessionHandler, + extends ChannelHandlerAdapter, + implements ChannelInboundHandler<Object>, ChannelOutboundHandler<Object> {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +import io.netty.channel.ChannelInboundHandler;, +import io.netty.channel.ChannelOutboundHandler;, +public class SpdySessionHandler, + extends ChannelHandlerAdapter, + implements ChannelInboundHandler<Object>, ChannelOutboundHandler<Object> {, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java, +import io.netty.channel.ChannelInboundHandler;, +import io.netty.channel.ChannelOutboundHandler;, + extends ChannelHandlerAdapter, + implements ChannelInboundHandler<INBOUND_IN>, ChannelOutboundHandler<OUTBOUND_IN> {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +import io.netty.channel.ChannelInboundHandler;, +import io.netty.channel.ChannelOutboundHandler;, +public class SpdySessionHandler, + extends ChannelHandlerAdapter, + implements ChannelInboundHandler<Object>, ChannelOutboundHandler<Object> {, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java, +import io.netty.channel.ChannelInboundHandler;, +import io.netty.channel.ChannelOutboundHandler;, + extends ChannelHandlerAdapter, + implements ChannelInboundHandler<INBOUND_IN>, ChannelOutboundHandler<OUTBOUND_IN> {, +++ b/codec/src/main/java/io/netty/handler/codec/StreamToMessageCodec.java, +import io.netty.channel.ChannelInboundHandler;, +import io.netty.channel.ChannelOutboundHandler;, + extends ChannelHandlerAdapter, + implements ChannelInboundHandler<Byte>, ChannelOutboundHandler<OUTBOUND_IN> {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdySessionHandler.java, +import io.netty.channel.ChannelInboundHandler;, +import io.netty.channel.ChannelOutboundHandler;,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, +import io.netty.util.internal.StringUtil;, + addBodyFileUpload(name, file.getName(), file, contentType, isText);, + }, +, + /**, + * Add a file as a FileUpload, + *, + * @param name, + * the name of the parameter, + * @param file, + * the file to be uploaded (if not Multipart mode, only the filename will be included), + * @param filename, + * the filename to use for this File part, empty String will be ignored by, + * the encoder, + * @param contentType, + * the associated contentType for the File, + * @param isText, + *
[+++ b/pom.xml, + <version>0.7.5.201505241946</version>]
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, +, + // a special case ::1:2:3:4:5:d.d.d.d allows 7 colons with an, + // IPv4 ending, otherwise 7 :'s is bad, + if ((numberOfColons != 6 && !doubleColon) ||, + (numberOfColons == 7 && (ipAddress.charAt(startOffset) != ':' ||, + ipAddress.charAt(1 + startOffset) != ':'))) {, + return false;, + }, +, +, + final boolean mustBeZero = compressBegin + compressLength >= 14;, + return currentIndex <= 12 && currentIndex >= 2 && (!mustBeZero || compressBegin < 12) &&, + isValidIPv4MappedSeparators(bytes[currentIndex - 1], bytes[currentIndex - 2], mustBeZero) &&, + PlatformDependent.isZero(bytes, 0, currentIndex - 3);, +++ b/common/src/main/java/io/netty/util/NetUtil.java, +, +
[+++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, + return buf.readSlice(length).order(order);, +++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, + return buf.readSlice(length).order(order);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, + assertEquals(buffer.order(), actualValue.order());]
[+++ b/common/src/main/java/io/netty/util/DomainMappingBuilder.java, + map = new LinkedHashMap<String, V>(initialCapacity);, + return new ImmutableDomainNameMapping<V>(defaultValue, map);, + private final Map<String, V> map;, + final Map<String, V> mapCopy = new LinkedHashMap<String, V>(map.size());, + final String hostname = normalizeHostname(mapping.getKey());, + final V value = mapping.getValue();, + domainNamePatterns[index] = hostname;, + values[index] = value;, + mapCopy.put(hostname, value);, +, + this.map = Collections.unmodifiableMap(mapCopy);, + public Map<String, V> asMap() {, + return map;, +++ b/common/src/main/java/io/netty/util/DomainMappingBuilder.java, + map = new LinkedHashMap<String, V>(initialCapacity);, + return new ImmutableDomainNameMapping<V>(defaultValue, map);, + private final Map<String, V> map;, + final Map<String, V> mapCopy = new LinkedHashMap<String, V>(map.size());, + final String hostname = normalizeHostname(mapping.getKey());,
[+++ b/bom/pom.xml, + <artifactId>netty-transport-native-unix-common</artifactId>, + <version>4.1.13.Final-SNAPSHOT</version>]
[+++ b/testsuite/pom.xml, + <!--, + autobahntestsuite-maven-plugin lacks an option to skip the testsuite,, + so we run the least possible number of tests when skipTests or skipAutobahnTestsuite is set., + -->, + <properties>, + <enabledCase>*</enabledCase>, + </properties>, +, + <profiles>, + <profile>, + <id>skipTests</id>, + <activation>, + <property>, + <name>skipTests</name>, + </property>, + </activation>, + <properties>, + <enabledCase>1.1.1</enabledCase>, + </properties>, + </profile>, + <profile>, + <id>skipAutobahnTestsuite</id>, + <activation>, + <property>, + <name>skipAutobahnTestsuite</name>, + </property>, + </activation>, + <properties>, + <enabledCase>1.1.1</enabledCase>, + </properties>, + </profile>, + </profiles>, +, + <case>${enabledCase}</case>, + <excludeCases/>, +]
[+++ b/transport/src/main/java/io/netty/channel/Channel.java, +import sun.awt.windows.ThemeReader;, +, + /**, + * Return the {@link EventLoop} this {@link Channel} was registered too., + */, + /**, + * Return the {@link ChannelMetadata} of the {@link Channel} which describe the nature of the {@link Channel}., + */, + /**, + * <strong>Caution</strong> for transport implementations use only!, + */, + /**, + * <strong>Unsafe</strong> operations that should <strong>never</strong> be called, + * from user-code. These methods are only provided to implement the actual transport., + */, + /**, + * Return the {@link ChannelHandlerContext} which is directly connected to the outbound of the,
[+++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java, + private static final int ST_ALLOCATED_SUBPAGE = 3;, + // Try the right node first because it is more likely to be ST_UNUSED., + // It is because allocateRunSimple() always chooses the left node., +, + final int nextValLeft = memoryMap[nextIdxLeft];, + final boolean recurseLeft;, +, + switch (nextValLeft & 3) {, + case ST_UNUSED:, + return allocateRunSimple(normCapacity, nextIdxLeft, nextValLeft);, + case ST_BRANCH:, + recurseLeft = true;, + break;, + default:, + recurseLeft = false;, + }, +, + if (recurseRight) {, + long res = branchRun(normCapacity, nextIdxRight);, + if (recurseLeft) {, + return branchRun(normCapacity, nextIdxLeft);, +
[+++ b/buffer/src/main/java/io/netty/buffer/PoolChunkList.java, + return minUsage == Integer.MIN_VALUE ? 1 : minUsage;, + return maxUsage == Integer.MAX_VALUE ? 100 : maxUsage;, +++ b/buffer/src/main/java/io/netty/buffer/PoolChunkList.java, + return minUsage == Integer.MIN_VALUE ? 1 : minUsage;, + return maxUsage == Integer.MAX_VALUE ? 100 : maxUsage;, +++ b/buffer/src/test/java/io/netty/buffer/PooledByteBufAllocatorTest.java, + @Test, + public void testPoolChunkListMetric() {, + for (PoolArenaMetric arenaMetric: PooledByteBufAllocator.DEFAULT.heapArenas()) {, + assertPoolChunkListMetric(arenaMetric);, + }, + }, +, + private static void assertPoolChunkListMetric(PoolArenaMetric arenaMetric) {, + List<PoolChunkListMetric> lists = arenaMetric.chunkLists();, + assertEquals(6, lists.size());, + assertPoolChunkListMetric(lists.get(0), 1, 25);, + assertPoolChunkListMetric(lists.get(1), 1, 50);, + assertPoolChunkListMetric(lists.get(2), 25, 75);, + assertPoolChunkListMetric(lists.get(4), 75, 100);, + assertPoolChunkListMetric(lists.get(5), 100, 100);, + },
[+++ /dev/null, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/handler/codec/rtsp/RtspMethods.java, +/*, + * Copyright 2010 Red Hat, Inc., + *, + * Red Hat licenses this file to you under the Apache License, version 2.0, + * (the "License"); you may not use this file except in compliance with the, + * License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY
[+++ b/buffer/src/main/java/io/netty/buffer/ChannelBuf.java, + * Return {@code true} if the ChannelBuf is pooled., +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuf.java, + * Return {@code true} if the ChannelBuf is pooled., +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +, + // We're not using foreach to avoid creating an iterator., + // noinspection ForLoopReplaceableByForEach, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuf.java, + * Return {@code true} if the ChannelBuf is pooled., +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +, + // We're not using foreach to avoid creating an iterator., + // noinspection ForLoopReplaceableByForEach, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + * {@link URLDecoder#decode(String, String) URLDecoder.decode(s, charset.name())}, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuf.java, + * Return {@code true} if the ChannelBuf is pooled., +++ b/buffer/src/main/java/io/netty/buffer/DefaultCompositeByteBuf.java, +, + // We're
[+++ b/testsuite-shading/pom.xml, + <shadingPrefix2>shaded2</shadingPrefix2>, +, + <id>shade</id>, + <execution>, + <id>shade-1</id>, + <phase>package</phase>, + <goals>, + <goal>shade</goal>, + </goals>, + <configuration>, + <artifactSet>, + <includes>, + <include>${project.groupId}</include>, + </includes>, + </artifactSet>, + <relocations>, + <relocation>, + <pattern>${shadedPackagePrefix}</pattern>, + <shadedPattern>${shadingPrefix2}.${shadedPackagePrefix}</shadedPattern>, + </relocation>, + </relocations>, + </configuration>, + </execution>, + <copy file="${classesShadedNativeDir}/lib${nativeTransportLib}" tofile="${classesShadedNativeDir}/lib${shadingPrefix}_${nativeTransportLib}" />, + <copy file="${classesShadedNativeDir}/lib${nativeTransportLib}" tofile="${classesShadedNativeDir}/lib${shadingPrefix2}_${nativeTransportLib}" />, + <exec executable="install_name_tool" failonerror="true" dir="${project.build.directory}/" resolveexecutable="true">, + <arg value="-id" />, + <arg value="lib${shadingPrefix}_${nativeTransportLib}" />, + <arg value="${classesShadedNativeDir}/lib${shadingPrefix}_${nativeTransportLib}" />, + </exec>, + <!-- We need to adjust the ID used on MacOS so we are sure the correct lib is loaded later on
[+++ b/all/pom.xml, + <version>4.1.21.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.21.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.21.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.21.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.21.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, + <version>4.1.21.Final-SNAPSHOT</version>, +
[+++ b/pom.xml, + </modules>, +, + <profiles>, + <!-- Build all-in-one JAR, xref, Javadoc only on full build -->, + <profile>, + <id>fullbuild</id>, + <modules>, + </profile>, + </profiles>, + <plugin>, + <artifactId>maven-release-plugin</artifactId>, + <version>2.3.1</version>, + <configuration>, + <releaseProfiles>release,fullbuild</releaseProfiles>, + </configuration>, + </plugin>]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import java.util.LinkedHashSet;, +import java.util.Set;, + private static final Set<String> AVAILABLE_CIPHER_SUITES;, + final Set<String> availableCipherSuites = new LinkedHashSet<String>(128);, + AVAILABLE_CIPHER_SUITES = Collections.unmodifiableSet(availableCipherSuites);, + AVAILABLE_CIPHER_SUITES = Collections.emptySet();, + public static Set<String> availableCipherSuites() {, + return AVAILABLE_CIPHER_SUITES;, + }, +, + /**, + * Returns {@code true} if and only if the specified cipher suite is available in OpenSSL., + * Both Java-style cipher suite and OpenSSL-style cipher suite are accepted., + */, + public static boolean isCipherSuiteAvailable(String cipherSuite) {, + String converted = CipherSuiteConverter.toOpenSsl(cipherSuite);, + if (converted != null) {, + cipherSuite = converted;, + }, + return AVAILABLE_CIPHER_SUITES.contains(cipherSuite);,
[+++ b/common/src/main/java/io/netty/util/concurrent/FastThreadLocal.java, +import io.netty.util.internal.PlatformDependent;, + if (setKnownNotUnset(threadLocalMap, value)) {, + setKnownNotUnset(threadLocalMap, value);, + * @return see {@link InternalThreadLocalMap#setIndexedVariable(int, Object)}., + */, + private boolean setKnownNotUnset(InternalThreadLocalMap threadLocalMap, V value) {, + if (threadLocalMap.setIndexedVariable(index, value)) {, + addToVariablesToRemove(threadLocalMap, this);, + return true;, + }, + return false;, + }, +, + /**]
[+++ b/src/docbook/css/jbossorg.css, +.programlisting, .programlistingco pre {, +.programlisting img {, + margin: 0;, + padding: 0;, + vertical-align: middle;, +}, +, +++ b/src/docbook/css/jbossorg.css, +.programlisting, .programlistingco pre {, +.programlisting img {, + margin: 0;, + padding: 0;, + vertical-align: middle;, +}, +, +++ b/src/docbook/module/start.xml, +@&ChannelPipelineCoverage;("all")<co id="example.discard.co1"/>, +public class DiscardServerHandler extends &SimpleChannelHandler; {<co id="example.discard.co2"/>, + public void messageReceived(&ChannelHandlerContext; ctx, &MessageEvent; e) {<co id="example.discard.co3"/>, + public void exceptionCaught(&ChannelHandlerContext; ctx, &ExceptionEvent; e) {<co id="example.discard.co4"/>, + <callout arearefs="example.discard.co1">, + <callout arearefs="example.discard.co2">, + <callout arearefs="example.discard.co3">, + <callout arearefs="example.discard.co4">, + &ChannelFactory;<co id="example.discard2.co1" /> factory =, + new &NioServerSocketChannelFactory;<co id="example.discard2.co2" />(, + &ServerBootstrap; bootstrap = new &ServerBootstrap;<co id="example.discard2.co3"
[+++ b/pom.xml, + <autoDetectFonts>true</autoDetectFonts>, +++ b/pom.xml, + <autoDetectFonts>true</autoDetectFonts>, +++ b/src/docbook/xslt/pdf.xsl, + <!-- Override the default font settings -->, + <xsl:template name="pickfont-serif">, + <xsl:variable name="font">, + <xsl:call-template name="pickfont"/>, + </xsl:variable>, + <xsl:copy-of select="$font"/>, + <xsl:text>Liberation Serif,serif</xsl:text>, + </xsl:template>, + <xsl:call-template name="pickfont-serif"/>, + <xsl:call-template name="pickfont-serif"/>, + <xsl:param name="programlisting.font">, + <xsl:variable name="font">, + <xsl:call-template name="pickfont-mono"/>, + </xsl:variable>, + <xsl:message>, + <xsl:text>Setting 'programlisting.font' param=</xsl:text><xsl:copy-of select="$font"/>, + </xsl:message>, + <xsl:copy-of select="$font"/>, + </xsl:param>, + <xsl:param name="programlisting.font.size" select="'85%'" />]
[+++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java, +import io.netty.util.concurrent.DefaultEventExecutorGroup;, +import java.net.SocketAddress;, +import java.nio.ByteBuffer;, +import java.nio.channels.SocketChannel;, + * A list of {@link ChannelHandler}s which handles or intercepts inbound events and outbount operations of a, + * {@link Channel}. {@link ChannelPipeline} implements an advanced form of the, + * <a href="http://www.oracle.com/technetwork/java/interceptingfilter-142169.html">Intercepting Filter</a> pattern, + * to give a user full control over how an event is handled and how the {@link ChannelHandler}s in a pipeline, + * interact with each other., + * Each channel has its own pipeline and it is created automatically when a new channel is created., + * The following diagram describes
[+++ b/pom.xml, + <version>3.2.0.ALPHA2-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketUtil.java, + * A utility class mainly for use by web sockets, + * Performs a MD5 hash on the specified data, + * @param data The data to hash, + * @return The hashed data, + static byte[] md5(byte[] data) {, + //Try to get a MessageDigest that uses MD5, + //Hash the data, + return md.digest(data);, + //This shouldn't happen! How old is the computer?, + throw new InternalError("MD5 not supported on this platform - Outdated?");, + * Performs a SHA-1 hash on the specified data, + * @param data The data to hash, + *
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java, + buf.append(protocolVersion().text());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java, + buf.append(protocolVersion().text());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpRequest.java, + buf.append(protocolVersion().text());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java, + buf.append(protocolVersion().text());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpRequest.java, + buf.append(protocolVersion().text());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpResponse.java, + buf.append(protocolVersion().text());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java, + buf.append(protocolVersion().text());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpRequest.java, + buf.append(protocolVersion().text());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpResponse.java, + buf.append(protocolVersion().text());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + encoder = result.contentEncoder();, + result.targetContentEncoding());, + public String targetContentEncoding() {, + public EmbeddedByteChannel contentEncoder() {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpMessage.java, + buf.append(protocolVersion().text());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpRequest.java, + buf.append(protocolVersion().text());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpResponse.java, + buf.append(protocolVersion().text());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + encoder = result.contentEncoder();, + result.targetContentEncoding());, + public String targetContentEncoding() {, + public EmbeddedByteChannel contentEncoder() {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpVersion.java, + public String protocolName() {, + public int majorVersion() {, + public int
[+++ b/all/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/all/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/all/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/all/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/all/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/codec/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/all/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/codec/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/common/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/all/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Beta1</version>, +++ b/codec-socks/pom.xml, +
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + * Returns the reader index of needle in haystack, or -1 if needle is not in haystack., + */, + public static int indexOf(ByteBuf needle, ByteBuf haystack) {, + // TODO: maybe use Boyer Moore for efficiency., + int attempts = haystack.readableBytes() - needle.readableBytes() + 1;, + for (int i = 0; i < attempts; i++) {, + if (equals(needle, needle.readerIndex(),, + haystack, haystack.readerIndex() + i,, + needle.readableBytes())) {, + return haystack.readerIndex() + i;, + }, + }, + return -1;, + }, +, + /**, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + * Returns the reader index of needle
[+++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java, + final String uri = request.getUri();, + final String path = sanitizeUri(uri);, +, + if (file.isDirectory()) {, + if (uri.endsWith("/")) {, + sendListing(ctx, file);, + } else {, + sendRedirect(ctx, uri + '/');, + }, + return;, + }, +, + if (!uri.startsWith("/")) {, + return null;, + }, +, + private static void sendListing(ChannelHandlerContext ctx, File dir) {, + HttpResponse response = new DefaultHttpResponse(HTTP_1_1, HttpResponseStatus.OK);, + response.setHeader(CONTENT_TYPE, "text/html; charset=UTF-8");, +, + StringBuilder buf = new StringBuilder();, +, + buf.append("<!DOCTYPE html>\r\n");, + buf.append("<html><head><title>");, + buf.append("Listing of: ");, + buf.append(dir.getPath());, + buf.append("</title></head><body>\r\n");, +, + buf.append("<h3>Listing of: ");, +
[+++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + @Test, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + @Test, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + @Test, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +++ b/common/src/main/java/io/netty/util/internal/SharedResourceMisuseDetector.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + @Test, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +++ b/common/src/main/java/io/netty/util/internal/SharedResourceMisuseDetector.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + @Test, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +++ b/common/src/main/java/io/netty/util/internal/SharedResourceMisuseDetector.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + @Test, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +++ b/common/src/main/java/io/netty/util/internal/SharedResourceMisuseDetector.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + @Test, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +++ b/common/src/main/java/io/netty/util/internal/SharedResourceMisuseDetector.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerSslContext.java, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, + @Test, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +++ b/common/src/main/java/io/netty/util/internal/SharedResourceMisuseDetector.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/autobahn/AutobahnServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/server/WebSocketServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerHandler.java, +++ b/example/src/main/java/io/netty/example/http/websocketx/sslserver/WebSocketSslServerSslContext.java, +++ b/example/src/main/java/io/netty/example/sctp/SctpClientHandler.java, +import io.netty.channel.sctp.SctpPayload;, + stateEvent.getChannel().write(new SctpPayload(0, 0, ChannelBuffers.wrappedBuffer("SCTP ECHO".getBytes())));, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/AbstractSocketSpdyEchoTest.java, +
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketConnectTest.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketChunkedInput.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + // We need to enable SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER as the memory address may change between, + // calling OpenSSLEngine.wrap(...)., + // See https://github.com/netty/netty-tcnative/issues/100, + SSLContext.setMode(ctx, SSLContext.getMode(ctx) | SSL.SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);, +, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + // We need to enable SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER as the memory address may change between, + // calling OpenSSLEngine.wrap(...)., + // See https://github.com/netty/netty-tcnative/issues/100, + SSLContext.setMode(ctx, SSLContext.getMode(ctx) | SSL.SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);, +, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, +import io.netty.buffer.UnpooledByteBufAllocator;, +import io.netty.handler.ssl.util.InsecureTrustManagerFactory;, +import io.netty.handler.ssl.util.SelfSignedCertificate;, +import io.netty.util.internal.ThreadLocalRandom;, +import javax.net.ssl.SSLEngine;, +import javax.net.ssl.SSLEngineResult;, +import java.nio.ByteBuffer;, +, +import static org.junit.Assert.assertSame;, + @Test, + public void testWrapHeapBuffersNoWritePendingError() throws Exception {, + assumeTrue(OpenSsl.isAvailable());, + final SslContext clientContext = SslContextBuilder.forClient(), + .trustManager(InsecureTrustManagerFactory.INSTANCE),
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + public ChannelFuture handshake(Channel channel) {, + if (channel == null) {, + throw new NullPointerException("channel");, + }, + return handshake(channel, channel.newFuture());, + }, +, + /**, + * Begins the opening handshake, + *, + * @param channel, + * Channel, + * @param future, + * the {@link ChannelFuture} to be notified when the opening handshake is sent, + */, + public abstract ChannelFuture handshake(Channel channel, ChannelFuture future);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, + public ChannelFuture handshake(Channel channel) {, + if (channel == null) {, + throw new NullPointerException("channel");, + }, + return handshake(channel, channel.newFuture());, + }, +,
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java]
[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java, +import java.util.concurrent.Executor;, + DefaultEventExecutor(DefaultEventExecutorGroup parent, Executor executor) {, + super(parent, executor, true);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java, +import java.util.concurrent.Executor;, + DefaultEventExecutor(DefaultEventExecutorGroup parent, Executor executor) {, + super(parent, executor, true);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorGroup.java, +import java.util.concurrent.Executor;, + protected EventExecutor newChild(Executor executor, Object... args) throws Exception {, + return new DefaultEventExecutor(this, executor);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutor.java, +import java.util.concurrent.Executor;, + DefaultEventExecutor(DefaultEventExecutorGroup parent, Executor executor) {, + super(parent, executor, true);, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultEventExecutorGroup.java, +import java.util.concurrent.Executor;, + protected EventExecutor newChild(Executor executor, Object... args) throws Exception {, + return new DefaultEventExecutor(this, executor);, +++ b/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java, +import java.util.concurrent.Executor;, + * @param args arguments which will passed to each {@link #newChild(Executor, Object...)} call, +
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + * @throws {@link IndexOutOfBoundsException}, + * @throws {@link IndexOutOfBoundsException}, + * @throws {@link IndexOutOfBoundsException}, + * @throws {@link IndexOutOfBoundsException}, + * @throws {@link IndexOutOfBoundsException}, + * @throws {@link IndexOutOfBoundsException}, + * @throws {@link IndexOutOfBoundsException}, + * @throws {@link IndexOutOfBoundsException}, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + * @throws {@link IndexOutOfBoundsException}, + * @throws {@link IndexOutOfBoundsException}, + * @throws {@link IndexOutOfBoundsException}, + * @throws {@link IndexOutOfBoundsException}, + * @throws {@link IndexOutOfBoundsException}, + * @throws {@link IndexOutOfBoundsException}, + * @throws {@link IndexOutOfBoundsException}, + * @throws {@link IndexOutOfBoundsException}, +++ b/buffer/src/main/java/io/netty/buffer/DefaultMessageBuf.java, + public <T1> T1[] toArray(T1[] a) {, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + * @throws {@link
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, + String[] values = StringUtil.split(contents[i], '=', 2);, + String values = StringUtil.substringAfter(contents[2], '=');, + multipartMixedBoundary = "--" + values;, + String values = StringUtil.substringAfter(contents[i], '=');, + cleanString(values));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, + String[] values = StringUtil.split(contents[i], '=', 2);, + String values = StringUtil.substringAfter(contents[2], '=');, + multipartMixedBoundary = "--" + values;, + String values = StringUtil.substringAfter(contents[i], '=');, + cleanString(values));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoder.java, + String boundary = StringUtil.substringAfter(headerContentType[mrank], '=');, + if (boundary == null) {, + if (boundary.charAt(0) == '"') {, + String bound = boundary.trim();, + boundary = bound.substring(1, index);, + String charset = StringUtil.substringAfter(headerContentType[crank], '=');, + if (charset != null)
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + Certificate[] localCerts,, +, + // Set the client auth mode, this needs to be done via setClientAuth(...) method so we actually call the, + // needed JNI methods., + setClientAuth(clientMode ? ClientAuth.NONE : checkNotNull(clientAuth, "clientAuth"));]
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, +import java.net.InetSocketAddress;, + * Returns the {@link String} representation of an {@link InetSocketAddress}., + * <p>, + * The output does not include Scope ID., + * @param addr {@link InetSocketAddress} to be converted to an address string, + * @return {@code String} containing the text-formatted IP address, + */, + public static String toSocketAddressString(InetSocketAddress addr) {, + String port = String.valueOf(addr.getPort());, + final StringBuilder sb;, +, + if (addr.isUnresolved()) {, + String hostString = PlatformDependent.javaVersion() >= 7 ? addr.getHostString() : addr.getHostName();, + sb = newSocketAddressStringBuilder(hostString, port, !isValidIpV6Address(hostString));, + } else {, + InetAddress address = addr.getAddress();,
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/RoundRobinDnsAddressResolverGroup.java, +import io.netty.resolver.RoundRobinInetAddressResolver;, + /**, + * We need to override this method, not, + * {@link #newNameResolver(EventLoop, ChannelFactory, DnsServerAddresses)},, + * because we need to eliminate possible caching of {@link io.netty.resolver.NameResolver#resolve}, + * by {@link InflightNameResolver} created in {@link #newResolver(EventLoop, ChannelFactory, DnsServerAddresses)}., + */, + return new RoundRobinInetAddressResolver(eventLoop, resolver).asAddressResolver();, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/RoundRobinDnsAddressResolverGroup.java, +import io.netty.resolver.RoundRobinInetAddressResolver;, + /**, + * We need to override this method, not, + * {@link #newNameResolver(EventLoop, ChannelFactory, DnsServerAddresses)},, + * because we need to eliminate possible caching of {@link io.netty.resolver.NameResolver#resolve}, + * by {@link InflightNameResolver} created in {@link #newResolver(EventLoop, ChannelFactory, DnsServerAddresses)}., + */, + return
[+++ b/src/main/java/org/jboss/netty/handler/traffic/TrafficCounter.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2009, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version., + *, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, + checkKeyManagerFactory(keyManagerFactory);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, + checkKeyManagerFactory(keyManagerFactory);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +import javax.net.ssl.KeyManagerFactory;, +, + static void checkKeyManagerFactory(KeyManagerFactory keyManagerFactory) {, + if (keyManagerFactory != null) {, + throw new IllegalArgumentException(, + "KeyManagerFactory is currently not supported with OpenSslContext");, + }, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, + checkKeyManagerFactory(keyManagerFactory);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +import javax.net.ssl.KeyManagerFactory;, +, + static void checkKeyManagerFactory(KeyManagerFactory keyManagerFactory) {, + if (keyManagerFactory != null) {, + throw new IllegalArgumentException(, + "KeyManagerFactory is currently not supported with OpenSslContext");, + }, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslServerContext.java]
[+++ b/.gitignore, +/target, +++ b/.gitignore, +/target, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return getByte(index) != 0;, + return readByte() != 0;, +++ b/.gitignore, +/target, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return getByte(index) != 0;, + return readByte() != 0;, +++ b/buffer/src/main/java/io/netty/buffer/BigEndianHeapChannelBuffer.java, +++ b/.gitignore, +/target, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return getByte(index) != 0;, + return readByte() != 0;, +++ b/buffer/src/main/java/io/netty/buffer/BigEndianHeapChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufferBackedChannelBuffer.java, +++ b/.gitignore, +/target, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return getByte(index) != 0;, + return readByte() != 0;, +++ b/buffer/src/main/java/io/netty/buffer/BigEndianHeapChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufferBackedChannelBuffer.java, +++ b/buffer/src/main/java/io/netty/buffer/ChannelBuffer.java, + * for (int i = 0; i &lt; buffer.capacity(); i ++) {, +++ b/.gitignore, +/target, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return getByte(index) != 0;, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, +import io.netty.channel.ChannelInboundMessageHandler;, + * Create the {@link ChannelInboundMessageHandler} that is responsible for handling the http requests, + protected abstract ChannelInboundMessageHandler<?> createHttpRequestHandlerForHttp();, + * Create the {@link ChannelInboundMessageHandler} that is responsible for handling the http responses, + protected ChannelInboundMessageHandler<?> createHttpRequestHandlerForSpdy() {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, +import io.netty.channel.ChannelInboundMessageHandler;, + * Create the {@link ChannelInboundMessageHandler} that is responsible for handling the http requests, + protected abstract ChannelInboundMessageHandler<?> createHttpRequestHandlerForHttp();, + * Create the {@link ChannelInboundMessageHandler} that is responsible for handling the http responses, + protected ChannelInboundMessageHandler<?> createHttpRequestHandlerForSpdy() {, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageDecoder.java, +import io.netty.channel.ChannelInboundByteHandlerAdapter;, + extends ChannelInboundByteHandlerAdapter {, + public void inboundBufferUpdated(ChannelHandlerContext ctx, ByteBuf in)
[+++ b/pom.xml, + <version>1.2.6.GA-SNAPSHOT</version>, + -group "Miscellaneous" ${project.groupId}.logging*:${project.groupId}.util*, + <excludePackageNames>${project.groupId}.example*:${project.groupId}.util.internal*</excludePackageNames>, +++ b/pom.xml, + <version>1.2.6.GA-SNAPSHOT</version>, + -group "Miscellaneous" ${project.groupId}.logging*:${project.groupId}.util*, + <excludePackageNames>${project.groupId}.example*:${project.groupId}.util.internal*</excludePackageNames>, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +import org.jboss.netty.util.internal.MapUtil;, +++ b/pom.xml, + <version>1.2.6.GA-SNAPSHOT</version>, + -group "Miscellaneous" ${project.groupId}.logging*:${project.groupId}.util*, + <excludePackageNames>${project.groupId}.example*:${project.groupId}.util.internal*</excludePackageNames>, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +import org.jboss.netty.util.internal.MapUtil;, +++ b/src/main/java/org/jboss/netty/channel/AbstractChannel.java, +import org.jboss.netty.util.internal.ConcurrentHashMap;, +++ b/pom.xml, + <version>1.2.6.GA-SNAPSHOT</version>, + -group "Miscellaneous" ${project.groupId}.logging*:${project.groupId}.util*, + <excludePackageNames>${project.groupId}.example*:${project.groupId}.util.internal*</excludePackageNames>, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +import org.jboss.netty.util.internal.MapUtil;, +++ b/src/main/java/org/jboss/netty/channel/AbstractChannel.java, +import org.jboss.netty.util.internal.ConcurrentHashMap;, +++ b/src/main/java/org/jboss/netty/channel/ChannelLocal.java, +import org.jboss.netty.util.internal.ConcurrentIdentityWeakKeyHashMap;, +++ b/pom.xml, + <version>1.2.6.GA-SNAPSHOT</version>, + -group "Miscellaneous" ${project.groupId}.logging*:${project.groupId}.util*, + <excludePackageNames>${project.groupId}.example*:${project.groupId}.util.internal*</excludePackageNames>, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +import org.jboss.netty.util.internal.MapUtil;, +++ b/src/main/java/org/jboss/netty/channel/AbstractChannel.java, +import org.jboss.netty.util.internal.ConcurrentHashMap;, +++ b/src/main/java/org/jboss/netty/channel/ChannelLocal.java, +import org.jboss.netty.util.internal.ConcurrentIdentityWeakKeyHashMap;, +++ b/src/main/java/org/jboss/netty/channel/DefaultExceptionEvent.java, +import org.jboss.netty.util.internal.StackTraceSimplifier;, +++ b/pom.xml, + <version>1.2.6.GA-SNAPSHOT</version>, + -group "Miscellaneous" ${project.groupId}.logging*:${project.groupId}.util*, +
[+++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedSocketAddress.java, +, + @Override, + public String toString() {, + return "embedded";, + }]
[+++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.bootstrap.ClientBootstrap;, + ClientBootstrap b = new ClientBootstrap();, + .channel(NioSocketChannel.class), +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.bootstrap.ClientBootstrap;, + ClientBootstrap b = new ClientBootstrap();, + .channel(NioSocketChannel.class), +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, + .channel(NioServerSocketChannel.class), +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.bootstrap.ClientBootstrap;, + ClientBootstrap b = new ClientBootstrap();, + .channel(NioSocketChannel.class), +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, + .channel(NioServerSocketChannel.class), +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.bootstrap.ClientBootstrap;, + ClientBootstrap b = new ClientBootstrap();, + .channel(NioSocketChannel.class), +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.bootstrap.ClientBootstrap;, + ClientBootstrap b = new ClientBootstrap();, + .channel(NioSocketChannel.class), +++ b/example/src/main/java/io/netty/example/discard/DiscardServer.java, + .channel(NioServerSocketChannel.class), +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.bootstrap.ClientBootstrap;, + ClientBootstrap b = new ClientBootstrap();, + .channel(NioSocketChannel.class), +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + .channel(NioServerSocketChannel.class), +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.bootstrap.ClientBootstrap;, + ClientBootstrap b = new ClientBootstrap();, +
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpObjectAggregatorTest.java, +import static org.junit.Assert.assertArrayEquals;, + assertThat(response, instanceOf(LastHttpContent.class));, + ReferenceCountUtil.release(response);, +, +, + try {, + embedder.writeInbound(new DefaultHttpContent(Unpooled.EMPTY_BUFFER));, + fail();, + } catch (Exception e) {, + assertThat(e, instanceOf(ClosedChannelException.class));, + // expected, + }, + assertFalse(embedder.writeInbound(new DefaultHttpContent(Unpooled.copiedBuffer(new byte[8]))));, + assertFalse(embedder.writeInbound(new DefaultHttpContent(Unpooled.copiedBuffer(new byte[8]))));, +, + // Now start a new message and ensure we will not reject it again., + HttpRequest message2 = new DefaultHttpRequest(HttpVersion.HTTP_1_0, HttpMethod.PUT, "http://localhost");, + HttpUtil.setContentLength(message, 2);, +, + assertFalse(embedder.writeInbound(message2));, + assertNull(embedder.readOutbound());, + assertFalse(embedder.writeInbound(new DefaultHttpContent(Unpooled.copiedBuffer(new byte[] { 1 }))));, + assertNull(embedder.readOutbound());, + assertTrue(embedder.writeInbound(new DefaultLastHttpContent(Unpooled.copiedBuffer(new byte[] { 2 }))));, + assertNull(embedder.readOutbound());, +, + FullHttpRequest request = embedder.readInbound();, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + cleanup();, + @Override, + public void afterRemove(ChannelHandlerContext ctx) throws Exception {, + cleanup();, + super.afterRemove(ctx);, + }, +, + @Override, + public void channelInactive(ChannelHandlerContext ctx) throws Exception {, + cleanup();, + super.channelInactive(ctx);, + }, +, + private void cleanup() {, + if (decoder != null) {, + // Clean-up the previous decoder if not cleaned up correctly., + finishDecode(Unpooled.buffer());, + }, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + cleanup();, + @Override, + public void afterRemove(ChannelHandlerContext ctx) throws Exception {, + cleanup();, + super.afterRemove(ctx);, + }, +, + @Override, + public void channelInactive(ChannelHandlerContext ctx) throws Exception {, +
[+++ b/transport/src/main/java/io/netty/channel/AdaptiveRecvByteBufAllocator.java, +import static java.lang.Math.max;, +import static java.lang.Math.min;, +, + public void lastBytesRead(int bytes) {, + // If we read as much as we asked for we should check if we need to ramp up the size of our next guess., + // This helps adjust more quickly when large amounts of data is pending and can avoid going back to, + // the selector to check for more data. Going back to the selector can add significant latency for large, + // data transfers., + if (bytes == attemptedBytesRead()) {, + record(bytes);, + }, + super.lastBytesRead(bytes);, + },
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + if (upgrade == null || !upgrade.equalsIgnoreCase(Values.WEBSOCKET)) {, + if (connection == null || !connection.equalsIgnoreCase(Values.UPGRADE)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + if (upgrade == null || !upgrade.equalsIgnoreCase(Values.WEBSOCKET)) {, + if (connection == null || !connection.equalsIgnoreCase(Values.UPGRADE)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + if (upgrade == null || !upgrade.equalsIgnoreCase(Values.WEBSOCKET)) {, + if (connection == null || !connection.equalsIgnoreCase(Values.UPGRADE)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, + if (upgrade == null || !upgrade.equalsIgnoreCase(Values.WEBSOCKET)) {, + if (connection == null || !connection.equalsIgnoreCase(Values.UPGRADE)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, + if (upgrade == null || !upgrade.equalsIgnoreCase(Values.WEBSOCKET)) {, + if (connection == null || !connection.equalsIgnoreCase(Values.UPGRADE)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java, + if (upgrade == null || !upgrade.equalsIgnoreCase(Values.WEBSOCKET))
[+++ b/handler-proxy/src/main/java/io/netty/handler/proxy/HttpProxyHandler.java, +import io.netty.handler.codec.http.HttpHeaders;, + private HttpHeaders headers;, + this(proxyAddress, null);, + }, +, + public HttpProxyHandler(SocketAddress proxyAddress, HttpHeaders headers) {, + this.headers = headers;, + this(proxyAddress, username, password, null);, + }, +, + public HttpProxyHandler(SocketAddress proxyAddress, String username, String password,, + HttpHeaders headers) {, +, + this.headers = headers;, + if (headers != null) {, + req.headers().add(headers);, + }, +, +++ b/handler-proxy/src/main/java/io/netty/handler/proxy/HttpProxyHandler.java, +import io.netty.handler.codec.http.HttpHeaders;, + private HttpHeaders headers;, + this(proxyAddress, null);, + }, +, + public HttpProxyHandler(SocketAddress proxyAddress, HttpHeaders headers) {, + this.headers = headers;, + this(proxyAddress, username, password, null);, + }, +, + public HttpProxyHandler(SocketAddress proxyAddress, String
[+++ b/all/pom.xml]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java]
[+++ b/all/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR10-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + final EchoServerHandler serverHandler = new EchoServerHandler();, + p.addLast(serverHandler);, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + final EchoServerHandler serverHandler = new EchoServerHandler();, + p.addLast(serverHandler);, +++ b/example/src/main/java/io/netty/example/sctp/SctpEchoServer.java, + final SctpEchoServerHandler serverHandler = new SctpEchoServerHandler();, + serverHandler);]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + SelfSignedCertificate cert = null;, + cert = new SelfSignedCertificate();, + if (cert != null) {, + cert.delete();, + }]
[+++ b/.gitignore, +/*.geany, +++ b/.gitignore, +/*.geany, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +++ b/.gitignore, +/*.geany, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ClientBootstrap.java, +++ b/.gitignore, +/*.geany, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ConnectionlessBootstrap.java, +++ b/.gitignore, +/*.geany, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ConnectionlessBootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ServerBootstrap.java, +++ b/.gitignore, +/*.geany, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ConnectionlessBootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ServerBootstrap.java, +++ b/src/main/java/org/jboss/netty/buffer/AbstractChannelBuffer.java, +++ b/.gitignore, +/*.geany, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ConnectionlessBootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ServerBootstrap.java, +++ b/src/main/java/org/jboss/netty/buffer/AbstractChannelBuffer.java, +++ b/src/main/java/org/jboss/netty/buffer/AbstractChannelBufferFactory.java, +++ b/.gitignore, +/*.geany, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ConnectionlessBootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ServerBootstrap.java, +++ b/src/main/java/org/jboss/netty/buffer/AbstractChannelBuffer.java, +++ b/src/main/java/org/jboss/netty/buffer/AbstractChannelBufferFactory.java, +++ b/src/main/java/org/jboss/netty/buffer/BigEndianHeapChannelBuffer.java, +++ b/.gitignore, +/*.geany, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ClientBootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ConnectionlessBootstrap.java, +++ b/src/main/java/org/jboss/netty/bootstrap/ServerBootstrap.java, +++ b/src/main/java/org/jboss/netty/buffer/AbstractChannelBuffer.java, +++ b/src/main/java/org/jboss/netty/buffer/AbstractChannelBufferFactory.java, +++ b/src/main/java/org/jboss/netty/buffer/BigEndianHeapChannelBuffer.java, +++ b/src/main/java/org/jboss/netty/buffer/ByteBufferBackedChannelBuffer.java,
[+++ b/COPYRIGHT.txt, +sent to Trustin Lee <trustin@gmail.com>., +fredbregier Frederic Bregier, +++ b/COPYRIGHT.txt, +sent to Trustin Lee <trustin@gmail.com>., +fredbregier Frederic Bregier, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, + * @author Trustin Lee (trustin@gmail.com), +++ b/COPYRIGHT.txt, +sent to Trustin Lee <trustin@gmail.com>., +fredbregier Frederic Bregier, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, + * @author Trustin Lee (trustin@gmail.com), +++ b/src/main/java/org/jboss/netty/bootstrap/ClientBootstrap.java, + * @author Trustin Lee (trustin@gmail.com), +++ b/COPYRIGHT.txt, +sent to Trustin Lee <trustin@gmail.com>., +fredbregier Frederic Bregier, +++ b/src/main/java/org/jboss/netty/bootstrap/Bootstrap.java, + * @author Trustin Lee (trustin@gmail.com), +++ b/src/main/java/org/jboss/netty/bootstrap/ClientBootstrap.java, + * @author Trustin Lee (trustin@gmail.com), +++ b/src/main/java/org/jboss/netty/bootstrap/ConnectionlessBootstrap.java, + * @author Trustin Lee (trustin@gmail.com), +++ b/COPYRIGHT.txt, +sent to Trustin Lee <trustin@gmail.com>., +fredbregier Frederic Bregier, +++
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java, + buffer.writeBytes(bytes, 0, read);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java, + buffer.writeBytes(bytes, 0, read);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpDataTest.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS"
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.SETTINGS_INITIAL_WINDOW_SIZE;, +import static io.netty.handler.codec.http2.Http2CodecUtil.isMaxFrameSizeValid;, +import static io.netty.handler.codec.http2.Http2CodecUtil.readUnsignedInt;, +import static io.netty.handler.codec.http2.Http2Error.ENHANCE_YOUR_CALM;, +import static io.netty.handler.codec.http2.Http2Exception.streamError;, + listener.onHeadersRead(ctx, headersStreamId, hdrBlockBuilder.headers(), streamDependency,, + weight, exclusive, padding, headersFlags.endOfStream());, + listener.onPushPromiseRead(ctx, pushPromiseStreamId, promisedStreamId,, + headersBlockBuilder().headers(), padding);, + * The local header size maximum has been exceeded while accumulating bytes., + * @throws Http2Exception A connection error indicating too much data has been received., + */, + private void headerSizeExceeded() throws Http2Exception {, + close();, + throw connectionError(ENHANCE_YOUR_CALM, "Header size exceeded max allowed size (%d)",, + headersDecoder.configuration().maxHeaderSize());, + }, +, + /**, + final void addFragment(ByteBuf fragment, ByteBufAllocator alloc, boolean endOfHeaders) throws
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + ByteBuf buf = Unpooled.buffer();, + finishDecode(buf);, + buf.release();, + buf.release();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + ByteBuf buf = Unpooled.buffer();, + finishDecode(buf);, + buf.release();, + buf.release();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, + ByteBuf chunkContent = chunk.content();, + if (fullRequest.content() != chunkContent) {, + fullRequest.content().clear().writeBytes(chunkContent);, + chunkContent.release();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + ByteBuf buf = Unpooled.buffer();, + finishDecode(buf);, + buf.release();, + buf.release();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, + ByteBuf chunkContent = chunk.content();, + if (fullRequest.content() != chunkContent) {, + fullRequest.content().clear().writeBytes(chunkContent);, + chunkContent.release();, +++ b/codec/src/main/java/io/netty/handler/codec/string/StringEncoder.java, + try {, + } finally {, + encoded.release();, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + ByteBuf buf = Unpooled.buffer();, + finishDecode(buf);, + buf.release();, + buf.release();,
[+++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, + if (queue instanceof MessageBuf) {, + return (MessageBuf<T>) queue;, + }, +++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, + if (queue instanceof MessageBuf) {, + return (MessageBuf<T>) queue;, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import java.util.ArrayDeque;, + final Queue<HttpMethod> queue = new ArrayDeque<HttpMethod>();, +++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, + if (queue instanceof MessageBuf) {, + return (MessageBuf<T>) queue;, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import java.util.ArrayDeque;, + final Queue<HttpMethod> queue = new ArrayDeque<HttpMethod>();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, +import java.util.ArrayDeque;, + private final Queue<String> acceptEncodingQueue = new ArrayDeque<String>();, +++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, + if (queue instanceof MessageBuf) {, + return (MessageBuf<T>) queue;, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpClientCodec.java, +import java.util.ArrayDeque;, + final Queue<HttpMethod> queue =
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java, +import io.netty.handler.codec.http.HttpUtil;, +, + if (HttpUtil.isKeepAlive(request)) {, + ctx.writeAndFlush(response);, + } else {, + }, +, + if (HttpUtil.isKeepAlive(request)) {, + ctx.writeAndFlush(new DefaultFullHttpResponse(request.protocolVersion(), FORBIDDEN));, + } else {, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java, +import io.netty.handler.codec.http.HttpUtil;, +, + if (HttpUtil.isKeepAlive(request)) {, + ctx.writeAndFlush(response);, + } else {, + }, +, + if (HttpUtil.isKeepAlive(request)) {, + ctx.writeAndFlush(new DefaultFullHttpResponse(request.protocolVersion(), FORBIDDEN));, + } else {, + }, +, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsHandlerTest.java, +import io.netty.util.AsciiString;, +import static io.netty.handler.codec.http.HttpHeaderNames.CONNECTION;, +import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;, +import static io.netty.handler.codec.http.HttpHeaderValues.CLOSE;, + public void shortCurcuitWithConnectionKeepAliveShouldStayOpen() {, + final CorsConfig config = forOrigin("http://localhost:8080").shortCircuit().build();, + final EmbeddedChannel channel = new EmbeddedChannel(new CorsHandler(config));, +
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketHalfClosedTest.java, +import static java.util.concurrent.TimeUnit.MILLISECONDS;, +import static org.junit.Assert.assertEquals;, + @Test(timeout = 10000), + public void testHalfClosureOnlyOneEventWhenAutoRead() throws Throwable {, + run();, + }, +, + public void testHalfClosureOnlyOneEventWhenAutoRead(ServerBootstrap sb, Bootstrap cb) throws Throwable {, + Channel serverChannel = null;, + try {, + cb.option(ChannelOption.ALLOW_HALF_CLOSURE, true), + .option(ChannelOption.AUTO_READ, true);, + sb.childHandler(new ChannelInitializer<Channel>() {, + @Override, + protected void initChannel(Channel ch) {, + ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {, + @Override, + public void channelActive(ChannelHandlerContext ctx) {, + ((DuplexChannel) ctx).shutdownOutput();, + }, +, + @Override, + public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {, + ctx.close();, + }, + });, + }, + });, +,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, +import io.netty.handler.codec.CodecException;, + final HttpMessage message = (HttpMessage) msg;, + final HttpHeaders headers = message.headers();, + decoder = newContentDecoder(contentEncoding);, + if (decoder == null) {, + if (message instanceof HttpContent) {, + ((HttpContent) message).retain();, + }, + out.add(message);, + return;, + }, +, + // Remove content-length header:, + // the correct value can be set only after all chunks are processed/decoded., + // If buffering is not an issue, add HttpObjectAggregator down the chain, it will set the header., + // Otherwise, rely on LastHttpContent message., + headers.remove(HttpHeaderNames.CONTENT_LENGTH);, +, + // set new content encoding,, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, + return (int) min(MAX_ENCRYPTED_PACKET_LENGTH,, + pendingBytes + (long) MAX_TLS_RECORD_OVERHEAD_LENGTH * numComponents);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, + return (int) min(MAX_ENCRYPTED_PACKET_LENGTH,, + pendingBytes + (long) MAX_TLS_RECORD_OVERHEAD_LENGTH * numComponents);, +++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslEngineTest.java, + assertEquals(MAX_ENCRYPTED_PACKET_LENGTH,, + @Test, + public void testCalculateOutNetBufSizeMaxEncryptedPacketLength() {, + assertEquals(MAX_ENCRYPTED_PACKET_LENGTH,, + ReferenceCountedOpenSslEngine.calculateOutNetBufSize(MAX_ENCRYPTED_PACKET_LENGTH + 1, 2));, + }, +]
[+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +, +, + if (maxPendingTimeouts > 0 && pendingTimeoutsCount > maxPendingTimeouts) {, + /**, + * Returns the number of pending timeouts of this {@link Timer}., + */, + public long pendingTimeouts() {, + return pendingTimeouts.get();, + } else {, +++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java, +, +, + if (maxPendingTimeouts > 0 && pendingTimeoutsCount > maxPendingTimeouts) {, + /**, + * Returns the number of pending timeouts of this {@link Timer}., + */, + public long pendingTimeouts() {, + return pendingTimeouts.get();, + } else {, +++ b/common/src/test/java/io/netty/util/HashedWheelTimerTest.java, + @Test(), + public void reportPendingTimeouts() throws InterruptedException {, + final CountDownLatch latch
[+++ b/buffer/src/main/java/io/netty/buffer/UnsafeByteBufUtil.java, + final int length = src.remaining();, + buf.checkIndex(index, length);, + PlatformDependent.copyMemory(srcAddress + src.position(), addr, length);, + buf.checkIndex(index, length);, + if (length < 8) {, + setSingleBytes(buf, addr, index, src, length);, + } else {, + //no need to checkIndex: internalNioBuffer is already taking care of it, + assert buf.nioBufferCount() == 1;, + final ByteBuffer internalBuffer = buf.internalNioBuffer(index, length);, + internalBuffer.put(src);, + private static void setSingleBytes(final AbstractByteBuf buf, final long addr, final int index,, + final ByteBuffer src, final int length) {, + buf.checkIndex(index, length);, + final int srcPosition = src.position();, + final int srcLimit = src.limit();, +
[+++ b/handler/src/main/java/io/netty/handler/stream/ChunkedFile.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedFile.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedInput.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedFile.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedInput.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedMessageInput.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedFile.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedInput.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedMessageInput.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedNioFile.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedFile.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedInput.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedMessageInput.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedNioFile.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedNioStream.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedFile.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedInput.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedMessageInput.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedNioFile.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedNioStream.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedStream.java, + offset += buffer.writeBytes(in, chunkSize);, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedFile.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedInput.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedMessageInput.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedNioFile.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedNioStream.java, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedStream.java, + offset += buffer.writeBytes(in, chunkSize);, +++ b/handler/src/main/java/io/netty/handler/stream/ChunkedWriteHandler.java]
[+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/StreamBufferingEncoderTest.java, + when(writer.writeData(any(ChannelHandlerContext.class), anyInt(), any(ByteBuf.class), anyInt(), anyBoolean(),, + any(ChannelPromise.class))).thenAnswer(successAnswer());, + when(writer.writeGoAway(any(ChannelHandlerContext.class), anyInt(), anyLong(), any(ByteBuf.class),, + ByteBuf data = data();, + final int expectedBytes = data.readableBytes() * 3;, + encoder.writeData(ctx, 3, data, 0, false, promise);, + assertEquals(expectedBytes, bufCaptor.getValue().readableBytes());]
[+++ b/pom.xml]
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, + handshakeException = new SSLHandshakeException(SSL.getErrorString(err));, + // We need to clear all errors so we not pick up anything that was left on the stack on the next, + // operation. Note that shutdownWithError(...) will cleanup the stack as well so its only needed here., + SSL.clearError();, + throw shutdownWithError("SSL_read", SSL.getErrorString(err));, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, + handshakeException = new SSLHandshakeException(SSL.getErrorString(err));, + // We need to clear all errors so we not pick up anything that was left on the stack on the next, + // operation. Note that shutdownWithError(...) will cleanup the stack as well so its only needed
[+++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java, +import java.io.Closeable;, +import java.nio.file.Files;, +import java.nio.file.attribute.PosixFilePermission;, +import java.util.EnumSet;, +import java.util.Set;, + } catch (UnsatisfiedLinkError e) {, + try {, + if (tmpFile != null && tmpFile.isFile() && tmpFile.canRead() &&, + !NoexecVolumeDetector.canExecuteExecutable(tmpFile)) {, + logger.info("{} exists but cannot be executed even when execute permissions set; " +, + "check volume for \"noexec\" flag; use -Dio.netty.native.workdir=[path] " +, + "to set native working directory separately.",, + tmpFile.getPath());, + }, + } catch (Throwable t) {, + logger.debug("Error checking if {} is on a file store mounted with noexec", tmpFile, t);, + }, + // Re-throw to fail the load,
[+++ b/NOTICE.txt, +This product contains a modified portion of 'libdivsufsort', a C API library to construct, +the suffix array and the Burrows-Wheeler transformed string for any input string of, +a constant-size alphabet written by Yuta Mori. It can be obtained at:, +, + * LICENSE:, + * license/LICENSE.libdivsufsort.txt (MIT License), + * HOMEPAGE:, + * https://code.google.com/p/libdivsufsort/, +, +++ b/NOTICE.txt, +This product contains a modified portion of 'libdivsufsort', a C API library to construct, +the suffix array and the Burrows-Wheeler transformed string for any input string of, +a constant-size alphabet written by Yuta Mori. It can be obtained at:, +,
[+++ b/example/src/main/java/io/netty/example/factorial/FactorialClientHandler.java, + private int next = 1;, + ChannelFuture future = null;, + for (int i = 0; i < 4096 && next <= count; i++) {, + future = ctx.write(Integer.valueOf(next));, + next++;, + }, + if (next <= count) {, + assert future != null;]
[+++ b/pom.xml, + <configuration>, + <!--, + ~ Add generated MANIFEST.MF., + ~ See https://github.com/netty/netty/issues/2058, + -->, + <useDefaultManifestFile>true</useDefaultManifestFile>, + </configuration>]
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +#include <stddef.h>, +jint epollCtl(JNIEnv* env, jint efd, int op, jint fd, jint flags) {, + uint32_t events = flags;, + .data.fd = fd,, + .events = events, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_epollWait0(JNIEnv* env, jclass clazz, jint efd, jlong address, jint len, jint timeout) {, + struct epoll_event *ev = (struct epoll_event*) address;, + return -err;, +JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_epollCtlAdd(JNIEnv* env, jclass clazz, jint efd, jint fd, jint flags) {, + if (epollCtl(env, efd, EPOLL_CTL_ADD, fd, flags) < 0) {, +JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_epollCtlMod(JNIEnv* env, jclass clazz, jint efd, jint fd, jint flags) {, + if (epollCtl(env, efd, EPOLL_CTL_MOD,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerUpgradeHandler.java, + * @param upgradeRequest the request that triggered the upgrade to this protocol., + void upgradeTo(ChannelHandlerContext ctx, FullHttpRequest upgradeRequest);, + finalUpgradeCodec.upgradeTo(ctx, request);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpServerUpgradeHandler.java, + * @param upgradeRequest the request that triggered the upgrade to this protocol., + void upgradeTo(ChannelHandlerContext ctx, FullHttpRequest upgradeRequest);, + finalUpgradeCodec.upgradeTo(ctx, request);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ServerUpgradeCodec.java, + public void upgradeTo(final ChannelHandlerContext ctx, FullHttpRequest upgradeRequest) {]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + IovArray array = ((EpollEventLoop) eventLoop()).cleanArray();, + in.forEachFlushedMessage(array);, +, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + IovArray array = ((EpollEventLoop) eventLoop()).cleanArray();, + in.forEachFlushedMessage(array);, +, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java, + IovArray array = ((EpollEventLoop) eventLoop()).cleanArray();, + array.add(data);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + IovArray array = ((EpollEventLoop) eventLoop()).cleanArray();, + in.forEachFlushedMessage(array);, +, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java, + IovArray array = ((EpollEventLoop) eventLoop()).cleanArray();, + array.add(data);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoop.java, + private final IovArray iovArray = new IovArray();, + /**, + * Return a cleared {@link IovArray} that can be used for writes in this {@link EventLoop}., + */, + IovArray cleanArray() {, + iovArray.clear();, + return iovArray;, + }, +, + iovArray.release();, +++
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + lifecycleManager.onError(ctx, e);, + lifecycleManager.onError(ctx, cause);, + lifecycleManager.onError(ctx, cause);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + lifecycleManager.onError(ctx, e);, + lifecycleManager.onError(ctx, cause);, + lifecycleManager.onError(ctx, cause);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + onError(ctx, e);, + onError(ctx, e);, + onError(ctx, cause);, + public void onError(ChannelHandlerContext ctx, Throwable cause) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + lifecycleManager.onError(ctx, e);, + lifecycleManager.onError(ctx, cause);, + lifecycleManager.onError(ctx, cause);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + onError(ctx, e);, + onError(ctx, e);, + onError(ctx, cause);, + public void onError(ChannelHandlerContext ctx, Throwable cause) {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2LifecycleManager.java, + * Processes the given error., + void onError(ChannelHandlerContext ctx, Throwable cause);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java, + int streamId = httpHeaders.getInt(SpdyHttpHeaders.Names.STREAM_ID);, + int associatedToStreamId = httpHeaders.getInt(SpdyHttpHeaders.Names.ASSOCIATED_TO_STREAM_ID, 0);, + byte priority = (byte) httpHeaders.getInt(SpdyHttpHeaders.Names.PRIORITY, 0);, + CharSequence scheme = httpHeaders.get(SpdyHttpHeaders.Names.SCHEME);, + httpHeaders.remove(SpdyHttpHeaders.Names.STREAM_ID);, + httpHeaders.remove(SpdyHttpHeaders.Names.ASSOCIATED_TO_STREAM_ID);, + httpHeaders.remove(SpdyHttpHeaders.Names.PRIORITY);, + httpHeaders.remove(SpdyHttpHeaders.Names.SCHEME);, + frameHeaders.setObject(SpdyHeaders.HttpNames.METHOD, httpRequest.method());, + frameHeaders.set(SpdyHeaders.HttpNames.PATH, httpRequest.uri());, + frameHeaders.setObject(SpdyHeaders.HttpNames.VERSION, httpRequest.protocolVersion());, + frameHeaders.set(SpdyHeaders.HttpNames.HOST, host);, + frameHeaders.set(SpdyHeaders.HttpNames.SCHEME, scheme);, + int streamId = httpHeaders.getInt(SpdyHttpHeaders.Names.STREAM_ID);, + httpHeaders.remove(SpdyHttpHeaders.Names.STREAM_ID);, + frameHeaders.setInt(SpdyHeaders.HttpNames.STATUS, httpResponse.status().code());, + frameHeaders.setObject(SpdyHeaders.HttpNames.VERSION, httpResponse.protocolVersion());]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderDateFormat.java, + * @deprecated Use {@link HttpHeaderDateFormatter} instead, +@Deprecated, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderDateFormat.java, + * @deprecated Use {@link HttpHeaderDateFormatter} instead, +@Deprecated, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpHeaderDateFormatter.java, +/*, + * Copyright 2016 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + headers.set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + headers.set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentDecoderTest.java, +, + assertFalse("Content-Length header not removed.", r.headers().contains(HttpHeaderNames.CONTENT_LENGTH));, +, + String transferEncoding = r.headers().get(HttpHeaderNames.TRANSFER_ENCODING);, + assertNotNull("Content-length as well as transfer-encoding not set.", transferEncoding);, + assertEquals("Unexpected transfer-encoding value.", HttpHeaderValues.CHUNKED.toString(), transferEncoding);, + contentLength = calculateContentLength(req, contentLength);, + byte[] receivedContent = readContent(req, contentLength);, + contentLength = calculateContentLength(resp, contentLength);, + byte[] receivedContent = readContent(resp, contentLength);, + private static byte[] gzDecompress(byte[] input) {, + private static byte[] readContent(Queue<Object> req, int contentLength) {, + byte[] receivedContent = new byte[contentLength];, + int readCount = 0;, + for (Object o : req) {, + if (o
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyControlFrame.java, +public interface SpdyControlFrame extends SpdyDataOrControlFrame {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyControlFrame.java, +public interface SpdyControlFrame extends SpdyDataOrControlFrame {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataFrame.java, +public interface SpdyDataFrame extends ByteBufHolder, SpdyStreamFrame, SpdyDataOrControlFrame {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyControlFrame.java, +public interface SpdyControlFrame extends SpdyDataOrControlFrame {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataFrame.java, +public interface SpdyDataFrame extends ByteBufHolder, SpdyStreamFrame, SpdyDataOrControlFrame {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyDataOrControlFrame.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:,
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + /**, + * Read the given amount of bytes into a new {@link ByteBuf} that is allocated from the {@link ByteBufAllocator}., + */, + public static ByteBuf readBytes(ByteBufAllocator alloc, ByteBuf buffer, int length) {, + boolean release = true;, + ByteBuf dst = alloc.buffer(length);, + try {, + buffer.readBytes(dst);, + release = false;, + return dst;, + } finally {, + if (release) {, + dst.release();, + }, + }, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + /**, + * Read the given amount of bytes into a new {@link ByteBuf} that is allocated from the {@link
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, + // We may have more then one cert in the chain so add all of them now. We must NOT skip the, + // first cert when client mode., + if (!SSLContext.setCertificateChainFile(ctx, keyCertChainFile.getPath(), false)) {, + long error = SSL.getLastErrorNumber();, + if (OpenSsl.isError(error)) {, + throw new SSLException(, + "failed to set certificate chain: ", + + keyCertChainFile + " (" + SSL.getErrorString(error) + ')');, + }, + }, + // We may have more then one cert in the chain so add all of them now. We must NOT skip the, + // first cert
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +import java.util.concurrent.Future;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;, + protected static final int DEFAULT_FORCE_CLOSE_TIMEOUT_MILLIS = 10000;, + private volatile long forceCloseTimeoutMillis = DEFAULT_FORCE_CLOSE_TIMEOUT_MILLIS;, +, + private volatile int forceCloseInit;, +, + private static final AtomicIntegerFieldUpdater<WebSocketClientHandshaker> FORCE_CLOSE_INIT_UPDATER =, + AtomicIntegerFieldUpdater.newUpdater(WebSocketClientHandshaker.class, "forceCloseInit");, +, + private volatile boolean forceCloseComplete;, +, + this(uri, version, subprotocol, customHeaders, maxFramePayloadLength, DEFAULT_FORCE_CLOSE_TIMEOUT_MILLIS);, + }, +, + /**, + * Base constructor, + *, + * @param uri, + * URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be, + * sent to this URL., + * @param version, + * Version of web
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, +import io.netty.util.ReferenceCountUtil;, +, + @Test, + public void testReleasesItsComponents() {, + ByteBuf buffer = PooledByteBufAllocator.DEFAULT.buffer(); // 1, +, + buffer.writeBytes(new byte[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10});, +, + ByteBuf s1 = buffer.readSlice(2).retain(); // 2, + ByteBuf s2 = s1.readSlice(2).retain(); // 3, + ByteBuf s3 = s2.readSlice(2).retain(); // 4, + ByteBuf s4 = s3.readSlice(2).retain(); // 5, +, + ByteBuf composite = PooledByteBufAllocator.DEFAULT.compositeBuffer(), + .addComponent(s1), + .addComponents(s2, s3, s4), + .order(ByteOrder.LITTLE_ENDIAN);, +, + assertEquals(composite.refCnt(), 1);, + assertEquals(buffer.refCnt(), 5);, +, + // releasing composite should release the 4 components, + ReferenceCountUtil.release(composite);, + assertEquals(composite.refCnt(), 0);, +
[+++ b/all/pom.xml, +++ b/all/pom.xml, +++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E> {, +, + public ObjectArray(E[] array, int offset, int length) {, + super(array, offset, length);, + }, +, + @Override, + public E[] array() {, + return (E[]) super.array();, + }, +}, +++ b/all/pom.xml, +++ b/buffer/src/main/java/io/netty/array/ObjectArray.java, +package io.netty.array;, +, +, +public class ObjectArray<E> extends AbstractArray<E> {, +, + public ObjectArray(E[] array, int offset, int length) {, + super(array, offset, length);, + }, +, + @Override, + public E[] array() {, + return (E[]) super.array();, + }, +}, +++ b/buffer/src/main/java/io/netty/buffer/AbstractChannelBuffer.java, + return writerIndex > readerIndex;,
[+++ b/codec-stomp/src/main/java/io/netty/handler/codec/stomp/DefaultStompFrame.java, + content.retain(increment);]
[+++ b/pom.xml, + <version>[3.0.4,)</version>]
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java, + private int maxQueriesPerResolve = 16;, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverBuilder.java, + private int maxQueriesPerResolve = 16;, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java, + buf.append("failed to resolve '"), + .append(hostname).append('\'');, + if (tries < maxAllowedQueries) {, + buf.append(" after "), + .append(tries), + .append(" queries ");, + buf.append(". Exceeded max queries per resolve "), + .append(maxAllowedQueries), + .append(' ');, + }, + buf.append(':'), + .append(trace);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java, + if (name.charAt(0) == '$') {, + throw new IllegalArgumentException("name starting with '$' not allowed: " + name);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultCookie.java, + if (name.charAt(0) == '$') {, + throw new IllegalArgumentException("name starting with '$' not allowed: " + name);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/CookieDecoderTest.java, +, + @Test, + public void testDecodingWeirdNames1() {, + String src = "path=; expires=Mon, 01-Jan-1990 00:00:00 GMT; path=/; domain=.www.google.com";, + Set<Cookie> cookies = new CookieDecoder().decode(src);, + Cookie c = cookies.iterator().next();, + assertEquals("path", c.getName());, + assertEquals("", c.getValue());, + assertEquals("/", c.getPath());, + }, +, + @Test, + public void testDecodingWeirdNames2() {, + String
[+++ b/codec/src/main/java/io/netty/handler/codec/xml/XmlFrameDecoder.java, + boolean inCDATASection = false;, + } else if (!inCDATASection && readByte == '<') {, + } else if (peekAheadByte == '!') {, + if (isCommentBlockStart(in, i)) {, + } else if (isCDATABlockStart(in, i)) {, + // <![CDATA[ start found, + openBracketsCount++;, + inCDATASection = true;, + }, + } else if (!inCDATASection && readByte == '/') {, + if (!inCDATASection) {, + } else if (peekBehindByte == ']' && i - 2 > -1 && in.getByte(i - 2) == ']') {, + // a <![CDATA[...]]> block was closed, + openBracketsCount--;, + inCDATASection = false;, + },
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java, + ctx.write(msg, promise);]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +import io.netty.handler.codec.http2.Http2Stream.State;, + static State activeState(int streamId, State initialState, boolean isLocal, boolean halfClosed), + throws Http2Exception {, + switch (initialState) {, + case IDLE:, + return halfClosed ? isLocal ? HALF_CLOSED_LOCAL : HALF_CLOSED_REMOTE : OPEN;, + case RESERVED_LOCAL:, + return HALF_CLOSED_REMOTE;, + case RESERVED_REMOTE:, + return HALF_CLOSED_LOCAL;, + default:, + throw streamError(streamId, PROTOCOL_ERROR, "Attempting to open a stream in an invalid state: ", + + initialState);, + }, + }, +, + void notifyHalfClosed(Http2Stream stream) {, + for (int i = 0; i < listeners.size(); i++) {, + try {, + listeners.get(i).onStreamHalfClosed(stream);, + } catch (RuntimeException e)
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/microbench/pom.xml, + <packaging>jar</packaging>]
[+++ b/NOTICE.txt, +This product contains a modified version of 'JZlib', a re-implementation of, +zlib in pure Java, which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.jzlib.txt (BSD Style License), + * HOMEPAGE:, + * http://www.jcraft.com/jzlib/, +, +++ b/NOTICE.txt, +This product contains a modified version of 'JZlib', a re-implementation of, +zlib in pure Java, which can be obtained at:, +, + * LICENSE:, + * license/LICENSE.jzlib.txt (BSD Style License), + * HOMEPAGE:, + * http://www.jcraft.com/jzlib/, +, +++ b/pom.xml, +++ b/NOTICE.txt, +This product contains a modified version of 'JZlib', a re-implementation of, +zlib in pure Java, which can
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, + /**, + * Determine whether a message has a content or not. Some message may have headers indicating, + * a content without having an actual content, e.g the response to an HEAD or CONNECT request., + *, + * @param msg the message to test, + * @return {@code true} to signal the message has no content, + */, + protected boolean isContentAlwaysEmpty(@SuppressWarnings("unused") H msg) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, + /**, + * Determine whether a message has a content or not. Some message may have headers indicating, + * a content without having an actual
[+++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadClient.java, +import io.netty.handler.ssl.util.InsecureTrustManagerFactory;, + sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);, +++ b/example/src/main/java/io/netty/example/http/upload/HttpUploadClient.java, +import io.netty.handler.ssl.util.InsecureTrustManagerFactory;, + sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);, +++ b/example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClient.java, +import io.netty.handler.ssl.util.InsecureTrustManagerFactory;, + sslCtx = SslContext.newClientContext(InsecureTrustManagerFactory.INSTANCE);]
[+++ b/resolver/src/main/java/io/netty/resolver/HostsFileParser.java, +import java.util.regex.Pattern;, + private static final Pattern WHITESPACES = Pattern.compile("[ \t]+");, +, + for (String s: WHITESPACES.split(line)) {, + entries.put(hostname, InetAddress.getByAddress(hostname, ipBytes));, + try {, + } catch (IOException e) {, + logger.warn("Failed to close a reader", e);, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpResponseStatus.java, + public static final HttpResponseStatus CONTINUE = newStatus(100, "Continue");, + public static final HttpResponseStatus SWITCHING_PROTOCOLS = newStatus(101, "Switching Protocols");, + public static final HttpResponseStatus PROCESSING = newStatus(102, "Processing");, + public static final HttpResponseStatus OK = newStatus(200, "OK");, + public static final HttpResponseStatus CREATED = newStatus(201, "Created");, + public static final HttpResponseStatus ACCEPTED = newStatus(202, "Accepted");, + newStatus(203, "Non-Authoritative Information");, + public static final HttpResponseStatus NO_CONTENT = newStatus(204, "No Content");, + public static final HttpResponseStatus RESET_CONTENT = newStatus(205, "Reset Content");, + public static final HttpResponseStatus PARTIAL_CONTENT = newStatus(206, "Partial Content");, + public static final HttpResponseStatus MULTI_STATUS = newStatus(207,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostStandardRequestDecoder.java, + } catch (IllegalArgumentException e) {, + // error while decoding, + undecodedChunk.readerIndex(firstpos);, + throw new ErrorDataDecoderException(e);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostStandardRequestDecoder.java, + } catch (IllegalArgumentException e) {, + // error while decoding, + undecodedChunk.readerIndex(firstpos);, + throw new ErrorDataDecoderException(e);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java, +import io.netty.handler.codec.http.DefaultLastHttpContent;, +, + @Test, + public void testFormEncodeIncorrect() throws Exception {, + LastHttpContent content = new DefaultLastHttpContent(, + Unpooled.copiedBuffer("project=netty&&project=netty", CharsetUtil.US_ASCII));, + DefaultHttpRequest req = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, "/");, + HttpPostRequestDecoder decoder = new HttpPostRequestDecoder(req);, + try {, + decoder.offer(content);, + fail();, + } catch (HttpPostRequestDecoder.ErrorDataDecoderException e) {, + assertTrue(e.getCause() instanceof IllegalArgumentException);, + } finally {, + decoder.destroy();, +
[+++ b/example/src/main/java/io/netty/example/http/helloworld/HttpHelloWorldServerHandler.java, +import static io.netty.handler.codec.http.HttpVersion.*;, + Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("Hello World", CharsetUtil.US_ASCII));, + int size = msgs.size();, + for (int i = 0; i < size; i++) {]
[+++ b/buffer/src/main/java/io/netty/buffer/UnsafeByteBufUtil.java, + return (PlatformDependent.getByte(address) & 0xff) << 16 |, + (BIG_ENDIAN_NATIVE_ORDER ? PlatformDependent.getShort(address + 1), + : Short.reverseBytes(PlatformDependent.getShort(address + 1))) & 0xffff;, + ((BIG_ENDIAN_NATIVE_ORDER ? Short.reverseBytes(PlatformDependent.getShort(address + 1)), + : PlatformDependent.getShort(address + 1)) & 0xffff) << 8;, + (PlatformDependent.getByte(address + 2) & 0xff) << 16;, + return ((long) PlatformDependent.getByte(address)) << 56 |, + (PlatformDependent.getByte(address + 1) & 0xffL) << 48 |, + (PlatformDependent.getByte(address + 2) & 0xffL) << 40 |, + (PlatformDependent.getByte(address + 3) & 0xffL) << 32 |, + (PlatformDependent.getByte(address + 4) & 0xffL) << 24 |, + (PlatformDependent.getByte(address + 5) & 0xffL) << 16 |, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaders.java]
[+++ b/codec/pom.xml, + <dependency>, + <groupId>org.jboss.marshalling</groupId>, + <artifactId>jboss-marshalling</artifactId>, + <optional>true</optional>, + </dependency>, + , + <!-- Test dependencies for jboss marshalling encoder/decoder -->, + <dependency>, + <groupId>org.jboss.marshalling</groupId>, + <artifactId>jboss-marshalling-serial</artifactId>, + <scope>test</scope>, + </dependency>, + <dependency>, + <groupId>org.jboss.marshalling</groupId>, + <artifactId>jboss-marshalling-river</artifactId>, + <scope>test</scope>, + </dependency>, +++ b/codec/pom.xml, + <dependency>, + <groupId>org.jboss.marshalling</groupId>, + <artifactId>jboss-marshalling</artifactId>, + <optional>true</optional>, + </dependency>, + , + <!-- Test dependencies for jboss marshalling encoder/decoder -->, + <dependency>, + <groupId>org.jboss.marshalling</groupId>, + <artifactId>jboss-marshalling-serial</artifactId>, + <scope>test</scope>, + </dependency>, + <dependency>, + <groupId>org.jboss.marshalling</groupId>, + <artifactId>jboss-marshalling-river</artifactId>, + <scope>test</scope>, + </dependency>, +++ b/codec/src/main/java/io/netty/handler/codec/marshalling/ChannelBufferByteInput.java, +/*, + * Copyright 2012 The Netty Project, + *, +
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + /**, + * Reset the stored remoteAddress, + */, + /**, + * Create a new {@link AbstractUnsafe} instance which will be used for the life-time of the {@link Channel}, + */, + protected abstract AbstractUnsafe newUnsafe();, + /**, + * {@link Unsafe} implementation which sub-classes must extend and use., + */, + /**, + * Return {@code true} if the given {@link EventLoop} is compatible with this instance., + */, + /**, + * Returns the {@link SocketAddress} which is bound locally., + */, +, + /**, + * Return the {@link SocketAddress} which the
[+++ b/example/pom.xml, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-tcnative</artifactId>, + <classifier>${os.detected.classifier}</classifier>, + </dependency>, + <dependency>]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, + public static final int NUM_STANDARD_SETTINGS = 6;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, + public static final int NUM_STANDARD_SETTINGS = 6;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Settings.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.NUM_STANDARD_SETTINGS;, + /**, + * Default capacity based on the number of standard settings from the HTTP/2 spec, adjusted so that adding all of, + * the standard settings will not cause the map capacity to change., + */, + private static final int DEFAULT_CAPACITY = (int) (NUM_STANDARD_SETTINGS / DEFAULT_LOAD_FACTOR) + 1;, + this(DEFAULT_CAPACITY);, + * Adds the given setting key/value pair. For standard settings defined by the HTTP/2 spec, performs, + * validation on
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, +import io.netty.channel.ChannelFutureNotifier;, + ChannelFuture handshakeFuture = channel.newFuture();, + future.addListener(new ChannelFutureNotifier(handshakeFuture));, + return handshakeFuture;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, +import io.netty.channel.ChannelFutureNotifier;, + ChannelFuture handshakeFuture = channel.newFuture();, + future.addListener(new ChannelFutureNotifier(handshakeFuture));, + return handshakeFuture;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, +import io.netty.channel.ChannelFutureNotifier;, + ChannelFuture handshakeFuture = channel.newFuture();, + future.addListener(new ChannelFutureNotifier(handshakeFuture));, + return handshakeFuture;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker00.java, +import io.netty.channel.ChannelFutureNotifier;, + ChannelFuture handshakeFuture = channel.newFuture();, + future.addListener(new ChannelFutureNotifier(handshakeFuture));, + return handshakeFuture;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, +import io.netty.channel.ChannelFutureNotifier;, + ChannelFuture handshakeFuture = channel.newFuture();, + future.addListener(new ChannelFutureNotifier(handshakeFuture));, + return handshakeFuture;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java, +import io.netty.channel.ChannelFutureNotifier;, + ChannelFuture handshakeFuture = channel.newFuture();, + future.addListener(new ChannelFutureNotifier(handshakeFuture));, + return handshakeFuture;]
[+++ b/transport-native-epoll/src/main/c/netty_epoll_linuxsocket.c, +static void netty_epoll_linuxsocket_getTcpInfo(JNIEnv* env, jclass clazz, jint fd, jlongArray array) {, + jlong cArray[32];, + // Expand to 64 bits, then cast away unsigned-ness., + cArray[0] = (jlong) (uint64_t) tcp_info.tcpi_state;, + cArray[1] = (jlong) (uint64_t) tcp_info.tcpi_ca_state;, + cArray[2] = (jlong) (uint64_t) tcp_info.tcpi_retransmits;, + cArray[3] = (jlong) (uint64_t) tcp_info.tcpi_probes;, + cArray[4] = (jlong) (uint64_t) tcp_info.tcpi_backoff;, + cArray[5] = (jlong) (uint64_t) tcp_info.tcpi_options;, + cArray[6] = (jlong) (uint64_t) tcp_info.tcpi_snd_wscale;, + cArray[7] = (jlong) (uint64_t) tcp_info.tcpi_rcv_wscale;, + cArray[8] = (jlong) (uint64_t) tcp_info.tcpi_rto;, + cArray[9] = (jlong) (uint64_t) tcp_info.tcpi_ato;, + cArray[10] = (jlong) (uint64_t) tcp_info.tcpi_snd_mss;, + cArray[11] = (jlong) (uint64_t) tcp_info.tcpi_rcv_mss;, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, + @Override, + @Override, + @Override, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, + @Override, + @Override, + @Override, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeadersFrame.java, + @Override, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, + @Override, + @Override, + @Override, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeadersFrame.java, + @Override, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java, + @Override, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, + @Override, + @Override, + @Override, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeadersFrame.java, + @Override, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java, + @Override, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyRstStreamFrame.java, + @Override, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyGoAwayFrame.java, + @Override, + @Override, + @Override, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyHeadersFrame.java, + @Override, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyPingFrame.java, + @Override, + @Override, +++
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java, + return newAddressResolver(eventLoop, resolver);, +, + /**, + * Creates a new {@link AddressResolver}. Override this method to create an alternative {@link AddressResolver}, + * implementation or override the default configuration., + */, + protected AddressResolver<InetSocketAddress> newAddressResolver(EventLoop eventLoop,, + NameResolver<InetAddress> resolver), + throws Exception {, + return new InetSocketAddressResolver(eventLoop, resolver);, + }, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsAddressResolverGroup.java, + return newAddressResolver(eventLoop, resolver);, +, + /**, + * Creates a new {@link AddressResolver}. Override this method to create an alternative {@link AddressResolver}, + * implementation or override the default configuration., + */, + protected AddressResolver<InetSocketAddress> newAddressResolver(EventLoop eventLoop,, + NameResolver<InetAddress> resolver), + throws
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java, + private volatile int maxMessagesPerRead;, +, + if (channel instanceof ServerChannel) {, + // Accept as many incoming connections as possible., + maxMessagesPerRead = 16;, + } else {, + maxMessagesPerRead = 1;, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockCompressor.java, + static SpdyHeaderBlockCompressor newInstance(, + int compressionLevel, int windowBits, int memLevel) {, +, + return new SpdyHeaderBlockZlibCompressor(compressionLevel);, + return new SpdyHeaderBlockJZlibCompressor(, + compressionLevel, windowBits, memLevel);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockCompressor.java, + static SpdyHeaderBlockCompressor newInstance(, + int compressionLevel, int windowBits, int memLevel) {, +, + return new SpdyHeaderBlockZlibCompressor(compressionLevel);, + return new SpdyHeaderBlockJZlibCompressor(, + compressionLevel, windowBits, memLevel);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockDecompressor.java, + return new SpdyHeaderBlockJZlibDecompressor();, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockCompressor.java, + static SpdyHeaderBlockCompressor newInstance(, + int compressionLevel, int windowBits, int memLevel) {, +, + return new SpdyHeaderBlockZlibCompressor(compressionLevel);, + return new SpdyHeaderBlockJZlibCompressor(, + compressionLevel, windowBits, memLevel);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockDecompressor.java, + return new SpdyHeaderBlockJZlibDecompressor();, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockJZlibCompressor.java, +/*, + * Copyright
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java, + promise.tryFailure(new SearchDomainUnknownHostException(future.cause(), hostname));, + private static final class SearchDomainUnknownHostException extends UnknownHostException {, + SearchDomainUnknownHostException(Throwable cause, String originalHostname) {, + super("Search domain query failed. Original hostname: '" + originalHostname + "' " + cause.getMessage());, + setStackTrace(cause.getStackTrace());, + }, +, + @Override, + public Throwable fillInStackTrace() {, + return this;, + }, + }, +, + buf.append("failed to resolve '").append(hostname).append('\'');, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsNameResolverContext.java, + promise.tryFailure(new SearchDomainUnknownHostException(future.cause(), hostname));, + private static final class SearchDomainUnknownHostException extends UnknownHostException {, + SearchDomainUnknownHostException(Throwable cause, String originalHostname) {, + super("Search domain query failed. Original hostname: '" + originalHostname + "' " + cause.getMessage());, + setStackTrace(cause.getStackTrace());,
[+++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, + s.pipeline().addLast("logger", new LoggingHandler(InternalLogLevel.INFO));]
[+++ b/all/pom.xml, + <artifactId>netty-codec-smtp</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + <optional>true</optional>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>]
[+++ b/all/pom.xml, + <version>19</version>, +++ b/all/pom.xml, + <version>19</version>, +++ b/pom.xml, + <version>1.7.5</version>, + <version>1.1.3</version>, + <version>1.0.13</version>, + <version>2.4.1</version>, + <version>2.15</version>, + <version>2.15</version>, + <version>2.8</version>, + <!-- Do NOT upgrade -->, + <version>1.8</version>, +]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java, +import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_HEADER_LIST_SIZE;, +import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_INITIAL_HUFFMAN_DECODE_CAPACITY;, +import static io.netty.util.internal.ObjectUtil.checkPositive;, + * <li>{@link #initialHuffmanDecodeCapacity(int)}</li>, + private int initialHuffmanDecodeCapacity = DEFAULT_INITIAL_HUFFMAN_DECODE_CAPACITY;, + * Sets the initial size of an intermediate buffer used during HPACK huffman decoding., + * @param initialHuffmanDecodeCapacity initial size of an intermediate buffer used during HPACK huffman decoding., + * @return this., + */, + protected B initialHuffmanDecodeCapacity(int initialHuffmanDecodeCapacity) {, + enforceNonCodecConstraints("initialHuffmanDecodeCapacity");, + this.initialHuffmanDecodeCapacity = checkPositive(initialHuffmanDecodeCapacity, "initialHuffmanDecodeCapacity");, + return self();, + }, +, + /**, + Http2FrameReader reader = new DefaultHttp2FrameReader(new DefaultHttp2HeadersDecoder(isValidateHeaders(),, + maxHeaderListSize == null ? DEFAULT_HEADER_LIST_SIZE : maxHeaderListSize,, + initialHuffmanDecodeCapacity));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2ConnectionHandlerBuilder.java, +import static
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/example/src/main/java/io/netty/example/udt/echo/rendezvous/Config.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the
[+++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.handler.logging.LogLevel;, + EventLoop loop = new SelectorEventLoop();, + p.addLast("logger", new LoggingHandler(LogLevel.INFO));, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.handler.logging.LogLevel;, + EventLoop loop = new SelectorEventLoop();, + p.addLast("logger", new LoggingHandler(LogLevel.INFO));, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, +import io.netty.handler.logging.LogLevel;, + EventLoop parentLoop = new SelectorEventLoop();, + EventLoop childLoop = new SelectorEventLoop();, + .parentOption(ChannelOption.SO_BACKLOG, 24), + .childEventLoop(childLoop), + .childOption(ChannelOption.TCP_NODELAY, true), + p.addLast("logger", new LoggingHandler(LogLevel.INFO));, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.handler.logging.LogLevel;, + EventLoop loop = new SelectorEventLoop();, + p.addLast("logger", new LoggingHandler(LogLevel.INFO));, +++ b/example/src/main/java/io/netty/example/echo/EchoServer.java, +import io.netty.handler.logging.LogLevel;, + EventLoop parentLoop = new SelectorEventLoop();, + EventLoop childLoop = new SelectorEventLoop();, + .parentOption(ChannelOption.SO_BACKLOG, 24), + .childEventLoop(childLoop), + .childOption(ChannelOption.TCP_NODELAY, true), + p.addLast("logger", new LoggingHandler(LogLevel.INFO));, +++
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamChannel.java, +import io.netty.util.internal.ObjectUtil;, + // Volatile, as parent and child channel may be on different eventloops., + private volatile int streamId = -1;, + protected AbstractHttp2StreamChannel(Channel parent) {, + return isOpen();, + * This method must only be called within the parent channel's eventloop., + */, + protected void streamId(int streamId) {, + if (this.streamId != -1) {, + throw new IllegalStateException("Stream identifier may only be set once.");, + }, + this.streamId = ObjectUtil.checkPositiveOrZero(streamId, "streamId");, + }, +, + protected int streamId() {, + return streamId;, + }, +, + /**, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamChannel.java, +import io.netty.util.internal.ObjectUtil;, + // Volatile,
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java, + this.minTtl = Math.min(MAX_SUPPORTED_TTL_SECS, checkPositiveOrZero(minTtl, "minTtl"));, + this.maxTtl = Math.min(MAX_SUPPORTED_TTL_SECS, checkPositiveOrZero(maxTtl, "maxTtl"));, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java, + this.minTtl = Math.min(MAX_SUPPORTED_TTL_SECS, checkPositiveOrZero(minTtl, "minTtl"));, + this.maxTtl = Math.min(MAX_SUPPORTED_TTL_SECS, checkPositiveOrZero(maxTtl, "maxTtl"));, +++ b/resolver-dns/src/test/java/io/netty/resolver/dns/DefaultDnsCacheTest.java, + public void testExpireWithToBigMinTTL() {, + EventLoopGroup group = new NioEventLoopGroup(1);, +, + try {, + EventLoop loop = group.next();, + final DefaultDnsCache cache = new DefaultDnsCache(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);, + assertNotNull(cache.cache("netty.io", null, NetUtil.LOCALHOST, 100, loop));, + } finally {, + group.shutdownGracefully();, + }, + }, +, + @Test]
[+++ b/transport/src/main/java/io/netty/channel/oio/OioByteStreamChannel.java, + int length = Math.max(1, Math.min(available(), buf.maxWritableBytes()));]
[+++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, + boolean success = false;, + try {, + success = true;, + } finally {, + if (!success) {, + ch.close();, + }, + }, +++ b/src/main/java/io/netty/bootstrap/ClientBootstrap.java, + boolean success = false;, + try {, + success = true;, + } finally {, + if (!success) {, + ch.close();, + }, + }, +++ b/src/main/java/io/netty/bootstrap/ConnectionlessBootstrap.java, + boolean success = false;, + try {, + success = true;, + } finally {, + if (!success) {, + ch.close();, + }, + }, + boolean success = false;, + try {, + success = true;, + } finally
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + public int writeBytes(ScatteringByteChannel in, int length) throws IOException {, + ensureWritable(length);]
[+++ b/all/pom.xml, + -link https://commons.apache.org/proper/commons-logging/apidocs/, +++ b/all/pom.xml, + -link https://commons.apache.org/proper/commons-logging/apidocs/, +++ b/codec/src/test/resources/io/netty/handler/codec/xml/sample-04.xml, + <version>2.6.1</version>, + <version>1.1.3</version>, + <version>1.7.21</version>, + <version>1.2</version>, + <version>4.12</version>, + <version>3.4</version>, + <version>2.8.2</version>, + <version>1.1.7</version>, + <version>1.4.1</version>, + <version>3.5.1</version>, + <version>1.15</version>, + <version>1.1</version>, + <version>2.12.1</version>, + <version>2.5.4</version>, + <version>3.0.1</version>, + <version>2.10.4</version>, + <version>2.8.2</version>, + <!-- Downgrade to 2.4.1 if release fails -->, + <version>2.5.3</version>, + <version>1.9.7</version>, + <version>1.9.7</version>, + <version>2.19.1</version>, + <version>2.19.1</version>, + <version>3.0.0</version>, + <version>3.0.1</version>, + <version>3.0.2</version>, + <version>2.10</version>, + <version>2.6</version>, + <version>1.8</version>, + <version>1.10</version>, +++ b/all/pom.xml, + -link https://commons.apache.org/proper/commons-logging/apidocs/, +++ b/codec/src/test/resources/io/netty/handler/codec/xml/sample-04.xml, + <version>2.6.1</version>, + <version>1.1.3</version>, + <version>1.7.21</version>, + <version>1.2</version>, + <version>4.12</version>, + <version>3.4</version>, +
[+++ /dev/null, +++ /dev/null, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpNotificationHandler.java, + * {@link Notification} user event in the {@link ChannelPipeline} of a {@link SctpChannel}., + fireEvent(notification);, + fireEvent(notification);, + fireEvent(notification);, + fireEvent(notification);, + private void fireEvent(Notification notification) {, + sctpChannel.pipeline().fireUserEventTriggered(notification);, +++ /dev/null, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpNotificationHandler.java, + * {@link Notification} user event in the {@link ChannelPipeline} of a {@link SctpChannel}., + fireEvent(notification);, + fireEvent(notification);, + fireEvent(notification);, + fireEvent(notification);, + private void fireEvent(Notification notification) {, + sctpChannel.pipeline().fireUserEventTriggered(notification);, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/nio/NioSctpChannel.java, +import io.netty.channel.RecvByteBufAllocator;, + private RecvByteBufAllocator.Handle allocHandle;, +, +, + RecvByteBufAllocator.Handle allocHandle = this.allocHandle;, + if (allocHandle == null) {, + this.allocHandle = allocHandle = config().getRecvByteBufAllocator().newHandle();, + },
[+++ b/common/src/main/java/io/netty/util/internal/SuppressJava6Requirement.java, +/*, + * Copyright 2018 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java, + encodeHeaders(m.headers(), buf);, + /**, + * Encode the {@link HttpHeaders} into a {@link ByteBuf}., + */, + protected void encodeHeaders(HttpHeaders headers, ByteBuf buf) throws Exception {, + HttpHeaders.encode(headers, buf);, + }, +, + encodeHeaders(headers, buf);]
[+++ b/handler/src/main/java/io/netty/handler/ssl/PemReader.java, + throw new KeyException("could not find a PKCS #8 private key in input stream" +, + " (see http://netty.io/wiki/sslcontextbuilder-and-private-key.html for more information)");]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/CharSequenceMap.java, + public CharSequenceMap(boolean caseSensitive) {, + this(caseSensitive, UnsupportedValueConverter.<V>instance());, + public CharSequenceMap(boolean caseSensitive, ValueConverter<V> valueConverter) {, + super(caseSensitive ? CASE_SENSITIVE_HASHER : CASE_INSENSITIVE_HASHER, valueConverter);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/CharSequenceMap.java, + public CharSequenceMap(boolean caseSensitive) {, + this(caseSensitive, UnsupportedValueConverter.<V>instance());, + public CharSequenceMap(boolean caseSensitive, ValueConverter<V> valueConverter) {, + super(caseSensitive ? CASE_SENSITIVE_HASHER : CASE_INSENSITIVE_HASHER, valueConverter);, +++ b/codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompHeadersTest.java, + public void testHeadersCaseSensitive() {, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/CharSequenceMap.java, + public CharSequenceMap(boolean caseSensitive) {, + this(caseSensitive, UnsupportedValueConverter.<V>instance());, + public CharSequenceMap(boolean caseSensitive, ValueConverter<V> valueConverter) {, + super(caseSensitive ? CASE_SENSITIVE_HASHER : CASE_INSENSITIVE_HASHER, valueConverter);, +++ b/codec-stomp/src/test/java/io/netty/handler/codec/stomp/StompHeadersTest.java, + public void testHeadersCaseSensitive() {, +++ b/common/src/test/java/io/netty/util/AsciiStringCharacterTest.java, + private static void assertContains(String a, String b, boolean caseSensitiveEquals, boolean
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, +import static io.netty.handler.codec.http.HttpHeaderNames.CONNECTION;, + private static final FullHttpResponse TOO_LARGE_CLOSE = new DefaultFullHttpResponse(, + HttpVersion.HTTP_1_1, HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE, Unpooled.EMPTY_BUFFER);, +, + TOO_LARGE_CLOSE.headers().set(CONTENT_LENGTH, 0);, + TOO_LARGE_CLOSE.headers().set(CONNECTION, HttpHeaderValues.CLOSE);, +, + // If the client started to send data already, close because it's impossible to recover., + // If keep-alive is off and 'Expect: 100-continue' is missing, no need to leave the connection open., + if (oversized instanceof FullHttpMessage ||, + !HttpUtil.is100ContinueExpected(oversized) && !HttpUtil.isKeepAlive(oversized)) {, + ChannelFuture future = ctx.writeAndFlush(TOO_LARGE_CLOSE.retainedDuplicate());, + future.addListener(new ChannelFutureListener() {, + @Override, + public void operationComplete(ChannelFuture future) throws Exception {, + if (!future.isSuccess()) {, + logger.debug("Failed to send a
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/Epoll.java, +import io.netty.util.internal.PlatformDependent;, + UNAVAILABILITY_CAUSE = PlatformDependent.hasUnsafe() ? null :, + new IllegalStateException("sun.misc.Unsafe not available");]
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + incTinySmallAllocation(tiny);, + synchronized (this) {, + }, +, + incTinySmallAllocation(tiny);, + synchronized (this) {, + ++allocationsNormal;, + }, + // Method must be called insided synchronized(this) { ... }block, + private void allocateNormal(PooledByteBuf<T> buf, int reqCapacity, int normCapacity) {, + private void incTinySmallAllocation(boolean tiny) {, + if (tiny) {, + allocationsTiny.increment();, + } else {, + allocationsSmall.increment();, + }, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + incTinySmallAllocation(tiny);, + synchronized (this) {, + }, +, + incTinySmallAllocation(tiny);, + synchronized (this) {, + ++allocationsNormal;, + }, + // Method must be called insided synchronized(this) { ... }block, + private
[+++ b/transport-native-epoll/src/main/c/netty_epoll_linuxsocket.c, + int optlen = sizeof(optval);, + // We call getsockopt directly so we can handle ENOPROTOOPT by ourself., + if (getsockopt(fd, IPPROTO_TCP, TCP_FASTOPEN_CONNECT, &optval, &optlen) == -1) {, + if (errno == ENOPROTOOPT) {, + // Not supported by the system, so just return 0., + return 0;, + }, + netty_unix_socket_getOptionHandleError(env, errno);, +++ b/transport-native-epoll/src/main/c/netty_epoll_linuxsocket.c, + int optlen = sizeof(optval);, + // We call getsockopt directly so we can handle ENOPROTOOPT by ourself., + if (getsockopt(fd, IPPROTO_TCP, TCP_FASTOPEN_CONNECT, &optval, &optlen) == -1) {, + if (errno == ENOPROTOOPT) {, + // Not supported by the system, so
[+++ b/common/src/main/java/io/netty/util/DomainMappingBuilder.java, + * @deprecated Use {@link DomainNameMappingBuilder} instead., +@Deprecated, + private final DomainNameMappingBuilder<V> builder;, + builder = new DomainNameMappingBuilder<V>(defaultValue);, + builder = new DomainNameMappingBuilder<V>(initialCapacity, defaultValue);, + builder.add(hostname, output);, + return builder.build();, +++ b/common/src/main/java/io/netty/util/DomainMappingBuilder.java, + * @deprecated Use {@link DomainNameMappingBuilder} instead., +@Deprecated, + private final DomainNameMappingBuilder<V> builder;, + builder = new DomainNameMappingBuilder<V>(defaultValue);, + builder = new DomainNameMappingBuilder<V>(initialCapacity, defaultValue);, + builder.add(hostname, output);, + return builder.build();, +++ b/common/src/main/java/io/netty/util/DomainNameMapping.java, + private final Map<String, V> unmodifiableMap;, + * @deprecated use {@link DomainNameMappingBuilder} to create and fill the mapping instead, + * @deprecated use {@link DomainNameMappingBuilder} to create and fill the mapping instead, +
[+++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, + /**, + * Return a unreleasable view on the given {@link ByteBuf} which will just ignore release and retain calls., + */, + public static ByteBuf unreleasableBuffer(ByteBuf buf) {, + return new UnreleasableByteBuf(buf);, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, + /**, + * Return a unreleasable view on the given {@link ByteBuf} which will just ignore release and retain calls., + */, + public static ByteBuf unreleasableBuffer(ByteBuf buf) {, + return new UnreleasableByteBuf(buf);, + }, +, +++ b/buffer/src/main/java/io/netty/buffer/UnreleasableByteBuf.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + private boolean isInboundFreed() {, + return (flags & FLAG_FREED_INBOUND) != 0;, + }, +, + private boolean isOutboundFreed() {, + return (flags & FLAG_FREED_OUTBOUND) != 0;, + }, +, + if (isInboundFreed()) {, + if (handler instanceof ChannelInboundByteHandler && !isInboundFreed()) {, + if (isOutboundFreed()) {, + if (handler instanceof ChannelOutboundByteHandler && !isOutboundFreed()) {, + if (isOutboundFreed()) {]
[+++ b/codec/src/main/java/io/netty/handler/codec/redis/Command.java, + static final byte[] ARGS_PREFIX = "*".getBytes();, + static final byte[] CRLF = "\r\n".getBytes();, + static final byte[] BYTES_PREFIX = "$".getBytes();, + static final byte[] EMPTY_BYTES = new byte[0];, + static final byte[] NEG_ONE_AND_CRLF = convertWithCRLF(-1);, +++ b/codec/src/main/java/io/netty/handler/codec/redis/Command.java, + static final byte[] ARGS_PREFIX = "*".getBytes();, + static final byte[] CRLF = "\r\n".getBytes();, + static final byte[] BYTES_PREFIX = "$".getBytes();, + static final byte[] EMPTY_BYTES = new byte[0];, + static final byte[] NEG_ONE_AND_CRLF = convertWithCRLF(-1);, +++ b/codec/src/main/java/io/netty/handler/codec/redis/RedisDecoder.java, +++ b/codec/src/main/java/io/netty/handler/codec/redis/Command.java, + static final byte[] ARGS_PREFIX = "*".getBytes();, + static final byte[] CRLF = "\r\n".getBytes();, + static final byte[] BYTES_PREFIX
[+++ b/buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java, + private final ByteBuf[] buffers;, + this.buffers = buffers;, + ByteBuf b = buffers[i];, + if (b instanceof Component) {, + comp = (Component) b;, + if (comp == null) {, + ByteBuf b = buffers[i];, + return b instanceof Component ? ((Component) b).buf : b;, + private static final class Component extends WrappedByteBuf {, + super(buf);, +++ b/buffer/src/main/java/io/netty/buffer/FixedCompositeByteBuf.java, + private final ByteBuf[] buffers;, + this.buffers = buffers;, + ByteBuf b = buffers[i];, + if (b instanceof Component) {, + comp = (Component) b;, + if (comp == null) {, + ByteBuf b = buffers[i];, + return
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + new ExtendedClosedChannelException(null), AbstractUnsafe.class, "ensureOpen(...)");, + new ExtendedClosedChannelException(null), AbstractUnsafe.class, "write(...)");, + private static final ClosedChannelException FLUSH0_CLOSED_CHANNEL_EXCEPTION = ThrowableUtil.unknownStackTrace(, + new ExtendedClosedChannelException(null), AbstractUnsafe.class, "flush0()");, + private Throwable initialCloseCause;, + safeSetFailure(promise, newWriteException(initialCloseCause));, + outboundBuffer.failFlushed(newFlush0Exception(initialCloseCause), false);, + initialCloseCause = t;, + close(voidPromise(), t, newFlush0Exception(t), false);, + initialCloseCause = t;, + close(voidPromise(), t2, newFlush0Exception(t), false);, + private ClosedChannelException newWriteException(Throwable cause) {, + if (cause == null) {, + return WRITE_CLOSED_CHANNEL_EXCEPTION;, + }, + return ThrowableUtil.unknownStackTrace(, + new ExtendedClosedChannelException(cause), AbstractUnsafe.class, "write(...)");, + }, +, + private ClosedChannelException newFlush0Exception(Throwable cause) {, + if (cause == null) {, + return FLUSH0_CLOSED_CHANNEL_EXCEPTION;, + }, +
[+++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Throwable e) {, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Throwable e) {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +import io.netty.channel.socket.DatagramChannel;, +import io.netty.channel.socket.ServerSocketChannel;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.channel.socket.nio.NioSocketChannelConfig;, +, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Throwable e) {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +import io.netty.channel.socket.DatagramChannel;, +import io.netty.channel.socket.ServerSocketChannel;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.channel.socket.nio.NioSocketChannelConfig;, +, +++ /dev/null, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Throwable e) {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +import io.netty.channel.socket.DatagramChannel;, +import io.netty.channel.socket.ServerSocketChannel;, +import io.netty.channel.socket.SocketChannel;, +import io.netty.channel.socket.nio.NioSocketChannelConfig;, +, +++ /dev/null, +++ /dev/null, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/socket/AbstractDatagramMulticastTest.java, +++ b/transport-sctp/src/test/java/io/netty/testsuite/transport/AbstractSocketServerBootstrapTest.java, + } catch (Throwable e) {, +++ b/transport/src/main/java/io/netty/channel/Channel.java, +import io.netty.channel.socket.DatagramChannel;, +import io.netty.channel.socket.ServerSocketChannel;, +import io.netty.channel.socket.SocketChannel;,
[+++ b/pom.xml, + <version>3.1.0.ALPHA3-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + merged.put(buffers[i]);, +++ b/buffer/src/main/java/io/netty/buffer/CompositeByteBuf.java, + merged.put(buffers[i]);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractCompositeByteBufTest.java, + public void testCompositeToSingleBuffer() {, + CompositeByteBuf buf = compositeBuffer(3);, +, + buf.addComponent(wrappedBuffer(new byte[] {1, 2, 3}));, + assertEquals(1, buf.numComponents());, +, + buf.addComponent(wrappedBuffer(new byte[] {4}));, + assertEquals(2, buf.numComponents());, +, + buf.addComponent(wrappedBuffer(new byte[] {5, 6}));, + assertEquals(3, buf.numComponents());, +, + // NOTE: hard-coding 6 here, since it seems like addComponent doesn't bump the writer index., + // I'm unsure as to whether or not this is correct behavior, + ByteBuffer nioBuffer = buf.nioBuffer(0, 6);, + byte[] bytes = nioBuffer.array();, + assertEquals(6, bytes.length);, + assertArrayEquals(new byte[] {1, 2, 3, 4, 5,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpRequestEncoder.java, + if (uri.lastIndexOf(SLASH) < start) {, + if (uri.lastIndexOf(SLASH, index) < start) {]
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, +++ /dev/null, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, +++ /dev/null, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + int lastPrimingReadResult = SSL.readFromSSL(ssl, EMPTY_ADDR, 0); // priming read, + // check if SSL_read returned <= 0. In this case we need to check the error and see if it was something, + // fatal., + if (lastPrimingReadResult <= 0) {, + }, + } else {, + // Reset to 0 as -1 is used to signal that nothing was written and no priming read needs to be done, + bytesConsumed = 0;, + }, + //, + // We first check handshakeFinished to eliminate the overhead of extra JNI call if possible., + int
[+++ b/src/docbook/custom.dtd, +<!ENTITY ChannelPipelineFactory "<ulink url='&API;channel/ChannelPipelineFactory.html'><interfacename>ChannelPipelineFactory</interfacename></ulink>">, +<!ENTITY ServerSocketChannel "<ulink url='&API;channel/socket/ServerSocketChannel.html'><interfacename>ServerSocketChannel</interfacename></ulink>">, +<!ENTITY SocketChannel "<ulink url='&API;channel/socket/SocketChannel.html'><interfacename>SocketChannel</interfacename></ulink>">, +<!ENTITY NioClientSocketChannelFactory "<ulink url='&API;channel/socket/nio/NioClientSocketChannelFactory.html'><classname>NioClientSocketChannelFactory</classname></ulink>">, +, +<!-- Types in the handler.codec.frame package -->, +, +<!ENTITY FrameDecoder "<ulink url='&API;handler/codec/frame/FrameDecoder.html'><classname>FrameDecoder</classname></ulink>">, +, +<!-- Types in the handler.codec.replay package -->, +, +<!ENTITY ReplayingDecoder "<ulink url='&API;handler/codec/replay/ReplayingDecoder.html'><classname>ReplayingDecoder</classname></ulink>">, +<!ENTITY VoidEnum "<ulink url='&API;handler/codec/replay/VoidEnum.html'><classname>VoidEnum</classname></ulink>">, +, +, +++ b/src/docbook/custom.dtd, +<!ENTITY ChannelPipelineFactory "<ulink url='&API;channel/ChannelPipelineFactory.html'><interfacename>ChannelPipelineFactory</interfacename></ulink>">, +<!ENTITY ServerSocketChannel "<ulink url='&API;channel/socket/ServerSocketChannel.html'><interfacename>ServerSocketChannel</interfacename></ulink>">, +<!ENTITY SocketChannel "<ulink url='&API;channel/socket/SocketChannel.html'><interfacename>SocketChannel</interfacename></ulink>">, +<!ENTITY NioClientSocketChannelFactory "<ulink url='&API;channel/socket/nio/NioClientSocketChannelFactory.html'><classname>NioClientSocketChannelFactory</classname></ulink>">, +, +<!-- Types in the handler.codec.frame package -->, +, +<!ENTITY FrameDecoder "<ulink url='&API;handler/codec/frame/FrameDecoder.html'><classname>FrameDecoder</classname></ulink>">, +, +<!-- Types in the handler.codec.replay package -->, +, +<!ENTITY ReplayingDecoder "<ulink url='&API;handler/codec/replay/ReplayingDecoder.html'><classname>ReplayingDecoder</classname></ulink>">, +<!ENTITY VoidEnum "<ulink url='&API;handler/codec/replay/VoidEnum.html'><classname>VoidEnum</classname></ulink>">, +,
[+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java, +import io.netty.util.internal.StringUtil;, + Entries entries = resolveCache.remove(appendDot(hostname));, + Entries entries = resolveCache.get(appendDot(hostname));, + cache0(appendDot(hostname), e,, + Math.max(minTtl, Math.min(MAX_SUPPORTED_TTL_SECS, (int) Math.min(maxTtl, originalTtl))), loop);, + cache0(appendDot(hostname), e, Math.min(MAX_SUPPORTED_TTL_SECS, negativeTtl), loop);, + private void cache0(String hostname, DefaultDnsCacheEntry e, int ttl, EventLoop loop) {, + Entries entries = resolveCache.get(hostname);, + Entries oldEntries = resolveCache.putIfAbsent(hostname, entries);, + scheduleCacheExpiration(hostname, e, ttl, loop);, + private void scheduleCacheExpiration(final String hostname, final DefaultDnsCacheEntry e,, + Entries entries = resolveCache.remove(hostname);, +, + private static String appendDot(String hostname) {, + return StringUtil.endsWith(hostname, '.') ? hostname : hostname + '.';, + }, +++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DefaultDnsCache.java, +import io.netty.util.internal.StringUtil;, + Entries entries
[+++ b/all/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta6-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, +++ b/common/src/main/java/io/netty/util/AbstractReferenceCounted.java]
[+++ b/common/pom.xml, +++ b/common/pom.xml, +++ b/pom.xml, + <!-- add "verify" back after karaf release -->, +++ b/common/pom.xml, +++ b/pom.xml, + <!-- add "verify" back after karaf release -->, +++ /dev/null, +++ b/common/pom.xml, +++ b/pom.xml, + <!-- add "verify" back after karaf release -->, +++ /dev/null, +++ /dev/null, +++ b/common/pom.xml, +++ b/pom.xml, + <!-- add "verify" back after karaf release -->, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/common/pom.xml, +++ b/pom.xml, + <!-- add "verify" back after karaf release -->, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/common/pom.xml, +++ b/pom.xml, + <!-- add "verify" back after karaf release
[+++ b/pom.xml, + <jetty.alpnAgent.version>2.0.8</jetty.alpnAgent.version>]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + if (future.isSuccess()) {, + if (errorCode != NO_ERROR.code()) {, + ctx.close();, + }, + } else {, + if (logger.isErrorEnabled()) {, + logger.error(, + format("Sending GOAWAY failed: lastStreamId '%d', errorCode '%d', debugData '%s'.",, + lastStreamId, errorCode, debugData), future.cause());, + }, + ctx.close();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + if (future.isSuccess()) {, + if (errorCode != NO_ERROR.code()) {, + ctx.close();, + }, + } else {, + if (logger.isErrorEnabled()) {, + logger.error(, + format("Sending GOAWAY failed: lastStreamId '%d', errorCode '%d', debugData '%s'.",, + lastStreamId, errorCode, debugData), future.cause());, + }, + ctx.close();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2LifecycleManager.java, + * Prevents the peer from creating
[+++ b/all/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/example/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.Alpha4-SNAPSHOT</version>, +++ b/codec/pom.xml, +
[+++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, + private static final InternalLogger logger =, + InternalLoggerFactory.getInstance(DiscardClient.class);, +, + logger.error(, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, + private static final InternalLogger logger =, + InternalLoggerFactory.getInstance(DiscardClient.class);, +, + logger.error(, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, + private static final InternalLogger logger =, + InternalLoggerFactory.getInstance(EchoClient.class);, +, + logger.error(, +++ b/example/src/main/java/io/netty/example/discard/DiscardClient.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, + private static final InternalLogger logger =, + InternalLoggerFactory.getInstance(DiscardClient.class);, +, + logger.error(, +++ b/example/src/main/java/io/netty/example/echo/EchoClient.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, + private static final InternalLogger logger =, + InternalLoggerFactory.getInstance(EchoClient.class);, +, + logger.error(, +++ b/example/src/main/java/io/netty/example/factorial/FactorialClient.java, +import io.netty.logging.InternalLogger;, +import io.netty.logging.InternalLoggerFactory;, + private static
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFrameDecoder.java, + private static final int SNAPPY_IDENTIFIER_LEN = 6;, + if (chunkLength != SNAPPY_IDENTIFIER_LEN) {, + if (inSize < 4 + SNAPPY_IDENTIFIER_LEN) {, + in.skipBytes(4);, + int offset = in.readerIndex();, + in.skipBytes(SNAPPY_IDENTIFIER_LEN);, + checkByte(in.getByte(offset++), (byte) 's');, + checkByte(in.getByte(offset++), (byte) 'N');, + checkByte(in.getByte(offset++), (byte) 'a');, + checkByte(in.getByte(offset++), (byte) 'P');, + checkByte(in.getByte(offset++), (byte) 'p');, + checkByte(in.getByte(offset), (byte) 'Y');, + private static void checkByte(byte actual, byte expect) {, + if (actual != expect) {, + throw new DecompressionException("Unexpected stream identifier contents. Mismatched snappy " +, + "protocol version?");, + }, + }, +]
[+++ b/handler/src/main/java/io/netty/handler/ssl/ApplicationProtocolConfig.java, +import javax.net.ssl.SSLEngine;, +import static io.netty.handler.ssl.ApplicationProtocolUtil.*;, +import static io.netty.util.internal.ObjectUtil.*;, +, + /**, + * The configuration that disables application protocol negotiation., + */, + public static final ApplicationProtocolConfig DISABLED = new ApplicationProtocolConfig();, +, + private ApplicationProtocolConfig(, + Protocol protocol, SelectorFailureBehavior selectorBehavior,, +, + if (protocol == Protocol.NONE) {, + throw new IllegalArgumentException("protocol (" + Protocol.NONE + ") must not be " + Protocol.NONE + '.');, + }, + }, +, + /**, + * A special constructor that is used to instantiate {@link #DISABLED}., + */, + private ApplicationProtocolConfig() {, + supportedProtocols = Collections.emptyList();, + protocol = Protocol.NONE;,
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +void throwOutOfMemoryError(JNIEnv* env) {, + (*env)->ThrowNew(env, exceptionClass, "");, + throwRuntimeException(env, exceptionMessage("getsockopt() failed: ", err));, + throwRuntimeException(env, exceptionMessage("setsockopt() failed: ", err));, + throwOutOfMemoryError(env);, + throwOutOfMemoryError(env);, + throwOutOfMemoryError(env);, + throwRuntimeException(env, "failed to get method ID: ClosedChannelException.<init>()");, + throwOutOfMemoryError(env);, + throwOutOfMemoryError(env);, + throwOutOfMemoryError(env);, + throwOutOfMemoryError(env);, + throwOutOfMemoryError(env);, + throwOutOfMemoryError(env);, + throwRuntimeException(env, "failed to get method ID: ByteBuffer.position()");, + throwRuntimeException(env, "failed to get method ID: ByteBuffer.limit()");, + throwRuntimeException(env, "failed to fet method ID: ByteBuffer.position(int)");, + throwRuntimeException(env, "failed to get field ID: DefaultFileRegion.file");, + throwRuntimeException(env, "failed to get field ID: DefaultFileRegion.transfered");, + throwRuntimeException(env, "failed to get field ID: FileChannelImpl.fd");, + throwRuntimeException(env, "failed
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioChannel.java, + // FIXME: Magic number, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioChannel.java, + // FIXME: Magic number, +++ b/transport/src/main/java/io/netty/channel/socket/oio/OioSocketChannel.java, +import java.io.InputStream;, + private InputStream is;, + is = socket.getInputStream();, + is = socket.getInputStream();, + if (available > 0) {, + } else if (!buf.writable()) {, + // FIXME: Magic number, + buf.ensureWritableBytes(4096);, + }, +, + int readBytes = buf.writeBytes(is, buf.writableBytes());, + if (!buf.writable()) {, + // FIXME: Magic number, + buf.ensureWritableBytes(4096);, + }, + return readBytes;]
[+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundInvoker.java, + * failed with an {@link IncompleteFlushException}. So if you are interested to know if it was partial successful, + * you need to check if the returned {@link ChannelFuture#cause()} returns an instance of, + * to the remote peer. In such cases the {@link ChannelFuture} will be failed with a, + * {@link IncompleteFlushException}. In such cases you may want to call {@link #flush(ChannelPromise)} or, + * {@link #flush()} to flush the rest of the data or just close the connection via {@link #close(ChannelPromise)}, + * or {@link #close()} if it is not possible to recover.,
[+++ b/common/src/main/java/io/netty/util/internal/ObjectUtil.java, + * Checks that the given argument is strictly positive. If it is not, throws {@link IllegalArgumentException}., + * Checks that the given argument is strictly positive. If it is not, throws {@link IllegalArgumentException}., + * Checks that the given argument is positive or zero. If it is not , throws {@link IllegalArgumentException}., + * Checks that the given argument is positive or zero. If it is not, throws {@link IllegalArgumentException}.]
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/AbstractTestsuiteTest.java, + Method m = getClass().getMethod(, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/AbstractTestsuiteTest.java, + Method m = getClass().getMethod(, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketConnectionAttemptTest.java, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelHandler;, +import io.netty.testsuite.util.TestUtils;, +import io.netty.util.NetUtil;, +import io.netty.util.concurrent.GlobalEventExecutor;, +import io.netty.util.concurrent.Promise;, + @Test(timeout = 30000), + public void testConnectRefused() throws Throwable {, + run();, + }, +, + public void testConnectRefused(Bootstrap cb) throws Throwable {, + testConnectRefused0(cb, false);, + }, +, + @Test(timeout = 30000), + public void testConnectRefusedHalfClosure() throws Throwable {, + run();, + }, +, + public void testConnectRefusedHalfClosure(Bootstrap cb) throws Throwable {, + testConnectRefused0(cb, true);, + }, +, + private static void testConnectRefused0(Bootstrap cb, boolean halfClosure) throws Throwable {,
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToByteDecoder.java, + private volatile boolean singleDecode;, +, + /**, + * If set then only one message is decoded on each {@link #inboundBufferUpdated(ChannelHandlerContext)} call., + * This may be useful if you need to do some protocol upgrade and want to make sure nothing is mixed up., + *, + * Default is {@code false} as this has performance impacts., + */, + public void setSingleDecode(boolean singleDecode) {, + this.singleDecode = singleDecode;, + }, +, + /**, + * If {@code true} then only one message is decoded on each, + * {@link #inboundBufferUpdated(ChannelHandlerContext)} call., + *, +
[+++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java, + public boolean isWritable() {, + return false;, + }, +, + @Override, + public boolean isWritable(int numBytes) {, + return false;, + }, +, + @Override, +++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBuf.java, + public boolean isWritable() {, + return false;, + }, +, + @Override, + public boolean isWritable(int numBytes) {, + return false;, + }, +, + @Override, +++ b/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java, +, + public void shouldIndicateNotWriteable() {, + assertFalse(unmodifiableBuffer(buffer(1)).isWritable());, + }, +, + public void shouldIndicteNotWritableAnyNumber() {, + assertFalse(unmodifiableBuffer(buffer(1)).isWritable(1));, + }]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + // Disable ticket support by default to be more inline with SSLEngineImpl of the JDK., + // This also let SSLSession.getId() work the same way for the JDK implementation and the OpenSSLEngine., + // If tickets are supported SSLSession.getId() will only return an ID on the server-side if it could, + // make use of tickets., + SSLContext.setOptions(ctx, SSL.SSL_OP_NO_TICKET);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + // Disable ticket support by default to be more inline with SSLEngineImpl of the JDK., + // This also let SSLSession.getId() work the same way for the JDK implementation and the OpenSSLEngine., + //
[+++ b/common/pom.xml, +++ b/common/pom.xml, +++ b/pom.xml, + <version>1.16</version>, + <!-- NioDatagramChannel implementation -->, + <ignore>java.net.ProtocolFamily</ignore>, +, + <version>3.1.0</version>]
[+++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, + return UnsafeByteBufUtil.getByte(addr(index));, + return UnsafeByteBufUtil.getShort(addr(index));, + return UnsafeByteBufUtil.getUnsignedMedium(addr(index));, + return UnsafeByteBufUtil.getInt(addr(index));, + return UnsafeByteBufUtil.getLong(addr(index));, + UnsafeByteBufUtil.setByte(addr(index), (byte) value);, + UnsafeByteBufUtil.setShort(addr(index), value);, + UnsafeByteBufUtil.setMedium(addr(index), value);, + UnsafeByteBufUtil.setInt(addr(index), value);, + UnsafeByteBufUtil.setLong(addr(index), value);, + if (PlatformDependent.isUnaligned()) {, + // Only use if unaligned access is supported otherwise there is no gain., + return super.newSwappedByteBuf();, + }, +++ b/buffer/src/main/java/io/netty/buffer/PooledUnsafeDirectByteBuf.java, + return UnsafeByteBufUtil.getByte(addr(index));, + return UnsafeByteBufUtil.getShort(addr(index));, + return UnsafeByteBufUtil.getUnsignedMedium(addr(index));, + return UnsafeByteBufUtil.getInt(addr(index));, + return UnsafeByteBufUtil.getLong(addr(index));, + UnsafeByteBufUtil.setByte(addr(index), (byte) value);, + UnsafeByteBufUtil.setShort(addr(index), value);, + UnsafeByteBufUtil.setMedium(addr(index), value);, + UnsafeByteBufUtil.setInt(addr(index), value);, + UnsafeByteBufUtil.setLong(addr(index), value);, + if (PlatformDependent.isUnaligned()) {, + // Only use if unaligned
[+++ b/all/pom.xml, + <version>4.1.10.Final</version>, +++ b/all/pom.xml, + <version>4.1.10.Final</version>, +++ b/bom/pom.xml, + <version>4.1.10.Final</version>, + <tag>netty-4.1.10.Final</tag>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, +++ b/all/pom.xml, + <version>4.1.10.Final</version>, +++ b/bom/pom.xml, + <version>4.1.10.Final</version>, + <tag>netty-4.1.10.Final</tag>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, + <version>4.1.10.Final</version>, +
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/FastLz.java, + * constants which use by {@link FastLzFrameEncoder} and {@link FastLzFrameDecoder}., +++ b/codec/src/main/java/io/netty/handler/codec/compression/FastLz.java, + * constants which use by {@link FastLzFrameEncoder} and {@link FastLzFrameDecoder}., +++ b/codec/src/main/java/io/netty/handler/codec/compression/FastLzFrameDecoder.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +, + /**, + * Return the constructed raw path for the give {@link URI}., + */, + static String rawPath(URI wsURL) {, + String path = wsURL.getRawPath();, + String query = wsURL.getQuery();, + if (query != null && !query.isEmpty()) {, + path = path + '?' + query;, + }, +, + return path == null || path.isEmpty() ? "/" : path;, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker.java, +, + /**, + * Return the constructed raw path for the give {@link URI}., + */, + static String rawPath(URI wsURL) {, + String path = wsURL.getRawPath();, + String
[+++ b/all/pom.xml, +, + <!-- Only include in full profile as this will not work on Java9 yet -->, + <!-- https://issues.apache.org/jira/browse/JXR-133 -->, + <build>, + <plugins>, + <!-- Generate Xref -->, + <plugin>, + <artifactId>maven-jxr-plugin</artifactId>, + <executions>, + <execution>, + <id>generate-xref</id>, + <phase>package</phase>, + <goals>, + <goal>jxr</goal>, + </goals>, + </execution>, + </executions>, + <configuration>, + <linkJavadoc>true</linkJavadoc>, + <destDir>${project.build.directory}/xref</destDir>, + <javadocDir>${project.build.directory}/api</javadocDir>, + <docTitle>Netty Source Xref (${project.version})</docTitle>, + <windowTitle>Netty Source Xref (${project.version})</windowTitle>, + </configuration>, + <dependencies>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-build</artifactId>, + <version>19</version>, + <exclusions>, + <!-- Use version 7.3 until a new netty-build release is out -->,
[+++ b/pom.xml, + <tcnative.version>2.0.0.Beta7</tcnative.version>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/AbstractMemoryHttpData.java, + ByteBuf chunk = byteBuf.slice(chunkPosition, sliceLength).retain();]
[+++ b/example/src/main/java/io/netty/example/telnet/TelnetClientHandler.java, +import io.netty.channel.ChannelHandler.Sharable;, +@Sharable, +++ b/example/src/main/java/io/netty/example/telnet/TelnetClientHandler.java, +import io.netty.channel.ChannelHandler.Sharable;, +@Sharable, +++ b/example/src/main/java/io/netty/example/telnet/TelnetClientInitializer.java, + private static final StringDecoder DECODER = new StringDecoder();, + private static final StringEncoder ENCODER = new StringEncoder();, + private static final TelnetClientHandler CLIENTHANDLER = new TelnetClientHandler();, + pipeline.addLast("decoder", DECODER);, + pipeline.addLast("encoder", ENCODER);, + pipeline.addLast("handler", CLIENTHANDLER);, +++ b/example/src/main/java/io/netty/example/telnet/TelnetClientHandler.java, +import io.netty.channel.ChannelHandler.Sharable;, +@Sharable, +++ b/example/src/main/java/io/netty/example/telnet/TelnetClientInitializer.java, + private static final StringDecoder DECODER = new StringDecoder();, + private static final StringEncoder ENCODER = new StringEncoder();, + private static final TelnetClientHandler CLIENTHANDLER = new TelnetClientHandler();, + pipeline.addLast("decoder", DECODER);, + pipeline.addLast("encoder", ENCODER);, + pipeline.addLast("handler", CLIENTHANDLER);, +++ b/example/src/main/java/io/netty/example/telnet/TelnetServerHandler.java, +import io.netty.channel.ChannelHandler.Sharable;, +@Sharable, +++ b/example/src/main/java/io/netty/example/telnet/TelnetClientHandler.java, +import
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + private final DefaultChannelPipeline pipeline;, + pipeline = new DefaultChannelPipeline(this);, + return pipeline.directOutbound;, + final ChannelBufferHolder<Object> out = directOutbound();, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + private final DefaultChannelPipeline pipeline;, + pipeline = new DefaultChannelPipeline(this);, + return pipeline.directOutbound;, + final ChannelBufferHolder<Object> out = directOutbound();, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +import java.util.concurrent.BlockingQueue;, +import java.util.concurrent.atomic.AtomicReference;, + final ChannelBufferHolder<Object> out;, +, + // When the two handlers run in a different thread and they are next to each other,, + // each other's buffers can be accessed at the same time resuslting in a race condition., + // To avoid such situation, we lazily creates an additional
[+++ b/common/pom.xml, + <!-- JCTools is shaded -->, + <Import-Package>!org.jctools.*;sun.misc;resolution:=optional;*</Import-Package>, +++ b/common/pom.xml, + <!-- JCTools is shaded -->, + <Import-Package>!org.jctools.*;sun.misc;resolution:=optional;*</Import-Package>, +++ b/example/pom.xml, +++ b/common/pom.xml, + <!-- JCTools is shaded -->, + <Import-Package>!org.jctools.*;sun.misc;resolution:=optional;*</Import-Package>, +++ b/example/pom.xml, +++ b/pom.xml]
[+++ b/all/pom.xml, + <version>4.1.0.CR3</version>, +++ b/all/pom.xml, + <version>4.1.0.CR3</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR3</version>, +++ b/all/pom.xml, + <version>4.1.0.CR3</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR3</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR3</version>, +++ b/all/pom.xml, + <version>4.1.0.CR3</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR3</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR3</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR3</version>, +++ b/all/pom.xml, + <version>4.1.0.CR3</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR3</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR3</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR3</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR3</version>, +++ b/all/pom.xml, + <version>4.1.0.CR3</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR3</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR3</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.CR3</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.CR3</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.CR3</version>, +++ b/all/pom.xml, + <version>4.1.0.CR3</version>, +++ b/buffer/pom.xml, + <version>4.1.0.CR3</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.CR3</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioChannelConfig.java]
[+++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java, + * Returns the context of the first {@link ChannelHandler} in this pipeline., + *, + * @return the context of the first handler. {@code null} if this pipeline is empty., + */, + ChannelHandlerContext firstContext();, +, + /**, + * Returns the context of the last {@link ChannelHandler} in this pipeline., + *, + * @return the context of the last handler. {@code null} if this pipeline is empty., + */, + ChannelHandlerContext lastContext();, +, + /**, +++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java, + * Returns the context of the first {@link ChannelHandler} in this pipeline., + *, + *
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + if (servernames != null) {, + + " instances are supported, but found: " +, + serverName);, + }]
[+++ b/handler/src/main/java/io/netty/handler/timeout/ReadTimeoutHandler.java, + private long lastReadTime;, +, + private volatile boolean reading;, + reading = true;, + @Override, + public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {, + lastReadTime = System.nanoTime();, + reading = false;, + ctx.fireChannelReadComplete();, + }, +, + long nextDelay = timeoutNanos;, + if (!reading) {, + nextDelay -= currentTime - lastReadTime;, + }, +]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + protected AbstractByteBuf(ByteOrder endianness) {, + markedReaderIndex = Math.max(markedReaderIndex - readerIndex, 0);, + markedWriterIndex = Math.max(markedWriterIndex - readerIndex, 0);, + markedReaderIndex = Math.max(markedReaderIndex - readerIndex, 0);, + markedWriterIndex = Math.max(markedWriterIndex - readerIndex, 0);, + public void ensureWritableBytes(int writableBytes) {, + if (writableBytes > writableBytes()) {, + throw new IndexOutOfBoundsException("Writable bytes exceeded: Got ", + + writableBytes + ", maximum is " + writableBytes());, + ByteBuf buf = factory().getBuffer(order(), length);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + protected AbstractByteBuf(ByteOrder endianness) {, + markedReaderIndex = Math.max(markedReaderIndex - readerIndex, 0);, + markedWriterIndex = Math.max(markedWriterIndex - readerIndex, 0);, + markedReaderIndex = Math.max(markedReaderIndex - readerIndex, 0);,
[+++ b/microbench/pom.xml, + <groupId>junit</groupId>, + <artifactId>junit</artifactId>, + <scope>compile</scope>, + </dependency>, + <dependency>, + <testSourceDirectory>${project.build.sourceDirectory}</testSourceDirectory>, + <testClassesDirectory>${project.build.outputDirectory}</testClassesDirectory>, + <exclude>**/generated/*.class</exclude>, + <plugin>, + <groupId>org.apache.felix</groupId>, + <artifactId>maven-bundle-plugin</artifactId>, + <executions>, + <execution>, + <id>generate-manifest</id>, + <phase>process-classes</phase>, + <goals>, + <goal>manifest</goal>, + </goals>, + <configuration>, + <supportedProjectTypes>, + <supportedProjectType>jar</supportedProjectType>, + <supportedProjectType>bundle</supportedProjectType>, + </supportedProjectTypes>, + <instructions>, + <Export-Package>${project.groupId}.*</Export-Package>, + <Export-Package>!*.generated.*</Export-Package>, + <!-- enforce JVM vendor package as optional -->, + <Import-Package>sun.nio.ch;resolution:=optional,org.eclipse.jetty.npn;version="[1,2)";resolution:=optional,org.eclipse.jetty.alpn;version="[1,2)";resolution:=optional,*</Import-Package>, + <!-- override "internal" private package convention -->, + <Private-Package>!*</Private-Package>, + </instructions>, + </configuration>, + </execution>, + </executions>, + </plugin>, +++ b/microbench/pom.xml, + <groupId>junit</groupId>, + <artifactId>junit</artifactId>, + <scope>compile</scope>, + </dependency>, + <dependency>, + <testSourceDirectory>${project.build.sourceDirectory}</testSourceDirectory>,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + * An interface defining an, + * <a href="http://en.wikipedia.org/wiki/HTTP_cookie">HTTP cookie</a>., + * Gets the name of this {@link Cookie}., + *, + * @return The name of this {@link Cookie}, + * Gets the value of this {@link Cookie}., + *, + * @return The value of this {@link Cookie}, + * Sets the value of this {@link Cookie}., + *, + * @param value The value to set, + * Gets the domain of this {@link Cookie}., + *, + * @return The domain of this {@link Cookie}, + * Sets the domain of this
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, + // check but do not changed readerIndex, + nextByte = undecodedChunk.getByte(undecodedChunk.readerIndex());, + // force read, + undecodedChunk.readByte();, + } else {, + // Write CR (not followed by LF), + line.writeByte(HttpConstants.CR);, + } else {, + // Write CR (not followed by LF), + sao.pos--;, + line.writeByte(HttpConstants.CR);, + } else {, + // error CR without LF, + // delimiter not found so break here !, + undecodedChunk.readerIndex(readerIndex);, + throw new NotEnoughDataDecoderException();, + } else {, + // error CR without LF, + // delimiter not found so break here !, + undecodedChunk.readerIndex(readerIndex);, + throw new
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelConfig.java, + ALLOCATOR, AUTO_READ, RCVBUF_ALLOCATOR, WRITE_BUFFER_HIGH_WATER_MARK,, + WRITE_BUFFER_LOW_WATER_MARK);, + if (option == WRITE_BUFFER_HIGH_WATER_MARK) {, + return (T) Integer.valueOf(getWriteBufferHighWaterMark());, + }, + if (option == WRITE_BUFFER_LOW_WATER_MARK) {, + return (T) Integer.valueOf(getWriteBufferLowWaterMark());, + }, + } else if (option == WRITE_BUFFER_HIGH_WATER_MARK) {, + setWriteBufferHighWaterMark((Integer) value);, + } else if (option == WRITE_BUFFER_LOW_WATER_MARK) {, + setWriteBufferLowWaterMark((Integer) value);]
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, + length = in.readUnsignedShortLE();, + int offset = in.readUnsignedShortLE();, + * the permissible bounds of an offset (0 < offset < Integer.MAX_VALUE), and does not, + if (offset == 0) {, + throw new DecompressionException("Offset is less than minimum permissible value");, + if (offset < 0) {, + // Due to arithmetic overflow, + throw new DecompressionException("Offset is greater than maximum value supported by this implementation");, +++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java, + length = in.readUnsignedShortLE();, + int offset = in.readUnsignedShortLE();, + * the permissible bounds of an offset (0 < offset < Integer.MAX_VALUE), and does not, + if (offset ==
[+++ b/buffer/src/main/java/io/netty/buffer/AdvancedLeakAwareByteBuf.java]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, + * @see {@link DefaultHttp2HeadersDecoder(boolean)}, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, + * @see {@link DefaultHttp2HeadersDecoder(boolean)}, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, + public DefaultHttp2FrameWriter(Http2HeadersEncoder.SensitivityDetector headersSensativityDetector) {, + this(new DefaultHttp2HeadersEncoder(Http2CodecUtil.DEFAULT_HEADER_TABLE_SIZE, headersSensativityDetector));, + }, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, + * @see {@link DefaultHttp2HeadersDecoder(boolean)}, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameWriter.java, + public DefaultHttp2FrameWriter(Http2HeadersEncoder.SensitivityDetector headersSensativityDetector) {, + this(new DefaultHttp2HeadersEncoder(Http2CodecUtil.DEFAULT_HEADER_TABLE_SIZE, headersSensativityDetector));, + }, +, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + private Http2HeadersEncoder.SensitivityDetector headersSensativityDetector =, + Http2HeadersEncoder.NEVER_SENSITIVE;, + * Set the {@link Http2HeadersEncoder.SensitivityDetector} that will be used., + */, + public B headersSensativityDetector(Http2HeadersEncoder.SensitivityDetector headersSensativityDetector) {, + this.headersSensativityDetector = checkNotNull(headersSensativityDetector, "headersSensativityDetector");, + return thisB();, + }, +, + /**, + Http2FrameWriter writer = new DefaultHttp2FrameWriter(headersSensativityDetector);, + * <ul>, +
[+++ b/common/src/main/java/io/netty/util/internal/StringUtil.java, + * Unescapes the specified escaped CSV field, if necessary according to, + * <a href="https://tools.ietf.org/html/rfc4180#section-2">RFC-4180</a>., + *, + * @param value The escaped CSV field which will be unescaped according to, + * <a href="https://tools.ietf.org/html/rfc4180#section-2">RFC-4180</a>, + * @return {@link CharSequence} the unescaped value if necessary, or the value unchanged, + */, + public static CharSequence unescapeCsv(CharSequence value) {, + int length = checkNotNull(value, "value").length();, + if (length == 0) {, + return value;, + }, + int last = length - 1;, + boolean quoted = isDoubleQuote(value.charAt(0)) && isDoubleQuote(value.charAt(last)) && length != 1;, + if (!quoted)
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/transport/src/main/java/io/netty/channel/ChannelConfig.java, +import java.util.Map;, +, +++ /dev/null, +++ /dev/null, +++ b/transport/src/main/java/io/netty/channel/ChannelConfig.java, +import java.util.Map;, +, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/transport/src/main/java/io/netty/channel/ChannelConfig.java, +import java.util.Map;, +, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/transport/src/main/java/io/netty/channel/ChannelConfig.java, +import java.util.Map;, +, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/transport/src/main/java/io/netty/channel/ChannelConfig.java, +import java.util.Map;, +, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null]
[+++ b/pom.xml, + <version>3.1.2.GA</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.1.2.GA</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.1.2.GA</developerConnection>]
[+++ b/handler/src/main/java/io/netty/handler/ssl/SslContextBuilder.java, + return new SslContextBuilder(false);, + return new SslContextBuilder(true).keyManager(keyCertChainFile, keyFile);, + return new SslContextBuilder(true).keyManager(keyCertChainFile, keyFile, keyPassword);]
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseEncoderTest.java, + public long transferred() {, + return 0;, + }, +, + @Override, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseEncoderTest.java, + public long transferred() {, + return 0;, + }, +, + @Override, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + if (region.transferred() >= regionCount) {, + final long offset = region.transferred();, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseEncoderTest.java, + public long transferred() {, + return 0;, + }, +, + @Override, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/AbstractEpollStreamChannel.java, + if (region.transferred() >= regionCount) {, + final long offset = region.transferred();, +++ b/transport/src/main/java/io/netty/channel/DefaultFileRegion.java, + @Deprecated, + public long transferred() {, + return transfered;, + }, +, + @Override, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpResponseEncoderTest.java, + public long transferred() {, + return
[+++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyByteBufferBuf.java, + ensureAccessible();, + if (length == 0) {, + return this;, + }, +, + if (buffer.hasArray()) {, + out.write(buffer.array(), index + buffer.arrayOffset(), length);, + } else {, + byte[] tmp = new byte[length];, + ByteBuffer tmpBuf = internalNioBuffer();, + tmpBuf.clear().position(index);, + tmpBuf.get(tmp);, + out.write(tmp);, + }, + return this;, + ensureAccessible();, + if (length == 0) {, + return 0;, + }, +, + ByteBuffer tmpBuf = internalNioBuffer();, + tmpBuf.clear().position(index).limit(index + length);, + return out.write(tmpBuf);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + final CharSequence acceptEncoding;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + final CharSequence acceptEncoding;, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java, + MqttMessage message = MqttMessageFactory.newMessage(, + mqttFixedHeader, variableHeader, decodedPayload.value);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + final CharSequence acceptEncoding;, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java, + MqttMessage message = MqttMessageFactory.newMessage(, + mqttFixedHeader, variableHeader, decodedPayload.value);, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/SocksAuthRequestDecoder.java, + if (byteBuf.readByte() != SocksSubnegotiationVersion.AUTH_PASSWORD.byteValue()) {, + out.add(SocksCommonUtils.UNKNOWN_SOCKS_REQUEST);, + int fieldLength = byteBuf.readByte();, + int fieldLength = byteBuf.readByte();, + String password = SocksCommonUtils.readUsAscii(byteBuf, fieldLength);, + out.add(new SocksAuthRequest(username, password));, + break;, + }, + default: {, + throw new Error();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + final CharSequence acceptEncoding;, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java, + MqttMessage message = MqttMessageFactory.newMessage(, + mqttFixedHeader, variableHeader, decodedPayload.value);, +++
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioChannel.java, +, + @Override, + protected boolean isCompatible(EventLoop loop) {, + return loop instanceof NioChildEventLoop;, + }, +, + @Override, + protected boolean isFlushPending() {, + return (selectionKey.interestOps() & SelectionKey.OP_WRITE) != 0;, + }, +, + @Override, + protected void doRegister() throws Exception {, + NioChildEventLoop loop = (NioChildEventLoop) eventLoop();, + selectionKey = javaChannel().register(, + loop.selector, isActive()? defaultInterestOps : 0, this);, + }, +, + @Override, + protected void doDeregister() throws Exception {, + ((NioChildEventLoop) eventLoop()).cancel(selectionKey());, + }, +, + protected abstract boolean doConnect(SocketAddress remoteAddress, SocketAddress localAddress) throws Exception;, + protected abstract void doFinishConnect() throws Exception;, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioChannel.java,
[+++ b/handler/src/test/java/io/netty/handler/ssl/CipherSuiteCanaryTest.java, +import io.netty.channel.SimpleChannelInboundHandler;, +import java.security.NoSuchAlgorithmException;, +import java.util.Collections;, +import javax.net.ssl.SSLContext;, +import javax.net.ssl.SSLEngine;, +, + private static void assumeCipherAvailable(SslProvider provider, String cipher) throws NoSuchAlgorithmException {, + boolean cipherSupported = false;, + if (provider == SslProvider.JDK) {, + SSLEngine engine = SSLContext.getDefault().createSSLEngine();, + for (String c: engine.getSupportedCipherSuites()) {, + if (cipher.equals(c)) {, + cipherSupported = true;, + break;, + }, + }, + } else {, + cipherSupported = OpenSsl.isCipherSuiteAvailable(cipher);, + }, + Assume.assumeTrue("Unsupported cipher: " + cipher, cipherSupported);, + }, +, + // Check if the cipher is supported at all which may not be the case for various JDK
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, + closeHeadersContinuation();, + }, +, + private void closeHeadersContinuation() {, + headersContinuation = null;, + private void verifyUnknownFrame() throws Http2Exception {, + if (headersContinuation != null) {, + int streamId = headersContinuation.getStreamId();, + closeHeadersContinuation();, + throw connectionError(PROTOCOL_ERROR, "Extension frames must not be in the middle of headers ", + + "on stream %d", streamId);, + }, + }, +, + resetHeadersContinuationIfEnd(flags.endOfHeaders());, + resetHeadersContinuationIfEnd(flags.endOfHeaders());, + }, +, + private void resetHeadersContinuationIfEnd(boolean endOfHeaders) {, + if (endOfHeaders) {, + closeHeadersContinuation();, + }, + resetHeadersContinuationIfEnd(flags.endOfHeaders());, + resetHeadersContinuationIfEnd(flags.endOfHeaders());, + verifyUnknownFrame();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2FrameReader.java, + closeHeadersContinuation();, + }, +, + private void closeHeadersContinuation()
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + private final ChannelBufferHolder<Object> outbound;, + @SuppressWarnings("unchecked"), + outbound = (ChannelBufferHolder<Object>) newOutboundBuffer();, + return outbound;, + protected abstract ChannelBufferHolder<?> newOutboundBuffer();, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + private final ChannelBufferHolder<Object> outbound;, + @SuppressWarnings("unchecked"), + outbound = (ChannelBufferHolder<Object>) newOutboundBuffer();, + return outbound;, + protected abstract ChannelBufferHolder<?> newOutboundBuffer();, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, + protected ChannelBufferHolder<Object> newOutboundBuffer() {, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + private final ChannelBufferHolder<Object> outbound;, + @SuppressWarnings("unchecked"), + outbound = (ChannelBufferHolder<Object>) newOutboundBuffer();, + return outbound;, + protected abstract ChannelBufferHolder<?> newOutboundBuffer();, +++ b/transport/src/main/java/io/netty/channel/AbstractServerChannel.java, + protected ChannelBufferHolder<Object> newOutboundBuffer() {, +++ b/transport/src/main/java/io/netty/channel/socket/nio/AbstractNioMessageChannel.java, + protected ChannelBufferHolder<?> newOutboundBuffer() {, + return ChannelBufferHolders.messageBuffer();, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + private final ChannelBufferHolder<Object> outbound;, + @SuppressWarnings("unchecked"),
[+++ b/pom.xml, + <version>1.2.1.GA</version>, + <version>1.2.1.GA</version>, + <version>2.1.0</version>, +++ b/pom.xml, + <version>1.2.1.GA</version>, + <version>1.2.1.GA</version>, + <version>2.1.0</version>, +++ b/src/main/java/org/jboss/netty/example/localtime/LocalTimeProtocol.java, + public static enum Continent, + implements com.google.protobuf.ProtocolMessageEnum {, + public static enum DayOfWeek, + implements com.google.protobuf.ProtocolMessageEnum {, + public static final int CONTINENT_FIELD_NUMBER = 1;, + public static final int CITY_FIELD_NUMBER = 2;, + public static org.jboss.netty.example.localtime.LocalTimeProtocol.Location parseDelimitedFrom(java.io.InputStream input), + throws java.io.IOException {, + return newBuilder().mergeDelimitedFrom(input).buildParsed();, + }, + public static org.jboss.netty.example.localtime.LocalTimeProtocol.Location parseDelimitedFrom(, + java.io.InputStream input,, + com.google.protobuf.ExtensionRegistry extensionRegistry), + throws java.io.IOException {, + return newBuilder().mergeDelimitedFrom(input, extensionRegistry), + .buildParsed();, + }, + public Builder toBuilder() { return newBuilder(this); }, +
[+++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, +import io.netty.channel.RecvByteBufAllocator;, + // Ensure the inboundBuffer is not empty as readInbound() will always call fireChannelReadComplete(), + if (!inboundBuffer.isEmpty()) {, + readInbound();, +, + private void readInbound() {, + RecvByteBufAllocator.Handle handle = unsafe().recvBufAllocHandle();, + handle.reset(config());, + ChannelPipeline pipeline = pipeline();, + do {, + Object received = inboundBuffer.poll();, + if (received == null) {, + break;, + }, + pipeline.fireChannelRead(received);, + } while (handle.continueReading());, +, + pipeline.fireChannelReadComplete();, + }, +, + readInbound();, + peer.readInbound();, +++ b/transport/src/main/java/io/netty/channel/local/LocalChannel.java, +import io.netty.channel.RecvByteBufAllocator;, + // Ensure the inboundBuffer is not empty as readInbound() will always call fireChannelReadComplete(), + if (!inboundBuffer.isEmpty()) {, +
[+++ b/pom.xml, + <version>2.3.0</version>, +++ b/pom.xml, + <version>2.3.0</version>, +++ b/src/main/java/org/jboss/netty/example/localtime/LocalTimeProtocol.java, +// source: LocalTimeProtocol.proto, +, + // @@protoc_insertion_point(enum_scope:org.jboss.netty.example.localtime.Continent), +, + // @@protoc_insertion_point(enum_scope:org.jboss.netty.example.localtime.DayOfWeek), + private Location() {, + initFields();, + }, + private Location(boolean noInit) {}, + private static final Location defaultInstance;, + private org.jboss.netty.example.localtime.LocalTimeProtocol.Continent continent_;, + private void initFields() {, + continent_ = org.jboss.netty.example.localtime.LocalTimeProtocol.Continent.AFRICA;, + }, + getSerializedSize();, + Builder builder = newBuilder();, + if (builder.mergeDelimitedFrom(input)) {, + return builder.buildParsed();, + } else {, + return null;, + }, + Builder builder = newBuilder();, + if (builder.mergeDelimitedFrom(input, extensionRegistry)) {, + return builder.buildParsed();, + } else {, + return null;, +
[+++ b/common/src/main/java/io/netty/util/internal/logging/LocationAwareSlf4JLogger.java, + static final String FQCN = LocationAwareSlf4JLogger.class.getName();, + private void log(final int level, final String message) {, + logger.log(null, FQCN, level, message, null, null);, + private void log(final int level, final String message, Throwable cause) {, + logger.log(null, FQCN, level, message, null, cause);, + }, +, + private void log(final int level, final org.slf4j.helpers.FormattingTuple tuple) {, + logger.log(null, FQCN, level, tuple.getMessage(), tuple.getArgArray(), tuple.getThrowable());, + log(TRACE_INT, msg);, + log(TRACE_INT, org.slf4j.helpers.MessageFormatter.format(format, arg));, + log(TRACE_INT, org.slf4j.helpers.MessageFormatter.format(format, argA, argB));, + log(TRACE_INT, org.slf4j.helpers.MessageFormatter.format(format, argArray));, + log(DEBUG_INT, org.slf4j.helpers.MessageFormatter.format(format, arg));, + log(DEBUG_INT, org.slf4j.helpers.MessageFormatter.format(format, argA, argB));, + log(DEBUG_INT, org.slf4j.helpers.MessageFormatter.format(format, argArray));, + log(INFO_INT, org.slf4j.helpers.MessageFormatter.format(format, arg));, +
[+++ b/handler/src/main/java/io/netty/handler/stream/ChunkedStream.java, + private boolean closed;, + if (closed) {, + return true;, + }, +, + closed = true;]
[+++ b/pom.xml, + <version>4.0.0.Alpha1-SNAPSHOT</version>]
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + return ch.isOpen();, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + return ch.isOpen();, +++ b/transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java, + return isOpen();]
[+++ b/pom.xml, + -link http://java.sun.com/products/servlet/2.5/docs/servlet-2_5-mr2/]
[+++ b/all/pom.xml, + <version>4.0.0.CR5</version>, +++ b/all/pom.xml, + <version>4.0.0.CR5</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR5</version>, +++ b/all/pom.xml, + <version>4.0.0.CR5</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR5</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR5</version>, +++ b/all/pom.xml, + <version>4.0.0.CR5</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR5</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR5</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR5</version>, +++ b/all/pom.xml, + <version>4.0.0.CR5</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR5</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR5</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR5</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR5</version>, +++ b/all/pom.xml, + <version>4.0.0.CR5</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR5</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR5</version>, +++ b/codec-socks/pom.xml, + <version>4.0.0.CR5</version>, +++ b/codec/pom.xml, + <version>4.0.0.CR5</version>, +++ b/common/pom.xml, + <version>4.0.0.CR5</version>, +++ b/all/pom.xml, + <version>4.0.0.CR5</version>, +++ b/buffer/pom.xml, + <version>4.0.0.CR5</version>, +++ b/codec-http/pom.xml, + <version>4.0.0.CR5</version>, +++ b/codec-socks/pom.xml, +
[+++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelOption.java, +public class RxtxChannelOption<T> extends ChannelOption<T> {, + public static final RxtxChannelOption<Integer> BAUD_RATE =, + new RxtxChannelOption<Integer>("BAUD_RATE");, + public static final RxtxChannelOption<Boolean> DTR =, + new RxtxChannelOption<Boolean>("DTR");, + public static final RxtxChannelOption<Boolean> RTS =, + new RxtxChannelOption<Boolean>("RTS");, + public static final RxtxChannelOption<Stopbits> STOP_BITS =, + new RxtxChannelOption<Stopbits>("STOP_BITS");, + public static final RxtxChannelOption<Databits> DATA_BITS =, + new RxtxChannelOption<Databits>("DATA_BITS");, + public static final RxtxChannelOption<Paritybit> PARITY_BIT =, + new RxtxChannelOption<Paritybit>("PARITY_BIT");, + private RxtxChannelOption(String name) {, +++ b/transport-rxtx/src/main/java/io/netty/channel/rxtx/RxtxChannelOption.java, +public class RxtxChannelOption<T> extends ChannelOption<T> {, + public static final RxtxChannelOption<Integer> BAUD_RATE =, + new RxtxChannelOption<Integer>("BAUD_RATE");, + public static final RxtxChannelOption<Boolean> DTR =, +
[+++ b/all/pom.xml, + <version>4.1.16.Final</version>, +++ b/all/pom.xml, + <version>4.1.16.Final</version>, +++ b/bom/pom.xml, + <version>4.1.16.Final</version>, + <tag>netty-4.1.16.Final</tag>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, +++ b/all/pom.xml, + <version>4.1.16.Final</version>, +++ b/bom/pom.xml, + <version>4.1.16.Final</version>, + <tag>netty-4.1.16.Final</tag>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, + <version>4.1.16.Final</version>, +
[+++ b/common/src/main/java/io/netty/util/concurrent/PromiseNotifier.java, + * {@link GenericFutureListener} implementation which takes other {@link Promise}s, + private final boolean logNotifyFailure;, + this(true, promises);, + }, +, + /**, + * Create a new instance., + *, + * @param logNotifyFailure {@code true} if logging should be done in case notification fails., + * @param promises the {@link Promise}s to notify once this {@link GenericFutureListener} is notified., + */, + @SafeVarargs, + public PromiseNotifier(boolean logNotifyFailure, Promise<? super V>... promises) {, + this.logNotifyFailure = logNotifyFailure;, + if (!p.trySuccess(result) && logNotifyFailure) {, + if (!p.cancel(false) && logNotifyFailure) {, + if (!p.tryFailure(cause) && logNotifyFailure) {, +++
[+++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/DefaultSocks5CommandRequest.java, + if (dstPort < 0 || dstPort > 65535) {, + throw new IllegalArgumentException("dstPort: " + dstPort + " (expected: 0~65535)");, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/DefaultSocks5CommandRequest.java, + if (dstPort < 0 || dstPort > 65535) {, + throw new IllegalArgumentException("dstPort: " + dstPort + " (expected: 0~65535)");, +++ b/codec-socks/src/test/java/io/netty/handler/codec/socksx/v5/DefaultSocks5CommandRequestTest.java, + ".", -1);, +, + new DefaultSocks5CommandRequest(Socks5CommandType.BIND, Socks5AddressType.DOMAIN,, + ".", 0);, + new DefaultSocks5CommandRequest(Socks5CommandType.BIND, Socks5AddressType.DOMAIN,, + ".", 65535);]
[+++ b/pom.xml, + <version>3.8.0</version>]
[+++ b/pom.xml, + <plugin>, + <groupId>org.apache.maven.plugins</groupId>, + <artifactId>maven-eclipse-plugin</artifactId>, + <version>2.6</version>, + <configuration>, + <downloadSources>true</downloadSources>, + <addVersionToProjectName>true</addVersionToProjectName>, + </configuration>, + </plugin>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkedInput.java, + if (buf == null) {, + return null;, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkedInput.java, + if (buf == null) {, + return null;, + }, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpChunkedInputTest.java, +import io.netty.buffer.ByteBufAllocator;, +import io.netty.channel.ChannelHandlerContext;, + @Test, + public void testWrappedReturnNull() throws Exception {, + HttpChunkedInput input = new HttpChunkedInput(new ChunkedInput<ByteBuf>() {, + @Override, + public boolean isEndOfInput() throws Exception {, + return false;, + }, +, + @Override, + public void close() throws Exception {, + // NOOP, + }, +, + @Override, + public ByteBuf readChunk(ChannelHandlerContext ctx) throws Exception {, + return null;, + }, +, + @Override, + public
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollEventLoopGroup.java, +import io.netty.channel.EventLoop;, + this(nThreads, (ThreadFactory) null, selectStrategyFactory);, + public EpollEventLoopGroup(int nThreads, Executor executor) {, + this(nThreads, executor, DefaultSelectStrategyFactory.INSTANCE);, + }, +, + public EpollEventLoopGroup(int nThreads, Executor executor, SelectStrategyFactory selectStrategyFactory) {, + super(nThreads, executor, 0, selectStrategyFactory);, + }, +]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdyWindowUpdateFrame.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/transport/src/main/java/io/netty/channel/socket/DatagramChannel.java, + boolean isConnected();, +, +++ b/transport/src/main/java/io/netty/channel/socket/DatagramChannel.java, + boolean isConnected();, +, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + public boolean isConnected() {, + return javaChannel().isConnected();, + }, +, + @Override, +++ b/transport/src/main/java/io/netty/channel/socket/DatagramChannel.java, + boolean isConnected();, +, +++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + public boolean isConnected() {, + return javaChannel().isConnected();, + }, +, + @Override, +++ b/transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java, + public boolean isConnected() {, + return socket.isConnected();, + }, +, + @Override]
[+++ b/testsuite-shading/pom.xml, + <nativeTransportLib>netty_transport_native_kqueue_${os.detected.arch}.jnilib</nativeTransportLib>, + <nativeTcnativeLib>netty_tcnative.jnilib</nativeTcnativeLib>, + <!-- Needed to test shading of netty-tcnative -->, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-handler</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>${tcnative.artifactId}</artifactId>, + <version>${tcnative.version}</version>, + <classifier>${tcnative.classifier}</classifier>, + <scope>compile</scope>, + </dependency>, + <move file="${classesShadedNativeDir}/lib${nativeTransportLib}" tofile="${classesShadedNativeDir}/lib${shadingPrefix}_${nativeTransportLib}" />, + <move file="${classesShadedNativeDir}/lib${nativeTcnativeLib}" tofile="${classesShadedNativeDir}/lib${shadingPrefix}_${nativeTcnativeLib}" />, + <nativeTransportLib>netty_transport_native_epoll_${os.detected.arch}.so</nativeTransportLib>, + <nativeTcnativeLib>netty_tcnative.so</nativeTcnativeLib>, + <!-- Needed to test shading of netty-tcnative -->, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-handler</artifactId>, + <version>${project.version}</version>, + <scope>compile</scope>, + </dependency>, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>${tcnative.artifactId}</artifactId>, + <version>${tcnative.version}</version>, + <classifier>${tcnative.classifier}</classifier>, + <scope>compile</scope>, + </dependency>, + <move file="${classesShadedNativeDir}/lib${nativeTransportLib}" tofile="${classesShadedNativeDir}/lib${shadingPrefix}_${nativeTransportLib}" />, + <move file="${classesShadedNativeDir}/lib${nativeTcnativeLib}" tofile="${classesShadedNativeDir}/lib${shadingPrefix}_${nativeTcnativeLib}"
[+++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, + return new ChannelBootstrap(), + .eventLoop(new SelectorEventLoop()), + .channel(new NioSocketChannel());, + return new ServerChannelBootstrap(), + .eventLoop(new SelectorEventLoop(), new SelectorEventLoop()), + .channel(new NioServerSocketChannel());, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, + return new ChannelBootstrap(), + .eventLoop(new SelectorEventLoop()), + .channel(new NioSocketChannel());, + return new ServerChannelBootstrap(), + .eventLoop(new SelectorEventLoop(), new SelectorEventLoop()), + .channel(new NioServerSocketChannel());, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioOioSocketSpdyEchoTest.java, +import io.netty.channel.ChannelBootstrap;, +import io.netty.channel.ServerChannelBootstrap;, +import io.netty.channel.socket.nio.NioSocketChannel;, +import io.netty.channel.socket.nio.SelectorEventLoop;, +import io.netty.channel.socket.oio.BlockingChannelEventLoop;, +import io.netty.channel.socket.oio.OioServerSocketChannel;, + protected ChannelBootstrap newClientBootstrap() {, + return new ChannelBootstrap(), + .eventLoop(new SelectorEventLoop()), + .channel(new NioSocketChannel());, + protected ServerChannelBootstrap newServerBootstrap() {, + return new ServerChannelBootstrap(), + .eventLoop(new BlockingChannelEventLoop(), new BlockingChannelEventLoop()), + .channel(new OioServerSocketChannel());, +++ b/codec-http/src/test/java/io/netty/handler/codec/spdy/NioNioSocketSpdyEchoTest.java, + return new
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, + code = getsockopt(fd, level, optname, optval, &optlen);, +JNIEXPORT jboolean JNICALL Java_io_netty_channel_epoll_Native_finishConnect(JNIEnv * env, jclass clazz, jint fd) {, + // connect may be done, + // return true if connection finished successfully, + // return false if connection is still in progress, + // throw exception if connection failed, + if (res != 0) {, + // getOption failed, + throwIOException(env, exceptionMessage("finishConnect getOption failed: ", res));, + return JNI_FALSE;, + } else if (optval == EINPROGRESS) {, + // connect still in progress, + return JNI_FALSE;, + } else if (optval == 0) {, + //
[+++ b/transport-native-unix-common/src/main/java/io/netty/channel/unix/IovArray.java, + } else if (buf.hasMemoryAddress() && buf.nioBufferCount() == 1) {]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cookie/ClientCookieDecoder.java, + cookieBuilder = new CookieBuilder(cookie, header);, + cookieBuilder.appendAttribute(nameBegin, nameEnd, valueBegin, valueEnd);, + private final String header;, + private int expiresStart;, + private int expiresEnd;, + public CookieBuilder(DefaultCookie cookie, String header) {, + this.header = header;, + private long mergeMaxAgeAndExpires() {, + } else {, + String expires = computeValue(expiresStart, expiresEnd);, + if (expires != null) {, + }, + cookie.setMaxAge(mergeMaxAgeAndExpires());, + * @param valueStart, + * where the value starts in the header, + * @param valueEnd, + * where the value ends in the header, + public void appendAttribute(int keyStart, int keyEnd, int valueStart, int valueEnd)
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, +public class WebSocket00FrameDecoder extends ReplayingDecoder<Void> implements WebSocketFrameDecoder {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, +public class WebSocket00FrameDecoder extends ReplayingDecoder<Void> implements WebSocketFrameDecoder {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameEncoder.java, +public class WebSocket00FrameEncoder extends MessageToByteEncoder<WebSocketFrame> implements WebSocketFrameEncoder {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, +public class WebSocket00FrameDecoder extends ReplayingDecoder<Void> implements WebSocketFrameDecoder {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameEncoder.java, +public class WebSocket00FrameEncoder extends MessageToByteEncoder<WebSocketFrame> implements WebSocketFrameEncoder {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +public class WebSocket08FrameDecoder extends ReplayingDecoder<WebSocket08FrameDecoder.State>, + implements WebSocketFrameDecoder {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameDecoder.java, +public class WebSocket00FrameDecoder extends ReplayingDecoder<Void> implements WebSocketFrameDecoder {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket00FrameEncoder.java, +public class WebSocket00FrameEncoder extends MessageToByteEncoder<WebSocketFrame> implements WebSocketFrameEncoder {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +public class WebSocket08FrameDecoder extends ReplayingDecoder<WebSocket08FrameDecoder.State>, + implements WebSocketFrameDecoder {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java, +public class WebSocket08FrameEncoder extends MessageToByteEncoder<WebSocketFrame>
[+++ b/pom.xml]
[+++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_setIpFreeBind(JNIEnv* env, jclass clazz, jint fd, jint optval) {, + setOption(env, fd, IPPROTO_IP, IP_FREEBIND, &optval, sizeof(optval));, +}, +, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_isIpFreeBind(JNIEnv* env, jclass clazz, jint fd) {, + int optval;, + if (getOption(env, fd, IPPROTO_TCP, IP_FREEBIND, &optval, sizeof(optval)) == -1) {, + return -1;, + }, + return optval;, +}, +, +++ b/transport-native-epoll/src/main/c/io_netty_channel_epoll_Native.c, +JNIEXPORT void JNICALL Java_io_netty_channel_epoll_Native_setIpFreeBind(JNIEnv* env, jclass clazz, jint fd, jint optval) {, + setOption(env, fd, IPPROTO_IP, IP_FREEBIND, &optval, sizeof(optval));, +}, +, +JNIEXPORT jint JNICALL Java_io_netty_channel_epoll_Native_isIpFreeBind(JNIEnv* env, jclass clazz, jint fd) {, + int optval;, + if (getOption(env, fd, IPPROTO_TCP, IP_FREEBIND,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockZlibDecoder.java, +import io.netty.buffer.ByteBufAllocator;, + numBytes = decompress(encoded.alloc(), frame);, + private int decompress(ByteBufAllocator alloc, SpdyHeadersFrame frame) throws Exception {, + ensureBuffer(alloc);, + private void ensureBuffer(ByteBufAllocator alloc) {, + decompressed = alloc.heapBuffer(DEFAULT_BUFFER_CAPACITY);, + releaseBuffer();, + releaseBuffer();, +, + private void releaseBuffer() {, + if (decompressed != null) {, + decompressed.release();, + decompressed = null;, + }, + }]
[+++ b/pom.xml, + -Dio.netty.resourceLeakDetection]
[+++ b/transport/src/main/java/io/netty/channel/MultithreadEventExecutorGroup.java, + * Create a new instance., +++ b/transport/src/main/java/io/netty/channel/MultithreadEventExecutorGroup.java, + * Create a new instance., +++ b/transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java, + * @see {@link MultithreadEventExecutorGroup##MultithreadEventLoopGroup(int,ThreadFactory, Object...)}, +++ b/transport/src/main/java/io/netty/channel/MultithreadEventExecutorGroup.java, + * Create a new instance., +++ b/transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java, + * @see {@link MultithreadEventExecutorGroup##MultithreadEventLoopGroup(int,ThreadFactory, Object...)}, +++ b/transport/src/main/java/io/netty/channel/socket/aio/AbstractAioChannel.java, +/**, + * Abstract base class for {@link Channel} implementations that use the new {@link AsynchronousChannel} which is part, + * of NIO.2., + */, + /**, + * Creates a new instance., + *, + * @param id, + * the unique non-negative integer ID of this channel., + * Specify {@code null} to auto-generate a
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker07.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker08.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketClientHandshaker13.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameEncoder.java, +import
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, +import java.security.AccessController;, +import java.security.PrivilegedAction;, + // As a SecurityManager may prevent reading the somaxconn file we wrap this in a privileged block., + //, + // See https://github.com/netty/netty/issues/3680, + SOMAXCONN = AccessController.doPrivileged(new PrivilegedAction<Integer>() {, + @Override, + public Integer run() {, + return somaxconn;, + }, + });]
[+++ /dev/null, +++ /dev/null, +++ b/all/pom.xml, + <docletArtifact>, + <groupId>org.jboss.apiviz</groupId>, + <artifactId>apiviz</artifactId>, + <version>1.3.2.GA</version>, + </docletArtifact>]
[+++ b/all/pom.xml, + <version>4.0.14.Final</version>, +++ b/all/pom.xml, + <version>4.0.14.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final</version>, +++ b/all/pom.xml, + <version>4.0.14.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final</version>, +++ b/all/pom.xml, + <version>4.0.14.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Final</version>, +++ b/all/pom.xml, + <version>4.0.14.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec/pom.xml, + <version>4.0.14.Final</version>, +++ b/all/pom.xml, + <version>4.0.14.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-socks/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec/pom.xml, + <version>4.0.14.Final</version>, +++ b/common/pom.xml, + <version>4.0.14.Final</version>, +++ b/all/pom.xml, + <version>4.0.14.Final</version>, +++ b/buffer/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-http/pom.xml, + <version>4.0.14.Final</version>, +++ b/codec-socks/pom.xml, +
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java, + if (dataLength > Short.MAX_VALUE) {, + ByteBuf slice = in.readSlice(Short.MAX_VALUE);, + snappy.encode(slice, out, Short.MAX_VALUE);, + dataLength -= Short.MAX_VALUE;]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpVersion.java]
[+++ b/pom.xml, + <allowTimestampedSnapshots>false</allowTimestampedSnapshots>, +++ b/pom.xml, + <allowTimestampedSnapshots>false</allowTimestampedSnapshots>, +++ b/testsuite-osgi/testsuite-osgi-deps/pom.xml, + <version>3.0.0.RC1</version>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, + private byte[] maskingKey;, + if (maskingKey == null) {, + maskingKey = new byte[4];, + }, + in.readBytes(maskingKey);, + frame.setByte(i, frame.getByte(i) ^ maskingKey[i % 4]);]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, +import io.netty.buffer.UnpooledByteBufAllocator;, + // Bytes of self-signed certificate for netty.io and the matching private-key, + private static byte[] CERT_BYTES = {, + 48, -126, 1, -93, 48, -126, 1, 12, -96, 3, 2, 1, 2, 2, 8, 31, 127, -24, 79, 67,, + -72, -128, 124, 48, 13, 6, 9, 42, -122, 72, -122, -9, 13, 1, 1, 11, 5, 0, 48,, + 19, 49, 17, 48, 15, 6, 3, 85, 4, 3, 19, 8, 110, 101, 116, 116, 121, 46, 105,, + 111, 48, 32, 23, 13, 49, 56, 48, 51, 50, 55, 49, 50, 52,
[+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java, + throw new MqttUnacceptableProtocolVersionException("missing " + PROTOCOL_NAME + " signature");, + throw new MqttIdentifierRejectedException("invalid clientIdentifier: " + decodedClientIdValue);, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java, + throw new MqttUnacceptableProtocolVersionException("missing " + PROTOCOL_NAME + " signature");, + throw new MqttIdentifierRejectedException("invalid clientIdentifier: " + decodedClientIdValue);, +++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttIdentifierRejectedException.java, +/*, + * Copyright 2014 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + *
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, +import static io.netty.util.internal.StringUtil.NEWLINE;, +import static io.netty.util.internal.StringUtil.isSurrogate;, + } else if (isSurrogate(c)) {, + if (!Character.isHighSurrogate(c)) {, + throw new IllegalArgumentException("Invalid encoding. " +, + "Expected high (leading) surrogate at index " + i + " but got " + c);, + }, + final char c2;, + try {, + // Surrogate Pair consumes 2 characters. Optimistically try to get the next character to avoid, + // duplicate bounds checking with charAt. If an IndexOutOfBoundsException is thrown we will, + // re-throw a more informative exception describing the problem., + c2 = seq.charAt(++i);, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +, +import io.netty.handler.codec.DateFormatter;, +import java.util.Date;, + Date date = DateFormatter.parseHttpDate(value);, + if (date != null) {, + long maxAgeMillis = date.getTime() - System.currentTimeMillis();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +, +import io.netty.handler.codec.DateFormatter;, +import java.util.Date;, + Date date = DateFormatter.parseHttpDate(value);, + if (date != null) {, + long maxAgeMillis = date.getTime() - System.currentTimeMillis();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, +import io.netty.handler.codec.DateFormatter;, + return DateFormatter.format((Date) value);, + return DateFormatter.format(((Calendar) value).getTime());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/CookieDecoder.java, +, +import io.netty.handler.codec.DateFormatter;, +import java.util.Date;, + Date date = DateFormatter.parseHttpDate(value);, + if (date != null) {, + long maxAgeMillis = date.getTime() - System.currentTimeMillis();, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, +import io.netty.handler.codec.DateFormatter;, + return DateFormatter.format((Date) value);, + return DateFormatter.format(((Calendar) value).getTime());,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameDecoder.java, + while (numHeaders > 0) {, + numHeaders --;, + numHeaders --;]
[+++ b/pom.xml, + <meminitial>256m</meminitial>, + <maxmem>1024m</maxmem>]
[+++ b/buffer/src/test/java/io/netty/buffer/UnpooledTest.java, + assertEquals(0, copyInt(new int[] {}).capacity());, + assertEquals(0, copyShort(new short[] {}).capacity());, + assertEquals(0, copyShort(new int[] {}).capacity());, + assertEquals(0, copyMedium(new int[] {}).capacity());, + assertEquals(0, copyLong(new long[] {}).capacity());, + assertEquals(0, copyFloat(new float[] {}).capacity());, + assertEquals(0, copyDouble(new double[] {}).capacity());, + assertEquals(0, copyBoolean(new boolean[] {}).capacity());, +++ b/buffer/src/test/java/io/netty/buffer/UnpooledTest.java, + assertEquals(0, copyInt(new int[] {}).capacity());, + assertEquals(0, copyShort(new short[] {}).capacity());, + assertEquals(0, copyShort(new int[] {}).capacity());, + assertEquals(0, copyMedium(new int[] {}).capacity());, + assertEquals(0, copyLong(new long[] {}).capacity());, + assertEquals(0, copyFloat(new float[] {}).capacity());, + assertEquals(0, copyDouble(new double[] {}).capacity());, + assertEquals(0, copyBoolean(new boolean[] {}).capacity());, +++ b/common/src/main/java/io/netty/util/internal/EmptyArrays.java, + public static final byte[] EMPTY_BYTES = {};, + public static final char[]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/QueryStringDecoder.java, + * Returns the uri used to initialize this {@link QueryStringDecoder}., + */, + public String uri() {, + return uri;, + }, +, + /**]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + if (c instanceof LastHttpContent) {, + decodeStarted = false;, + }, +, + if (c instanceof LastHttpContent) {, + decodeStarted = false;, + }, + decodeStarted = false;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, + if (c instanceof LastHttpContent) {, + decodeStarted = false;, + }, +, + if (c instanceof LastHttpContent) {, + decodeStarted = false;, + }, + decodeStarted = false;, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + encodeStarted = false;, + if (c instanceof LastHttpContent) {, + encodeStarted = false;, + }, +]
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/AbstractClientSocketTest.java, +import java.net.SocketAddress;, + protected volatile SocketAddress addr;, + addr = newSocketAddress();, +, + protected SocketAddress newSocketAddress() {, + return new InetSocketAddress(, + NetUtil.LOCALHOST, TestUtils.getFreePort());, + }, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/AbstractClientSocketTest.java, +import java.net.SocketAddress;, + protected volatile SocketAddress addr;, + addr = newSocketAddress();, +, + protected SocketAddress newSocketAddress() {, + return new InetSocketAddress(, + NetUtil.LOCALHOST, TestUtils.getFreePort());, + }, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/AbstractServerSocketTest.java, +import java.net.SocketAddress;, + protected volatile SocketAddress addr;, + addr = newSocketAddress();, +, + protected SocketAddress newSocketAddress() {, + return new InetSocketAddress(, + NetUtil.LOCALHOST, TestUtils.getFreePort());, + }, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/AbstractClientSocketTest.java, +import java.net.SocketAddress;, + protected volatile SocketAddress addr;, + addr = newSocketAddress();, +, +
[+++ b/src/main/java/org/jboss/netty/channel/socket/http/AcceptedServerChannelPipelineFactory.java, +/*, + * Copyright 2009 Red Hat, Inc., + *, + * Red Hat licenses this file to you under the Apache License, version 2.0, + * (the "License"); you may not use this file except in compliance with the, + * License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + private final VoidChannelPromise voidPromise = new VoidChannelPromise(this, true);, + private final VoidChannelPromise unsafeVoidPromise = new VoidChannelPromise(this, false);, + @Override, + public ChannelPromise voidPromise() {, + return unsafeVoidPromise;, + }, +, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, + private final VoidChannelPromise voidPromise = new VoidChannelPromise(this, true);, + private final VoidChannelPromise unsafeVoidPromise = new VoidChannelPromise(this, false);, + @Override, + public ChannelPromise voidPromise() {, + return unsafeVoidPromise;, + }, +, +++ b/transport/src/main/java/io/netty/channel/Channel.java, + * <li>{@link #voidPromise()}</li>, +, + /**, + * Return a special ChannelPromise which can be reused and passed to the operations in {@link Unsafe}., + * It will never be
[+++ b/src/main/java/org/jboss/netty/example/echo/EchoClient.java, + EchoClientHandler handler = new EchoClientHandler(firstMessageSize);, +++ b/src/main/java/org/jboss/netty/example/echo/EchoClient.java, + EchoClientHandler handler = new EchoClientHandler(firstMessageSize);, +++ b/src/main/java/org/jboss/netty/example/echo/EchoClientHandler.java, +/*, + * Copyright 2009 Red Hat, Inc., + *, + * Red Hat licenses this file to you under the Apache License, version 2.0, + * (the "License"); you may not use this file except in compliance with the, + * License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on
[+++ b/metrics-yammer/pom.xml]
[+++ b/all/pom.xml, + <version>4.1.11.Final</version>, +++ b/all/pom.xml, + <version>4.1.11.Final</version>, +++ b/bom/pom.xml, + <version>4.1.11.Final</version>, + <tag>netty-4.1.11.Final</tag>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, +++ b/all/pom.xml, + <version>4.1.11.Final</version>, +++ b/bom/pom.xml, + <version>4.1.11.Final</version>, + <tag>netty-4.1.11.Final</tag>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, + <version>4.1.11.Final</version>, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, + if (p.get(HttpChunkAggregator.class) != null) {, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, + if (p.get(HttpChunkAggregator.class) != null) {, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java, + if (p.get(HttpChunkAggregator.class) != null) {, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker00.java, + if (p.get(HttpChunkAggregator.class) != null) {, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker08.java, + if (p.get(HttpChunkAggregator.class) != null) {, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker13.java, + if (p.get(HttpChunkAggregator.class) != null) {, + }, +]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + final SSLEngine newEngine0(ByteBufAllocator alloc, String peerHost, int peerPort, boolean jdkCompatibilityMode) {, + return new OpenSslEngine(this, alloc, peerHost, peerPort, jdkCompatibilityMode);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + final SSLEngine newEngine0(ByteBufAllocator alloc, String peerHost, int peerPort, boolean jdkCompatibilityMode) {, + return new OpenSslEngine(this, alloc, peerHost, peerPort, jdkCompatibilityMode);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + OpenSslEngine(OpenSslContext context, ByteBufAllocator alloc, String peerHost, int peerPort,, + boolean jdkCompatibilityMode) {, + super(context, alloc, peerHost, peerPort, jdkCompatibilityMode, false);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + final SSLEngine newEngine0(ByteBufAllocator alloc, String peerHost, int peerPort, boolean jdkCompatibilityMode) {, + return new OpenSslEngine(this, alloc, peerHost, peerPort, jdkCompatibilityMode);, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java, + OpenSslEngine(OpenSslContext context, ByteBufAllocator alloc, String peerHost, int peerPort,,
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/ZlibCodecFactory.java, + noJdkZlibDecoder = SystemPropertyUtil.getBoolean("io.netty.noJdkZlibDecoder",, + PlatformDependent.javaVersion() < 7);]
[+++ b/handler/src/main/java/io/netty/handler/ssl/CipherSuiteConverter.java, + if (handshakeAlgo.isEmpty()) {, + if (handshakeAlgo.isEmpty()) {, + if (handshakeAlgo.isEmpty()) {, +++ b/handler/src/main/java/io/netty/handler/ssl/CipherSuiteConverter.java, + if (handshakeAlgo.isEmpty()) {, + if (handshakeAlgo.isEmpty()) {, + if (handshakeAlgo.isEmpty()) {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + if (c == null || c.isEmpty() || availableOpenSslCipherSuites.contains(c)) {, + certBio = ReferenceCountedOpenSslContext.toBIO(cert.cert());, +++ b/handler/src/main/java/io/netty/handler/ssl/CipherSuiteConverter.java, + if (handshakeAlgo.isEmpty()) {, + if (handshakeAlgo.isEmpty()) {, + if (handshakeAlgo.isEmpty()) {, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + if (c == null || c.isEmpty() || availableOpenSslCipherSuites.contains(c)) {, + certBio = ReferenceCountedOpenSslContext.toBIO(cert.cert());, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, + convertedCiphers, DEFAULT_CIPHERS, OpenSsl.availableOpenSslCipherSuites()));, + public void setBioNonApplicationBufferSize(int bioNonApplicationBufferSize) {, + checkPositiveOrZero(bioNonApplicationBufferSize, "bioNonApplicationBufferSize");, +++ b/handler/src/main/java/io/netty/handler/ssl/CipherSuiteConverter.java, + if (handshakeAlgo.isEmpty()) {, + if (handshakeAlgo.isEmpty()) {,
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslEngine.java]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + checkNotNull(dst, "dst").setBytes(dstIdx, src.array(), srcIdx + src.arrayOffset(), length);, + checkNotNull(dst, "dst").writeBytes(src.array(), srcIdx + src.arrayOffset(), length);, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + checkNotNull(dst, "dst").setBytes(dstIdx, src.array(), srcIdx + src.arrayOffset(), length);, + checkNotNull(dst, "dst").writeBytes(src.array(), srcIdx + src.arrayOffset(), length);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java, + encoder.encodeHeader(stream,, + key.isEntireArrayUsed() ? key.array() : new ByteString(key, true).array(),, + value.isEntireArrayUsed() ? value.array() : new ByteString(value, true).array(),, + sensitivityDetector.isSensitive(key, value));, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + checkNotNull(dst, "dst").setBytes(dstIdx, src.array(), srcIdx + src.arrayOffset(), length);, + checkNotNull(dst, "dst").writeBytes(src.array(), srcIdx + src.arrayOffset(), length);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java, + encoder.encodeHeader(stream,, + key.isEntireArrayUsed() ? key.array() : new ByteString(key, true).array(),, + value.isEntireArrayUsed() ? value.array() : new ByteString(value, true).array(),, + sensitivityDetector.isSensitive(key, value));, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/HttpUtil.java,
[+++ b/COPYRIGHT.txt, +The Netty Project - Copyright (C) 2008, Red Hat Middleware LLC, and individual, +contributors, and is licensed under the GNU LGPL., +, +A summary of the individual contributors is given below. Any omission should be, +sent to Trustin Lee <tlee@redhat.com>., +, +SVN Login(s) Name, +-------------------------------------------------------------------------------, +trustin Adrian Brock, +-------------------------------------------------------------------------------, +, +* JBoss is a registered trademark of Red Hat Middleware LLC., +, +++ b/COPYRIGHT.txt, +The Netty Project - Copyright (C) 2008, Red Hat Middleware LLC, and individual, +contributors, and is licensed under the GNU LGPL., +, +A summary of the individual contributors is given below. Any omission
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java, + int uncompressedLength = out.writerIndex() - uncompressedStart;, +++ b/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java, + int uncompressedLength = out.writerIndex() - uncompressedStart;, +++ b/codec/src/test/java/io/netty/handler/codec/compression/SnappyFramedDecoderTest.java, +, + // The following two tests differ in only the checksum provided for the literal, + // uncompressed string "netty", +, + @Test(expected = CompressionException.class), + public void testInvalidChecksumThrowsException() throws Exception {, + EmbeddedByteChannel channel = new EmbeddedByteChannel(new SnappyFramedDecoder(true));, +, + // checksum here is presented as 0, + ByteBuf in = Unpooled.wrappedBuffer(new byte[] {, + -0x80, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59,, + 0x01, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 'n', 'e', 't',
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, + this(Collections.singletonList(checkNotNull(config, "config")), config.isShortCircuit());, + if (origin != null && config != null) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsHandler.java, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, + this(Collections.singletonList(checkNotNull(config, "config")), config.isShortCircuit());, + if (origin != null && config != null) {, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/cors/CorsHandlerTest.java, + public void preflightRequestWithUnauthorizedOrigin() {, + final String origin = "http://host";, + final CorsConfig config = forOrigin("http://localhost").build();, + final HttpResponse response = preflightRequest(config, origin, "xheader1");, + assertThat(response.headers().contains(ACCESS_CONTROL_ALLOW_ORIGIN), is(false));, + }, +, + @Test]
[+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishVariableHeader.java, + private final int packetId;, + public MqttPublishVariableHeader(String topicName, int packetId) {, + this.packetId = packetId;, + /**, + * @deprecated Use {@link #packetId()} instead., + */, + @Deprecated, + return packetId;, + }, +, + public int packetId() {, + return packetId;, + .append(", packetId=").append(packetId)]
[+++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, + final ByteBuf buf = (ByteBuf) in.current();, + in.progress(buf.readableBytes());, + in.progress(readableBytes);, + in.progress(readableBytes);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, + final ByteBuf buf = (ByteBuf) in.current();, + in.progress(buf.readableBytes());, + in.progress(readableBytes);, + in.progress(readableBytes);, +++ b/transport/src/main/java/io/netty/channel/oio/AbstractOioByteChannel.java, + int readableBytes = buf.readableBytes();, + while (readableBytes > 0) {, + int newReadableBytes = buf.readableBytes();, + in.progress(readableBytes - newReadableBytes);, + readableBytes = newReadableBytes;, + FileRegion region = (FileRegion) msg;, + long transfered = region.transfered();, + doWriteFileRegion(region);, + in.progress(region.transfered() - transfered);, +++ b/transport-native-epoll/src/main/java/io/netty/channel/epoll/EpollSocketChannel.java, + final ByteBuf buf = (ByteBuf) in.current();, + in.progress(buf.readableBytes());, + in.progress(readableBytes);, + in.progress(readableBytes);, +++ b/transport/src/main/java/io/netty/channel/oio/AbstractOioByteChannel.java, + int readableBytes = buf.readableBytes();, + while (readableBytes >
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + ensureAccessible();, + _setByte(writerIndex++, value);, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + ensureAccessible();, + _setByte(writerIndex++, value);, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, +++ b/buffer/src/main/java/io/netty/buffer/UnsafeDirectSwappedByteBuf.java, + wrapped.ensureAccessible();, + wrapped.ensureAccessible();, + wrapped.ensureAccessible();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + ensureAccessible();, + _setByte(writerIndex++, value);, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, +++ b/buffer/src/main/java/io/netty/buffer/UnsafeDirectSwappedByteBuf.java, + wrapped.ensureAccessible();, + wrapped.ensureAccessible();, + wrapped.ensureAccessible();, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +import io.netty.util.IllegalReferenceCountException;, +import java.io.IOException;, + @Test(expected
[+++ b/example/src/main/java/io/netty/example/http/websocketx/client/WebSocketClientHandler.java, +import io.netty.handler.codec.http.websocketx.WebSocketHandshakeException;, + try {, + } catch (WebSocketHandshakeException e) {, + System.out.println("WebSocket Client failed to connect");, + handshakeFuture.setFailure(e);, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + @Override, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + @Override, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + @Override, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/EmptyHttpHeaders.java, + public static final EmptyHttpHeaders INSTANCE = instance();, +, + /**, + * @deprecated Use {@link EmptyHttpHeaders#INSTANCE}, + * <p>, + * This is needed to break a cyclic static initialization loop between {@link HttpHeaders} and, + * {@link EmptyHttpHeaders}., + * @see HttpUtil#EMPTY_HEADERS, + */, + @Deprecated, + static EmptyHttpHeaders instance() {, + return HttpUtil.EMPTY_HEADERS;, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/Cookie.java, + @Override, + @Override, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultHttpHeaders.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/EmptyHttpHeaders.java, + public static final EmptyHttpHeaders INSTANCE =
[+++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, + try {, + } catch (Throwable cause) {, + promise.tryFailure(cause);, + }]
[+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java, + return new Bootstrap().group(oioWorkerGroup).channel(OioDatagramChannel.class), + .option(ChannelOption.SO_TIMEOUT, OIO_SO_TIMEOUT);, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java, + return new Bootstrap().group(oioWorkerGroup).channel(OioDatagramChannel.class), + .option(ChannelOption.SO_TIMEOUT, OIO_SO_TIMEOUT);, +++ b/transport/src/main/java/io/netty/channel/socket/DefaultDatagramChannelConfig.java, + protected final DatagramSocket javaSocket() {, + return javaSocket;, + }, +, +++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketTestPermutation.java, + return new Bootstrap().group(oioWorkerGroup).channel(OioDatagramChannel.class), + .option(ChannelOption.SO_TIMEOUT, OIO_SO_TIMEOUT);, +++ b/transport/src/main/java/io/netty/channel/socket/DefaultDatagramChannelConfig.java, + protected final DatagramSocket javaSocket() {, + return javaSocket;, + }, +, +++ b/transport/src/main/java/io/netty/channel/socket/oio/DefaultOioDatagramChannelConfig.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with
[+++ b/pom.xml, +++ b/pom.xml, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/pom.xml, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + * Always returns {@code true} if {@link #isAvailable()} returns {@code true}., + *, + * @deprecated Will be removed because hostname validation is always done by a, + * {@link javax.net.ssl.TrustManager} implementation., + @Deprecated, + return isAvailable();, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + * Always returns {@code true} if {@link #isAvailable()} returns {@code true}., + *, + * @deprecated Will be removed because hostname validation is always done by a, + * {@link javax.net.ssl.TrustManager} implementation., + @Deprecated, + return isAvailable();, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +++ b/handler/src/main/java/io/netty/handler/ssl/OpenSsl.java, + * Always returns {@code true} if {@link #isAvailable()} returns {@code true}., + *, +
[+++ b/src/main/java/org/jboss/netty/handler/codec/http/CaseIgnoringComparator.java, +/*, + * Copyright 2009 Red Hat, Inc., + *, + * Red Hat licenses this file to you under the Apache License, version 2.0, + * (the "License"); you may not use this file except in compliance with the, + * License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or
[+++ b/all/.gitignore, +src, +++ b/all/.gitignore, +src, +++ b/all/pom.xml, + <id>clean-src</id>, + <phase>clean</phase>, + <goals>, + <goal>clean</goal>, + </goals>, + <configuration>, + <filesets>, + <fileset>, + <directory>${project.basedir}/src</directory>, + <followSymlinks>false</followSymlinks>, + <useDefaultExcludes>false</useDefaultExcludes>, + </fileset>, + <fileset>, + <directory>${project.basedir}/target</directory>, + <followSymlinks>false</followSymlinks>, + </fileset>, + </filesets>, + </configuration>, + </execution>, + <execution>, + <id>clean-all</id>, + <configuration>, + <filesets>, + <fileset>, + <directory>${project.basedir}/src</directory>, + <followSymlinks>false</followSymlinks>, + <useDefaultExcludes>false</useDefaultExcludes>, + </fileset>, + <fileset>, + <directory>${project.basedir}/target</directory>, + <followSymlinks>false</followSymlinks>, + </fileset>, + </filesets>, + </configuration>, + <includeGroupIds>io.netty</includeGroupIds>, + <outputDirectory>${project.basedir}/src/main/java</outputDirectory>, + <overWriteReleases>false</overWriteReleases>, + <overWriteSnapshots>true</overWriteSnapshots>, + <overWriteReleases>false</overWriteReleases>, + <overWriteSnapshots>true</overWriteSnapshots>, + <artifactId>maven-jxr-plugin</artifactId>, + <version>2.2</version>, + <id>generate-xref</id>, + <phase>package</phase>, + <goal>jxr</goal>, +
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + ensureAccessible();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + ensureAccessible();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + checkIndex(index, length);, + ensureAccessible();, + checkIndex(index, length);, +++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + ensureAccessible();, +++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java, + ensureAccessible();, + ensureAccessible();, + ensureAccessible();, + checkIndex(index, length);, + ensureAccessible();, + checkIndex(index, length);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, + @Test(expected = IllegalReferenceCountException.class), + public void testSliceAfterRelease() {, + releasedBuffer().slice();, + }, +, + @Test(expected = IllegalReferenceCountException.class), + public void testSliceAfterRelease2() {, + releasedBuffer().slice(0, 1);, + }, +, + private static void assertSliceFailAfterRelease(ByteBuf... bufs) {, + for (ByteBuf buf : bufs) {, + if (buf.refCnt() > 0) {, + buf.release();, + },
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java, + private final HpackDecoder hpackDecoder;, + this(validateHeaders, new HpackDecoder(maxHeaderListSize, initialHuffmanDecodeCapacity));, + DefaultHttp2HeadersDecoder(boolean validateHeaders, HpackDecoder hpackDecoder) {, + this.hpackDecoder = ObjectUtil.checkNotNull(hpackDecoder, "hpackDecoder");, + hpackDecoder.setMaxHeaderTableSize(max);, + return hpackDecoder.getMaxHeaderTableSize();, + hpackDecoder.setMaxHeaderListSize(max, goAwayMax);, + return hpackDecoder.getMaxHeaderListSize();, + return hpackDecoder.getMaxHeaderListSizeGoAway();, + hpackDecoder.decode(streamId, headerBlock, headers);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersDecoder.java, + private final HpackDecoder hpackDecoder;, + this(validateHeaders, new HpackDecoder(maxHeaderListSize, initialHuffmanDecodeCapacity));, + DefaultHttp2HeadersDecoder(boolean validateHeaders, HpackDecoder hpackDecoder) {, + this.hpackDecoder = ObjectUtil.checkNotNull(hpackDecoder, "hpackDecoder");, + hpackDecoder.setMaxHeaderTableSize(max);, + return hpackDecoder.getMaxHeaderTableSize();, + hpackDecoder.setMaxHeaderListSize(max, goAwayMax);, + return hpackDecoder.getMaxHeaderListSize();, + return hpackDecoder.getMaxHeaderListSizeGoAway();, + hpackDecoder.decode(streamId, headerBlock, headers);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2HeadersEncoder.java, + private final HpackEncoder hpackEncoder;, + this(sensitivityDetector, new HpackEncoder());, + this(sensitivityDetector, new HpackEncoder(ignoreMaxHeaderListSize));, + this(sensitivityDetector,
[+++ b/NOTICE.txt, +Copyright 2014 The Netty Project, +This product contains a modified portion of 'jbzip2', a Java bzip2 compression, +and decompression library written by Matthew J. Francis. It can be obtained at:, +, + * LICENSE:, + * license/LICENSE.jbzip2.txt (MIT License), + * HOMEPAGE:, + * https://code.google.com/p/jbzip2/, +, +++ b/NOTICE.txt, +Copyright 2014 The Netty Project, +This product contains a modified portion of 'jbzip2', a Java bzip2 compression, +and decompression library written by Matthew J. Francis. It can be obtained at:, +, + * LICENSE:, + * license/LICENSE.jbzip2.txt (MIT License), + * HOMEPAGE:, + * https://code.google.com/p/jbzip2/, +, +++ b/codec/pom.xml, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2UnknownFrame.java, +public interface Http2UnknownFrame extends Http2StreamFrame, ByteBufHolder {, + @Override, + @Override, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2UnknownFrame.java, +public interface Http2UnknownFrame extends Http2StreamFrame, ByteBufHolder {, + @Override, + @Override, +++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexCodecTest.java, + public void writeUnknownFrame() {, + childChannelInitializer.handler = new ChannelInboundHandlerAdapter() {, + @Override, + public void channelActive(ChannelHandlerContext ctx) {, + ctx.writeAndFlush(new DefaultHttp2HeadersFrame(new DefaultHttp2Headers()));, + ctx.writeAndFlush(new DefaultHttp2UnknownFrame((byte) 99, new Http2Flags()));, + ctx.fireChannelActive();, + }, + };, +, + Channel childChannel = newOutboundStream();, + assertTrue(childChannel.isActive());, +, + Http2FrameStream stream = readOutboundHeadersAndAssignId();, + parentChannel.runPendingTasks();, +, + Http2UnknownFrame frame = parentChannel.readOutbound();, + assertEquals(stream, frame.stream());, + assertEquals(99, frame.frameType());, + assertEquals(new Http2Flags(), frame.flags());, + frame.release();, + },
[+++ b/example/src/main/java/io/netty/example/filetransfer/FileServer.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, + checkJavaVersion();, + private static void checkJavaVersion() {, + if (PlatformDependent.javaVersion() < 7) {, + throw new UnsupportedOperationException("Only supported on java 7+.");, + }, + }, +, +, + checkJavaVersion();, +, +, + checkJavaVersion();, +, + checkJavaVersion();, +]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +, + // If the stream is opened in a half-closed state, the headers must have either, + // been sent if this is a local stream, or received if it is a remote stream., + if (state == HALF_CLOSED_LOCAL) {, + headersSent(/*isInformational*/ false);, + } else if (state == HALF_CLOSED_REMOTE) {, + headersReceived(/*isInformational*/ false);, + }, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +, + // If the stream is opened in a half-closed state, the headers must have either, + // been sent if this is a local stream, or received if it is a remote stream., + if (state
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, +import io.netty.util.internal.SystemPropertyUtil;, + /**, + * To make it easier for users to replace JDK implemention with OpenSsl version we also use, + * {@code jdk.tls.rejectClientInitiatedRenegotiation} to allow disabling client initiated renegotiation., + * Java8+ uses this system property as well., + *, + * See also <a href="http://blog.ivanristic.com/2014/03/ssl-tls-improvements-in-java-8.html">, + * Significant SSL/TLS improvements in Java 8</a>, + */, + private static final boolean JDK_REJECT_CLIENT_INITIATED_RENEGOTIATION =, + SystemPropertyUtil.getBoolean("jdk.tls.rejectClientInitiatedRenegotiation", false);, + private volatile boolean rejectRemoteInitiatedRenegotiation;, + if (mode == SSL.SSL_MODE_SERVER) {, + rejectRemoteInitiatedRenegotiation =, + JDK_REJECT_CLIENT_INITIATED_RENEGOTIATION;, + }, + final OpenSslEngine engine = new OpenSslEngine(, + ctx, alloc,
[+++ b/common/src/main/java/io/netty/util/concurrent/DefaultProgressivePromise.java, + if (total < 0) {, + // total unknown, + total = -1; // normalize, + if (progress < 0) {, + throw new IllegalArgumentException("progress: " + progress + " (expected: >= 0)");, + }, + } else if (progress < 0 || progress > total) {, +++ b/common/src/main/java/io/netty/util/concurrent/DefaultProgressivePromise.java, + if (total < 0) {, + // total unknown, + total = -1; // normalize, + if (progress < 0) {, + throw new IllegalArgumentException("progress: " + progress + " (expected: >= 0)");, + }, + } else if (progress < 0 || progress > total)
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + if (!pipeline.isInboundShutdown()) {]
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, +, + @Override, + ChannelHandlerContext fireChannelRegistered();, +, + @Override, + ChannelHandlerContext fireChannelUnregistered();, +, + @Override, + ChannelHandlerContext fireChannelActive();, +, + @Override, + ChannelHandlerContext fireChannelInactive();, +, + @Override, + ChannelHandlerContext fireExceptionCaught(Throwable cause);, +, + @Override, + ChannelHandlerContext fireUserEventTriggered(Object event);, +, + @Override, + ChannelHandlerContext fireInboundBufferUpdated();, +, + @Override, + ChannelHandlerContext fireChannelReadSuspended();, +++ b/transport/src/main/java/io/netty/channel/ChannelHandlerContext.java, +, + @Override, + ChannelHandlerContext fireChannelRegistered();, +, + @Override, + ChannelHandlerContext fireChannelUnregistered();, +, + @Override, + ChannelHandlerContext fireChannelActive();, +, + @Override, + ChannelHandlerContext fireChannelInactive();, +, + @Override, + ChannelHandlerContext fireExceptionCaught(Throwable cause);, +, + @Override, + ChannelHandlerContext fireUserEventTriggered(Object event);, +, + @Override, + ChannelHandlerContext fireInboundBufferUpdated();, +,
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2Connection.java, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java, +import io.netty.buffer.ByteBuf;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.handler.codec.http2.Http2Exception.ClosedStreamCreationException;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, +import java.util.List;, +, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(DefaultHttp2ConnectionDecoder.class);, + public int onDataRead(final ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding,, + boolean endOfStream) throws Http2Exception {, + boolean shouldIgnore = true;, + try {, + shouldIgnore = shouldIgnoreHeadersOrDataFrame(ctx, streamId, stream, "DATA");, + } finally {, + if (shouldIgnore) {, + }, + if (shouldIgnoreHeadersOrDataFrame(ctx, streamId, stream, "HEADERS")) {, + if (logger.isInfoEnabled()) {, + logger.info("%s ignoring PRIORITY frame for stream id %d. Stream doesn't exist but may " +, +
[+++ b/.gitattributes, +# Set the default behavior, in case people don't have core.autocrlf set., +* text=auto, +++ b/.gitattributes, +# Set the default behavior, in case people don't have core.autocrlf set., +* text=auto, +++ b/.mvn/wrapper/maven-wrapper.jar, +++ b/.gitattributes, +# Set the default behavior, in case people don't have core.autocrlf set., +* text=auto, +++ b/.mvn/wrapper/maven-wrapper.jar, +++ b/.mvn/wrapper/maven-wrapper.properties, +distributionUrl=https://repo1.maven.org/maven2/org/apache/maven/apache-maven/3.5.2/apache-maven-3.5.2-bin.zip, +++ b/.gitattributes, +# Set the default behavior, in case people don't have core.autocrlf set., +* text=auto, +++ b/.mvn/wrapper/maven-wrapper.jar, +++ b/.mvn/wrapper/maven-wrapper.properties, +distributionUrl=https://repo1.maven.org/maven2/org/apache/maven/apache-maven/3.5.2/apache-maven-3.5.2-bin.zip, +++ b/NOTICE.txt, +, +This product contains the Maven wrapper scripts from 'Maven Wrapper', that provides an easy way to ensure a user has
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/example/http/snoop/HttpClient.java, +/*, + * JBoss, Home of Professional Open Source,
[+++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java, + return def;, +++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java, + return def;, +++ b/common/src/test/java/io/netty/util/internal/SystemPropertyUtilTest.java, +/*, + * Copyright 2017 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT,
[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, +import java.util.concurrent.AbstractExecutorService;, +import java.util.concurrent.RunnableFuture;, + * Abstract base class for {@link EventExecutor} implementations., +public abstract class AbstractEventExecutor extends AbstractExecutorService implements EventExecutor {, + @Override, + public EventExecutor next() {, + return this;, + public <V> Promise<V> newPromise() {, + return new DefaultPromise<V>(this);, + }, +, + @Override, + public <V> Future<V> newSucceededFuture(V result) {, + return new SucceededFuture<V>(this, result);, + }, +, + @Override, + public <V> Future<V> newFailedFuture(Throwable cause) {, + return new FailedFuture<V>(this, cause);, + }, +, + @Override, + public Future<?> submit(Runnable task) {, + return (Future<?>) super.submit(task);, + }, +, + @Override, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, +public abstract class HttpContentDecoder extends MessageToMessageDecoder<HttpObject> {, + protected Object decode(ChannelHandlerContext ctx, HttpObject msg) throws Exception {, + protected void freeInboundMessage(HttpObject msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, +public abstract class HttpContentDecoder extends MessageToMessageDecoder<HttpObject> {, + protected Object decode(ChannelHandlerContext ctx, HttpObject msg) throws Exception {, + protected void freeInboundMessage(HttpObject msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentDecoder.java, +public abstract class HttpContentDecoder extends MessageToMessageDecoder<HttpObject> {, + protected Object decode(ChannelHandlerContext ctx, HttpObject msg) throws Exception {, + protected void freeInboundMessage(HttpObject msg) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpDecoder.java, + public boolean acceptInboundMessage(Object msg) throws Exception {, + return msg instanceof
[+++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteConnectorChannel.java, + protected int doWriteBytes(final ByteBuf byteBuf, final boolean lastSpin) throws Exception {, + final int expectedWrittenBytes = byteBuf.readableBytes();, + final int writtenBytes = byteBuf.readBytes(javaChannel(), expectedWrittenBytes);, + updateOpWrite(expectedWrittenBytes, writtenBytes, lastSpin);, +++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteConnectorChannel.java, + protected int doWriteBytes(final ByteBuf byteBuf, final boolean lastSpin) throws Exception {, + final int expectedWrittenBytes = byteBuf.readableBytes();, + final int writtenBytes = byteBuf.readBytes(javaChannel(), expectedWrittenBytes);, + updateOpWrite(expectedWrittenBytes, writtenBytes, lastSpin);, +++ b/transport/src/main/java/io/netty/channel/DefaultFileRegion.java, +++ b/transport-udt/src/main/java/io/netty/channel/udt/nio/NioUdtByteConnectorChannel.java, + protected int doWriteBytes(final ByteBuf byteBuf, final boolean lastSpin) throws Exception {, + final int expectedWrittenBytes = byteBuf.readableBytes();, + final int writtenBytes = byteBuf.readBytes(javaChannel(), expectedWrittenBytes);, + updateOpWrite(expectedWrittenBytes, writtenBytes, lastSpin);, +++ b/transport/src/main/java/io/netty/channel/DefaultFileRegion.java, +++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioByteChannel.java,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMessage.java, + * An HTTP message which provides common properties for {@link HttpRequest} and, + * {@link HttpResponse}., + * Returns the header value with the specified header name. If there are, + * more than one header value for the specified header name, the first, + * value is returned., + * @return the header value or {@code null} if there is no such header, + * Returns the header values with the specified header name., + * @return the {@link List} of header values. An empty list if there is no, + * such header., +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, + if (!in.isReadable()) {, + return;, + }, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, + if (!in.isReadable()) {, + return;, + }, +, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoderTest.java, +/*, + * Copyright 2013 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License, version 2.0 (the "License");, + * you may not use this file except in compliance with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketUtil.java, +import io.netty.util.internal.PlatformDependent;, + PlatformDependent.threadLocalRandom().nextBytes(bytes);, + assert minimum < maximum;, + double fraction = PlatformDependent.threadLocalRandom().nextDouble();, +, + // the idea here is that nextDouble gives us a random value, + //, + // 0 <= fraction <= 1, + //, + // the distance from min to max declared as, + //, + // dist = max - min, + //, + // satisfies the following, + //, + // min + dist = max, + //, + // taking into account, + //, + // 0 <= fraction * dist <= dist, + //, + // we've
[+++ b/all/pom.xml, + <id>full</id>, +++ b/all/pom.xml, + <id>full</id>, +++ b/pom.xml, + <id>full</id>, + <releaseProfiles>release,full</releaseProfiles>]
[+++ b/pom.xml, + <module>testsuite-osgi</module>, +++ b/pom.xml, + <module>testsuite-osgi</module>, +++ b/testsuite-osgi/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<!--, + ~ Copyright 2015 The Netty Project, + ~, + ~ The Netty Project licenses this file to you under the Apache License,, + ~ version 2.0 (the "License"); you may not use this file except in compliance, + ~ with the License. You may obtain a copy of the License at:, + ~, + ~ http://www.apache.org/licenses/LICENSE-2.0, + ~, + ~ Unless required by applicable law or agreed to in writing, software, + ~ distributed under the License is distributed on an "AS IS" BASIS,
[+++ b/handler/src/main/java/io/netty/handler/ssl/DelegatingSslContext.java, +import java.util.concurrent.Executor;, + protected SslHandler newHandler(ByteBufAllocator alloc, boolean startTls, Executor executor) {, + SslHandler handler = ctx.newHandler(alloc, startTls, executor);, + initHandler(handler);, + return handler;, + }, +, + @Override, + protected SslHandler newHandler(ByteBufAllocator alloc, String peerHost, int peerPort,, + boolean startTls, Executor executor) {, + SslHandler handler = ctx.newHandler(alloc, peerHost, peerPort, startTls, executor);, + initHandler(handler);, + return handler;, + }, +, + @Override, +++ b/handler/src/main/java/io/netty/handler/ssl/DelegatingSslContext.java, +import java.util.concurrent.Executor;, + protected SslHandler newHandler(ByteBufAllocator alloc, boolean startTls, Executor executor) {, + SslHandler handler = ctx.newHandler(alloc, startTls, executor);, + initHandler(handler);, + return handler;, + }, +, + @Override, + protected SslHandler
[+++ b/example/src/main/java/io/netty/example/http/file/HttpStaticFileServerHandler.java, + private static final Pattern ALLOWED_FILE_NAME = Pattern.compile("[^-\\._]?[^<>&\\\"]*");, + .append("<html><head><meta charset='utf-8' /><title>")]
[+++ b/pom.xml, + <version>3.1.0.ALPHA1</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/tags/netty-3.1.0.ALPHA1</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/tags/netty-3.1.0.ALPHA1</developerConnection>]
[+++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, +import io.netty.channel.socket.aio.AioEventLoopGroup;, +import io.netty.channel.socket.aio.AioSocketChannel;, +, + @Override, + public Bootstrap channel(Class<? extends Channel> channelClass) {, + if (channelClass == null) {, + throw new NullPointerException("channelClass");, + }, + if (channelClass == AioSocketChannel.class) {, + return channelFactory(new AioSocketChannelFactory());, + }, + return super.channel(channelClass);, + }, +, + private final class AioSocketChannelFactory implements ChannelFactory {, + @Override, + public Channel newChannel() {, + return new AioSocketChannel((AioEventLoopGroup) group());, + }, + }, +++ b/transport/src/main/java/io/netty/bootstrap/Bootstrap.java, +import io.netty.channel.socket.aio.AioEventLoopGroup;, +import io.netty.channel.socket.aio.AioSocketChannel;, +, + @Override, + public Bootstrap channel(Class<? extends Channel> channelClass) {, + if (channelClass == null) {, + throw new NullPointerException("channelClass");, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + ChannelHandlerContext ctx;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + ChannelHandlerContext ctx;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + final void flush0(ChannelHandlerContext ctx) {, + static final class Http2MultiplexCodecStream extends DefaultHttp2FrameStream {, + writeDoneAndNoFlush |= consumeBytes(stream.id(), numBytesToBeConsumed);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameCodec.java, + ChannelHandlerContext ctx;, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodec.java, + final void flush0(ChannelHandlerContext ctx) {, + static final class Http2MultiplexCodecStream extends DefaultHttp2FrameStream {, + writeDoneAndNoFlush |= consumeBytes(stream.id(), numBytesToBeConsumed);, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2MultiplexCodecBuilder.java, + private Http2FrameWriter frameWriter;, + // For testing only., + Http2MultiplexCodecBuilder frameWriter(Http2FrameWriter frameWriter) {, + this.frameWriter = checkNotNull(frameWriter, "frameWriter");, + return this;, + }, +, + Http2FrameWriter frameWriter = this.frameWriter;, + if (frameWriter != null) {, + // This is
[+++ b/codec/src/main/java/io/netty/handler/codec/compression/Lz4FrameEncoder.java, +import io.netty.buffer.Unpooled;, +import java.nio.ByteBuffer;, + private final int blockSize;, +, + private ByteBuf buffer;, + * @param factory user customizable {@link LZ4Factory} instance, + this.blockSize = blockSize;, + final ByteBuf buffer = this.buffer;, + final int blockSize = buffer.capacity();, + checksum.update(buffer.array(), buffer.arrayOffset(), currentBlockLength);, + ByteBuffer outNioBuffer = out.internalNioBuffer(idx + HEADER_LENGTH, out.writableBytes() - HEADER_LENGTH);, + int pos = outNioBuffer.position();, + // We always want to start at position 0 as we take care of reusing the buffer in the encode(...) loop., + compressor.compress(buffer.internalNioBuffer(0, currentBlockLength), outNioBuffer);, + compressedLength = outNioBuffer.position() - pos;, + out.setBytes(idx + HEADER_LENGTH, buffer, 0, currentBlockLength);,
[+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java]
[+++ b/transport/src/test/java/io/netty/channel/ReentrantChannelTest.java, +import io.netty.util.concurrent.Future;, +import io.netty.util.concurrent.GenericFutureListener;, +import java.nio.channels.ClosedChannelException;, +, +import static org.junit.Assert.*;, +, + @Test, + public void testWriteFlushPingPong() throws Exception {, +, + LocalAddress addr = new LocalAddress("testWriteFlushPingPong");, +, + ServerBootstrap sb = getLocalServerBootstrap();, + sb.bind(addr).sync().channel();, +, + Bootstrap cb = getLocalClientBootstrap();, +, + setInterest(Event.WRITE, Event.FLUSH, Event.CLOSE, Event.EXCEPTION);, +, + Channel clientChannel = cb.connect(addr).sync().channel();, +, + clientChannel.pipeline().addLast(new ChannelOutboundHandlerAdapter() {, +, + int writeCount;, + int flushCount;, +, + @Override, + public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {, + if (writeCount < 5) {, + writeCount++;, + ctx.channel().flush();, + }, + super.write(ctx, msg, promise);, +
[+++ b/codec-memcache/src/test/java/io/netty/handler/codec/memcache/binary/BinaryMemcacheObjectAggregatorTest.java, +, + channel.finish();]
[+++ b/pom.xml, + <version>3.1.0.BETA1-SNAPSHOT</version>, + <connection>scm:svn:http://anonsvn.jboss.org/repos/netty/trunk</connection>, + <developerConnection>scm:svn:https://svn.jboss.org/repos/netty/trunk</developerConnection>]
[+++ b/transport/src/main/java/io/netty/channel/ChannelHandlerAdapter.java, + public boolean isSharable() {]
[+++ b/transport/src/main/java/io/netty/bootstrap/AbstractBootstrap.java, +import io.netty.util.internal.logging.InternalLogger;, + static void setChannelOptions(, + Channel channel, Map<ChannelOption<?>, Object> options, InternalLogger logger) {, + for (Map.Entry<ChannelOption<?>, Object> e: options.entrySet()) {, + setChannelOption(channel, e.getKey(), e.getValue(), logger);, + }, + }, +, + static void setChannelOptions(, + Channel channel, Map.Entry<ChannelOption<?>, Object>[] options, InternalLogger logger) {, + for (Map.Entry<ChannelOption<?>, Object> e: options) {, + setChannelOption(channel, e.getKey(), e.getValue(), logger);, + }, + }, +, + @SuppressWarnings("unchecked"), + private static void setChannelOption(, + Channel channel, ChannelOption<?> option, Object value, InternalLogger logger) {, + try {, + if (!channel.config().setOption((ChannelOption<Object>) option, value)) {, + logger.warn("Unknown channel option '{}' for channel '{}'", option,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +import io.netty.buffer.ByteBufProcessor;, + private final AppendableCharSequence seq = new AppendableCharSequence(128);, + private final HeaderParser headerParser = new HeaderParser(seq);, + private final LineParser lineParser = new LineParser(seq);, + String[] initialLine = splitInitialLine(lineParser.parse(buffer));, + AppendableCharSequence line = lineParser.parse(buffer);, + AppendableCharSequence line = headerParser.parse(buffer);, + line = headerParser.parse(buffer);, + AppendableCharSequence line = headerParser.parse(buffer);, + line = headerParser.parse(buffer);, +, + private final class HeaderParser implements ByteBufProcessor {, + private final AppendableCharSequence seq;, +, + HeaderParser(AppendableCharSequence seq) {, + this.seq = seq;, + }, +, + public AppendableCharSequence parse(ByteBuf buffer) {, + seq.reset();, + headerSize = 0;, + int i = buffer.forEachByte(this);,
[+++ b/example/src/main/java/io/netty/example/sctp/SctpEchoClient.java, +/*, + * Copyright 2012 The Netty Project, + *, + * The Netty Project licenses this file to you under the Apache License,, + * version 2.0 (the "License"); you may not use this file except in compliance, + * with the License. You may obtain a copy of the License at:, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslClientContext.java, + private final OpenSslSessionContext sessionContext;, + sessionContext = new OpenSslClientSessionContext(ctx);, + public OpenSslSessionContext sessionContext() {, + return sessionContext;, + }, +, + // No cache is currently supported for client side mode., + private static final class OpenSslClientSessionContext extends OpenSslSessionContext {, + private OpenSslClientSessionContext(long context) {, + super(context);, + }, +, + @Override, + public void setSessionTimeout(int seconds) {, + if (seconds < 0) {, + throw new IllegalArgumentException();, + }, + }, +, + @Override, + public int getSessionTimeout() {, + return 0;, + }, +, + @Override, + public void setSessionCacheSize(int size) {, + if
[+++ b/handler/src/test/java/io/netty/handler/ssl/PemEncodedTest.java, +import static org.junit.Assume.assumeFalse;, + assumeFalse(OpenSsl.useKeyManagerFactory());, +]
[+++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return (int) out.write(toByteBuffers(index, length));, + }, +++ b/buffer/src/main/java/io/netty/buffer/DynamicChannelBuffer.java, + , + , + // Check if we exceeded the maximum size of 2gb if this is the case then , + // newCapacity == 0, + //, + // https://github.com/netty/netty/issues/258, + if (newCapacity == 0) {, + throw new IllegalStateException("Maximum size of 2gb exceeded");, + }, +++ b/buffer/src/main/java/io/netty/buffer/CompositeChannelBuffer.java, +import io.netty.util.internal.DetectionUtil;, +, + if (DetectionUtil.javaVersion() >= 7) {, + return
[+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, + incrementPendingOutboundBytes(size, true);, + void incrementPendingOutboundBytes(int size, boolean fireEvent) {, + if (fireEvent) {, + }, + void decrementPendingOutboundBytes(int size, boolean fireEvent) {, + if (fireEvent) {, + }, + decrementPendingOutboundBytes(size, true);, + decrementPendingOutboundBytes(size, true);, +++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java, + incrementPendingOutboundBytes(size, true);, + void incrementPendingOutboundBytes(int size, boolean fireEvent) {, + if (fireEvent) {, + }, + void decrementPendingOutboundBytes(int size, boolean fireEvent) {, + if (fireEvent) {, + }, + decrementPendingOutboundBytes(size, true);, + decrementPendingOutboundBytes(size, true);, +++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, +import static io.netty.channel.DefaultChannelPipeline.logger;, + DefaultChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutorGroup group, String name,, + ChannelHandler handler) {, +, + write(msg, false, promise);, +, + write(msg, true,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java, + this.setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + this.setBinaryData(binaryData);, + this.setFinalFragment(finalFragment);, + this.setRsv(rsv);, + this.setBinaryData(binaryData);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java, + this.setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + this.setBinaryData(binaryData);, + this.setFinalFragment(finalFragment);, + this.setRsv(rsv);, + this.setBinaryData(binaryData);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java, + this.setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + this.setFinalFragment(finalFragment);, + this.setRsv(rsv);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java, + this.setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + this.setBinaryData(binaryData);, + this.setFinalFragment(finalFragment);, + this.setRsv(rsv);, + this.setBinaryData(binaryData);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java, + this.setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + this.setFinalFragment(finalFragment);, + this.setRsv(rsv);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/ContinuationWebSocketFrame.java, + this.setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + this.setBinaryData(binaryData);, + this.setFinalFragment(finalFragment);, + this.setRsv(rsv);, + this.setBinaryData(binaryData);, + this.setFinalFragment(finalFragment);, + this.setRsv(rsv);, + this.setBinaryData(binaryData);, + this.setFinalFragment(finalFragment);, + this.setRsv(rsv);, + this.setText(text);, + if (this.getBinaryData() == null) {, + return this.getBinaryData().toString(CharsetUtil.UTF_8);, + this.setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + this.setBinaryData(ChannelBuffers.copiedBuffer(text, CharsetUtil.UTF_8));, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java, + this.setBinaryData(ChannelBuffers.EMPTY_BUFFER);, + this.setBinaryData(binaryData);, + this.setFinalFragment(finalFragment);, +
[+++ b/buffer/src/test/java/io/netty/buffer/ByteBufUtilTest.java, + byte[][] validUtf8Bytes = {, + {(byte) 0x24},, + {(byte) 0xC2, (byte) 0xA2},, + {(byte) 0xE2, (byte) 0x82, (byte) 0xAC},, + {(byte) 0xF0, (byte) 0x90, (byte) 0x8D, (byte) 0x88},, + {(byte) 0x24,, + byte[][] invalidUtf8Bytes = {, + {(byte) 0x80},, + {(byte) 0xF0, (byte) 0x82, (byte) 0x82, (byte) 0xAC}, // Overlong encodings, + {(byte) 0xC2}, // not enough bytes, + {(byte) 0xE2, (byte) 0x82}, // not enough bytes, + {(byte) 0xF0, (byte) 0x90, (byte) 0x8D}, // not enough bytes, + {(byte) 0xC2, (byte) 0xC0}, // not correct bytes, + {(byte) 0xE2, (byte) 0x82, (byte) 0xC0}, // not
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHttpEncoder.java, + frameHeaders.set(SpdyHeaders.HttpNames.METHOD, httpRequest.method().name());, + frameHeaders.set(SpdyHeaders.HttpNames.VERSION, httpRequest.protocolVersion().text());, + frameHeaders.set(SpdyHeaders.HttpNames.STATUS, httpResponse.status().codeAsText());, + frameHeaders.set(SpdyHeaders.HttpNames.VERSION, httpResponse.protocolVersion().text());]
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java, + ByteBufAllocator DEFAULT = ByteBufUtil.DEFAULT_ALLOCATOR;, +, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufAllocator.java, + ByteBufAllocator DEFAULT = ByteBufUtil.DEFAULT_ALLOCATOR;, +, +++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, +import io.netty.util.internal.SystemPropertyUtil;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +import java.util.Locale;, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(ByteBufUtil.class);, +, + static final ByteBufAllocator DEFAULT_ALLOCATOR;, +, +, + String allocType = SystemPropertyUtil.get("io.netty.allocator.type", "pooled").toLowerCase(Locale.US).trim();, + ByteBufAllocator alloc;, + if ("unpooled".equals(allocType)) {, + alloc = UnpooledByteBufAllocator.DEFAULT;, + logger.debug("-Dio.netty.allocator.type: {}", allocType);, + } else if ("pooled".equals(allocType)) {, + alloc = PooledByteBufAllocator.DEFAULT;, + logger.debug("-Dio.netty.allocator.type: {}", allocType);, + } else {, + alloc = PooledByteBufAllocator.DEFAULT;, + logger.debug("-Dio.netty.allocator.type: pooled (unknown: {})", allocType);, + }, +, + DEFAULT_ALLOCATOR = alloc;, +++
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import static io.netty.handler.ssl.SslUtils.SSL_RECORD_HEADER_LENGTH;, +import static io.netty.internal.tcnative.SSL.SSL_MAX_PLAINTEXT_LENGTH;, +import static io.netty.internal.tcnative.SSL.SSL_MAX_RECORD_LENGTH;, +import static io.netty.util.internal.EmptyArrays.EMPTY_CERTIFICATES;, +import static io.netty.util.internal.EmptyArrays.EMPTY_JAVAX_X509_CERTIFICATES;, +import static io.netty.util.internal.ObjectUtil.checkNotNull;, + static final int MAX_PLAINTEXT_LENGTH = SSL_MAX_PLAINTEXT_LENGTH;, + /**, + * Depends upon tcnative ... only use if tcnative is available!, + */, + private static final int MAX_RECORD_SIZE = SSL_MAX_RECORD_LENGTH;, + if (len < SSL_RECORD_HEADER_LENGTH) {, + final int packetLengthDataOnly = packetLength - SSL_RECORD_HEADER_LENGTH;, + if (packetLengthDataOnly > capacity) {, + // Not enough space in the destination buffer so signal the caller that the buffer needs to be, + // increased., + if (packetLengthDataOnly > MAX_RECORD_SIZE) {,
[+++ b/handler/src/main/java/io/netty/handler/logging/LoggingHandler.java, + return formatSimple(ctx, eventName, arg);, + return formatSimple(ctx, eventName, firstArg);, + private static String formatSimple(ChannelHandlerContext ctx, String eventName, Object msg) {]
[+++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +import io.netty.util.internal.PlatformDependent;, + PlatformDependent.threadLocalRandom().nextBytes(data);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +import io.netty.util.internal.PlatformDependent;, + PlatformDependent.threadLocalRandom().nextBytes(data);, +++ b/buffer/src/test/java/io/netty/buffer/RetainedSlicedByteBufTest.java, +import io.netty.util.internal.PlatformDependent;, + ByteBuf buffer = wrapped.retainedSlice(length > 1 ?, + PlatformDependent.threadLocalRandom().nextInt(length - 1) + 1 : 0, length);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +import io.netty.util.internal.PlatformDependent;, + PlatformDependent.threadLocalRandom().nextBytes(data);, +++ b/buffer/src/test/java/io/netty/buffer/RetainedSlicedByteBufTest.java, +import io.netty.util.internal.PlatformDependent;, + ByteBuf buffer = wrapped.retainedSlice(length > 1 ?, + PlatformDependent.threadLocalRandom().nextInt(length - 1) + 1 : 0, length);, +++ b/buffer/src/test/java/io/netty/buffer/SlicedByteBufTest.java, +import io.netty.util.internal.PlatformDependent;, + new byte[length * 2], length > 1 ?, + PlatformDependent.threadLocalRandom().nextInt(length - 1) + 1 : 0, length);, +++ b/buffer/src/test/java/io/netty/buffer/AbstractByteBufTest.java, +import io.netty.util.internal.PlatformDependent;, + PlatformDependent.threadLocalRandom().nextBytes(data);, +++ b/buffer/src/test/java/io/netty/buffer/RetainedSlicedByteBufTest.java, +import io.netty.util.internal.PlatformDependent;, + ByteBuf buffer = wrapped.retainedSlice(length > 1
[+++ b/pom.xml, + <useReleaseProfile>false</useReleaseProfile>, + <arguments>-P release,sonatype-oss-release,full</arguments>]
[+++ b/pom.xml]
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + private int dataSize;, + dataSize = queue.readableBytes();, + return dataSize + padding;, + // Don't update dataSize because we need to ensure the size() method returns a consistent size even after, + // error so we don't invalidate flow control when returning bytes to flow control., + dataSize = queue.readableBytes();, + dataSize = queue.readableBytes();, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionEncoder.java, + private int dataSize;, + dataSize = queue.readableBytes();, + return dataSize + padding;, + // Don't update dataSize because we need to ensure the size() method returns a consistent size even after, + // error so we don't invalidate flow
[+++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/package-info.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/package-info.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/SocksMessage.java, + * {@link SocksRequest} and {@link SocksResponse}., +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/package-info.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/SocksMessage.java, + * {@link SocksRequest} and {@link SocksResponse}., +++ /dev/null, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/package-info.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/SocksMessage.java, + * {@link SocksRequest} and {@link SocksResponse}., +++ /dev/null, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/SocksProtocolVersion.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/package-info.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/SocksMessage.java, + * {@link SocksRequest} and {@link SocksResponse}., +++ /dev/null, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/SocksProtocolVersion.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/SocksRequest.java, +import io.netty.handler.codec.socksx.v4.Socks4Request;, +import io.netty.handler.codec.socksx.v5.Socks5Request;, + * An abstract class that defines a SOCKS request, providing common properties for, + * {@link Socks4Request} and {@link Socks5Request}., +++ b/codec-socks/src/main/java/io/netty/handler/codec/socks/package-info.java, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/SocksMessage.java, + * {@link SocksRequest} and {@link SocksResponse}., +++ /dev/null, +++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/SocksProtocolVersion.java, +++
[+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(AbstractEventExecutor.class);, +, + /**, + * Try to execute the given {@link Runnable} and just log if it throws a {@link Throwable}., + */, + protected static void safeExecute(Runnable task) {, + try {, + task.run();, + } catch (Throwable t) {, + logger.warn("A task raised an exception. Task: {}", task, t);, + }, + }, +++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(AbstractEventExecutor.class);, +, + /**, + * Try to execute the given {@link Runnable} and just
[+++ b/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java, + ch.register(unwrappedSelector, interestOps, task);, +++ b/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java, + ch.register(unwrappedSelector, interestOps, task);, +++ b/transport/src/test/java/io/netty/channel/nio/NioEventLoopTest.java, +import java.net.InetSocketAddress;, +import java.nio.channels.SelectionKey;, +import java.nio.channels.SocketChannel;, +, + @Test(timeout = 1000), + public void testSelectableChannel() throws Exception {, + NioEventLoopGroup group = new NioEventLoopGroup(1);, + NioEventLoop loop = (NioEventLoop) group.next();, +, + try {, + Channel channel = new NioServerSocketChannel();, + loop.register(channel).syncUninterruptibly();, + channel.bind(new InetSocketAddress(0)).syncUninterruptibly();, +, + SocketChannel selectableChannel = SocketChannel.open();, + selectableChannel.configureBlocking(false);, + selectableChannel.connect(channel.localAddress());, +, + final CountDownLatch latch = new CountDownLatch(1);, +, + loop.register(selectableChannel, SelectionKey.OP_CONNECT, new NioTask<SocketChannel>() {, + @Override, + public void channelReady(SocketChannel ch, SelectionKey key) {, + latch.countDown();, + }, +,
[+++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioMessageChannel.java, + if (!isActive()) {, + // If the channel is not active anymore for whatever reason we should not try to continue reading., + return true;, + }, + if (cause instanceof PortUnreachableException) {, + return false;, + }, + if (cause instanceof IOException) {, + return !(this instanceof ServerChannel);, + }, + return true;, +++ b/transport/src/main/java/io/netty/channel/nio/AbstractNioMessageChannel.java, + if (!isActive()) {, + // If the channel is not active anymore for whatever reason we should not try to continue reading., + return true;, + }, + if (cause instanceof PortUnreachableException) {, + return false;, + }, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import static javax.net.ssl.SSLEngineResult.Status.BUFFER_UNDERFLOW;, + private int writeEncryptedData(final ByteBuffer src, int len) {, + int newLimit = pos + len;, + if (newLimit != src.remaining()) {, + buf.setBytes(0, (ByteBuffer) src.duplicate().position(pos).limit(newLimit));, + } else {, + }, + if (dst.remaining() < MAX_ENCRYPTED_PACKET_LENGTH) {, + // Can not hold the maximum packet so we need to tell the caller to use a bigger destination, + // buffer., + return new SSLEngineResult(BUFFER_OVERFLOW, getHandshakeStatus(), 0, 0);, + }, + if (len < SslUtils.SSL_RECORD_HEADER_LENGTH) {, + return new SSLEngineResult(BUFFER_UNDERFLOW, getHandshakeStatus(), 0, 0);, + }, +, + int packetLength = SslUtils.getEncryptedPacketLength(srcs, srcsOffset);, + if
[+++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +import io.netty.channel.ChannelOutboundMessageHandler;, +import io.netty.channel.ChannelPipeline;, + /**, + * The types which will be accepted by the encoder. If a received message is an other type it will be just forwared, + * to the next {@link ChannelOutboundMessageHandler} in the {@link ChannelPipeline}, + */, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +import io.netty.channel.ChannelOutboundMessageHandler;, +import io.netty.channel.ChannelPipeline;, + /**, + * The types which will be accepted by the encoder. If a received message is an other type it will be just forwared, + * to the next {@link ChannelOutboundMessageHandler} in the {@link ChannelPipeline}, + */, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java, + *, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToByteEncoder.java, +import io.netty.channel.ChannelOutboundMessageHandler;, +import
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java, + * Web Socket frame containing binary data., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java, + * Web Socket frame containing binary data., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java, + * Web Socket Frame for closing the connection., + * reserved bits used for protocol extensions., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/BinaryWebSocketFrame.java, + * Web Socket frame containing binary data., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/CloseWebSocketFrame.java, + * Web Socket Frame for closing the connection., + * reserved bits used for protocol extensions., +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/ContinuationWebSocketFrame.java, + * Creates a new continuation frame with the specified binary data., + * Returns the text data in this frame., + * Sets the string for this frame.,
[+++ b/all/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.3.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/all/pom.xml, + <version>4.1.29.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.29.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.29.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.29.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.29.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, + <version>4.1.29.Final-SNAPSHOT</version>, +
[+++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java, + this(header, null, null);, + this(header, key, null);, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheRequest.java, + this(header, null, null);, + this(header, key, null);, +++ b/codec-memcache/src/main/java/io/netty/handler/codec/memcache/binary/DefaultBinaryMemcacheResponse.java, + this(header, null, null);, + this(header, key, null);]
[+++ b/handler/src/main/java/io/netty/handler/ssl/ApplicationProtocolNegotiationHandler.java, + SslHandler sslHandler = ctx.pipeline().get(SslHandler.class);, + if (sslHandler == null) {, + throw new IllegalStateException("cannot find a SslHandler in the pipeline (required for " +, + "application-level protocol negotiation)");, + }, +++ b/handler/src/main/java/io/netty/handler/ssl/ApplicationProtocolNegotiationHandler.java, + SslHandler sslHandler = ctx.pipeline().get(SslHandler.class);, + if (sslHandler == null) {, + throw new IllegalStateException("cannot find a SslHandler in the pipeline (required for " +, + "application-level protocol negotiation)");, + }, +++ b/handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java, +import io.netty.bootstrap.Bootstrap;, +import io.netty.bootstrap.ServerBootstrap;, +import io.netty.channel.Channel;, +import io.netty.channel.ChannelFuture;, +import io.netty.channel.ChannelHandlerContext;, +import io.netty.channel.ChannelInitializer;, +import io.netty.channel.ChannelPipeline;, +import io.netty.channel.EventLoopGroup;, +import io.netty.channel.nio.NioEventLoopGroup;, +import io.netty.channel.socket.nio.NioServerSocketChannel;, +import io.netty.channel.socket.nio.NioSocketChannel;, +import io.netty.util.DomainMappingBuilder;, +import java.net.InetSocketAddress;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +import
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectAggregator.java, +import io.netty.handler.codec.TooLongFrameException;, +import io.netty.util.internal.logging.InternalLogger;, +import io.netty.util.internal.logging.InternalLoggerFactory;, +, + /**, + * @deprecated Will be removed in the next minor version bump., + */, + @Deprecated, + public static final int DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS = 1024; // TODO: Make it private in the next bump., +, + private static final InternalLogger logger = InternalLoggerFactory.getInstance(HttpObjectAggregator.class);, +, + static {, + TOO_LARGE.headers().set(Names.CONTENT_LENGTH, 0);, + }, +, + private boolean handlingOversizedMessage;, + * {@link #handleOversizedMessage(ChannelHandlerContext, HttpMessage)}, + * The default value of this property is {@value #DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS}., + * The default value of this property is {@value #DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS}, + handlingOversizedMessage = false;, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + logger.debug("{} WebSocket version {} server handshake", channel, version());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker.java, + logger.debug("{} WebSocket version {} server handshake", channel, version());, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerHandshaker07.java, + logger.debug("WebSocket version 07 server handshake key: {}, response: {}.", key, accept);]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + if (!freed) {, + }]
[+++ b/all/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/codec-http2/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/codec-dns/pom.xml, + <version>4.1.0.Beta5-SNAPSHOT</version>, +++ b/codec-haproxy/pom.xml, +
[+++ b/common/src/main/java/io/netty/util/concurrent/ImmediateEventExecutor.java, +++ b/common/src/main/java/io/netty/util/concurrent/ImmediateEventExecutor.java, +++ b/example/src/main/java/io/netty/example/securechat/SecureChatServerHandler.java, +import io.netty.util.concurrent.GlobalEventExecutor;, + static final ChannelGroup channels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);, +++ b/common/src/main/java/io/netty/util/concurrent/ImmediateEventExecutor.java, +++ b/example/src/main/java/io/netty/example/securechat/SecureChatServerHandler.java, +import io.netty.util.concurrent.GlobalEventExecutor;, + static final ChannelGroup channels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/udt/UDTClientServerConnectionTest.java, +import io.netty.util.concurrent.DefaultThreadFactory;, +import io.netty.util.concurrent.GlobalEventExecutor;, +import java.util.concurrent.ThreadFactory;, + final ThreadFactory clientFactory = new DefaultThreadFactory("client");, + final ChannelGroup group = new DefaultChannelGroup("server group", GlobalEventExecutor.INSTANCE);, + final ThreadFactory acceptFactory = new DefaultThreadFactory("accept");, + final ThreadFactory serverFactory = new DefaultThreadFactory("server");, + if (group.isEmpty()) {, + * wait-time = {@code WAIT_COUNT} * {@value #WAIT_SLEEP}, +++ b/common/src/main/java/io/netty/util/concurrent/ImmediateEventExecutor.java, +++ b/example/src/main/java/io/netty/example/securechat/SecureChatServerHandler.java, +import io.netty.util.concurrent.GlobalEventExecutor;, + static final ChannelGroup channels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);, +++ b/testsuite/src/test/java/io/netty/testsuite/transport/udt/UDTClientServerConnectionTest.java, +import io.netty.util.concurrent.DefaultThreadFactory;,
[+++ b/buffer/pom.xml, +++ b/buffer/pom.xml, +++ b/codec-http/pom.xml, +++ b/buffer/pom.xml, +++ b/codec-http/pom.xml, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyProtocolException.java, + private static final long serialVersionUID = -1097979786367505658L;, +, +++ b/buffer/pom.xml, +++ b/codec-http/pom.xml, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyProtocolException.java, + private static final long serialVersionUID = -1097979786367505658L;, +, +++ b/codec/pom.xml, +++ b/buffer/pom.xml, +++ b/codec-http/pom.xml, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyProtocolException.java, + private static final long serialVersionUID = -1097979786367505658L;, +, +++ b/codec/pom.xml, +++ b/common/pom.xml, +++ b/buffer/pom.xml, +++ b/codec-http/pom.xml, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyProtocolException.java, + private static final long serialVersionUID = -1097979786367505658L;, +, +++ b/codec/pom.xml, +++ b/common/pom.xml, +++ b/example/pom.xml, +++ b/buffer/pom.xml, +++ b/codec-http/pom.xml, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyProtocolException.java, + private static final long serialVersionUID = -1097979786367505658L;, +, +++ b/codec/pom.xml, +++ b/common/pom.xml, +++ b/example/pom.xml,
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, +import io.netty.buffer.ByteBufUtil;, + // Create the debug message. `* 3` because UTF-8 max character consumes 3 bytes., + ByteBuf debugData = ctx.alloc().buffer(cause.getMessage().length() * 3);, + ByteBufUtil.writeUtf8(debugData, cause.getMessage());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2CodecUtil.java, +import io.netty.buffer.ByteBufUtil;, + // Create the debug message. `* 3` because UTF-8 max character consumes 3 bytes., + ByteBuf debugData = ctx.alloc().buffer(cause.getMessage().length() * 3);, + ByteBufUtil.writeUtf8(debugData, cause.getMessage());, +++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java, + // Need to retain before we write the buffer because if we do it after the refCnt could already be 0 and, + // result in an IllegalRefCountException., + debugData.retain();, + if (future.isDone()) {, + processGoAwayWriteResult(ctx, lastStreamId, errorCode,
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpConstants.java, + /**, + * Horizontal space, + */, + public static final char SP_CHAR = (char) SP;, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpConstants.java, + /**, + * Horizontal space, + */, + public static final char SP_CHAR = (char) SP;, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, +, + sb.append(HttpConstants.SP_CHAR);, + sb.append(HttpConstants.SP_CHAR);, + sb.append(HttpConstants.SP_CHAR);, + sb.append(HttpConstants.SP_CHAR);, + sb.append(HttpConstants.SP_CHAR);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpConstants.java, + /**, + * Horizontal space, + */, + public static final char SP_CHAR = (char) SP;, +, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostMultipartRequestDecoder.java, +, + sb.append(HttpConstants.SP_CHAR);, + sb.append(HttpConstants.SP_CHAR);, + sb.append(HttpConstants.SP_CHAR);, + sb.append(HttpConstants.SP_CHAR);, + sb.append(HttpConstants.SP_CHAR);, +++ b/codec-http/src/test/java/io/netty/handler/codec/http/multipart/HttpPostRequestDecoderTest.java, +import io.netty.handler.codec.http.HttpHeaders;, +, + @Test, + public void testFilenameContainingSemicolon2() throws Exception
[+++ b/microbench/pom.xml, + <jmh.version>1.17.4</jmh.version>, + <version>${jmh.version}</version>, + <version>${jmh.version}</version>]
[+++ b/transport/src/main/java/io/netty/channel/socket/nio/NioDatagramChannel.java, +import io.netty.channel.ChannelFuture;, +import java.net.SocketAddress;, +, + @Override, + public ChannelFuture write(Object message, SocketAddress remoteAddress) {, + if (remoteAddress == null || remoteAddress.equals(getRemoteAddress())) {, + return super.write(message, null);, + } else {, + return super.write(message, remoteAddress);, + }, +, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, +import io.netty.channel.ChannelHandlerUtil;, + return ChannelHandlerUtil.allocate(ctx);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, +import io.netty.channel.ChannelHandlerUtil;, + return ChannelHandlerUtil.allocate(ctx);, +++ b/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java, +import io.netty.channel.ChannelHandlerUtil;, + return ChannelHandlerUtil.allocate(ctx, frameLength);, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, +import io.netty.channel.ChannelHandlerUtil;, + return ChannelHandlerUtil.allocate(ctx);, +++ b/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java, +import io.netty.channel.ChannelHandlerUtil;, + return ChannelHandlerUtil.allocate(ctx, frameLength);, +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClientHandler.java, +import io.netty.channel.ChannelHandlerUtil;, + return ChannelHandlerUtil.allocate(ctx,, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, +import io.netty.channel.ChannelHandlerUtil;, + return ChannelHandlerUtil.allocate(ctx);, +++ b/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java, +import io.netty.channel.ChannelHandlerUtil;, + return ChannelHandlerUtil.allocate(ctx, frameLength);, +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClientHandler.java, +import io.netty.channel.ChannelHandlerUtil;, + return ChannelHandlerUtil.allocate(ctx,, +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoServerHandler.java, +import io.netty.channel.ChannelHandlerUtil;, + return ChannelHandlerUtil.allocate(ctx,, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyOrHttpChooser.java, +import io.netty.channel.ChannelHandlerUtil;, + return ChannelHandlerUtil.allocate(ctx);, +++ b/codec/src/main/java/io/netty/handler/codec/FixedLengthFrameDecoder.java, +import io.netty.channel.ChannelHandlerUtil;, + return ChannelHandlerUtil.allocate(ctx, frameLength);, +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoClientHandler.java, +import io.netty.channel.ChannelHandlerUtil;, + return ChannelHandlerUtil.allocate(ctx,, +++ b/example/src/main/java/io/netty/example/udt/echo/bytes/ByteEchoServerHandler.java, +import io.netty.channel.ChannelHandlerUtil;,
[+++ b/all/pom.xml, + <artifactId>netty-all</artifactId>, + <packaging>jar</packaging>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java, + private final boolean validateHeaders;, + this.validateHeaders = validateHeaders;, + getProtocolVersion(), getMethod(), getUri(), content().copy(), validateHeaders);, + getProtocolVersion(), getMethod(), getUri(), content().duplicate(), validateHeaders);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java, + private final boolean validateHeaders;, + this.validateHeaders = validateHeaders;, + getProtocolVersion(), getMethod(), getUri(), content().copy(), validateHeaders);, + getProtocolVersion(), getMethod(), getUri(), content().duplicate(), validateHeaders);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java, + private final boolean validateHeaders;, + this.validateHeaders = validateHeaders;, + DefaultFullHttpResponse copy = new DefaultFullHttpResponse(, + getProtocolVersion(), getStatus(), content().copy(), validateHeaders);, + content().duplicate(), validateHeaders);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpRequest.java, + private final boolean validateHeaders;, + this.validateHeaders = validateHeaders;, + getProtocolVersion(), getMethod(), getUri(), content().copy(), validateHeaders);, + getProtocolVersion(), getMethod(), getUri(), content().duplicate(), validateHeaders);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/DefaultFullHttpResponse.java, + private final
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkedInput.java, +import io.netty.buffer.ByteBufAllocator;, + @Deprecated, + return readChunk(ctx.alloc());, + }, +, + @Override, + public HttpContent readChunk(ByteBufAllocator allocator) throws Exception {, + ByteBuf buf = input.readChunk(allocator);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkedInput.java, +import io.netty.buffer.ByteBufAllocator;, + @Deprecated, + return readChunk(ctx.alloc());, + }, +, + @Override, + public HttpContent readChunk(ByteBufAllocator allocator) throws Exception {, + ByteBuf buf = input.readChunk(allocator);, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/HttpPostRequestEncoder.java, +import io.netty.buffer.ByteBufAllocator;, + @Deprecated, + @Override, + public HttpContent readChunk(ChannelHandlerContext ctx) throws Exception {, + return readChunk(ctx.alloc());, + }, +, + public HttpContent readChunk(ByteBufAllocator allocator) throws Exception {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpChunkedInput.java, +import io.netty.buffer.ByteBufAllocator;, + @Deprecated, + return readChunk(ctx.alloc());, + }, +, + @Override, +
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslX509Certificate.java, +import javax.security.auth.x500.X500Principal;, +import java.security.Provider;, +import java.security.cert.CertificateParsingException;, +import java.util.Collection;, +import java.util.List;, + public X500Principal getIssuerX500Principal() {, + return unwrap().getIssuerX500Principal();, + }, +, + @Override, + public X500Principal getSubjectX500Principal() {, + return unwrap().getSubjectX500Principal();, + }, +, + @Override, + public List<String> getExtendedKeyUsage() throws CertificateParsingException {, + return unwrap().getExtendedKeyUsage();, + }, +, + @Override, + public Collection<List<?>> getSubjectAlternativeNames() throws CertificateParsingException {, + return unwrap().getSubjectAlternativeNames();, + }, +, + @Override, + public Collection<List<?>> getIssuerAlternativeNames() throws CertificateParsingException {, + return unwrap().getSubjectAlternativeNames();, + }, +, + // No @Override annotation as it was only introduced in Java8., + public void verify(PublicKey key, Provider
[+++ b/all/pom.xml, + <version>4.1.13.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.13.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.13.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.1.13.Final-SNAPSHOT</version>, +++ b/bom/pom.xml, + <version>4.1.13.Final-SNAPSHOT</version>, + <tag>HEAD</tag>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, + <version>4.1.13.Final-SNAPSHOT</version>, +
[+++ b/buffer/pom.xml, + <packaging>bundle</packaging>, +++ b/buffer/pom.xml, + <packaging>bundle</packaging>, +++ b/codec-http/pom.xml, + <packaging>bundle</packaging>, +++ b/buffer/pom.xml, + <packaging>bundle</packaging>, +++ b/codec-http/pom.xml, + <packaging>bundle</packaging>, +++ b/codec-socks/pom.xml, + <packaging>bundle</packaging>, +++ b/buffer/pom.xml, + <packaging>bundle</packaging>, +++ b/codec-http/pom.xml, + <packaging>bundle</packaging>, +++ b/codec-socks/pom.xml, + <packaging>bundle</packaging>, +++ b/codec/pom.xml, + <packaging>bundle</packaging>, +++ b/buffer/pom.xml, + <packaging>bundle</packaging>, +++ b/codec-http/pom.xml, + <packaging>bundle</packaging>, +++ b/codec-socks/pom.xml, + <packaging>bundle</packaging>, +++ b/codec/pom.xml, + <packaging>bundle</packaging>, +++ b/common/pom.xml, + <packaging>bundle</packaging>, + <build>, + <plugins>, + <plugin>, + <groupId>org.apache.felix</groupId>, + <artifactId>maven-bundle-plugin</artifactId>, + <configuration>, + <instructions>, + <!-- enforce JVM vendor package as optional -->, + <Import-Package>, + sun.misc.*;resolution:=optional,, + *, + </Import-Package>, + <!-- override "internal" private package convention -->,
[+++ b/example/src/main/java/io/netty/example/securechat/SecureChatServer.java, + public void run() throws InterruptedException {]
[+++ b/codec-http/src/test/java/io/netty/handler/codec/http/HttpContentCompressorTest.java, +import io.netty.buffer.ByteBufUtil;, +import io.netty.buffer.Unpooled;, +import io.netty.handler.codec.http.HttpHeaders.Values;, +import io.netty.util.CharsetUtil;, +, + public void testSplitContent() throws Exception {, + ch.writeInbound(newRequest());, + ch.writeOutbound(new DefaultHttpContent(Unpooled.copiedBuffer("Hell", CharsetUtil.US_ASCII)));, + ch.writeOutbound(new DefaultHttpContent(Unpooled.copiedBuffer("o, w", CharsetUtil.US_ASCII)));, + ch.writeOutbound(new DefaultLastHttpContent(Unpooled.copiedBuffer("orld", CharsetUtil.US_ASCII)));, + assertEncodedResponse(ch);, + assertThat(ByteBufUtil.hexDump(chunk.content()), is("1f8b0800000000000000f248cdc901000000ffff"));, + assertThat(ByteBufUtil.hexDump(chunk.content()), is("cad7512807000000ffff"));, + chunk.release();, +, + chunk = ch.readOutbound();, + assertThat(ByteBufUtil.hexDump(chunk.content()), is("ca2fca4901000000ffff"));, + chunk.release();, +, + chunk = ch.readOutbound();, + assertThat(ByteBufUtil.hexDump(chunk.content()), is("0300c2a99ae70c000000"));, + assertThat(chunk, is(instanceOf(HttpContent.class)));, + chunk.release();, +, + chunk = ch.readOutbound();, + assertThat(chunk, is(instanceOf(LastHttpContent.class)));, +, + @Test, + public void testChunkedContent() throws Exception {, + EmbeddedChannel ch = new EmbeddedChannel(new HttpContentCompressor());, + ch.writeInbound(newRequest());, +, + HttpResponse res = new
[+++ b/transport/src/main/java/io/netty/channel/socket/oio/OioDatagramChannel.java, + InetSocketAddress remote = p.remoteAddress();, + if (remote != null) {, + tmpPacket.setSocketAddress(remote);, + }]
[+++ b/transport/src/test/java/io/netty/channel/pool/SimpleChannelPoolTest.java, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertNotSame;, +import static org.junit.Assert.assertSame;, +import static org.junit.Assert.assertThat;, +import static org.junit.Assert.fail;, + EventLoopGroup group = new LocalEventLoopGroup();, + ch.pipeline().addLast(new ChannelInboundHandlerAdapter());, + EventLoopGroup group = new LocalEventLoopGroup();, + ch.pipeline().addLast(new ChannelInboundHandlerAdapter());]
[+++ b/transport/src/main/java/io/netty/channel/group/ChannelGroupFuture.java]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java, +import io.netty.handler.codec.ByteToMessageDecoder;, +public abstract class HttpObjectDecoder extends ByteToMessageDecoder {, + private LastHttpContent trailer;, +, + private enum State {, + private State currentState = State.SKIP_CONTROL_CHARS;, +, + switch (currentState) {, + if (!skipControlCharacters(buffer)) {, + return;, + currentState = State.READ_INITIAL;, + AppendableCharSequence line = lineParser.parse(buffer);, + if (line == null) {, + return;, + }, + String[] initialLine = splitInitialLine(line);, + currentState = State.SKIP_CONTROL_CHARS;, + currentState = State.READ_HEADER;, + if (nextState == null) {, + return;, + }, + currentState = nextState;, + int toRead = Math.min(buffer.readableBytes(), maxChunkSize);, + int readLimit = buffer.readableBytes();, + if (line ==
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java, + public Set<Integer> getIds() {, + public boolean isPersistValue(int ID) {, + Setting(int value, boolean persist, boolean persisted) {, + int getValue() {, + void setValue(int value) {, + boolean getPersist() {, + void setPersist(boolean persist) {, + boolean getPersisted() {, + void setPersisted(boolean persisted) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/DefaultSpdySettingsFrame.java, + public Set<Integer> getIds() {, + public boolean isPersistValue(int ID) {, + Setting(int value, boolean persist, boolean persisted) {, + int getValue() {, + void setValue(int value) {, + boolean getPersist() {, + void setPersist(boolean persist) {, + boolean getPersisted() {, + void setPersisted(boolean persisted) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyFrameEncoder.java, +
[+++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java, +import static io.netty.util.internal.StringUtil.EMPTY_STRING;, +import static io.netty.util.internal.StringUtil.NEWLINE;, +import static io.netty.util.internal.StringUtil.simpleClassName;, + private int removedRecords;, + ++removedRecords;, + return EMPTY_STRING;, + final Object[] array;, + final int removedRecords;, + removedRecords = this.removedRecords;, + StringBuilder buf = new StringBuilder(16384).append(NEWLINE);, + if (removedRecords > 0) {, + buf.append("WARNING: "), + .append(removedRecords), + .append(" leak records were discarded because the leak record count is limited to "), + .append(MAX_RECORDS), + .append(". Use system property "), + .append(PROP_MAX_RECORDS), + .append(" to increase the limit."), + .append(NEWLINE);, + }, + buf.append("Recent access records: "), +++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java, +import static io.netty.util.internal.StringUtil.EMPTY_STRING;, +import static io.netty.util.internal.StringUtil.NEWLINE;, +import static
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslClientContext.java, + SSLContext.setVerify(ctx, SSL.SSL_CVERIFY_NONE, VERIFY_DEPTH);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslClientContext.java, + SSLContext.setVerify(ctx, SSL.SSL_CVERIFY_NONE, VERIFY_DEPTH);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import io.netty.util.internal.UnstableApi;, + /**, + * See <a href="https://www.openssl.org/docs/man1.0.2/ssl/SSL_set_verify.html">SSL_set_verify</a> and, + * {@link SSL#setVerify(long, int, int)}., + */, + @UnstableApi, + public synchronized final void setVerify(int verifyMode, int depth) {, + SSL.setVerify(ssl, verifyMode, depth);, + }, +, + SSL.setVerify(ssl, SSL.SSL_CVERIFY_REQUIRED, ReferenceCountedOpenSslContext.VERIFY_DEPTH);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslClientContext.java, + SSLContext.setVerify(ctx, SSL.SSL_CVERIFY_NONE, VERIFY_DEPTH);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslEngine.java, +import io.netty.util.internal.UnstableApi;, + /**, + * See <a href="https://www.openssl.org/docs/man1.0.2/ssl/SSL_set_verify.html">SSL_set_verify</a> and, + * {@link SSL#setVerify(long, int, int)}., + */, + @UnstableApi, + public synchronized final void setVerify(int verifyMode, int depth) {, + SSL.setVerify(ssl, verifyMode, depth);, + },
[+++ /dev/null, +++ /dev/null, +++ b/src/main/java/org/jboss/netty/channel/local/DefaultLocalChannel.java, +/*, + * JBoss, Home of Professional Open Source, + * Copyright 2005-2008, Red Hat Middleware LLC, and individual contributors, + * by the @authors tag. See the copyright.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version., +
[+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java, + PooledByteBuf<T> allocate(PoolThreadCache cache, int minCapacity, int maxCapacity) {, + allocate(cache, buf, minCapacity);, + private void allocate(PoolThreadCache cache, PooledByteBuf<T> buf, int minCapacity) {, + final int capacity = normalizeCapacity(minCapacity);, + if ((capacity & subpageOverflowMask) == 0) { // capacity < pageSize, + if ((capacity & 0xFFFFFE00) == 0) { // < 512, + tableIdx = capacity >>> 4;, + int i = capacity >>> 10;, + if (!s.doNotDestroy || s.elemSize != capacity) {, + s.chunk.initBufWithSubpage(buf, handle);, + allocateNormal(buf, capacity);, + private synchronized void allocateNormal(PooledByteBuf<T> buf, int capacity) {, + if (q050.allocate(buf, capacity) || q025.allocate(buf, capacity) ||, +
[+++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponseDecoder.java, + final DnsRecord r = recordDecoder.decodeRecord(buf);, + if (r == null) {, + // Truncated response, + break;, + }, +, + response.addRecord(section, r);, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DatagramDnsResponseDecoder.java, + final DnsRecord r = recordDecoder.decodeRecord(buf);, + if (r == null) {, + // Truncated response, + break;, + }, +, + response.addRecord(section, r);, +++ b/codec-dns/src/main/java/io/netty/handler/codec/dns/DefaultDnsRecordDecoder.java, + final int startOffset = in.readerIndex();, +, + final int endOffset = in.writerIndex();, + if (endOffset - startOffset < 10) {, + // Not enough data, + in.readerIndex(startOffset);, + return null;, + }, +, + if (endOffset - offset < length) {, + // Not
[+++ b/transport/src/main/java/io/netty/channel/ChannelPipeline.java, + * @param name the name of the handler to insert first. {@code null} to let the name auto-generated., + * if the specified handler is {@code null}, + * @param name the name of the handler to insert first. {@code null} to let the name auto-generated., + * if the specified handler is {@code null}, + * @param name the name of the handler to insert first. {@code null} to let the name auto-generated., + * if the specified handler is {@code null}, + * @param name the name of the handler to append. {@code null}
[+++ b/src/main/java/org/jboss/netty/channel/DefaultReceiveBufferSizePredictor.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2008, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version 2.1 of, + * the License, or (at your option) any later version., + *, +
[+++ b/transport-native-epoll/src/main/c/netty_epoll_native.c, +#include <sys/timerfd.h>, + netty_unix_errors_throwChannelExceptionErrorNo(env, "eventfd() failed: ", errno);, +static jint netty_epoll_native_timerFd(JNIEnv* env, jclass clazz) {, + jint timerFD = timerfd_create(CLOCK_MONOTONIC, TFD_CLOEXEC | TFD_NONBLOCK);, +, + if (timerFD < 0) {, + netty_unix_errors_throwChannelExceptionErrorNo(env, "timerfd_create() failed: ", errno);, + }, + return timerFD;, +}, +, + netty_unix_errors_throwChannelExceptionErrorNo(env, "eventfd_write() failed: ", errno);, +static void netty_epoll_native_timerFdRead(JNIEnv* env, jclass clazz, jint fd) {, + uint64_t timerFireCount;, +, + if (read(fd, &timerFireCount, sizeof(uint64_t)) < 0) {, + // it is expected that this is only called where there is known to be activity, so this is an error., + netty_unix_errors_throwChannelExceptionErrorNo(env, "read() failed: ",
[+++ b/example/src/main/java/io/netty/example/sctp/SctpClientHandler.java, +import io.netty.channel.sctp.SctpFrame;, + stateEvent.getChannel().write(new SctpFrame(0, 0, ChannelBuffers.wrappedBuffer("SCTP ECHO".getBytes())));, +++ b/example/src/main/java/io/netty/example/sctp/SctpClientHandler.java, +import io.netty.channel.sctp.SctpFrame;, + stateEvent.getChannel().write(new SctpFrame(0, 0, ChannelBuffers.wrappedBuffer("SCTP ECHO".getBytes())));, +++ b/transport-sctp/pom.xml, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-codec</artifactId>, + <version>${project.version}</version>, + </dependency>, +++ b/example/src/main/java/io/netty/example/sctp/SctpClientHandler.java, +import io.netty.channel.sctp.SctpFrame;, + stateEvent.getChannel().write(new SctpFrame(0, 0, ChannelBuffers.wrappedBuffer("SCTP ECHO".getBytes())));, +++ b/transport-sctp/pom.xml, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-codec</artifactId>, + <version>${project.version}</version>, + </dependency>, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelImpl.java, + if (m instanceof SctpFrame) {, + return ((SctpFrame) m).getPayloadBuffer().readableBytes();, +++ b/example/src/main/java/io/netty/example/sctp/SctpClientHandler.java, +import io.netty.channel.sctp.SctpFrame;, + stateEvent.getChannel().write(new SctpFrame(0, 0, ChannelBuffers.wrappedBuffer("SCTP ECHO".getBytes())));, +++ b/transport-sctp/pom.xml, + <dependency>, + <groupId>${project.groupId}</groupId>, + <artifactId>netty-codec</artifactId>, + <version>${project.version}</version>, + </dependency>, +++ b/transport-sctp/src/main/java/io/netty/channel/sctp/SctpChannelImpl.java, + if (m instanceof SctpFrame) {, + return ((SctpFrame)
[+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +import java.nio.channels.NotYetConnectedException;, +, +, + // Mark all pending write requests as failure if the channel is inactive., + if (!isActive()) {, + if (isOpen()) {, + outboundBuffer.fail(new NotYetConnectedException());, + } else {, + outboundBuffer.fail(new ClosedChannelException());, + }, + inFlushNow = false;, + return;, + }, +, +++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java, +import java.nio.channels.NotYetConnectedException;, +, +, + // Mark all pending write requests as failure if the channel is inactive., + if (!isActive()) {, + if (isOpen()) {, + outboundBuffer.fail(new NotYetConnectedException());, + } else {, + outboundBuffer.fail(new ClosedChannelException());, + }, + inFlushNow = false;, + return;, + }, +, +++
[+++ b/common/pom.xml, + <version>2.4.8</version>]
[+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslContext.java, + buffer.writeBytes(content, content.readerIndex(), content.readableBytes());]
[+++ b/codec/src/test/java/io/netty/handler/codec/frame/LengthFieldBasedFrameDecoderTest.java, + buf.release();]
[+++ b/transport/src/main/java/io/netty/channel/DefaultChannelHandlerContext.java, + void forwardBufferContent(final DefaultChannelHandlerContext forwardPrev,, + final DefaultChannelHandlerContext forwardNext) {, + boolean flush = false;, + boolean inboundBufferUpdated = false;, + ByteBuf forwardPrevBuf;, + if (forwardPrev.hasOutboundByteBuffer()) {, + forwardPrevBuf = forwardPrev.outboundByteBuffer();, + } else {, + forwardPrevBuf = forwardPrev.nextOutboundByteBuffer();, + }, + forwardPrevBuf.writeBytes(outboundByteBuffer());, + flush = true;, + MessageBuf<Object> forwardPrevBuf;, + if (forwardPrev.hasOutboundMessageBuffer()) {, + forwardPrevBuf = forwardPrev.outboundMessageBuffer();, + } else {, + forwardPrevBuf = forwardPrev.nextOutboundMessageBuffer();, + }, + if (outboundMessageBuffer().drainTo(forwardPrevBuf) > 0) {, + flush = true;, + ByteBuf forwardNextBuf;, + if (forwardNext.hasInboundByteBuffer()) {, + forwardNextBuf = forwardNext.inboundByteBuffer();, + } else {, + forwardNextBuf = forwardNext.nextInboundByteBuffer();,
[+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java, + * Encode a {@link CharSequence} in <a href="http://en.wikipedia.org/wiki/UTF-8">UTF-8</a> and write, + * it to a {@link ByteBuf}., + *, + * This method returns the actual number of bytes written., + */, + public static int writeUtf8(ByteBuf buf, CharSequence seq) {, + if (buf == null) {, + throw new NullPointerException("buf");, + }, + if (seq == null) {, + throw new NullPointerException("seq");, + }, + // UTF-8 uses max. 3 bytes per char, so calculate the worst case., + final int len = seq.length();, + final int maxSize = len * 3;, + buf.ensureWritable(maxSize);, +
[+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2FrameLogger.java, +import io.netty.util.internal.StringUtil;, + if (!logger.isEnabled(level)) {, + return StringUtil.EMPTY_STRING;, + }, +]
[+++ b/pom.xml, + <version>2.3.0</version>]
[+++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, + return buf;, +++ b/buffer/src/main/java/io/netty/buffer/SwappedByteBuf.java, + return buf;, +++ b/buffer/src/test/java/io/netty/buffer/ByteBufDerivationTest.java, +import static org.hamcrest.Matchers.sameInstance;, + assertThat(swapped.unwrap(), sameInstance(buf));]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBufAllocator.java, + private static final int DEFAULT_INITIAL_CAPACITY = 256;, + private static final int DEFAULT_MAX_COMPONENTS = 16;, + return heapBuffer(DEFAULT_INITIAL_CAPACITY, Integer.MAX_VALUE);, + return directBuffer(DEFAULT_INITIAL_CAPACITY, Integer.MAX_VALUE);, + return compositeHeapBuffer(DEFAULT_MAX_COMPONENTS);, + return compositeDirectBuffer(DEFAULT_MAX_COMPONENTS);]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/spdy/SpdyHeaderBlockRawDecoder.java, + private static final int LENGTH_FIELD_SIZE = 4;, +, + private int numHeaders = -1;, + public SpdyHeaderBlockRawDecoder(SpdyVersion spdyVersion, int maxHeaderSize) {, + if (spdyVersion == null) {, + throw new NullPointerException("spdyVersion");, + version = spdyVersion.getVersion();, + private static int readLengthField(ByteBuf buffer) {, + int length = getSignedInt(buffer, buffer.readerIndex());, + buffer.skipBytes(LENGTH_FIELD_SIZE);, + if (encoded.readableBytes() < LENGTH_FIELD_SIZE) {, + if (encoded.readableBytes() < LENGTH_FIELD_SIZE) {, + if (encoded.readableBytes() < LENGTH_FIELD_SIZE) {]
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java, + // even => "real" refcount is (refCnt >>> 1); odd => "real" refcount is 0, + @SuppressWarnings("unused"), + private volatile int refCnt = 2;, + private static int realRefCnt(int rawCnt) {, + return (rawCnt & 1) != 0 ? 0 : rawCnt >>> 1;, + }, +, + private int nonVolatileRawCnt() {, + // TODO: Once we compile against later versions of Java we can replace the Unsafe usage here by varhandles., + return REFCNT_FIELD_OFFSET != -1 ? PlatformDependent.getInt(this, REFCNT_FIELD_OFFSET), + : refCntUpdater.get(this);, + }, +, + return realRefCnt(nonVolatileRawCnt());, + return realRefCnt(refCntUpdater.get(this));, + protected final void
[+++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, + keyPassword == null ? StringUtil.EMPTY_STRING : keyPassword);, +++ b/handler/src/main/java/io/netty/handler/ssl/ReferenceCountedOpenSslContext.java, + keyPassword == null ? StringUtil.EMPTY_STRING : keyPassword);, +++ b/pom.xml, + <tcnative.version>1.1.33.Fork20-SNAPSHOT</tcnative.version>]
[+++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java, + *, + * @deprecated Use {@link #wrappedUnmodifiableBuffer(ByteBuf...)}., + @Deprecated, + * The returned {@link ByteBuf} may wrap the provided array directly, and so should not be subsequently modified.]
[+++ b/common/src/main/java/io/netty/util/AsciiString.java, + int start = arrayOffset(), last = arrayOffset() + length() - 1;, +++ b/common/src/main/java/io/netty/util/AsciiString.java, + int start = arrayOffset(), last = arrayOffset() + length() - 1;, +++ b/common/src/test/java/io/netty/util/AsciiStringCharacterTest.java, +, + @Test, + public void testTrim() {, + assertEquals("", AsciiString.EMPTY_STRING.trim().toString());, + assertEquals("abc", new AsciiString(" abc").trim().toString());, + assertEquals("abc", new AsciiString("abc ").trim().toString());, + assertEquals("abc", new AsciiString(" abc ").trim().toString());, + }]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocketServerProtocolHandshakeHandler.java]
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, +import java.util.List;, + * The loopback {@link NetworkInterface} of the current machine, + byte[] LOCALHOST4_BYTES = {127, 0, 0, 1};, + byte[] LOCALHOST6_BYTES = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};, + localhost4 = (Inet4Address) InetAddress.getByAddress(LOCALHOST4_BYTES);, + localhost6 = (Inet6Address) InetAddress.getByAddress(LOCALHOST6_BYTES);, + // Retrieve the list of available network interfaces., + List<NetworkInterface> ifaces = new ArrayList<NetworkInterface>();, + try {, + for (Enumeration<NetworkInterface> i = NetworkInterface.getNetworkInterfaces(); i.hasMoreElements();) {, + NetworkInterface iface = i.nextElement();, + // Use the interface with proper INET addresses only., + if (iface.getInetAddresses().hasMoreElements()) {, + ifaces.add(iface);,
[+++ b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufDecoder.java, +import io.netty.handler.codec.ByteToMessageDecoder;, + * be used with a proper {@link ByteToMessageDecoder} such as {@link ProtobufVarint32FrameDecoder}, + * void messageReceived({@link ChannelHandlerContext} ctx, MyMessage req) {, +++ b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufDecoder.java, +import io.netty.handler.codec.ByteToMessageDecoder;, + * be used with a proper {@link ByteToMessageDecoder} such as {@link ProtobufVarint32FrameDecoder}, + * void messageReceived({@link ChannelHandlerContext} ctx, MyMessage req) {, +++ b/codec/src/main/java/io/netty/handler/codec/protobuf/ProtobufEncoder.java, + * void messageReceived({@link ChannelHandlerContext} ctx, MyMessage req) {]
[+++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, +import io.netty.util.internal.TypeParameterMatcher;, + private final TypeParameterMatcher outboundMsgMatcher;, + outboundMsgMatcher = TypeParameterMatcher.find(this, parameterizedHandlerType, messageTypeParamIndex);, + return outboundMsgMatcher.match(msg);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, +import io.netty.util.internal.TypeParameterMatcher;, + private final TypeParameterMatcher outboundMsgMatcher;, + outboundMsgMatcher = TypeParameterMatcher.find(this, parameterizedHandlerType, messageTypeParamIndex);, + return outboundMsgMatcher.match(msg);, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java, +import io.netty.util.internal.TypeParameterMatcher;, + private final TypeParameterMatcher inboundMsgMatcher;, + private final TypeParameterMatcher outboundMsgMatcher;, + inboundMsgMatcher = TypeParameterMatcher.find(this, MessageToMessageCodec.class, 0);, + outboundMsgMatcher = TypeParameterMatcher.find(this, MessageToMessageCodec.class, 1);, + inboundMsgMatcher = TypeParameterMatcher.find(, + outboundMsgMatcher = TypeParameterMatcher.find(, + return inboundMsgMatcher.match(msg);, + return outboundMsgMatcher.match(msg);, +++ b/codec/src/main/java/io/netty/handler/codec/ByteToMessageCodec.java, +import io.netty.util.internal.TypeParameterMatcher;, + private final TypeParameterMatcher outboundMsgMatcher;, + outboundMsgMatcher = TypeParameterMatcher.find(this, parameterizedHandlerType, messageTypeParamIndex);, + return outboundMsgMatcher.match(msg);, +++ b/codec/src/main/java/io/netty/handler/codec/MessageToMessageCodec.java, +import io.netty.util.internal.TypeParameterMatcher;, +
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + HttpMethod method = msg.method();, + if (HttpMethod.HEAD.equals(method)) {, + } else if (HttpMethod.CONNECT.equals(method)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + HttpMethod method = msg.method();, + if (HttpMethod.HEAD.equals(method)) {, + } else if (HttpMethod.CONNECT.equals(method)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMethod.java, + if (this == o) {, + return true;, + }, + if (o == this) {, + return 0;, + }, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpContentEncoder.java, + HttpMethod method = msg.method();, + if (HttpMethod.HEAD.equals(method)) {, + } else if (HttpMethod.CONNECT.equals(method)) {, +++ b/codec-http/src/main/java/io/netty/handler/codec/http/HttpMethod.java, + if (this == o) {, + return true;, + }, + if (o == this) {, + return 0;, + },
[+++ b/all/pom.xml, + <version>4.1.28.Final</version>, +++ b/all/pom.xml, + <version>4.1.28.Final</version>, +++ b/bom/pom.xml, + <version>4.1.28.Final</version>, + <tag>netty-4.1.28.Final</tag>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, +++ b/all/pom.xml, + <version>4.1.28.Final</version>, +++ b/bom/pom.xml, + <version>4.1.28.Final</version>, + <tag>netty-4.1.28.Final</tag>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, + <version>4.1.28.Final</version>, +
[+++ b/all/pom.xml, + <version>4.1.34.Final</version>, +++ b/all/pom.xml, + <version>4.1.34.Final</version>, +++ b/bom/pom.xml, + <version>4.1.34.Final</version>, + <tag>netty-4.1.34.Final</tag>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, +++ b/all/pom.xml, + <version>4.1.34.Final</version>, +++ b/bom/pom.xml, + <version>4.1.34.Final</version>, + <tag>netty-4.1.34.Final</tag>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, + <version>4.1.34.Final</version>, +
[+++ b/common/src/main/java/io/netty/util/internal/ThreadLocalRandom.java, + * //@since 1.7, + * //@author Doug Lea, + if (initialized) {, + }, + if (least >= bound) {, + }, + if (n <= 0) {, + }, +, + if ((bits & 1) == 0) {, + }, + if (least >= bound) {, + }, + if (n <= 0) {, + }, + if (least >= bound) {, + }]
[+++ b/common/src/main/java/io/netty/util/NetUtil.java, + in = new BufferedReader(new FileReader(file));]
[+++ b/src/docbook/module/preface.xml, + with each other. For example, we often use an HTTP client library to, + retrieve information from a web server and to invoke a remote procedure, + call via web services., + application, media streaming, or large file transfer. You could even, + want to design and implement a whole new protocol which is precisely, + tailored to your need., + <firstterm><ulink url="&Home;">The Netty project</ulink></firstterm> is, + an effort to provide an asynchronous event-driven network application, + framework and tooling for the rapid development of maintainable, + high-performance &middot; high-scalability protocol servers and clients., + programming
[+++ b/all/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/codec/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/common/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/all/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/buffer/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/codec-http/pom.xml, + <version>4.0.10.Final-SNAPSHOT</version>, +++ b/codec-socks/pom.xml, +
[+++ b/common/src/test/resources/logback-test.xml, +<configuration debug="false">, + <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">, + <encoder>, + <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>, + </encoder>, + </appender>, +, + <root level="${logLevel:-info}">, + <appender-ref ref="STDOUT" />, + </root>, +</configuration>, +++ b/common/src/test/resources/logback-test.xml, +<configuration debug="false">, + <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">, + <encoder>, + <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>, + </encoder>, + </appender>, +, + <root level="${logLevel:-info}">, + <appender-ref ref="STDOUT" />, + </root>, +</configuration>, +++ b/pom.xml, + <logging.config>${project.basedir}/../common/src/test/resources/logback-test.xml</logging.config>, + <logging.logLevel>debug</logging.logLevel>, + <systemPropertyVariables>, + <logback.configurationFile>${logging.config}</logback.configurationFile>, + <logLevel>${logging.logLevel}</logLevel>, + </systemPropertyVariables>]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/multipart/DiskFileUpload.java, + return "upload";]
[+++ b/codec-http/src/main/java/io/netty/handler/codec/http/websocketx/WebSocket08FrameDecoder.java, + checkCloseFrameBody(ctx, payloadBuffer);, + Object closeMessage;, + if (receivedClosingHandshake) {, + closeMessage = Unpooled.EMPTY_BUFFER;, + } else {, + closeMessage = new CloseWebSocketFrame(1002, null);, + }, + ctx.writeAndFlush(closeMessage).addListener(ChannelFutureListener.CLOSE);]
[+++ b/pom.xml, + <jboss.marshalling.version>1.3.17.GA</jboss.marshalling.version>, + <version>1.7.4</version>, + <version>4.11</version>, + <version>2.6.0</version>, + <version>1.0.10</version>, + <version>1.2</version>, + <version>3.0</version>, + <compilerArgument>-Xlint:-options</compilerArgument>, + <version>1.9</version>, + <version>2.2.1</version>, + <version>2.9</version>, + <version>2.4</version>, + <version>2.14</version>, + <version>2.14</version>, + <version>2.6</version>, + <version>2.7</version>, + <version>2.4</version>]
[+++ b/src/main/java/org/jboss/netty/buffer/ByteBufferBackedChannelBuffer.java, + this.buffer = buffer.slice().order(buffer.order());, + dst.order(order());, +++ b/src/main/java/org/jboss/netty/buffer/ByteBufferBackedChannelBuffer.java, + this.buffer = buffer.slice().order(buffer.order());, + dst.order(order());, +++ b/src/test/java/org/jboss/netty/buffer/BigEndianDirectChannelBufferTest.java, +/*, + * JBoss, Home of Professional Open Source, + *, + * Copyright 2008, Red Hat Middleware LLC, and individual contributors, + * by the @author tags. See the COPYRIGHT.txt in the distribution for a, + * full listing of individual contributors., + *, + * This is free software; you can redistribute it and/or modify it, + * under the terms of the GNU Lesser General Public License as, + * published by the Free Software Foundation; either version
[+++ b/buffer/src/main/java/io/netty/buffer/AbstractByteBuf.java, + ensureWritable0(minWritableBytes);, + private void ensureWritable0(int minWritableBytes) {, + if (minWritableBytes <= writableBytes()) {, + return;, + }, +, + _setLong(index, 0);, + _setInt(index, 0);, + // Not need to update the index as we not will use it after this., + _setByte(index, (byte) 0);, + _setInt(index, 0);, + _setByte(index, (byte) 0);, + checkReadableBytes0(1);, + byte b = _getByte(i);, + checkReadableBytes0(2);, + checkReadableBytes0(3);, + checkReadableBytes0(4);, + checkReadableBytes0(8);, + ensureWritable0(1);, + ensureWritable0(2);, + ensureWritable0(3);, + ensureWritable0(4);, + ensureWritable0(8);, + int wIndex = writerIndex;, + checkIndex(wIndex, length);, + _setLong(wIndex, 0);, + wIndex += 8;, + _setInt(wIndex, 0);, + wIndex
[+++ b/src/docbook/en-US/module/start.xml, + future.awaitUninterruptibly();<co id="example.time7.co2"/>]
