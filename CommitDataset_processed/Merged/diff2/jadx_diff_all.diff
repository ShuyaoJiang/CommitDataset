[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import java.util.concurrent.ConcurrentHashMap;, + private Map<ClassNode, JavaClass> classesMap = new ConcurrentHashMap<>();, + private Map<MethodNode, JavaMethod> methodsMap = new ConcurrentHashMap<>();, + private Map<FieldNode, JavaField> fieldsMap = new ConcurrentHashMap<>();]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (origType.isGenericType() && !callMth.getParentClass().equals(mth.getParentClass())) {, + // cancel cast, + return false;, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (origType.isGenericType() && !callMth.getParentClass().equals(mth.getParentClass())) {, + // cancel cast, + return false;, + }, +++ b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestSuperInvokeWithGenerics.java, +package jadx.tests.integration.invoke;, +, +import org.junit.jupiter.api.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.hamcrest.MatcherAssert.assertThat;, +import static org.hamcrest.Matchers.anyOf;, +, +public class TestSuperInvokeWithGenerics extends IntegrationTest {, +, + public static class TestCls {, +, + public class A<T extends Exception, V> {, + public A(T t) {, + System.out.println("t" + t);, + }, +, + public A(V v) {, + System.out.println("v" +
[+++ b/jadx-core/src/test/java/jadx/api/InternalJadxTest.java, + protected boolean outputCFG = false;, + protected String outDir = "test-out-tmp";, +, + List<IDexTreeVisitor> passes = Jadx.getPassesList(new DefaultJadxArgs() {, + @Override, + public boolean isCFGOutput() {, + return outputCFG;, + }, +, + @Override, + public boolean isRawCFGOutput() {, + return outputCFG;, + }, + }, new File(outDir));, + fail("Class file not found: " + path);, + fail("Class is not stored in a file.");, + if (in != null) {, +}, +++ b/jadx-core/src/test/java/jadx/api/InternalJadxTest.java, + protected boolean outputCFG = false;, + protected String outDir = "test-out-tmp";, +, + List<IDexTreeVisitor> passes = Jadx.getPassesList(new DefaultJadxArgs() {, + @Override, +
[+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.regions.loops.ForLoop;, + if (type instanceof ForLoop) {, + ForLoop forLoop = (ForLoop) type;, + makeInsn(forLoop.getInitInsn(), code, Flags.INLINE);, + makeInsn(forLoop.getIncrInsn(), code, Flags.INLINE);, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.regions.loops.ForLoop;, + if (type instanceof ForLoop) {, + ForLoop forLoop = (ForLoop) type;, + makeInsn(forLoop.getInitInsn(), code, Flags.INLINE);, + makeInsn(forLoop.getIncrInsn(), code, Flags.INLINE);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, + public static boolean isInstanceOf(ArgType type, ArgType of) {, + if (type.equals(of)) {, + return true;, + }, + if (!type.isObject() || !of.isObject()) {, + return false;, + }, + return clsp.isImplements(type.getObject(), of.getObject());, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.regions.loops.ForLoop;, + if (type instanceof ForLoop) {, + ForLoop forLoop
[+++ b/.travis.yml, + - $HOME/.gradle/caches/, + - $HOME/.gradle/wrapper/, +, +before_cache:, + - rm -f $HOME/.gradle/caches/modules-2/modules-2.lock]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + // 'static' modifier not allowed for top classes (not inner), + if (!cls.getClassInfo().isInner()) {, + af = af.remove(AccessFlags.ACC_STATIC);, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + // 'static' modifier not allowed for top classes (not inner), + if (!cls.getClassInfo().isInner()) {, + af = af.remove(AccessFlags.ACC_STATIC);, + }, +, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +import jadx.api.JadxInternalAccess;, +import jadx.tests.api.compiler.DynamicCompiler;, +import java.lang.reflect.Method;, + protected boolean compile = true;, + private DynamicCompiler dynamicCompiler;, +, + compile(cls);, + void compile(ClassNode cls) {, + if (!compile) {, + return;, + }, + try {, + dynamicCompiler = new DynamicCompiler(cls);, + boolean result = dynamicCompiler.compile();, + assertTrue("Compilation failed on
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfCondition.java, + return fromIfNode((IfNode) header.getInstructions().get(0));, + }, +, + public static IfCondition fromIfNode(IfNode insn) {, + return new IfCondition(new Compare(insn));, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfCondition.java, + return fromIfNode((IfNode) header.getInstructions().get(0));, + }, +, + public static IfCondition fromIfNode(IfNode insn) {, + return new IfCondition(new Compare(insn));, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import jadx.core.dex.instructions.args.RegisterArg;, +import static jadx.core.utils.BlockUtils.getBlockByOffset;, +import static jadx.core.utils.BlockUtils.isPathExists;, +import static jadx.core.utils.BlockUtils.selectOther;, +, + if (isPathExists(loopExit, next)) {, + BlockNode bThen = getBlockByOffset(ifnode.getTarget(), condBlock.getSuccessors());, + BlockNode bElse = selectOther(bThen, condBlock.getSuccessors());, + out = selectOther(loopBody, condBlock.getSuccessors());, + boolean p = isPathExists(exitBlock, node);, + BlockNode bThen = getBlockByOffset(ifnode.getTarget(), block.getSuccessors());, + BlockNode bElse;, + if (block.getSuccessors().size() == 1) {,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.attributes.FieldReplaceAttr;, + if (fieldNode != null) {, + FieldReplaceAttr replace = (FieldReplaceAttr) fieldNode.getAttributes().get(AttributeType.FIELD_REPLACE);, + if (replace != null) {, + FieldInfo info = replace.getFieldInfo();, + if (replace.isOuterClass()) {, + code.add(useClass(info.getDeclClass())).add(".this");, + }, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.attributes.FieldReplaceAttr;, + if (fieldNode != null) {, + FieldReplaceAttr replace = (FieldReplaceAttr) fieldNode.getAttributes().get(AttributeType.FIELD_REPLACE);, + if (replace != null) {, + FieldInfo info = replace.getFieldInfo();, + if (replace.isOuterClass()) {, + code.add(useClass(info.getDeclClass())).add(".this");, + }, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeType.java, + FIELD_REPLACE(true),, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.attributes.FieldReplaceAttr;, + if (fieldNode != null) {, + FieldReplaceAttr replace = (FieldReplaceAttr) fieldNode.getAttributes().get(AttributeType.FIELD_REPLACE);, + if (replace != null)
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, + FALL_THROUGH,, +, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, + FALL_THROUGH,, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import java.util.Collections;, +import java.util.Comparator;, + Map<BlockNode, BlockNode> fallThroughCases = new LinkedHashMap<BlockNode, BlockNode>();, +, + BitSet df = s.getDomFrontier();, + // fall through case block, + if (df.cardinality() > 1) {, + if (df.cardinality() > 2) {, + LOG.debug("Unexpected case pattern, block: {}, mth: {}", s, mth);, + } else {, + BlockNode first = mth.getBasicBlocks().get(df.nextSetBit(0));, + BlockNode second = mth.getBasicBlocks().get(df.nextSetBit(first.getId() + 1));, + if (second.getDomFrontier().get(first.getId())) {, + fallThroughCases.put(s, second);, + df = new BitSet(df.size());, + df.set(first.getId());, + } else if (first.getDomFrontier().get(second.getId())) {, + fallThroughCases.put(s, first);, + df
[+++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +import jadx.core.dex.visitors.DepthTraversal;, + DepthTraversal.visit(visitor, cls);, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +import jadx.core.dex.visitors.DepthTraversal;, + DepthTraversal.visit(visitor, cls);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.dex.visitors.DepthTraversal;, + DepthTraversal.visit(new FallbackModeVisitor(), mth);, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +import jadx.core.dex.visitors.DepthTraversal;, + DepthTraversal.visit(visitor, cls);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.dex.visitors.DepthTraversal;, + DepthTraversal.visit(new FallbackModeVisitor(), mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DepthTraversal.java, +package jadx.core.dex.visitors;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.MethodNode;, +import jadx.core.utils.ErrorsCounter;, +, +public class DepthTraversal {, +, + public static void visit(IDexTreeVisitor visitor, ClassNode cls) {, + try {, + if (visitor.visit(cls)) {, + for (ClassNode inCls : cls.getInnerClasses()) {, + visit(visitor, inCls);, + }, + for (MethodNode mth : cls.getMethods()) {, + visit(visitor, mth);, + }, + }, + } catch
[+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JCertificate.java, +package jadx.gui.treemodel;, +import jadx.api.ResourceFile;, +import jadx.core.utils.files.ZipSecurity;, +import jadx.gui.utils.CertificateManager;, +import jadx.gui.utils.NLS;, +import jadx.gui.utils.Utils;, +import javax.swing.*;, +import java.io.*;, +import java.util.zip.ZipEntry;, +import java.util.zip.ZipFile;, +, +public class JCertificate extends JNode {, +, + private static final ImageIcon CERTIFICATE_ICON = Utils.openIcon("certificate_obj");, + private final transient ResourceFile rf;, +, + public JCertificate(ResourceFile resFile) {, + this.rf = resFile;, + }, +, + @Override, + public JClass getJParent() {, + return null;, + }, +, + @Override, + public Icon getIcon() {, + return CERTIFICATE_ICON;, + }, +, + @Override, + public String makeString() {, + return NLS.str("certificate.title");, + }, +, + @Override, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java, +import jadx.core.dex.nodes.parser.FieldInitAttr;, +, + // process instructions from field init, + FieldInitAttr fieldInitAttr = fieldNode.get(AType.FIELD_INIT);, + if (fieldInitAttr != null && fieldInitAttr.getValueType() == FieldInitAttr.InitType.INSN) {, + processInsn(dex, depList, fieldInitAttr.getInsn());, + }]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, + super(ArgType.OBJECT.getObject());, + && bounds == ((WildcardType) obj).bounds, + && type.equals(((WildcardType) obj).type);, + return "? " + (bounds == -1 ? "super" : "extends") + " " + type.toString();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, + super(ArgType.OBJECT.getObject());, + && bounds == ((WildcardType) obj).bounds, + && type.equals(((WildcardType) obj).type);, + return "? " + (bounds == -1 ? "super" : "extends") + " " + type.toString();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java, + end = sign.length();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, + super(ArgType.OBJECT.getObject());, + && bounds == ((WildcardType) obj).bounds, + && type.equals(((WildcardType) obj).type);, + return "? " + (bounds == -1 ? "super" : "extends") + " " + type.toString();,
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, + public ConstructorInsn(MethodInfo callMth, CallType callType, RegisterArg instanceArg) {, + super(InsnType.CONSTRUCTOR, callMth.getArgsCount());, + this.callMth = callMth;, + this.callType = callType;, + this.instanceArg = instanceArg;, + }, +, + public CallType getCallType() {, + return callType;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, + public ConstructorInsn(MethodInfo callMth, CallType callType, RegisterArg instanceArg) {, + super(InsnType.CONSTRUCTOR, callMth.getArgsCount());, + this.callMth = callMth;, + this.callType = callType;, + this.instanceArg = instanceArg;, + }, +, + public CallType getCallType() {, + return callType;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +import jadx.core.codegen.TypeGen;, + ConstructorInsn replace = processConstructor(mth, co);, + if (replace != null) {, + replaceInsn(block, insnNumber,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.dex.nodes.DexNode;, + String baseClass = useClassInternal(cls.getClassInfo(), classInfo);, + private String useClassInternal(ClassInfo useCls, ClassInfo classInfo) {, + if (parentGen != null) {, + return parentGen.useClassInternal(useCls, classInfo);, + }, + if (fallback) {, + }, + if (isClassInnerFor(classInfo, useCls)) {, + }, + if (classInfo.getPackage().equals(useCls.getPackage()) && !classInfo.isInner()) {, + }, + if (classInfo.getPackage().equals(useCls.getPackage())) {, + clsStr = classInfo.getNameWithoutPackage();, + }, + if (searchCollision(cls.dex(), useCls, shortName)) {, + return clsStr;, + }, + if (cls.getShortName().equals(shortName)) {, + }, + private static boolean isClassInnerFor(ClassInfo inner, ClassInfo parent) {, + return p.equals(parent) || isClassInnerFor(p, parent);, + private static boolean searchCollision(DexNode dex,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.utils.ErrorsCounter;, + if (cls.contains(AFlag.DONT_GENERATE)) {, + code.add("/* anonymous class already generated */");, + ErrorsCounter.methodError(mth, "Anonymous class already generated: " + cls);, + return;, + }, + InsnNode inlCopy = inl.copy();, + inlCopy.getRegisterArgs(inlArgs);, + inlCopy.replaceArg(r, repl);, + makeInsn(inlCopy, code, Flags.BODY_ONLY);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.utils.ErrorsCounter;, + if (cls.contains(AFlag.DONT_GENERATE)) {, + code.add("/* anonymous class already generated */");, + ErrorsCounter.methodError(mth, "Anonymous class already generated: " + cls);, + return;, + }, + InsnNode inlCopy = inl.copy();, + inlCopy.getRegisterArgs(inlArgs);, + inlCopy.replaceArg(r, repl);, + makeInsn(inlCopy, code, Flags.BODY_ONLY);, +++ b/jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java, + public static String classError(ClassNode cls, String errorMsg) {, + return classError(cls, errorMsg,
[+++ b/jadx-gui/src/main/resources/i18n/Messages_zh_CN.properties, +menu.file=文件, +menu.view=视图, +menu.recent_files=最近打开文件, +menu.no_recent_files=无最近打开文件, +menu.preferences=偏好, +menu.sync=同步, +menu.flatten=Show flatten packages, +menu.navigation=导航, +menu.text_search=搜索文字, +menu.class_search=搜索类, +menu.tools=工具, +menu.log=日志查看器, +menu.help=帮助, +menu.about=关于, +menu.update_label=发现新版本 %s !, +, +file.open=打开文件, +file.save_all=保存全部, +file.export_gradle=另存为 gradle project, +file.save_all_msg=选择反编译资源路径, +file.select=选择, +file.exit=退出, +, +tree.loading=稍等..., +, +search=搜索, +search.previous=预览, +search.next=下一个, +search.mark_all=标记全部, +search.regex=正则表达式, +search.match_case=区分大小写, +search.whole_word=整个词语, +search.find=查询, +, +tabs.close=关闭, +tabs.closeOthers=关闭其他, +tabs.closeAll=关闭全部, +, +nav.back=后退, +nav.forward=向前, +, +search_dialog.open=打开, +search_dialog.cancel=取消, +search_dialog.open_by_name=搜索文本\:, +search_dialog.search_in=Search definitions of \:, +search_dialog.class=类, +search_dialog.method=方法, +search_dialog.field=变量, +search_dialog.code=代码, +, +usage_dialog.title=使用搜索 , +usage_dialog.label=Usage for:, +, +preferences.title=偏好, +preferences.deobfuscation=Deobfuscation, +preferences.editor=编辑, +preferences.decompile=反编译, +preferences.other=其他, +preferences.check_for_updates=启动时检查更新, +preferences.fallback=Fallback mode (simple dump), +preferences.showInconsistentCode=显示不一致的代码, +preferences.escapeUnicode=Unicode转义, +preferences.replaceConsts=替换常量, +preferences.skipResourcesDecode=Don't decode resources, +preferences.threads=Processing threads count, +preferences.cfg=Generate methods CFG graphs (in 'dot' format), +preferences.raw_cfg=Generate RAW CFG graphs, +preferences.font=编辑器字体, +preferences.start_jobs=自动开启后台反编译, +preferences.select_font=选择,
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, + makeClsAlias(cls);, + public String getClsAlias(ClassNode cls) {, + DeobfClsInfo deobfClsInfo = clsMap.get(cls.getClassInfo());, + if (deobfClsInfo != null) {, + return deobfClsInfo.getAlias();, + }, + return makeClsAlias(cls);, + }, +, + ClassInfo classInfo = cls.getClassInfo();, + String clsName = classInfo.getShortName();, + String alias = String.format("C%04d%s", clsIndex++, makeName(clsName));, +, + PackageNode pkg = getPackageNode(classInfo.getPackage(), true);, + clsMap.put(classInfo, new DeobfClsInfo(this, cls, pkg, alias));, + return alias;, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, + makeClsAlias(cls);, + public String getClsAlias(ClassNode cls) {, + DeobfClsInfo deobfClsInfo = clsMap.get(cls.getClassInfo());, + if (deobfClsInfo != null) {, + return deobfClsInfo.getAlias();, + }, + return makeClsAlias(cls);, + }, +, +
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (cls != null && cls.isAnonymous() && !fallback) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (cls != null && cls.isAnonymous() && !fallback) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/LiveVarAnalysis.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (cls != null && cls.isAnonymous() && !fallback) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/LiveVarAnalysis.java, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java, + private static void process(MethodNode mth) {, + int regsCount = mth.getRegsCount();, + for (int i = 0; i < regsCount; i++) {, + private static void placePhi(MethodNode mth, int regNum, LiveVarAnalysis la) {, + private static void addPhi(BlockNode block, int regNum) {, + private static void renameVariables(MethodNode mth) {, + private static void renameVar(MethodNode mth, SSAVar[]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ArithOp.java, + public boolean noWrapWith(ArithOp other) {, + return (this == ADD && other == ADD), + || (this == MUL && other == MUL), + || (this == AND && other == AND), + || (this == OR && other == OR);, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ArithOp.java, + public boolean noWrapWith(ArithOp other) {, + return (this == ADD && other == ADD), + || (this == MUL && other == MUL), + || (this == AND && other == AND), + || (this == OR && other == OR);, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +import jadx.core.dex.instructions.ArithNode;, +import jadx.core.dex.instructions.InsnType;, +,
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, +import jadx.core.utils.InstructionRemover;, + InstructionRemover remover = new InstructionRemover(block.getInstructions());, + for (InsnNode insn : block.getInstructions()) {, + remover.add(insn);, + remover.perform();, + int assignCount = 0;, + assignCount++;, + return replaceCount == use.size() - assignCount;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, +import jadx.core.utils.InstructionRemover;, + InstructionRemover remover = new InstructionRemover(block.getInstructions());, + for (InsnNode insn : block.getInstructions()) {, + remover.add(insn);, + remover.perform();, + int assignCount = 0;, + assignCount++;, + return replaceCount == use.size() - assignCount;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessReturnInsns.java, +import jadx.core.dex.regions.IfRegion;, +import jadx.core.dex.regions.SwitchRegion;, + // ignore paths on other branches, + if (region instanceof IfRegion, + || region instanceof SwitchRegion) {, + curContainer = region;, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +import jadx.core.dex.attributes.AttributeType;, +import jadx.core.dex.info.FieldInfo;, +import jadx.core.dex.instructions.IndexInsnNode;, +import jadx.core.dex.nodes.DexNode;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.parser.FieldValueAttr;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, + private static final Logger LOG = LoggerFactory.getLogger(RegisterArg.class);, +, + public Object getConstValue(DexNode dex) {, + case SGET:, + FieldInfo f = (FieldInfo) ((IndexInsnNode) parInsn).getIndex();, + FieldNode fieldNode = dex.resolveField(f);, + if (fieldNode != null) {, + FieldValueAttr attr = (FieldValueAttr) fieldNode.getAttributes().get(AttributeType.FIELD_VALUE);, + if (attr != null) {, + return attr.getValue();, + }, + } else {, + LOG.warn("Field {} not found in dex {}", f, dex);, + }, + break;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +import jadx.core.dex.attributes.AttributeType;, +import jadx.core.dex.info.FieldInfo;, +import jadx.core.dex.instructions.IndexInsnNode;, +import
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, + DepthRegionTraversal.traverse(mth, new AbstractRegionVisitor() {, + DepthRegionTraversal.traverse(mth, new TracedRegionVisitor() {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, + DepthRegionTraversal.traverse(mth, new AbstractRegionVisitor() {, + DepthRegionTraversal.traverse(mth, new TracedRegionVisitor() {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CleanRegions.java, + DepthRegionTraversal.traverse(mth, removeEmptyBlocks);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, + DepthRegionTraversal.traverse(mth, new AbstractRegionVisitor() {, + DepthRegionTraversal.traverse(mth, new TracedRegionVisitor() {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CleanRegions.java, + DepthRegionTraversal.traverse(mth, removeEmptyBlocks);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/DepthRegionTraversal.java, + public static void traverseIncludingExcHandlers(MethodNode mth, IRegionVisitor visitor) {, + public static void traverseIterative(MethodNode mth, IRegionIterativeVisitor visitor) {, + repeat = traverseIterativeInternal(mth, visitor, mth.getRegion());, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, + DepthRegionTraversal.traverse(mth, new AbstractRegionVisitor() {, + DepthRegionTraversal.traverse(mth, new TracedRegionVisitor() {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CleanRegions.java, + DepthRegionTraversal.traverse(mth, removeEmptyBlocks);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/DepthRegionTraversal.java, + public static void traverseIncludingExcHandlers(MethodNode mth, IRegionVisitor visitor)
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfInfo.java, + private BlockNode outBlock;, + public BlockNode getOutBlock() {, + return outBlock;, + }, +, + public void setOutBlock(BlockNode outBlock) {, + this.outBlock = outBlock;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfInfo.java, + private BlockNode outBlock;, + public BlockNode getOutBlock() {, + return outBlock;, + }, +, + public void setOutBlock(BlockNode outBlock) {, + this.outBlock = outBlock;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/LoopRegion.java, + if (body != null) {, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfInfo.java, + private BlockNode outBlock;, + public BlockNode getOutBlock() {, + return outBlock;, + }, +, + public void setOutBlock(BlockNode outBlock) {, + this.outBlock = outBlock;, + },
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java, + if (getProjectPath() != null) {, + }]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, + currentTag = deobfClassName(getString(startNSName));, + currentTag = getValidTagAttributeName(currentTag);, + String elemName = deobfClassName(getString(elementNameId));, + elemName = getValidTagAttributeName(elemName);]
[+++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, + public boolean isSet() {, + return line != 0 || offset != 0;, + }, +, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, + public boolean isSet() {, + return line != 0 || offset != 0;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, + classGen.useType(code, a.getType());, + classGen.useType(code, ex);, + classGen.useType(code, (ArgType) val);, + code.add(".class");, + InsnGen.makeStaticFieldAccess(code, field, classGen);, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, + public boolean isSet() {, + return line != 0 || offset != 0;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, + classGen.useType(code, a.getType());, + classGen.useType(code, ex);, + classGen.useType(code, (ArgType) val);, + code.add(".class");, + InsnGen.makeStaticFieldAccess(code, field, classGen);, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.dex.instructions.args.PrimitiveType;, + clsCode.add("extends
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +, + if (args.isCFGOutput()) {, + passes.add(new DotGraphVisitor(outDir, false));, + }, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +, + if (args.isCFGOutput()) {, + passes.add(new DotGraphVisitor(outDir, false));, + }, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +, + if (args.isCFGOutput()) {, + passes.add(new DotGraphVisitor(outDir, false));, + }, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, + public boolean isNameEquals(InsnArg arg) {, + if (name == null || !(arg instanceof Named)) {, + return false;, + }, + return name.equals(((Named) arg).getName());, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +, + if (args.isCFGOutput()) {, + passes.add(new DotGraphVisitor(outDir, false));, + }, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, + public boolean isNameEquals(InsnArg arg) {, + if (name
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, + public static JadxSettings makeDefault() {, + JadxSettings jadxSettings = new JadxSettings();, + jadxSettings.fixOnLoad();, + return jadxSettings;, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, + public static JadxSettings makeDefault() {, + JadxSettings jadxSettings = new JadxSettings();, + jadxSettings.fixOnLoad();, + return jadxSettings;, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java, + settings = JadxSettings.makeDefault();, + } else {, + }, + if (LOG.isDebugEnabled()) {, + }, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, + public static JadxSettings makeDefault() {, + JadxSettings jadxSettings = new JadxSettings();, + jadxSettings.fixOnLoad();, + return jadxSettings;, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java, + settings = JadxSettings.makeDefault();, + } else {, + }, + if (LOG.isDebugEnabled()) {, + }, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +import jadx.gui.ui.codearea.EditorTheme;, + String
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.dex.instructions.InvokeNode;, +import jadx.core.dex.instructions.args.InsnWrapArg;, + cls.getMethods().forEach(mth -> removeSyntheticMethods(cls, mth));, + cls.getMethods().forEach(ClassModifier::removeEmptyMethods);, + private static void removeSyntheticMethods(ClassNode cls, MethodNode mth) {, + return;, + if (!af.isSynthetic()) {, + return;, + }, + if (removeBridgeMethod(cls, mth)) {, + return;, + }, + if (af.isConstructor() && mth.getBasicBlocks().size() == 2) {, + private static boolean removeBridgeMethod(ClassNode cls, MethodNode mth) {, + List<InsnNode> allInsns = BlockUtils.collectAllInsns(mth.getBasicBlocks());, + if (allInsns.size() == 1) {, + InsnNode wrappedInsn = allInsns.get(0);, + if (wrappedInsn.getType() == InsnType.RETURN) {, + InsnArg arg = wrappedInsn.getArg(0);, + if (arg.isInsnWrap()) {, + wrappedInsn = ((InsnWrapArg) arg).getWrapInsn();, + }, + }, +
[+++ b/.DS_Store, +++ b/.DS_Store, +++ b/README.md, +, +++ b/.DS_Store, +++ b/README.md, +, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +import java.util.ArrayList;, +import java.util.Enumeration;, +import java.util.List;, +import java.util.zip.ZipEntry;, +import java.util.zip.ZipFile;, +, + public static String bytesToHex(byte[] bytes) {, + char[] hexArray = "0123456789abcdef".toCharArray();, + if (bytes == null || bytes.length <= 0) {, + return null;, + }, + char[] hexChars = new char[bytes.length * 2];, + for ( int j = 0; j < bytes.length; j++ ) {, + int v = bytes[j] & 0xFF;, + hexChars[j * 2] = hexArray[v >>> 4];, + hexChars[j * 2 + 1] = hexArray[v & 0x0F];, +
[+++ b/jadx-gui/src/main/java/jadx/gui/utils/JumpManager.java, + if (currentPos >= 0 && currentPos < list.size()) {, + int size = list.size();, + if (size == 0) {, + currentPos = 0;, + return null;, + }, + if (newPos >= size) {, + currentPos = size - 1;, +++ b/jadx-gui/src/main/java/jadx/gui/utils/JumpManager.java, + if (currentPos >= 0 && currentPos < list.size()) {, + int size = list.size();, + if (size == 0) {, + currentPos = 0;, + return null;, + }, + if (newPos >= size) {, + currentPos = size - 1;, +++ b/jadx-gui/src/test/groovy/jadx/gui/tests/TestJumpManager.groovy, + def "empty history 2"() {, + expect:, +
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, + int result = 0;, + result = processAndSave(jadxArgs);, + result = 1;, + } finally {, + System.exit(result);, + static int processAndSave(JadxCLIArgs inputArgs) {, + return 1;, + int errorsCount = jadx.getErrorsCount();, + if (errorsCount != 0) {, + return errorsCount;, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, + int result = 0;, + result = processAndSave(jadxArgs);, + result = 1;, + } finally {, + System.exit(result);, + static int processAndSave(JadxCLIArgs inputArgs) {, + return 1;, + int errorsCount = jadx.getErrorsCount();, + if (errorsCount != 0) {, + return errorsCount;, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + public int getWarnsCount() {, + if (root ==
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.EmptyBitSet;, + private BitSet doms = EmptyBitSet.EMPTY;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.EmptyBitSet;, + private BitSet doms = EmptyBitSet.EMPTY;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + int argsCount = list.size();, + for (int i = 0; i < argsCount; i++) {, + throw new JadxRuntimeException("Incorrect register number in instruction: " + insnNode, + + ", expected to be less than " + regsCount);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.EmptyBitSet;, + private BitSet doms = EmptyBitSet.EMPTY;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + int argsCount = list.size();, + for (int i = 0; i < argsCount; i++) {, + throw new JadxRuntimeException("Incorrect register number in instruction: " + insnNode,
[+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, + return invoke(method, new Class<?>[0]);, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, + return invoke(method, new Class<?>[0]);, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, + private final Map<String, Class<?>> clsCache = new HashMap<String, Class<?>>();, + Class<?> cacheCls = clsCache.get(name);, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, + return invoke(method, new Class<?>[0]);, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, + private final Map<String, Class<?>> clsCache = new HashMap<String, Class<?>>();, + Class<?> cacheCls = clsCache.get(name);, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/DynamicCompiler.java, + for (Class<?> type : types) {, + private Class<?> checkType(Class<?> type) throws ClassNotFoundException {, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, + return invoke(method, new Class<?>[0]);, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, + private final Map<String, Class<?>> clsCache = new HashMap<String, Class<?>>();, + Class<?> cacheCls = clsCache.get(name);, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/DynamicCompiler.java, +
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.ReturnVisitor;, + passes.add(new ReturnVisitor());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.ReturnVisitor;, + passes.add(new ReturnVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, + if (!els.contains(AFlag.ELSE_IF_CHAIN)) {, + return false;, + }, + if (!(els instanceof Region)) {, + return false;, + }, + List<IContainer> subBlocks = ((Region) els).getSubBlocks();, + if (subBlocks.size() == 1, + && subBlocks.get(0) instanceof IfRegion) {, + makeIf((IfRegion) subBlocks.get(0), code, false);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.ReturnVisitor;, + passes.add(new ReturnVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, + if (!els.contains(AFlag.ELSE_IF_CHAIN)) {, + return false;, + }, + if (!(els instanceof Region)) {, + return false;, + }, + List<IContainer> subBlocks = ((Region) els).getSubBlocks();, + if (subBlocks.size() == 1, +
[+++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, + private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());]
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, + if (methodInfo.isClassInit() || methodInfo.isConstructor()) {, + return null;, + }]
[+++ b/build.gradle, +apply plugin: 'java', +apply plugin: 'application', +, +apply plugin: 'eclipse', +apply plugin: 'idea', +, +sourceCompatibility = 1.6, +targetCompatibility = 1.6, +, +version = 'dev', +, +mainClassName = "jadx.Main", +, +project.ext {, + mainSamplesClass = "jadx.samples.RunTests" , + samplesJadxSrcDir = "${buildDir}/samples-jadx/src", +}, +, +dependencies {, + compile 'com.google.android.tools:dx:1.7', + compile 'com.beust:jcommander:1.30', + compile 'org.slf4j:slf4j-api:1.6.6', + compile 'ch.qos.logback:logback-classic:1.0.9', + testCompile 'junit:junit:4.8.2', +}, +, +repositories {, + mavenCentral(), +}, +, +sourceSets {, + samples, + //TODO don't add to eclipse classpath, + samplesJadx {, + java {, + srcDir samplesJadxSrcDir, + output.classesDir "${buildDir}/samples-jadx/output", + }, + }, +}, +, +task
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.xmlgen.BinaryXMLParser;, + BinaryXMLParser bxp = new BinaryXMLParser(args[0],args[1]);, + bxp.parse();, + System.exit(4);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.xmlgen.BinaryXMLParser;, + BinaryXMLParser bxp = new BinaryXMLParser(args[0],args[1]);, + bxp.parse();, + System.exit(4);, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + public void parseAndSaveXML() {, + if (this.args.isXMLTest()) {, + InputFile inf = inputFiles.get(0);, + try {, + byte[] buffer = InputFile.loadXMLBuffer(inf.getFile());, + if (buffer != null) {, + File out = new File(outDir, "AndroidManifest.xml");, + BinaryXMLParser bxp = new BinaryXMLParser(root);, + bxp.parse(buffer, out);, + }, + } catch (Exception e) {, + LOG.info("Decompiling AndroidManifest.xml failed!", e);, + }, + }, + }, +, + parseAndSaveXML();, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + public void parseAndSaveXML() {, + if (this.args.isXMLTest()) {, + InputFile inf = inputFiles.get(0);, + try {, + byte[] buffer = InputFile.loadXMLBuffer(inf.getFile());, + if (buffer != null) {,
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, + }, + if (srcDir == null) {, + args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, + }, + if (resDir == null) {, + args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, + }, + checkDir(args.getOutDir(), "Output");, + checkDir(args.getOutDirSrc(), "Source output");, + checkDir(args.getOutDirRes(), "Resources output");, + private static void checkDir(File dir, String desc) {, + throw new JadxArgsValidateException(desc + " directory exists as file " + dir);, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, + }, + if (srcDir == null) {, + args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, + }, + if (resDir == null)
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, + }, + if (j2d.isError()) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, + }, + if (j2d.isError()) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/JavaToDex.java, +import java.lang.reflect.Field;, +, + debug = true;, + resetOutDexVar();, + private void resetOutDexVar() throws JadxException {, + try {, + Field outputDex = Main.class.getDeclaredField("outputDex");, + outputDex.setAccessible(true);, + outputDex.set(null, null);, + } catch (Exception e) {, + throw new JadxException("Failed to reset outputDex field", e);, + }, + }, +, + return dxErrors != null && !dxErrors.isEmpty();]
[+++ b/jadx-gui/build.gradle, + compile 'com.fifesoft:rsyntaxtextarea:2.5.4', +++ b/jadx-gui/build.gradle, + compile 'com.fifesoft:rsyntaxtextarea:2.5.4', +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +import jadx.gui.update.JadxUpdate.IUpdateCallback;, + checkForUpdate();, + }, +, + private void checkForUpdate() {, + // TODO: add option for disable update checks, + JadxUpdate.check(new IUpdateCallback() {, +++ b/jadx-gui/build.gradle, + compile 'com.fifesoft:rsyntaxtextarea:2.5.4', +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +import jadx.gui.update.JadxUpdate.IUpdateCallback;, + checkForUpdate();, + }, +, + private void checkForUpdate() {, + // TODO: add option for disable update checks, + JadxUpdate.check(new IUpdateCallback() {, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchBar.java, +import org.fife.ui.rtextarea.SearchResult;, + context.setMarkAll(markAllCB.isSelected());, + SearchResult result = SearchEngine.find(rTextArea, context);, + if (!result.wasFound()) {, +++ b/jadx-gui/build.gradle, + compile 'com.fifesoft:rsyntaxtextarea:2.5.4', +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +import jadx.gui.update.JadxUpdate.IUpdateCallback;, + checkForUpdate();, + }, +,
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java, +import java.util.Locale;, + return floatToString(Float.intBitsToFloat(data));, + NumberFormat f = NumberFormat.getInstance(Locale.ROOT);, + private static String floatToString(float value) {, + return doubleToString((double) value);, + }, +]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.codegen.CodeGen;, + private CodeGen codeGen;, +, + this.codeGen = new CodeGen(args);, + ProcessClass.process(cls, passes, codeGen);, + public IJadxArgs getArgs() {, + return args;, + }, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.codegen.CodeGen;, + private CodeGen codeGen;, +, + this.codeGen = new CodeGen(args);, + ProcessClass.process(cls, passes, codeGen);, + public IJadxArgs getArgs() {, + return args;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DependencyCollector;, +, + passes.add(new DependencyCollector());, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.codegen.CodeGen;, + private CodeGen codeGen;, +, + this.codeGen = new CodeGen(args);, + ProcessClass.process(cls, passes, codeGen);, + public IJadxArgs getArgs() {, + return args;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DependencyCollector;,
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + try {, + } catch (Exception e) {, + LOG.error("Error saving class: {}", cls.getFullName(), e);, + }, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + try {, + } catch (Exception e) {, + LOG.error("Error saving class: {}", cls.getFullName(), e);, + }, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, + public synchronized void unload() {, + cls.unload();, + }, +, + mths.sort(Comparator.comparing(JavaMethod::getName));, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + try {, + } catch (Exception e) {, + LOG.error("Error saving class: {}", cls.getFullName(), e);, + }, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, + public synchronized void unload() {, + cls.unload();, + }, +, + mths.sort(Comparator.comparing(JavaMethod::getName));, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + try {, + }
[+++ b/.gitmodules, +[submodule "jadx-test-app/test-app"], + path = jadx-test-app/test-app, + url = git://github.com/skylot/jadx-test-app.git, +++ b/.gitmodules, +[submodule "jadx-test-app/test-app"], + path = jadx-test-app/test-app, + url = git://github.com/skylot/jadx-test-app.git, +++ b/build.gradle, +task testAppCheck(dependsOn: 'jadx-test-app:testAppCheck') {, +}, +, +++ b/.gitmodules, +[submodule "jadx-test-app/test-app"], + path = jadx-test-app/test-app, + url = git://github.com/skylot/jadx-test-app.git, +++ b/build.gradle, +task testAppCheck(dependsOn: 'jadx-test-app:testAppCheck') {, +}, +, +++ b/jadx-test-app/README.md, +### Run jadx on test android application, +, +This module contains build scripts for test recompilation of simple android app from:, +https://github.com/skylot/jadx-test-app, +, +For run tests type follow commands in jadx root directory:, +, +```java, +git submodule init, +git submodule update, +./gradlew testAppCheck, +```, +,
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, + public static void main(String[] args) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, + public static void main(String[] args) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + protected static final int DEFAULT_THREADS_COUNT = Math.max(1, Runtime.getRuntime().availableProcessors() / 2);, +, + protected int threadsCount = DEFAULT_THREADS_COUNT;, + throw new JadxException("Threads count must be positive, got: " + threadsCount);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, + public static void main(String[] args) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + protected static final int DEFAULT_THREADS_COUNT = Math.max(1, Runtime.getRuntime().availableProcessors() / 2);, +, + protected int threadsCount = DEFAULT_THREADS_COUNT;, + throw new JadxException("Threads count must be positive, got: " + threadsCount);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, + public void fixOnLoad() {, +
[+++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, + opt.append(" (default: ").append(val).append(')');, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, + opt.append(" (default: ").append(val).append(')');, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, + return line + ':' + offset + (node != null ? " " + node : "");, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, + opt.append(" (default: ").append(val).append(')');, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, + return line + ':' + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, + outDirName = name + '-' + JadxArgs.DEFAULT_OUT_DIR;, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, + opt.append(" (default: ").append(val).append(')');, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, + return line + ':' + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, + outDirName =
[+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + arg.getSVar().setVariableName(name);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + arg.getSVar().setVariableName(name);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, + public void setVariableName(String name) {, + setName(name);, + if (isUsedInPhi()) {, + PhiInsn phi = getUsedInPhi();, + phi.getResult().getSVar().setVariableName(name);, + for (InsnArg arg : phi.getArguments()) {, + if (arg.isRegister()) {, + RegisterArg reg = (RegisterArg) arg;, + SSAVar sVar = reg.getSVar();, + if (sVar != this && !name.equals(reg.getName())) {, + sVar.setVariableName(name);, + }, + }, + }, + }, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + arg.getSVar().setVariableName(name);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, + public void setVariableName(String name) {, + setName(name);, + if (isUsedInPhi()) {, + PhiInsn phi = getUsedInPhi();, + phi.getResult().getSVar().setVariableName(name);, + for
[+++ b/jadx-gui/src/main/java/jadx/gui/utils/CertificateManager.java, + StringBuilder buf = new StringBuilder(bytes.length * 3);]
[+++ b/jadx-gui/src/main/java/jadx/gui/utils/search/TextSearchIndex.java, + int lineLength = line.length();, + if (lineLength == 0 || (lineLength == 1 && line.charAt(0) == '}')) {, + continue;, + }]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + ClassNode pCls = mth.getParentClass();, + FieldNode fieldNode = pCls.searchField(field);, +, + while ((fieldNode == null) , + && (pCls.getParentClass() != pCls) && (pCls.getParentClass() != null)), + {, + pCls = pCls.getParentClass();, + fieldNode = pCls.searchField(field);, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + ClassNode pCls = mth.getParentClass();, + FieldNode fieldNode = pCls.searchField(field);, +, + while ((fieldNode == null) , + && (pCls.getParentClass() != pCls) && (pCls.getParentClass() != null)), + {, + pCls = pCls.getParentClass();, + fieldNode = pCls.searchField(field);, + }, +++ b/jadx-samples/src/main/java/jadx/samples/TestInner3.java, +package jadx.samples;, +, +public class TestInner3 extends AbstractTest {, +, + private String i0;, +, + public
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + // remove INFO ThresholdFilter, + rootLogger.getAppender("STDOUT").clearAllFilters();, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + // remove INFO ThresholdFilter, + rootLogger.getAppender("STDOUT").clearAllFilters();, +++ b/jadx-cli/src/main/resources/logback.xml, + <filter class="ch.qos.logback.classic.filter.ThresholdFilter">, + <level>INFO</level>, + </filter>, + <root level="DEBUG">, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + // remove INFO ThresholdFilter, + rootLogger.getAppender("STDOUT").clearAllFilters();, +++ b/jadx-cli/src/main/resources/logback.xml, + <filter class="ch.qos.logback.classic.filter.ThresholdFilter">, + <level>INFO</level>, + </filter>, + <root level="DEBUG">, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.utils.LogCollector;, + LogCollector.register();, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + // remove INFO ThresholdFilter, + rootLogger.getAppender("STDOUT").clearAllFilters();, +++ b/jadx-cli/src/main/resources/logback.xml, + <filter class="ch.qos.logback.classic.filter.ThresholdFilter">, + <level>INFO</level>, + </filter>, + <root level="DEBUG">, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.utils.LogCollector;, + LogCollector.register();, +++ b/jadx-gui/src/main/java/jadx/gui/ui/LogViewer.java, +package jadx.gui.ui;, +, +import ch.qos.logback.classic.Level;, +import jadx.gui.utils.LogCollector;, +import jadx.gui.utils.NLS;, +, +import javax.swing.BorderFactory;, +import
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + } else if (field.getDeclClass().getFullName().startsWith(mth.getParentClass().getPackage() + ".R")) {, + return field.getDeclClass().getNameWithoutPackage() + '.' + field.getName();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + } else if (field.getDeclClass().getFullName().startsWith(mth.getParentClass().getPackage() + ".R")) {, + return field.getDeclClass().getNameWithoutPackage() + '.' + field.getName();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, + } else {, + if (inv.getArgsCount() > 0) {, + for (int j = 0; j < inv.getArgsCount(); j++) {, + InsnArg arg = inv.getArg(j);, + if (arg.isLiteral()) {, + f = parentClass.getConstFieldByLiteralArg((LiteralArg) arg);, + if (f != null) {, + arg.wrapInstruction(new IndexInsnNode(InsnType.SGET, f.getFieldInfo(), 0));, + }, + }, + }, + }]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, + String nsValue = entry.getValue();, + writer.add(" xmlns");, + if (nsValue != null && !nsValue.trim().isEmpty()) {, + writer.add(':');, + writer.add(nsValue);, + }, + writer.add("=\"").add(entry.getKey()).add("\"");]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + case CAST: {, + }, + case INSTANCE_OF: {, + boolean wrap = state.contains(IGState.BODY_ONLY);, + if (wrap), + code.add("(");, + code.add(arg(insn, 0));, + code.add(" instanceof ");, + code.add(useType((ArgType) ((IndexInsnNode) insn).getIndex()));, + if (wrap) {, + code.add(")");, + }, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + case CAST: {, + }, + case INSTANCE_OF: {, + boolean wrap = state.contains(IGState.BODY_ONLY);, + if (wrap), + code.add("(");, + code.add(arg(insn, 0));, + code.add(" instanceof ");, + code.add(useType((ArgType) ((IndexInsnNode) insn).getIndex()));, + if (wrap) {, + code.add(")");, + }, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.instructions.ArithNode;, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.dex.instructions.args.InsnWrapArg;, + if (lit.getLiteral() == 0)
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"-f", "--fallback"}, description = "make simple dump (using goto instead of 'if', 'for', etc)"), + @Parameter(names = {"--show-bad-code"}, description = "show inconsistent code (incorrectly decompiled)"), + protected boolean showInconsistentCode = false;, +, + public boolean isShowInconsistentCode() {, + return showInconsistentCode;, + }, +, + @Override, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"-f", "--fallback"}, description = "make simple dump (using goto instead of 'if', 'for', etc)"), + @Parameter(names = {"--show-bad-code"}, description = "show inconsistent code (incorrectly decompiled)"), + protected boolean showInconsistentCode = false;, +, + public boolean isShowInconsistentCode() {, + return showInconsistentCode;, + }, +, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, + public void setParentInsn(@Nullable InsnNode parentInsn) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, + public void setParentInsn(@Nullable InsnNode parentInsn) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, +import org.jetbrains.annotations.Nullable;, +, + if (inline(arg, assignInsn, assignBlock, mth)) {, + }, + inline(wrapInfo.getArg(), wrapInfo.getInsn(), block, mth);, + private static boolean inline(RegisterArg arg, InsnNode insn, @Nullable BlockNode block, MethodNode mth) {, + InsnNode parentInsn = arg.getParentInsn();, + // replace move instruction if needed, + if (parentInsn != null && parentInsn.getType() == InsnType.MOVE) {, + if (block == null) {, + block = BlockUtils.getBlockByInsn(mth, parentInsn);, + }, + if (block != null) {, + int index = InsnList.getIndex(block.getInstructions(), parentInsn);, +
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import java.awt.Window;, +import java.util.HashMap;, +import java.util.Map;, + private Map<String, WindowLocation> windowPos = new HashMap<String, WindowLocation>();, +, + public void saveWindowPos(Window window) {, + WindowLocation pos = new WindowLocation(window.getClass().getSimpleName(),, + window.getX(), window.getY(),, + window.getWidth(), window.getHeight(), + );, + windowPos.put(pos.getWindowId(), pos);, + sync();, + }, +, + public boolean loadWindowPos(Window window) {, + WindowLocation pos = windowPos.get(window.getClass().getSimpleName());, + if (pos == null) {, + return false;, + }, + window.setLocation(pos.getX(), pos.getY());, + window.setSize(pos.getWidth(), pos.getHeight());, + return true;, + }, +, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import java.awt.Window;, +import java.util.HashMap;, +import java.util.Map;, + private Map<String, WindowLocation> windowPos = new HashMap<String, WindowLocation>();, +, +
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, + private static final String CLASS_NAME_SEPARATOR = ".";, + private static final String INNER_CLASS_SEPARATOR = "$";, + private final Set<String> pkgSet = new TreeSet<String>();, + if (fullPkgName.isEmpty() || fullPkgName.equals(CLASS_NAME_SEPARATOR)) {, + int idx = fullPkgName.indexOf(CLASS_NAME_SEPARATOR);, + prefix += INNER_CLASS_SEPARATOR;, + return pkg.getFullAlias() + CLASS_NAME_SEPARATOR + makeNameWithoutPkg();, + prefix += INNER_CLASS_SEPARATOR;, + return String.format("C%04d%s", clsIndex++, makeName(clsName));, + if (!pkg.hasAlias() && shouldRename(pkgName)) {, + final String pkgAlias = String.format("p%03d%s", pkgIndex++, makeName(pkgName));, + return s.length() > maxLength, + || s.length() < minLength, + || NameMapper.isReserved(s), + || !NameMapper.isAllCharsPrintable(s);, + }, +, + private String makeName(String name) {, + if (name.length()
[+++ b/jadx-core/build.gradle, + compile files('lib/dx-1.8.jar'), +++ b/jadx-core/build.gradle, + compile files('lib/dx-1.8.jar'), +++ b/jadx-core/lib/dx-1.8.jar, +++ b/jadx-core/build.gradle, + compile files('lib/dx-1.8.jar'), +++ b/jadx-core/lib/dx-1.8.jar, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +import com.android.dex.FieldId;, +++ b/jadx-core/build.gradle, + compile files('lib/dx-1.8.jar'), +++ b/jadx-core/lib/dx-1.8.jar, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +import com.android.dex.FieldId;, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +import com.android.dex.MethodId;, +import com.android.dex.ProtoId;, +++ b/jadx-core/build.gradle, + compile files('lib/dx-1.8.jar'), +++ b/jadx-core/lib/dx-1.8.jar, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +import com.android.dex.FieldId;, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +import com.android.dex.MethodId;, +import com.android.dex.ProtoId;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +import com.android.dex.Code;, +++ b/jadx-core/build.gradle, + compile files('lib/dx-1.8.jar'), +++ b/jadx-core/lib/dx-1.8.jar, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, +import com.android.dex.FieldId;, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, +import com.android.dex.MethodId;, +import com.android.dex.ProtoId;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +import com.android.dex.Code;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import com.android.dex.ClassData;, +import com.android.dex.ClassData.Field;, +import com.android.dex.ClassData.Method;, +import com.android.dex.ClassDef;, +++ b/jadx-core/build.gradle, + compile files('lib/dx-1.8.jar'), +++ b/jadx-core/lib/dx-1.8.jar,
[+++ b/.gitignore, +node_modules/, +++ b/.gitignore, +node_modules/, +++ b/.releaserc.yml, +branch: release, +verifyConditions:, + - '@semantic-release/github', +prepare:, + - path: '@semantic-release/exec', + cmd: "JADX_VERSION=${nextRelease.version} ./gradlew clean dist", +publish:, + - path: '@semantic-release/exec', + cmd: "JADX_VERSION=${nextRelease.version} BINTRAY_PACKAGE=releases bash scripts/bintray-upload.sh", + - path: '@semantic-release/github', + assets:, + - path: 'build/*.zip', + label: 'zip bundle', + - path: 'build/*.exe', + label: 'jadx-gui windows', +, +++ b/.gitignore, +node_modules/, +++ b/.releaserc.yml, +branch: release, +verifyConditions:, + - '@semantic-release/github', +prepare:, + - path: '@semantic-release/exec', + cmd: "JADX_VERSION=${nextRelease.version} ./gradlew clean dist", +publish:, + - path: '@semantic-release/exec', + cmd: "JADX_VERSION=${nextRelease.version} BINTRAY_PACKAGE=releases bash scripts/bintray-upload.sh", + - path: '@semantic-release/github', + assets:, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + enterBlock = null;, + sVars.clear();, + region = null;, + loops.clear();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + enterBlock = null;, + sVars.clear();, + region = null;, + loops.clear();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java, + removeInnerClassesFromDeps(cls, depList);, +, + private void removeInnerClassesFromDeps(ClassNode cls, Set<ClassNode> depList) {, + cls.getInnerClasses().forEach(inner -> {, + depList.remove(inner);, + removeInnerClassesFromDeps(inner, depList);, + });, + }]
[+++ b/.gitlab-ci.yml, + - sed -i " 1 s/.*/&-glb$(git rev-list --count HEAD)-$(git rev-parse --short HEAD)/" version, + - build/jadx*.exe, +++ b/.gitlab-ci.yml, + - sed -i " 1 s/.*/&-glb$(git rev-list --count HEAD)-$(git rev-parse --short HEAD)/" version, + - build/jadx*.exe, +++ b/.travis.yml, + - TERM=dumb GRADLE_OPTS="-Dorg.gradle.daemon=false", +++ b/.gitlab-ci.yml, + - sed -i " 1 s/.*/&-glb$(git rev-list --count HEAD)-$(git rev-parse --short HEAD)/" version, + - build/jadx*.exe, +++ b/.travis.yml, + - TERM=dumb GRADLE_OPTS="-Dorg.gradle.daemon=false", +++ b/bintray.json, + "includePattern": "build/(jadx.*\.(zip|exe))",, +++ b/.gitlab-ci.yml, + - sed -i " 1 s/.*/&-glb$(git rev-list --count HEAD)-$(git rev-parse --short HEAD)/" version, + - build/jadx*.exe, +++ b/.travis.yml, + - TERM=dumb GRADLE_OPTS="-Dorg.gradle.daemon=false",
[+++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.dex.info.MethodInfo;, + return makeNameFromInvoke(inv.getCallMth());, +, + private static String makeNameFromInvoke(MethodInfo callMth) {, + String name = callMth.getName();, + if (name.startsWith("get") || name.startsWith("set")) {, + return fromName(name.substring(3));, + }, + ArgType declType = callMth.getDeclClass().getType();, + if ("iterator".equals(name)) {, + return "it";, + }, + if ("toString".equals(name)) {, + return makeNameForType(declType);, + }, + if ("forName".equals(name) && declType.equals(ArgType.CLASS)) {, + return OBJ_ALIAS.get(Consts.CLASS_CLASS);, + }, + return name;, + }]
[+++ b/build.gradle, +, + testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.1', + testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.1', + }, +, + test {, + useJUnitPlatform(), +++ b/build.gradle, +, + testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.1', + testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.1', + }, +, + test {, + useJUnitPlatform(), +++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +import org.junit.jupiter.api.Test;, +++ b/build.gradle, +, + testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.1', + testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.1', + }, +, + test {, + useJUnitPlatform(), +++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +import org.junit.jupiter.api.Test;, +++ b/jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java, +import org.junit.jupiter.api.Test;, +++ b/build.gradle, +, + testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.1', + testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.1', + }, +, + test {, + useJUnitPlatform(), +++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +import org.junit.jupiter.api.Test;, +++ b/jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java, +import org.junit.jupiter.api.Test;, +++ b/jadx-core/src/test/java/jadx/api/JadxDecompilerTest.java, +import org.junit.jupiter.api.Disabled;, +import org.junit.jupiter.api.Test;, + @Disabled, +++ b/build.gradle, +,
[+++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, + }, + if (srcDir == null) {, + args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, + }, + if (resDir == null) {, + args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, + }, + checkDir(args.getOutDir(), "Output");, + checkDir(args.getOutDirSrc(), "Source output");, + checkDir(args.getOutDirRes(), "Resources output");, + private static void checkDir(File dir, String desc) {, + throw new JadxArgsValidateException(desc + " directory exists as file " + dir);, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, + }, + if (srcDir == null) {, + args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, + }, + if (resDir == null) {, + args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, + }, + checkDir(args.getOutDir(), "Output");, + checkDir(args.getOutDirSrc(), "Source output");, + checkDir(args.getOutDirRes(), "Resources
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + BlockNode ss = s.get(0);, + BlockNode cross = BlockUtils.getPathCross(mth, ss, handler);, + if (cross != null && cross != ss && cross != handler) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + BlockNode ss = s.get(0);, + BlockNode cross = BlockUtils.getPathCross(mth, ss, handler);, + if (cross != null && cross != ss && cross != handler) {, +++ b/jadx-core/src/test/java/jadx/tests/internal/others/TestIssue13.java, +package jadx.tests.internal.others;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import java.lang.reflect.Field;, +import java.util.HashMap;, +, +import org.junit.Test;, +, +import static jadx.tests.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestIssue13 extends InternalJadxTest {, +, + public static class TestCls {, + private static final String
[+++ b/build.gradle, +++ b/build.gradle, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + code.add("new ").add(insn.getResult().getInitType().toString());, +++ b/build.gradle, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + code.add("new ").add(insn.getResult().getInitType().toString());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +import jadx.core.utils.InsnRemover;, + InsnRemover.fixUsedInPhiFlag(reg);, +++ b/build.gradle, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + code.add("new ").add(insn.getResult().getInitType().toString());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +import jadx.core.utils.InsnRemover;, + InsnRemover.fixUsedInPhiFlag(reg);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +import jadx.core.utils.InsnRemover;, + attachArg(arg);, + }, +, + public void setArg(int n, InsnArg arg) {, + arguments.set(n, arg);, + attachArg(arg);, + }, +, + private void attachArg(InsnArg arg) {, + InsnRemover.unbindArgUsage(null, arg);, + InsnRemover.unbindArgUsage(null, arg);, +++ b/build.gradle, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + code.add("new ").add(insn.getResult().getInitType().toString());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +import jadx.core.utils.InsnRemover;, + InsnRemover.fixUsedInPhiFlag(reg);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +import jadx.core.utils.InsnRemover;, + attachArg(arg);, + }, +, + public void setArg(int n,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +import jadx.core.deobf.NameMapper;, + char ch = (char) lit;, + if (!NameMapper.isPrintableChar(ch)) {, + return Integer.toString(ch);, + }, + return stringUtils.unescapeChar(ch);, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +import jadx.core.deobf.NameMapper;, + char ch = (char) lit;, + if (!NameMapper.isPrintableChar(ch)) {, + return Integer.toString(ch);, + }, + return stringUtils.unescapeChar(ch);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessVariables.java, + && canDeclareInRegion(u, assignRegion), + if (canDeclareInRegion(u, region)) {, + private static boolean canDeclareInRegion(Usage u, IRegion region) {, + // TODO: make index for faster search, + return isAllRegionsAfter(region, u.getAssigns()), + && isAllRegionsAfter(region, u.getUseRegions());, + private static boolean isAllRegionsAfter(IRegion region, Set<IRegion> others) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +import jadx.core.deobf.NameMapper;, + char ch = (char) lit;,
[+++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, + private List<JavaClass> classes;, + ex.shutdown();, + if (classes == null) {, + List<JavaClass> clsList = new ArrayList<JavaClass>(classNodeList.size());, + clsList.add(new JavaClass(this, classNode));, + classes = Collections.unmodifiableList(clsList);, + }, + return classes;, + for (JavaClass javaClass : getClasses()) {, + reset();, + private void reset() {, + ClassInfo.clearCache();, + ErrorsCounter.reset();, + classes = null;, + }, +, +, + JavaClass findJavaClass(ClassNode cls) {, + if (cls == null) {, + return null;, + }, + for (JavaClass javaClass : getClasses()) {, + if (javaClass.getClassNode().equals(cls)) {, + return javaClass;, + }, + }, + return null;, + }, +++
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.LoopRegionVisitor;, + passes.add(new LoopRegionVisitor());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.LoopRegionVisitor;, + passes.add(new LoopRegionVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +import jadx.core.dex.regions.conditions.Compare;, +import jadx.core.dex.regions.conditions.IfCondition;, +import jadx.core.dex.regions.conditions.IfCondition.Mode;, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.LoopRegionVisitor;, + passes.add(new LoopRegionVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +import jadx.core.dex.regions.conditions.Compare;, +import jadx.core.dex.regions.conditions.IfCondition;, +import jadx.core.dex.regions.conditions.IfCondition.Mode;, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + protected enum Flags {, + INLINE, + protected boolean makeInsn(InsnNode insn, CodeWriter code, Flags flag) throws CodegenException {, + if (flag != Flags.INLINE) {, + }, + if (flag != Flags.INLINE) {, + }, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.LoopRegionVisitor;, + passes.add(new LoopRegionVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +import jadx.core.dex.regions.conditions.Compare;, +import jadx.core.dex.regions.conditions.IfCondition;, +import jadx.core.dex.regions.conditions.IfCondition.Mode;, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + protected enum Flags {, + INLINE, +
[+++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.xmlgen.ResContainer;, +, + public ZipRef getZipRef() {, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.xmlgen.ResContainer;, +, + public ZipRef getZipRef() {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +import java.io.FileInputStream;, +import jadx.api.ResourceFile.ZipRef;, +import jadx.core.codegen.CodeWriter;, +import jadx.core.utils.Utils;, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.utils.files.InputFile;, +import jadx.core.xmlgen.ResContainer;, +import jadx.core.xmlgen.ResTableParser;, + long size;, + ZipRef zipRef = rf.getZipRef();, + if (zipRef == null) {, + File file = new File(rf.getName());, + inputStream = new BufferedInputStream(new FileInputStream(file));, + size = file.length();, + } else {, + size = entry.getSize();, + }, + result = decoder.decode(size, inputStream);, + throw new JadxException("Error decode: " + rf.getName(), e);, + LOG.error("Error close
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfInfo.java, + return "IfInfo: then: " + thenBlock + ", else: " + elseBlock;, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfInfo.java, + return "IfInfo: then: " + thenBlock + ", else: " + elseBlock;, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java, + return body == null ? "-" : body.baseString();, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfInfo.java, + return "IfInfo: then: " + thenBlock + ", else: " + elseBlock;, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java, + return body == null ? "-" : body.baseString();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, + // printRegion(mth);, + private void printRegion(MethodNode mth) {, + LOG.debug("|" + mth.toString());, + printRegion(mth, mth.getRegion(), "| ");, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfInfo.java, + return "IfInfo: then: " + thenBlock
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new DebugInfoVisitor());, + passes.add(new TypeInference());, +, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new FinishTypeInference());, +, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new DebugInfoVisitor());, + passes.add(new TypeInference());, +, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, + private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new DebugInfoVisitor());,
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/test/java/jadx/tests/functional/JadxClasspathTest.java, +package jadx.tests.functional;, +, +import jadx.core.clsp.ClspGraph;, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.utils.exceptions.DecodeException;, +, +import java.io.IOException;, +, +import org.junit.Before;, +import org.junit.Test;, +, +import static jadx.core.dex.instructions.args.ArgType.object;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertTrue;, +, +public class JadxClasspathTest {, +, + private static final String JAVA_LANG_EXCEPTION = "java.lang.Exception";, + private
[+++ b/.travis.yml, + - JADX_LAST_TAG=$(git describe --abbrev=0 --tags), + - JADX_VERSION="${JADX_LAST_TAG:1}-b$TRAVIS_BUILD_NUMBER-$(git rev-parse --short HEAD)"]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/test/java/jadx/tests/internal/conditions/TestConditions.java, +package jadx.tests.internal.conditions;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.CoreMatchers.not;, +import static org.junit.Assert.assertThat;, +, +public class TestConditions extends InternalJadxTest {, +, + public static class TestCls {, + private boolean f1(boolean a, boolean b, boolean c) {, + return (a && b) || c;, + }, + }, +, + @Test, + public void test() {, + ClassNode cls = getClassNode(TestCls.class);, + String code = cls.getCode().toString();, + System.out.println(code);, +, + assertThat(code, not(containsString("(!a
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.NewArrayNode;, + ArgType arrayType = ((NewArrayNode) insn).getArrayType();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.NewArrayNode;, + ArgType arrayType = ((NewArrayNode) insn).getArrayType();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FilledNewArrayNode.java, +import org.jetbrains.annotations.NotNull;, +, + public FilledNewArrayNode(@NotNull ArgType elemType, int size) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.NewArrayNode;, + ArgType arrayType = ((NewArrayNode) insn).getArrayType();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FilledNewArrayNode.java, +import org.jetbrains.annotations.NotNull;, +, + public FilledNewArrayNode(@NotNull ArgType elemType, int size) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, + ArgType arrType = dex.getType(insn.getIndex());, + return new NewArrayNode(arrType,, + InsnArg.reg(insn, 0, arrType),, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.NewArrayNode;, + ArgType arrayType = ((NewArrayNode) insn).getArrayType();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FilledNewArrayNode.java, +import org.jetbrains.annotations.NotNull;, +, + public FilledNewArrayNode(@NotNull ArgType elemType, int size) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, + ArgType arrType
[+++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +// if (lz), +// return "(" + str + ")";, +// else, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +// if (lz), +// return "(" + str + ")";, +// else, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/AnnotationsParser.java, +import java.util.LinkedHashMap;, + EncValueParser parser = new EncValueParser(dex, s);, + if (readVisibility) {, + }, + Map<String, Object> values = new LinkedHashMap<String, Object>(size);, + values.put(name, parser.parseValue());, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +// if (lz), +// return "(" + str + ")";, +// else, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/AnnotationsParser.java, +import java.util.LinkedHashMap;, + EncValueParser parser = new EncValueParser(dex, s);, + if (readVisibility) {, + }, + Map<String, Object> values = new LinkedHashMap<String, Object>(size);, + values.put(name, parser.parseValue());, +++
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, + List<ClassNode> classes = root.getClasses(true);, + for (ClassNode cls : classes) {, + }, + Set<String> clsFullPaths = new HashSet<>(classes.size());, + for (ClassNode cls : classes) {, + ClassInfo clsInfo = cls.getClassInfo();, + ClassInfo aliasClsInfo = clsInfo.getAlias();, + if (!clsFullPaths.add(aliasClsInfo.getFullPath().toLowerCase())) {, + String newFullName = aliasClsInfo.makeFullClsName(newShortName, true);, +, + clsInfo.rename(root, newFullName);, + clsFullPaths.add(clsInfo.getAlias().getFullPath().toLowerCase());]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +import java.util.HashSet;, +import java.util.Set;, + private Set<String> nsMapGenerated;, + nsMapGenerated = new HashSet<>();, + if(!nsMap.containsValue(attrName) && !nsMapGenerated.contains(attrName)) {, + nsMapGenerated.add(attrName);]
[+++ b/jadx-core/src/main/java/jadx/core/Consts.java, + public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass_";, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, + public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass_";, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + code.add('{');, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, + public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass_";, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + code.add('{');, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.utils.RegionUtils;, + if (cls.getSuperClass() != null && !cls.getSuperClass().isObject()) {, + } else {, + }, + MethodNode defCtr = cls.getDefaultConstructor();, + if (RegionUtils.notEmpty(defCtr.getRegion())) {, + defCtr.getAttributes().add(AttributeFlag.ANONYMOUS_CONSTRUCTOR);, + } else {, + defCtr.getAttributes().add(AttributeFlag.DONT_GENERATE);, + }, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, + public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass_";, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + code.add('{');, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.utils.RegionUtils;, + if (cls.getSuperClass() != null &&
[+++ b/.travis.yml, + if: branch = master AND env(BINTRAY_KEY) IS present, +++ b/.travis.yml, + if: branch = master AND env(BINTRAY_KEY) IS present, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +, + public boolean canThrowException() {, + switch (getType()) {, + case RETURN:, + case IF:, + case GOTO:, + case MOVE:, + case MOVE_EXCEPTION:, + case NEG:, + case CONST:, + case CONST_STR:, + case CONST_CLASS:, + case CMP_L:, + case CMP_G:, + return false;, +, + default:, + return true;, + }, + }, +++ b/.travis.yml, + if: branch = master AND env(BINTRAY_KEY) IS present, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +, + public boolean canThrowException() {,
[+++ b/.travis.yml, +before_install:, + - chmod +x gradlew, +script: ./gradlew clean build dist, +++ b/.travis.yml, +before_install:, + - chmod +x gradlew, +script: ./gradlew clean build dist, +++ b/build.gradle, + gradleVersion = '1.9', +++ b/.travis.yml, +before_install:, + - chmod +x gradlew, +script: ./gradlew clean build dist, +++ b/build.gradle, + gradleVersion = '1.9', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/.travis.yml, +before_install:, + - chmod +x gradlew, +script: ./gradlew clean build dist, +++ b/build.gradle, + gradleVersion = '1.9', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.9-bin.zip]
[+++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, + addTask(() -> {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, + addTask(() -> {, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, + SwingUtilities.invokeLater(() -> {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, + addTask(() -> {, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, + SwingUtilities.invokeLater(() -> {, +++ b/jadx-gui/src/main/java/jadx/gui/ui/ProgressPanel.java, + cancelButton.addActionListener(e -> mainWindow.cancelBackgroundJobs());, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, + addTask(() -> {, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, + SwingUtilities.invokeLater(() -> {, +++ b/jadx-gui/src/main/java/jadx/gui/ui/ProgressPanel.java, + cancelButton.addActionListener(e -> mainWindow.cancelBackgroundJobs());, +++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/CodeArea.java, +import java.awt.Dimension;, +import java.awt.Point;, +import java.awt.Rectangle;, +import java.awt.event.MouseAdapter;, +import java.awt.event.MouseEvent;, +, +import javax.swing.JPopupMenu;, +import javax.swing.JViewport;, +import javax.swing.SwingUtilities;, + FindUsageAction findUsage = new FindUsageAction(contentPanel, this, jCls);, + popup.addPopupMenuListener(findUsage);, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, + addTask(() -> {, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, + SwingUtilities.invokeLater(() -> {, +++ b/jadx-gui/src/main/java/jadx/gui/ui/ProgressPanel.java, + cancelButton.addActionListener(e
[+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, + if (RegionUtils.hasExitEdge(c)) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, + if (RegionUtils.hasExitEdge(c)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + LoopInfo loop = mth.getLoopForBlock(block);, + BitSet outs = new BitSet(mth.getBasicBlocks().size());, + outs.or(block.getDomFrontier());, + for (BlockNode s : block.getCleanSuccessors()) {, + outs.or(s.getDomFrontier());, + }, + stack.push(sw);, + stack.addExits(BlockUtils.bitSetToBlocks(mth, outs));, +, + // filter 'out' block, + if (outs.cardinality() > 1) {, + BlockUtils.cleanBitSet(mth, outs);, + if (outs.cardinality() > 1) {, + // filter loop start and successors of other blocks, + for (int i = outs.nextSetBit(0); i >= 0; i = outs.nextSetBit(i + 1)) {, + if (b.contains(AFlag.LOOP_START)) {, + outs.clear(b.getId());, + } else {,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + warns.forEach(warn -> code.startLine("/* JADX WARNING: ").addMultiLine(warn.getWarn()).add(" */"));]
[+++ b/jadx-core/src/main/java/jadx/core/Consts.java, + public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass";, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, + public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass";, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + || innerCls.contains(AFlag.ANONYMOUS_CLASS)) {, + if (!innerCls.contains(AFlag.ANONYMOUS_CLASS)) {, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, + public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass";, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + || innerCls.contains(AFlag.ANONYMOUS_CLASS)) {, + if (!innerCls.contains(AFlag.ANONYMOUS_CLASS)) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (cls != null && cls.contains(AFlag.ANONYMOUS_CLASS) && !fallback) {, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, + public static final String ANONYMOUS_CLASS_PREFIX = "AnonymousClass";, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + || innerCls.contains(AFlag.ANONYMOUS_CLASS)) {, + if (!innerCls.contains(AFlag.ANONYMOUS_CLASS)) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (cls != null && cls.contains(AFlag.ANONYMOUS_CLASS) && !fallback) {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, + ANONYMOUS_CLASS,, +++
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +import jadx.core.dex.attributes.nodes.EdgeInsnAttr;, + public static final AType<AttrList<EdgeInsnAttr>> EDGE_INSN = new AType<AttrList<EdgeInsnAttr>>();, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +import jadx.core.dex.attributes.nodes.EdgeInsnAttr;, + public static final AType<AttrList<EdgeInsnAttr>> EDGE_INSN = new AType<AttrList<EdgeInsnAttr>>();, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EdgeInsnAttr.java, +package jadx.core.dex.attributes.nodes;, +, +import jadx.core.dex.attributes.AType;, +import jadx.core.dex.attributes.AttrList;, +import jadx.core.dex.attributes.IAttribute;, +import jadx.core.dex.nodes.BlockNode;, +import jadx.core.dex.nodes.InsnNode;, +, +public class EdgeInsnAttr implements IAttribute {, +, + private final BlockNode start;, + private final BlockNode end;, + private final InsnNode insn;, +, + public static void addEdgeInsn(BlockNode start, BlockNode end, InsnNode insn) {, + EdgeInsnAttr edgeInsnAttr = new EdgeInsnAttr(start, end, insn);, + start.addAttr(AType.EDGE_INSN, edgeInsnAttr);, + end.addAttr(AType.EDGE_INSN, edgeInsnAttr);, + }, +, + public EdgeInsnAttr(BlockNode start, BlockNode end,
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, + } else {, + return currentIf;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, + } else {, + return currentIf;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java, + return removeRedundantElseBlock(mth, (IfRegion) region);, + private static boolean removeRedundantElseBlock(MethodNode mth, IfRegion ifRegion) {, + if (ifRegion.getElseRegion() == null, + || ifRegion.contains(AFlag.ELSE_IF_CHAIN), + || ifRegion.getElseRegion().contains(AFlag.ELSE_IF_CHAIN)) {, + return false;, + }, + if (!hasBranchTerminator(ifRegion.getThenRegion())) {, + return false;, + }, + // code style check:, + // will remove 'return;' from 'then' and 'else' with one instruction, + // see #jadx.tests.integration.conditions.TestConditions9, + if (mth.getReturnType() == ArgType.VOID, + && insnsCount(ifRegion.getThenRegion()) == 2, + && insnsCount(ifRegion.getElseRegion()) == 2) {, + return
[+++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryAfterDeclaration.java, +package jadx.tests.integration.trycatch;, +, +import java.io.FileInputStream;, +import java.io.IOException;, +import java.io.InputStream;, +, +import org.junit.jupiter.api.Test;, +, +import jadx.NotYetImplemented;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.hamcrest.MatcherAssert.assertThat;, +, +public class TestTryAfterDeclaration extends IntegrationTest {, +, + static class TestClass {, + public static void consume() throws IOException {, + InputStream bis = null;, + try {, + bis = new FileInputStream("1.txt");, + while (bis != null) {, + System.out.println("c");, + }, + } catch (final IOException e) {, + }, + }, + }, +, + /**, + * Issue #62., + */, + @Test, + @NotYetImplemented, +
[+++ b/jadx-core/src/test/java/jadx/tests/StringUtilsTest.java, +import org.junit.Test;, +import static org.junit.Assert.assertEquals;, +, +public class StringUtilsTest {, +, + @Test, +++ b/jadx-core/src/test/java/jadx/tests/StringUtilsTest.java, +import org.junit.Test;, +import static org.junit.Assert.assertEquals;, +, +public class StringUtilsTest {, +, + @Test, +++ b/jadx-core/src/test/java/jadx/tests/TypeMergeTest.java, +import org.junit.Before;, +import org.junit.Test;, +, +import static org.junit.Assert.assertNotNull;, +import static org.junit.Assert.assertNull;, +import static org.junit.Assert.assertTrue;, +public class TypeMergeTest {, + @Before, + public void initClsp() throws IOException, DecodeException {, + @Test, +++ b/jadx-core/src/test/java/jadx/tests/StringUtilsTest.java, +import org.junit.Test;, +import static org.junit.Assert.assertEquals;, +, +public class StringUtilsTest {, +, + @Test, +++ b/jadx-core/src/test/java/jadx/tests/TypeMergeTest.java, +import org.junit.Before;, +import org.junit.Test;, +, +import static org.junit.Assert.assertNotNull;, +import static org.junit.Assert.assertNull;, +import static org.junit.Assert.assertTrue;, +public class TypeMergeTest {, + @Before,
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, + if (!dir.mkdirs() && !dir.isDirectory()) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, + if (!dir.mkdirs() && !dir.isDirectory()) {, +++ b/jadx-gui/src/main/java/jadx/gui/utils/CertificateManager.java, + StringBuffer buf = new StringBuffer(bytes.length * 3);]
[+++ b/README.md, + ./gradlew clean build, + bin/jadx -d out lib/jadx-core-*.jar, + #or, +jadx[-gui] [options] <input file> (.dex, .apk or .jar), +++ b/README.md, + ./gradlew clean build, + bin/jadx -d out lib/jadx-core-*.jar, + #or, +jadx[-gui] [options] <input file> (.dex, .apk or .jar), +++ b/build.gradle, + mainAttributes('jadx-version' : jadxVersion), +task copyArtifacts (type: Sync, dependsOn: ['jadx-cli:installApp', 'jadx-gui:installApp']) {, +task build (dependsOn: pack) {, + description = 'Build jadx distribution zip', +}, +, +++ b/README.md, + ./gradlew clean build, + bin/jadx -d out lib/jadx-core-*.jar, + #or, +jadx[-gui] [options] <input file> (.dex, .apk or .jar), +++ b/build.gradle, + mainAttributes('jadx-version' : jadxVersion), +task copyArtifacts
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, + if (!isLastEnd) {, + isLastEnd = true;, + writer.add(">");, + }, + String escapedStr = StringUtils.escapeXML(str);, + writer.add(escapedStr);, +// if (elementNS != -1) {, +// writer.add(getString(elementNS)).add(':');, +// }]
[+++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.xmlgen.ResContainer;, +, + public ZipRef getZipRef() {, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.xmlgen.ResContainer;, +, + public ZipRef getZipRef() {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +import java.io.FileInputStream;, +import jadx.api.ResourceFile.ZipRef;, +import jadx.core.codegen.CodeWriter;, +import jadx.core.utils.Utils;, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.utils.files.InputFile;, +import jadx.core.xmlgen.ResContainer;, +import jadx.core.xmlgen.ResTableParser;, + long size;, + ZipRef zipRef = rf.getZipRef();, + if (zipRef == null) {, + File file = new File(rf.getName());, + inputStream = new BufferedInputStream(new FileInputStream(file));, + size = file.length();, + } else {, + size = entry.getSize();, + }, + result = decoder.decode(size, inputStream);, + throw new JadxException("Error decode: " + rf.getName(), e);, + LOG.error("Error close
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, + && Objects.equals(result, other.result)]
[+++ b/.travis.yml, +cache:, + directories:, + - $HOME/.gradle, +, +++ b/.travis.yml, +cache:, + directories:, + - $HOME/.gradle, +, +++ b/settings.gradle, +include 'jadx-core', +include 'jadx-cli', +include 'jadx-gui', +include 'jadx-samples']
[+++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, + if (!(obj instanceof LineAttrNode)) {, + return null;, + }, + clsNode = clsNode.getTopParentClass();, + if (defLine == 0) {, + return new CodePosition(jCls, defLine, 0);, + }, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, + if (!(obj instanceof LineAttrNode)) {, + return null;, + }, + clsNode = clsNode.getTopParentClass();, + if (defLine == 0) {, + return new CodePosition(jCls, defLine, 0);, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, + public ClassNode getTopParentClass() {, + ClassNode parent = getParentClass();, + return parent == this ? this : parent.getParentClass();, + }, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, + * For every exception handler must be only one splitter block,, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, + * For every exception handler must be only one splitter block,, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoParser.java, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, + * For every exception handler must be only one splitter block,, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoParser.java, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +@SuppressWarnings("unused"), +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, + * For every exception handler must be only one splitter block,, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoParser.java, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +@SuppressWarnings("unused"), +++ b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java, + @SuppressWarnings("unused"), +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, + * For every exception handler must be only one splitter block,, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/debuginfo/DebugInfoParser.java, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +@SuppressWarnings("unused"), +++ b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java, + @SuppressWarnings("unused"), +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java, + @SuppressWarnings("unused"),
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import java.util.Objects;, + if (callMth.getArgsCount() != mth.getMethodInfo().getArgsCount()) {, + return false;, + }, + if (Objects.equals(wrappedMth.getAlias(), alias)) {, + return true;, + if (!wrappedMth.isVirtual()) {, + return false;, + }, + wrappedMth.getMethodInfo().setAlias(alias);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +import java.io.EOFException;, +, +import com.android.dex.Code;, +import com.android.dx.io.OpcodeInfo;, +import com.android.dx.io.Opcodes;, +import com.android.dx.io.instructions.DecodedInstruction;, +import com.android.dx.io.instructions.FillArrayDataPayloadDecodedInstruction;, +import com.android.dx.io.instructions.PackedSwitchPayloadDecodedInstruction;, +import com.android.dx.io.instructions.ShortArrayCodeInput;, +import com.android.dx.io.instructions.SparseSwitchPayloadDecodedInstruction;, +import org.jetbrains.annotations.NotNull;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, + private static final Logger LOG = LoggerFactory.getLogger(InsnDecoder.class);, + decoded[in.cursor()] = decodeRawInsn(in);, + throw new DecodeException(method, e.getMessage(), e);, + private DecodedInstruction decodeRawInsn(ShortArrayCodeInput in) throws EOFException {, + int opcodeUnit = in.read();, + int opcode = Opcodes.extractOpcodeFromUnit(opcodeUnit);, + OpcodeInfo.Info opcodeInfo;, + try {, + opcodeInfo = OpcodeInfo.get(opcode);, + } catch (IllegalArgumentException e) {, + LOG.warn("Ignore decode error: '{}', replace with NOP instruction", e.getMessage());, + opcodeInfo = OpcodeInfo.NOP;, + }, + return opcodeInfo.getFormat().decode(opcodeUnit,
[+++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, + CodeWriter code = cls.getCode();, + if (code == null) {, + return Collections.emptyMap();, + }, + return code.getAnnotations();]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/AboutDialog.java, +import java.net.URL;, +import jadx.gui.utils.Utils;, + URL logoURL = getClass().getResource("/logos/jadx-logo-48px.png");, + Icon logo = new ImageIcon(logoURL, "jadx logo");, +, + JLabel name = new JLabel("jadx", logo, SwingConstants.CENTER);, + JLabel version = new JLabel("jadx version: " + JadxDecompiler.getVersion());, + String javaVm = System.getProperty("java.vm.name");, + String javaVer = System.getProperty("java.vm.version");, +, + javaVm = javaVm == null ? "" : javaVm;, +, + JLabel javaVmLabel = new JLabel("Java VM: " + javaVm);, + javaVmLabel.setFont(font);, + javaVmLabel.setAlignmentX(0.5f);, +, + javaVer = javaVer == null ? "" : javaVer;, + JLabel javaVerLabel = new JLabel("Java version: " + javaVer);, + javaVerLabel.setFont(font);, + javaVerLabel.setAlignmentX(0.5f);,
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +@JadxVisitor(, + name = "ClassModifier",, + desc = "Remove synthetic classes, methods and fields",, + runAfter = ModVisitor.class, +), + continue;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +@JadxVisitor(, + name = "ClassModifier",, + desc = "Remove synthetic classes, methods and fields",, + runAfter = ModVisitor.class, +), + continue;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/JadxVisitor.java, +package jadx.core.dex.visitors;, +, +import java.lang.annotation.ElementType;, +import java.lang.annotation.Retention;, +import java.lang.annotation.RetentionPolicy;, +import java.lang.annotation.Target;, +, +/**, + * Annotation for describe dependencies of jadx visitors, + */, +@Retention(RetentionPolicy.RUNTIME), +@Target(ElementType.TYPE), +public @interface JadxVisitor {, + /**, + * Visitor short name (identifier), + */, + String name();, +, + /**, + * Detailed visitor description,
[+++ b/README.md, + --deobf-use-sourcename - use source file name as class name alias, + --escape-unicode - escape non latin characters in strings (with \u), +++ b/README.md, + --deobf-use-sourcename - use source file name as class name alias, + --escape-unicode - escape non latin characters in strings (with \u), +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import ch.qos.logback.classic.spi.ILoggingEvent;, +import ch.qos.logback.core.Appender;, + @Parameter(names = {"--escape-unicode"}, description = "escape non latin characters in strings (with \\u)"), + protected boolean escapeUnicode = false;, +, + Appender<ILoggingEvent> appender = rootLogger.getAppender("STDOUT");, + if (appender != null) {, + appender.clearAllFilters();, + }, +, + @Override, + public boolean escapeUnicode() {, +
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, + passes.add(new DebugInfoParseVisitor());, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new ConstructorVisitor());, + passes.add(new TypeInferenceVisitor());, + passes.add(new DebugInfoApplyVisitor());, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, + passes.add(new DebugInfoParseVisitor());, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, +
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, + passes.add(new DebugInfoParseVisitor());, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new ConstructorVisitor());, + passes.add(new TypeInferenceVisitor());, + passes.add(new DebugInfoApplyVisitor());, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, + passes.add(new DebugInfoParseVisitor());, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, +
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +public class JadxCLIArgs implements IJadxArgs {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +public class JadxCLIArgs implements IJadxArgs {, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, + if (deobfMapFile.exists() && !args.isDeobfuscationForceSave()) {, + LOG.info("Loading obfuscation map from: {}", deobfMapFile.getAbsoluteFile());, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +public class JadxCLIArgs implements IJadxArgs {, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, + if (deobfMapFile.exists() && !args.isDeobfuscationForceSave()) {, + LOG.info("Loading obfuscation map from: {}", deobfMapFile.getAbsoluteFile());, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.settings.JadxSettings;, +import jadx.gui.settings.JadxSettingsAdapter;, + final JadxSettings jadxArgs = JadxSettingsAdapter.load();, + // overwrite loaded settings by command line arguments, + MainWindow window = new MainWindow(jadxArgs);, + window.open();, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +public class JadxCLIArgs implements IJadxArgs {, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, + if (deobfMapFile.exists() && !args.isDeobfuscationForceSave()) {,
[+++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, + return name.equals(fieldInfo.name), + && type.equals(fieldInfo.type), + && declClass.equals(fieldInfo.declClass);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, + return name.equals(fieldInfo.name), + && type.equals(fieldInfo.type), + && declClass.equals(fieldInfo.declClass);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import org.jetbrains.annotations.TestOnly;, + return searchField(FieldInfo.fromDex(dex, id));, + }, +, + public FieldNode searchField(FieldInfo field) {, + if (f.getFieldInfo().equals(field)) {, + @TestOnly]
[+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java, + if(ext.equals("arsc")) {, + return SyntaxConstants.SYNTAX_STYLE_XML;, + }]
[+++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, + HashSet<BlockNode> visited = new HashSet<BlockNode>();, + collectWhileDominates(dominator, start, result, visited);, + private static void collectWhileDominates(BlockNode dominator, BlockNode child, List<BlockNode> result, HashSet<BlockNode> visited) {, + if (visited.contains(child)) return;, + visited.add(child);, + collectWhileDominates(dominator, node, result, visited);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java, + BlockNode source = edge.getSource();, + if (!target.contains(AFlag.SYNTHETIC) && !source.contains(AFlag.SYNTHETIC)) {, + BlockSplitter.insertBlockBetween(mth, source, target);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java, + BlockNode source = edge.getSource();, + if (!target.contains(AFlag.SYNTHETIC) && !source.contains(AFlag.SYNTHETIC)) {, + BlockSplitter.insertBlockBetween(mth, source, target);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, + || insn.contains(AType.EXC_HANDLER)]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, + if (mth.isDefaultConstructor()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, + if (mth.isDefaultConstructor()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + , + public boolean isDefaultConstructor() {, + boolean result = false;, +, + if (accFlags.isConstructor() && mthInfo.isConstructor()) {, + int defaultArgCount = 0;, +, + /** workaround for non-static inner class constructor, that has, + * synthetic argument */, + if ((parentClass != null) && parentClass.getClassInfo().isInner()) {, + if (!parentClass.getAccessFlags().isStatic()) {, + ClassNode outerCls = parentClass.getParentClass();, + if ((argsList != null) && (argsList.size() >= 1)) {, + if (argsList.get(0).getType().equals(outerCls.getClassInfo().getType())) {, + defaultArgCount = 1;, + }, + }, + }, + }, +, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, + if (block.getAttributes().contains(AttributeFlag.LOOP_END)) {, + // don't follow back edge, + if (loop.getStart() == b) {, + continue;, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, + if (block.getAttributes().contains(AttributeFlag.LOOP_END)) {, + // don't follow back edge, + if (loop.getStart() == b) {, + continue;, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java, + if (pred != otherPred) {, + // merge, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, + if (block.getAttributes().contains(AttributeFlag.LOOP_END)) {, + // don't follow back edge, + if (loop.getStart() == b) {, + continue;, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java, + if (pred != otherPred) {, + // merge, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + IfInfo mergedIf = mergeNestedIfNodes(condBlock,
[+++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, + return Collections.unmodifiableList(classes);, + return Collections.unmodifiableList(packages);, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, + return Collections.unmodifiableList(classes);, + return Collections.unmodifiableList(packages);, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.dex.attributes.AttributeFlag;, +import jadx.core.dex.info.AccessInfo;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.MethodNode;, +, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, + private final List<JavaClass> innerClasses;, + private final List<JavaField> fields;, + private final List<JavaMethod> methods;, +, + int inClsCount = cls.getInnerClasses().size();, + if (inClsCount == 0) {, + this.innerClasses = Collections.emptyList();, + } else {, + List<JavaClass> list = new ArrayList<JavaClass>(inClsCount);, + for (ClassNode inner : cls.getInnerClasses()) {, + list.add(new JavaClass(decompiler, inner));, + }, + this.innerClasses = Collections.unmodifiableList(list);, + }, +, + int fieldsCount = cls.getFields().size();,
[+++ b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java, +, + public static String escapeXML(String str) {, + int len = str.length();, + StringBuilder sb = new StringBuilder(len);, + for (int i = 0; i < len; i++) {, + char c = str.charAt(i);, + switch (c) {, + case '&': sb.append("&amp;"); break;, + case '<': sb.append("&lt;"); break;, + case '>': sb.append("&gt;"); break;, + case '"': sb.append("&quot;"); break;, + case '\'': sb.append("&apos;"); break;, + default:, + sb.append(c);, + break;, + }, + }, + return sb.toString();, + }, +++ b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java, +, + public static String escapeXML(String str) {, + int len = str.length();, + StringBuilder sb
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import jadx.core.utils.exceptions.JadxOverflowException;, + // 'dumb' guard to prevent endless loop in regions processing, + private static final int REGIONS_LIMIT = 1000 * 1000;, +, + private int regionsCount;, + regionsCount++;, + if (regionsCount > REGIONS_LIMIT) {, + throw new JadxOverflowException("Regions count limit reached");, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import jadx.core.utils.exceptions.JadxOverflowException;, + // 'dumb' guard to prevent endless loop in regions processing, + private static final int REGIONS_LIMIT = 1000 * 1000;, +, + private int regionsCount;, + regionsCount++;, + if (regionsCount > REGIONS_LIMIT) {, + throw new JadxOverflowException("Regions count limit reached");, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionStack.java, +import jadx.core.utils.exceptions.JadxOverflowException;, +
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + } else if (field.getDeclClass().getFullName().startsWith(mth.getParentClass().getPackage() + ".R")) {, + return field.getDeclClass().getNameWithoutPackage() + '.' + field.getName();, + assert isFallback();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + } else if (field.getDeclClass().getFullName().startsWith(mth.getParentClass().getPackage() + ".R")) {, + return field.getDeclClass().getNameWithoutPackage() + '.' + field.getName();, + assert isFallback();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, + if (accFlags.isPublic()), + else, + public FieldNode getConstField(Object o) {, + field = cn.constFields.get(o);, + if (field == null), + field = dex.getConstFields().get(o);, + ArgType type = arg.getType();, +, + if (type.equals(ArgType.DOUBLE)), + return getConstField(Double.longBitsToDouble(literal));, + else if (type.equals(ArgType.FLOAT)), + return getConstField(Float.intBitsToFloat((int) literal));, + else if (Math.abs(literal) > 0x1) {, + if (type.equals(ArgType.INT)), + return getConstField((int)
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, + if (recentFiles.getItemCount() == 0) {, + recentFiles.add(new JMenuItem(NLS.str("menu.no_recent_files")));, + }, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, + if (recentFiles.getItemCount() == 0) {, + recentFiles.add(new JMenuItem(NLS.str("menu.no_recent_files")));, + }, +++ b/jadx-gui/src/main/resources/i18n/Messages_en_US.properties, +menu.no_recent_files=No recent files]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, + public static String literalToString(long lit, ArgType type, StringUtils stringUtils) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, + public static String literalToString(long lit, ArgType type, StringUtils stringUtils) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/LiteralArg.java, +import jadx.api.JadxArgs;, +import jadx.core.utils.StringUtils;, + private static final StringUtils DEF_STRING_UTILS = new StringUtils(new JadxArgs());, +, + String value = TypeGen.literalToString(literal, getType(), DEF_STRING_UTILS);]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + passes.add(new MethodInlineVisitor());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + passes.add(new MethodInlineVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, + NClass cls = names.get(fullName);, + if (cls == null) {, + return cls;, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + passes.add(new MethodInlineVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, + NClass cls = names.get(fullName);, + if (cls == null) {, + return cls;, +++ b/jadx-core/src/main/java/jadx/core/clsp/NClass.java, + private final int id;, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + passes.add(new MethodInlineVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, + NClass cls = names.get(fullName);, + if (cls == null) {, + return cls;, +++ b/jadx-core/src/main/java/jadx/core/clsp/NClass.java, + private final int id;, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, + if (!aCls.startsWith(Consts.DALVIK_ANNOTATION_PKG)) {, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + passes.add(new MethodInlineVisitor());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, + NClass cls =
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + BlockNode body = getNextBlock(block);, + if (body == null) {, + mth.add(AFlag.INCONSISTENT_CODE);, + LOG.warn("Unexpected end of synchronized block");, + return null;, + }, + exit = traverseMonitorExitsCross(body, exits, cacheSet);, + synchRegion.getSubBlocks().add(makeRegion(body, stack));, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + BlockNode body = getNextBlock(block);, + if (body == null) {, + mth.add(AFlag.INCONSISTENT_CODE);, + LOG.warn("Unexpected end of synchronized block");, + return null;, + }, + exit = traverseMonitorExitsCross(body, exits, cacheSet);, + synchRegion.getSubBlocks().add(makeRegion(body, stack));, +++ b/jadx-core/src/main/java/jadx/core/utils/AsmUtils.java, + String className = null;, + FileInputStream in = null;, + try {, + in = new FileInputStream(file);, + className = classReader.getClassName();, + } finally {, +
[+++ b/src/main/java/jadx/Main.java, +import jadx.dex.visitors.ClassModifier;, +import jadx.dex.visitors.regions.CleanRegions;, + passes.add(new ClassModifier());, +, +, + passes.add(new CleanRegions());, +++ b/src/main/java/jadx/Main.java, +import jadx.dex.visitors.ClassModifier;, +import jadx.dex.visitors.regions.CleanRegions;, + passes.add(new ClassModifier());, +, +, + passes.add(new CleanRegions());, +++ b/src/main/java/jadx/codegen/MethodGen.java, + LOG.debug(ErrorsCounter.formatErrorMsg(mth, " Inconsistent code"));, +++ b/src/main/java/jadx/Main.java, +import jadx.dex.visitors.ClassModifier;, +import jadx.dex.visitors.regions.CleanRegions;, + passes.add(new ClassModifier());, +, +, + passes.add(new CleanRegions());, +++ b/src/main/java/jadx/codegen/MethodGen.java, + LOG.debug(ErrorsCounter.formatErrorMsg(mth, " Inconsistent code"));, +++ b/src/main/java/jadx/codegen/RegionGen.java, + code.startLine();, + code.add("if ").add(makeCondition(insn)).add(" {");, + code.add(" else ");, +, + // connect if-else-if block, + if (els instanceof Region) {, + Region re = (Region) els;, + if (re.getSubBlocks().size() == 1, + && re.getSubBlocks().get(0) instanceof IfRegion) {, + makeIf((IfRegion)
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<?> jcw) {, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<?> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<?> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<?> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.CodeShrinker;, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new BlockProcessor());, + passes.add(new BlockExceptionHandler());, + passes.add(new BlockFinallyExtract());, + passes.add(new BlockFinish());, +, + passes.add(new SSATransform());, + if (args.isDebugInfo()) {, + passes.add(new DebugInfoVisitor());, + }, + passes.add(new TypeInference());,
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfInfo.java, +import java.util.LinkedList;, +import java.util.List;, + private final Set<BlockNode> mergedBlocks;, + private final List<BlockNode> skipBlocks;, + this(condition, thenBlock, elseBlock, new HashSet<BlockNode>(), new LinkedList<BlockNode>());, + this(condition, info.getThenBlock(), info.getElseBlock(), info.getMergedBlocks(), info.getSkipBlocks());, + }, +, + public IfInfo(IfInfo info, BlockNode thenBlock, BlockNode elseBlock) {, + this(info.getCondition(), thenBlock, elseBlock, info.getMergedBlocks(), info.getSkipBlocks());, + }, +, + private IfInfo(IfCondition condition, BlockNode thenBlock, BlockNode elseBlock,, + Set<BlockNode> mergedBlocks, List<BlockNode> skipBlocks) {, + this.thenBlock = thenBlock;, + this.elseBlock = elseBlock;, + this.mergedBlocks = mergedBlocks;, + this.skipBlocks = skipBlocks;, + IfCondition invertedCondition = IfCondition.invert(info.getCondition());, + IfInfo tmpIf = new IfInfo(invertedCondition,, + info.getElseBlock(), info.getThenBlock(),, + info.getMergedBlocks(), info.getSkipBlocks());, +
[+++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, +package jadx.api;, +, +public final class CodePosition {, +, + private final JavaClass cls;, + private final int line;, + private final int offset;, +, + public CodePosition(JavaClass cls, int line, int offset) {, + this.cls = cls;, + this.line = line;, + this.offset = offset;, + }, +, + public CodePosition(int line, int offset) {, + this.cls = null;, + this.line = line;, + this.offset = offset;, + }, +, + public JavaClass getJavaClass() {, + return cls;, + }, +, + public int getLine() {, + return line;, + }, +, + public int getOffset()
[+++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +package jadx.api;, +, +import java.io.File;, +, +public class JadxArgs implements IJadxArgs {, +, + private File outDir = new File("jadx-output");, + private int threadsCount = Math.max(1, Runtime.getRuntime().availableProcessors() - 1);, +, + private boolean cfgOutput = false;, + private boolean rawCFGOutput = false;, +, + private boolean isVerbose = false;, + private boolean fallbackMode = false;, + private boolean showInconsistentCode = false;, +, + private boolean isSkipResources = false;, + private boolean isSkipSources = false;, +, + private boolean isDeobfuscationOn = false;, + private boolean isDeobfuscationForceSave = false;, + private boolean useSourceNameAsClassAlias = false;,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, + if (s == Short.MAX_VALUE) {, + return "Short.MAX_VALUE";, + }, + if (s == Short.MIN_VALUE) {, + return "Short.MIN_VALUE";, + }, + return "(short) " + Short.toString(s);, + if (b == Byte.MAX_VALUE) {, + return "Byte.MAX_VALUE";, + }, + if (b == Byte.MIN_VALUE) {, + return "Byte.MIN_VALUE";, + }, + return "(byte) " + Byte.toString(b);, + if (i == Integer.MAX_VALUE) {, + return "Integer.MAX_VALUE";, + }, + if (i == Integer.MIN_VALUE) {, + return "Integer.MIN_VALUE";, + }, + return Integer.toString(i);, + }, +, + public static String formatLong(long l) {, + if (l == Long.MAX_VALUE) {,
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java, +// removeParenthesis(block);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java, +// removeParenthesis(block);, +++ b/jadx-core/src/test/java/jadx/tests/integration/arith/TestArith2.java, + // @Test]
[+++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import static jadx.core.utils.files.FileUtils.READ_BUFFER_SIZE;, +import static jadx.core.utils.files.FileUtils.close;, +import static jadx.core.utils.files.FileUtils.copyStream;, +, + LOG.error("Error close zip file: {}", zipRef, e);, + close(inputStream);, + copyStream(is, baos);, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import static jadx.core.utils.files.FileUtils.READ_BUFFER_SIZE;, +import static jadx.core.utils.files.FileUtils.close;, +import static jadx.core.utils.files.FileUtils.copyStream;, +, + LOG.error("Error close zip file: {}", zipRef, e);, + close(inputStream);, + copyStream(is, baos);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import static jadx.core.utils.files.FileUtils.close;, +, + close(out);, + close(outputStream);, + close(out);, + close(input);, + close(in);, + close(inputStream);, + close(in);, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import static jadx.core.utils.files.FileUtils.READ_BUFFER_SIZE;, +import static jadx.core.utils.files.FileUtils.close;, +import static jadx.core.utils.files.FileUtils.copyStream;, +, + LOG.error("Error close zip file: {}", zipRef, e);, + close(inputStream);, + copyStream(is, baos);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import static
[+++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestVariablesNames.java, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestVariablesNames.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClassFakeSyntheticConstructor.java, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestVariablesNames.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClassFakeSyntheticConstructor.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClassSyntheticConstructor.java, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestVariablesNames.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClassFakeSyntheticConstructor.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClassSyntheticConstructor.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestEndlessLoop.java, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/debuginfo/TestVariablesNames.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClassFakeSyntheticConstructor.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/inner/TestInnerClassSyntheticConstructor.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestEndlessLoop.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchReturnFromCase2.java]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + boolean badCode = mth.getAttributes().contains(AttributeFlag.INCONSISTENT_CODE);, + if (badCode) {, + code.startLine("/* JADX WARNING: inconsistent code. */");, + code.startLine("/* Code decompiled incorrectly, please refer to instructions dump. */");, + code.incIndent();, + mthGen.addInstructions(code);, + code.decIndent();, + addEnumFields(cls, code);, + private void addEnumFields(ClassNode cls, CodeWriter code) throws CodegenException {, + EnumClassAttr enumFields = (EnumClassAttr) cls.getAttributes().get(AttributeType.ENUM_CLASS);, + if (enumFields != null) {, + InsnGen igen = null;, + for (Iterator<EnumField> it = enumFields.getFields().iterator(); it.hasNext(); ) {, + EnumField f = it.next();, + code.startLine(f.getName());, + if (f.getArgs().size() != 0) {, + code.add('(');, + for (Iterator<InsnArg> aIt = f.getArgs().iterator(); aIt.hasNext(); ) {, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, + public boolean canReorderRecursive() {, + if (!canReorder()) {, + return false;, + }, + for (InsnArg arg : this.getArguments()) {, + if (arg.isInsnWrap()) {, + InsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();, + if (!wrapInsn.canReorderRecursive()) {, + return false;, + }, + }, + }, + return true;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, + public boolean canReorderRecursive() {, + if (!canReorder()) {, + return false;, + }, + for (InsnArg arg : this.getArguments()) {, + if (arg.isInsnWrap()) {, + InsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();, + if (!wrapInsn.canReorderRecursive()) {, + return false;, + }, + }, + }, +
[+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, + Enumeration en = this.breadthFirstEnumeration();, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, + Enumeration en = this.breadthFirstEnumeration();, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, + private JList resultsList;, + private static class ResultsModel extends DefaultListModel {, + private static class ResultsCellRenderer implements ListCellRenderer {, + public Component getListCellRendererComponent(JList list,, + resultsList = new JList(resultsModel);, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, + Enumeration en = this.breadthFirstEnumeration();, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, + private JList resultsList;, + private static class ResultsModel extends DefaultListModel {, + private static class ResultsCellRenderer implements ListCellRenderer {, + public Component getListCellRendererComponent(JList list,, + resultsList = new JList(resultsModel);, +++ b/jadx-gui/src/main/java/jadx/gui/utils/Link.java]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, + LoopType arrForEach = checkArrayForEach(mth, loopRegion, initInsn, incrInsn, condition);, + private static LoopType checkArrayForEach(MethodNode mth, LoopRegion loopRegion, InsnNode initInsn, InsnNode incrInsn,, + if (!usedOnlyInLoop(mth, loopRegion, iterVar)) {, + return null;, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, + LoopType arrForEach = checkArrayForEach(mth, loopRegion, initInsn, incrInsn, condition);, + private static LoopType checkArrayForEach(MethodNode mth, LoopRegion loopRegion, InsnNode initInsn, InsnNode incrInsn,, + if (!usedOnlyInLoop(mth, loopRegion, iterVar)) {, + return null;, + }, +++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestIndexedLoop.java, +package jadx.tests.integration.loops;, +, +import java.io.File;, +, +import org.junit.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.hamcrest.Matchers.containsString;, +import static org.hamcrest.Matchers.is;, +import static org.hamcrest.Matchers.not;, +import static org.hamcrest.Matchers.nullValue;,
[+++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.codegen.CodeWriter;, +import jadx.core.dex.attributes.AFlag;, +import jadx.core.dex.attributes.nodes.LineAttrNode;, +import jadx.core.dex.info.AccessInfo;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.MethodNode;, +, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.codegen.CodeWriter;, +import jadx.core.dex.attributes.AFlag;, +import jadx.core.dex.attributes.nodes.LineAttrNode;, +import jadx.core.dex.info.AccessInfo;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.MethodNode;, +, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +import java.util.List;, +, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.codegen.CodeWriter;, +import jadx.core.dex.attributes.AFlag;, +import jadx.core.dex.attributes.nodes.LineAttrNode;, +import jadx.core.dex.info.AccessInfo;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.MethodNode;, +, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +import java.util.List;, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import java.io.File;, +, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.codegen.CodeWriter;, +import jadx.core.dex.attributes.AFlag;, +import jadx.core.dex.attributes.nodes.LineAttrNode;, +import jadx.core.dex.info.AccessInfo;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.MethodNode;, +, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +import java.util.List;, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import java.io.File;, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.nodes.ClassNode;,
[+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +import java.util.concurrent.Callable;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.Executors;, +import java.util.concurrent.Future;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.TimeoutException;, + limitExecTime(() -> checkMth.invoke(origCls.getConstructor().newInstance()));, + } catch (Exception e) {, + rethrow("Original check failed", e);, + limitExecTime(() -> invoke("check"));, + } catch (Exception e) {, + rethrow("Decompiled check failed", e);, + private <T> T limitExecTime(Callable<T> call) {, + ExecutorService executor = Executors.newSingleThreadExecutor();, + Future<T> future = executor.submit(call);, + try {, + return future.get(5, TimeUnit.SECONDS);, + } catch (TimeoutException ex) {, + future.cancel(true);, + rethrow("Execution timeout", ex);, + } catch (Exception ex) {, + rethrow(ex.getMessage(), ex);, + } finally {, + executor.shutdownNow();, + },
[+++ b/.travis.yml, +env:, + - TERM=dumb, +, + - sed -i " 1 s/.*/&-b$TRAVIS_BUILD_NUMBER-$(git rev-parse --short HEAD)/" version, + - cat version, + - sed -i "s/BUILD_VERSION/$(head -c -1 version)/g" bintray.json, + - ./gradlew clean build, + - ./gradlew clean build jacocoTestReport, + - ./gradlew clean sonarqube -Dsonar.host.url=$SONAR_HOST -Dsonar.organization=$SONAR_ORG -Dsonar.login=$SONAR_TOKEN, + - ./gradlew clean dist, +, +deploy:, + provider: bintray, + file: bintray.json, + user: skylot, + key:, + secure: bBzfhraRwT5w+FkAcQnWJQgt4i894k595g4gNFf8dGpBsvPUvGzoa/SUaokrmlj5UCFc12k7j6aZswNITGjBuAf2fDVRwMQCH9ORiqIcJWuemQPHB7iAQjITGXKwef6zWKcZSkVuMtUMmGymYSsqpya+pSqwdP5rLbWPgGixEaQ=, + skip_cleanup: true, + on:, + branch: master, + tags: false, +++ b/.travis.yml, +env:, + - TERM=dumb, +, + - sed -i " 1 s/.*/&-b$TRAVIS_BUILD_NUMBER-$(git rev-parse --short HEAD)/"
[+++ b/.travis.yml, + edge:, + branch: v1.8.47, + key: $BINTRAY_KEY]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +, + stack.push(loopRegion);, + stack.pop();, + && outAttrs.get(AttributeType.LOOP) != loop, + && stack.peekRegion() instanceof LoopRegion, + && RegionUtils.isRegionContainsBlock(stack.peekRegion(), out)) {, +, + stack.push(loopRegion);, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +, + stack.push(loopRegion);, + stack.pop();, + && outAttrs.get(AttributeType.LOOP) != loop, + && stack.peekRegion() instanceof LoopRegion, + && RegionUtils.isRegionContainsBlock(stack.peekRegion(), out)) {, +, + stack.push(loopRegion);, + }, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +, + stack.push(loopRegion);, + stack.pop();, + && outAttrs.get(AttributeType.LOOP) != loop, + && stack.peekRegion() instanceof LoopRegion, + && RegionUtils.isRegionContainsBlock(stack.peekRegion(), out)) {, +, + stack.push(loopRegion);, + }, +++ /dev/null, +++ b/jadx-core/src/test/java/jadx/tests/internal/loops/TestLoopCondition.java, +package jadx.tests.internal.loops;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import
[+++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.utils.logs.LogCollector;, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.utils.logs.LogCollector;, +++ b/jadx-gui/src/main/java/jadx/gui/ui/LogViewer.java, +import jadx.gui.utils.logs.ILogListener;, +import jadx.gui.utils.logs.LogCollector;, + logCollector.registerListener(new ILogListener() {, + SwingUtilities.invokeLater(() -> textPane.append(logStr));, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.utils.logs.LogCollector;, +++ b/jadx-gui/src/main/java/jadx/gui/ui/LogViewer.java, +import jadx.gui.utils.logs.ILogListener;, +import jadx.gui.utils.logs.LogCollector;, + logCollector.registerListener(new ILogListener() {, + SwingUtilities.invokeLater(() -> textPane.append(logStr));, +++ /dev/null, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.utils.logs.LogCollector;, +++ b/jadx-gui/src/main/java/jadx/gui/ui/LogViewer.java, +import jadx.gui.utils.logs.ILogListener;, +import jadx.gui.utils.logs.LogCollector;, + logCollector.registerListener(new ILogListener() {, + SwingUtilities.invokeLater(() -> textPane.append(logStr));, +++ /dev/null, +++ b/jadx-gui/src/main/java/jadx/gui/utils/logs/ILogListener.java, +package jadx.gui.utils.logs;, +, +import ch.qos.logback.classic.Level;, +, +public interface ILogListener {, + Level getFilterLevel();, +, + void onAppend(String logStr);, +}, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.utils.logs.LogCollector;, +++ b/jadx-gui/src/main/java/jadx/gui/ui/LogViewer.java, +import jadx.gui.utils.logs.ILogListener;, +import jadx.gui.utils.logs.LogCollector;, + logCollector.registerListener(new ILogListener() {, + SwingUtilities.invokeLater(()
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + assert isFallback() : "if insn in not fallback mode";, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + assert isFallback() : "if insn in not fallback mode";, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import jadx.core.dex.instructions.args.PrimitiveType;, + if (accFlags.isPublic()) {, + }, + public FieldNode getConstField(Object obj) {, + return getConstField(obj, true);, + }, +, + public FieldNode getConstField(Object obj, boolean searchGlobal) {, + field = cn.constFields.get(obj);, + if (field == null && searchGlobal) {, + field = dex.getConstFields().get(obj);, + }, + PrimitiveType type = arg.getType().getPrimitiveType();, + if (type == null) {, + return null;, + }, + switch (type) {, + case BOOLEAN:, + return getConstField(literal
[+++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, + private final JavaNode node;, + public CodePosition(JavaNode node, int line, int offset) {, + this.node = node;, + this.node = null;, + public JavaNode getNode() {, + return node;, + }, +, + JavaClass parent = node.getDeclaringClass();, + if (parent == null && node instanceof JavaClass) {, + return (JavaClass) node;, + }, + return parent;, + return line + ":" + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, + private final JavaNode node;, + public CodePosition(JavaNode node, int line, int offset) {, + this.node = node;, + this.node
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, + recentFiles.subList(RECENT_FILES_COUNT, count).clear();]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, +import java.util.Collections;, +import java.util.HashSet;, +import java.util.Set;, +import jadx.core.dex.attributes.AType;, +import jadx.core.dex.attributes.nodes.RegDebugInfoAttr;, +import jadx.core.dex.nodes.MethodNode;, +, + public String getDetailedVarInfo(MethodNode mth) {, + Set<ArgType> types = new HashSet<>();, + Set<String> names = Collections.emptySet();, +, + List<RegisterArg> useArgs = new ArrayList<>(1 + useList.size());, + useArgs.add(assign);, + useArgs.addAll(useList);, +, + if (mth.contains(AType.LOCAL_VARS_DEBUG_INFO)) {, + names = new HashSet<>();, + for (RegisterArg arg : useArgs) {, + RegDebugInfoAttr debugInfoAttr = arg.get(AType.REG_DEBUG_INFO);, + if (debugInfoAttr != null) {, + names.add(debugInfoAttr.getName());, + types.add(debugInfoAttr.getRegType());, + }, + }, + }, +, + for (RegisterArg arg : useArgs) {, + ArgType initType = arg.getInitType();, + if (initType.isTypeKnown())
[+++ b/build.gradle, + compile 'org.slf4j:slf4j-api:1.7.5', + compile 'ch.qos.logback:logback-classic:1.0.11', + testCompile 'junit:junit:4.11', + gradleVersion = '1.5', +++ b/build.gradle, + compile 'org.slf4j:slf4j-api:1.7.5', + compile 'ch.qos.logback:logback-classic:1.0.11', + testCompile 'junit:junit:4.11', + gradleVersion = '1.5', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, + compile 'org.slf4j:slf4j-api:1.7.5', + compile 'ch.qos.logback:logback-classic:1.0.11', + testCompile 'junit:junit:4.11', + gradleVersion = '1.5', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.5-bin.zip]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, + , + String nsValue = getString(beginPrefix);, + if(!nsMap.containsValue(nsValue)) {, + nsMap.putIfAbsent(getString(beginURI), nsValue);, + }, + , + String nsValue = getString(endPrefix);, + if(!nsMap.containsValue(nsValue)) {, + nsMap.putIfAbsent(getString(endURI), nsValue);, + }]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/AboutDialog.java, + String javaVer = System.getProperty("java.version");]
[+++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, + LOG.debug("Class not found: {}", fullName);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, + LOG.debug("Class not found: {}", fullName);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, + this.fullName = makeFullClsName(clsName);, +, + public String makeFullClsName(String shortName) {, + if (parentClass != null) {, + return parentClass.fullName + "." + shortName;, + }, + return pkg.isEmpty() ? shortName : pkg + "." + shortName;, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, + LOG.debug("Class not found: {}", fullName);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, + this.fullName = makeFullClsName(clsName);, +, + public String makeFullClsName(String shortName) {, + if (parentClass != null) {, + return parentClass.fullName + "." + shortName;, + }, + return pkg.isEmpty() ? shortName : pkg +
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, + writer.print(strings[attributeName] + "=\"");, + if(attrValDataType==0x3) writer.print(strings[attrValData]);, + else if(attrValDataType==0x10) writer.print(attrValData);, + if(attrValData==0) writer.print("false");, + else if(attrValData==1 || attrValData==-1) writer.print("true");, + else writer.print("UNKNOWN_BOOLEAN_TYPE");, + } else if(attrValDataType==0x1) writer.print("0x" + Integer.toHexString(attrValData));, + else writer.print("UNKNOWN_DATA_TYPE_" + attrValDataType);, + writer.print("\"");]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"--deobf"}, description = "activate deobfuscation"), + protected boolean deobfuscationOn = false;, +, + @Parameter(names = {"--deobf-min"}, description = "min length of name"), + protected int deobfuscationMinLength = 2;, +, + @Parameter(names = {"--deobf-max"}, description = "max length of name"), + protected int deobfuscationMaxLength = 40;, +, + @Parameter(names = {"--deobf-rewrite-cfg"}, description = "force to save deobfuscation map"), + protected boolean deobfuscationForceSave = false;, +, +, + @Override, + public boolean isDeobfuscationOn() {, + return deobfuscationOn;, + }, +, + @Override, + public int getDeobfuscationMinLength() {, + return deobfuscationMinLength;, + }, +, + @Override, +
[+++ b/.travis.yml, + if: branch = master AND env(BINTRAY_KEY) IS present]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + if(f.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, + continue;, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + if(f.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, + continue;, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.attributes.AttributeFlag;, + FieldNode fieldNode = mth.getParentClass().searchField(field);, + if(fieldNode != null && fieldNode.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, + return "";, + }, + // TODO: add jadx argument "add this", + String argStr = arg(arg);, + return argStr.isEmpty() ? name : argStr + "." + name;, + ClassNode cls = mth.dex().resolveClass(insn.getClassType());, + return;, + }, + if (insn.isSelf()) {, + return;, + }, + if (insn.isSuper()) {, + code.add("super");, + } else if (insn.isThis()) {, + code.add("this");, + generateArguments(code, insn, 0, mth.dex().resolveMethod(insn.getCallMth()));,
[+++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, + public Integer getSourceLine(int decompiledLine) {, + decompile();, + return cls.getCode().getLineMapping().get(decompiledLine);, + }, +, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, + public Integer getSourceLine(int decompiledLine) {, + decompile();, + return cls.getCode().getLineMapping().get(decompiledLine);, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, + public Integer getSourceLine(int decompiledLine) {, + decompile();, + return cls.getCode().getLineMapping().get(decompiledLine);, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, + private Map<Integer, Integer> lineMap = Collections.emptyMap();, + for (Map.Entry<Integer, Integer> entry : code.lineMap.entrySet()) {, + attachSourceLine(line + entry.getKey(), entry.getValue());, + }, + public CodeWriter addIndent() {, + add(INDENT);, + return this;, + }, +, + private void attachSourceLine(int decompiledLine, int sourceLine) {, + if
[+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, + code.startLineWithNum(region.getConditionSourceLine());, + code.add("} while (");, + code.startLineWithNum(region.getConditionSourceLine());, + code.add("while (");, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, + code.startLineWithNum(region.getConditionSourceLine());, + code.add("} while (");, + code.startLineWithNum(region.getConditionSourceLine());, + code.add("while (");, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, +, +import org.jetbrains.annotations.Nullable;, + /**, + * loop header contains one 'if' insn, equals null for infinite loop, + */, + @Nullable, + public LoopRegion(IRegion parent, LoopInfo info, @Nullable BlockNode header, boolean reversed) {, + public int getConditionSourceLine() {, + if (conditionBlock != null) {, + List<InsnNode> condInsns = conditionBlock.getInstructions();, + if (!condInsns.isEmpty()) {, + return condInsns.get(0).getSourceLine();, + }, + }, + return 0;, +
[+++ b/jadx-core/src/main/java/jadx/api/JavaField.java, + return field.getAlias();, + return parent.getFullName() + "." + getName();, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, + return field.getAlias();, + return parent.getFullName() + "." + getName();, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, + return mth.getAlias();, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, + return field.getAlias();, + return parent.getFullName() + "." + getName();, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, + return mth.getAlias();, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, + return field.getAlias();, + return parent.getFullName() + "." + getName();, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, + return mth.getAlias();, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, + return field.getAlias();, + return parent.getFullName() + "." + getName();, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, + return mth.getAlias();, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + code.add(f.getAlias());, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, + return field.getAlias();,
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java]
[+++ b/jadx-gui/src/main/java/jadx/gui/MainWindow.java, +import jadx.gui.utils.NLS;, +import jadx.gui.utils.Utils;, +import javax.swing.AbstractAction;, +import javax.swing.KeyStroke;, +import java.awt.event.InputEvent;, + private static final ImageIcon ICON_SEARCH = Utils.openIcon("magnifier");, + private JToolBar searchToolBar;, + private SearchBar searchBar;, + private void toggleSearch() {, + searchBar.toggle();, + }, +, + final JToggleButton flatPkgButton = new JToggleButton(ICON_FLAT_PKG);, + toolbar.addSeparator();, +, + final JButton searchButton = new JButton(ICON_SEARCH);, + searchButton.addActionListener(new ActionListener() {, + @Override, + public void actionPerformed(ActionEvent e) {, + toggleSearch();, + }, + });, + searchButton.setToolTipText(NLS.str("search"));, + toolbar.add(searchButton);, +, + KeyStroke key = KeyStroke.getKeyStroke(KeyEvent.VK_F, InputEvent.CTRL_MASK);, + Utils.addKeyBinding(textArea, key, "SearchAction", new AbstractAction() {, + @Override, + public void actionPerformed(ActionEvent e) {,
[+++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, + if (!this.getFullName().contains(fileName.replace(".java", "")), + && !fileName.equals("SourceFile")) {, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, + if (!this.getFullName().contains(fileName.replace(".java", "")), + && !fileName.equals("SourceFile")) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + BlockNode loopExit = BlockUtils.selectOtherSafe(loopBody, condBlock.getCleanSuccessors());, + if (loopExit != null) {, + }, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, + if (!this.getFullName().contains(fileName.replace(".java", "")), + && !fileName.equals("SourceFile")) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + BlockNode loopExit = BlockUtils.selectOtherSafe(loopBody, condBlock.getCleanSuccessors());, + if (loopExit != null) {, + }, +++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, + public static BlockNode selectOtherSafe(BlockNode node, List<BlockNode> blocks) {, + int size = blocks.size();, + if (size == 1) {, + BlockNode first = blocks.get(0);, + return
[+++ /dev/null, +++ /dev/null, +++ b/.gitignore, +*.orig, +++ /dev/null, +++ b/.gitignore, +*.orig, +++ b/build.gradle, +build.dependsOn(dist, samples), +++ /dev/null, +++ b/.gitignore, +*.orig, +++ b/build.gradle, +build.dependsOn(dist, samples), +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ /dev/null, +++ b/.gitignore, +*.orig, +++ b/build.gradle, +build.dependsOn(dist, samples), +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-cli/src/main/resources/logback.xml, +, +, +++ /dev/null, +++ b/.gitignore, +*.orig, +++ b/build.gradle, +build.dependsOn(dist, samples), +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-cli/src/main/resources/logback.xml, +, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ /dev/null, +++ b/.gitignore, +*.orig, +++ b/build.gradle, +build.dependsOn(dist, samples), +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, + ClassInfo alias = getAlias();, + return alias.getPackage().replace('.', File.separatorChar), + + alias.getNameWithoutPackage().replace('.', '_');]
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import java.awt.Font;, +import java.awt.GraphicsDevice;, +import java.awt.GraphicsEnvironment;, +import java.awt.Window;, + if (pos == null || !isContainedInAnyScreen(pos)) {, +, + private static boolean isContainedInAnyScreen(WindowLocation pos) {, + for (GraphicsDevice gd : GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices()) {, + if (gd.getDefaultConfiguration().getBounds().contains(, + pos.getX(), pos.getY(), pos.getWidth(), pos.getHeight())) {, + return true;, + }, + }, + return false;, + }, +]
[+++ b/src/main/java/jadx/codegen/RegionGen.java, +import jadx.dex.regions.IfCondition;, + code.add("if (").add(makeCondition(region.getCondition())).add(") {");, + List<IContainer> subBlocks = re.getSubBlocks();, + if (subBlocks.size() == 1 && subBlocks.get(0) instanceof IfRegion) {, + makeIf((IfRegion) subBlocks.get(0), code);, + IfCondition condition = region.getCondition();, + if (condition == null) {, + if (region.isConditionAtEnd()) {, + code.startLine("} while (").add(makeCondition(condition)).add(");");, + } else {, + code.startLine("while (").add(makeCondition(condition)).add(") {");, + makeRegionIndent(code, region.getBody());, + code.startLine('}');, + private String makeCondition(IfCondition condition) throws CodegenException {, + switch (condition.getMode()) {, + case COMPARE:, + return makeCompare(condition.getCompare());, + case NOT:, + return "!" + makeCondition(condition.getArgs().get(0));, + case AND:, + case OR:, + String mode = condition.getMode() == IfCondition.MODE.AND ?
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, + passes.add(new
[+++ b/jadx-gui/src/main/java/jadx/gui/MainWindow.java, +import javax.swing.ImageIcon;, +import javax.swing.JButton;, +import javax.swing.JToggleButton;, +import javax.swing.JToolBar;, +import javax.swing.tree.TreePath;, + private static final String DEFAULT_TITLE = "jadx-gui";, + private static final Color BACKGROUND = new Color(0xf7f7f7);, +, + private static final ImageIcon ICON_OPEN = Utils.openIcon("folder");, + private static final ImageIcon ICON_CLOSE = Utils.openIcon("cross");, + private static final ImageIcon ICON_FLAT_PKG = Utils.openIcon("empty_logical_package_obj");, + initMenuAndToolbar();, +// expandTree();, + }, +, + private void toggleFlattenPackage() {, + Object root = treeModel.getRoot();, + if (root instanceof JRoot) {, + JRoot treeRoot = (JRoot) root;, + treeRoot.setFlatPackages(!treeRoot.isFlatPackages());, + treeModel.reload();, + tree.expandRow(0);, + }, + }, +, + private void expandTree() {,
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"-r", "--no-res"}, description = "do not decode resources"), + protected boolean skipResources = false;, +, + @Parameter(names = {"-s", "--no-src"}, description = "do not decompile source code"), + protected boolean skipSources = false;, +, + public boolean isSkipResources() {, + return skipResources;, + }, +, + @Override, + public boolean isSkipSources() {, + return skipSources;, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"-r", "--no-res"}, description = "do not decode resources"), + protected boolean skipResources = false;, +, + @Parameter(names = {"-s", "--no-src"}, description = "do not decompile source code"), + protected boolean skipSources = false;, +,
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, + public boolean canBeObject() {, + return isObject() || (!isTypeKnown() && contains(PrimitiveType.OBJECT));, + }, +, + public boolean canBeArray() {, + return isArray() || (!isTypeKnown() && contains(PrimitiveType.ARRAY));, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, + public boolean canBeObject() {, + return isObject() || (!isTypeKnown() && contains(PrimitiveType.OBJECT));, + }, +, + public boolean canBeArray() {, + return isArray() || (!isTypeKnown() && contains(PrimitiveType.ARRAY));, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java, + TypeUpdateResult result = updateTypeChecked(updateInfo, updateArg, candidateType);, + if (result == REJECT) {, + // soft checks for objects and array - exact type not compared, + ArgType updateArgType = updateArg.getType();, + if
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, + if (iterVar == null) {, + return false;, + }, + if (!fixIterableType(mth, iterableArg, iterVar)) {, + return false;, + }, + if (iterVar == null || !fixIterableType(mth, iterableArg, iterVar)) {, + return false;, + }, + private static boolean fixIterableType(MethodNode mth, InsnArg iterableArg, RegisterArg iterVar) {, + if (ArgType.isInstanceOf(mth.dex(), gType, varType)) {, + ArgType wildcardType = gType.getWildcardType();, + if (wildcardType != null, + && gType.getWildcardBounds() == 1, + && ArgType.isInstanceOf(mth.dex(), wildcardType, varType)) {, + return true;, + }, + LOG.warn("Generic type differs: '{}' and '{}' in {}", gType, varType, mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, + if (iterVar
[+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, + addArg(code, arg, false);, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, + addArg(code, arg, false);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + domsOn.xor(succ); // filter 'out' block, + List<BlockNode> blocks = mth.getBasicBlocks();, + BlockNode b = blocks.get(i);, + domsOn.clear(s.getId());, + // one or several case blocks are empty,, + // run expensive algorithm for find 'out' block, + for (BlockNode maybeOut : block.getSuccessors()) {, + boolean allReached = true;, + for (BlockNode s : block.getSuccessors()) {, + if (!BlockUtils.isPathExists(s, maybeOut)) {, + allReached = false;, + break;, + }, + }, + if (allReached) {, + out = maybeOut;, + break;, + }, + }, +++
[+++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +import java.util.List;, +, +import org.jetbrains.annotations.Nullable;, +, + synchronized (getSyncObj(cls)) {, + public static Object getSyncObj(ClassNode cls) {, + return cls.getClassInfo();, + }, +, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +import java.util.List;, +, +import org.jetbrains.annotations.Nullable;, +, + synchronized (getSyncObj(cls)) {, + public static Object getSyncObj(ClassNode cls) {, + return cls.getClassInfo();, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, + int len = NL.length();, + if (buf.substring(0, len).equals(NL)) {, + buf.delete(0, len);, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, +import java.util.List;, +, +import org.jetbrains.annotations.Nullable;, +, + synchronized (getSyncObj(cls)) {, + public static Object getSyncObj(ClassNode cls) {, + return cls.getClassInfo();, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, + int len = NL.length();, + if
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import java.util.Comparator;, + public static final Comparator<MethodNode> METHOD_LINE_COMPARATOR = new Comparator<MethodNode>() {, + @Override, + public int compare(MethodNode a, MethodNode b) {, + return Utils.compare(a.getSourceLine(), b.getSourceLine());, + }, + };, +, + List<MethodNode> methods = sortMethodsByLine(cls.getMethods());, + for (MethodNode mth : methods) {, + private static List<MethodNode> sortMethodsByLine(List<MethodNode> methods) {, + List<MethodNode> out = new ArrayList<MethodNode>(methods);, + Collections.sort(out, METHOD_LINE_COMPARATOR);, + return out;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import java.util.Comparator;, + public static final Comparator<MethodNode> METHOD_LINE_COMPARATOR = new Comparator<MethodNode>() {, + @Override, + public int compare(MethodNode a, MethodNode b) {, + return Utils.compare(a.getSourceLine(), b.getSourceLine());, + }, + };,
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, + return getConstField((char) literal, Math.abs(literal) > 10);, + return getConstField((byte) literal, Math.abs(literal) > 10);, + return getConstField((short) literal, Math.abs(literal) > 100);, + return getConstField((int) literal, Math.abs(literal) > 100);, + return getConstField(literal, Math.abs(literal) > 1000);, + float f = Float.intBitsToFloat((int) literal);, + return getConstField(f, f != 0.0);, + double d = Double.longBitsToDouble(literal);, + return getConstField(d, d != 0);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, + return getConstField((char) literal, Math.abs(literal) > 10);, + return getConstField((byte) literal, Math.abs(literal) > 10);, + return getConstField((short) literal, Math.abs(literal) > 100);, + return getConstField((int) literal, Math.abs(literal) > 100);, + return getConstField(literal, Math.abs(literal) > 1000);, + float f =
[+++ b/.gitignore, +.attach_pid*, +++ b/.gitignore, +.attach_pid*, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + if (mth.getMethodInfo().isRenamed() && !ai.isConstructor()) {, + if (ai.isConstructor()) {, +++ b/.gitignore, +.attach_pid*, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + if (mth.getMethodInfo().isRenamed() && !ai.isConstructor()) {, + if (ai.isConstructor()) {, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, + mth.setAlias(String.format("mo%d%s", id, prepareNamePart(mth.getName())));, + alias = String.format("C%04d%s", clsIndex++, prepareNamePart(clsName));, + String alias = String.format("f%d%s", fldIndex++, prepareNamePart(field.getName()));, + String alias = String.format("m%d%s", mthIndex++, prepareNamePart(mth.getName()));, + String pkgAlias = String.format("p%03d%s", pkgIndex++, prepareNamePart(pkgName));, + int len = s.length();, + return len < minLength || len > maxLength, + || !NameMapper.isValidIdentifier(s);, + private String prepareNamePart(String name) {, +++ b/.gitignore, +.attach_pid*, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + if (mth.getMethodInfo().isRenamed() && !ai.isConstructor())
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, + passes.add(new DebugInfoParseVisitor());, + passes.add(new BlockProcessor());, + passes.add(new BlockExceptionHandler());, + passes.add(new BlockFinish());, +, + passes.add(new SSATransform());, + passes.add(new ConstructorVisitor());, + passes.add(new InitCodeVariables());, + passes.add(new MarkFinallyVisitor());, + passes.add(new TypeInferenceVisitor());, + passes.add(new DebugInfoApplyVisitor());, + passes.add(new CleanRegions());, + passes.add(new ProcessVariables());, + passes.add(new
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +import java.util.LinkedHashSet;, + Set<ClassNode> clsParents = new LinkedHashSet<>();, + collectClassHierarchy(mth.getParentClass(), clsParents);, +, + Set<MethodInfo> overrideSet = new LinkedHashSet<>();, + for (ClassNode classNode : clsParents) {, + MethodInfo methodInfo = getMthOverride(classNode.getMethods(), mthSignature);, + if (methodInfo != null) {, + overrideSet.add(methodInfo);, + if (overrideSet.isEmpty()) {, + return;, + }, + OverridedMethodsNode overrideNode = getOverrideMethodsNode(overrideSet);, + for (MethodInfo overrideMth : overrideSet) {, + if (!ovrdMap.containsKey(overrideMth)) {, + ovrdMap.put(overrideMth, overrideNode);, + overrideNode.add(overrideMth);, +, + private OverridedMethodsNode getOverrideMethodsNode(Set<MethodInfo> overrideSet) {, + for (MethodInfo overrideMth : overrideSet) {, + OverridedMethodsNode node = ovrdMap.get(overrideMth);, + if (node != null) {, + return node;, +
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p/>, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p/>, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + FieldNode fieldNode = pCls.searchField(field);, + while (fieldNode == null, + && pCls.getParentClass() != pCls, + && pCls.getParentClass() != null) {, + pCls = pCls.getParentClass();, + fieldNode = pCls.searchField(field);, + }, + FieldNode fieldNode = clsGen.getClassNode().dex().resolveField(field);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p/>, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + FieldNode fieldNode = pCls.searchField(field);, + while (fieldNode == null, + && pCls.getParentClass() != pCls, + && pCls.getParentClass() != null) {, + pCls = pCls.getParentClass();, + fieldNode = pCls.searchField(field);, + }, + FieldNode fieldNode = clsGen.getClassNode().dex().resolveField(field);, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, + ArgType superClass = cls.getSuperClass();, +
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +import java.util.Random;, + private final Map<String, String> tagAttrDeobfNames = new HashMap<>();, + currentTag = getValidTagAttributeName(getString(startNSName));, + String attrName = getValidTagAttributeName(getAttributeName(attributeName));, + String elemName = getValidTagAttributeName(getString(elementNameId));, + , + private String getValidTagAttributeName(String originalName) {, + if(XMLChar.isValidName(originalName)) {, + return originalName;, + }, + if(tagAttrDeobfNames.containsKey(originalName)) {, + return tagAttrDeobfNames.get(originalName);, + }, + String generated;, + do {, + generated = generateTagAttrName();, + }, + while(tagAttrDeobfNames.containsValue(generated));, + tagAttrDeobfNames.put(originalName, generated);, + return generated;, + }, + , + private static String generateTagAttrName() {, + final int length = 6;, + Random r = new Random();, + StringBuilder sb = new StringBuilder();,
[+++ b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java, + if(c >= 0 && c <= 0x1F) {, + return "\\" + (int) c;, + }, + case '\\':, + return "\\\\";]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ReSugarCode;, + passes.add(new ReSugarCode());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ReSugarCode;, + passes.add(new ReSugarCode());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + addArg(code, insn.getArg(i), false);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ReSugarCode;, + passes.add(new ReSugarCode());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + addArg(code, insn.getArg(i), false);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ReSugarCode.java, +package jadx.core.dex.visitors;, +, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.instructions.args.LiteralArg;, +import jadx.core.dex.nodes.BlockNode;, +import jadx.core.dex.nodes.InsnNode;, +import jadx.core.dex.nodes.MethodNode;, +import jadx.core.utils.InstructionRemover;, +import jadx.core.utils.exceptions.JadxException;, +, +import java.util.List;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +public class ReSugarCode extends AbstractVisitor {, + private static final Logger LOG = LoggerFactory.getLogger(ReSugarCode.class);, +, + @Override, + public void visit(MethodNode mth) throws JadxException {, + if (mth.isNoCode()) {, + return;, + }, + InstructionRemover remover
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, + if (!dir.mkdirs() && !dir.isDirectory()) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, + if (!dir.mkdirs() && !dir.isDirectory()) {, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, + private final Map<String, JavaClassObject> clsMap = new HashMap<>();, + private final Map<String, Class<?>> clsCache = new HashMap<>();]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +/*, +*/]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + if (threadsCount <= 0) {, + }, + if (file.exists()) {, + } else {, + }, + if (input.size() > 1) {, + }, + if (outDirName != null) {, + }, + if (len > maxNamesLen) {, + }, + for (int i = 0; i < count; i++) {, + }, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + if (threadsCount <= 0) {, + }, + if (file.exists()) {, + } else {, + }, + if (input.size() > 1) {, + }, + if (outDirName != null) {, + }, + if (len > maxNamesLen) {,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + boolean wrap = state.contains(Flags.BODY_ONLY), + && !insn.getAttributes().contains(AttributeFlag.DONT_WRAP);, + if (wrap) {, + }, + code.add(insn.getOp().getSymbol());, + if (wrap) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + boolean wrap = state.contains(Flags.BODY_ONLY), + && !insn.getAttributes().contains(AttributeFlag.DONT_WRAP);, + if (wrap) {, + }, + code.add(insn.getOp().getSymbol());, + if (wrap) {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeFlag.java, + DONT_WRAP,, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + boolean wrap = state.contains(Flags.BODY_ONLY), + && !insn.getAttributes().contains(AttributeFlag.DONT_WRAP);, + if (wrap) {, + }, + code.add(insn.getOp().getSymbol());, + if (wrap) {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeFlag.java, + DONT_WRAP,, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java, +import jadx.core.dex.attributes.AttributeFlag;, +import jadx.core.dex.instructions.ArithOp;, +import jadx.core.dex.instructions.args.InsnWrapArg;, + removeBrackets(block);, + private static void removeBrackets(BlockNode block) {, + for (InsnNode insn : block.getInstructions()) {, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +, + default:, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +, + default:, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/PrepareForCodeGen.java, +/**, + * Prepare instructions for code generation pass,, + * most of this modification breaks register dependencies,, + * so this pass must be just before CodeGen., + */, + checkInline(block);, + removeParenthesis(block);, + private static void checkInline(BlockNode block) {, + List<InsnNode> list = block.getInstructions();, + for (int i = 0; i < list.size(); i++) {, + InsnNode insn = list.get(i);, + // replace 'move' with inner wrapped instruction, + if (insn.getType() == InsnType.MOVE, + && insn.getArg(0).isInsnWrap(), + && !insn.getAttributes().contains(AttributeFlag.DECLARE_VAR)) {, +
[+++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, + private static void addFilesFromDirectory(File dir,, + List<InputFile> inputFiles) throws IOException, DecodeException {, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, + private static void addFilesFromDirectory(File dir,, + List<InputFile> inputFiles) throws IOException, DecodeException {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ArithNode.java, + public boolean isSame(InsnNode obj) {, + if (!(obj instanceof ArithNode) || !super.isSame(obj)) {, + ArithNode other = (ArithNode) obj;, + return op == other.op;, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, + private static void addFilesFromDirectory(File dir,, + List<InputFile> inputFiles) throws IOException, DecodeException {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ArithNode.java, + public boolean isSame(InsnNode obj) {, + if (!(obj instanceof ArithNode) || !super.isSame(obj)) {, + ArithNode other = (ArithNode) obj;, + return op == other.op;,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + code.newLine().addMultiLine(ErrorsCounter.methodError(mth, "Method generation error", e));, + code.newLine().addMultiLine(Utils.getStackTrace(e));, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + code.newLine().addMultiLine(ErrorsCounter.methodError(mth, "Method generation error", e));, + code.newLine().addMultiLine(Utils.getStackTrace(e));, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +, + /**, + * RegisterArg attribute for method arguments, + */, + METHOD_ARGUMENT,, +, + /**, + * Type of RegisterArg or SSAVar can't be changed, + */, + IMMUTABLE_TYPE,, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + code.newLine().addMultiLine(ErrorsCounter.methodError(mth, "Method generation error", e));, + code.newLine().addMultiLine(Utils.getStackTrace(e));, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, +, + /**, + * RegisterArg attribute for method arguments, + */, + METHOD_ARGUMENT,, +, + /**, + * Type of RegisterArg or SSAVar can't be changed, + */, + IMMUTABLE_TYPE,, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.TernaryVisitor;, + passes.add(new RegionMakerVisitor());, + passes.add(new TernaryVisitor());, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.TernaryVisitor;, + passes.add(new RegionMakerVisitor());, + passes.add(new TernaryVisitor());, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +package jadx.core.codegen;, +, +import jadx.core.dex.instructions.ArithNode;, +import jadx.core.dex.instructions.IfOp;, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.instructions.args.InsnWrapArg;, +import jadx.core.dex.instructions.args.LiteralArg;, +import jadx.core.dex.nodes.InsnNode;, +import jadx.core.dex.regions.Compare;, +import jadx.core.dex.regions.IfCondition;, +import jadx.core.utils.ErrorsCounter;, +import jadx.core.utils.exceptions.CodegenException;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +public class ConditionGen {, + private static final Logger LOG = LoggerFactory.getLogger(ConditionGen.class);, +, + static String make(InsnGen insnGen, IfCondition condition) throws CodegenException {, + switch (condition.getMode()) {, + case COMPARE:, + return makeCompare(insnGen, condition.getCompare());, + case NOT:, + return "!(" + make(insnGen,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (arg.contains(AFlag.SKIP_ARG)) {, + if (i != k) {, + code.add(", ");, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (arg.contains(AFlag.SKIP_ARG)) {, + if (i != k) {, + code.add(", ");, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java, + AttributeStorage copyFrom = attrNode.storage;, + if (!copyFrom.isEmpty()) {, + initStorage().addAll(copyFrom);, + }, + private AttributeStorage initStorage() {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (arg.contains(AFlag.SKIP_ARG)) {, + if (i != k) {, + code.add(", ");, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java, + AttributeStorage copyFrom = attrNode.storage;, + if (!copyFrom.isEmpty()) {, + initStorage().addAll(copyFrom);, + }, + private AttributeStorage initStorage() {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java, + public boolean isEmpty() {, + return flags.isEmpty() && attributes.isEmpty();, + },
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java, + BlockNode handlerBlock = excHandler.getHandlerBlock();, + if (handlerBlock != null) {, + SplitterBlockAttr splitter = handlerBlock.get(AType.SPLITTER_BLOCK);, + }, + BlockNode handlerBlock = h.getHandlerBlock();, + if (handlerBlock != null, + && RegionUtils.hasPathThroughBlock(handlerBlock, cont)) {]
[+++ b/.DS_Store, +++ b/.DS_Store, +++ b/jadx-core/.DS_Store, +++ b/.DS_Store, +++ b/jadx-core/.DS_Store, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.files.ZipSecurity;, + , + if(!ZipSecurity.isValidZipEntry(entry)) {, + return null;, + }, + , + if(ZipSecurity.isValidZipEntry(entry)) {, + }, +++ b/.DS_Store, +++ b/jadx-core/.DS_Store, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.files.ZipSecurity;, + , + if(!ZipSecurity.isValidZipEntry(entry)) {, + return null;, + }, + , + if(ZipSecurity.isValidZipEntry(entry)) {, + }, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.utils.files.ZipSecurity;, + if (entry.getName().endsWith(CLST_EXTENSION) && ZipSecurity.isValidZipEntry(entry)) {, +++ b/.DS_Store, +++ b/jadx-core/.DS_Store, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.files.ZipSecurity;, + , + if(!ZipSecurity.isValidZipEntry(entry)) {, + return null;, + }, + , + if(ZipSecurity.isValidZipEntry(entry)) {, + }, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.utils.files.ZipSecurity;, + if (entry.getName().endsWith(CLST_EXTENSION) &&
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + public void makeInsn(InsnNode insn, CodeWriter code) throws CodegenException {, + makeInsn(insn, code, null);, + protected void makeInsn(InsnNode insn, CodeWriter code, Flags flag) throws CodegenException {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + public void makeInsn(InsnNode insn, CodeWriter code) throws CodegenException {, + makeInsn(insn, code, null);, + protected void makeInsn(InsnNode insn, CodeWriter code, Flags flag) throws CodegenException {, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.dex.attributes.nodes.JumpInfo;, +import jadx.core.dex.instructions.IfNode;, + ArgType argType = var.getType();, + mth.unload();, + InsnNode prevInsn = null;, + if (addLabels && needLabel(insn, prevInsn)) {, + code.startLine();, + RegisterArg resArg = insn.getResult();, + if (resArg != null) {, + ArgType varType = resArg.getInitType();,
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java, + Region newRegion = wrapBlocks(region, dominator);, + if (newRegion != null) {, + // dominator may be moved into new region, + leaveRegion(mth, newRegion);, + }, + private Region wrapBlocks(IRegion region, BlockNode dominator) {, + return null;, + , + return newRegion;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java, + Region newRegion = wrapBlocks(region, dominator);, + if (newRegion != null) {, + // dominator may be moved into new region, + leaveRegion(mth, newRegion);, + }, + private Region wrapBlocks(IRegion region, BlockNode dominator) {, + return null;, + , + return newRegion;, +++ b/jadx-core/src/test/java/jadx/tests/internal/trycatch/TestNestedTryCatch.java, +package jadx.tests.internal.trycatch;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, + passes.add(new DebugInfoParseVisitor());, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new ConstructorVisitor());, + passes.add(new TypeInferenceVisitor());, + passes.add(new DebugInfoApplyVisitor());, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, + passes.add(new DebugInfoParseVisitor());, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, +
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java, +import static jadx.core.xmlgen.ParserConstants.PLURALS_MAP;, +, + switch (typeName) {, + case "attr":, + if (nameStr != null), + break;, + case "style":, + if (nameStr != null), + break;, + case "plurals":, + final String quantity = PLURALS_MAP.get(value.getNameRef());, + addSimpleValue(cw, typeName, itemTag, "quantity", quantity, valueStr);, + break;, + default:, + break;]
[+++ b/README.md, +[![Coverity Scan Build Status](https://scan.coverity.com/projects/2166/badge.svg)](https://scan.coverity.com/projects/2166), +++ b/README.md, +[![Coverity Scan Build Status](https://scan.coverity.com/projects/2166/badge.svg)](https://scan.coverity.com/projects/2166), +++ b/build.gradle, + if (!"$it".contains(':jadx-samples:')) {, +++ b/README.md, +[![Coverity Scan Build Status](https://scan.coverity.com/projects/2166/badge.svg)](https://scan.coverity.com/projects/2166), +++ b/build.gradle, + if (!"$it".contains(':jadx-samples:')) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, + JadxCLIArgs jadxArgs = new JadxCLIArgs();, + if (processArgs(jadxArgs, args)) {, + }, + } catch (JadxException e) {, + static void processAndSave(JadxCLIArgs jadxArgs) throws JadxException {, + throw new JadxException("jadx error: " + e.getMessage(), e);, + if (ErrorsCounter.getErrorCount() != 0) {, + throw new JadxException("finished with errors");, + LOG.info("done");, +, + static boolean processArgs(JadxCLIArgs jadxArgs, String[] args) throws JadxException {, + if (!jadxArgs.processArgs(args)) {, + return
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper jcw) {, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.CodeShrinker;, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new BlockProcessor());, + passes.add(new BlockExceptionHandler());, + passes.add(new BlockFinallyExtract());, + passes.add(new BlockFinish());, +, + passes.add(new SSATransform());, + passes.add(new DebugInfoVisitor());, + passes.add(new TypeInference());, +, + passes.add(new FinishTypeInference());, + passes.add(new
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + protected int threadsCount = Math.max(1, Runtime.getRuntime().availableProcessors() / 2);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + protected int threadsCount = Math.max(1, Runtime.getRuntime().availableProcessors() / 2);, +++ b/jadx-cli/src/main/resources/logback.xml, + <pattern>%d{HH:mm:ss} %-5level - %msg%n</pattern>, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + protected int threadsCount = Math.max(1, Runtime.getRuntime().availableProcessors() / 2);, +++ b/jadx-cli/src/main/resources/logback.xml, + <pattern>%d{HH:mm:ss} %-5level - %msg%n</pattern>, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +import jadx.gui.utils.search.TextSearchIndex;, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + protected int threadsCount = Math.max(1, Runtime.getRuntime().availableProcessors() / 2);, +++ b/jadx-cli/src/main/resources/logback.xml, + <pattern>%d{HH:mm:ss} %-5level - %msg%n</pattern>, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +import jadx.gui.utils.search.TextSearchIndex;, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, +import jadx.gui.utils.JNodeCache;, +import jadx.gui.utils.search.StringRef;, +import jadx.gui.utils.search.TextSearchIndex;, +, +import java.util.List;, + public IndexJob(JadxWrapper wrapper, CacheObject cache, int threadsCount, boolean useFastSearch) {, + super(wrapper, threadsCount);, +
[+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JPackage.java, + if (this == o) {, + if (o == null || getClass() != o.getClass()) {, + return false;, + }, + return name.equals(((JPackage) o).name);, + }, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JPackage.java, + if (this == o) {, + if (o == null || getClass() != o.getClass()) {, + return false;, + }, + return name.equals(((JPackage) o).name);, + }, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, +import java.util.IdentityHashMap;, + /**, + * Convert packages list to hierarchical packages representation, + *, + * @param packages input packages list, + * @return root packages, + */, +, +, + // use identity set for collect inner
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + insertSourceFileInfo(clsCode, cls);, + if (mthGen.addDefinition(code)) {, + code.add(' ');, + }, + code.startLine("// compiled from: ");, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + insertSourceFileInfo(clsCode, cls);, + if (mthGen.addDefinition(code)) {, + code.add(' ');, + }, + code.startLine("// compiled from: ");, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + public boolean addDefinition(CodeWriter code) {, + return true;, + return false;, + return true;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + insertSourceFileInfo(clsCode, cls);, + if (mthGen.addDefinition(code)) {, + code.add(' ');, + }, + code.startLine("// compiled from: ");, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + public boolean addDefinition(CodeWriter code) {, + return true;, + return false;, + return true;, +++ b/jadx-core/src/test/java/jadx/tests/internal/TestAnnotations.java, +, + assertThat(code, containsString("int a();"));, +
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, + passes.add(new DebugInfoParseVisitor());, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new ConstructorVisitor());, + passes.add(new TypeInferenceVisitor());, + passes.add(new DebugInfoApplyVisitor());, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, + passes.add(new DebugInfoParseVisitor());, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, +
[+++ b/build.gradle, + testCompile "org.mockito:mockito-core:1.9.5", +++ b/build.gradle, + testCompile "org.mockito:mockito-core:1.9.5", +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, + public int getErrorsCount() {, + return errorsCount;, + }, +, +++ b/build.gradle, + testCompile "org.mockito:mockito-core:1.9.5", +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, + public int getErrorsCount() {, + return errorsCount;, + }, +, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +public final class JavaField {, +++ b/build.gradle, + testCompile "org.mockito:mockito-core:1.9.5", +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, + public int getErrorsCount() {, + return errorsCount;, + }, +, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +public final class JavaField {, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +public final class JavaMethod {, +++ b/build.gradle, + testCompile "org.mockito:mockito-core:1.9.5", +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, + public int getErrorsCount() {, + return errorsCount;, + }, +, +++
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, + private boolean autoStartJobs = false;]
[+++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, + ClassInfo cls = dex.root().getInfoStorage().getCls(type);, + return dex.root().getInfoStorage().putCls(cls);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, + ClassInfo cls = dex.root().getInfoStorage().getCls(type);, + return dex.root().getInfoStorage().putCls(cls);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, + return dex.root().getInfoStorage().getField(field);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, + ClassInfo cls = dex.root().getInfoStorage().getCls(type);, + return dex.root().getInfoStorage().putCls(cls);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, + return dex.root().getInfoStorage().getField(field);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/InfoStorage.java, +import jadx.core.dex.nodes.DexNode;, + private int generateMethodLookupId(DexNode dex, int mthId) {, + return (dex.getDexId()<<16)|mthId;, + public MethodInfo getMethod(DexNode dex, int mtdId) {, + return methods.get(generateMethodLookupId(dex,mtdId));, + }, +, + public MethodInfo putMethod(DexNode dex, int mthId, MethodInfo mth) {, + MethodInfo prev = methods.put(generateMethodLookupId(dex,mthId), mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, + ClassInfo cls = dex.root().getInfoStorage().getCls(type);, + return dex.root().getInfoStorage().putCls(cls);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, + return
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, + ClassInfo alias = classInfo.getAlias();, + String clsName = alias.getShortName();, + classInfo.rename(cls.root(), alias.makeFullClsName(newShortName, true));, + if (alias.getPackage().isEmpty()) {, + String fullName = alias.makeFullClsName(alias.getShortName(), true);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, + regionsCount++;, + if (regionsCount > REGIONS_LIMIT) {, + throw new JadxRuntimeException("Regions count limit reached");, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, + regionsCount++;, + if (regionsCount > REGIONS_LIMIT) {, + throw new JadxRuntimeException("Regions count limit reached");, + }, +++ b/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java, + File out = new File("test-graph-" + desc + "-tmp");]
[+++ b/README.md, +### add by qi, +add: check file's type by file header, +, +++ b/README.md, +### add by qi, +add: check file's type by file header, +, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +import java.util.ArrayList;, +import java.util.Enumeration;, +import java.util.List;, +import java.util.zip.ZipEntry;, +import java.util.zip.ZipFile;, +, + //add by qi, + public static String bytesToHex(byte[] bytes) {, + char[] hexArray = "0123456789abcdef".toCharArray();, + if (bytes == null || bytes.length <= 0) {, + return null;, + }, + char[] hexChars = new char[bytes.length * 2];, + for ( int j = 0; j < bytes.length; j++ ) {, + int v = bytes[j] &
[+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.nodes.FieldNode;, + if (k instanceof FieldNode) {, + FieldNode fn = (FieldNode) k;, + if (fn.getParentClass().isEnum()) {, + code.add(fn.getName());, + } else {, + staticField(code, fn.getFieldInfo());, + }, + } else if (k instanceof IndexInsnNode) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.nodes.FieldNode;, + if (k instanceof FieldNode) {, + FieldNode fn = (FieldNode) k;, + if (fn.getParentClass().isEnum()) {, + code.add(fn.getName());, + } else {, + staticField(code, fn.getFieldInfo());, + }, + } else if (k instanceof IndexInsnNode) {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +import jadx.core.dex.attributes.nodes.EnumMapAttr;, + public static final AType<EnumMapAttr> ENUM_MAP = new AType<EnumMapAttr>();, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.nodes.FieldNode;, + if (k instanceof
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstInlineVisitor;, + passes.add(new ConstInlineVisitor());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstInlineVisitor;, + passes.add(new ConstInlineVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstInlineVisitor;, + passes.add(new ConstInlineVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, +import jadx.core.dex.nodes.BlockNode;, +import jadx.core.utils.InstructionRemover;, +import jadx.core.utils.exceptions.JadxRuntimeException;, +import java.util.IdentityHashMap;, +import java.util.Map;, +, +import org.jetbrains.annotations.NotNull;, +, +public final class PhiInsn extends InsnNode {, +, + private final Map<RegisterArg, BlockNode> blockBinds;, + this.blockBinds = new IdentityHashMap<RegisterArg, BlockNode>(predecessors);, + public RegisterArg bindArg(BlockNode pred) {, + RegisterArg arg = InsnArg.reg(getResult().getRegNum(), getResult().getType());, + bindArg(arg, pred);, + return arg;, + }, +, + public void bindArg(RegisterArg arg, BlockNode pred) {, + if (blockBinds.containsValue(pred)) {, + throw new JadxRuntimeException("Duplicate predecessors
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, + if (entry.getName().endsWith(CLST_EXTENSION)) {, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, + if (entry.getName().endsWith(CLST_EXTENSION)) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, + if (entry.getName().endsWith(CLST_EXTENSION)) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, + if (entry.getName().endsWith(CLST_EXTENSION)) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java, +import javax.xml.parsers.DocumentBuilderFactory;, + DocumentBuilder dBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, + if (entry.getName().endsWith(CLST_EXTENSION)) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ManifestAttributes.java, +import javax.xml.parsers.DocumentBuilderFactory;,
[+++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +import java.util.Collections;, + for (ClassNode cls : classes) {, + size += cls.getInnerClasses().size();, + }, + int k = 0;, + for (ClassNode cls : classes) {, + nClasses[k++] = addClass(cls);, + for (ClassNode inner : cls.getInnerClasses()) {, + nClasses[k++] = addClass(inner);, + }, + private NClass addClass(ClassNode cls) {, + NClass nClass = new NClass(cls.getRawName(), -1);, + nameMap.put(cls.getRawName(), nClass);, + return nClass;, + }, +, + if (clsName.equals(implClsName)) {, + return clsName;, + }, + NClass cls = nameMap.get(implClsName);, + if (cls != null) {, + }, + if (result != null) {, + return result;,
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/EmptyAttrStorage.java, + // ignore, + // ignore, + // ignore, + // ignore, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/EmptyAttrStorage.java, + // ignore, + // ignore, + // ignore, + // ignore, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/IAttribute.java, + <T extends IAttribute> AType<T> getType();, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/EmptyAttrStorage.java, + // ignore, + // ignore, + // ignore, + // ignore, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/IAttribute.java, + <T extends IAttribute> AType<T> getType();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/EmptyAttrStorage.java, + // ignore, + // ignore, + // ignore, + // ignore, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/IAttribute.java, + <T extends IAttribute> AType<T> getType();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/TargetInsnNode.java, + public void initBlocks(BlockNode curBlock) {, + }, + public boolean replaceTargetBlock(BlockNode origin,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + ArgType type = classInfo.getType();, + ArgType[] generics = type.getGenericTypes();, + if (generics == null) {, + return baseClass;, + }, +, + ArgType wt = gt.getWildcardType();, + if (wt != null) {, + int bounds = gt.getWildcardBounds();, + if (bounds != 0) {, + sb.append(bounds == -1 ? " super " : " extends ");, + sb.append(TypeGen.translate(this, wt));, + }, + } else {, + sb.append(TypeGen.translate(this, gt));, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + ArgType type = classInfo.getType();, + ArgType[] generics = type.getGenericTypes();, + if (generics == null) {, + return baseClass;, + }, +, + ArgType wt = gt.getWildcardType();,
[+++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockProcessingHelper.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockProcessingHelper.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockProcessingHelper.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.utils.InstructionRemover;, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockProcessingHelper.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.utils.InstructionRemover;, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockProcessingHelper.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.utils.InstructionRemover;, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockProcessingHelper.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.utils.InstructionRemover;, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +import jadx.core.utils.InstructionRemover;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/EncValueParser.java, + private static final int ENCODED_BYTE = 0x00;, + private static final int ENCODED_SHORT = 0x02;, + private static final int ENCODED_CHAR = 0x03;, + private static final int ENCODED_INT = 0x04;, + private static final int ENCODED_LONG = 0x06;, + private static final int ENCODED_FLOAT = 0x10;, + private static final int ENCODED_DOUBLE = 0x11;, + private static final int ENCODED_STRING = 0x17;, + private static final int ENCODED_TYPE = 0x18;, + private static final int ENCODED_FIELD = 0x19;, + private static final int ENCODED_ENUM = 0x1b;, + private static final int ENCODED_METHOD = 0x1a;, +
[+++ b/build.gradle, + sourceCompatibility = JavaVersion.VERSION_1_8, + targetCompatibility = JavaVersion.VERSION_1_8, +++ b/build.gradle, + sourceCompatibility = JavaVersion.VERSION_1_8, + targetCompatibility = JavaVersion.VERSION_1_8, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, + sourceCompatibility = JavaVersion.VERSION_1_8, + targetCompatibility = JavaVersion.VERSION_1_8, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.4.1-bin.zip, +++ b/build.gradle, + sourceCompatibility = JavaVersion.VERSION_1_8, + targetCompatibility = JavaVersion.VERSION_1_8, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.4.1-bin.zip, +++ b/gradlew, +#!/usr/bin/env sh, +# Attempt to set APP_HOME, +# Resolve links: $0 may be a link, +PRG="$0", +# Need this for relative symlinks., +while [ -h "$PRG" ] ; do, + ls=`ls -ld "$PRG"`, + link=`expr "$ls" : '.*-> \(.*\)$'`, + if expr "$link" : '/.*'
[+++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, + if (decompiler == null) {, + throw new JadxRuntimeException("Can't decompile inner class");, + }, + load();, + }, + private void load() {, + JavaClass javaClass = new JavaClass(null, inner);, + javaClass.load();, + list.add(javaClass);, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, + if (decompiler == null) {, + throw new JadxRuntimeException("Can't decompile inner class");, + }, + load();, + }, + private void load() {, + JavaClass javaClass = new JavaClass(null, inner);, + javaClass.load();, + list.add(javaClass);, +++ b/jadx-gui/src/main/java/jadx/gui/MainWindow.java, + JClass cls = node.getRootClass();, + if (cls != null) {, + showCode(cls, node.getLine());, + cls.getRootClass().load();, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import
[+++ b/build.gradle, + testCompile 'ch.qos.logback:logback-classic:1.1.2', + testCompile 'cglib:cglib-nodep:3.1', +++ b/build.gradle, + testCompile 'ch.qos.logback:logback-classic:1.1.2', + testCompile 'cglib:cglib-nodep:3.1', +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +import jadx.core.utils.exceptions.JadxException;, + reset();, + void reset() {, + ClassInfo.clearCache();, + ErrorsCounter.reset();, + classes = null;, + }, +, + public void loadFile(File file) throws JadxException {, + public void loadFiles(List<File> files) throws JadxException {, + throw new JadxException("Empty file list");, + try {, + } catch (IOException e) {, + throw new JadxException("Error load file: " + file, e);, + }, + throw new JadxRuntimeException("Save interrupted", e);, + public ExecutorService getSaveExecutor() {, + ExecutorService executor = Executors.newFixedThreadPool(threadsCount);, + if (root
[+++ b/build.gradle, +, + testCompile 'org.eclipse.jdt.core.compiler:ecj:4.6.1', +++ b/build.gradle, +, + testCompile 'org.eclipse.jdt.core.compiler:ecj:4.6.1', +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +import jadx.api.JadxArgs;, +import jadx.api.JadxDecompiler;, +import jadx.api.JadxInternalAccess;, +import jadx.core.ProcessClass;, +import jadx.core.codegen.CodeGen;, +import jadx.core.dex.attributes.AFlag;, +import jadx.core.dex.attributes.AType;, +import jadx.core.dex.attributes.AttrList;, +import jadx.core.dex.attributes.IAttributeNode;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.MethodNode;, +import jadx.core.dex.nodes.RootNode;, +import jadx.core.dex.visitors.DepthTraversal;, +import jadx.core.dex.visitors.IDexTreeVisitor;, +import jadx.core.xmlgen.ResourceStorage;, +import jadx.core.xmlgen.entry.ResourceEntry;, +import jadx.tests.api.compiler.DynamicCompiler;, +import jadx.tests.api.compiler.StaticCompiler;, +import jadx.tests.api.utils.TestUtils;, +import org.junit.jupiter.api.BeforeEach;, +, + private static final String OUT_DIR = "test-out-tmp";, +, + private static final String CHECK_METHOD_NAME = "check";, + protected boolean deleteTmpFiles;, + protected boolean withDebugInfo;, + protected boolean unloadCls;, + protected boolean compile;, + protected boolean useEclipseCompiler;, + @BeforeEach, + public void init() {,
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.utils.ErrorsCounter;, + processAndSave(jadxArgs);, + } catch (JadxException e) {, + private static void processAndSave(JadxCLIArgs jadxArgs) {, + try {, + Decompiler jadx = new Decompiler(jadxArgs);, + jadx.loadFiles(jadxArgs.getInput());, + jadx.setOutputDir(jadxArgs.getOutDir());, + jadx.save();, + LOG.info("done");, + } catch (Throwable e) {, + LOG.error("jadx error:", e);, + }, + int errorsCount = ErrorsCounter.getErrorCount();, + if (errorsCount != 0) {, + ErrorsCounter.printReport();, + }, + System.exit(errorsCount);, + }, +, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.utils.ErrorsCounter;, + processAndSave(jadxArgs);, + } catch (JadxException e) {, + private static void processAndSave(JadxCLIArgs jadxArgs) {, + try {, + Decompiler jadx = new Decompiler(jadxArgs);, + jadx.loadFiles(jadxArgs.getInput());, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, + private static InsnWrapArg wrap(InsnNode insn) {, + public static InsnArg wrapArg(InsnNode insn) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, + private static InsnWrapArg wrap(InsnNode insn) {, + public static InsnArg wrapArg(InsnNode insn) {, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, + private static InsnWrapArg wrap(InsnNode insn) {, + public static InsnArg wrapArg(InsnNode insn) {, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, + return new ArithNode(ArithOp.ADD, fArg, fArg, InsnArg.wrapArg(concat));]
[+++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, + /**, + * @return {@code clsName} instanceof {@code implClsName}, + */, + public List<String> getImplementations(String clsName) {, + List<String> list = new ArrayList<>();, + for (String cls : nameMap.keySet()) {, + if (isImplements(cls, clsName)) {, + list.add(cls);, + }, + }, + return list;, + }, +, + public Set<String> getAncestors(String clsName) {, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, + /**, + * @return {@code clsName} instanceof {@code implClsName}, + */, + public List<String> getImplementations(String clsName) {, + List<String> list = new ArrayList<>();, + for (String cls : nameMap.keySet()) {, + if (isImplements(cls, clsName)) {, + list.add(cls);, + }, +
[+++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import jadx.core.utils.StringUtils;, + public CodeWriter addMultiLine(String str) {, + buf.append(str);, + if (str.contains(NL)) {, + line += StringUtils.countMatches(str, NL);, + offset = 0;, + }, + return this;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import jadx.core.utils.StringUtils;, + public CodeWriter addMultiLine(String str) {, + buf.append(str);, + if (str.contains(NL)) {, + line += StringUtils.countMatches(str, NL);, + offset = 0;, + }, + return this;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + code.newLine().add("Error: ").addMultiLine(Utils.getStackTrace(cause));, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import jadx.core.utils.StringUtils;, + public CodeWriter addMultiLine(String str) {, + buf.append(str);, + if (str.contains(NL)) {, + line += StringUtils.countMatches(str, NL);, + offset = 0;, + }, +
[+++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.utils.LangLocale;, +import jadx.gui.utils.NLS;, +import java.util.Locale;, +import java.util.prefs.BackingStoreException;, +import java.util.prefs.Preferences;, +, + NLS.setLocale(settings.getLangLocale());, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.utils.LangLocale;, +import jadx.gui.utils.NLS;, +import java.util.Locale;, +import java.util.prefs.BackingStoreException;, +import java.util.prefs.Preferences;, +, + NLS.setLocale(settings.getLangLocale());, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import jadx.gui.utils.LangLocale;, +import jadx.gui.utils.NLS;, + private static final int CURRENT_SETTINGS_VERSION = 4;, + private LangLocale langLocale = NLS.defaultLocale();, + public LangLocale getLangLocale(){, + return this.langLocale;, + }, +, + public void setLangLocale(LangLocale langLocale) {, + this.langLocale = langLocale;, + }, +, + fromVersion++;, + }, + if (fromVersion == 3) {, + setLangLocale(NLS.defaultLocale());, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.utils.LangLocale;, +import jadx.gui.utils.NLS;, +import java.util.Locale;, +import java.util.prefs.BackingStoreException;, +import java.util.prefs.Preferences;, +, +
[+++ b/jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java, + private final Set<IAttributeNode> errorNodes = new HashSet<>();, + List<String> errors = new ArrayList<>(errorNodes.size());, + for (IAttributeNode node : errorNodes) {, + errors.add(nodeName + ": " + node);, + }, + Collections.sort(errors);, + for (String err : errors) {, + LOG.error(" {}", err);]
[+++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, + if (!tryDefaultLookAndFeel()) {, + }, + SwingUtilities.invokeLater(new MainWindow(settings)::open);, +, + private static boolean tryDefaultLookAndFeel() {, + String defLaf = System.getProperty("swing.defaultlaf");, + if (defLaf != null) {, + try {, + UIManager.setLookAndFeel(defLaf);, + return true;, + } catch (Exception e) {, + LOG.error("Failed to set default laf: {}", defLaf, e);, + }, + }, + return false;, + }, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, + if (!tryDefaultLookAndFeel()) {, + }, + SwingUtilities.invokeLater(new MainWindow(settings)::open);, +, + private static boolean tryDefaultLookAndFeel() {, + String defLaf = System.getProperty("swing.defaultlaf");, + if (defLaf != null) {, + try {, + UIManager.setLookAndFeel(defLaf);, + return true;, +
[+++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, + for (final JavaClass cls : getClasses()) {, + cls.decompile();, + SaveCode.save(outDir, args, cls.getClassNode());, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, + for (final JavaClass cls : getClasses()) {, + cls.decompile();, + SaveCode.save(outDir, args, cls.getClassNode());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + noCode = false;, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, + for (final JavaClass cls : getClasses()) {, + cls.decompile();, + SaveCode.save(outDir, args, cls.getClassNode());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + noCode = false;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SaveCode.java, + save(dir, args, cls);, + return false;, + }, + public static void save(File dir, IJadxArgs args, ClassNode cls) {, + CodeWriter clsCode = cls.getCode();]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.args.SSAVar;, + if (arg.getSVar().contains(AFlag.FINAL)) {, + code.add("final ");, + }, + switch (replace.getReplaceType()) {, + case CLASS_INSTANCE:, + useClass(code, replace.getClsRef());, + break;, + case VAR:, + addArg(code, replace.getVarRef());, + break;, + inlineAnonymousConstr(code, cls, insn);, + return;, + }, + if (insn.isSelf()) {, + throw new JadxRuntimeException("Constructor 'self' invoke must be removed!");, + }, + if (insn.isSuper()) {, + code.add("super");, + } else if (insn.isThis()) {, + code.add("this");, + } else {, + code.add("new ");, + useClass(code, insn.getClassType());, + }, + MethodNode callMth = mth.dex().resolveMethod(insn.getCallMth());, + generateMethodArguments(code, insn, 0, callMth);, + }, +, + private void inlineAnonymousConstr(CodeWriter
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + // ignore classes from default package, + if (extClsInfo.isDefaultPackage()) {, + return shortName;, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + // ignore classes from default package, + if (extClsInfo.isDefaultPackage()) {, + return shortName;, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import static jadx.core.utils.android.AndroidResourcesUtils.handleAppResField;, +, + if (!handleAppResField(code, clsGen, declClass)) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + // ignore classes from default package, + if (extClsInfo.isDefaultPackage()) {, + return shortName;, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import static jadx.core.utils.android.AndroidResourcesUtils.handleAppResField;, +, + if (!handleAppResField(code, clsGen, declClass)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, + public boolean isDefaultPackage() {, + return pkg.isEmpty();, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + // ignore classes from default
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (arguments == null || arguments.isEmpty()) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (arguments == null || arguments.isEmpty()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +, + public InsnArg duplicate() {, + return this;, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (arguments == null || arguments.isEmpty()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +, + public InsnArg duplicate() {, + return this;, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/TypeImmutableArg.java, +, + @Override, + public RegisterArg duplicate() {, + return duplicate(getRegNum(), getSVar());, + }, +, + @Override, + public RegisterArg duplicate(int regNum, SSAVar sVar) {, + RegisterArg dup = new TypeImmutableArg(regNum, getInitType());, + if (sVar != null) {, + dup.setSVar(sVar);, +
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + boolean wrap = state.contains(IGState.BODY_ONLY);, + if (wrap), + code.add("(");, + code.add("(");, + code.add(") ");, + code.add(arg(insn.getArg(0)));, + if (wrap), + code.add(")");, + private void addArgs(CodeWriter code, InsnNode insn, int k) throws CodegenException {, + int argsCount = insn.getArgsCount();, + code.add('(');, + if (k < argsCount) {, + code.add(arg(insn.getArg(k), false));, + for (int i = k + 1; i < argsCount; i++) {, + code.add(", ");, + code.add(arg(insn.getArg(i), false));, + }, + }, + code.add(')');, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + boolean wrap = state.contains(IGState.BODY_ONLY);, + if (wrap), + code.add("(");, + code.add("(");, + code.add(") ");, + code.add(arg(insn.getArg(0)));,
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + if (args.isCfgOutput()) {, + passes.add(DotGraphVisitor.dumpRegions());, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + if (args.isCfgOutput()) {, + passes.add(DotGraphVisitor.dumpRegions());, + }, +, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, + cls.getDependencies().forEach(depCls -> process(depCls, passes, null));, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + if (args.isCfgOutput()) {, + passes.add(DotGraphVisitor.dumpRegions());, + }, +, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, + cls.getDependencies().forEach(depCls -> process(depCls, passes, null));, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, + if (els.contains(AFlag.ELSE_IF_CHAIN) && els instanceof Region) {, + if (subBlocks.size() == 1) {, + IContainer elseBlock = subBlocks.get(0);, + if (elseBlock instanceof IfRegion) {, + declareVars(code, elseBlock);, + makeIf((IfRegion) elseBlock, code, false);, + }, + }, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + if (args.isCfgOutput()) {, + passes.add(DotGraphVisitor.dumpRegions());, + }, +,
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/AbstractRegion.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, + private static final Logger LOG = LoggerFactory.getLogger(AbstractRegion.class);, + LOG.warn("Replace sub block not supported for class \"{}\"", this.getClass());, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/AbstractRegion.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, + private static final Logger LOG = LoggerFactory.getLogger(AbstractRegion.class);, + LOG.warn("Replace sub block not supported for class \"{}\"", this.getClass());, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfRegion.java, + public boolean replaceSubBlock(IContainer oldBlock, IContainer newBlock) {, + if (oldBlock == thenRegion) {, + thenRegion = newBlock;, + return true;, + }, + if (oldBlock == elseRegion) {, + elseRegion = newBlock;, + return true;, + }, + return false;, + }, +, + @Override, +++
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import jadx.core.dex.instructions.args.LiteralArg;, + public FieldNode getConstFieldByLiteralArg(LiteralArg arg) {, + ArgType type = arg.getType();, + long literal = arg.getLiteral();, +, + if (type.equals(ArgType.DOUBLE)), + return getConstField(Double.longBitsToDouble(literal));, + else if (type.equals(ArgType.FLOAT)), + return getConstField(Float.intBitsToFloat((int) literal));, + else if (Math.abs(literal) > 0x1) {, + if (type.equals(ArgType.INT)), + return getConstField((int) literal);, + else if (type.equals(ArgType.LONG)), + return getConstField(literal);, + }, + return null;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import jadx.core.dex.instructions.args.LiteralArg;, + public FieldNode getConstFieldByLiteralArg(LiteralArg arg) {, + ArgType type = arg.getType();, + long literal = arg.getLiteral();, +, + if (type.equals(ArgType.DOUBLE)), + return getConstField(Double.longBitsToDouble(literal));, + else if (type.equals(ArgType.FLOAT)), + return getConstField(Float.intBitsToFloat((int) literal));,
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/EliminatePhiNodes.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, + private static final Logger LOG = LoggerFactory.getLogger(EliminatePhiNodes.class);, +, + removeInsn(mth, block, phiInsn);, + }, + }, + }, +, + private static void removeInsn(MethodNode mth, BlockNode block, PhiInsn phiInsn) {, + Iterator<InsnNode> it = block.getInstructions().iterator();, + while (it.hasNext()) {, + InsnNode insn = it.next();, + it.remove();, + return;, + LOG.warn("Phi node not removed: {}, mth: {}", phiInsn, mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/EliminatePhiNodes.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, + private static final Logger LOG = LoggerFactory.getLogger(EliminatePhiNodes.class);, +, + removeInsn(mth, block, phiInsn);, + }, + }, + }, +, + private static void removeInsn(MethodNode mth,
[+++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, + if (cls == null) {, + LOG.debug("Missing class: {}", implClsName);, + return null;, + }, + }, + if (cls == null) {, + LOG.debug("Missing class: {}", clsName);, + return Collections.emptySet();, + }, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, + if (cls == null) {, + LOG.debug("Missing class: {}", implClsName);, + return null;, + }, + }, + if (cls == null) {, + LOG.debug("Missing class: {}", clsName);, + return Collections.emptySet();, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +import jadx.core.dex.regions.IfCondition.Mode;, + String mode = condition.getMode() == Mode.AND ? " && " : " || ";, + return !condition.isCompare() && condition.getMode() != Mode.NOT;, +++
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +, + final String firstInputFileName = root.getDexNodes().get(0).getInputFile().getFile().getAbsolutePath();, + final String inputPath = org.apache.commons.io.FilenameUtils.getFullPathNoEndSeparator(, + firstInputFileName);, + final String inputName = org.apache.commons.io.FilenameUtils.getBaseName(firstInputFileName);, +, + File deobfMapFile = new File(inputPath, inputName + ".jobf");]
[+++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, + if (isValidIdentifier(name)) {, +++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, + if (isValidIdentifier(name)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, + String cleanClsName = NameMapper.removeInvalidChars(clsName, "C");, + if (!NameMapper.isValidIdentifier(cleanClsName)) {, + return 'C' + cleanClsName;, + return cleanClsName;, +++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, + if (isValidIdentifier(name)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, + String cleanClsName = NameMapper.removeInvalidChars(clsName, "C");, + if (!NameMapper.isValidIdentifier(cleanClsName)) {, + return 'C' + cleanClsName;, + return cleanClsName;, +++ b/jadx-core/src/test/java/jadx/tests/integration/names/TestClassNameWithInvalidChar.java, +package jadx.tests.integration.names;, +, +import org.junit.jupiter.api.Test;, +, +import jadx.api.JadxDecompiler;, +import jadx.api.JadxInternalAccess;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.RootNode;, +import jadx.tests.api.SmaliTest;, +, +public class TestClassNameWithInvalidChar extends SmaliTest {, + /*, + public class do- {}, + public class i-f {}, + */, +, +
[+++ b/build.gradle, + id 'com.github.ben-manes.versions' version '0.21.0', + compile 'org.slf4j:slf4j-api:1.7.26', + testCompile 'org.mockito:mockito-core:2.25.0', +++ b/build.gradle, + id 'com.github.ben-manes.versions' version '0.21.0', + compile 'org.slf4j:slf4j-api:1.7.26', + testCompile 'org.mockito:mockito-core:2.25.0', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-5.2.1-bin.zip, +++ b/build.gradle, + id 'com.github.ben-manes.versions' version '0.21.0', + compile 'org.slf4j:slf4j-api:1.7.26', + testCompile 'org.mockito:mockito-core:2.25.0', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-5.2.1-bin.zip, +++ b/jadx-core/build.gradle, + compile 'org.ow2.asm:asm:7.1', + compile 'org.jetbrains:annotations:17.0.0', + compile 'uk.com.robust-it:cloning:1.9.12', + testCompile 'org.smali:smali:2.2.6', + testCompile 'org.smali:baksmali:2.2.6', +, + // update dependency in smali, + testCompile 'com.google.guava:guava:27.1-jre', + testCompile 'com.beust:jcommander:1.74', +++ b/build.gradle, + id 'com.github.ben-manes.versions' version '0.21.0', + compile 'org.slf4j:slf4j-api:1.7.26', + testCompile 'org.mockito:mockito-core:2.25.0', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-5.2.1-bin.zip, +++ b/jadx-core/build.gradle, + compile 'org.ow2.asm:asm:7.1', + compile 'org.jetbrains:annotations:17.0.0',
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + && stack.peekRegion() instanceof LoopRegion) {, + LoopRegion outerLoop = (LoopRegion) stack.peekRegion();, + if (outerLoop.getBody() == null /* processing not yet finished */, + || RegionUtils.isRegionContainsBlock(outerLoop, out)) {, + }]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, + openAction.putValue(Action.SHORT_DESCRIPTION, NLS.str("file.open_action"));, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, + openAction.putValue(Action.SHORT_DESCRIPTION, NLS.str("file.open_action"));, +++ b/jadx-gui/src/main/java/jadx/gui/utils/NLS.java, +import java.io.IOException;
[+++ b/.DS_Store, +++ b/.DS_Store, +++ b/jadx-core/.DS_Store, +++ b/.DS_Store, +++ b/jadx-core/.DS_Store, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + private Map<ClassNode, JavaClass> classesMap = new HashMap<ClassNode, JavaClass>();, + private Map<MethodNode, JavaMethod> methodsMap = new HashMap<MethodNode, JavaMethod>();, + private Map<FieldNode, JavaField> fieldsMap = new HashMap<FieldNode, JavaField>();, +++ b/.DS_Store, +++ b/jadx-core/.DS_Store, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + private Map<ClassNode, JavaClass> classesMap = new HashMap<ClassNode, JavaClass>();, + private Map<MethodNode, JavaMethod> methodsMap = new HashMap<MethodNode, JavaMethod>();, + private Map<FieldNode, JavaField> fieldsMap = new HashMap<FieldNode, JavaField>();, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.files.ZipSecurity;, + if(!ZipSecurity.isValidZipEntry(entry)) {, + return null;, + }, + , + if(ZipSecurity.isValidZipEntry(entry)) {, + }, +++ b/.DS_Store, +++ b/jadx-core/.DS_Store, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + private
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +, + public boolean canThrowException() {, + switch (getType()) {, + case RETURN:, + case IF:, + case GOTO:, + case MOVE:, + case MOVE_EXCEPTION:, + case NEG:, + case CONST:, + case CONST_STR:, + case CONST_CLASS:, + case CMP_L:, + case CMP_G:, + return false;, +, + default:, + return true;, + }, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +, + public boolean canThrowException() {, + switch (getType()) {, + case RETURN:, + case IF:, + case GOTO:, + case MOVE:, + case MOVE_EXCEPTION:, + case NEG:, + case CONST:, + case CONST_STR:, + case CONST_CLASS:, + case
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +import jadx.core.dex.instructions.args.ArgType;, +import java.util.ArrayList;, +import java.util.HashSet;, +import java.util.Iterator;, + private final Map<MethodInfo, OverridedMethodsNode> ovrdMap = new HashMap<MethodInfo, OverridedMethodsNode>();, + private final List<OverridedMethodsNode> ovrd = new ArrayList<OverridedMethodsNode>();, +, + postProcess();, + }, +, + private void postProcess() {, + int id = 1;, + for (OverridedMethodsNode o : ovrd) {, +, + Iterator<MethodInfo> it = o.getMethods().iterator();, + if (it.hasNext()) {, + MethodInfo mth = it.next();, +, + if (mth.isRenamed() && !mth.isAliasFromPreset()) {, + mth.setAlias(String.format("mo%d%s", id, makeName(mth.getName())));, + }, + String firstMethodAlias = mth.getAlias();, +, + while (it.hasNext()) {, + mth = it.next();, + if (!mth.getAlias().equals(firstMethodAlias)) {, + mth.setAlias(firstMethodAlias);,
[+++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, + case XML:, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, + case XML:, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, + private static final Charset STRING_CHARSET_UTF16 = Charset.forName("UTF-16LE");, + private static final Charset STRING_CHARSET_UTF8 = Charset.forName("UTF-8");, +, + private static final int RES_NULL_TYPE = 0x0000;, + private static final int RES_STRING_POOL_TYPE = 0x0001;, + private static final int RES_TABLE_TYPE = 0x0002;, +, + private static final int RES_XML_TYPE = 0x0003;, + private static final int RES_XML_FIRST_CHUNK_TYPE = 0x0100;, + private static final int RES_XML_START_NAMESPACE_TYPE = 0x0100;, + private static final int RES_XML_END_NAMESPACE_TYPE = 0x0101;, + private static final int RES_XML_START_ELEMENT_TYPE = 0x0102;, + private static final int
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + if (source.contains(AType.CATCH_BLOCK), + && source.getSuccessors().size() == 2) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + if (source.contains(AType.CATCH_BLOCK), + && source.getSuccessors().size() == 2) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ssa/SSATransform.java, +import jadx.core.dex.attributes.AFlag;, + fixLastTryCatchAssign(mth);, + if (removeUselessPhi(mth)) {, + renameVariables(mth);, + }, +, + private static void fixLastTryCatchAssign(MethodNode mth) {, + for (BlockNode block : mth.getBasicBlocks()) {, + PhiListAttr phiList = block.get(AType.PHI_LIST);, + if (phiList == null || !block.contains(AType.EXC_HANDLER)) {, + continue;, + }, + for (PhiInsn phi : phiList.getList()) {, + for (int i = 0; i < phi.getArgsCount(); i++) {, + RegisterArg arg = phi.getArg(i);, + InsnNode parentInsn = arg.getAssignInsn();, + if (parentInsn
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java, + baseDir = baseDir.getCanonicalFile();]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.args.NamedArg;, + } else if (arg.isInsnWrap()) {, + } else if (arg.isNamed()) {, + return ((NamedArg) arg).getName();, + } else {, + throw new CodegenException("Unknown arg type " + arg);, + code.add("monitor-exit(").add(arg(insn, 0)).add(')');, + code.add(arg(insn, 0));, + code.add(arg(insn, 0));, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.args.NamedArg;, + } else if (arg.isInsnWrap()) {, + } else if (arg.isNamed()) {, + return ((NamedArg) arg).getName();, + } else {, + throw new CodegenException("Unknown arg type " + arg);, + code.add("monitor-exit(").add(arg(insn, 0)).add(')');, + code.add(arg(insn, 0));, + code.add(arg(insn, 0));, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.dex.instructions.args.NamedArg;, + * @param arg register variable, + if (varNames.add(name) || fallback),
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, + if (!elType.isTypeKnown() && insnElementType.isPrimitive()) {, + if (elType.contains(insnElementType.getPrimitiveType())) {, + elType = insnElementType;, + }, + }]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, + public boolean removeArg(RegisterArg arg) {, + boolean isRemoved = super.removeArg(arg);, + if (isRemoved) {, + arg.getSVar().setUsedInPhi(null);, + }, + return isRemoved;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/PhiInsn.java, + public boolean removeArg(RegisterArg arg) {, + boolean isRemoved = super.removeArg(arg);, + if (isRemoved) {, + arg.getSVar().setUsedInPhi(null);, + }, + return isRemoved;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, + protected boolean removeArg(InsnArg arg) {, + int count = getArgsCount();, + for (int i = 0; i < count; i++) {, + if (arg == arguments.get(i)) {, + arguments.remove(i);, + return true;, + }, + }, + return false;, + }, +,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, + private static final String[] INDENT_CACHE = {, + "",, + INDENT,, + INDENT + INDENT,, + INDENT + INDENT + INDENT,, + INDENT + INDENT + INDENT + INDENT,, + INDENT + INDENT + INDENT + INDENT + INDENT,, + };, +, + public CodeWriter add(Object obj) {, + buf.append(obj);, + return this;, + }, +, + if (curIndent < INDENT_CACHE.length) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, + private static final String[] INDENT_CACHE = {, + "",, + INDENT,, + INDENT + INDENT,, + INDENT + INDENT + INDENT,, + INDENT + INDENT + INDENT + INDENT,, + INDENT
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/ISettingsUpdater.java, +package jadx.gui.settings;, +, +public interface ISettingsUpdater {, + void update(JadxSettings settings);, +}, +++ b/jadx-gui/src/main/java/jadx/gui/settings/ISettingsUpdater.java, +package jadx.gui.settings;, +, +public interface ISettingsUpdater {, + void update(JadxSettings settings);, +}, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, + public void partialSync(ISettingsUpdater updater) {, + JadxSettings settings = JadxSettingsAdapter.load();, + updater.update(settings);, + JadxSettingsAdapter.store(settings);, + }, +, + partialSync(settings -> settings.lastOpenFilePath = JadxSettings.this.lastOpenFilePath);, + partialSync(settings -> settings.lastSaveFilePath = JadxSettings.this.lastSaveFilePath);, + partialSync(settings -> settings.flattenPackage = JadxSettings.this.flattenPackage);, + partialSync(settings -> settings.recentFiles = recentFiles);, + partialSync(settings -> settings.windowPos = windowPos);]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, + while((count+2)<=bytes.length) {, + else if(type==0x0101) parseNameSpaceEnd();, + else if(type==0x0103) parseElementEnd();, + else if(type==0x0000) continue; // NullType is just doing nothing, + //if(beginLineNumber!=2) die("NAMESPACE beginning line number != 2 not supported yet");, + System.out.println("NAMESPACE BEGIN Line: " + beginLineNumber);, + private void parseNameSpaceEnd() {, + if(cInt16(bytes, count) != 0x0010) die("NAMESPACE header is not 0x0010");, + if(cInt32(bytes, count) != 0x18) die("NAMESPACE header chunk is not 0x18 big");, + int endLineNumber = cInt32(bytes, count);, + //if(endLineNumber!=2) die("NAMESPACE begining line number != 2 not supported yet");, + System.out.println("NAMESPACE END Line: " + endLineNumber);, + System.out.println("Comment: 0x" + Integer.toHexString(cInt32(bytes, count)));, +
[+++ b/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java, +import static java.nio.charset.StandardCharsets.UTF_8;, +, +import java.nio.charset.Charset;, +import java.nio.file.Files;, +import java.nio.file.Path;, + private static final Charset MAP_FILE_CHARSET = UTF_8;, + private final Path deobfMapFile;, + public DeobfPresets(Deobfuscator deobfuscator, Path deobfMapFile) {, + if (!Files.exists(deobfMapFile)) {, + LOG.info("Loading obfuscation map from: {}", deobfMapFile.toAbsolutePath());, + List<String> lines = Files.readAllLines(deobfMapFile, MAP_FILE_CHARSET);, + LOG.error("Failed to load deobfuscation map file '{}'", deobfMapFile.toAbsolutePath(), e);, + if (Files.exists(deobfMapFile)) {, + deobfMapFile.toAbsolutePath());, + LOG.error("Failed to load deobfuscation map file '{}'", deobfMapFile.toAbsolutePath(), e);, + Files.write(deobfMapFile, list, MAP_FILE_CHARSET);, +++ b/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java, +import static java.nio.charset.StandardCharsets.UTF_8;, +, +import java.nio.charset.Charset;, +import java.nio.file.Files;, +import java.nio.file.Path;, + private static final Charset MAP_FILE_CHARSET = UTF_8;,
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import jadx.gui.utils.LangLocale;, +import jadx.gui.utils.NLS;, + if (deobfuscationMinLength < 0) {, + deobfuscationMinLength = 0;, + }, + if (deobfuscationMaxLength < 0) {, + deobfuscationMaxLength = 0;, + }, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import jadx.gui.utils.LangLocale;, +import jadx.gui.utils.NLS;, + if (deobfuscationMinLength < 0) {, + deobfuscationMinLength = 0;, + }, + if (deobfuscationMaxLength < 0) {, + deobfuscationMaxLength = 0;, + }, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +import jadx.gui.utils.LangLocale;, + SpinnerNumberModel minLenModel = new SpinnerNumberModel(settings.getDeobfuscationMinLength(), 0, Integer.MAX_VALUE, 1);, + JSpinner minLenSpinner = new JSpinner(minLenModel);, + minLenSpinner.addChangeListener(e -> {, + settings.setDeobfuscationMinLength((Integer) minLenSpinner.getValue());, + SpinnerNumberModel maxLenModel = new SpinnerNumberModel(settings.getDeobfuscationMaxLength(), 0, Integer.MAX_VALUE, 1);, + JSpinner maxLenSpinner =
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + for (ClassInfo importCls : getImports()) {, + if (classInfo.isInner()) {, + String parent = useClassInternal(useCls, classInfo.getParentClass());, + return parent + "." + shortName;, + } else {, + }, + private Set<ClassInfo> getImports() {, + if (parentGen != null) {, + return parentGen.getImports();, + } else {, + return imports;, + }, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + for (ClassInfo importCls : getImports()) {, + if (classInfo.isInner()) {, + String parent = useClassInternal(useCls, classInfo.getParentClass());, + return parent + "." + shortName;, + } else {, + }, + private Set<ClassInfo> getImports() {, + if (parentGen !=
[+++ b/NOTICE, +, +GUI icons copied from several places:, + - Eclipse Project (JDT UI) - licensed under EPL v1.0 (http://www.eclipse.org/legal/epl-v10.html), + - famfamfam silk icon set (http://www.famfamfam.com/lab/icons/silk/) - licensed under Creative Commons Attribution 2.5 License (http://creativecommons.org/licenses/by/2.5/), +, +++ b/NOTICE, +, +GUI icons copied from several places:, + - Eclipse Project (JDT UI) - licensed under EPL v1.0 (http://www.eclipse.org/legal/epl-v10.html), + - famfamfam silk icon set (http://www.famfamfam.com/lab/icons/silk/) - licensed under Creative Commons Attribution 2.5 License (http://creativecommons.org/licenses/by/2.5/), +, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, + setInput(file);, + inputFiles.clear();, + private void setInput(File file) throws IOException, DecodeException {, + inputFiles.clear();, + inputFiles.add(new InputFile(file));, + }, +,
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.blocksmaker.BlockExceptionHandler;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.blocksmaker.BlockFinish;, +import jadx.core.dex.visitors.blocksmaker.BlockProcessor;, +import jadx.core.dex.visitors.blocksmaker.BlockSplitter;, + passes.add(new BlockSplitter());, + passes.add(new BlockProcessor());, + passes.add(new BlockExceptionHandler());, + passes.add(new BlockFinallyExtract());, + passes.add(new BlockFinish());, +, +, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.blocksmaker.BlockExceptionHandler;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.blocksmaker.BlockFinish;, +import jadx.core.dex.visitors.blocksmaker.BlockProcessor;, +import jadx.core.dex.visitors.blocksmaker.BlockSplitter;, + passes.add(new BlockSplitter());, + passes.add(new BlockProcessor());, + passes.add(new BlockExceptionHandler());, + passes.add(new BlockFinallyExtract());, + passes.add(new BlockFinish());, +, +, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + assert isFallback();, + code.add("PHI(").add(String.valueOf(insn.getArgsCount())).add(")");, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.blocksmaker.BlockExceptionHandler;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.blocksmaker.BlockFinish;, +import jadx.core.dex.visitors.blocksmaker.BlockProcessor;, +import jadx.core.dex.visitors.blocksmaker.BlockSplitter;, + passes.add(new BlockSplitter());, + passes.add(new BlockProcessor());, + passes.add(new BlockExceptionHandler());, + passes.add(new BlockFinallyExtract());, + passes.add(new BlockFinish());, +, +, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java,
[+++ /dev/null]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java]
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, + LOG.debug("Selected Font: {}", font);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, + LOG.debug("Selected Font: {}", font);, +++ b/jadx-gui/src/main/java/jadx/gui/ui/codearea/LineNumbers.java, + private static final Map<?, ?> DESKTOP_HINTS = (Map<?, ?>) Toolkit.getDefaultToolkit().getDesktopProperty("awt.font.desktophints");
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, + LOG.debug("Stop processing blocks after 'if': {}, method: {}", info, mth);, + if (badElse) {, + } else if (badThen) {, + info = new IfInfo(info.getCondition(), elseBlock, null);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, + LOG.debug("Stop processing blocks after 'if': {}, method: {}", info, mth);, + if (badElse) {, + } else if (badThen) {, + info = new IfInfo(info.getCondition(), elseBlock, null);, +++ b/jadx-core/src/test/java/jadx/tests/internal/others/TestIfInTry.java, +package jadx.tests.internal.others;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import java.io.File;, +import java.io.IOException;, +, +import org.junit.Test;, +, +import static jadx.tests.utils.JadxMatchers.containsOne;, +import static jadx.tests.utils.JadxMatchers.countString;, +import static org.junit.Assert.assertThat;, +, +public class TestIfInTry extends InternalJadxTest {, +, + public static class
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + Set<BlockNode> cacheSet = new HashSet<BlockNode>();, + BlockNode insnBlock = BlockUtils.getBlockByInsn(mth, exitInsn);, + if (insnBlock != null) {, + insnBlock.add(AFlag.SKIP);, + }, + exitInsn.add(AFlag.SKIP);, + BlockNode exit = null;, + } else if (exits.size() > 1) {, + if (exit != null) {, + } else {, + for (BlockNode exitBlock : exits) {, + // don't add exit blocks which leads to method end blocks ('return', 'throw', etc), + List<BlockNode> list = BlockUtils.buildSimplePath(exitBlock);, + if (list.isEmpty() || !list.get(list.size() - 1).getSuccessors().isEmpty()) {, + stack.addExit(exitBlock);, + }, + }, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + Set<BlockNode> cacheSet = new
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/TryCatchRegion.java, + StringBuilder sb = new StringBuilder();, + sb.append("Try: ").append(tryRegion);, + if (!catchRegions.isEmpty()) {, + sb.append(" catches: ").append(Utils.listToString(catchRegions.values()));, + }, + if (finallyRegion != null) {, + sb.append(" finally: ").append(finallyRegion);, + }, + return sb.toString();, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/TryCatchRegion.java, + StringBuilder sb = new StringBuilder();, + sb.append("Try: ").append(tryRegion);, + if (!catchRegions.isEmpty()) {, + sb.append(" catches: ").append(Utils.listToString(catchRegions.values()));, + }, + if (finallyRegion != null) {, + sb.append(" finally: ").append(finallyRegion);, + }, + return sb.toString();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockExceptionHandler.java, + if (handlerAttr == null) {, + return;, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/TryCatchRegion.java, + StringBuilder sb = new StringBuilder();, + sb.append("Try: ").append(tryRegion);, + if (!catchRegions.isEmpty()) {,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + protected void useType(CodeWriter code, ArgType type) {, + if (insn.getResult() != null && !insn.contains(AFlag.ARITH_ONEARG)) {, + if (insn.contains(AFlag.ARITH_ONEARG)) {, + makeArithOneArg(insn, code);, + return;, + }, + InsnArg arg = insn.getArg(1);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + protected void useType(CodeWriter code, ArgType type) {, + if (insn.getResult() != null && !insn.contains(AFlag.ARITH_ONEARG)) {, + if (insn.contains(AFlag.ARITH_ONEARG)) {, + makeArithOneArg(insn, code);, + return;, + }, + InsnArg arg = insn.getArg(1);, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.regions.loops.ForEachLoop;, + if (type instanceof ForEachLoop) {, + ForEachLoop forEachLoop = (ForEachLoop) type;, + code.startLine("for (");, + declareVar(code, forEachLoop.getVarArg());, + code.add(" : ");, + addArg(code, forEachLoop.getIterableArg(), false);, +
[+++ b/.gitlab-ci.yml, + - test, + - check, +java-8:, + stage: test, + image: openjdk:8, + script: ./gradlew clean build, +, +java-11:, + stage: test, + image: openjdk:11, + script: ./gradlew clean build, +, +check:, + stage: check, + image: openjdk:8, + - export JADX_LAST_TAG="$(git describe --abbrev=0 --tags)", + - export JADX_VERSION="${JADX_LAST_TAG:1}-dev-$(git rev-parse --short HEAD)", + - ./gradlew clean sonarqube -Dsonar.host.url=$SONAR_HOST -Dsonar.organization=$SONAR_ORG -Dsonar.login=$SONAR_TOKEN -Dsonar.branch.name=dev, + - ./gradlew clean dist]
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, + passes.add(new DebugInfoParseVisitor());, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new ConstructorVisitor());, + passes.add(new TypeInferenceVisitor());, + passes.add(new DebugInfoApplyVisitor());, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, + passes.add(new DebugInfoParseVisitor());, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, + if (fieldsCls != null && parentClass.equals(fieldsCls.getClassInfo())) {]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + if (classInfo.isRenamed(), + && !cls.getShortName().equals(cls.getAlias().getShortName())) {]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, + if (aList == null || aList.isEmpty()) {, + if (aList == null || aList.isEmpty()) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, + if (aList == null || aList.isEmpty()) {, + if (aList == null || aList.isEmpty()) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + if (!cls.getInterfaces().isEmpty() && !af.isAnnotation()) {, + if (!f.getArgs().isEmpty()) {, + ArgType[] generics = classInfo.getType().getGenericTypes();, + if (searchCollision(cls.dex(), useCls, classInfo)) {, + private static boolean searchCollision(DexNode dex, ClassInfo useCls, ClassInfo searchCls) {, + String shortName = searchCls.getShortName();, + if (inner.getShortName().equals(shortName), + && !inner.getClassInfo().equals(searchCls)) {, + return searchCollision(dex, useCls.getParentClass(), searchCls);, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, + if (aList == null || aList.isEmpty()) {, + if
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + ErrorsCounter.methodError(mth, "Inconsistent code");, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + ErrorsCounter.methodError(mth, "Inconsistent code");, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +import java.io.EOFException;, +, +import com.android.dx.io.instructions.ShortArrayCodeInput;, + private DecodedInstruction[] insnArr;, + public InsnDecoder(MethodNode mthNode) throws DecodeException {, + public void decodeInsns(Code mthCode) throws DecodeException {, + short[] encodedInstructions = mthCode.getInstructions();, + int size = encodedInstructions.length;, + DecodedInstruction[] decoded = new DecodedInstruction[size];, + ShortArrayCodeInput in = new ShortArrayCodeInput(encodedInstructions);, + try {, + while (in.hasMore()) {, + decoded[in.cursor()] = DecodedInstruction.decode(in);, + }, + } catch (EOFException e) {, + throw new DecodeException(method, "", e);, + }, + insnArr = decoded;, + }, +, + public InsnNode[] process() throws
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + public int getLoopsCount() {, + return loops.size();, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + public int getLoopsCount() {, + return loops.size();, + }, +, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + public int getLoopsCount() {, + return loops.size();, + }, +, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + public int getLoopsCount() {, + return loops.size();, + }, +, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/PostRegionVisitor.java, + IContainer startRegion = mth.getRegion();, + if (mth.isNoCode() || startRegion == null) {, + DepthRegionTraverser.traverse(mth, new ProcessTryCatchRegions(mth), startRegion);, + if (mth.getLoopsCount() != 0) {, + DepthRegionTraverser.traverse(mth, new ProcessLoopRegions(), startRegion);, + if (mth.getReturnType().equals(ArgType.VOID)) {, + DepthRegionTraverser.traverseAll(mth,
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, + passes.add(new DebugInfoParseVisitor());, + passes.add(new BlockProcessor());, + passes.add(new BlockExceptionHandler());, + passes.add(new BlockFinish());, +, + passes.add(new SSATransform());, + passes.add(new ConstructorVisitor());, + passes.add(new InitCodeVariables());, + passes.add(new MarkFinallyVisitor());, + passes.add(new TypeInferenceVisitor());, + passes.add(new DebugInfoApplyVisitor());, + passes.add(new CleanRegions());, + passes.add(new ProcessVariables());, + passes.add(new
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"--no-imports"}, converter = InvertedBooleanConverter.class,, + description = "disables use of imports, always writes entire package name"), + protected boolean useImports = true;, +, + public boolean isUsingImports() {, + return useImports;, + }, +, + @Override, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"--no-imports"}, converter = InvertedBooleanConverter.class,, + description = "disables use of imports, always writes entire package name"), + protected boolean useImports = true;, +, + public boolean isUsingImports() {, + return useImports;, + }, +, + @Override, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, + , + boolean isUsingImports();, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"--no-imports"}, converter = InvertedBooleanConverter.class,, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.BlockUtils;, + if (BlockUtils.isBlockMustBeCleared(b)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.BlockUtils;, + if (BlockUtils.isBlockMustBeCleared(b)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import jadx.core.utils.BlockUtils;, + // skip synthetic loop exit blocks, + BlockUtils.skipPredSyntheticPaths(block);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.BlockUtils;, + if (BlockUtils.isBlockMustBeCleared(b)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import jadx.core.utils.BlockUtils;, + // skip synthetic loop exit blocks, + BlockUtils.skipPredSyntheticPaths(block);, +++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, + public static boolean isBlockMustBeCleared(BlockNode b) {, + if (b.contains(AType.EXC_HANDLER) || b.contains(AFlag.SKIP)) {, + return true;, + }, + if (b.contains(AFlag.SYNTHETIC)) {, + List<BlockNode> s = b.getSuccessors();, + if (s.size() == 1 && s.get(0).contains(AType.EXC_HANDLER)) {, + return true;, + }, + }, + return false;, + },
[+++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, + if (codeGen == null && cls.getState() == PROCESSED) {, + return;, + }, + processDependencies(cls, passes);]
[+++ b/jadx-core/src/main/java/jadx/core/deobf/PackageNode.java, +, + if (pp.size() > 0) {, + } else {, + result.append(this.getAlias());, + }]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java, + appResClass = AndroidResourcesUtils.searchAppResClass(this, resStorage);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java, + appResClass = AndroidResourcesUtils.searchAppResClass(this, resStorage);, +++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java, +import java.util.HashMap;, +import java.util.HashSet;, +import java.util.LinkedList;, +import java.util.Map;, +import java.util.Set;, +import jadx.core.xmlgen.ResourceStorage;, +import jadx.core.xmlgen.entry.ResourceEntry;, + public static ClassNode searchAppResClass(RootNode root, ResourceStorage resStorage) {, + return makeClass(root, fullName, resStorage);, + private static ClassNode makeClass(RootNode root, String clsName, ResourceStorage resStorage) {, + ClassNode classNode = new ClassNode(dexNodes.get(0), r);, + generateMissingRCode(classNode, resStorage);, + return classNode;, + }, + , + private static void generateMissingRCode(ClassNode cls, ResourceStorage resStorage) {, + Map<String, List<ResourceEntry>> sortedMap = new HashMap<>();, + for(ResourceEntry ri : resStorage.getResources())
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (elType == null) {, + throw new JadxRuntimeException("Null array element type");, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (elType == null) {, + throw new JadxRuntimeException("Null array element type");, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +import org.jetbrains.annotations.Nullable;, + @Nullable("Null for method arguments"), + @Nullable, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (elType == null) {, + throw new JadxRuntimeException("Null array element type");, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +import org.jetbrains.annotations.Nullable;, + @Nullable("Null for method arguments"), + @Nullable, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, + if (lit == 0 && checkObjectInline(sVar)) {, + InsnNode assignInsn = insn.getResult().getAssignInsn();, + if (assignInsn != null) {, + assignInsn.add(AFlag.DONT_INLINE);, + }, +++
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.utils.exceptions.DecodeException;, + public JadxDecompiler() {, + public JadxDecompiler(IJadxArgs jadxArgs) {, + public void setOutputDir(File outDir) {, + void init() {, + sourcesOutDir = outDir;, + resOutDir = outDir;, + void parse() throws DecodeException {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.utils.exceptions.DecodeException;, + public JadxDecompiler() {, + public JadxDecompiler(IJadxArgs jadxArgs) {, + public void setOutputDir(File outDir) {, + void init() {, + sourcesOutDir = outDir;, + resOutDir = outDir;, + void parse() throws DecodeException {, +++
[+++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.ui.MainWindow;, + MainWindow window = new MainWindow(wrapper);, + window.pack();, + window.setLocationAndPosition();, + window.setVisible(true);, + window.setLocationRelativeTo(null);, + window.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);, + window.openFile();, + window.openFile(jadxArgs.getInput().get(0));, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.ui.MainWindow;, + MainWindow window = new MainWindow(wrapper);, + window.pack();, + window.setLocationAndPosition();, + window.setVisible(true);, + window.setLocationRelativeTo(null);, + window.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);, + window.openFile();, + window.openFile(jadxArgs.getInput().get(0));, +++ /dev/null, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.ui.MainWindow;, + MainWindow window = new MainWindow(wrapper);, + window.pack();, + window.setLocationAndPosition();, + window.setVisible(true);, + window.setLocationRelativeTo(null);, + window.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);, + window.openFile();, + window.openFile(jadxArgs.getInput().get(0));, +++ /dev/null, +++ /dev/null, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import jadx.gui.ui.MainWindow;, + MainWindow window = new MainWindow(wrapper);, + window.pack();, + window.setLocationAndPosition();, + window.setVisible(true);, + window.setLocationRelativeTo(null);, + window.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);, +
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +import jadx.core.dex.attributes.AFlag;, + if (field.contains(AFlag.DONT_RENAME)), + continue;, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +import jadx.core.dex.attributes.AFlag;, + if (field.contains(AFlag.DONT_RENAME)), + continue;, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, + DONT_RENAME, // do not rename during deobfuscation, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +import jadx.core.dex.attributes.AFlag;, + if (field.contains(AFlag.DONT_RENAME)), + continue;, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, + DONT_RENAME, // do not rename during deobfuscation, +++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java, +import jadx.core.dex.attributes.AFlag;, + fieldNode.add(AFlag.DONT_RENAME);]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + private int clsDeclLine;, + af = af.remove(AccessFlags.ACC_FINAL), + .remove(AccessFlags.ACC_ABSTRACT), + .remove(AccessFlags.ACC_STATIC);, + if (innerCls.contains(AFlag.DONT_GENERATE), + || innerCls.isAnonymous()) {, + continue;, + }, +, + private boolean isInnerClassesPresents() {, + for (ClassNode innerCls : cls.getInnerClasses()) {, + if (!innerCls.isAnonymous()) {, + return true;, + }, + }, + return false;, + if (mth.contains(AFlag.DONT_GENERATE)) {, + continue;, + }, + try {, +, + private boolean isMethodsPresents() {, + for (MethodNode mth : cls.getMethods()) {, + if (!mth.contains(AFlag.DONT_GENERATE)) {, + return true;, + }, + }, + return false;, + private boolean isFieldsPresents() {, + for (FieldNode field
[+++ b/README.md, + --no-replace-consts - don't replace constant value with matching constant field, + --escape-unicode - escape non latin characters in strings (with \u), + --cfg - save methods control flow graph to dot file, + --raw-cfg - save methods control flow graph (use raw instructions), + -f, --fallback - make simple dump (using goto instead of 'if', 'for', etc), + -v, --verbose - verbose output, +++ b/README.md, + --no-replace-consts - don't replace constant value with matching constant field, + --escape-unicode - escape non latin characters in strings (with \u), + --cfg - save methods control flow graph to
[+++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +import jadx.api.ResourceFile;, + public List<ResourceFile> getResources() {, + return decompiler.getResources();, + }, +, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +import jadx.api.ResourceFile;, + public List<ResourceFile> getResources() {, + return decompiler.getResources();, + }, +, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java, +import org.fife.ui.rsyntaxtextarea.SyntaxConstants;, +, + public String getContent() {, + public String getSyntaxName() {, + return SyntaxConstants.SYNTAX_STYLE_JAVA;, + }, +, + @Override, + public Integer getSourceLine(int line) {, + return cls.getSourceLine(line);, + }, +, + @Override, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +import jadx.api.ResourceFile;, + public List<ResourceFile> getResources() {, + return decompiler.getResources();, + }, +, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java, +import org.fife.ui.rsyntaxtextarea.SyntaxConstants;, +, + public String getContent() {, + public String getSyntaxName() {, + return
[+++ b/.codecov.yml, +coverage:, + precision: 2, + round: down, + range: "50...100", +, + status:, + project:, + default: on, + patch:, + default: on, + changes:, + default: off, +, +comment: false]
[+++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java, +import java.util.HashMap;, +import org.jetbrains.annotations.NotNull;, +import jadx.core.deobf.NameMapper;, +import jadx.core.dex.info.AccessInfo;, +import jadx.core.dex.info.ConstStorage;, + Map<Integer, FieldNode> resFieldsMap = fillResFieldsMap(resCls);, + ClassNode typeCls = innerClsMap.computeIfAbsent(, + resource.getTypeName(),, + name -> addClassForResType(resCls, rClsExists, name), + );, + String resName = resource.getKeyName();, + FieldNode rField = typeCls.searchFieldByName(resName);, + FieldInfo rFieldInfo = FieldInfo.from(typeCls.dex(), typeCls.getClassInfo(), resName, ArgType.INT);, + FieldNode fieldNode = resFieldsMap.get(resource.getId());, + if (fieldNode != null, + && !fieldNode.getName().equals(resName), + && NameMapper.isValidIdentifier(resName)) {, + fieldNode.getFieldInfo().setAlias(resName);, +, + @NotNull, + private static ClassNode addClassForResType(ClassNode resCls, boolean rClsExists, String typeName) {, + ClassNode newTypeCls = new ClassNode(resCls.dex(), resCls.getFullName() + "$" + typeName,, + AccessFlags.ACC_PUBLIC | AccessFlags.ACC_STATIC
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new DebugInfoVisitor());, + passes.add(new TypeInference());, +, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new FinishTypeInference());, +, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new DebugInfoVisitor());, + passes.add(new TypeInference());, +, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, + private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new DebugInfoVisitor());,
[+++ b/.releaserc.yml]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ssa.SSATransform;, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ssa.SSATransform;, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (callMthNode != null && inlineMethod(callMthNode, insn, code)) {, + private boolean inlineMethod(MethodNode callMthNode, InvokeNode insn, CodeWriter code) throws CodegenException {, + MethodInlineAttr mia = (MethodInlineAttr) callMthNode.getAttributes().get(AttributeType.METHOD_INLINE);, + if (mia == null) {, + return false;, + }, + InsnNode inl = mia.getInsn();, + int regNum = r.getRegNum();, + if (regNum >= regs.length) {, + LOG.warn("Unknown register number {} in method call: {} from {}", r, callMthNode, mth);, + InsnArg repl = regs[regNum];, + LOG.warn("Not passed register {} in method call: {} from {}", r, callMthNode, mth);, +
[+++ b/.gitlab-ci.yml, +image: java:8, +, +variables:, + GRADLE_OPTS: "-Dorg.gradle.daemon=false", + TERM: "dumb", +, +before_script:, + - chmod +x gradlew, +, +stages:, + - build, +, +build:, + stage: build, + script:, + - sed -i " 1 s/.*/&-b${CI_JOB_ID}/" version, + - ./gradlew -g /cache/.gradle clean build jacocoTestReport dist, + artifacts:, + paths:, + - build/jadx*.zip, +++ b/.gitlab-ci.yml, +image: java:8, +, +variables:, + GRADLE_OPTS: "-Dorg.gradle.daemon=false", + TERM: "dumb", +, +before_script:, + - chmod +x gradlew, +, +stages:, + - build, +, +build:, + stage: build, + script:, + - sed -i " 1 s/.*/&-b${CI_JOB_ID}/" version, + - ./gradlew -g /cache/.gradle
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java, +import java.io.EOFException;, + public void readFully(byte[] b) throws IOException {, + readFully(b, 0, b.length);, + }, +, + public void readFully(byte[] b, int off, int len) throws IOException {, + readPos += len;, + if (len < 0), + throw new IndexOutOfBoundsException();, + int n = 0;, + while (n < len) {, + int count = input.read(b, off + n, len - n);, + if (count < 0), + throw new EOFException();, + n += count;, + }, + }, +, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java, +import java.io.EOFException;, + public void readFully(byte[] b) throws IOException {, + readFully(b, 0,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + mth.addError("Method generation error: " + e.getMessage(), e);, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + mth.addError("Method generation error: " + e.getMessage(), e);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + } else if (mth.contains(AFlag.SKIP_FIRST_ARG)) {, + args = args.subList(1, args.size());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + mth.addError("Method generation error: " + e.getMessage(), e);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + } else if (mth.contains(AFlag.SKIP_FIRST_ARG)) {, + args = args.subList(1, args.size());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, + useList.removeIf(registerArg -> registerArg == arg);, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + mth.addError("Method generation error: " + e.getMessage(), e);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + } else if (mth.contains(AFlag.SKIP_FIRST_ARG)) {, + args = args.subList(1, args.size());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, + useList.removeIf(registerArg -> registerArg == arg);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + public
[+++ b/jadx-core/src/test/java/jadx/tests/api/compiler/DynamicCompiler.java, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, + private static final Logger LOG = LoggerFactory.getLogger(DynamicCompiler.class);, +, + if (compiler == null) {, + LOG.error("Can not find compiler, please use JDK instead");, + return false;, + }]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +import jadx.core.dex.attributes.AttributeFlag;, +import jadx.core.dex.instructions.ConstClassNode;, +import jadx.core.dex.instructions.ConstStringNode;, +import jadx.core.dex.instructions.FillArrayNode;, +import jadx.core.dex.instructions.IndexInsnNode;, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.dex.instructions.InvokeNode;, +import jadx.core.dex.instructions.SwitchNode;, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.instructions.args.LiteralArg;, +import jadx.core.dex.instructions.args.RegisterArg;, +import jadx.core.dex.nodes.BlockNode;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, +import jadx.core.dex.nodes.InsnNode;, +import jadx.core.dex.nodes.MethodNode;, + if (mth.isNoCode()) {, + }, + ClassNode parentClass = mth.getParentClass();, + mth.getAttributes().add(AttributeFlag.INCONSISTENT_CODE);, + FieldNode f = parentClass.getConstFieldByLiteralArg((LiteralArg) arg);, + case CONST_CLASS: {, + FieldNode f;, + }, + FieldNode f = parentClass.getConstField(sn.getKeys()[k]);, + if (insn.getArgsCount() > 0 && insn.getArg(0).isLiteral()) {, + FieldNode f = parentClass.getConstFieldByLiteralArg(arg);, + if (superCall != null && !parentClass.isEnum() && superCall.getArgsCount() != 0) {, + if (handlerAttr == null)
[+++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, + private final String[] exts;, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, + private final String[] exts;, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, + private final JadxDecompiler jadxRef;, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, + private final String[] exts;, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, + private final JadxDecompiler jadxRef;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, + return condition.getMode() != Mode.NOT;, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, + private final String[] exts;, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, + private final JadxDecompiler jadxRef;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, + return condition.getMode() != Mode.NOT;, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumMapAttr.java, + private final Map<Object, Object> map = new HashMap<Object, Object>();, + private final Map<FieldNode, KeyValueMap> fieldsMap = new HashMap<FieldNode, KeyValueMap>();, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, + private final String[] exts;, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, + private final JadxDecompiler jadxRef;,
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, + public ThreadPoolExecutor saveAll(File dir) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, + public ThreadPoolExecutor saveAll(File dir) {, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, + if (!m.getAccessFlags().isSynthetic()) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, + public ThreadPoolExecutor saveAll(File dir) {, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, + if (!m.getAccessFlags().isSynthetic()) {, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +import jadx.core.dex.instructions.args.ArgType;, + public ArgType getType() {, + return field.getType();, + }, +, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, + public ThreadPoolExecutor saveAll(File dir) {, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, + if (!m.getAccessFlags().isSynthetic()) {, +++ b/jadx-core/src/main/java/jadx/api/JavaField.java, +import jadx.core.dex.instructions.args.ArgType;, + public ArgType getType() {, + return field.getType();, + }, +, +++ b/jadx-core/src/main/java/jadx/api/JavaMethod.java, +import jadx.core.dex.instructions.args.ArgType;, +import java.util.List;, +, + public
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + code.add(") ");, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + code.add(") ");, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/MthParameterArg.java, + sVar.setTypeImmutable(type);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + code.add(") ");, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/MthParameterArg.java, + sVar.setTypeImmutable(type);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, + @Deprecated, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + code.add(") ");, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/MthParameterArg.java, + sVar.setTypeImmutable(type);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, + @Deprecated, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, + private boolean typeImmutable;, + public int getRegNum() {, + return regNum;, + }, +, + ArgType acceptedType;, + if (typeImmutable) {, + // don't change type, just update types in useList, + acceptedType = this.type;, + } else {, + acceptedType = type;, + this.type = acceptedType;, + }, + assign.type = acceptedType;, + useList.get(i).type =
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java, + List<TypeUpdateEntry> updates = updateInfo.getUpdates();, + updates.forEach(TypeUpdateEntry::apply);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java, + List<TypeUpdateEntry> updates = updateInfo.getUpdates();, + updates.forEach(TypeUpdateEntry::apply);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdateEntry.java, +package jadx.core.dex.visitors.typeinference;, +, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.instructions.args.InsnArg;, +, +public final class TypeUpdateEntry {, + private final InsnArg arg;, + private final ArgType type;, +, + public TypeUpdateEntry(InsnArg arg, ArgType type) {, + this.arg = arg;, + this.type = type;, + }, +, + public void apply() {, + arg.setType(type);, + }, +, + public InsnArg getArg() {, + return arg;, + }, +, + public ArgType getType() {, + return type;, + }, +, + @Override, + public String
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, + } catch (Exception e) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, + } catch (Exception e) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + if (catchBlocks.length == 0 && tries.length == 0) {, + return;, + }, + InsnNode insn = insnByOffset[offset];, + insn.add(AFlag.TRY_ENTER);, + insn = insnByOffset[offset];, + catchBlock.addInsn(insn);, + } else {, + insn.add(AFlag.TRY_LEAVE);, + if (parentClass.getClassInfo().isInner(), + && !parentClass.getAccessFlags().isStatic()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, + } catch (Exception e) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + if (catchBlocks.length == 0 && tries.length == 0) {, + return;, + }, + InsnNode insn = insnByOffset[offset];, + insn.add(AFlag.TRY_ENTER);, + insn = insnByOffset[offset];, + catchBlock.addInsn(insn);, + } else {,
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/DepthRegionTraversal.java, + repeat = traverseIterativeStepInternal(mth, visitor, mth.getRegion());, + if (k++ > ITERATIVE_LIMIT) {, + throw new JadxOverflowException("Iterative traversal limit reached, method: " + mth);, + }, + } while (repeat);, + }, +, + public static void traverseIncludingExcHandlers(MethodNode mth, IRegionIterativeVisitor visitor) {, + boolean repeat;, + int k = 0;, + do {, + repeat = traverseIterativeStepInternal(mth, visitor, mth.getRegion());, + if (!repeat) {, + for (ExceptionHandler h : mth.getExceptionHandlers()) {, + repeat = traverseIterativeStepInternal(mth, visitor, h.getHandlerRegion());, + if (repeat) {, + break;, + }, + }, + }, + private static boolean traverseIterativeStepInternal(MethodNode mth, IRegionIterativeVisitor visitor,, + if
[+++ b/jadx-core/build.gradle, + compile 'uk.com.robust-it:cloning:1.9.2', +++ b/jadx-core/build.gradle, + compile 'uk.com.robust-it:cloning:1.9.2', +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/LineAttrNode.java, +, + public void copyLines(LineAttrNode lineAttrNode) {, + setSourceLine(lineAttrNode.getSourceLine());, + setDecompiledLine(lineAttrNode.getDecompiledLine());, + }, +++ b/jadx-core/build.gradle, + compile 'uk.com.robust-it:cloning:1.9.2', +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/LineAttrNode.java, +, + public void copyLines(LineAttrNode lineAttrNode) {, + setSourceLine(lineAttrNode.getSourceLine());, + setDecompiledLine(lineAttrNode.getDecompiledLine());, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ConstClassNode.java, + public InsnNode copy() {, + return copyCommonParams(new ConstClassNode(clsType));, + }, +, + @Override, +++ b/jadx-core/build.gradle, + compile 'uk.com.robust-it:cloning:1.9.2', +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/LineAttrNode.java, +, + public void copyLines(LineAttrNode lineAttrNode) {, + setSourceLine(lineAttrNode.getSourceLine());, + setDecompiledLine(lineAttrNode.getDecompiledLine());, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ConstClassNode.java, + public InsnNode copy() {, + return copyCommonParams(new ConstClassNode(clsType));, + }, +, + @Override, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/ConstStringNode.java,
[+++ b/jadx-core/build.gradle, + compile 'com.intellij:annotations:12.0', +++ b/jadx-core/build.gradle, + compile 'com.intellij:annotations:12.0', +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, + // not null after SSATransform pass, + private SSAVar sVar;, + return sVar.getAssign().getParentInsn();, + InsnNode parent = sVar.getAssign().getParentInsn();, +++ b/jadx-core/build.gradle, + compile 'com.intellij:annotations:12.0', +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, + // not null after SSATransform pass, + private SSAVar sVar;, + return sVar.getAssign().getParentInsn();, + InsnNode parent = sVar.getAssign().getParentInsn();, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, +import org.jetbrains.annotations.NotNull;, +import org.jetbrains.annotations.Nullable;, +, + @NotNull, + @Nullable, + public SSAVar(int regNum, int v, @NotNull RegisterArg assign) {, + if (assign.getParentInsn() != null) {, + @NotNull, + public void setAssign(@NotNull RegisterArg assign) {, + public void setUsedInPhi(@Nullable PhiInsn usedInPhi)
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (callMthNode != null && inlineMethod(callMthNode, insn, code)) {, + code.add(callMthNode.getAlias());, + } else {, + }, + ArgType origType;, + List<RegisterArg> arguments = callMth.getArguments(false);, + if (arguments.isEmpty()) {, + mth.addComment("JADX WARN: used method not loaded: " + callMth + ", types can be incorrect");, + origType = callMth.getMethodInfo().getArgumentsTypes().get(origPos);, + } else {, + origType = arguments.get(origPos).getInitType();, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (callMthNode != null && inlineMethod(callMthNode, insn, code)) {, + code.add(callMthNode.getAlias());, + } else {, + }, + ArgType origType;, + List<RegisterArg> arguments = callMth.getArguments(false);, + if (arguments.isEmpty()) {, + mth.addComment("JADX WARN: used method
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + // 'static' and 'private' modifier not allowed for top classes (not inner), + af = af.remove(AccessFlags.ACC_STATIC).remove(AccessFlags.ACC_PRIVATE);, + code.startLine(f.getField().getAlias());, + if (isFieldsPresents()) {, + code.startLine();, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + // 'static' and 'private' modifier not allowed for top classes (not inner), + af = af.remove(AccessFlags.ACC_STATIC).remove(AccessFlags.ACC_PRIVATE);, + code.startLine(f.getField().getAlias());, + if (isFieldsPresents()) {, + code.startLine();, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumClassAttr.java, +import jadx.core.dex.info.FieldInfo;, + private final FieldInfo field;, + public EnumField(FieldInfo field, ConstructorInsn co, int startArg) {, + this.field = field;, + public FieldInfo getField() {, + return field;, + return field + "(" + constrInsn + ") " +
[+++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, +package jadx.cli;, +, +import java.io.PrintStream;, +import java.lang.reflect.Field;, +import java.util.ArrayList;, +import java.util.LinkedHashMap;, +import java.util.List;, +import java.util.Map;, +, +import com.beust.jcommander.JCommander;, +import com.beust.jcommander.ParameterDescription;, +import com.beust.jcommander.ParameterException;, +import com.beust.jcommander.Parameterized;, +, +import jadx.api.JadxDecompiler;, +, +public class JCommanderWrapper<T> {, + private final JCommander jc;, +, + public JCommanderWrapper(T obj) {, + this.jc = JCommander.newBuilder().addObject(obj).build();, + }, +, + public boolean parse(String[] args) {, + try {, + jc.parse(args);, + return true;, + } catch (ParameterException e) {, + System.err.println("Arguments parse error: " + e.getMessage());, + printUsage();, + return false;, + }, + }, +, + public void overrideProvided(T obj) {, + List<ParameterDescription> fieldsParams =
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + "Incorrect type for fill-array insn " + InsnUtils.formatOffset(insn.getOffset()), + + ", element type: " + elType + ", insn element type: " + insnElementType);, + if (!elType.isTypeKnown()) {, + elType = insnElementType.isTypeKnown() ? insnElementType : elType.selectFirst();, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + "Incorrect type for fill-array insn " + InsnUtils.formatOffset(insn.getOffset()), + + ", element type: " + elType + ", insn element type: " + insnElementType);, + if (!elType.isTypeKnown()) {, + elType = insnElementType.isTypeKnown() ? insnElementType : elType.selectFirst();, + }, +++ b/jadx-core/src/test/java/jadx/tests/internal/TestTmp2.java, +package jadx.tests.internal;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import
[+++ b/build.gradle, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, + } catch (Exception e) {, + private static void checkArgs(JadxCLIArgs jadxArgs) throws Exception {, + if (jadxArgs.getInput().isEmpty()) {, + LOG.error("Please specify input file");, + jadxArgs.printUsage();, + System.exit(1);, + }, + if (pos != -1) {, + } else {, + }, + if (outputDir.exists() && !outputDir.isDirectory()) {, + throw new Exception("Output directory exists as file " + outputDir);, + }, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, + } catch (Exception e) {, + private static void checkArgs(JadxCLIArgs jadxArgs) throws Exception {, + if (jadxArgs.getInput().isEmpty()) {, + LOG.error("Please specify input file");, + jadxArgs.printUsage();, + System.exit(1);,
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, + private int numtabs=-1;, + numtabs+=1;, + for(int i=0; i<numtabs; i++) System.out.print("\t");, + System.out.print("<" + strings[startNSName]);, + if(attributeCount>0) System.out.print(" ");, + //if(attributeNS!=-1) System.out.println("ai["+i+"] Sns: " + strings[attributeNS]);, + if(attributeName!=-1) System.out.println("ai["+i+"] Sns: " + strings[attributeName]);, + if(attrValDataType==0x3) System.out.print(strings[attributeName] + "=\"" + strings[attrValData]+"\"");, + else if(attrValDataType==0x10) System.out.print(strings[attributeName] + "=\"" + attrValData+"\"");, + else if(attrValDataType==0x12) {, + // TODO: data is always -1, FIXME, + if(attrValData==0) System.out.print(strings[attributeName] + "=\"false\"");, + else if(attrValData==1 || attrValData==-1) System.out.print(strings[attributeName] + "=\"true\"");, + else System.out.print(strings[attributeName] + "=\"UNKNOWN\"");, + }, + else System.out.print(strings[attributeName] + " = UNKNOWN DATA TYPE: " + attrValDataType);, + System.out.print(" ");, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, + THIS,, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, + THIS,, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, + // must be implemented in RegisterArg, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, + THIS,, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, + // must be implemented in RegisterArg, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +import jadx.core.dex.attributes.AFlag;, + if (contains(AFlag.THIS)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, + THIS,, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, + // must be implemented in RegisterArg, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +import jadx.core.dex.attributes.AFlag;, + if (contains(AFlag.THIS)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/TypeImmutableArg.java, + public static final String THIS_ARG_NAME = "this";, + if (isThis()) {, + return THIS_ARG_NAME;, + if (isThis()) {, + sVar.setName(THIS_ARG_NAME);, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, + THIS,, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, + // must be implemented in RegisterArg, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, +import jadx.core.dex.attributes.AFlag;,
[+++ b/.travis.yml, + if: branch = master AND repo = env(MAIN_REPO) AND type = push, + if: branch = release AND repo = env(MAIN_REPO) AND type = push]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockExceptionHandler.java, + processTryCatchBlocks(block);, + ExcHandlerAttr handlerAttr = block.get(AType.EXC_HANDLER);, + if (!block.getInstructions().isEmpty()) {, + InsnNode me = block.getInstructions().get(0);, + resArg.copyAttributesFrom(me);, + return;, + }, + }, + return eh.isCatchAll() || eh.isFinally();, + private static void processTryCatchBlocks(BlockNode block) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockExceptionHandler.java, + processTryCatchBlocks(block);, + ExcHandlerAttr handlerAttr = block.get(AType.EXC_HANDLER);, + if (!block.getInstructions().isEmpty()) {, + InsnNode me = block.getInstructions().get(0);, + resArg.copyAttributesFrom(me);, + return;, + }, + }, + return eh.isCatchAll() || eh.isFinally();, + private static void processTryCatchBlocks(BlockNode block) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, +import jadx.core.dex.trycatch.ExcHandlerAttr;, + BlockNode newBlock = startNewBlock(mth, insn.getOffset());, + connect(curBlock, newBlock);, + curBlock = newBlock;, + curBlock = connectNewBlock(mth, curBlock, insn.getOffset());,
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + protected int deobfuscationMinLength = 4;, + protected boolean deobfuscationUseSourceNameAsAlias = true;, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + protected int deobfuscationMinLength = 4;, + protected boolean deobfuscationUseSourceNameAsAlias = true;, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, + private static final Logger LOG = LoggerFactory.getLogger(JadxSettings.class);, + private static final int CURRENT_SETTINGS_VERSION = 1;, + private int settingsVersion = 0;, +, + if (settingsVersion != CURRENT_SETTINGS_VERSION) {, + upgradeSettings(settingsVersion);, + }, +, + private void upgradeSettings(int fromVersion) {, + LOG.debug("upgrade settings from version: {} to {}", fromVersion, CURRENT_SETTINGS_VERSION);, + if (fromVersion == 0) {, + setDeobfuscationMinLength(4);, + setDeobfuscationUseSourceNameAsAlias(true);, + setDeobfuscationForceSave(true);, + setThreadsCount(1);, +
[+++ b/build.gradle, + compile 'com.google.android:android:4.1.1.4', +++ b/build.gradle, + compile 'com.google.android:android:4.1.1.4', +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +//import jadx.core.xmlgen.BinaryXMLParser;, +/*, +*/, +++ b/build.gradle, + compile 'com.google.android:android:4.1.1.4', +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +//import jadx.core.xmlgen.BinaryXMLParser;, +/*, +*/, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +import java.lang.reflect.Field;, +, +import java.util.HashMap;, +import java.util.Map;, +, +import android.R.style;, +//import android.content.res.Resources;, +, + Map<Integer, String> styleMap = null;, + styleMap = new HashMap<Integer, String>();, + if(null==styleMap) die("null==styleMap");, + for(Field f : android.R.style.class.getFields()) {, + try {, + styleMap.put(f.getInt(f.getType()),f.getName());, + } catch(IllegalAccessException iae) {, + die("IAE");, + }, + }, + , + if(styleIndex!=0) System.out.println("startNS: styleIndex: " + styleIndex);, + } else if(attrValDataType==0x1) {, + if(attrValData<0x7f000000) {, + //System.out.println("0x"+Integer.toHexString(attrValData));, +
[+++ b/.gitignore, +*-tmp/, +, +++ b/.gitignore, +*-tmp/, +, +++ b/build.gradle, +++ b/.gitignore, +*-tmp/, +, +++ b/build.gradle, +++ b/jadx-core/build.gradle, +ext.jadxClasspath = 'clsp-data/android-4.3.jar', +, + compile 'ch.qos.logback:logback-classic:1.0.13', +, + runtime files(jadxClasspath), +++ b/.gitignore, +*-tmp/, +, +++ b/build.gradle, +++ b/jadx-core/build.gradle, +ext.jadxClasspath = 'clsp-data/android-4.3.jar', +, + compile 'ch.qos.logback:logback-classic:1.0.13', +, + runtime files(jadxClasspath), +++ b/jadx-core/clsp-data/android-4.3.jar, +++ b/.gitignore, +*-tmp/, +, +++ b/build.gradle, +++ b/jadx-core/build.gradle, +ext.jadxClasspath = 'clsp-data/android-4.3.jar', +, + compile 'ch.qos.logback:logback-classic:1.0.13', +, + runtime files(jadxClasspath), +++ b/jadx-core/clsp-data/android-4.3.jar, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, + List<ClassNode> classNodeList = root.getClasses(false);, + List<JavaClass> classes = new ArrayList<JavaClass>(classNodeList.size());, + for (ClassNode classNode : classNodeList) {, + for (ClassNode cls : root.getClasses(false)) {, +
[+++ b/jadx-gui/build.gradle, + defaultJvmOpts = ['-Xms128M', '-Xmx4g', '-Dawt.useSystemAAFontSettings=lcd', '-Dswing.aatext=true'], + jvmOptions = ['-Dawt.useSystemAAFontSettings=lcd', '-Dswing.aatext=true'], +, +++ b/jadx-gui/build.gradle, + defaultJvmOpts = ['-Xms128M', '-Xmx4g', '-Dawt.useSystemAAFontSettings=lcd', '-Dswing.aatext=true'], + jvmOptions = ['-Dawt.useSystemAAFontSettings=lcd', '-Dswing.aatext=true'], +, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import static jadx.gui.utils.Utils.FONT_HACK;, +, + private static final Font DEFAULT_FONT = FONT_HACK != null ? FONT_HACK : new RSyntaxTextArea().getFont();, +++ b/jadx-gui/build.gradle, + defaultJvmOpts = ['-Xms128M', '-Xmx4g', '-Dawt.useSystemAAFontSettings=lcd', '-Dswing.aatext=true'], + jvmOptions = ['-Dawt.useSystemAAFontSettings=lcd', '-Dswing.aatext=true'], +, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import static jadx.gui.utils.Utils.FONT_HACK;, +, + private static final Font DEFAULT_FONT = FONT_HACK != null ? FONT_HACK : new RSyntaxTextArea().getFont();, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, +import static jadx.gui.utils.Utils.FONT_HACK;, +, + registerBundledFonts();, + public static void
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import static jadx.core.utils.Utils.lockList;, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import static jadx.core.utils.Utils.lockList;, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +import static jadx.core.utils.Utils.lockList;, +, + exceptionHandlers = Collections.emptyList();, + loops = Collections.emptyList();, + blocks = lockList(blocks);, + exitBlocks = lockList(exitBlocks);, + loops = lockList(loops);, + blocks.forEach(BlockNode::lock);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import static jadx.core.utils.Utils.lockList;, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +import static jadx.core.utils.Utils.lockList;, +, + exceptionHandlers = Collections.emptyList();, + loops = Collections.emptyList();, + blocks = lockList(blocks);, + exitBlocks = lockList(exitBlocks);, + loops = lockList(loops);, + blocks.forEach(BlockNode::lock);, +++ b/jadx-core/src/main/java/jadx/core/utils/ImmutableList.java, +package jadx.core.utils;, +, +import java.util.Arrays;, +import java.util.Collection;, +import java.util.Comparator;, +import java.util.Iterator;, +import java.util.List;, +import java.util.ListIterator;, +import java.util.Objects;, +import java.util.RandomAccess;, +import java.util.function.Consumer;, +import java.util.function.Predicate;,
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java, + res.setContent(makeXmlDump());, + public CodeWriter makeXmlDump() {, + CodeWriter writer = new CodeWriter();, + writer.startLine("<?xml version=\"1.0\" encoding=\"utf-8\"?>");, + writer.startLine("<resources>");, + writer.incIndent();, +, + for (ResourceEntry ri : resStorage.getResources()) {, + String format = String.format("<public type=\"%s\" name=\"%s\" id=\"%s\" />",, + ri.getTypeName(), ri.getKeyName(), ri.getId());, + writer.startLine(format);, + }, + writer.decIndent();, + writer.startLine("</resources>");, + writer.finish();, + return writer;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java, + res.setContent(makeXmlDump());, + public CodeWriter makeXmlDump() {, + CodeWriter writer = new CodeWriter();, + writer.startLine("<?xml version=\"1.0\" encoding=\"utf-8\"?>");, + writer.startLine("<resources>");, + writer.incIndent();, +, + for (ResourceEntry ri : resStorage.getResources()) {, + String format = String.format("<public type=\"%s\" name=\"%s\" id=\"%s\"
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java, + if (!RegionUtils.hasExitBlock(ifRegion.getThenRegion())) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfRegionVisitor.java, + if (!RegionUtils.hasExitBlock(ifRegion.getThenRegion())) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import java.util.Optional;, + insertLoopBreak(stack, loop, loopExit, exitEdge);, + if (found && !checkLoopExits(loop, block)) {, + found = false;, + }, + private boolean checkLoopExits(LoopInfo loop, BlockNode mainExitBlock) {, + List<Edge> exitEdges = loop.getExitEdges();, + if (exitEdges.size() < 2) {, + return true;, + }, + Optional<Edge> mainEdgeOpt = exitEdges.stream().filter(edge -> edge.getSource() == mainExitBlock).findFirst();, + if (!mainEdgeOpt.isPresent()) {, + throw new JadxRuntimeException("Not found exit edge by exit block: " + mainExitBlock);, + }, + Edge mainExitEdge = mainEdgeOpt.get();, + BlockNode mainOutBlock = skipSyntheticSuccessor(mainExitEdge.getTarget());, + for (Edge
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java, + LOG.error("Failed to decode 9-patch png image, path: {}", name, e);, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java, + LOG.error("Failed to decode 9-patch png image, path: {}", name, e);, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java, +public class JClass extends JLoadableNode {, + @Override, + public void loadNode() {, + getRootClass().load();, + }, +, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java, + LOG.error("Failed to decode 9-patch png image, path: {}", name, e);, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JClass.java, +public class JClass extends JLoadableNode {, + @Override, + public void loadNode() {, + getRootClass().load();, + }, +, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JLoadableNode.java, +package jadx.gui.treemodel;, +, +public abstract class JLoadableNode extends JNode {, + public abstract void loadNode();, +}, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java,
[+++ b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java, + res.append('"');, + res.append('"');, + return res.toString();, + res.append('\'');, + res.append('\'');, + return res.toString();]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new BlockProcessor());, + passes.add(new BlockExceptionHandler());, + passes.add(new BlockFinallyExtract());, + passes.add(new BlockFinish());, +, + passes.add(new SSATransform());, + passes.add(new DebugInfoVisitor());, + passes.add(new TypeInference());, +, + passes.add(new FinishTypeInference());, + passes.add(new EliminatePhiNodes());, +, +, + passes.add(new LoopRegionVisitor());, + passes.add(new ProcessVariables());, +, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new BlockProcessor());, +
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + root.load(inputFiles);, +, + BinaryXMLParser bxp = new BinaryXMLParser(root);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + root.load(inputFiles);, +, + BinaryXMLParser bxp = new BinaryXMLParser(root);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, + public int getIndent() {, + return indent;, + }, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + root.load(inputFiles);, +, + BinaryXMLParser bxp = new BinaryXMLParser(root);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, + public int getIndent() {, + return indent;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java, + public List<DexNode> getDexNodes() {, + return dexNodes;, + }, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + root.load(inputFiles);, +, + BinaryXMLParser bxp = new BinaryXMLParser(root);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, + public int getIndent() {, + return indent;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/AbstractRegionVisitor.java, + public boolean enterRegion(MethodNode mth, IRegion region) {, + return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/AbstractRegionVisitor.java, + public boolean enterRegion(MethodNode mth, IRegion region) {, + return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, + public boolean enterRegion(MethodNode mth, IRegion region) {, + return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/AbstractRegionVisitor.java, + public boolean enterRegion(MethodNode mth, IRegion region) {, + return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, + public boolean enterRegion(MethodNode mth, IRegion region) {, + return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CleanRegions.java, + public boolean enterRegion(MethodNode mth, IRegion region) {, + return true;, + return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/AbstractRegionVisitor.java, + public boolean enterRegion(MethodNode mth, IRegion region) {, + return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, + public boolean
[+++ b/jadx-gui/build.gradle, +, + compile 'org.apache.commons:commons-lang3:3.7', +, + compile 'io.reactivex.rxjava2:rxjava:2.1.13', + compile "com.github.akarnokd:rxjava2-swing:0.2.12", +++ b/jadx-gui/build.gradle, +, + compile 'org.apache.commons:commons-lang3:3.7', +, + compile 'io.reactivex.rxjava2:rxjava:2.1.13', + compile "com.github.akarnokd:rxjava2-swing:0.2.12", +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/CodeNode.java, + private final transient int lineNum;, + public CodeNode(JNode jNode, int lineNum, StringRef lineStr) {, + this.line = lineStr;, +++ b/jadx-gui/build.gradle, +, + compile 'org.apache.commons:commons-lang3:3.7', +, + compile 'io.reactivex.rxjava2:rxjava:2.1.13', + compile "com.github.akarnokd:rxjava2-swing:0.2.12", +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/CodeNode.java, + private final transient int lineNum;, + public CodeNode(JNode jNode, int lineNum, StringRef lineStr) {, + this.line = lineStr;, +++ b/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java, + String statusText = String.format(, + NLS.str("search_dialog.info_label"),, + resultsModel.getDisplayedResultsStart(),, + resultsModel.getDisplayedResultsEnd(),, + resultsModel.getResultCount(), + );, +
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java]
[+++ b/build.gradle, + id 'org.sonarqube' version '2.7', + testCompile 'org.hamcrest:hamcrest-library:2.1', + testCompile 'org.mockito:mockito-core:2.23.4', +++ b/build.gradle, + id 'org.sonarqube' version '2.7', + testCompile 'org.hamcrest:hamcrest-library:2.1', + testCompile 'org.mockito:mockito-core:2.23.4', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-5.1.1-bin.zip, +++ b/build.gradle, + id 'org.sonarqube' version '2.7', + testCompile 'org.hamcrest:hamcrest-library:2.1', + testCompile 'org.mockito:mockito-core:2.23.4', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-5.1.1-bin.zip, +++ b/jadx-core/build.gradle, + compile 'org.ow2.asm:asm:7.0', + compile 'org.jetbrains:annotations:16.0.3', + compile 'uk.com.robust-it:cloning:1.9.11', + testCompile 'org.smali:smali:2.2.5', + testCompile 'org.smali:baksmali:2.2.5', + testCompile 'org.apache.commons:commons-lang3:3.8.1', +++ b/build.gradle, + id 'org.sonarqube' version '2.7', + testCompile 'org.hamcrest:hamcrest-library:2.1', + testCompile 'org.mockito:mockito-core:2.23.4', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-5.1.1-bin.zip, +++ b/jadx-core/build.gradle, + compile 'org.ow2.asm:asm:7.0', + compile 'org.jetbrains:annotations:16.0.3', + compile 'uk.com.robust-it:cloning:1.9.11', + testCompile 'org.smali:smali:2.2.5', + testCompile 'org.smali:baksmali:2.2.5', +
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import org.jetbrains.annotations.Nullable;, + String filledArray = makeArrayElements(insn);, + code.add("new ");, + useType(code, insn.getElementType());, + code.add("[]{").add(filledArray).add('}');, + }, +, + private String makeArrayElements(FillArrayNode insn) throws CodegenException {, + insn.mergeElementType(elType);, +, + return str.toString();, + generateMethodArguments(code, insn, 0, mth.dex().resolveMethod(insn.getCallMth()));, + generateMethodArguments(code, insn, k, callMthNode);, + private void generateMethodArguments(CodeWriter code, InsnNode insn, int startArgNum,, + @Nullable MethodNode callMth) throws CodegenException {, + int k = startArgNum;, + if (k < argsCount) {, + boolean overloaded = callMth != null && callMth.isArgsOverload();, + boolean cast = overloaded && processOverloadedArg(code, callMth, arg, i - startArgNum);, + if (!cast && i == argsCount
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/LoopRegion.java, + return "LOOP: " + baseString();, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/LoopRegion.java, + return "LOOP: " + baseString();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + Region body = makeRegion(loopBody, stack);, + // add blocks from loop start to first condition block, + BlockNode conditionBlock = condInfo.getIfBlock();, + if (loopStart != conditionBlock) {, + Set<BlockNode> blocks = BlockUtils.getAllPathsBlocks(loopStart, conditionBlock);, + blocks.remove(conditionBlock);, + for (BlockNode block : blocks) {, + if (block.getInstructions().isEmpty(), + && !block.contains(AFlag.SKIP), + && !RegionUtils.isRegionContainsBlock(body, block)) {, + body.add(block);, + }, + }, + }, + loopRegion.setBody(body);, + List<BlockNode> s = splitter.getSuccessors();, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/LoopRegion.java, + return "LOOP: " + baseString();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + Region
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/CallMthInterface.java, +package jadx.core.dex.instructions;, +, +import jadx.core.dex.info.MethodInfo;, +, +public interface CallMthInterface {, +, + public MethodInfo getCallMth();, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/CallMthInterface.java, +package jadx.core.dex.instructions;, +, +import jadx.core.dex.info.MethodInfo;, +, +public interface CallMthInterface {, +, + public MethodInfo getCallMth();, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java, +public class InvokeNode extends InsnNode implements CallMthInterface {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/CallMthInterface.java, +package jadx.core.dex.instructions;, +, +import jadx.core.dex.info.MethodInfo;, +, +public interface CallMthInterface {, +, + public MethodInfo getCallMth();, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InvokeNode.java, +public class InvokeNode extends InsnNode implements CallMthInterface {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, +import jadx.core.dex.instructions.CallMthInterface;, +public class ConstructorInsn extends InsnNode implements CallMthInterface {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/CallMthInterface.java, +package jadx.core.dex.instructions;, +, +import jadx.core.dex.info.MethodInfo;, +, +public interface CallMthInterface {, +,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + JadxErrorAttr errorAttr = mth.get(AType.JADX_ERROR);, + if (errorAttr == null, + || errorAttr.getCause() == null, + || !errorAttr.getCause().getClass().equals(DecodeException.class)) {, + code.startLine("// Can't load method instructions: " + e.getMessage());, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + JadxErrorAttr errorAttr = mth.get(AType.JADX_ERROR);, + if (errorAttr == null, + || errorAttr.getCause() == null, + || !errorAttr.getCause().getClass().equals(DecodeException.class)) {, + code.startLine("// Can't load method instructions: " + e.getMessage());, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, + } catch (Exception e) {, + LOG.error("Method load error:", e);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + JadxErrorAttr errorAttr = mth.get(AType.JADX_ERROR);, + if (errorAttr == null, + || errorAttr.getCause() == null, + || !errorAttr.getCause().getClass().equals(DecodeException.class)) {, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +, + RegisterArg activeReg = (RegisterArg) activeRegisters[var.getRegNum()];, + if (activeReg != null) {, + SSAVar ssaVar = activeReg.getSVar();, + if ((ssaVar != null) && (ssaVar.getStartAddr() != -1)) {, + if (ssaVar.getAssign() != null) {, + if (ssaVar.getAssign().getParentInsn() != null) {, + if (ssaVar.getAssign().getParentInsn().getOffset() >= 0) {, + addr = ssaVar.getAssign().getParentInsn().getOffset();, + }, + }, + }, + }, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +, + RegisterArg activeReg = (RegisterArg) activeRegisters[var.getRegNum()];, + if (activeReg != null) {, + SSAVar ssaVar = activeReg.getSVar();, + if ((ssaVar != null) && (ssaVar.getStartAddr() != -1)) {, + if (ssaVar.getAssign() != null) {,
[+++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, + LOG.error("Class process exception: {}", cls, e);, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, + LOG.error("Class process exception: {}", cls, e);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, + LOG.warn("Class not found: {}", fullName);, + LOG.info("Classes count: {}", classes.length);, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, + LOG.error("Class process exception: {}", cls, e);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, + LOG.warn("Class not found: {}", fullName);, + LOG.info("Classes count: {}", classes.length);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, + LOG.info("Loaded: {}", inputFile.getFile());, + LOG.info("Output: {}", output);, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, + LOG.error("Class process exception: {}", cls, e);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, + LOG.warn("Class not found: {}", fullName);, + LOG.info("Classes count: {}", classes.length);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, + LOG.info("Loaded: {}", inputFile.getFile());, + LOG.info("Output: {}", output);, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, + }
[+++ b/.travis.yml, +++ b/.travis.yml, +++ b/jadx-core/build.gradle, + compile files('lib/dx.jar'), +++ b/.travis.yml, +++ b/jadx-core/build.gradle, + compile files('lib/dx.jar'), +++ /dev/null, +++ b/.travis.yml, +++ b/jadx-core/build.gradle, + compile files('lib/dx.jar'), +++ /dev/null, +++ b/jadx-core/lib/dx.jar]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +import java.util.List;, +, + List<BlockNode> successors = curBlock.getSuccessors();, + thenBlock = getBlockByOffset(target, successors);, + if (successors.size() == 1) {, + elseBlock = selectOther(thenBlock, successors);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +import java.util.List;, +, + List<BlockNode> successors = curBlock.getSuccessors();, + thenBlock = getBlockByOffset(target, successors);, + if (successors.size() == 1) {, + elseBlock = selectOther(thenBlock, successors);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +import java.util.Objects;, + if (Objects.equals(thenBlock, elseBlock)) {, + IfInfo ifInfo = new IfInfo(info, null, null);, + ifInfo.setOutBlock(thenBlock);, + return ifInfo;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, +import java.util.List;, +, + List<BlockNode> successors = curBlock.getSuccessors();, + thenBlock = getBlockByOffset(target, successors);, + if (successors.size() == 1) {, +
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import java.util.EnumSet;, +import java.util.HashSet;, +import java.util.Locale;, +import java.util.Set;, +import com.beust.jcommander.IStringConverter;, +import com.beust.jcommander.Parameter;, +, +import ch.qos.logback.classic.spi.ILoggingEvent;, +import ch.qos.logback.core.Appender;, +import jadx.api.JadxArgs.RENAME;, + @Parameter(names = {"--rename-flags"}, description = "what to rename, comma-separated, 'case' for system case sensitivity, 'valid' for java identifiers, 'printable' characters, 'none' or 'all'",, + converter = RenameConverter.class), + protected Set<RENAME> renameFlags = EnumSet.allOf(RENAME.class);, +, + args.setRenameCaseSensitive(isRenameCaseSensitive());, + args.setRenameValid(isRenameValid());, + args.setRenamePrintable(isRenamePrintable());, +, + public boolean isRenameCaseSensitive() {, + return renameFlags.contains(RENAME.CASE);, + }, +, + public void setRenameCaseSensitive(boolean renameCase) {, + if (renameCase && !isRenameCaseSensitive()) {, + renameFlags.add(RENAME.CASE);, + } else if (!renameCase && isRenameCaseSensitive()) {, + renameFlags.remove(RENAME.CASE);, +
[+++ /dev/null]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/build.gradle, +, + testCompile 'org.apache.commons:commons-lang3:3.7', +++ b/.gitignore, +++ b/jadx-core/build.gradle, +, + testCompile 'org.apache.commons:commons-lang3:3.7', +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, + /**, + * Run auto check method if defined:, + * <pre>, + * public static void check(), + * </pre>, + */, + public static final String CHECK_METHOD_NAME = "check";, +, + checkMth = origCls.getMethod(CHECK_METHOD_NAME);, + rethrow("Original check failed", ie);, +++ b/.gitignore, +++ b/jadx-core/build.gradle, +, + testCompile 'org.apache.commons:commons-lang3:3.7', +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, + /**, + * Run auto check method if defined:, + * <pre>, + * public static void check(), + * </pre>, + */, + public static
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + MethodGen mthGen = new MethodGen(this, mth);, + MethodGen mthGen;, + if (badCode || mth.contains(AType.JADX_ERROR)) {, + mthGen = MethodGen.getFallbackMethodGen(mth);, + } else {, + mthGen = new MethodGen(this, mth);, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + MethodGen mthGen = new MethodGen(this, mth);, + MethodGen mthGen;, + if (badCode || mth.contains(AType.JADX_ERROR)) {, + mthGen = MethodGen.getFallbackMethodGen(mth);, + } else {, + mthGen = new MethodGen(this, mth);, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + if (mth.contains(AType.JADX_ERROR), + || mth.contains(AFlag.INCONSISTENT_CODE), + || mth.getRegion() == null) {, + code.startLine("throw new UnsupportedOperationException(\"Method not decompiled: "), + .add(mth.toString()), + .add("\");");, + if (mth.contains(AType.JADX_ERROR)) {, + },
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + if (!classNode.contains(AFlag.DONT_GENERATE)) {, + }, + ProcessClass.process(cls, passes, true);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + if (!classNode.contains(AFlag.DONT_GENERATE)) {, + }, + ProcessClass.process(cls, passes, true);, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, + public static void process(ClassNode cls, List<IDexTreeVisitor> passes, boolean generateCode) {, + if (!generateCode && cls.getState() == PROCESSED) {, + if (cls.getState() == PROCESSED && generateCode) {, + CodeGen.generate(cls);, + cls.getDependencies().forEach(depCls -> process(depCls, passes, false));, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + if (!classNode.contains(AFlag.DONT_GENERATE)) {, + }, + ProcessClass.process(cls, passes, true);, +++ b/jadx-core/src/main/java/jadx/core/ProcessClass.java, + public static void process(ClassNode cls, List<IDexTreeVisitor> passes, boolean generateCode) {, + if (!generateCode && cls.getState() == PROCESSED) {, + if (cls.getState() == PROCESSED
[+++ b/.travis.yml, +env:, + - TERM=dumb, +, +, + - ./gradlew clean build dist, +, +after_success:, + - ./gradlew jacocoTestReport coveralls, +, +++ b/.travis.yml, +env:, + - TERM=dumb, +, +, + - ./gradlew clean build dist, +, +after_success:, + - ./gradlew jacocoTestReport coveralls, +, +++ b/README.md, +, +[![Build Status](https://travis-ci.org/skylot/jadx.png?branch=master)](https://travis-ci.org/skylot/jadx), +[![Build Status](https://drone.io/github.com/skylot/jadx/status.png)](https://drone.io/github.com/skylot/jadx/latest), +[![Coverage Status](https://coveralls.io/repos/skylot/jadx/badge.png)](https://coveralls.io/r/skylot/jadx), +, +*Copyright 2014 by Skylot*, +++ b/.travis.yml, +env:, + - TERM=dumb, +, +, + - ./gradlew clean build dist, +, +after_success:, + - ./gradlew jacocoTestReport coveralls, +, +++ b/README.md, +, +[![Build Status](https://travis-ci.org/skylot/jadx.png?branch=master)](https://travis-ci.org/skylot/jadx), +[![Build Status](https://drone.io/github.com/skylot/jadx/status.png)](https://drone.io/github.com/skylot/jadx/latest), +[![Coverage Status](https://coveralls.io/repos/skylot/jadx/badge.png)](https://coveralls.io/r/skylot/jadx), +, +*Copyright 2014 by Skylot*, +++ b/build.gradle, + apply plugin:
[+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, + // remove classes which are parents for test class, + if (!next.getName().contains(cls.getSimpleName())) {, + for (File clsFile : files) {, + clsFile.deleteOnExit();, + }, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, + // remove classes which are parents for test class, + if (!next.getName().contains(cls.getSimpleName())) {, + for (File clsFile : files) {, + clsFile.deleteOnExit();, + }, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/StaticCompiler.java, + super(file.toURI(), kind);]
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, + passes.add(new DebugInfoParseVisitor());, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new ConstructorVisitor());, + passes.add(new TypeInferenceVisitor());, + passes.add(new DebugInfoApplyVisitor());, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, + passes.add(new DebugInfoParseVisitor());, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, +
[+++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, + return StringUtils.escape(shortName.toLowerCase());]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java, + // TODO: don't store binary files in memory, + } catch (Exception e) {, + LOG.warn("Contents of the binary resource '{}' not saved, got exception", name, e);, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java, + // TODO: don't store binary files in memory, + } catch (Exception e) {, + LOG.warn("Contents of the binary resource '{}' not saved, got exception", name, e);, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResourcesSaver.java, +import jadx.core.utils.files.FileUtils;, + FileUtils.makeDirsForFile(outFile);, + try (FileOutputStream binaryFileStream = new FileOutputStream(outFile)) {, + } finally {, + } catch (Exception e) {, + LOG.warn("Resource '{}' not saved, got exception", rc.getName(), e);]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + useClass(code, ClassInfo.fromType(cls.dex(), type));, + useClass(code, ClassInfo.fromType(cls.dex(), g));, + useClass(code, ClassInfo.fromType(cls.dex(), type));, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + useClass(code, ClassInfo.fromType(cls.dex(), type));, + useClass(code, ClassInfo.fromType(cls.dex(), g));, + useClass(code, ClassInfo.fromType(cls.dex(), type));, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + this.nameGen = new NameGen(mth, classGen.isFallbackMode());, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + useClass(code, ClassInfo.fromType(cls.dex(), type));, + useClass(code, ClassInfo.fromType(cls.dex(), g));, + useClass(code, ClassInfo.fromType(cls.dex(), type));, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + this.nameGen = new NameGen(mth, classGen.isFallbackMode());, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.dex.nodes.MethodNode;, + private final MethodNode mth;, + public NameGen(MethodNode mth, boolean fallback) {, + this.mth = mth;, + varName = guessName(arg);, + private String guessName(RegisterArg arg) {, + SSAVar sVar
[+++ b/jadx-core/src/main/java/jadx/core/utils/Utils.java, +import jadx.api.JadxDecompiler;, +, +import java.util.Arrays;, + public static final String JADX_API_PACKAGE = JadxDecompiler.class.getPackage().getName();, +, + filterRecursive(throwable);, + private static void filterRecursive(Throwable th) {, + try {, + filter(th);, + } catch (Exception e) {, + // ignore filter exceptions, + }, + Throwable cause = th.getCause();, + if (cause != null) {, + filterRecursive(cause);, + }, + }, +, + private static void filter(Throwable th) {, + StackTraceElement[] stackTrace = th.getStackTrace();, + int cutIndex = -1;, + int length = stackTrace.length;, + for (int i = 0; i < length; i++) {, + StackTraceElement stackTraceElement = stackTrace[i];,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + boolean firstArg = true;, + if (!firstArg) {, + firstArg = false;, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + boolean firstArg = true;, + if (!firstArg) {, + firstArg = false;, +++ b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestConstructorInvoke.java, +package jadx.tests.integration.invoke;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import org.junit.Test;, +, +import static org.hamcrest.Matchers.containsString;, +import static org.junit.Assert.assertThat;, +, +public class TestConstructorInvoke extends IntegrationTest {, +, + public class TestCls {, + void test(String root, String name) {, + ViewHolder viewHolder = new ViewHolder(root, name);, + }, +, + private final class ViewHolder {, + private int mElements = 0;, + private final String mRoot;, + private String
[+++ b/README.md, +++ b/README.md, +++ b/jadx-core/build.gradle, + compile files('lib/dx.jar'), +++ b/README.md, +++ b/jadx-core/build.gradle, + compile files('lib/dx.jar'), +++ /dev/null, +++ b/README.md, +++ b/jadx-core/build.gradle, + compile files('lib/dx.jar'), +++ /dev/null, +++ b/jadx-core/lib/dx.jar, +++ b/README.md, +++ b/jadx-core/build.gradle, + compile files('lib/dx.jar'), +++ /dev/null, +++ b/jadx-core/lib/dx.jar, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +++ b/README.md, +++ b/jadx-core/build.gradle, + compile files('lib/dx.jar'), +++ /dev/null, +++ b/jadx-core/lib/dx.jar, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +import static jadx.core.utils.files.FileUtils.close;, + if (fileName.endsWith(".apk") || fileName.endsWith(".zip")) {]
[+++ b/.travis.yml, +language: java, +jdk:, + - oraclejdk7, + - openjdk7, + - openjdk6, +script: gradle clean build samples, +notifications:, + email:, + - skylot@gmail.com, +++ b/.travis.yml, +language: java, +jdk:, + - oraclejdk7, + - openjdk7, + - openjdk6, +script: gradle clean build samples, +notifications:, + email:, + - skylot@gmail.com, +++ b/README.md, +### Build [![Build Status](https://travis-ci.org/skylot/jadx.png?branch=master)](https://travis-ci.org/skylot/jadx)]
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +import static jadx.core.utils.files.FileUtils.isApkFile;, +import static jadx.core.utils.files.FileUtils.isZipDexFile;, +, +import java.nio.file.Files;, +import java.nio.file.Path;, +import com.android.dex.Dex;, +, + for (Dex dex : loadFromClassFile(file)) {, + addDexFile(dex);, + }, + for (Dex dex : loadFromJar(file.toPath())) {, + addDexFile(dex);, + }, + Path jarFile = Files.createTempFile(entryName, ".jar");, + Files.copy(inputStream, jarFile);, + for (Dex dex : loadFromJar(jarFile)) {, + addDexFile(entryName, dex);, + private static List<Dex> loadFromJar(Path jar) throws DecodeException {, + LOG.info("converting to dex: {} ...", jar.getFileName());, + List<byte[]> byteList = j2d.convert(jar);, + if (byteList.isEmpty()) {, + List<Dex> dexList = new ArrayList<>(byteList.size());, + for (byte[] b : byteList) {, + dexList.add(new Dex(b));, +
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, + if (clsName == null || !ZipSecurity.isValidZipEntryName(clsName)) {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + for (BlockNode node : block.getSuccessors()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + for (BlockNode node : block.getSuccessors()) {, +++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatch8.java, +package jadx.tests.integration.trycatch;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import org.junit.Test;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.hamcrest.Matchers.*;, +import static org.junit.Assert.assertThat;, +, +public class TestTryCatch8 extends IntegrationTest {, +, + public static class TestCls {, + static class MyException extends Exception {, + private static final long serialVersionUID = 7963400419047287279L;, +, + MyException() {, + }, +, + MyException(String msg, Throwable cause) {, + super(msg, cause);, + }, + }, +, + MyException e = null;, +, + public void
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, + public static final AType<AttrList<JadxError>> JADX_ERROR = new AType<>(); // code failed to decompile completely, + public static final AType<AttrList<JadxWarn>> JADX_WARN = new AType<>(); // mark code as inconsistent (code can be viewed), + public static final AType<AttrList<String>> COMMENTS = new AType<>(); // any additional info about decompilation, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, + public static final AType<AttrList<JadxError>> JADX_ERROR = new AType<>(); // code failed to decompile completely, + public static final AType<AttrList<JadxWarn>> JADX_WARN = new AType<>(); // mark code as inconsistent (code can be viewed), + public static final AType<AttrList<String>> COMMENTS = new AType<>(); // any additional info about
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +import com.android.dx.io.instructions.DecodedInstruction;, +import com.rits.cloning.Cloner;, +, +import jadx.core.dex.attributes.AFlag;, + if (contains(AFlag.DONT_GENERATE)) {, + if (getType() == InsnType.MONITOR_EXIT) {, + return false;, + }, + return true;, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +import com.android.dx.io.instructions.DecodedInstruction;, +import com.rits.cloning.Cloner;, +, +import jadx.core.dex.attributes.AFlag;, + if (contains(AFlag.DONT_GENERATE)) {, + if (getType() == InsnType.MONITOR_EXIT) {, + return false;, + }, + return true;, + }, +++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestFinally2.java, + assertThat(code, containsOne("return new Result(400);"));]
[+++ b/NOTICE, +JFontChooser Component - http://sourceforge.jp/projects/jfontchooser/, +++ b/NOTICE, +JFontChooser Component - http://sourceforge.jp/projects/jfontchooser/, +++ b/jadx-gui/build.gradle, + compile files('libs/jfontchooser-1.0.5.jar'), +++ b/NOTICE, +JFontChooser Component - http://sourceforge.jp/projects/jfontchooser/, +++ b/jadx-gui/build.gradle, + compile files('libs/jfontchooser-1.0.5.jar'), +++ b/jadx-gui/libs/jfontchooser-1.0.5.jar, +++ b/NOTICE, +JFontChooser Component - http://sourceforge.jp/projects/jfontchooser/, +++ b/jadx-gui/build.gradle, + compile files('libs/jfontchooser-1.0.5.jar'), +++ b/jadx-gui/libs/jfontchooser-1.0.5.jar, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import javax.swing.JLabel;, +import java.awt.Font;, + private static final Font DEFAULT_FONT = new JLabel().getFont();, +, + private String fontStr = "";, +, + public Font getFont() {, + if (fontStr.isEmpty()) {, + return DEFAULT_FONT;, + }, + return Font.decode(fontStr);, + }, +, + public void setFont(Font font) {, + this.fontStr = font.getFontName() + addStyleName(font.getStyle()) +
[+++ b/.gitignore, +++ b/.gitignore, +++ b/.travis.yml, +sudo: false, +dist: trusty, + - wget https://github.com/sormuras/bach/raw/master/install-jdk.sh, +env:, + global:, + - TERM=dumb, +, +matrix:, + include:, + - env: JDK=oracle-8, + jdk: oraclejdk8, + - env: JDK=oracle-10, + install: . ./install-jdk.sh -F 10 -L BCL, +, + - java -version, + - test $JDK = "oracle-8" && ./gradlew clean build jacocoTestReport && bash <(curl -s https://codecov.io/bash) || echo "Codecov did not collect coverage reports", + - test $JDK = "oracle-8" && ./gradlew clean sonarqube -Dsonar.host.url=$SONAR_HOST -Dsonar.organization=$SONAR_ORG -Dsonar.login=$SONAR_TOKEN || echo "Skip sonar build and upload", +, +before_deploy:, + condition: $JDK = oracle-8,
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java, +, + public boolean isAttrStorageEmpty() {, + return storage.isEmpty();, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java, +, + public boolean isAttrStorageEmpty() {, + return storage.isEmpty();, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +import java.util.Objects;, + if (insnType != other.insnType) {, + return false;, + }, + int size = arguments.size();, + if (size != other.arguments.size()) {, + /**, + * 'Hard' equals, compare all arguments, + */, + public boolean isDeepEquals(InsnNode other) {, + if (this == other) {, + return true;, + }, + return isSame(other), + && Objects.equals(arguments, other.arguments);, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttrNode.java, +, + public boolean isAttrStorageEmpty() {, + return
[+++ b/.gitlab-ci.yml, + - cat version, + - ./gradlew -g /cache/.gradle clean build jacocoTestReport, + - ./gradlew -g /cache/.gradle clean sonarqube -Dsonar.host.url=$SONAR_HOST -Dsonar.organization=$SONAR_ORG -Dsonar.login=$SONAR_TOKEN, + - ./gradlew -g /cache/.gradle clean dist, +++ b/.gitlab-ci.yml, + - cat version, + - ./gradlew -g /cache/.gradle clean build jacocoTestReport, + - ./gradlew -g /cache/.gradle clean sonarqube -Dsonar.host.url=$SONAR_HOST -Dsonar.organization=$SONAR_ORG -Dsonar.login=$SONAR_TOKEN, + - ./gradlew -g /cache/.gradle clean dist, +++ b/README.md, +[![Gitlab CI](https://gitlab.com/skylot/jadx/badges/master/build.svg)](https://gitlab.com/skylot/jadx/builds), +[![Jadx Core Coverage](https://gitlab.com/skylot/jadx/badges/master/coverage.svg)](https://gitlab.com/skylot/jadx/builds), +[![SonarQube Bugs](https://sonarcloud.io/api/badges/measure?key=jadx&metric=bugs)](https://sonarcloud.io/dashboard?id=jadx), +Java 8 JDK or higher must be installed:, +, +++ b/.gitlab-ci.yml, + - cat version, + - ./gradlew -g /cache/.gradle clean build jacocoTestReport, + - ./gradlew -g /cache/.gradle
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, + }, + setFromOut(args);, + checkDir(args.getOutDir());, + checkDir(args.getOutDirSrc());, + checkDir(args.getOutDirRes());, + private static void setFromOut(JadxArgs args) {, + if (args.getOutDirSrc() == null) {, + args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, + }, + if (args.getOutDirRes() == null) {, + args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, + }, + }, +, + private static void checkDir(File dir) {, + throw new JadxArgsValidateException("Output directory exists as file " + dir);, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, + }, + setFromOut(args);, + checkDir(args.getOutDir());, + checkDir(args.getOutDirSrc());, + checkDir(args.getOutDirRes());, + private static void setFromOut(JadxArgs
[+++ b/.gitlab-ci.yml, + before_script:, + - export JADX_LAST_TAG="$(git describe --abbrev=0 --tags)", + - export JADX_VERSION="${JADX_LAST_TAG:1}-$(git rev-parse --short HEAD)"]
[+++ b/build.gradle, + gradleVersion = '2.7', +++ b/build.gradle, + gradleVersion = '2.7', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.7-bin.zip]
[+++ b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java, +, + public static String escapeResStrValue(String str) {, + int len = str.length();, + StringBuilder sb = new StringBuilder(len);, + for (int i = 0; i < len; i++) {, + char c = str.charAt(i);, + switch (c) {, + case '&': sb.append("&amp;"); break;, + case '<': sb.append("&lt;"); break;, + case '>': sb.append("&gt;"); break;, + case '"': sb.append("\\\""); break;, + case '\'': sb.append("\\'"); break;, +, + case '\n': sb.append("\\n"); break;, + case '\r': sb.append("\\r"); break;, + case '\t': sb.append("\\t"); break;, + case '\b': sb.append("\\b"); break;, + case '\f': sb.append("\\f"); break;, + default:, + sb.append(c);, + break;, +
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, + .doOnError(e -> LOG.error("Error while searching: {}", e.getMessage(), e)), +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, + .doOnError(e -> LOG.error("Error while searching: {}", e.getMessage(), e)), +++ b/jadx-gui/src/main/java/jadx/gui/utils/search/CodeIndex.java, + public synchronized void put(StringRef str, T value) {]
[+++ b/jadx-gui/build.gradle, +++ b/jadx-gui/build.gradle, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, + if (searchIndex != null && searchIndex.getSkippedCount() > 0) {, +++ b/jadx-gui/build.gradle, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, + if (searchIndex != null && searchIndex.getSkippedCount() > 0) {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, + public IndexJob(JadxWrapper wrapper, CacheObject cache, int threadsCount) {, + final TextSearchIndex index = new TextSearchIndex(nodeCache);, +++ b/jadx-gui/build.gradle, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, + if (searchIndex != null && searchIndex.getSkippedCount() > 0) {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, + public IndexJob(JadxWrapper wrapper, CacheObject cache, int threadsCount) {, + final TextSearchIndex index = new TextSearchIndex(nodeCache);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +++ b/jadx-gui/build.gradle, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, + if (searchIndex != null && searchIndex.getSkippedCount() > 0) {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/IndexJob.java, +
[+++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, + return "JadxArgs{" + "inputFiles=" + inputFiles +, + ", outDir=" + outDir +, + ", outDirSrc=" + outDirSrc +, + ", outDirRes=" + outDirRes +, + ", threadsCount=" + threadsCount +, + ", cfgOutput=" + cfgOutput +, + ", rawCFGOutput=" + rawCFGOutput +, + ", fallbackMode=" + fallbackMode +, + ", showInconsistentCode=" + showInconsistentCode +, + ", useImports=" + useImports +, + ", isSkipResources=" + isSkipResources +, + ", isSkipSources=" + isSkipSources +, + ", isDeobfuscationOn=" + isDeobfuscationOn +, + ", isDeobfuscationForceSave=" + isDeobfuscationForceSave +, + ", useSourceNameAsClassAlias=" + useSourceNameAsClassAlias +, + ", deobfuscationMinLength=" + deobfuscationMinLength
[+++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.utils.files.ZipSecurity;, + protected ResourceFile(JadxDecompiler decompiler, String name, ResourceType type) {, + , + public static ResourceFile createResourceFileInstance(JadxDecompiler decompiler, String name, ResourceType type) {, + if(!ZipSecurity.isValidZipEntryName(name)) {, + return null;, + }, + return new ResourceFile(decompiler, name, type);, + }, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.utils.files.ZipSecurity;, + protected ResourceFile(JadxDecompiler decompiler, String name, ResourceType type) {, + , + public static ResourceFile createResourceFileInstance(JadxDecompiler decompiler, String name, ResourceType type) {, + if(!ZipSecurity.isValidZipEntryName(name)) {, + return null;, + }, + return new ResourceFile(decompiler, name, type);, + }, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +import jadx.core.utils.files.ZipSecurity;, + private ResourceFileContent(String name, ResourceType type, CodeWriter content) {, + ,
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockExceptionHandler.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import jadx.core.dex.instructions.args.NamedArg;, + private static final Logger LOG = LoggerFactory.getLogger(BlockExceptionHandler.class);, +, + if (handlerAttr == null) {, + ArgType argType = excHandler.isCatchAll() ? ArgType.THROWABLE : excHandler.getCatchType().getType();, + if (me.getType() == InsnType.MOVE_EXCEPTION) {, + RegisterArg resArg = InsnArg.reg(me.getResult().getRegNum(), argType);, + } else {, + // handler arguments not used, + excHandler.setArg(new NamedArg("unused", argType));, + }, + if (handler.getHandlerBlock() == null) {, + LOG.warn("Exception handler block not set for {}, mth: {}", handler, mth);, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockExceptionHandler.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import jadx.core.dex.instructions.args.NamedArg;, + private static final Logger LOG = LoggerFactory.getLogger(BlockExceptionHandler.class);, +,
[+++ b/build.gradle, + id 'com.github.ben-manes.versions' version '0.20.0', + testCompile 'org.mockito:mockito-core:2.20.1', + testCompile 'cglib:cglib-nodep:3.2.7', +++ b/build.gradle, + id 'com.github.ben-manes.versions' version '0.20.0', + testCompile 'org.mockito:mockito-core:2.20.1', + testCompile 'cglib:cglib-nodep:3.2.7', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, + id 'com.github.ben-manes.versions' version '0.20.0', + testCompile 'org.mockito:mockito-core:2.20.1', + testCompile 'cglib:cglib-nodep:3.2.7', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-bin.zip, +++ b/build.gradle, + id 'com.github.ben-manes.versions' version '0.20.0', + testCompile 'org.mockito:mockito-core:2.20.1', + testCompile 'cglib:cglib-nodep:3.2.7', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-bin.zip, +++ b/jadx-core/build.gradle, + testCompile 'org.smali:smali:2.2.4', + testCompile 'org.smali:baksmali:2.2.4', +++ b/build.gradle, + id 'com.github.ben-manes.versions' version '0.20.0', + testCompile 'org.mockito:mockito-core:2.20.1', + testCompile 'cglib:cglib-nodep:3.2.7', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-bin.zip, +++ b/jadx-core/build.gradle, + testCompile 'org.smali:smali:2.2.4', + testCompile 'org.smali:baksmali:2.2.4', +++
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new DebugInfoVisitor());, + passes.add(new TypeInference());, +, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new FinishTypeInference());, +, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new DebugInfoVisitor());, + passes.add(new TypeInference());, +, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, + private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new DebugInfoVisitor());,
[+++ b/.gitignore, +*.ipr, +*.iws, +gradle.properties, +++ b/.gitignore, +*.ipr, +*.iws, +gradle.properties, +++ b/build.gradle, +ext.jadxVersion = file('version').readLines().get(0), +, +subprojects {, + apply plugin: 'java', + apply plugin: 'idea', + apply plugin: 'eclipse', +, + jar {, + version = jadxVersion, + }, + manifest {, + mainAttributes("jadx-version" : jadxVersion), +++ b/.gitignore, +*.ipr, +*.iws, +gradle.properties, +++ b/build.gradle, +ext.jadxVersion = file('version').readLines().get(0), +, +subprojects {, + apply plugin: 'java', + apply plugin: 'idea', + apply plugin: 'eclipse', +, + jar {, + version = jadxVersion, + }, + manifest {, + mainAttributes("jadx-version" : jadxVersion), +++ b/jadx-cli/build.gradle, +apply plugin: 'application', +, +mainClassName = "jadx.cli.JadxCLI", +,
[+++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.utils.files.FileUtils;, + FileUtils.makeDirsForFile(output);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.utils.files.FileUtils;, + FileUtils.makeDirsForFile(output);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import jadx.core.utils.files.FileUtils;, + FileUtils.makeDirsForFile(file);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.utils.files.FileUtils;, + FileUtils.makeDirsForFile(output);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import jadx.core.utils.files.FileUtils;, + FileUtils.makeDirsForFile(file);, +++ b/jadx-core/src/main/java/jadx/core/utils/Utils.java, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.utils.files.FileUtils;, + FileUtils.makeDirsForFile(output);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import jadx.core.utils.files.FileUtils;, + FileUtils.makeDirsForFile(file);, +++ b/jadx-core/src/main/java/jadx/core/utils/Utils.java, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, +, +, + public static void makeDirsForFile(File file) {, + File dir = file.getParentFile();, + if (dir != null && !dir.exists()) {, + // if directory already created in other thread mkdirs will return false,, + // so check dir existence again, + if (!dir.mkdirs() && !dir.exists()) {, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, + BlockNode otherPathBlock;, + if (followThenBranch) {, + otherPathBlock = first.getElseBlock();, + if (!otherPathBlock.equals(result.getElseBlock())) {, + result.getSkipBlocks().add(otherPathBlock);, + }, + } else {, + otherPathBlock = first.getThenBlock();, + if (!otherPathBlock.equals(result.getThenBlock())) {, + result.getSkipBlocks().add(otherPathBlock);, + }, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, + BlockNode otherPathBlock;, + if (followThenBranch) {, + otherPathBlock = first.getElseBlock();, + if (!otherPathBlock.equals(result.getElseBlock())) {, + result.getSkipBlocks().add(otherPathBlock);, + }, + } else {, + otherPathBlock = first.getThenBlock();, + if (!otherPathBlock.equals(result.getThenBlock())) {, + result.getSkipBlocks().add(otherPathBlock);, + }, + }, +++ b/jadx-core/src/test/java/jadx/tests/integration/conditions/TestComplexIf.java, +package jadx.tests.integration.conditions;, +, +import org.junit.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.SmaliTest;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java, + long stringsEnd = stylesStart == 0 ? chunkEnd : start + stylesStart;, + is.skipToPos(stringsEnd, "Skip string8 padding");, + byte[] strArray = is.readInt8Array((int) (stringsEnd - is.getPos()));, + is.skipToPos(chunkEnd, "Skip string pool padding");, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java, + long stringsEnd = stylesStart == 0 ? chunkEnd : start + stylesStart;, + is.skipToPos(stringsEnd, "Skip string8 padding");, + byte[] strArray = is.readInt8Array((int) (stringsEnd - is.getPos()));, + is.skipToPos(chunkEnd, "Skip string pool padding");, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ParserStream.java, + checkPos(expectedOffset, error);]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, + //System.out.println("COUNT: "+Integer.toHexString(count));, + //System.out.println("NAMESPACE BEGIN Line: " + beginLineNumber);, + int comment = cInt32(bytes, count);, + //System.out.println("Comment: 0x" + Integer.toHexString(comment));, + //System.out.println("COUNT: "+Integer.toHexString(count));, + //System.out.println("NAMESPACE END Line: " + endLineNumber);, + int comment = cInt32(bytes, count);, + //System.out.println("Comment: 0x" + Integer.toHexString(comment));, + //System.out.println("elementLineNumber: " + elementLineNumber);, + int comment = cInt32(bytes, count);, + //System.out.println("Comment: 0x" + Integer.toHexString(comment));, + //System.out.println("COUNT: "+Integer.toHexString(count));, + //System.out.println("Namespace: 0x" + Integer.toHexString(startNS));, + //System.out.println("Namespace name: " + strings[startNSName]);, + //System.out.println("startNS: attributeCount: " + attributeCount);, + //System.out.println("startNS: idIndex: " + idIndex);, + //System.out.println("startNS: classIndex: " + classIndex);, + //System.out.println("startNS: styleIndex: " + styleIndex);, +
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +, + if (this.args.isXMLTest()) {, + InputFile inf = inputFiles.get(0);, + try {, + byte[] buffer = InputFile.loadXMLBuffer(inf.getFile());, + if (buffer != null) {, + File out = new File(args.getOutDir(), "AndroidManifest.xml");, + BinaryXMLParser bxp = new BinaryXMLParser(root);, + bxp.parse(buffer, out);, + }, + } catch (Exception e) {, + LOG.info("Decompiling AndroidManifest.xml failed!", e);, + }, + }, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +, + if (this.args.isXMLTest()) {, + InputFile inf = inputFiles.get(0);, + try {, + byte[] buffer = InputFile.loadXMLBuffer(inf.getFile());, + if (buffer != null) {, + File out = new File(args.getOutDir(), "AndroidManifest.xml");, + BinaryXMLParser bxp = new BinaryXMLParser(root);, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +import jadx.core.dex.instructions.ConstStringNode;, +, + // If this is a 'new StringBuilder(xxx).append(yyy).append(zzz).toString(), , + // convert it to STRING_CONCAT pseudo instruction., + int constrIndex = -1; //RAF, + // Case where new StringBuilder() is called with NO args (the entire, + // string is created using .append() calls:, + constrIndex = 0;, + } else if (chain.size()>2 && chain.get(1).getType()==InsnType.CONSTRUCTOR) {, + //RAF Case where the first string element is String arg to the , + // new StringBuilder("xxx") constructor, + constrIndex = 1;, + } else if (chain.size()>3 && chain.get(2).getType()==InsnType.CONSTRUCTOR) {, + //RAF Case where the first string
[+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, + makeRegionIndent(code, c);, + makeRegionIndent(code, sw.getDefaultCase());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, + makeRegionIndent(code, c);, + makeRegionIndent(code, sw.getDefaultCase());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/IBranchRegion.java, +package jadx.core.dex.nodes;, +, +import java.util.List;, +, +public interface IBranchRegion extends IRegion {, +, + /**, + * Return list of branches in this region., + * NOTE: Contains 'null' elements for indicate empty branches., + */, + List<IContainer> getBranches();, +, +}, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, + makeRegionIndent(code, c);, + makeRegionIndent(code, sw.getDefaultCase());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/IBranchRegion.java, +package jadx.core.dex.nodes;, +, +import java.util.List;, +, +public interface IBranchRegion extends IRegion {, +, + /**, + * Return list of branches in this region., + * NOTE: Contains 'null' elements
[+++ b/jadx-core/src/main/java/jadx/core/utils/ErrorsCounter.java, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.Comparator;, +import java.util.List;, + List<Object> nodes = new ArrayList<Object>(ERROR_NODES);, + Collections.sort(nodes, new Comparator<Object>() {, + @Override, + public int compare(Object o1, Object o2) {, + return String.valueOf(o1).compareTo(String.valueOf(o2));, + }, + });, + for (Object node : nodes) {]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +//import jadx.core.xmlgen.BinaryXMLParser;, + //BinaryXMLParser bxp = new BinaryXMLParser(args[0],args[1]);, + //bxp.parse();, + //System.exit(4);]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java]
[+++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, + public static ResourceFile createResourceFile(JadxDecompiler decompiler, String name, ResourceType type) {, + if (!ZipSecurity.isValidZipEntryName(name)) {, + return null;, + }, + return new ResourceFile(decompiler, name, type);, + }, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, + public static ResourceFile createResourceFile(JadxDecompiler decompiler, String name, ResourceType type) {, + if (!ZipSecurity.isValidZipEntryName(name)) {, + return null;, + }, + return new ResourceFile(decompiler, name, type);, + }, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, + public ResourceFileContent(String name, ResourceType type, CodeWriter content) {, + return ResContainer.textResource(getName(), content);, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, + public static ResourceFile createResourceFile(JadxDecompiler decompiler, String name, ResourceType type) {, + if (!ZipSecurity.isValidZipEntryName(name)) {, + return null;, + },
[+++ b/jadx-cli/build.gradle, + compile 'com.beust:jcommander:1.72', +++ b/jadx-cli/build.gradle, + compile 'com.beust:jcommander:1.72', +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.utils.exceptions.JadxArgsValidateException;, + try {, + } catch (JadxArgsValidateException e) {, + LOG.error("Incorrect arguments: {}", e.getMessage());, + System.exit(1);, + }, +++ b/jadx-cli/build.gradle, + compile 'com.beust:jcommander:1.72', +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.utils.exceptions.JadxArgsValidateException;, + try {, + } catch (JadxArgsValidateException e) {, + LOG.error("Incorrect arguments: {}", e.getMessage());, + System.exit(1);, + }, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(description = "<input file> (.apk, .dex, .jar or .class)"), + @Parameter(names = {"-j", "--threads-count"}, description = "processing threads count"), + protected int threadsCount = JadxArgs.DEFAULT_THREADS_COUNT;, +, + @Parameter(names = {"--no-imports"}, description = "disable use of imports, always
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumMapAttr.java, +import jadx.core.dex.nodes.FieldNode;, + public static class KeyValueMap {, + public Object get(Object key) {, + return map.get(key);, + }, +, + void put(Object key, Object value) {, + map.put(key, value);, + }, + }, +, + private Map<FieldNode, KeyValueMap> fieldsMap = new HashMap<FieldNode, KeyValueMap>();, +, + public KeyValueMap getMap(FieldNode field) {, + return fieldsMap.get(field);, + }, +, + public void add(FieldNode field, Object key, Object value) {, + KeyValueMap map = getMap(field);, + if (map == null) {, + map = new KeyValueMap();, + fieldsMap.put(field, map);, + }, + map.put(key, value);, + return "Enum fields map: "
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, + passes.add(new
[+++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.Utils;, + throw new JadxException("Error decode: " + zipRef.getEntryName(), e);, + CodeWriter cw = new CodeWriter();, + cw.add("Error decode ").add(rf.getType().toString().toLowerCase());, + cw.startLine(Utils.getStackTrace(e.getCause()));, + return cw;, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.Utils;, + throw new JadxException("Error decode: " + zipRef.getEntryName(), e);, + CodeWriter cw = new CodeWriter();, + cw.add("Error decode ").add(rf.getType().toString().toLowerCase());, + cw.startLine(Utils.getStackTrace(e.getCause()));, + return cw;, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, + public synchronized CodeWriter parse(InputStream inputStream) throws IOException {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.Utils;, + throw new JadxException("Error decode: " + zipRef.getEntryName(), e);, + CodeWriter cw = new CodeWriter();, + cw.add("Error decode ").add(rf.getType().toString().toLowerCase());, + cw.startLine(Utils.getStackTrace(e.getCause()));, + return cw;, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, + public
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, + && cls.getMethods().isEmpty(), + && cls.getInnerClasses().isEmpty()) {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + if (!simplePath.isEmpty()) {, + BlockNode lastBlock = simplePath.get(simplePath.size() - 1);, + if (lastBlock.contains(AFlag.RETURN), + || lastBlock.getSuccessors().isEmpty()) {, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + if (!simplePath.isEmpty()) {, + BlockNode lastBlock = simplePath.get(simplePath.size() - 1);, + if (lastBlock.contains(AFlag.RETURN), + || lastBlock.getSuccessors().isEmpty()) {, + }, +++ b/jadx-core/src/test/java/jadx/tests/integration/loops/TestBreakInLoop2.java, +package jadx.tests.integration.loops;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import java.util.List;, +, +import org.junit.Test;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestBreakInLoop2 extends IntegrationTest {, +, + public static class TestCls {, + public void test(List<Integer> data) throws Exception {, + for (; ; ) {, + try {, + funcB(data);,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + // don't add import if class not public (must be accessed using inheritance), + ClassNode classNode = cls.dex().resolveClass(classInfo);, + if (classNode != null && !classNode.getAccessFlags().isPublic()) {, + return shortName;, + if (classInfo.getPackage().equals(useCls.getPackage())) {, + fullName = classInfo.getNameWithoutPackage();, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + // don't add import if class not public (must be accessed using inheritance), + ClassNode classNode = cls.dex().resolveClass(classInfo);, + if (classNode != null && !classNode.getAccessFlags().isPublic()) {, + return shortName;, + if (classInfo.getPackage().equals(useCls.getPackage())) {, + fullName = classInfo.getNameWithoutPackage();, + }, +++ b/jadx-samples/src/main/java/jadx/samples/TestImports.java, +package jadx.samples;, +, +import jadx.samples.otherpkg.A;, +, +/**, + * Tests:, + * -
[+++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import java.util.TreeMap;, + private Object attachAnnotation(Object obj, CodePosition pos) {, + if (annotations.isEmpty()) {, + annotations = new HashMap<CodePosition, Object>();, + return annotations.put(pos, obj);, + if (sourceLine == 0) {, + return;, + }, + private void attachSourceLine(int decompiledLine, int sourceLine) {, + if (lineMap.isEmpty()) {, + lineMap = new TreeMap<Integer, Integer>();, + }, + lineMap.put(decompiledLine, sourceLine);, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import java.util.TreeMap;, + private Object attachAnnotation(Object obj, CodePosition pos) {, + if (annotations.isEmpty()) {, + annotations = new HashMap<CodePosition, Object>();, + return annotations.put(pos, obj);, + if (sourceLine == 0) {, + return;, + }, +
[+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.info.FieldInfo;, +import jadx.core.dex.instructions.IndexInsnNode;, + List<Object> keys = sw.getKeys().get(i);, + for (Object k : keys) {, + if (k instanceof IndexInsnNode) {, + code.add(sfield((FieldInfo) ((IndexInsnNode) k).getIndex()));, + }, + else {, + code.add(TypeGen.literalToString((Integer) k, arg.getType()));, + }, + private String sfield(FieldInfo field) {, + String thisClass = mth.getParentClass().getFullName();, + if (field.getDeclClass().getFullName().equals(thisClass)) {, + return field.getName();, + } else {, + return useClass(field.getDeclClass()) + '.' + field.getName();, + }, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.info.FieldInfo;, +import jadx.core.dex.instructions.IndexInsnNode;, + List<Object> keys = sw.getKeys().get(i);, + for (Object k : keys) {, + if (k instanceof IndexInsnNode) {, + code.add(sfield((FieldInfo) ((IndexInsnNode)
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + passes.add(new EnumVisitor());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + passes.add(new EnumVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.dex.instructions.mods.ConstructorInsn;, + ConstructorInsn constrInsn = f.getConstrInsn();, + if (constrInsn.getArgsCount() > f.getStartArg()) {, + MethodNode callMth = cls.dex().resolveMethod(constrInsn.getCallMth());, + igen.generateMethodArguments(code, constrInsn, f.getStartArg(), callMth);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + passes.add(new EnumVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.dex.instructions.mods.ConstructorInsn;, + ConstructorInsn constrInsn = f.getConstrInsn();, + if (constrInsn.getArgsCount() > f.getStartArg()) {, + MethodNode callMth = cls.dex().resolveMethod(constrInsn.getCallMth());, + igen.generateMethodArguments(code, constrInsn, f.getStartArg(), callMth);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + void generateMethodArguments(CodeWriter code, InsnNode insn, int startArgNum,, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + passes.add(new EnumVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.dex.instructions.mods.ConstructorInsn;, + ConstructorInsn constrInsn = f.getConstrInsn();, + if (constrInsn.getArgsCount() > f.getStartArg()) {, + MethodNode callMth =
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java, + TypeInfo typeInfo = var.getTypeInfo();, + ArgType type = typeInfo.getType();, + boolean changed = tryAllTypes(var, type);, + if (!changed) {, + mth.addComment("JADX WARNING: type inference failed for: " + var + ", bounds: " + typeInfo.getBounds());, + }, + private boolean tryAllTypes(SSAVar var, ArgType type) {, + return true;, + return false;]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + if (saveSources) {, + appendSourcesSave(executor, sourcesOutDir);, + }]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, + writer.add("=\"").add(StringUtils.escapeXML(entry.getKey())).add("\"");, + writer.add(StringUtils.escapeXML(decodedAttr));, + writer.add(str != null ? StringUtils.escapeXML(str) : "null");]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java, +// TODO: run after code shrinker at final stage, + ClassInfo classInfo = cls.getClassInfo();, + if (f.getDeclClass().equals(classInfo)) {, + FieldNode fieldNode = cls.searchField(f);, + if (fieldNode != null, + && fieldNode.getAccessFlags().isSynthetic(), + && fieldNode.getType().isArray(), + && fieldNode.getType().getArrayRootElement().equals(classInfo.getType())) {, + }, + if (!clsInfo.equals(classInfo) && !constrCls.getAccessFlags().isEnum()) {, + InsnArg constrArg = iArg;, + } else if (iArg.isRegister()) {, + if (!co.getClassType().equals(classInfo)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java, +// TODO: run after code shrinker at final stage, + ClassInfo classInfo = cls.getClassInfo();, + if (f.getDeclClass().equals(classInfo)) {, + FieldNode fieldNode = cls.searchField(f);, + if (fieldNode != null, + && fieldNode.getAccessFlags().isSynthetic(), + && fieldNode.getType().isArray(),
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + if (args.isRawCFGOutput()) {, + passes.add(new DotGraphVisitor(outDir, false, true));, + }, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + if (args.isRawCFGOutput()) {, + passes.add(new DotGraphVisitor(outDir, false, true));, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + public int getExceptionHandlersCount() {, + return exceptionHandlers.size();, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + if (args.isRawCFGOutput()) {, + passes.add(new DotGraphVisitor(outDir, false, true));, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + public int getExceptionHandlersCount() {, + return exceptionHandlers.size();, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, +import jadx.core.dex.instructions.args.SSAVar;, +import jadx.core.utils.BlockUtils;, + List<InsnNode> toRemove = new ArrayList<InsnNode>();, + toRemove.clear();, + toRemove.add(insn);, + if (!toRemove.isEmpty()) {, + InstructionRemover.removeAll(mth, block, toRemove);, + }, + if (insn.getType() != InsnType.CONST) {, + return
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + InputFile.addFilesFrom(file, inputFiles, args.isSkipSources());, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + InputFile.addFilesFrom(file, inputFiles, args.isSkipSources());, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, + public static void addFilesFrom(File file, List<InputFile> list, boolean... skipSources) throws IOException, DecodeException {, + inputFile.searchDexFiles(skipSources[0]);, + private void searchDexFiles(boolean skipSources) throws IOException, DecodeException {, + if (skipSources) return;, +]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, + Iterator<?> it = ((List) val).iterator();, +++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, + Iterator<?> it = ((List) val).iterator();, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + private int clsDeclLine = 0;, + addClassDeclaration(code);, + addClassBody(code);, + public void addClassDeclaration(CodeWriter clsCode) {, + addGenericMap(clsCode, cls.getGenericMap());, + public boolean addGenericMap(CodeWriter code, Map<ArgType, List<ArgType>> gmap) {, + public void addClassBody(CodeWriter clsCode) throws CodegenException {, + clsDeclLine = clsCode.getLine();, + clsCode.incIndent();, + addFields(clsCode);, + addInnerClasses(clsCode, cls);, + addMethods(clsCode);, + clsCode.decIndent();, + private void addInnerClasses(CodeWriter code, ClassNode cls) throws CodegenException {, + for (ClassNode innerCls : cls.getInnerClasses()) {, + if (!innerCls.isAnonymous()) {, + ClassGen inClGen = new ClassGen(innerCls, getParentGen(), fallback);, +
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, + passes.add(new DebugInfoParseVisitor());, + passes.add(new BlockProcessor());, + passes.add(new BlockExceptionHandler());, + passes.add(new BlockFinish());, +, + passes.add(new SSATransform());, + passes.add(new ConstructorVisitor());, + passes.add(new InitCodeVariables());, + passes.add(new MarkFinallyVisitor());, + passes.add(new TypeInferenceVisitor());, + passes.add(new DebugInfoApplyVisitor());, + passes.add(new CleanRegions());, + passes.add(new ProcessVariables());, + passes.add(new
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java, +import javax.swing.SwingConstants;, +import java.util.HashMap;, +import java.util.Map;, +import org.jetbrains.annotations.Nullable;, + private Map<Integer, Component> componentCache = new HashMap<Integer, Component>();, +, + public ResultsTableCellRenderer() {, + int id = (row << 2) | column;, + Component comp = componentCache.get(id);, + if (comp == null && (obj instanceof JNode)) {, + comp = makeCell((JNode) obj, column);, + componentCache.put(id, comp);, + if (comp != null) {, + updateSelection(comp, isSelected);, + }, + return comp;, + }, + private void updateSelection(Component comp, boolean isSelected) {, + comp.setBackground(selectedBackground);, + comp.setForeground(selectedForeground);, + comp.setBackground(ContentArea.BACKGROUND);, + }, +, + @Nullable, + protected Component makeCell(JNode node, int column)
[+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, + String s = makeCondition(arg);, + if (arg.isCompare()) {, + sb.append(s);, + } else {, + sb.append('(').append(s).append(')');, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, + String s = makeCondition(arg);, + if (arg.isCompare()) {, + sb.append(s);, + } else {, + sb.append('(').append(s).append(')');, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, + boolean internalEquals(Object obj) {, + return type == ((PrimitiveArg) obj).type;, + }, +, + @Override, + this.hash = object.hashCode();, + boolean internalEquals(Object obj) {, + return object.equals(((ObjectArg) obj).object);, + }, +, + @Override, + boolean internalEquals(Object obj) {, + return super.internalEquals(obj), + && Arrays.equals(generics, ((GenericObjectArg) obj).generics);, + }, +, + @Override, + boolean internalEquals(Object
[+++ b/build.gradle, + id "com.github.kt3k.coveralls" version "2.3.1", + id "info.solidsoft.pitest" version "1.1.4", +// id "com.github.ben-manes.versions" version "0.8", + testCompile 'org.hamcrest:hamcrest-library:1.3', + testCompile 'org.spockframework:spock-core:1.0-groovy-2.4', + gradleVersion = '2.3', +++ b/build.gradle, + id "com.github.kt3k.coveralls" version "2.3.1", + id "info.solidsoft.pitest" version "1.1.4", +// id "com.github.ben-manes.versions" version "0.8", + testCompile 'org.hamcrest:hamcrest-library:1.3', + testCompile 'org.spockframework:spock-core:1.0-groovy-2.4', + gradleVersion = '2.3', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, + id "com.github.kt3k.coveralls" version "2.3.1", + id "info.solidsoft.pitest" version "1.1.4", +// id "com.github.ben-manes.versions" version "0.8", + testCompile 'org.hamcrest:hamcrest-library:1.3', + testCompile 'org.spockframework:spock-core:1.0-groovy-2.4', + gradleVersion = '2.3', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.3-all.zip]
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.IfRegionVisitor;, + passes.add(new IfRegionVisitor());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.IfRegionVisitor;, + passes.add(new IfRegionVisitor());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/TernaryInsn.java, +import jadx.core.dex.instructions.args.LiteralArg;, +, + if (th.equals(LiteralArg.FALSE) && els.equals(LiteralArg.TRUE)) {, + // inverted, + this.condition = IfCondition.invert(condition);, + addArg(els);, + addArg(th);, + } else {, + this.condition = condition;, + }, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.IfRegionVisitor;, + passes.add(new IfRegionVisitor());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/TernaryInsn.java, +import jadx.core.dex.instructions.args.LiteralArg;, +, + if (th.equals(LiteralArg.FALSE) && els.equals(LiteralArg.TRUE)) {, + // inverted, + this.condition = IfCondition.invert(condition);, + addArg(els);, + addArg(th);, + } else {, + this.condition = condition;, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, + // all dominators, + private BitSet doms;, + // dominance frontier,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.attributes.nodes.LoopLabelAttr;, + LoopLabelAttr labelAttr = insn.get(AType.LOOP_LABEL);, + if (labelAttr != null) {, + code.add(' ').add(mgen.getNameGen().getLoopLabel(labelAttr));, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.attributes.nodes.LoopLabelAttr;, + LoopLabelAttr labelAttr = insn.get(AType.LOOP_LABEL);, + if (labelAttr != null) {, + code.add(' ').add(mgen.getNameGen().getLoopLabel(labelAttr));, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.dex.attributes.nodes.LoopLabelAttr;, + // TODO: avoid name collision with variables names, + public String getLoopLabel(LoopLabelAttr attr) {, + String name = "loop" + attr.getLoop().getId();, + varNames.add(name);, + return name;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.attributes.nodes.LoopLabelAttr;, + LoopLabelAttr labelAttr = insn.get(AType.LOOP_LABEL);, + if (labelAttr != null) {, + code.add(' ').add(mgen.getNameGen().getLoopLabel(labelAttr));, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.dex.attributes.nodes.LoopLabelAttr;, +
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.FilledNewArrayNode;, +import java.util.Arrays;, + filledNewArray((FilledNewArrayNode) insn, code);, + case FILL_ARRAY:, + assert isFallback();, + FillArrayNode arrayNode = (FillArrayNode) insn;, + Object data = arrayNode.getData();, + String arrStr;, + if (data instanceof int[]) {, + arrStr = Arrays.toString((int[]) data);, + } else if (data instanceof short[]) {, + arrStr = Arrays.toString((short[]) data);, + } else if (data instanceof byte[]) {, + arrStr = Arrays.toString((byte[]) data);, + } else if (data instanceof long[]) {, + arrStr = Arrays.toString((long[]) data);, + } else {, + arrStr = "?";, + }, + code.add('{').add(arrStr.substring(1, arrStr.length() - 1)).add('}');, + break;, +, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, + List<RegisterArg> args = new LinkedList<RegisterArg>();, + incrInsn.getRegisterArgs(args);, + for (RegisterArg iArg : args) {, + if (assignOnlyInLoop(mth, loopRegion, (RegisterArg) iArg)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, + List<RegisterArg> args = new LinkedList<RegisterArg>();, + incrInsn.getRegisterArgs(args);, + for (RegisterArg iArg : args) {, + if (assignOnlyInLoop(mth, loopRegion, (RegisterArg) iArg)) {, +++ b/jadx-core/src/test/java/jadx/tests/integration/arith/TestArith3.java, +package jadx.tests.integration.arith;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import org.junit.Test;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.CoreMatchers.not;, +import static org.junit.Assert.assertThat;, +, +public class TestArith3 extends IntegrationTest {, +, + public static class TestCls {, + private int vp;, +, + private void test(byte[] buffer) {, +
[+++ b/.travis.yml]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p>, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p>, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p>, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p>, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p>, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p>, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p>, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/Annotation.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * <p>, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/Annotation.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/AnnotationsList.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"--respect-bytecode-access-modifiers"}, description = "don't change original access modifiers"), + protected boolean respectBytecodeAccessModifiers = false;, +, + args.setRespectBytecodeAccModifiers(respectBytecodeAccessModifiers);, + public boolean isRespectBytecodeAccessModifiers() {, + return respectBytecodeAccessModifiers;, + }, +, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"--respect-bytecode-access-modifiers"}, description = "don't change original access modifiers"), + protected boolean respectBytecodeAccessModifiers = false;, +, + args.setRespectBytecodeAccModifiers(respectBytecodeAccessModifiers);, + public boolean isRespectBytecodeAccessModifiers() {, + return respectBytecodeAccessModifiers;, + }, +, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, + private boolean respectBytecodeAccModifiers = false;, + public boolean isRespectBytecodeAccModifiers() {, + return respectBytecodeAccModifiers;, + }, +, + public void setRespectBytecodeAccModifiers(boolean respectBytecodeAccModifiers) {, + this.respectBytecodeAccModifiers
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + private final boolean showInconsistentCode;, + public ClassGen(ClassNode cls, IJadxArgs jadxArgs) {, + this(cls, null, jadxArgs.isFallbackMode(), jadxArgs.isShowInconsistentCode());, + public ClassGen(ClassNode cls, ClassGen parentClsGen) {, + this(cls, parentClsGen, parentClsGen.fallback, parentClsGen.showInconsistentCode);, + }, +, + public ClassGen(ClassNode cls, ClassGen parentClsGen, boolean fallback, boolean showBadCode) {, + this.showInconsistentCode = showBadCode;, + ClassGen inClGen = new ClassGen(innerCls, getParentGen());, + badCode = false;, + new ClassGen(f.getCls(), this).addClassBody(code);, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + private final boolean showInconsistentCode;, + public ClassGen(ClassNode cls, IJadxArgs jadxArgs) {, + this(cls, null, jadxArgs.isFallbackMode(), jadxArgs.isShowInconsistentCode());, + public ClassGen(ClassNode cls, ClassGen parentClsGen) {, + this(cls, parentClsGen, parentClsGen.fallback, parentClsGen.showInconsistentCode);, + }, +, +
[+++ b/.editorconfig, +continuation_indent_size = 8 #IntelliJ Idea specific workaround, +max_line_length = 120]
[+++ b/build.gradle, + compile 'ch.qos.logback:logback-classic:1.0.13', + gradleVersion = '1.6', +++ b/build.gradle, + compile 'ch.qos.logback:logback-classic:1.0.13', + gradleVersion = '1.6', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, + compile 'ch.qos.logback:logback-classic:1.0.13', + gradleVersion = '1.6', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.6-bin.zip]
[+++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, + case CODE:, + case LIB:, + case FONT:, + case UNKNOWN:, + return ResContainer.singleBinaryFile(rf.getName(), inputStream);, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, + case CODE:, + case LIB:, + case FONT:, + case UNKNOWN:, + return ResContainer.singleBinaryFile(rf.getName(), inputStream);, +, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResContainer.java, +import java.io.IOException;, +import org.apache.commons.io.IOUtils;, + @Nullable, + private InputStream binary;, + public static ResContainer singleBinaryFile(String name, InputStream content) {, + ResContainer resContainer = new ResContainer(name, Collections.emptyList());, + try {, + resContainer.binary = new ByteArrayInputStream(IOUtils.toByteArray(content));, + }, + catch(IOException e) {, + LOG.warn("Contents of the binary resource '{}' not saved, got exception {}", name,
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsAdapter.java, + LOG.debug("Created new settings.");, + settings = new JadxSettings();]
[+++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, + return new ResTableParser(), + .decodeFiles(inputStream);, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, + return new ResTableParser(), + .decodeFiles(inputStream);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, + , + public void updateContent(String newData) {, + offset = newData.length();, + buf = new StringBuilder(newData);, + line = newData.split(NL).length + 1;, + code = newData;, + }, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, + return new ResTableParser(), + .decodeFiles(inputStream);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, + , + public void updateContent(String newData) {, + offset = newData.length();, + buf = new StringBuilder(newData);, + line = newData.split(NL).length + 1;, + code = newData;, + }, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, + private RootNode rootNode;, + private String appPackageName;, +, + public
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/FieldArg.java, +import org.jetbrains.annotations.Nullable;, +, + @Nullable, + public FieldArg(FieldInfo field, @Nullable InsnArg reg) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/FieldArg.java, +import org.jetbrains.annotations.Nullable;, +, + @Nullable, + public FieldArg(FieldInfo field, @Nullable InsnArg reg) {, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnWrapArg.java, +import org.jetbrains.annotations.NotNull;, +, + public InsnWrapArg(@NotNull InsnNode insn) {, + public int hashCode() {, + return wrappedInsn.hashCode();, + }, +, + @Override, + public boolean equals(Object o) {, + if (this == o) {, + return true;, + }, + if (!(o instanceof InsnWrapArg)) {, + return false;, + }, + InsnWrapArg that = (InsnWrapArg) o;, + InsnNode thisInsn = wrappedInsn;, + InsnNode thatInsn = that.wrappedInsn;, +
[+++ b/.travis.yml, +# override install to skip 'gradle assemble', +install:, + - true, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, + return new InsnNode(InsnType.NOP, 0);, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, + return new InsnNode(InsnType.NOP, 0);, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, +import java.util.EnumSet;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.Set;, +, + removeEmptyBlocks(mth);, + if (insn.getType() != InsnType.IF) {, + return false;, + }, + return targetBlock == curBlock;, + block.getInstructions().removeIf(insn -> {, + InsnType insnType = insn.getType();, + return insnType == InsnType.GOTO || insnType == InsnType.NOP;, + });, + private void removeEmptyBlocks(MethodNode mth) {, + mth.getBasicBlocks().removeIf(block ->, + block.getInstructions().isEmpty(), + && block.getPredecessors().isEmpty(), + && block.getSuccessors().isEmpty(), + );, + }]
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, + private boolean checkForUpdates = false;, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, + private boolean checkForUpdates = false;, +++ b/version, +0.6.1]
[+++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java, + if (resCls == null) {, + // We are in an APK without code therefore we don't have to update an 'R' class with the resources, + return null;, + }, + private static void addResourceFields(ClassNode resCls, ResourceStorage resStorage, boolean rClsExists) {, + for (ClassNode innerClass : resCls.getInnerClasses()) {, + ClassNode newTypeCls = new ClassNode(resCls.dex(), resCls.getFullName() + "$" + name,, + resCls.addInnerClass(newTypeCls);, +++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java, + if (resCls == null) {, + // We are in an APK without code therefore we don't have to update an 'R' class with the resources, + return null;, + },
[+++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, + public static final String INDENT = "\t";, + public boolean isEmpty() {, + return buf.length() == 0;, + }, +, + @Override, + public int hashCode() {, + return buf.toString().hashCode();, + }, +, + @Override, + public boolean equals(Object o) {, + if (this == o) {, + return true;, + }, + if (!(o instanceof CodeWriter)) {, + return false;, + }, + CodeWriter that = (CodeWriter) o;, + return buf.toString().equals(that.buf.toString());, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, + public static final String INDENT = "\t";, + public boolean isEmpty() {, + return buf.length() == 0;, + },
[+++ b/.gitlab-ci.yml, + - sed -i " 1 s/.*/&-b$(git rev-list --count HEAD)-$(git rev-parse --short HEAD)/" version]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + RegisterArg callArg = getCallMthArg(callMth, i - startArgNum);, + if (callArg != null && callArg.contains(AFlag.SKIP_ARG)) {, + continue;, + }, + private static RegisterArg getCallMthArg(@Nullable MethodNode callMth, int num) {, + if (callMth == null) {, + return null;, + }, + List<RegisterArg> args = callMth.getArguments(false);, + if (args != null && num < args.size()) {, + return args.get(num);, + }, + return null;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + RegisterArg callArg = getCallMthArg(callMth, i - startArgNum);, + if (callArg != null && callArg.contains(AFlag.SKIP_ARG)) {, + continue;, + }, + private static RegisterArg getCallMthArg(@Nullable MethodNode callMth, int
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + // don't add import if this class from same package, + if(classInfo.getPackage().equals(cls.getPackage())), + return shortName;, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + // don't add import if this class from same package, + if(classInfo.getPackage().equals(cls.getPackage())), + return shortName;, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + // don't add import if this class from same package, + if(classInfo.getPackage().equals(cls.getPackage())), + return shortName;, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.ConstClassInsn;, +import jadx.core.dex.instructions.ConstStringInsn;, + case CONST_STR:, + String str = ((ConstStringInsn) insn).getString();, + code.add(StringUtils.unescapeString(str));, + break;, +, + case CONST_CLASS:, + ArgType clsType = ((ConstClassInsn) insn).getClsType();, + code.add(useType(clsType)).add(".class");, + break;, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + //
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, + if (jadxArgs.processArgs(args)) {, + static void processAndSave(JadxCLIArgs inputArgs) {, + JadxDecompiler jadx = new JadxDecompiler(inputArgs.toJadxArgs());, + jadx.load();, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, + if (jadxArgs.processArgs(args)) {, + static void processAndSave(JadxCLIArgs inputArgs) {, + JadxDecompiler jadx = new JadxDecompiler(inputArgs.toJadxArgs());, + jadx.load();, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import java.util.stream.Collectors;, +import jadx.api.JadxArgs;, +import jadx.core.utils.files.FileUtils;, +public class JadxCLIArgs {, + protected List<String> files = new ArrayList<>(1);, + protected String outDir;, + protected String outDirSrc;, + protected String outDirRes;, + protected int threadsCount = JadxArgs.DEFAULT_THREADS_COUNT;, + public JadxArgs toJadxArgs() {, + JadxArgs args = new JadxArgs();, + args.setInputFiles(files.stream().map(FileUtils::toFile).collect(Collectors.toList()));, + args.setOutDir(FileUtils.toFile(outDir));, + args.setOutDirSrc(FileUtils.toFile(outDirSrc));, + args.setOutDirRes(FileUtils.toFile(outDirRes));, + args.setThreadsCount(threadsCount);, +
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, + boolean aliasFromPreset = false;, + String aliasToUse = null;, + for(MethodInfo mth : o.getMethods()){, + if(mth.isAliasFromPreset()) {, + aliasToUse = mth.getAlias();, + aliasFromPreset = true;, + }, + }, + for(MethodInfo mth : o.getMethods()){, + if(aliasToUse == null) {, + aliasToUse = mth.getAlias();, + mth.setAlias(aliasToUse);, + mth.setAliasFromPreset(aliasFromPreset);]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, + addLineIndent();, + addLineIndent();, + addLineIndent();, + private CodeWriter addLineIndent() {, + public CodeWriter addIndent() {, + add(INDENT);, + return this;, + }, +, + public int getLine() {, + return line;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, + addLineIndent();, + addLineIndent();, + addLineIndent();, + private CodeWriter addLineIndent() {, + public CodeWriter addIndent() {, + add(INDENT);, + return this;, + }, +, + public int getLine() {, + return line;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, + code.incIndent();, + code.decIndent();, + boolean addBreak = true;, + if (!RegionUtils.hasExitEdge(c)) {, + addBreak = false;, + }, + if (addBreak) {,
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + passes.add(DotGraphVisitor.dumpRaw(outDir));, + passes.add(DotGraphVisitor.dump(outDir));, + passes.add(DotGraphVisitor.dumpRegions(outDir));, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + passes.add(DotGraphVisitor.dumpRaw(outDir));, + passes.add(DotGraphVisitor.dump(outDir));, + passes.add(DotGraphVisitor.dumpRegions(outDir));, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java, + public static DotGraphVisitor dump(File outDir) {, + return new DotGraphVisitor(outDir, false, false);, + }, +, + public static DotGraphVisitor dumpRaw(File outDir) {, + return new DotGraphVisitor(outDir, false, true);, + }, +, + public static DotGraphVisitor dumpRegions(File outDir) {, + return new DotGraphVisitor(outDir, true, false);, + }, +, + public static DotGraphVisitor dumpRawRegions(File outDir) {, + return new DotGraphVisitor(outDir, true, true);, + }, +, + private DotGraphVisitor(File outDir, boolean useRegions, boolean rawInsn) {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, + return dexBuf.strings().get(index);]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + code.add(arg(insn, 0)).add('[').add(arg(insn.getArg(1), false)).add("] = ").add(arg(insn.getArg(2), false));, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + code.add(arg(insn, 0)).add('[').add(arg(insn.getArg(1), false)).add("] = ").add(arg(insn.getArg(2), false));, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, + String mode = condition.getMode() == IfCondition.Mode.AND ? " && " : " || ";, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + code.add(arg(insn, 0)).add('[').add(arg(insn.getArg(1), false)).add("] = ").add(arg(insn.getArg(2), false));, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, + String mode = condition.getMode() == IfCondition.Mode.AND ? " && " : " || ";, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/IfCondition.java, +import java.util.ArrayList;, + public static IfCondition merge(Mode mode, IfCondition a, IfCondition b) {, + if (a.getMode() == mode) {, + IfCondition n = new IfCondition(a);, + n.addArg(b);, + return n;, + } else if (b.getMode() ==
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlineVisitor.java, +import jadx.core.utils.exceptions.JadxOverflowException;, + checkInsn(mth, insn, toRemove);, + private static void checkInsn(MethodNode mth, InsnNode insn, List<InsnNode> toRemove) {, + if (insn.contains(AFlag.DONT_INLINE)) {, + return;, + }, + InsnType insnType = insn.getType();, + if (insnType != InsnType.CONST && insnType != InsnType.MOVE) {, + return;, + return;, + return;, + replaceConst(mth, insn, lit, toRemove);, + private static void replaceConst(MethodNode mth, InsnNode constInsn, long literal, List<InsnNode> toRemove) {, + SSAVar ssaVar = constInsn.getResult().getSVar();, + List<RegisterArg> useList = new ArrayList<>(ssaVar.getUseList());, + for (RegisterArg arg : useList) {, + if (replaceArg(mth, arg, literal, constInsn, toRemove)) {, + replaceCount++;, + }, + if (replaceCount
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"-ds", "--output-dir-src"}, description = "output directory for sources"), + protected String outDirNameSrc;, +, + @Parameter(names = {"-dr", "--output-dir-res"}, description = "output directory for resources"), + protected String outDirNameRes;, +, + private File outputDirSrc;, + private File outputDirRes;, + if(outDirNameSrc != null) {, + outputDirSrc = new File(outDirNameSrc);, + }, + if(outDirNameRes != null) {, + outputDirRes = new File(outDirNameRes);, + }, + if(outputDirSrc == null) {, + outputDirSrc = new File(outputDir, "source");, + if(outputDirRes == null) {, + outputDirRes = new File(outputDir, "res");, + }, + }, + , + @Override, + public File
[+++ b/.DS_Store, +++ b/.DS_Store, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import jadx.core.utils.files.ZipSecurity;, + if(!ZipSecurity.isValidZipEntryName(subDir) || !ZipSecurity.isValidZipEntryName(fileName)) {, + return;, + }, + if(!ZipSecurity.isValidZipEntryName(fileName)) {, + return;, + }, +++ b/.DS_Store, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import jadx.core.utils.files.ZipSecurity;, + if(!ZipSecurity.isValidZipEntryName(subDir) || !ZipSecurity.isValidZipEntryName(fileName)) {, + return;, + }, + if(!ZipSecurity.isValidZipEntryName(fileName)) {, + return;, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SaveCode.java, +import jadx.core.utils.files.ZipSecurity;, +++ b/.DS_Store, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +import jadx.core.utils.files.ZipSecurity;, + if(!ZipSecurity.isValidZipEntryName(subDir) || !ZipSecurity.isValidZipEntryName(fileName)) {, + return;, + }, + if(!ZipSecurity.isValidZipEntryName(fileName)) {, + return;, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SaveCode.java, +import jadx.core.utils.files.ZipSecurity;, +++ b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java, + private static final int MAX_SIZE_DIFF = 10;, + LOG.error("Path traversal attack detected, invalid name: {}", entryName);, + LOG.error("Path traversal attack
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainDropTarget.java, +package jadx.gui.ui;, +, +import java.awt.datatransfer.DataFlavor;, +import java.awt.datatransfer.Transferable;, +import java.awt.dnd.DnDConstants;, +import java.awt.dnd.DropTargetDragEvent;, +import java.awt.dnd.DropTargetDropEvent;, +import java.awt.dnd.DropTargetEvent;, +import java.awt.dnd.DropTargetListener;, +import java.io.File;, +import java.util.List;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +/**, + * Enables drop support from external applications for the {@link MainWindow} (load dropped APK file), + */, +public class MainDropTarget implements DropTargetListener {, +, + private static final Logger LOG = LoggerFactory.getLogger(MainDropTarget.class);, +, + private final MainWindow mainWindow;, +, + public MainDropTarget(MainWindow mainWindow) {, + super();, + this.mainWindow = mainWindow;, + }, +, + protected void processDrag(DropTargetDragEvent dtde) {, + if (dtde.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {, + dtde.acceptDrag(DnDConstants.ACTION_COPY);, + } else
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +import com.android.dex.Dex.Section;, + public Section openSection(int offset) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +import com.android.dex.Dex.Section;, + public Section openSection(int offset) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + int catchNum = aTry.getCatchHandlerIndex();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +import com.android.dex.Dex.Section;, + public Section openSection(int offset) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + int catchNum = aTry.getCatchHandlerIndex();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/AnnotationsParser.java, +import com.android.dex.Dex.Section;, + Section section = dex.openSection(offset);, + Section ss = dex.openSection(section.readInt());, + Section section = dex.openSection(offset);, + Section anSection = dex.openSection(section.readInt());, + public static Annotation readAnnotation(DexNode dex, Section s, boolean readVisibility) throws DecodeException {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, +import com.android.dex.Dex.Section;, + public Section openSection(int offset) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + int catchNum = aTry.getCatchHandlerIndex();, +++
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, + protected final int target;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, + protected final int target;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, + public int getTarget() {, + return thenBlock == null ? target : thenBlock.getStartOffset();, + }, +, + @Override, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, + protected final int target;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, + public int getTarget() {, + return thenBlock == null ? target : thenBlock.getStartOffset();, + }, +, + @Override, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, + protected final int target;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, + public int getTarget() {, + return thenBlock == null ? target : thenBlock.getStartOffset();, + }, +, + @Override, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/Region.java, +import jadx.core.utils.Utils;,
[+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JResource.java, +import java.util.Comparator;, +, + Comparator<JResource> typeComparator, + = (r1, r2) -> r1.type.ordinal() - r2.type.ordinal();, + Comparator<JResource> nameComparator, + = Comparator.comparing(JResource::getName, String.CASE_INSENSITIVE_ORDER);, +, + files.sort(typeComparator.thenComparing(nameComparator));, +]
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, + return NameMapper.removeInvalidCharsMiddle(name);, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, + return NameMapper.removeInvalidCharsMiddle(name);, +++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, + public static boolean isValidIdentifierStart(int codePoint) {, + return Character.isJavaIdentifierStart(codePoint);, + }, +, + public static boolean isValidIdentifierPart(int codePoint) {, + return Character.isJavaIdentifierPart(codePoint);, + }, +, + /**, + * Return modified string with removed:, + * <p><ul>, + * <li> not printable chars (including unicode), + * <li> chars not valid for java identifier part, + * </ul><p>, + * Note: this 'middle' method must be used with prefixed string:, + * <p><ul>, + * <li> can leave invalid chars for java identifier start (i.e numbers),
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + passes.add(new ProcessVariables());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + passes.add(new ProcessVariables());, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessVariables.java, +import jadx.core.dex.regions.loops.ForLoop;, +import jadx.core.dex.regions.loops.LoopRegion;, +import jadx.core.dex.regions.loops.LoopType;, + private static class CollectUsageRegionVisitor extends TracedRegionVisitor {, + private final List<RegisterArg> args;, + private final Map<Variable, Usage> usageMap;, +, + public CollectUsageRegionVisitor(Map<Variable, Usage> usageMap) {, + this.usageMap = usageMap;, + args = new ArrayList<RegisterArg>();, + regionProcess(mth, curRegion);, + if (insn.contains(AFlag.SKIP)) {, + continue;, + }, + args.clear();, + processInsn(insn, curRegion);, + }, + }, +, + private void regionProcess(MethodNode mth, IRegion region) {, + if (region instanceof LoopRegion) {, + LoopRegion loopRegion = (LoopRegion) region;, + LoopType loopType = loopRegion.getType();,
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java, + return doubleToString(value);, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java, + return doubleToString(value);, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, + progressMonitor.setProgress((int) (done * 100.0 / total));, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java, + return doubleToString(value);, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, + progressMonitor.setProgress((int) (done * 100.0 / total));, +++ b/jadx-samples/src/main/java/jadx/samples/TestCF4.java, + assertEquals(c, 'c');, + assertEquals(c, 'a');]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/entry/EntryConfig.java, + LOG.warn("Invalid orientation value: {}", orientation);, + LOG.warn("Invalid touchscreen value: {}", touchscreen);, + LOG.warn("Invalid density value: {}", density);, + LOG.warn("Invalid keyboard value: {}", keyboard);, + LOG.warn("Invalid navigation value: {}", navigation);]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, + return "DEX: " + file;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, + return "DEX: " + file;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.dex.instructions.args.ArgType;, + } else {, + List<RegisterArg> args = mth.getArguments(false);, + if (isRemovedClassInArgs(cls, args)) {, + modifySyntheticMethod(cls, mth, args);, + }, + }, + }, + }, + }, +, + private static boolean isRemovedClassInArgs(ClassNode cls, List<RegisterArg> mthArgs) {, + for (RegisterArg arg : mthArgs) {, + ArgType argType = arg.getType();, + if (!argType.isObject()) {, + continue;, + }, + ClassNode argCls = cls.dex().resolveClass(argType);, + if (argCls == null) {, + // check if missing class from current top class,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + ArgType origType = callMth.getArguments(false).get(origPos).getInitType();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + ArgType origType = callMth.getArguments(false).get(origPos).getInitType();, +++ b/jadx-core/src/test/java/jadx/tests/integration/invoke/TestCastInOverloadedInvoke.java, +package jadx.tests.integration.invoke;, +, +import java.util.ArrayList;, +import java.util.List;, +, +import org.junit.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestCastInOverloadedInvoke extends IntegrationTest {, +, + public static class TestCls {, +, + public void test() {, + call(new ArrayList<>());, + call((List<String>) new ArrayList<String>());, + }, +, + public void test2(Object obj) {, + if (obj instanceof String) {, + call((String) obj);, + }, + }, +, + public void call(String str) {, + }, +, + public
[+++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, + Object result = null;, + result = decoder.decode(entry.getSize(), inputStream);, + return result;, + public static CodeWriter loadToCodeWriter(InputStream is) throws IOException {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, + Object result = null;, + result = decoder.decode(entry.getSize(), inputStream);, + return result;, + public static CodeWriter loadToCodeWriter(InputStream is) throws IOException {, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +import jadx.api.ResourcesLoader;, + is = new ParserStream(inputStream);, + if (!isBinaryXml()) {, + return ResourcesLoader.loadToCodeWriter(inputStream);, + }, + private boolean isBinaryXml() throws IOException {, + is.mark(4);, + int v = is.readInt16(); // version, + int h = is.readInt16(); // header size, + if (v == 0x0003 && h == 0x0008)
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java, + // If set, this is a weak resource and may be overriden by strong resources of the same name/type., + // This is only useful during linking with other resource tables., + protected static final int FLAG_WEAK = 0x0004;, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ParserConstants.java, + // If set, this is a weak resource and may be overriden by strong resources of the same name/type., + // This is only useful during linking with other resource tables., + protected static final int FLAG_WEAK = 0x0004;, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResTableParser.java, + int size = is.readInt16();, + if ((flags & FLAG_COMPLEX) != 0 ||
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + protected int deobfuscationMaxLength = 64;, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + protected int deobfuscationMaxLength = 64;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + insertRenameInfo(clsCode, cls);, + private void insertRenameInfo(CodeWriter code, ClassNode cls) {, + ClassInfo classInfo = cls.getClassInfo();, + if (classInfo.isRenamed()) {, + code.startLine("/* renamed from: ").add(classInfo.getFullName()).add(" */");, + }, + }, +, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + protected int deobfuscationMaxLength = 64;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + insertRenameInfo(clsCode, cls);, + private void insertRenameInfo(CodeWriter code, ClassNode cls) {, + ClassInfo classInfo = cls.getClassInfo();, + if (classInfo.isRenamed()) {, + code.startLine("/* renamed from: ").add(classInfo.getFullName()).add(" */");, + }, + }, +, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +import jadx.core.dex.attributes.AType;, +import jadx.core.dex.attributes.nodes.SourceFileAttr;, +import org.jetbrains.annotations.NotNull;, +
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, + LOG.error("jadx error: {}", e.getMessage(), e);, + LOG.info("output directory: {}", outDirName);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, + LOG.error("jadx error: {}", e.getMessage(), e);, + LOG.info("output directory: {}", outDirName);, +++ b/jadx-core/src/main/java/jadx/api/JavaPackage.java, +import org.jetbrains.annotations.NotNull;, +, + public int compareTo(@NotNull JavaPackage o) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, + LOG.error("jadx error: {}", e.getMessage(), e);, + LOG.info("output directory: {}", outDirName);, +++ b/jadx-core/src/main/java/jadx/api/JavaPackage.java, +import org.jetbrains.annotations.NotNull;, +, + public int compareTo(@NotNull JavaPackage o) {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, + public interface ResourceDecoder {, + LOG.debug("Error close zip file: {}", zipRef, e);, + LOG.error("Zip file close error: {}", file.getAbsolutePath(), e);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, + LOG.error("jadx error: {}", e.getMessage(), e);, + LOG.info("output directory: {}", outDirName);,
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + protected int deobfuscationMinLength = 3;, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + protected int deobfuscationMinLength = 3;, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, + private static final int CURRENT_SETTINGS_VERSION = 3;, + setDeobfuscationMinLength(3);, + fromVersion++;, + }, + if (fromVersion == 2) {, + if (getDeobfuscationMinLength() == 4) {, + setDeobfuscationMinLength(3);, + }]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.utils.StringUtils;, + return StringUtils.escape(type.toString());, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.utils.StringUtils;, + return StringUtils.escape(type.toString());, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java, +import jadx.core.utils.StringUtils;, + String fileName = StringUtils.escape(mth.getMethodInfo().getShortId()), +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.utils.StringUtils;, + return StringUtils.escape(type.toString());, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java, +import jadx.core.utils.StringUtils;, + String fileName = StringUtils.escape(mth.getMethodInfo().getShortId()), +++ b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java, +, + public static String escape(String str) {, + int len = str.length();, + StringBuilder sb = new StringBuilder(len);, + for (int i = 0; i < len; i++) {, + char c = str.charAt(i);, + switch (c) {, + case '.':, + case '/':, + case ';':, + case '$':, + case ' ':, + case ',':,
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, + passes.add(new ProcessVariables());, + passes.add(new PrepareForCodeGen());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, + passes.add(new ProcessVariables());, + passes.add(new PrepareForCodeGen());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, + private static final NClass[] EMPTY_NCLASS_ARRAY = new NClass[0];, +, + int size = parents.size();, + if (size == 0) {, + return EMPTY_NCLASS_ARRAY;, + }, + return parents.toArray(new NClass[size]);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.regions.variables.ProcessVariables;, + passes.add(new ProcessVariables());, + passes.add(new PrepareForCodeGen());, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, + private static final NClass[] EMPTY_NCLASS_ARRAY = new NClass[0];, +, + int size = parents.size();, + if (size == 0) {, + return EMPTY_NCLASS_ARRAY;, + }, + return parents.toArray(new NClass[size]);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.args.CodeVar;, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + private final int regionsLimit;, + int blocksCount = mth.getBasicBlocks().size();, + this.processedBlocks = new BitSet(blocksCount);, + this.regionsLimit = blocksCount * 100;, + if (regionsCount > regionsLimit) {]
[+++ b/build.gradle, + gradle.projectsEvaluated {, + tasks.withType(Compile) {, + options.compilerArgs << "-Xlint" << "-Xlint:unchecked" << "-Xlint:deprecation", + }, +++ b/build.gradle, + gradle.projectsEvaluated {, + tasks.withType(Compile) {, + options.compilerArgs << "-Xlint" << "-Xlint:unchecked" << "-Xlint:deprecation", + }, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Sep 24 21:49:47 MSK 2013, +++ b/build.gradle, + gradle.projectsEvaluated {, + tasks.withType(Compile) {, + options.compilerArgs << "-Xlint" << "-Xlint:unchecked" << "-Xlint:deprecation", + }, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Sep 24 21:49:47 MSK 2013, +++ b/jadx-core/src/main/java/jadx/api/IJadxArgs.java, +++ b/build.gradle, + gradle.projectsEvaluated {, + tasks.withType(Compile) {, + options.compilerArgs << "-Xlint" << "-Xlint:unchecked" << "-Xlint:deprecation", + }, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Sep 24 21:49:47 MSK 2013, +++
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, + attrName = generateNameForNS(attrUrl);, + private String generateNameForNS(String attrUrl) {, + for(int i = 1; ; i++) {, + String attrName = "ns" + i;, + if(!nsMap.containsValue(attrName)) {, + // do not add generated value to nsMap, + // because attrUrl might be used in a neighbor element, but never defined, + writer.add("xmlns:").add(attrName), + .add("=\"").add(attrUrl).add("\"");, + return attrName;, + }, + }, + }, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java, + String obj;, + if (incompleteType) {, + obj = slice().replace('/', '.');, + } else {, + obj = inclusiveSlice();, + }, + return ArgType.object(obj);, + List<ArgType> list = new LinkedList<ArgType>();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java, + String obj;, + if (incompleteType) {, + obj = slice().replace('/', '.');, + } else {, + obj = inclusiveSlice();, + }, + return ArgType.object(obj);, + List<ArgType> list = new LinkedList<ArgType>();, +++ b/jadx-core/src/main/java/jadx/core/utils/Utils.java, + return obj;, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java, + String obj;, + if (incompleteType) {, + obj = slice().replace('/', '.');, + } else {, + obj = inclusiveSlice();, + }, + return ArgType.object(obj);, +
[+++ b/jadx-core/src/main/java/jadx/core/utils/android/DataInputDelegate.java, +/**, + * Copyright 2014 Ryszard Wiśniewski <brut.alll@gmail.com>, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/IgnoreEdgeAttr.java, + private final Set<BlockNode> blocks = new HashSet<BlockNode>(3);, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/IgnoreEdgeAttr.java, + private final Set<BlockNode> blocks = new HashSet<BlockNode>(3);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, + return startOffset;, + return id == other.id && startOffset == other.startOffset;, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/IgnoreEdgeAttr.java, + private final Set<BlockNode> blocks = new HashSet<BlockNode>(3);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, + return startOffset;, + return id == other.id && startOffset == other.startOffset;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, + case MOVE:, + InsnArg firstArg = insn.getArg(0);, + if (firstArg.isLiteral()) {, + InsnNode constInsn = new InsnNode(InsnType.CONST, 1);, + constInsn.setResult(insn.getResult());, + constInsn.addArg(firstArg);, + constInsn.copyAttributesFrom(insn);, + return constInsn;, + }, + break;, +, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/IgnoreEdgeAttr.java, + private final Set<BlockNode>
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, + DONT_INLINE,, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, + DONT_INLINE,, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +import jadx.core.utils.InsnUtils;, + boolean typeImmutable = elType.isPrimitive();, + int regsCount = insn.getRegisterCount();, + InsnArg[] regs = new InsnArg[regsCount];, + for (int i = 0; i < regsCount; i++) {, + regs[i] = InsnArg.reg(r, elType, typeImmutable);, + for (int i = 0; i < regsCount; i++) {, + int regNum = InsnUtils.getArg(insn, i);, + regs[i] = InsnArg.reg(regNum, elType, typeImmutable);, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AFlag.java, + DONT_INLINE,, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +import jadx.core.utils.InsnUtils;, + boolean typeImmutable = elType.isPrimitive();, + int regsCount = insn.getRegisterCount();, + InsnArg[] regs = new InsnArg[regsCount];, + for (int i = 0; i
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/HeapUsageBar.java, + timer = new Timer(2000, this);, + if (used > r.maxMemory() * 0.8) {, +++ b/jadx-gui/src/main/java/jadx/gui/ui/HeapUsageBar.java, + timer = new Timer(2000, this);, + if (used > r.maxMemory() * 0.8) {, +++ b/jadx-gui/src/main/java/jadx/gui/utils/CodeUsageInfo.java, +import java.util.concurrent.ConcurrentHashMap;, +, + public synchronized void addUsage(CodeNode codeNode) {, + usageList.add(codeNode);, + }, + private final Map<JNode, UsageInfo> usageMap = new ConcurrentHashMap<>();, + UsageInfo usageInfo = usageMap.computeIfAbsent(jNode, key -> new UsageInfo());, + usageInfo.addUsage(codeNode);]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java, + if (getNodeFullName() != null) {, + menu.addSeparator();, + }, + String name = getNodeFullName();, + if (name != null) {, + Utils.setClipboardString(name);, + }, + }, +, + @Nullable, + private String getNodeFullName() {, + return jClass.getFullName();, + } else {, + return node.getName();, + return null;, +++ b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java, + if (getNodeFullName() != null) {, + menu.addSeparator();, + }, + String name = getNodeFullName();, + if (name != null) {, + Utils.setClipboardString(name);, + }, + }, +, + @Nullable, + private String getNodeFullName() {, + return jClass.getFullName();, + } else {, + return node.getName();, + return
[+++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, + private static final boolean ADD_LINE_NUMBERS = false;, +, + if (ADD_LINE_NUMBERS) {, + incIndent(2);, + }, + public CodeWriter startLineWithNum(int sourceLine) {, + if (sourceLine == 0) {, + startLine();, + return this;, + }, + if (ADD_LINE_NUMBERS) {, + newLine();, + attachSourceLine(sourceLine);, + String ln = "/* " + sourceLine + " */ ";, + add(ln);, + if (indentStr.length() > ln.length()) {, + add(indentStr.substring(ln.length()));, + }, + } else {, + startLine();, + attachSourceLine(sourceLine);, + }, + return this;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, + private static final boolean ADD_LINE_NUMBERS = false;, +, + if
[+++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, + boolean isNew = result.add(cls.getName());, + if (isNew) {, + }]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (cls.getInterfaces().size() == 1) {, + } else {, + parent = cls.getSuperClass();, + code.add("new ").add(parent == null ? "Object" : useClass(parent)).add("() ");, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (cls.getInterfaces().size() == 1) {, + } else {, + parent = cls.getSuperClass();, + code.add("new ").add(parent == null ? "Object" : useClass(parent)).add("() ");, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, + return clsInfo.isInner(), + && getShortName().startsWith(Consts.ANONYMOUS_CLASS_PREFIX), + && getDefaultConstructor() != null;, + && (mth.getMethodInfo().getArgsCount() == 0, + || (mth.getArguments(false) != null && mth.getArguments(false).isEmpty()))) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (cls.getInterfaces().size() == 1) {, + } else {, + parent = cls.getSuperClass();, + code.add("new ").add(parent == null
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +, + if(f.getFieldInfo().isRenamed()) {, + code.startLine("/* renamed from: ").add(f.getName()).add(" */");, + }, + if (classInfo.isRenamed()) {, + code.startLine("/* renamed from: ").add(classInfo.getType().getObject()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +, + if(f.getFieldInfo().isRenamed()) {, + code.startLine("/* renamed from: ").add(f.getName()).add(" */");, + }, + if (classInfo.isRenamed()) {, + code.startLine("/* renamed from: ").add(classInfo.getType().getObject()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +, + if(mth.getMethodInfo().isRenamed()) {, + code.startLine("/* renamed from: ").add(mth.getName()).add(" */");, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +, + if(f.getFieldInfo().isRenamed()) {, + code.startLine("/* renamed from: ").add(f.getName()).add(" */");, + }, + if (classInfo.isRenamed()) {, + code.startLine("/* renamed from: ").add(classInfo.getType().getObject()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +, + if(mth.getMethodInfo().isRenamed()) {, + code.startLine("/* renamed from: ").add(mth.getName()).add(" */");, +
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +import org.jetbrains.annotations.Nullable;, + Dex dexBuf = makeDexBuf(entryName, inputStream);, + if (dexBuf != null) {, + addDexFile(entryName, dexBuf);, + }, + @Nullable, + private Dex makeDexBuf(String entryName, InputStream inputStream) {, + try {, + return new Dex(inputStream);, + } catch (Exception e) {, + LOG.error("Failed to load file: {}, error: {}", entryName, e.getMessage(), e);, + return null;, + }, + }, +]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeFlag.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeFlag.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/LoopAttr.java, +import jadx.core.dex.nodes.Edge;, +import java.util.LinkedList;, +import java.util.List;, + * Return source blocks of exit edges. <br>, + Set<BlockNode> blocks = getLoopBlocks();, + for (BlockNode block : blocks) {, + if (!blocks.contains(s) && !s.getAttributes().contains(AttributeType.EXC_HANDLER)) {, + /**, + * Return loop exit edges., + */, + public List<Edge> getExitEdges() {, + List<Edge> edges = new LinkedList<Edge>();, + Set<BlockNode> blocks = getLoopBlocks();, + for (BlockNode block : blocks) {, + for (BlockNode s : block.getSuccessors()) {, + if (!blocks.contains(s) && !s.getAttributes().contains(AttributeType.EXC_HANDLER)) {, + edges.add(new Edge(block, s));, + }, + },
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + if (badCode || mth.contains(AType.JADX_ERROR) || fallback) {, + if (fallback) {, + mthGen.addFallbackMethodCode(code);, + } else {, + }, + code.startLine("/* compiled from: ").add(sourceFileAttr.getFileName()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + if (badCode || mth.contains(AType.JADX_ERROR) || fallback) {, + if (fallback) {, + mthGen.addFallbackMethodCode(code);, + } else {, + }, + code.startLine("/* compiled from: ").add(sourceFileAttr.getFileName()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, + if (name == null || fallback) {, + return name != null ? base + "_" + name : base;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + if (badCode || mth.contains(AType.JADX_ERROR) || fallback) {, + if (fallback) {, + mthGen.addFallbackMethodCode(code);, + } else {,
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/CodePanel.java, + private static final long serialVersionUID = 5310536092010045565L;, +, +++ b/jadx-gui/src/main/java/jadx/gui/ui/CodePanel.java, + private static final long serialVersionUID = 5310536092010045565L;, +, +++ b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java, +import jadx.gui.utils.NLS;, +import javax.swing.JMenuItem;, +import javax.swing.JPopupMenu;, +import javax.swing.SwingUtilities;, +import java.awt.event.MouseWheelEvent;, +import java.awt.event.MouseWheelListener;, +import java.util.ArrayList;, +import java.util.LinkedHashMap;, +import java.util.List;, + private static final long serialVersionUID = -8833600618794570904L;, +, + private final Map<JClass, CodePanel> openTabs = new LinkedHashMap<JClass, CodePanel>();, +, + addMouseWheelListener(new MouseWheelListener() {, + public void mouseWheelMoved(MouseWheelEvent e) {, + int direction = e.getWheelRotation();, + int index = getSelectedIndex();, + int maxIndex = getTabCount() - 1;, + if ((index == 0 && direction < 0), +
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + h.setTryBlock(ct1);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + h.setTryBlock(ct1);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + BlockNode loopEnd = loop.getEnd();, + if (!RegionUtils.isRegionContainsBlock(body, loopEnd), + && !loopEnd.contains(AType.EXC_HANDLER)) {, + body.getSubBlocks().add(loopEnd);, + BlockNode next = getNextBlock(loopEnd);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + h.setTryBlock(ct1);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + BlockNode loopEnd = loop.getEnd();, + if (!RegionUtils.isRegionContainsBlock(body, loopEnd), + && !loopEnd.contains(AType.EXC_HANDLER)) {, + body.getSubBlocks().add(loopEnd);, + BlockNode next = getNextBlock(loopEnd);, +++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, + b.and(b2.getDomFrontier());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + h.setTryBlock(ct1);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + BlockNode loopEnd = loop.getEnd();, + if (!RegionUtils.isRegionContainsBlock(body, loopEnd), + && !loopEnd.contains(AType.EXC_HANDLER)) {, + body.getSubBlocks().add(loopEnd);, + BlockNode next = getNextBlock(loopEnd);, +++ b/jadx-core/src/main/java/jadx/core/utils/BlockUtils.java, + b.and(b2.getDomFrontier());, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + h.setTryBlock(ct1);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/AnnotationsList.java, +import java.util.Collections;, + public static final AnnotationsList EMPTY = new AnnotationsList(Collections.<Annotation>emptyList());, +, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/annotations/AnnotationsList.java, +import java.util.Collections;, + public static final AnnotationsList EMPTY = new AnnotationsList(Collections.<Annotation>emptyList());, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/AnnotationsParser.java, + if (offset == 0) {, + return AnnotationsList.EMPTY;, + }, + if (size == 0) {, + return AnnotationsList.EMPTY;, + }, + byte v = s.readByte();, + visibility = VISIBILITIES[v];]
[+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, + private static final long serialVersionUID = 1337L; // TODO: Create your own serialvers with serialver/eclipse, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, + private static final long serialVersionUID = 1337L; // TODO: Create your own serialvers with serialver/eclipse, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, + Enumeration<?> en = this.breadthFirstEnumeration();, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, + private static final long serialVersionUID = 1337L; // TODO: Create your own serialvers with serialver/eclipse, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, + Enumeration<?> en = this.breadthFirstEnumeration();, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, + private JList<Object> resultsList;, + private static class ResultsModel extends DefaultListModel<Object> {, + private static class ResultsCellRenderer implements ListCellRenderer<Object> {, + public Component getListCellRendererComponent(JList<?> list,, + resultsList = new
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +import jadx.core.dex.nodes.BlockNode;, +public class GotoNode extends TargetInsnNode {, + public boolean replaceTargetBlock(BlockNode origin, BlockNode replace) {, + return false;, + }, +, + @Override, + public void initBlocks(BlockNode curBlock) {, + }, +, + @Override, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, +import jadx.core.dex.nodes.BlockNode;, +public class GotoNode extends TargetInsnNode {, + public boolean replaceTargetBlock(BlockNode origin, BlockNode replace) {, + return false;, + }, +, + @Override, + public void initBlocks(BlockNode curBlock) {, + }, +, + @Override, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, + @Override, + @Override, + public boolean replaceTargetBlock(BlockNode origin, BlockNode replace) {, + if (thenBlock == origin) {, + thenBlock = replace;, +
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + ClassLoader classLoader = Jadx.class.getClassLoader();, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + ClassLoader classLoader = Jadx.class.getClassLoader();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + fallbackOnlyInsn(insn);, + fallbackOnlyInsn(insn);, + fallbackOnlyInsn(insn);, + fallbackOnlyInsn(insn);, + fallbackOnlyInsn(insn);, + fallbackOnlyInsn(insn);, + private void fallbackOnlyInsn(InsnNode insn) throws CodegenException {, + if (!fallback) {, + throw new CodegenException(insn.getType() + " can be used only in fallback mode");, + }, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + ClassLoader classLoader = Jadx.class.getClassLoader();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + fallbackOnlyInsn(insn);, + fallbackOnlyInsn(insn);, + fallbackOnlyInsn(insn);, + fallbackOnlyInsn(insn);, + fallbackOnlyInsn(insn);, + fallbackOnlyInsn(insn);, + private void fallbackOnlyInsn(InsnNode insn) throws CodegenException {, + if (!fallback) {, + throw new CodegenException(insn.getType() + " can be
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + JavaMethod getJavaMethodByNode(MethodNode mth) {, + JavaMethod javaMethod = methodsMap.get(mth);, + if (javaMethod != null) {, + return javaMethod;, + }, + // parent class not loaded yet, + JavaClass javaClass = classesMap.get(mth.getParentClass());, + if (javaClass != null) {, + javaClass.decompile();, + return methodsMap.get(mth);, + }, + return null;, + }, +, + JavaField getJavaFieldByNode(FieldNode fld) {, + JavaField javaField = fieldsMap.get(fld);, + if (javaField != null) {, + return javaField;, + }, + // parent class not loaded yet, + JavaClass javaClass = classesMap.get(fld.getParentClass());, + if (javaClass != null) {, + javaClass.decompile();, + return fieldsMap.get(fld);, +
[+++ b/jadx-core/src/main/java/jadx/core/utils/exceptions/JadxOverflowException.java, +, + private static final long serialVersionUID = 2568659798680154204L;, +]
[+++ b/.gitignore, +jadx-core/src/test/java/jadx/tests/external/, +++ b/.gitignore, +jadx-core/src/test/java/jadx/tests/external/, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + useClass(code, ClassInfo.extCls(cls.root(), type));, +++ b/.gitignore, +jadx-core/src/test/java/jadx/tests/external/, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + useClass(code, ClassInfo.extCls(cls.root(), type));, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + MethodNode callMthNode = mth.root().deepResolveMethod(callMth);, +++ b/.gitignore, +jadx-core/src/test/java/jadx/tests/external/, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + useClass(code, ClassInfo.extCls(cls.root(), type));, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + MethodNode callMthNode = mth.root().deepResolveMethod(callMth);, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, + ClassInfo extClsInfo = ClassInfo.extCls(mth.root(), type);, +++ b/.gitignore, +jadx-core/src/test/java/jadx/tests/external/, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + useClass(code, ClassInfo.extCls(cls.root(), type));, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + MethodNode callMthNode = mth.root().deepResolveMethod(callMth);, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, + ClassInfo extClsInfo = ClassInfo.extCls(mth.root(), type);, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +import jadx.api.JadxArgs;, +import jadx.core.dex.attributes.AType;, +import jadx.core.dex.attributes.nodes.SourceFileAttr;, +import jadx.core.dex.info.ClassInfo;, +import jadx.core.dex.info.FieldInfo;, +import jadx.core.dex.info.MethodInfo;, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.DexNode;, +import jadx.core.dex.nodes.FieldNode;, +import
[+++ b/.travis.yml, + if: branch = master AND env(BINTRAY_USER) IS present, +++ b/.travis.yml, + if: branch = master AND env(BINTRAY_USER) IS present, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +++ b/.travis.yml, + if: branch = master AND env(BINTRAY_USER) IS present, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + InsnNode insn = insnByOffset[offset];, + insn.add(AFlag.TRY_ENTER);, + } else {, +++ b/.travis.yml, + if: branch = master AND env(BINTRAY_USER) IS present, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + InsnNode insn = insnByOffset[offset];, + insn.add(AFlag.TRY_ENTER);, + } else {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java, +++ b/.travis.yml, + if: branch = master AND env(BINTRAY_USER) IS present, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnNode.java, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + InsnNode insn = insnByOffset[offset];, +
[+++ b/build.gradle, + compileJava {, + options.compilerArgs << '-Xlint', + }, +, + gradleVersion = '1.7', +++ b/build.gradle, + compileJava {, + options.compilerArgs << '-Xlint', + }, +, + gradleVersion = '1.7', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, + compileJava {, + options.compilerArgs << '-Xlint', + }, +, + gradleVersion = '1.7', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.7-bin.zip]
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfInfo.java, + private final Set<BlockNode> skipBlocks;, + this(condition, thenBlock, elseBlock, new HashSet<BlockNode>(), new HashSet<BlockNode>());, + Set<BlockNode> mergedBlocks, Set<BlockNode> skipBlocks) {, + public void merge(IfInfo... arr) {, + for (IfInfo info : arr) {, + mergedBlocks.addAll(info.getMergedBlocks());, + skipBlocks.addAll(info.getSkipBlocks());, + }, + }, +, + public Set<BlockNode> getSkipBlocks() {, + return skipBlocks;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfInfo.java, + private final Set<BlockNode> skipBlocks;, + this(condition, thenBlock, elseBlock, new HashSet<BlockNode>(), new HashSet<BlockNode>());, + Set<BlockNode> mergedBlocks, Set<BlockNode> skipBlocks) {, + public void merge(IfInfo... arr) {, + for (IfInfo info : arr) {, + mergedBlocks.addAll(info.getMergedBlocks());, + skipBlocks.addAll(info.getSkipBlocks());, + }, + }, +, + public
[+++ b/jadx-core/src/main/java/jadx/core/utils/android/AndroidResourcesUtils.java, + final String resTypeName = resource.getTypeName();, + resTypeName,, + final String resName;, + if ("style".equals(resTypeName)) {, + resName = resource.getKeyName().replace('.', '_');, + } else {, + resName = resource.getKeyName();, + }]
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, + if (!dir.exists() && !dir.mkdirs()) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, + if (!dir.exists() && !dir.mkdirs()) {, +++ b/jadx-core/src/test/java/jadx/tests/api/compiler/ClassFileManager.java, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentMap;, + private final Map<String, JavaClassObject> clsMap = new ConcurrentHashMap<>();, + private final Map<String, Class<?>> clsCache = new ConcurrentHashMap<>();]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, + return new ResRefField(dex, str.replace('/', '.'));, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, + return new ResRefField(dex, str.replace('/', '.'));, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java, +, + /**, + * Resources *, + */, + resourcesNames = resStorage.getResourcesNames();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, + return new ResRefField(dex, str.replace('/', '.'));, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/RootNode.java, +, + /**, + * Resources *, + */, + resourcesNames = resStorage.getResourcesNames();, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +import jadx.core.xmlgen.entry.ValuesParser;, + private final Map<Integer, String> styleMap = new HashMap<Integer, String>();, + private final Map<Integer, FieldNode> localStyleMap = new HashMap<Integer, FieldNode>();, + private final Map<Integer, String> resNames;, + private ValuesParser valuesParser;, +, + resNames = root.getResourcesNames();, +, + valuesParser = new ValuesParser(strings,
[+++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + passes = null;, + codeGen = null;, + init();, +, + root = new RootNode(args);, + root.initClassPath();, +, + initVisitors();, + }, +, + private void initVisitors() {, + for (IDexTreeVisitor pass : passes) {, + try {, + pass.init(root);, + } catch (Exception e) {, + LOG.error("Visitor init failed: {}", pass.getClass().getSimpleName(), e);, + }, + }, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + passes = null;, + codeGen = null;, + init();, +, + root = new RootNode(args);, + root.initClassPath();, +, + initVisitors();, + }, +, + private void initVisitors() {, + for
[+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +++ b/jadx-core/src/test/java/jadx/tests/integration/variables/TestVariables7.java, +package jadx.tests.integration.variables;, +, +import static org.hamcrest.MatcherAssert.assertThat;, +import static org.hamcrest.Matchers.containsString;, +, +import java.util.ArrayList;, +import java.util.List;, +, +import org.junit.jupiter.api.Test;, +, +import jadx.NotYetImplemented;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +public class TestVariables7 extends IntegrationTest {, +, + public static class TestCls {, +, + public void test() {, + List list;, + synchronized (this) {, + list = new ArrayList();, + }, + for (Object o : list) {, + System.out.println(o);, + }, + }, + }, +, + @Test, + @NotYetImplemented, + public void test() {, + ClassNode cls = getClassNode(TestCls.class);, + String code = cls.getCode().toString();,
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ExtractFieldInit;, + passes.add(new ExtractFieldInit());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ExtractFieldInit;, + passes.add(new ExtractFieldInit());, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.dex.nodes.InsnNode;, +import jadx.core.dex.nodes.parser.FieldInitAttr;, +import jadx.core.dex.nodes.parser.FieldInitAttr.InitType;, + FieldInitAttr fv = f.get(AType.FIELD_INIT);, + if (fv.getValueType() == InitType.CONST) {, + } else if (fv.getValueType() == InitType.INSN) {, + InsnGen insnGen = makeInsnGen(fv.getInsnMth());, + addInsnBody(insnGen, code, fv.getInsn());, + }, + igen = makeInsnGen(enumFields.getStaticMethod());, + private InsnGen makeInsnGen(MethodNode mth) {, + MethodGen mthGen = new MethodGen(this, mth);, + return new InsnGen(mthGen, false);, + }, +, + private void addInsnBody(InsnGen insnGen, CodeWriter code, InsnNode insn) {, + try {, + insnGen.makeInsn(insn, code, InsnGen.Flags.BODY_ONLY_NOWRAP);, + } catch (Exception e)
[+++ b/build.gradle, +buildscript {, + repositories {, + mavenCentral(), + jcenter(), + }, +}, +, +plugins {, + id "com.github.kt3k.coveralls" version "2.0.1", + id "info.solidsoft.pitest" version "1.1.1", +// id "com.github.ben-manes.versions" version "0.6", +}, +ext.jadxVersion = file('version').readLines().get(0), +version = jadxVersion, +, + apply plugin: 'com.github.kt3k.coveralls', + testCompile 'org.mockito:mockito-core:1.10.13', +/* Sonar runner configuration */, +sonarRunner {, + toolVersion = '2.4', +task pitest(overwrite: true, dependsOn: 'jadx-core:pitest') {, +task cleanBuildDir(type: Delete) {, +build.dependsOn(dist, samples), +, +clean.dependsOn(cleanBuildDir), +, + gradleVersion = '2.2.1', +++ b/build.gradle, +buildscript {, + repositories {, + mavenCentral(), + jcenter(), + }, +}, +, +plugins {, + id "com.github.kt3k.coveralls" version "2.0.1",
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import java.io.InputStream;, + try (InputStream is = resources.nextElement().openStream()) {, + Manifest manifest = new Manifest(is);, + }]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new DebugInfoVisitor());, + passes.add(new TypeInference());, +, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new FinishTypeInference());, +, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new DebugInfoVisitor());, + passes.add(new TypeInference());, +, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, + private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new DebugInfoVisitor());,
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, + opt.append(" (default: ").append(val).append(')');, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, + opt.append(" (default: ").append(val).append(')');, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<?> jcw) {, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, + opt.append(" (default: ").append(val).append(')');, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<?> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, + return line + ':' + offset + (node != null ? " " + node : "");, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, + opt.append(" (default: ").append(val).append(')');, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<?> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, + return line + ':' + offset + (node != null ? " " + node : "");, +++
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnContainer.java, + public InsnContainer(List<InsnNode> insns) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/InsnContainer.java, + public InsnContainer(List<InsnNode> insns) {, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/TryCatchBlock.java, +import java.util.Iterator;, +import java.util.LinkedList;, + handlers = new LinkedList<ExceptionHandler>();, + for (Iterator<ExceptionHandler> it = handlers.iterator(); it.hasNext(); ) {, + ExceptionHandler h = it.next();, + if (h == handler) {, + it.remove();, + } else {, + for (InsnNode insn : insns) {, + }, + for (BlockNode block : mth.getBasicBlocks()) {, + }, + }, + setFinalBlock(new InsnContainer(finalBlockInsns));, + for (BlockNode ehb : h.getBlocks()) {, + }, + if (attr == ca) {, + }, + for (InsnNode insn : tryBlock.getInsns()) {, +
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/TabbedPane.java, +import org.jetbrains.annotations.Nullable;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import java.awt.Component;, +import java.awt.FlowLayout;, +import javax.swing.BorderFactory;, +import javax.swing.ImageIcon;, +import javax.swing.JButton;, +import javax.swing.JLabel;, +import javax.swing.JMenuItem;, +import javax.swing.JPanel;, +import javax.swing.JPopupMenu;, +import javax.swing.JTabbedPane;, +import javax.swing.SwingUtilities;, +import javax.swing.plaf.basic.BasicButtonUI;, +import javax.swing.text.BadLocationException;, +import jadx.gui.treemodel.JCertificate;, +import jadx.gui.treemodel.JClass;, + JMenuItem copyRootClassName = new JMenuItem(NLS.str("tabs.copy_class_name"));, + copyRootClassName.addActionListener(new ActionListener() {, + @Override, + public void actionPerformed(ActionEvent actionEvent) {, + copyRootClassName();, + }, + });, + menu.add(copyRootClassName);, +, + public void copyRootClassName(){, + ContentPanel selectedPanel = getSelectedCodePanel();, + JNode node = selectedPanel.getNode();, + JClass jClass = node.getRootClass();, + if (jClass != null){, + String name = jClass.getFullName();, + Utils.setClipboardString(name);, + },
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, +import java.util.Collections;, +import java.util.HashSet;, + private final Set<String> reservedClsNames = new HashSet<>();, + Collections.addAll(reservedClsNames, cls.getPackage().split("\\."));, + }, + }, + for (DexNode dexNode : dexNodes) {, + for (ClassNode cls : dexNode.getClasses()) {, + if (!clsMap.containsKey(classInfo)) {, + String clsShortName = classInfo.getShortName();, + if (shouldRename(clsShortName) || reservedClsNames.contains(clsShortName)) {, + }]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.dex.instructions.mods.ConstructorInsn;, + if (cls.getAccessFlags().isSynthetic(), + && cls.getFields().isEmpty(), + && cls.getMethods().isEmpty()) {, + cls.getAttributes().add(AttributeFlag.DONT_GENERATE);, + return false;, + }, +, + // remove synthetic constructor for inner non-static classes, + if (af.isSynthetic() && af.isConstructor() && mth.getBasicBlocks().size() == 2) {, + List<InsnNode> insns = mth.getBasicBlocks().get(0).getInstructions();, + if (insns.size() == 1 && insns.get(0).getType() == InsnType.CONSTRUCTOR) {, + ConstructorInsn constr = (ConstructorInsn) insns.get(0);, + if (constr.isThis() && mth.getArguments(false).size() >= 1) {, + mth.removeFirstArgument();, + mth.getAttributes().add(AttributeFlag.DONT_GENERATE);, + }, + }, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.dex.instructions.mods.ConstructorInsn;, + if (cls.getAccessFlags().isSynthetic(), + && cls.getFields().isEmpty(), + && cls.getMethods().isEmpty()) {, + cls.getAttributes().add(AttributeFlag.DONT_GENERATE);, + return false;,
[+++ b/.travis.yml, + - env: JDK=openjdk11, + jdk: openjdk11]
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, + boolean replaced = false;, + replaced = true;, + replaced = true;, + return replaced;, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, + boolean replaced = false;, + replaced = true;, + replaced = true;, + return replaced;, +++ b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchReturnFromCase2.java, +package jadx.tests.integration.switches;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +import org.junit.Test;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertThat;, +import static org.junit.Assert.assertTrue;, +, +public class TestSwitchReturnFromCase2 extends IntegrationTest {, +, + public static class TestCls {, + public boolean test(int a) {, + switch (a % 4) {, + case 2:, + case 3:, +
[+++ b/build.gradle, + gradleVersion = '1.8', +++ b/build.gradle, + gradleVersion = '1.8', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, + gradleVersion = '1.8', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-bin.zip]
[+++ b/.travis.yml, + - TERM=dumb ./gradlew jacocoTestReport, + - bash <(curl -s https://codecov.io/bash) || echo "Codecov did not collect coverage reports", +++ b/.travis.yml, + - TERM=dumb ./gradlew jacocoTestReport, + - bash <(curl -s https://codecov.io/bash) || echo "Codecov did not collect coverage reports", +++ b/README.md, +[![Code Coverage](https://codecov.io/gh/skylot/jadx/branch/master/graph/badge.svg)](https://codecov.io/gh/skylot/jadx), +*Copyright 2016 by Skylot*, +++ b/.travis.yml, + - TERM=dumb ./gradlew jacocoTestReport, + - bash <(curl -s https://codecov.io/bash) || echo "Codecov did not collect coverage reports", +++ b/README.md, +[![Code Coverage](https://codecov.io/gh/skylot/jadx/branch/master/graph/badge.svg)](https://codecov.io/gh/skylot/jadx), +*Copyright 2016 by Skylot*, +++ b/build.gradle, +allprojects {, + mavenCentral(), + xml.enabled = true, +++ b/.travis.yml, + - TERM=dumb ./gradlew jacocoTestReport, + - bash
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, + // change default types priority, + PrimitiveType.INT,, + PrimitiveType.OBJECT, PrimitiveType.ARRAY,, + PrimitiveType.BOOLEAN, PrimitiveType.BYTE, PrimitiveType.SHORT, PrimitiveType.CHAR);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, + // change default types priority, + PrimitiveType.INT,, + PrimitiveType.OBJECT, PrimitiveType.ARRAY,, + PrimitiveType.BOOLEAN, PrimitiveType.BYTE, PrimitiveType.SHORT, PrimitiveType.CHAR);, +++ b/jadx-core/src/test/java/jadx/tests/integration/types/TestTypeResolver4.java, +package jadx.tests.integration.types;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import java.util.Arrays;, +, +import org.junit.Test;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.hamcrest.Matchers.is;, +import static org.junit.Assert.assertThat;, +, +public class TestTypeResolver4 extends IntegrationTest {, +, + public static class TestCls {, +, + private static String test(byte[] strArray, int offset) {, + int len = strArray.length;, + int start = offset + f(strArray, offset);, +
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + root.loadResources(getResources());, + root.initAppResClass();, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + root.loadResources(getResources());, + root.initAppResClass();, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, + return ResourcesLoader.loadContent(decompiler, this);, + ZipRef getZipRef() {, + return zipRef;, + }, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + root.loadResources(getResources());, + root.initAppResClass();, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, + return ResourcesLoader.loadContent(decompiler, this);, + ZipRef getZipRef() {, + return zipRef;, + }, +, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, + public static interface ResourceDecoder {, + Object decode(long size, InputStream is) throws IOException;, + }, +, + public static Object decodeStream(ResourceFile rf, ResourceDecoder decoder) throws JadxException {, + ZipRef zipRef = rf.getZipRef();, + if (entry == null) {, + throw new IOException("Zip entry not found: "
[+++ b/.editorconfig, +# EditorConfig is awesome: https://EditorConfig.org, +root = true, +, +[*], +end_of_line = lf, +insert_final_newline = true, +, +indent_style = tab, +tab_width = 4, +, +charset = utf-8, +trim_trailing_whitespace = true, +, +[*.xml], +indent_size = 1, +, +[*.yml], +indent_style = space, +indent_size = 2, +, +[*.bat], +end_of_line = crlf, +++ b/.editorconfig, +# EditorConfig is awesome: https://EditorConfig.org, +root = true, +, +[*], +end_of_line = lf, +insert_final_newline = true, +, +indent_style = tab, +tab_width = 4, +, +charset = utf-8, +trim_trailing_whitespace = true, +, +[*.xml], +indent_size = 1, +, +[*.yml], +indent_style = space, +indent_size = 2, +, +[*.bat], +end_of_line =
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, + InsnArg activeReg = activeRegisters[var.getRegNum()];, + if (activeReg instanceof RegisterArg) {, + SSAVar ssaVar = ((RegisterArg) activeReg).getSVar();, + if (ssaVar != null && ssaVar.getStartAddr() != -1) {, + InsnNode parentInsn = ssaVar.getAssign().getParentInsn();, + if (parentInsn != null && parentInsn.getOffset() >= 0) {, + addr = parentInsn.getOffset();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, + InsnArg activeReg = activeRegisters[var.getRegNum()];, + if (activeReg instanceof RegisterArg) {, + SSAVar ssaVar = ((RegisterArg) activeReg).getSVar();, + if (ssaVar != null && ssaVar.getStartAddr() != -1) {, + InsnNode parentInsn = ssaVar.getAssign().getParentInsn();, + if (parentInsn != null && parentInsn.getOffset() >= 0) {, + addr = parentInsn.getOffset();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"-x", "--xml"}, description = "try to decode the AndroidManifest.xml, save at current dir"), + protected boolean xmlTest = false;, +, + public boolean isXMLTest() {, + return xmlTest;, + }, +, + @Override, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"-x", "--xml"}, description = "try to decode the AndroidManifest.xml, save at current dir"), + protected boolean xmlTest = false;, +, + public boolean isXMLTest() {, + return xmlTest;, + }, +, + @Override, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +, + @Override, + public boolean isXMLTest() {, + return false;, + }, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"-x", "--xml"}, description
[+++ b/build.gradle, + id 'org.sonarqube' version '2.6.2', + id 'com.github.ben-manes.versions' version '0.17.0', + compile 'org.slf4j:slf4j-api:1.7.25', + testCompile 'ch.qos.logback:logback-classic:1.2.3', + testCompile 'org.mockito:mockito-core:2.15.0', + testCompile 'org.spockframework:spock-core:1.1-groovy-2.4', + testCompile 'cglib:cglib-nodep:3.2.6', + jacoco {, + toolVersion = "0.8.0", + }, +dependencyUpdates.resolutionStrategy = {, + componentSelection { rules ->, + rules.all { ComponentSelection selection ->, + boolean rejected = ['alpha', 'beta', 'rc', 'cr', 'm', 'atlassian'].any { qualifier ->, + selection.candidate.version ==~ /(?i).*[.-]${qualifier}[.\d-]*/, + }, + if (rejected) {, + selection.reject('Release candidate'), + }, + }, + }, +}, +, +++ b/build.gradle, + id 'org.sonarqube' version '2.6.2', + id 'com.github.ben-manes.versions' version '0.17.0', + compile 'org.slf4j:slf4j-api:1.7.25',
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, + if (isR(cls.getParentClass())) {, + return;, + }, +, + private static boolean isR(ClassNode cls) {, + if (!cls.getClassInfo().getShortName().equals("R")) {, + return false;, + }, + if (!cls.getMethods().isEmpty() || !cls.getFields().isEmpty()) {, + return false;, + }, + for (ClassNode inner : cls.getInnerClasses()) {, + for (MethodNode m : inner.getMethods()) {, + if (!m.getMethodInfo().isConstructor() && !m.getMethodInfo().isClassInit()) {, + return false;, + }, + }, + for (FieldNode field : cls.getFields()) {, + ArgType type = field.getType();, + if (type != ArgType.INT && (!type.isArray() || type.getArrayElement() != ArgType.INT)) {, + return false;, + }, + }, + }, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributesList.java, +import java.util.LinkedList;, + attributes = new LinkedList<IAttribute>();, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributesList.java, +import java.util.LinkedList;, + attributes = new LinkedList<IAttribute>();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import java.util.LinkedHashMap;, + private final AccessInfo accessFlags;, + private final List<MethodNode> methods;, + private final List<FieldNode> fields;, + private Map<Object, FieldNode> constFields = Collections.emptyMap();, + if (cls.getSupertypeIndex() == DexNode.NO_INDEX) {, + this.superClass = null;, + } else {, + this.superClass = ClassInfo.fromDex(dex, cls.getSupertypeIndex());, + }, + int mthsCount = clsData.getDirectMethods().length + clsData.getVirtualMethods().length;, + int fieldsCount = clsData.getStaticFields().length + clsData.getInstanceFields().length;, + methods = new ArrayList<MethodNode>(mthsCount);, + fields = new ArrayList<FieldNode>(fieldsCount);, +, + for (Method mth : clsData.getDirectMethods()) {, + },
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, + }, + setFromOut(args);, + checkDir(args.getOutDir());, + checkDir(args.getOutDirSrc());, + checkDir(args.getOutDirRes());, + private static void setFromOut(JadxArgs args) {, + if (args.getOutDirSrc() == null) {, + args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, + }, + if (args.getOutDirRes() == null) {, + args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, + }, + }, +, + private static void checkDir(File dir) {, + throw new JadxArgsValidateException("Output directory exists as file " + dir);, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, + }, + setFromOut(args);, + checkDir(args.getOutDir());, + checkDir(args.getOutDirSrc());, + checkDir(args.getOutDirRes());, + private static void setFromOut(JadxArgs
[+++ /dev/null, +++ /dev/null, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.utils.exceptions.JadxException;, +, +import java.io.File;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, + private static final Logger LOG = LoggerFactory.getLogger(JadxCLI.class);, + try {, + JadxCLIArgs jadxArgs = new JadxCLIArgs(args);, + checkArgs(jadxArgs);, + } catch (Throwable e) {, + LOG.error(e.getMessage());, + System.exit(1);, + }, + }, +, + private static void checkArgs(JadxCLIArgs jadxArgs) throws JadxException {, + if (jadxArgs.getInput().isEmpty()), + throw new JadxException("Please specify input file");, +, + File outputDir = jadxArgs.getOutDir();, + if (outputDir == null) {, + String outDirName;, + File file = jadxArgs.getInput().get(0);, + String name = file.getName();, + int pos = name.lastIndexOf('.');,
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, + boolean reThrow = false;, + reThrow = true;, + if (totalSize == 0 && noExitNode && reThrow) {]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchBar.java, +import jadx.gui.utils.TextStandardActions;, + new TextStandardActions(searchField);, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchBar.java, +import jadx.gui.utils.TextStandardActions;, + new TextStandardActions(searchField);, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, + new TextStandardActions(searchField);, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchBar.java, +import jadx.gui.utils.TextStandardActions;, + new TextStandardActions(searchField);, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, + new TextStandardActions(searchField);, +++ b/jadx-gui/src/main/java/jadx/gui/utils/TextStandardActions.java, +package jadx.gui.utils;, +, +import javax.swing.AbstractAction;, +import javax.swing.Action;, +import javax.swing.JPopupMenu;, +import javax.swing.KeyStroke;, +import javax.swing.event.UndoableEditEvent;, +import javax.swing.event.UndoableEditListener;, +import javax.swing.text.JTextComponent;, +import javax.swing.undo.UndoManager;, +import java.awt.Toolkit;, +import java.awt.datatransfer.DataFlavor;, +import java.awt.event.ActionEvent;, +import java.awt.event.InputEvent;, +import java.awt.event.KeyEvent;, +import java.awt.event.MouseAdapter;, +import java.awt.event.MouseEvent;, +, +@SuppressWarnings("serial"), +public class TextStandardActions {, +, + private final JTextComponent textComponent;, +, + private final JPopupMenu popup = new JPopupMenu();, + private final UndoManager undoManager;, +, + private Action undoAction;, + private
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, + public boolean isNewInstance() {, + return callType == CallType.CONSTRUCTOR;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, + public boolean isNewInstance() {, + return callType == CallType.CONSTRUCTOR;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, + int maxAddr = insnByOffset.length - 1;, + newAddr = Math.min(newAddr, maxAddr);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/mods/ConstructorInsn.java, + public boolean isNewInstance() {, + return callType == CallType.CONSTRUCTOR;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, + int maxAddr = insnByOffset.length - 1;, + newAddr = Math.min(newAddr, maxAddr);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +, + InstructionRemover remover = new InstructionRemover(mth);, + replaceStep(mth, remover);, + removeStep(mth, remover);, + private static void replaceStep(MethodNode mth, InstructionRemover remover) {, + remover.setBlock(block);,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + LOG.warn("Unknown array element type: {} in mth: {}", elType, mth);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + LOG.warn("Unknown array element type: {} in mth: {}", elType, mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, + RegisterArg iterVar = arrGetInsn.getResult();, + if (iterVar == null) {, + return null;, + }, + if (iterVar == null || !fixIterableType(iterableArg, iterVar)) {, + LOG.debug(" LoopRegionVisitor: instruction not found: {}, mth: {}", parentInsn, mth);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + LOG.warn("Unknown array element type: {} in mth: {}", elType, mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, + RegisterArg iterVar = arrGetInsn.getResult();, + if (iterVar == null) {, + return null;, + }, + if (iterVar ==
[+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import java.util.Iterator;, +import jadx.core.dex.info.ClassInfo;, + Iterator<ClassInfo> it = handler.getCatchTypes().iterator();, + if (it.hasNext()) {, + useClass(code, it.next());, + }, + while (it.hasNext()) {, + code.add(" | ");, + useClass(code, it.next());, + }, + InsnArg arg = handler.getArg();, + if (arg instanceof RegisterArg) {, + code.add(mgen.getNameGen().assignArg((RegisterArg) arg));, + } else if (arg instanceof NamedArg) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import java.util.Iterator;, +import jadx.core.dex.info.ClassInfo;, + Iterator<ClassInfo> it = handler.getCatchTypes().iterator();, + if (it.hasNext()) {, + useClass(code, it.next());, + }, + while (it.hasNext()) {, + code.add(" | ");, + useClass(code, it.next());, + }, + InsnArg arg = handler.getArg();, + if (arg instanceof RegisterArg) {,
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, + SwingUtilities.invokeLater(new MainWindow(settings)::init);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, + SwingUtilities.invokeLater(new MainWindow(settings)::init);, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, + Runnable save = () -> {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, + SwingUtilities.invokeLater(new MainWindow(settings)::init);, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, + Runnable save = () -> {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, + String msg = NLS.str("message.indexingClassesSkipped", searchIndex.getSkippedCount());, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, + SwingUtilities.invokeLater(new MainWindow(settings)::init);, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, + Runnable save = () -> {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, + String msg = NLS.str("message.indexingClassesSkipped", searchIndex.getSkippedCount());, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxProject.java, +package jadx.gui.settings;, +, +import java.io.BufferedWriter;, +import java.nio.file.Files;, +import java.nio.file.Path;, +import java.util.Arrays;, +import java.util.List;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import com.google.gson.Gson;, +import com.google.gson.GsonBuilder;, +,
[+++ b/.gitignore, +# Eclipse files, +# IntelliJ Idea files, +.idea/, +out/, +*.iml, +]
[+++ b/.travis.yml, + - oraclejdk8]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + return parentGen == null ? this : parentGen;]
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, + .doOnError(e -> LOG.error("Error prepare search: {}", e.getMessage(), e)), +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, + .doOnError(e -> LOG.error("Error prepare search: {}", e.getMessage(), e)), +++ b/jadx-gui/src/main/java/jadx/gui/utils/search/SimpleIndex.java, + private final Object syncData = new Object();, +, + synchronized (syncData) {, + }, + synchronized (syncData) {, + int size = keys.size();, + }, + synchronized (syncData) {, +}]
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumMapAttr.java, +import java.util.HashMap;, +import java.util.Map;, +, +import org.jetbrains.annotations.Nullable;, +, + @Nullable, + private Map<FieldNode, KeyValueMap> fieldsMap;, + @Nullable, + if (fieldsMap == null) {, + return null;, + }, + if (fieldsMap == null) {, + fieldsMap = new HashMap<>();, + }, + public boolean isEmpty() {, + return fieldsMap == null || fieldsMap.isEmpty();, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/nodes/EnumMapAttr.java, +import java.util.HashMap;, +import java.util.Map;, +, +import org.jetbrains.annotations.Nullable;, +, + @Nullable, + private Map<FieldNode, KeyValueMap> fieldsMap;, + @Nullable, + if (fieldsMap == null) {, + return null;, + }, + if (fieldsMap == null) {, + fieldsMap = new HashMap<>();,
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +import org.jetbrains.annotations.Nullable;, + @Nullable, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +import org.jetbrains.annotations.Nullable;, + @Nullable, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, + if (c == null) {, + throw new JadxRuntimeException("Switch block not found by offset: " + entry.getKey());, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +import org.jetbrains.annotations.Nullable;, + @Nullable, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, + if (c == null) {, + throw new JadxRuntimeException("Switch block not found by offset: " + entry.getKey());, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ReturnVisitor.java, +import jadx.core.dex.regions.SwitchRegion;, +, + @Override, + public boolean enterRegion(MethodNode mth, IRegion region) {, + super.enterRegion(mth, region);, + return !(region instanceof SwitchRegion);, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, +import org.jetbrains.annotations.Nullable;, + @Nullable, +++
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, + private static final Logger LOG = LoggerFactory.getLogger(ClassGen.class);, +, + if (mth.getAttributes().contains(AttributeFlag.INCONSISTENT_CODE)) {, + code.startLine("/* JADX WARNING: inconsistent code */");, + LOG.error(ErrorsCounter.formatErrorMsg(mth, " Inconsistent code"));, + mthGen.makeMethodDump(code);, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, + private static final Logger LOG = LoggerFactory.getLogger(ClassGen.class);, +, + if (mth.getAttributes().contains(AttributeFlag.INCONSISTENT_CODE)) {, + code.startLine("/* JADX WARNING: inconsistent code */");, + LOG.error(ErrorsCounter.formatErrorMsg(mth, " Inconsistent code"));, + mthGen.makeMethodDump(code);, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + makeMethodDump(code);, + public void makeMethodDump(CodeWriter code) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, + private static final Logger LOG = LoggerFactory.getLogger(ClassGen.class);, +, +
[+++ b/README.md, + -e, --export-gradle - save as android gradle project, +++ b/README.md, + -e, --export-gradle - save as android gradle project, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"-e", "--export-gradle"}, description = "save as android gradle project"), + protected boolean exportAsGradleProject = false;, +, +, + @Override, + public boolean isExportAsGradleProject() {, + return exportAsGradleProject;, + }, +++ b/README.md, + -e, --export-gradle - save as android gradle project, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"-e", "--export-gradle"}, description = "save as android gradle project"), + protected boolean exportAsGradleProject = false;, +, +, + @Override, + public boolean isExportAsGradleProject() {, + return exportAsGradleProject;,
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import java.io.File;, +import java.util.ArrayList;, +import java.util.List;, +, +import jadx.api.JadxArgs;, +import jadx.core.utils.files.FileUtils;, + JadxArgs args = inputArgs.toJadxArgs();, + args.setFsCaseSensitive(getFsCaseSensitivity(args));, + JadxDecompiler jadx = new JadxDecompiler(args);, +, + private static boolean getFsCaseSensitivity(JadxArgs args) {, + List<File> testDirList = new ArrayList<>(3);, + testDirList.add(args.getOutDir());, + testDirList.add(args.getOutDirSrc());, + if (!args.getInputFiles().isEmpty()) {, + testDirList.add(args.getInputFiles().get(0));, + }, + return FileUtils.isCaseSensitiveFS(testDirList);, + }, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import java.io.File;, +import java.util.ArrayList;, +import java.util.List;, +, +import jadx.api.JadxArgs;, +import jadx.core.utils.files.FileUtils;, + JadxArgs args = inputArgs.toJadxArgs();, + args.setFsCaseSensitive(getFsCaseSensitivity(args));, + JadxDecompiler jadx = new JadxDecompiler(args);, +, + private static boolean getFsCaseSensitivity(JadxArgs args) {, + List<File> testDirList = new ArrayList<>(3);, + testDirList.add(args.getOutDir());,
[+++ b/.DS_Store, +++ b/.DS_Store, +++ b/README.md, +, +++ b/.DS_Store, +++ b/README.md, +, +++ b/jadx-core/build.gradle, + compile files('lib/dx-1.10.jar'), +++ b/.DS_Store, +++ b/README.md, +, +++ b/jadx-core/build.gradle, + compile files('lib/dx-1.10.jar'), +++ b/jadx-core/lib/dx-1.10.jar, +++ b/.DS_Store, +++ b/README.md, +, +++ b/jadx-core/build.gradle, + compile files('lib/dx-1.10.jar'), +++ b/jadx-core/lib/dx-1.10.jar, +++ /dev/null, +++ b/.DS_Store, +++ b/README.md, +, +++ b/jadx-core/build.gradle, + compile files('lib/dx-1.10.jar'), +++ b/jadx-core/lib/dx-1.10.jar, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +import java.util.ArrayList;, +import java.util.Enumeration;, +import java.util.List;, +import java.util.zip.ZipEntry;, +import java.util.zip.ZipFile;, +, + public static String bytesToHex(byte[] bytes) {, + char[] hexArray = "0123456789abcdef".toCharArray();, + if (bytes == null || bytes.length <= 0) {, + return null;, + }, + char[]
[+++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, + if (!(obj instanceof MethodInfo)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, + if (!(obj instanceof MethodInfo)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import java.util.HashMap;, + // cache maps, + private Map<MethodInfo, MethodNode> mthInfoMap = Collections.emptyMap();, +, + buildCache();, + private void buildCache() {, + mthInfoMap = new HashMap<MethodInfo, MethodNode>(methods.size());, + for (MethodNode mth : methods) {, + mthInfoMap.put(mth.getMethodInfo(), mth);, + }, + }, +, + return mthInfoMap.get(mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, + if (!(obj instanceof MethodInfo)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import java.util.HashMap;, + // cache maps, + private Map<MethodInfo, MethodNode> mthInfoMap = Collections.emptyMap();, +, + buildCache();, + private void buildCache() {, + mthInfoMap = new HashMap<MethodInfo,
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, + InsnNode firstNode = chain.get(0);, + if (firstNode instanceof ConstStringNode) {, + ConstStringNode csn = (ConstStringNode) firstNode;, + } else {, + return null;, + }]
[+++ b/jadx-gui/src/main/resources/i18n/Messages_zh_CN.properties, +menu.preferences=首选项, +menu.sync=与编辑器同步, +menu.heapUsageBar=显示内存使用栏, +menu.update_label=发现新版本 %s！, +file.open_action=打开文件..., +search.previous=上一个, +search.find=查找, +message.indexingClassesSkipped=<html>Jadx 的内存不足。因此，%d 类没有编入索引。<br>如果要将所有类编入索引，请使用增加的最大堆大小重新启动 Jadx。</html>, +, +heapUsage.text=JADX 内存使用率：%.2f GB 共 %.2f GB, +, +preferences.title=首选项, +preferences.editor=编辑器, +preferences.language=语言, +preferences.check_for_updates=启动时检查更新, +preferences.respectBytecodeAccessModifiers=遵守字节码访问修饰符, +preferences.useImports=使用 import 语句, +preferences.excludedPackages=排除的包, +preferences.excludedPackages.tooltip=将不被解压缩或索引的以空格分隔的包名称列表（节省 RAM）, +preferences.excludedPackages.button=编辑, +preferences.excludedPackages.editDialog=<html>将不被解压或索引的以空格分隔的包名称列表（节省 RAM）<br>例如<code>android.support</html>, +preferences.select_font=更改, +popup.find_usage=查找用例, +certificate.serialPubKeyModulusSize=模数大小（位）, +, +apkSignature.signer=签名人, +apkSignature.verificationSuccess=签名验证成功, +apkSignature.verificationFailed=签名验证成功, +apkSignature.signatureSuccess=找到有效的 APK 签名 v%d, +apkSignature.signatureFailed=找到无效的 APK 签名 v%d, +apkSignature.errors=错误, +apkSignature.warnings=警告, +apkSignature.exception=APK 验证失败, +apkSignature.unprotectedEntry=不受签名保护的文件。不会检测对此 JAR 条目的未经授权的修改。]
[+++ b/jadx-core/build.gradle, + testCompile 'org.smali:smali:2.2.2', + testCompile 'org.smali:baksmali:2.2.2', +++ b/jadx-core/build.gradle, + testCompile 'org.smali:smali:2.2.2', + testCompile 'org.smali:baksmali:2.2.2', +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + case NEG:, + oneArgInsn(code, insn, state, '-');, +, + case NOT:, + oneArgInsn(code, insn, state, '~');, + break;, + private void oneArgInsn(CodeWriter code, InsnNode insn, Set<Flags> state, char op) throws CodegenException {, + boolean wrap = state.contains(Flags.BODY_ONLY);, + if (wrap) {, + code.add('(');, + }, + code.add(op);, + addArg(code, insn.getArg(0));, + if (wrap) {, + code.add(')');, + }, + }, +, +++ b/jadx-core/build.gradle, + testCompile 'org.smali:smali:2.2.2', + testCompile 'org.smali:baksmali:2.2.2', +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + case NEG:, + oneArgInsn(code, insn, state, '-');, +,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, + return Short.toString(s);, + return Byte.toString(b);, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, + return Short.toString(s);, + return Byte.toString(b);, +++ b/jadx-core/src/test/java/jadx/tests/integration/arrays/TestRedundantType.java, +package jadx.tests.integration.arrays;, +, +import static org.junit.jupiter.api.Assertions.assertEquals;, +, +import org.junit.jupiter.api.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.MatcherAssert.assertThat;, +, +public class TestRedundantType extends IntegrationTest {, +, + public static class TestCls {, +, + public byte[] method() {, + return new byte[]{10, 11, 12};, + }, + }, +, + @Test, + public void test() {, + ClassNode cls = getClassNode(TestCls.class);, + String code = cls.getCode().toString();, +, + assertThat(code, containsString("return new byte[]{10, 11, 12};"));, + }, +, +
[+++ b/build.gradle, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"-x", "--xml"}, description = "try to decode the AndroidManifest.xml"), +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"-x", "--xml"}, description = "try to decode the AndroidManifest.xml"), +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + byte[] buffer = InputFile.loadXMLBuffer(inf.getFile());, + if (buffer != null) {, + File out = new File(args.getOutDir(), "AndroidManifest.xml");, + BinaryXMLParser bxp = new BinaryXMLParser();, + bxp.parse(buffer, out);, + }, + } catch (Exception e) {, + LOG.info("Decompiling AndroidManifest.xml failed!", e);, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"-x", "--xml"}, description = "try to
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/CertificatePanel.java, +import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;, +, +public final class CertificatePanel extends ContentPanel {, + private static final long serialVersionUID = 8566591625905036877L;, +, + private final RSyntaxTextArea textArea;, +, + textArea = new RSyntaxTextArea(jnode.getContent());, + loadSettings();, + CodeArea.loadCommonSettings(getTabbedPane().getMainWindow(), textArea);]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, + String name = arg.getName();, + if (name == null) {, + return getFallbackName(arg);, + }, + return getFallbackName(arg);, + String name = arg.getName();, + private String getFallbackName(RegisterArg arg) {, + String name = arg.getName();, + String base = "r" + arg.getRegNum();, + if (name != null && !name.equals("this")) {, + return base + "_" + name;, + }, + return base;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, + String name = arg.getName();, + if (name == null) {, + return getFallbackName(arg);, + }, + return getFallbackName(arg);, + String name = arg.getName();, + private String getFallbackName(RegisterArg arg) {,
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + passes.add(new CodeShrinker());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + passes.add(new CodeShrinker());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, + addArg(code, cont.getEnterInsn().getArg(0));, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + passes.add(new CodeShrinker());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, + addArg(code, cont.getEnterInsn().getArg(0));, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, + if (parent == null) {, + return null;, + }, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + passes.add(new CodeShrinker());, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, + addArg(code, cont.getEnterInsn().getArg(0));, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, + if (parent == null) {, + return null;, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/TypedVar.java, +import java.util.Iterator;, + public List<InsnArg> getUseList() {, + return useList;, + }, +, + public void removeUse(InsnArg arg) {, + Iterator<InsnArg> it = useList.iterator();, + while (it.hasNext()) {, + InsnArg use = it.next();, + if (use
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + loop.getEnd().add(AFlag.SKIP);, + loop.getEnd().remove(AFlag.SKIP);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + loop.getEnd().add(AFlag.SKIP);, + loop.getEnd().remove(AFlag.SKIP);, +++ b/jadx-core/src/test/java/jadx/tests/internal/loops/TestLoopConditionInvoke.java, +package jadx.tests.internal.loops;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import static jadx.tests.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestLoopConditionInvoke extends InternalJadxTest {, +, + public static class TestCls {, + private static final char STOP_CHAR = 0;, + private int pos;, +, + private boolean test(char lastChar) {, + int startPos = pos;, + char ch;, + while ((ch = next()) != STOP_CHAR) {, + if (ch == lastChar) {, + return true;, + }, + }, + pos = startPos;, + return
[+++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/core/deobf/NameMapperTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/core/deobf/NameMapperTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/core/dex/info/AccessInfoTest.java, +import static org.junit.jupiter.api.Assertions.assertSame;, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/api/JadxArgsValidatorOutDirsTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/core/deobf/NameMapperTest.java, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/core/dex/info/AccessInfoTest.java, +import static org.junit.jupiter.api.Assertions.assertSame;, +import static org.hamcrest.MatcherAssert.assertThat;, +++ b/jadx-core/src/test/java/jadx/tests/TestsTest.java, +package jadx.tests;, +, +import static org.junit.jupiter.api.Assertions.assertTrue;, +import static org.junit.jupiter.api.Assertions.fail;, +, +import java.io.File;, +import java.io.IOException;, +import java.nio.file.Files;, +import java.nio.file.Path;, +import java.nio.file.Paths;, +import
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.api.JadxDecompiler;, + JadxDecompiler jadx = new JadxDecompiler(jadxArgs);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.api.JadxDecompiler;, + JadxDecompiler jadx = new JadxDecompiler(jadxArgs);, +++ /dev/null, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.api.JadxDecompiler;, + JadxDecompiler jadx = new JadxDecompiler(jadxArgs);, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +package jadx.api;, +, +import jadx.core.Jadx;, +import jadx.core.ProcessClass;, +import jadx.core.dex.info.ClassInfo;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.RootNode;, +import jadx.core.dex.visitors.IDexTreeVisitor;, +import jadx.core.dex.visitors.SaveCode;, +import jadx.core.utils.ErrorsCounter;, +import jadx.core.utils.exceptions.DecodeException;, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.utils.exceptions.JadxRuntimeException;, +import jadx.core.utils.files.InputFile;, +, +import java.io.File;, +import java.io.IOException;, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.Comparator;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.Executors;, +import java.util.concurrent.TimeUnit;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +/**, + * Jadx API usage example:,
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/CodeVar.java, + private ArgType type; // nullable before type inference, set only for immutable types, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/CodeVar.java, + private ArgType type; // nullable before type inference, set only for immutable types, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, + if (codeVar.getType() != null && !typeInfo.getType().equals(codeVar.getType())) {, + throw new JadxRuntimeException("Unmached types for SSA and Code variables: " + this + " and " + codeVar);, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/CodeVar.java, + private ArgType type; // nullable before type inference, set only for immutable types, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, + if (codeVar.getType() != null && !typeInfo.getType().equals(codeVar.getType())) {, + throw new JadxRuntimeException("Unmached types for SSA and Code variables:
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + private List<ExceptionHandler> exceptionHandlers = Collections.emptyList();, + if (exceptionHandlers.isEmpty()) {, + return Collections.unmodifiableList(exceptionHandlers);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + private List<ExceptionHandler> exceptionHandlers = Collections.emptyList();, + if (exceptionHandlers.isEmpty()) {, + return Collections.unmodifiableList(exceptionHandlers);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DotGraphVisitor.java, +import jadx.core.dex.instructions.IfNode;, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.utils.RegionUtils;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Set;, + private CodeWriter dot;, + private CodeWriter conn;, +, + dot = new CodeWriter();, + conn = new CodeWriter();, + dot.startLine("digraph \"CFG for");, + dot.add(escape(mth.getParentClass().getFullName() + "." + mth.getMethodInfo().getShortId()));, + dot.add("\" {");, + processMethodRegion(mth);, + processBlock(mth, block);, + dot.startLine("MethodNode[shape=record,label=\"{");, + dot.add(escape(mth.getAccessFlags().makeString()));, + dot.add(escape(mth.getReturnType() + " ", + + mth.getParentClass().getFullName() + "." + mth.getName(), + +
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java, +import jadx.core.dex.instructions.ArithNode;, +import jadx.core.dex.instructions.ArithOp;, + IfCondition i = simplifyCmpOp(c);, + if (i != null) {, + return i;, + }, + private static IfCondition simplifyCmpOp(Compare c) {, + return null;, + if (!c.getB().isLiteral()) {, + return null;, + long lit = ((LiteralArg) c.getB()).getLiteral();, + if (lit != 0 && lit != 1) {, + return null;, + }, +, + switch (wrapInsn.getType()) {, + case CMP_L:, + case CMP_G:, + if (lit == 0) {, + break;, +, + case ARITH:, + ArithOp arithOp = ((ArithNode) wrapInsn).getOp();, + if (arithOp == ArithOp.OR || arithOp == ArithOp.AND) {,
[+++ b/jadx-core/src/main/java/jadx/core/utils/ImmutableList.java, +import java.util.NoSuchElementException;, + @SuppressWarnings({"unchecked", "SuspiciousArrayCast"}), + public ImmutableList(Collection<E> col) {, + this((E[]) Objects.requireNonNull(col).toArray());, + }, +, + public ImmutableList(E[] arr) {, + this.arr = Objects.requireNonNull(arr);, + try {, + } catch (IndexOutOfBoundsException e) {, + throw new NoSuchElementException(e.getMessage());, + }, + return Arrays.copyOf(arr, arr.length);, + return (T[]) Arrays.copyOf(arr, arr.length);, +++ b/jadx-core/src/main/java/jadx/core/utils/ImmutableList.java, +import java.util.NoSuchElementException;, + @SuppressWarnings({"unchecked", "SuspiciousArrayCast"}), + public ImmutableList(Collection<E> col) {, + this((E[]) Objects.requireNonNull(col).toArray());, + }, +, + public ImmutableList(E[] arr) {, + this.arr = Objects.requireNonNull(arr);, + try {, + } catch (IndexOutOfBoundsException e) {, + throw new NoSuchElementException(e.getMessage());, + }, + return Arrays.copyOf(arr, arr.length);, + return
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, + if (domFrontier == null) {, + throw new JadxRuntimeException("Dominance frontier not set for block: " + this);, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, + if (domFrontier == null) {, + throw new JadxRuntimeException("Dominance frontier not set for block: " + this);, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinallyExtract.java, +import java.util.stream.Collectors;, + int removeApplied = 0;, + if (applyRemove(mth, removeInfo)) {, + removeApplied++;, + removeInfo.setApplied(true);, + }, + }, + if (removeApplied == 0) {, + if (removeApplied != removes.size()) {, + throw new JadxRuntimeException("Some finally instructions failed to remove: ", + + removes.stream().filter(n -> !n.isApplied()).map(BlocksRemoveInfo::toString).collect(Collectors.joining(",")), + );,
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, + private String nsURI="ERROR";, + private String currentTag="ERROR";, + private boolean wasOneLiner=false;, + nsURI=strings[beginURI];, + nsURI=strings[endURI];, + int elementBegLineNumber = cInt32(bytes, count);, + //System.out.println("ELEMENT BEG Line: " + elementBegLineNumber + " of " + strings[startNSName]);, + int startNSName = cInt32(bytes, count); // actually is elementName..., + if(!wasOneLiner && !"ERROR".equals(currentTag) && !currentTag.equals(strings[startNSName])) {, + writer.println(">");, + }, + wasOneLiner=false;, + currentTag=strings[startNSName];, + if("manifest".equals(strings[startNSName])) writer.print(" xmlns:\""+nsURI+"\"");, +/*(, + //writer.print(strings[attributeName] + "=\"");, + } else if(attrValDataType==0x1) writer.print(strings[attributeName] + "=\"0x" + Integer.toHexString(attrValData) + "\"");, + if((i+1)<attributeCount) writer.print(" ");, + //writer.println(">");, + //System.out.println("ELEMENT BEG Line: " + elementBegLineNumber + " of "
[+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + // don't add 'abstract' and 'public' to methods in interface, + ai = ai.remove(AccessFlags.ACC_PUBLIC);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + // don't add 'abstract' and 'public' to methods in interface, + ai = ai.remove(AccessFlags.ACC_PUBLIC);, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, + if (tryCatchBlock.getFinalRegion() != null) {, + makeRegionIndent(code, tryCatchBlock.getFinalRegion());, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + // don't add 'abstract' and 'public' to methods in interface, + ai = ai.remove(AccessFlags.ACC_PUBLIC);, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, + if (tryCatchBlock.getFinalRegion() != null) {, + makeRegionIndent(code, tryCatchBlock.getFinalRegion());, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + if (ct1 != ct2 && ct2.containsAllHandlers(ct1)) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + // don't add 'abstract' and 'public' to methods in interface, + ai =
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, + passes.add(new DebugInfoParseVisitor());, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new ConstructorVisitor());, + passes.add(new TypeInferenceVisitor());, + passes.add(new DebugInfoApplyVisitor());, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, + passes.add(new DebugInfoParseVisitor());, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, +
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, + JMenuItem excludeItem = new JCheckBoxMenuItem(NLS.str("popup.exclude"));, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, + JMenuItem excludeItem = new JCheckBoxMenuItem(NLS.str("popup.exclude"));, +++ b/jadx-gui/src/main/resources/i18n/Messages_en_US.properties, +popup.exclude=Exclude, +, +apkSignature.verificationFailed=Signature verification failed, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, + JMenuItem excludeItem = new JCheckBoxMenuItem(NLS.str("popup.exclude"));, +++ b/jadx-gui/src/main/resources/i18n/Messages_en_US.properties, +popup.exclude=Exclude, +, +apkSignature.verificationFailed=Signature verification failed, +++ b/jadx-gui/src/main/resources/i18n/Messages_es_ES.properties, +#menu.heapUsageBar=, +#message.indexingClassesSkipped=, +, +#heapUsage.text=, +, +#preferences.respectBytecodeAccessModifiers=, +#preferences.useImports=, +#preferences.excludedPackages=, +#preferences.excludedPackages.tooltip=, +#preferences.excludedPackages.button=, +#preferences.excludedPackages.editDialog=, +#popup.find_usage=, +#popup.exclude=, +#certificate.serialPubKeyModulusSize=, +, +#apkSignature.signer=, +#apkSignature.verificationSuccess=, +#apkSignature.verificationFailed=, +#apkSignature.signatureSuccess=, +#apkSignature.signatureFailed=, +#apkSignature.errors=, +#apkSignature.warnings=, +#apkSignature.exception=, +#apkSignature.unprotectedEntry=, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, + JMenuItem excludeItem = new JCheckBoxMenuItem(NLS.str("popup.exclude"));, +++ b/jadx-gui/src/main/resources/i18n/Messages_en_US.properties, +popup.exclude=Exclude, +, +apkSignature.verificationFailed=Signature verification failed, +++ b/jadx-gui/src/main/resources/i18n/Messages_es_ES.properties, +#menu.heapUsageBar=, +#message.indexingClassesSkipped=, +, +#heapUsage.text=, +, +#preferences.respectBytecodeAccessModifiers=, +#preferences.useImports=, +#preferences.excludedPackages=, +#preferences.excludedPackages.tooltip=, +#preferences.excludedPackages.button=, +#preferences.excludedPackages.editDialog=, +#popup.find_usage=, +#popup.exclude=, +#certificate.serialPubKeyModulusSize=, +, +#apkSignature.signer=, +#apkSignature.verificationSuccess=, +#apkSignature.verificationFailed=,
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, + if (i != 0 && modInsn.contains(AFlag.ARITH_ONEARG)) {, +, + InsnNode mergedNode = simplifyOneArgConsecutive(, + list.get(i - 1), list.get(i), (ArithNode) modInsn);, +, + if (mergedNode != null) {, + list.remove(i - 1);, + modInsn = mergedNode;, + i--;, + }, + }, + private static InsnNode simplifyOneArgConsecutive(InsnNode insn1, InsnNode insn2, ArithNode modInsn) {, + if (insn1.getType() == InsnType.IGET, + && insn2.getType() == InsnType.IPUT, + && insn1.getResult().getSVar().getUseCount() == 2, + && insn2.getArg(1).equals(insn1.getResult())) {, +, + FieldInfo field = (FieldInfo) ((IndexInsnNode) insn2).getIndex();, + FieldArg fArg = new FieldArg(field, new InsnWrapArg(insn1));, + return new ArithNode(modInsn.getOp(), fArg, modInsn.getArg(1));, + }, +
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + code.add("if (");, + code.add(arg(insn.getArg(0))).add(' ');, + code.add(ifInsn.getOp().getSymbol()).add(' ');, + code.add(arg(insn.getArg(1)));, + code.add(") goto ").add(MethodGen.getLabelName(ifInsn.getTarget()));, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + code.add("if (");, + code.add(arg(insn.getArg(0))).add(' ');, + code.add(ifInsn.getOp().getSymbol()).add(' ');, + code.add(arg(insn.getArg(1)));, + code.add(") goto ").add(MethodGen.getLabelName(ifInsn.getTarget()));, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, + this(InsnType.GOTO, target, 0);, + protected GotoNode(InsnType type, int target, int argsCount) {, + super(type, argsCount);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + code.add("if (");, + code.add(arg(insn.getArg(0))).add(' ');, + code.add(ifInsn.getOp().getSymbol()).add(' ');, + code.add(arg(insn.getArg(1)));, + code.add(") goto ").add(MethodGen.getLabelName(ifInsn.getTarget()));, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/GotoNode.java, + this(InsnType.GOTO, target, 0);, + protected GotoNode(InsnType type, int target, int argsCount) {, + super(type, argsCount);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/IfNode.java, + private static final ArgType ARG_TYPE = ArgType.unknown(, + PrimitiveType.INT,
[+++ b/.travis.yml, + - TERM=dumb ./gradlew clean build dist, + - TERM=dumb ./gradlew jacocoTestReport coveralls, +++ b/.travis.yml, + - TERM=dumb ./gradlew clean build dist, + - TERM=dumb ./gradlew jacocoTestReport coveralls, +++ b/build.gradle, + classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:0.6.1', + gradleVersion = '2.0', +++ b/.travis.yml, + - TERM=dumb ./gradlew clean build dist, + - TERM=dumb ./gradlew jacocoTestReport coveralls, +++ b/build.gradle, + classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:0.6.1', + gradleVersion = '2.0', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/.travis.yml, + - TERM=dumb ./gradlew clean build dist, + - TERM=dumb ./gradlew jacocoTestReport coveralls, +++ b/build.gradle, + classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:0.6.1', + gradleVersion = '2.0', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.0-bin.zip, +++ b/.travis.yml, + - TERM=dumb
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + if (badCode && showInconsistentCode) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + if (badCode && showInconsistentCode) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + } catch (Exception th) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + if (badCode && showInconsistentCode) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + } catch (Exception th) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + if (badCode && showInconsistentCode) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + } catch (Exception th) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +, + private AType() {, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + if (badCode && showInconsistentCode) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + } catch (Exception th) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, +, + private AType() {, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, + private static final int CURRENT_SETTINGS_VERSION = 5;, + public void setUseImports(boolean useImports) {, + this.useImports = useImports;, + }, +, + fromVersion++;, + }, + if (fromVersion == 4) {, + setUseImports(true);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, + private static final int CURRENT_SETTINGS_VERSION = 5;, + public void setUseImports(boolean useImports) {, + this.useImports = useImports;, + }, +, + fromVersion++;, + }, + if (fromVersion == 4) {, + setUseImports(true);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettingsWindow.java, + JCheckBox useImports = new JCheckBox();, + useImports.setSelected(settings.isUseImports());, + useImports.addItemListener(e -> {, + settings.setUseImports(e.getStateChange() == ItemEvent.SELECTED);, + needReload();, + });, +, + other.addRow(NLS.str("preferences.useImports"), useImports);, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +
[+++ b/NOTICE, +RSyntaxTextArea library (https://github.com/bobbylight/RSyntaxTextArea), +licensed under modified BSD license:, +Concurrent Trees (https://code.google.com/p/concurrent-trees/), +licenced under Apache License 2.0:, +, +*******************************************************************************, +Licensed under the Apache License, Version 2.0 (the "License");, +you may not use this file except in compliance with the License., +You may obtain a copy of the License at, +, + http://www.apache.org/licenses/LICENSE-2.0, +, +Unless required by applicable law or agreed to in writing, software, +distributed under the License is distributed on an "AS IS" BASIS,, +WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., +See the License for the specific language governing permissions and, +limitations under
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + InputFile.addFilesFrom(file, inputFiles);, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + InputFile.addFilesFrom(file, inputFiles);, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, + CODE(".dex", ".jar", ".class"),, + XML(".xml"),, + ARSC(".arsc"),, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + InputFile.addFilesFrom(file, inputFiles);, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, + CODE(".dex", ".jar", ".class"),, + XML(".xml"),, + ARSC(".arsc"),, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, + return loadContent(jadxRef, rf, is, size);, + InputStream inputStream, long size) throws IOException {, + if (size > LOAD_SIZE_LIMIT) {, + return ResContainer.singleFile(rf.getName(),, + new CodeWriter().add("File too big, size: " + String.format("%.2f KB", size / 1024.)));, + }, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + InputFile.addFilesFrom(file, inputFiles);, +++ b/jadx-core/src/main/java/jadx/api/ResourceType.java, + CODE(".dex", ".jar", ".class"),, + XML(".xml"),, + ARSC(".arsc"),, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, + return loadContent(jadxRef, rf, is, size);, +
[+++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, + if (excludedPackages.length() == 0) {, + }, + if (cls.getFullName().startsWith(exclude)) {, + }, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, + if (excludedPackages.length() == 0) {, + }, + if (cls.getFullName().startsWith(exclude)) {, + }, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +import jadx.gui.utils.NLS;, + SwingUtilities.invokeLater(() -> progressPane.setVisible(true));, + protected Void doInBackground() {, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, + if (excludedPackages.length() == 0) {, + }, + if (cls.getFullName().startsWith(exclude)) {, + }, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +import jadx.gui.utils.NLS;, + SwingUtilities.invokeLater(() -> progressPane.setVisible(true));, + protected Void doInBackground() {, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/DecompileJob.java, + addTask(cls::decompile);, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, + if (excludedPackages.length() == 0) {, + }, + if (cls.getFullName().startsWith(exclude)) {, + }, +++ b/jadx-gui/src/main/java/jadx/gui/jobs/BackgroundWorker.java, +import jadx.gui.utils.NLS;, +
[+++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import org.jetbrains.annotations.Nullable;, + private static final int CURRENT_SETTINGS_VERSION = 7;, + private static final Font DEFAULT_FONT = new RSyntaxTextArea().getFont();, + public void setFont(@Nullable Font font) {, + if (font == null) {, + this.fontStr = "";, + return;, + }, + fromVersion++;, + }, + if (fromVersion == 6) {, + if (getFont().getFontName().equals("Hack Regular")) {, + setFont(null);, + }, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import org.jetbrains.annotations.Nullable;, + private static final int CURRENT_SETTINGS_VERSION = 7;, + private static final Font DEFAULT_FONT = new RSyntaxTextArea().getFont();, + public void setFont(@Nullable Font font) {, + if (font == null) {, + this.fontStr = "";,
[+++ b/.travis.yml, +install: true, +jdk:, + - openjdk8, + - oraclejdk8, + - openjdk11, +, +script: ./gradlew clean build, +, +jobs:, + - stage: deploy-unstable, + jdk: openjdk8, + if: branch = master AND env(BINTRAY_USER) IS present, + - stage: deploy-release, + jdk: openjdk8, + if: branch = release AND env(GH_TOKEN) IS present, +++ b/.travis.yml, +install: true, +jdk:, + - openjdk8, + - oraclejdk8, + - openjdk11, +, +script: ./gradlew clean build, +, +jobs:, + - stage: deploy-unstable, + jdk: openjdk8, + if: branch = master AND env(BINTRAY_USER) IS present, + - stage: deploy-release, + jdk: openjdk8, + if:
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + FieldNode fieldNode = pCls.dex().root().deepResolveField(field);, + if (fieldNode == null) {, + } else {, + code.add(fieldNode.getAlias());, + }, + FieldNode fieldNode = clsGen.getClassNode().dex().root().deepResolveField(field);, + if (fieldNode == null) {, + } else {, + code.add(fieldNode.getAlias());, + }, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + FieldNode fieldNode = pCls.dex().root().deepResolveField(field);, + if (fieldNode == null) {, + } else {, + code.add(fieldNode.getAlias());, + }, + FieldNode fieldNode = clsGen.getClassNode().dex().root().deepResolveField(field);, + if (fieldNode == null) {, + } else {, + code.add(fieldNode.getAlias());, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, +import com.android.dex.ClassData;, +import com.android.dex.FieldId;, +import
[+++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, + if (Math.abs(lit) > 100) {, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, + if (Math.abs(lit) > 100) {, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, + public static final ArgType NARROW_NUMBERS = unknown(, + PrimitiveType.INT, PrimitiveType.FLOAT,, + PrimitiveType.BOOLEAN, PrimitiveType.SHORT, PrimitiveType.BYTE, PrimitiveType.CHAR);, +, + if (type == PrimitiveType.LONG || type == PrimitiveType.DOUBLE) {, + } else {, + return 1;, + }, + }, + if (!isTypeKnown()) {, + return 0;, +++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, + if (Math.abs(lit) > 100) {, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, + public static final ArgType NARROW_NUMBERS = unknown(, + PrimitiveType.INT, PrimitiveType.FLOAT,, + PrimitiveType.BOOLEAN, PrimitiveType.SHORT, PrimitiveType.BYTE, PrimitiveType.CHAR);, +, + if (type
[+++ b/jadx-gui/build.gradle, + compile 'com.googlecode.concurrent-trees:concurrent-trees:2.4.0', +++ b/jadx-gui/build.gradle, + compile 'com.googlecode.concurrent-trees:concurrent-trees:2.4.0', +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/CodeNode.java, +package jadx.gui.treemodel;, +, +import jadx.api.JavaClass;, +import jadx.gui.utils.Utils;, +, +import javax.swing.Icon;, +import javax.swing.ImageIcon;, +, +public class CodeNode extends JClass {, +, + private static final ImageIcon ICON = Utils.openIcon("file_obj");, +, + private final String line;, + private final int lineNum;, +, + public CodeNode(JavaClass javaClass, int lineNum, String line) {, + super(javaClass, (JClass) makeFrom(javaClass.getDeclaringClass()));, + this.line = line;, + this.lineNum = lineNum;, + }, +, + @Override, + public Icon getIcon() {, + return ICON;, + }, +, + @Override, + public int getLine() {, + return lineNum;,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +, + if(f.getFieldInfo().isRenamed()) {, + code.startLine("/* renamed from: ").add(f.getName()).add(" */");, + }, + if (classInfo.isRenamed()) {, + code.startLine("/* renamed from: ").add(classInfo.getType().getObject()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +, + if(f.getFieldInfo().isRenamed()) {, + code.startLine("/* renamed from: ").add(f.getName()).add(" */");, + }, + if (classInfo.isRenamed()) {, + code.startLine("/* renamed from: ").add(classInfo.getType().getObject()).add(" */");, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +, + if(mth.getMethodInfo().isRenamed()) {, + code.startLine("/* renamed from: ").add(mth.getName()).add(" */");, + }]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new DebugInfoVisitor());, + passes.add(new TypeInference());, +, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new FinishTypeInference());, +, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new DebugInfoVisitor());, + passes.add(new TypeInference());, +, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, + private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new DebugInfoVisitor());,
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayNode.java, +import jadx.core.dex.nodes.DexNode;, + public void mergeElementType(DexNode dex, ArgType foundElemType) {, + ArgType r = ArgType.merge(dex, elemType, foundElemType);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/FillArrayNode.java, +import jadx.core.dex.nodes.DexNode;, + public void mergeElementType(DexNode dex, ArgType foundElemType) {, + ArgType r = ArgType.merge(dex, elemType, foundElemType);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/ArgType.java, +import jadx.core.dex.nodes.DexNode;, + public static ArgType merge(@Nullable DexNode dex, ArgType a, ArgType b) {, + ArgType res = mergeInternal(dex, a, b);, + res = mergeInternal(dex, b, a); // swap, + private static ArgType mergeInternal(@Nullable DexNode dex, ArgType a, ArgType b) {, + return mergeArrays(dex, (ArrayArg) a, b);, + return mergeArrays(dex, (ArrayArg) b, a);, + if (dex == null) {,
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java, +import java.util.*;, + public static final int RESULTS_PER_PAGE = 100;, + protected JLabel resultsInfoLabel;, + protected synchronized void performSearch() {, + resultsTable.updateTable();, + updateProgressLabel();, + }, +, + resultsModel.addTableModelListener((e) -> updateProgressLabel());, + resultsTable.setDefaultRenderer(Object.class, renderer);, +, + JPanel paginationPanel = new JPanel();, + paginationPanel.setAlignmentX( Component.LEFT_ALIGNMENT );, + paginationPanel.setLayout(new BoxLayout(paginationPanel, BoxLayout.X_AXIS));, + resultsInfoLabel = new JLabel("");, +, + JButton nextPageButton = new JButton("->");, + nextPageButton.setToolTipText(NLS.str("search_dialog.next_page"));, + nextPageButton.addActionListener((e) -> {, + resultsModel.nextPage();, + resultsTable.updateTable();, + resultsTable.scrollRectToVisible(new Rectangle(0,0,1,1));, + });, +, + JButton prevPageButton = new JButton("<-");, + prevPageButton.setToolTipText(NLS.str("search_dialog.prev_page"));, + prevPageButton.addActionListener((e) -> {, + resultsModel.prevPage();, + resultsTable.updateTable();, + resultsTable.scrollRectToVisible(new Rectangle(0,0,1,1));, +
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + case ONE_ARG:, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + case ONE_ARG:, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnType.java, + // *** Additional instructions ***, +, + // replacement for removed instructions, + NOP,, +, + TERNARY,, +, + // strings concatenation, + STR_CONCAT,, + // just generate one argument, + ONE_ARG,, + // TODO: now multidimensional arrays created using Array.newInstance function, + NEW_MULTIDIM_ARRAY, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + case ONE_ARG:, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnType.java, + // *** Additional instructions ***, +, + // replacement for removed instructions, + NOP,, +, + TERNARY,, +, + // strings concatenation, + STR_CONCAT,, + // just generate one argument, + ONE_ARG,, + //
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, + BinaryXMLParser bxp = new BinaryXMLParser(args[0],args[1]);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, + BinaryXMLParser bxp = new BinaryXMLParser(args[0],args[1]);, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +import java.io.PrintWriter;, + PrintWriter writer;, + public BinaryXMLParser(String xmlfilepath, String xmloutfilepath) {, + //System.out.println(xmlfilepath);, + try {, + writer = new PrintWriter(xmloutfilepath,"UTF-8");, + } catch(FileNotFoundException fnfe) { die("FNFE"); }, + catch(UnsupportedEncodingException uee) { die("UEE"); }, + if(null==writer) die("null==writer");, + writer.close();, + //System.out.println("index i["+i+"] string: " + strings[i]);, + //System.out.println("RHeader Size: " + rhsize);, + //System.out.println("i["+i+"] ID: "+ids[i]);, + //System.out.println("Hex: 0x0" + Integer.toHexString(ids[i]) + " should be: " + strings[i]);, + //System.out.println("Prefix: " + strings[beginPrefix]);, + //System.out.println("URI: " + strings[beginURI]);, + //System.out.println("Prefix:
[+++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, + arg.setName(name);, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, + arg.setName(name);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, + public RegisterArg duplicate() {, + RegisterArg dup = new RegisterArg(getRegNum(), getType());, + dup.setSVar(sVar);, + return dup;, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, + arg.setName(name);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, + public RegisterArg duplicate() {, + RegisterArg dup = new RegisterArg(getRegNum(), getType());, + dup.setSVar(sVar);, + return dup;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, +import java.util.ArrayList;, + InsnNode newInstInsn = removeAssignChain(instArgAssignInsn, remover, InsnType.NEW_INSTANCE);, + if (newInstInsn != null) {, + RegisterArg instArg = newInstInsn.getResult();, + RegisterArg resultArg = co.getResult();, + if (!resultArg.equals(instArg)) {, + // replace all usages of 'instArg' with result of this constructor instruction, + for (RegisterArg useArg :
[+++ b/build.gradle, + compileJava {, + options.encoding = "UTF-8", + }, +, +++ b/build.gradle, + compileJava {, + options.encoding = "UTF-8", + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +import java.util.Iterator;, +import java.util.LinkedList;, +import java.util.Queue;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, + ErrorsCounter.methodError(mth, "Unsupported boolean condition " + op.getSymbol());, +, + default:, + return true;, +, +++ b/build.gradle, + compileJava {, + options.encoding = "UTF-8", + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +import java.util.Iterator;, +import java.util.LinkedList;, +import java.util.Queue;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, + ErrorsCounter.methodError(mth, "Unsupported boolean condition " + op.getSymbol());, +, + default:, + return true;, +, +++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, + Arrays.asList(, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, + case MOVE:, + InsnArg firstArg = insn.getArg(0);, + if (firstArg.isLiteral()) {, + InsnNode constInsn = new InsnNode(InsnType.CONST, 1);, + constInsn.setResult(insn.getResult());, + constInsn.addArg(firstArg);, + constInsn.copyAttributesFrom(insn);, + return constInsn;, + }, + break;, +]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DepthTraversal.java, +, + private DepthTraversal() {, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DepthTraversal.java, +, + private DepthTraversal() {, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinallyExtract.java, +import jadx.core.Jadx;, +import jadx.core.dex.attributes.AFlag;, +import jadx.core.dex.attributes.AType;, +import jadx.core.dex.attributes.nodes.IgnoreEdgeAttr;, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.instructions.args.RegisterArg;, +import jadx.core.dex.nodes.BlockNode;, +import jadx.core.dex.nodes.InsnNode;, +import jadx.core.dex.nodes.MethodNode;, +import jadx.core.dex.trycatch.CatchAttr;, +import jadx.core.dex.trycatch.ExceptionHandler;, +import jadx.core.dex.trycatch.SplitterBlockAttr;, +import jadx.core.dex.trycatch.TryCatchBlock;, +import jadx.core.dex.visitors.AbstractVisitor;, +import jadx.core.dex.visitors.DepthTraversal;, +import jadx.core.dex.visitors.IDexTreeVisitor;, +import jadx.core.dex.visitors.blocksmaker.helpers.BlocksPair;, +import jadx.core.dex.visitors.blocksmaker.helpers.BlocksRemoveInfo;, +import jadx.core.dex.visitors.ssa.LiveVarAnalysis;, +import jadx.core.utils.BlockUtils;, +import jadx.core.utils.ErrorsCounter;, +import jadx.core.utils.exceptions.JadxRuntimeException;, +, + try {, + } catch (Exception e) {, + LOG.warn("Undo finally extract visitor, mth: {}", mth, e);, + try {, + // reload method without applying this visitor, + // TODO:
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + protected String sfield(FieldInfo field) {, + ClassInfo declClass = field.getDeclClass();, + if (thisClass.startsWith(declClass.getFullName())) {, + // Android specific resources class handler, + ClassInfo parentClass = declClass.getParentClass();, + if (parentClass != null && parentClass.getShortName().equals("R")) {, + return useClass(parentClass) + "." + declClass.getShortName() + "." + field.getName();, + }, + return useClass(declClass) + '.' + field.getName();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + protected String sfield(FieldInfo field) {, + ClassInfo declClass = field.getDeclClass();, + if (thisClass.startsWith(declClass.getFullName())) {, + // Android specific resources class handler, + ClassInfo parentClass = declClass.getParentClass();, + if (parentClass != null && parentClass.getShortName().equals("R")) {, + return useClass(parentClass) + "."
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +//import jadx.core.xmlgen.BinaryXMLParser;, +// BinaryXMLParser bxp = new BinaryXMLParser(args[0],args[1]);, +// bxp.parse();, +// System.exit(4);]
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java, + private static final int MAX_SIZE_DIFF = 25;, + LOG.error("Zip bomp attack detected, invalid sizes: compressed {}, uncompressed {}, name {}",, + compressedSize, uncompressedSize, entry.getName());]
[+++ b/.gitignore, +jadx-output/, +++ b/.gitignore, +jadx-output/, +++ b/jadx-core/build.gradle, + compile files('lib/dx-1.14.jar'), +++ b/.gitignore, +jadx-output/, +++ b/jadx-core/build.gradle, + compile files('lib/dx-1.14.jar'), +++ /dev/null, +++ b/.gitignore, +jadx-output/, +++ b/jadx-core/build.gradle, + compile files('lib/dx-1.14.jar'), +++ /dev/null, +++ b/jadx-core/lib/dx-1.14.jar, +++ b/.gitignore, +jadx-output/, +++ b/jadx-core/build.gradle, + compile files('lib/dx-1.14.jar'), +++ /dev/null, +++ b/jadx-core/lib/dx-1.14.jar, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, + throw new DecodeException("Unknown instruction: '" + OpcodeInfo.getName(insn.getOpcode()) + "'");, +++ b/.gitignore, +jadx-output/, +++ b/jadx-core/build.gradle, + compile files('lib/dx-1.14.jar'), +++ /dev/null, +++ b/jadx-core/lib/dx-1.14.jar, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, + throw new DecodeException("Unknown instruction: '" + OpcodeInfo.getName(insn.getOpcode()) + "'");, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + throw new DecodeException(this, "Load method exception: " + e.getMessage(), e);, +++ b/.gitignore, +jadx-output/, +++ b/jadx-core/build.gradle,
[+++ b/NOTICE, +Copyright 2013, Skylot, +, +Jadx-gui components, +===================, +, +RSyntaxTextArea library licensed under modified BSD liense:, +, +*******************************************************************************, +Copyright (c) 2012, Robert Futrell, +All rights reserved., +, +Redistribution and use in source and binary forms, with or without, +modification, are permitted provided that the following conditions are met:, + * Redistributions of source code must retain the above copyright, + notice, this list of conditions and the following disclaimer., + * Redistributions in binary form must reproduce the above copyright, + notice, this list of conditions and the following disclaimer in the, + documentation and/or other materials provided
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, + if (fileName.endsWith(".apk") || fileName.endsWith(".zip")) {]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (callMthNode != null && callMthNode.isArgsOverload()) {, + int argsCount = insn.getArgsCount();, + List<ArgType> originalType = callMth.getArgumentsTypes();, + int origPos = 0;, +, + code.add('(');, + for (int i = k; i < argsCount; i++) {, + InsnArg arg = insn.getArg(i);, + ArgType origType = originalType.get(origPos);, + if (!arg.getType().equals(origType)) {, + code.add('(').add(useType(origType)).add(')').add(arg(arg));, + } else {, + code.add(arg(arg));, + }, + if (i < argsCount - 1) {, + code.add(", ");, + }, + origPos++;, + }, + code.add(')');, + } else {, + }, + int argsCount = insn.getArgsCount();, + if (k < argsCount) {,
[+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +import java.lang.reflect.InvocationTargetException;, +import java.lang.reflect.Modifier;, + System.out.println(cls.getCode());, +, + runAutoCheck(clsName);, +, + @Override, + public boolean isShowInconsistentCode() {, + return true;, + }, + private void runAutoCheck(String clsName) {, + try {, + // run 'check' method from original class, + Class<?> origCls;, + try {, + origCls = Class.forName(clsName);, + } catch (ClassNotFoundException e) {, + // ignore, + return;, + }, + Method checkMth;, + try {, + checkMth = origCls.getMethod("check");, + } catch (NoSuchMethodException e) {, + // ignore, + return;, + }, + if (!checkMth.getReturnType().equals(void.class), + || !Modifier.isPublic(checkMth.getModifiers()), + || Modifier.isStatic(checkMth.getModifiers())) {, + fail("Wrong
[+++ b/build.gradle, +++ b/build.gradle, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import java.io.File;, +, + ZipRef getZipRef() {, +++ b/build.gradle, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import java.io.File;, +, + ZipRef getZipRef() {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.api.ResourceFile.ZipRef;, +import jadx.core.codegen.CodeWriter;, +import jadx.core.utils.Utils;, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.utils.files.InputFile;, +import jadx.core.xmlgen.ResContainer;, +import jadx.core.xmlgen.ResTableParser;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, + ZipRef zipRef = rf.getZipRef();, + if (zipRef == null) {, + return null;, + }, + result = decoder.decode(entry.getSize(), inputStream);, + throw new JadxException("Error decode: " + zipRef.getEntryName(), e);, + LOG.error("Error close zip file: {}", zipRef, e);, +++ b/build.gradle, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import java.io.File;, +, + ZipRef getZipRef() {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.api.ResourceFile.ZipRef;, +import jadx.core.codegen.CodeWriter;,
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, + } catch (Exception e) {, + try {, + } catch (Exception e) {, + LOG.error("Field signature parse error: {}.{}", this.getFullName(), field.getName(), e);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, + } catch (Exception e) {, + try {, + } catch (Exception e) {, + LOG.error("Field signature parse error: {}.{}", this.getFullName(), field.getName(), e);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java, + if (inner == null) {, + throw new JadxRuntimeException("No inner type found: " + debugString());, + }, + if (pos >= sign.length()) {, + return sign;, + }]
[+++ b/.travis.yml, +script: gradle clean build, +++ b/.travis.yml, +script: gradle clean build, +++ b/README.md, + ./gradlew dist, + --cfg - save methods control flow graph to dot file, +++ b/.travis.yml, +script: gradle clean build, +++ b/README.md, + ./gradlew dist, + --cfg - save methods control flow graph to dot file, +++ b/build.gradle, + if (!"${it}".contains(":jadx-samples:")) {, + }, + }, +task dist(dependsOn: pack) {, +task samples(dependsOn: 'jadx-samples:samples') {, +}, +, +task build(dependsOn: [dist, samples]) {, +}, +, +++ b/.travis.yml, +script: gradle clean build, +++ b/README.md, + ./gradlew dist, + --cfg - save methods control flow graph to dot file,
[+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, + List<File> files = compileClass(cls);, + assertThat("File list is empty", files, not(empty()));, + String path = cls.getPackage().getName().replace('.', '/');, + for (File file : files) {, + String clsFullName = cls.getName();, + String rootClsName;, + int end = clsFullName.indexOf('$');, + rootClsName = clsFullName.substring(0, end);, + } else {, + rootClsName = clsFullName;, + String javaFileName = rootClsName.replace('.', '/') + ".java";, + File file = new File(TEST_DIRECTORY, javaFileName);, + file = new File(TEST_DIRECTORY2, javaFileName);, + assertThat("Test source file not found: " + javaFileName, file.exists(), is(true));, + files.forEach(File::deleteOnExit);, + String clsName = clsFullName.substring(clsFullName.lastIndexOf('.') + 1);, + files.removeIf(next -> !next.getName().contains(clsName));, +++
[+++ /dev/null, +++ /dev/null, +++ b/.gitignore, +**/.DS_Store, +]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, + public int length() {, + return buf.length();, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, + public int length() {, + return buf.length();, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + @Deprecated, + @Deprecated, + @Deprecated, + addArg(code, arg, wrap);, + return code;, + }, +, + public void addArg(CodeWriter code, InsnArg arg) throws CodegenException {, + addArg(code, arg, true);, + }, +, + public void addArg(CodeWriter code, InsnArg arg, boolean wrap) throws CodegenException {, + code.add(staticField(f.getField()));, + instanceField(code, f.getField(), regArg);, + private void instanceField(CodeWriter code, FieldInfo field, InsnArg arg) throws CodegenException {, + return;, + int len = code.length();, +
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, + passes.add(new DebugInfoParseVisitor());, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new ConstructorVisitor());, + passes.add(new TypeInferenceVisitor());, + passes.add(new DebugInfoApplyVisitor());, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, + passes.add(new DebugInfoParseVisitor());, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, +
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, + passes.add(new InitCodeVariables());, + passes.add(new MarkFinallyVisitor());, + passes.add(new CleanRegions());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, + passes.add(new InitCodeVariables());, + passes.add(new MarkFinallyVisitor());, + passes.add(new CleanRegions());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.InitCodeVariables;, +import jadx.core.dex.visitors.MarkFinallyVisitor;, +import jadx.core.dex.visitors.regions.CleanRegions;, + passes.add(new InitCodeVariables());, + passes.add(new MarkFinallyVisitor());, + passes.add(new CleanRegions());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.dex.nodes.ClassNode;, +import jadx.core.dex.nodes.FieldNode;, + addNamesUsedInClass();, + }, +, + private void addNamesUsedInClass() {, + ClassNode parentClass = mth.getParentClass();, + for (FieldNode field : parentClass.getFields()) {, + varNames.add(field.getAlias());, + }, + for (ClassNode innerClass : parentClass.getInnerClasses()) {, + varNames.add(innerClass.getAlias().getShortName());, + }, +++
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + String name = field.getName();, + if (arg.isThis()) {, + boolean useShort = true;, + List<RegisterArg> args = mth.getArguments(false);, + for (RegisterArg param : args) {, + String paramName = param.getTypedVar().getName();, + if (paramName != null && paramName.equals(name)) {, + useShort = false;, + }, + }, + if (useShort) {, + return name; // FIXME: check variable names in scope, + }, + }, + return arg(arg) + "." + name;, + InsnArg arg = insn.getArg(0);, + if (!arg.isThis()) { // FIXME: add 'this' for equals methods in scope, + code.add(arg(arg)).add('.');, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, + public static void main(String[] args) throws JadxException {, + } catch (Throwable e) {, + LOG.error("jadx error: " + e.getMessage(), e);, + jadx.loadFiles(jadxArgs.getInput());, + if (jadx.getErrorsCount() != 0) {, + jadx.printErrorsReport();, + LOG.error("finished with errors");, + } else {, + }, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, + public static void main(String[] args) throws JadxException {, + } catch (Throwable e) {, + LOG.error("jadx error: " + e.getMessage(), e);, + jadx.loadFiles(jadxArgs.getInput());, + if (jadx.getErrorsCount() != 0) {, + jadx.printErrorsReport();, + LOG.error("finished with errors");, + } else {, + }, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import jadx.api.JadxDecompiler;, + out.println("jadx - dex to java decompiler,
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +import java.util.Enumeration;, +, + // Input file could be .apk or .zip files, + // we should consider the input file could contain only one single dex, multi-dex, or instantRun support dex for Android .apk files, + String instantRunDexSuffix = "classes" + ext;, + for (Enumeration<? extends ZipEntry> e = zf.entries(); e.hasMoreElements(); ) {, + ZipEntry entry = e.nextElement();, + String entryName = entry.getName();, +, + if ((entryName.startsWith("classes") && entryName.endsWith(ext)) || entryName.endsWith(instantRunDexSuffix)) {, + index++;, + index++;, + } else if (entryName.equals("instant-run.zip") && ext.equals(".dex")) {, + File jarFile = FileUtils.createTempFile("instant-run.zip");, + FileOutputStream fos = new FileOutputStream(jarFile);, +
[+++ b/build.gradle, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, + opt.append(" (default: ").append(val).append(")");, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, + opt.append(" (default: ").append(val).append(")");, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, + return line + ":" + offset + (node != null ? " " + node : "");, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, + opt.append(" (default: ").append(val).append(")");, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, + return line + ":" + offset + (node != null ? " " + node : "");, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, + outDirName = name + "-" + JadxArgs.DEFAULT_OUT_DIR;, +++ b/build.gradle, +++ b/jadx-cli/src/main/java/jadx/cli/JCommanderWrapper.java, + opt.append(" (default: ").append(val).append(")");, +++ b/jadx-core/src/main/java/jadx/api/CodePosition.java, + return line + ":" + offset + (node != null ? "
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/AbstractRegion.java, + private IRegion parent;, + public void setParent(IRegion parent) {, + this.parent = parent;, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/AbstractRegion.java, + private IRegion parent;, + public void setParent(IRegion parent) {, + this.parent = parent;, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java, +import jadx.core.dex.regions.AbstractRegion;, +, + // fix parents, + for (IContainer cont : newRegion.getSubBlocks()) {, + if (cont instanceof AbstractRegion) {, + AbstractRegion aReg = (AbstractRegion) cont;, + aReg.setParent(newRegion);, + }, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/AbstractRegion.java, + private IRegion parent;, + public void setParent(IRegion parent) {, + this.parent = parent;, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java, +import jadx.core.dex.regions.AbstractRegion;, +, + // fix parents, + for
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, + if (!(container instanceof BlockNode)) {, + return;, + }, + BlockNode block = (BlockNode) container;, + if (blocksInRegions.add(block)) {, + return;, + }, + if (!block.contains(AFlag.RETURN), + && !block.contains(AFlag.SKIP), + && !block.contains(AFlag.SYNTHETIC), + && !block.getInstructions().isEmpty()) {, + // TODO, + // mth.add(AFlag.INCONSISTENT_CODE);, + LOG.debug(" Duplicated block: {} in {}", block, mth);]
[+++ b/jadx-gui/src/main/resources/i18n/Messages_en_US.properties, +certificate.serialSigVer=Version, +certificate.cert_issuer=Issuer, +certificate.cert_subject=Subject, +certificate.serialPubKeyType=Public key type, +certificate.serialPubKeyExponent=Exponent, +certificate.serialPubKeyModulus=Modulus, +++ b/jadx-gui/src/main/resources/i18n/Messages_en_US.properties, +certificate.serialSigVer=Version, +certificate.cert_issuer=Issuer, +certificate.cert_subject=Subject, +certificate.serialPubKeyType=Public key type, +certificate.serialPubKeyExponent=Exponent, +certificate.serialPubKeyModulus=Modulus, +++ b/jadx-gui/src/main/resources/i18n/Messages_zh_CN.properties, +menu.recent_files=最近打开的文件, +menu.no_recent_files=无最近打开的文件, +menu.preferences=设置, +menu.flatten=展开显示代码包, +menu.text_search=搜索文本, +menu.deobfuscation=反混淆, +file.open_action=打开..., +file.open_title=打开文件, +file.save_all=全部保存, +file.export_gradle=另存为 Gradle 项目, +tree.sources_title=源代码, +tree.resources_title=资源文件, +tabs.closeOthers=关闭其他文件, +tabs.closeAll=全部关闭, +nav.forward=前进, +search_dialog.open=转到, +search_dialog.open_by_name=搜索文本：, +search_dialog.search_in=在以下位置搜索：, +search_dialog.class=类名, +search_dialog.method=方法名, +search_dialog.field=变量名, +search_dialog.options=搜索选项：, +search_dialog.ignorecase=忽略大小写, +search_dialog.next_page=下一页, +search_dialog.prev_page=上一页, +search_dialog.info_label=显示了 %3$d 个结果中的第 %1$d 至第 %3$d 个, +search_dialog.col_node=节点, +search_dialog.col_code=代码, +usage_dialog.title=查找, +usage_dialog.label=查找用例：, +log_viewer.title=日志查看器, +log_viewer.log_level=日志等级：, +, +about_dialog.title=关于 JADX, +, +preferences.title=设置, +preferences.deobfuscation=反混淆, +preferences.fallback=输出中间代码, +preferences.escapeUnicode=将 Unicode 字符转义, +preferences.skipResourcesDecode=不反编译资源文件, +preferences.threads=并行线程数, +preferences.language=语言, +preferences.check_for_updates=启动时检查更新, +preferences.cfg=生成方法的 CFG 图（以 .dot 格式保存）, +preferences.raw_cfg=生成原始的 CFG 图, +preferences.theme=编辑器主题, +preferences.start_jobs=自动进行后台反编译, +preferences.deobfuscation_on=启用反混淆, +preferences.deobfuscation_force=强制覆盖反混淆映射文件, +preferences.reset_message=要恢复默认设置吗？, +msg.saving_sources=正在导出源代码..., +msg.index_not_initialized=索引尚未初始化，无法进行搜索！, +popup.redo=重做, +, +certificate.title=证书, +certificate.cert_type=类型, +certificate.serialSigVer=版本, +certificate.serialNumber=序列号, +certificate.cert_issuer=颁发者, +certificate.cert_subject=主题,
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, + public void mergeName(InsnArg arg) {, + if (arg instanceof Named) {, + Named otherArg = (Named) arg;, + String otherName = otherArg.getName();, + String name = getName();, + if (!Objects.equals(name, otherName)) {, + if (name == null) {, + setName(otherName);, + } else if (otherName == null) {, + otherArg.setName(name);, + }, + }, + }, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, + public void mergeName(InsnArg arg) {, + if (arg instanceof Named) {, + Named otherArg = (Named) arg;, + String otherName = otherArg.getName();, + String name = getName();, + if (!Objects.equals(name, otherName)) {, + if
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, + public static final Set<InsnType> SEPARATE_INSNS = EnumSet.of(, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, + public static final Set<InsnType> SEPARATE_INSNS = EnumSet.of(, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, + mth.addWarn("Code restructure failed: missing block: " + block + ", code lost:" + blockCode);, + // check loop conditions, + private static String getBlockInsnStr(MethodNode mth, IBlock block) {, + code.newLine();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, + public static final Set<InsnType> SEPARATE_INSNS = EnumSet.of(, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, + mth.addWarn("Code restructure failed: missing block: " + block + ", code lost:" + blockCode);, + // check loop conditions, + private static String getBlockInsnStr(MethodNode mth, IBlock block) {, + code.newLine();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java, +import
[+++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +import java.util.Comparator;, + for (JavaPackage pkg : packages) {, + Collections.sort(pkg.getClasses(), new Comparator<JavaClass>() {, + @Override, + public int compare(JavaClass o1, JavaClass o2) {, + return o1.getShortName().compareTo(o2.getShortName());, + }, + });, + }, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +import java.util.Comparator;, + for (JavaPackage pkg : packages) {, + Collections.sort(pkg.getClasses(), new Comparator<JavaClass>() {, + @Override, + public int compare(JavaClass o1, JavaClass o2) {, + return o1.getShortName().compareTo(o2.getShortName());, + }, + });, + }, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import java.util.Comparator;, + Collections.sort(mths, new Comparator<JavaMethod>() {, + @Override, + public int compare(JavaMethod o1, JavaMethod o2) {, + return o1.getName().compareTo(o2.getName());, + }, + });]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"-ds", "--output-dir-src"}, description = "output directory for sources"), + protected String outDirNameSrc;, +, + @Parameter(names = {"-dr", "--output-dir-res"}, description = "output directory for resources"), + protected String outDirNameRes;, +, + private File outputDirSrc;, + private File outputDirRes;, + if(outDirNameSrc != null) {, + outputDirSrc = new File(outDirNameSrc);, + }, + if(outDirNameRes != null) {, + outputDirRes = new File(outDirNameRes);, + }, + if(outputDirSrc == null) {, + outputDirSrc = new File(outputDir, "source");, + if(outputDirRes == null) {, + outputDirRes = new File(outputDir, "res");, + }, + }, + , + @Override, + public File
[+++ b/jadx-core/build.gradle, +ext.jadxClasspath = 'clsp-data/android-5.1.jar', +++ b/jadx-core/build.gradle, +ext.jadxClasspath = 'clsp-data/android-5.1.jar', +++ /dev/null, +++ b/jadx-core/build.gradle, +ext.jadxClasspath = 'clsp-data/android-5.1.jar', +++ /dev/null, +++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/build.gradle, +ext.jadxClasspath = 'clsp-data/android-5.1.jar', +++ /dev/null, +++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +++ b/jadx-core/build.gradle, +ext.jadxClasspath = 'clsp-data/android-5.1.jar', +++ /dev/null, +++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, + String fileName = file.getName();, + if (fileName.endsWith(".dex"), + || fileName.endsWith(".jar"), + || fileName.endsWith(".apk")) {, +++ b/jadx-core/build.gradle, +ext.jadxClasspath = 'clsp-data/android-5.1.jar', +++ /dev/null, +++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, + String fileName = file.getName();, + if (fileName.endsWith(".dex"), + || fileName.endsWith(".jar"), + || fileName.endsWith(".apk")) {, +++ /dev/null, +++ b/jadx-core/build.gradle, +ext.jadxClasspath = 'clsp-data/android-5.1.jar', +++ /dev/null, +++ b/jadx-core/clsp-data/android-5.1.jar,
[+++ b/jadx-core/src/test/java/jadx/NotYetImplemented.java, +package jadx;, +, +import java.lang.annotation.ElementType;, +import java.lang.annotation.Retention;, +import java.lang.annotation.RetentionPolicy;, +import java.lang.annotation.Target;, +, +/**, + * Indicates a test which is known to fail., + * , + * <p>This would cause a failure to be considered as success and a success as failure,, + * with the benefit of updating the related issue when it has been resolved even unintentionally.</p>, + * , + * <p>To have an effect, the test class must be annotated with:, + * , + * <code>, + * &#064;ExtendWith(NotYetImplementedExtension.class), + * </code>, + * </p>, + */, +@Retention(RetentionPolicy.RUNTIME), +@Target({ElementType.TYPE, ElementType.METHOD}), +public
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + private static enum IGState {, + BODY_ONLY_NOWRAP,, + return arg(arg, true);, + }, +, + public String arg(InsnArg arg, boolean wrap) throws CodegenException {, + IGState flag = wrap ? IGState.BODY_ONLY : IGState.BODY_ONLY_NOWRAP;, + makeInsn(((InsnWrapArg) arg).getWrapInsn(), code, flag);, + return makeInsn(insn, code, null);, + private boolean makeInsn(InsnNode insn, CodeWriter code, IGState flag) throws CodegenException {, + EnumSet<IGState> state = EnumSet.noneOf(IGState.class);, + if (flag == IGState.BODY_ONLY || flag == IGState.BODY_ONLY_NOWRAP) {, + state.add(flag);, + if (state.contains(IGState.SKIP)) {, + if (insn.getResult() != null && !state.contains(IGState.NO_RESULT)) {, + }, + if (!state.contains(IGState.NO_SEMICOLON)) {, + }, + private void makeInsnBody(CodeWriter
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, + if (sVar.getAssign() == null) {, + continue;, + }, + // allow inline only one use arg or 'this', + if (sVar.getVariableUseCount() != 1 && !arg.isThis()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, + if (sVar.getAssign() == null) {, + continue;, + }, + // allow inline only one use arg or 'this', + if (sVar.getVariableUseCount() != 1 && !arg.isThis()) {, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, + if (sVar.getAssign() == null) {, + continue;, + }, + // allow inline only one use arg or 'this', + if (sVar.getVariableUseCount() != 1 && !arg.isThis()) {, +++ /dev/null, +++ b/jadx-core/src/test/java/jadx/tests/internal/usethis/TestInlineThis.java, +package jadx.tests.internal.usethis;, +,
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxArgs.java, +package jadx.cli;, +, +import jadx.core.Consts;, +import jadx.api.IJadxArgs;, +import jadx.core.utils.exceptions.JadxException;, +, +import java.io.File;, +import java.io.PrintStream;, +import java.lang.reflect.Field;, +import java.util.ArrayList;, +import java.util.List;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import com.beust.jcommander.JCommander;, +import com.beust.jcommander.Parameter;, +import com.beust.jcommander.ParameterDescription;, +import com.beust.jcommander.ParameterException;, +, +public class JadxArgs implements IJadxArgs {, + private static final Logger LOG = LoggerFactory.getLogger(JadxArgs.class);, +, + @Parameter(description = "<input files> (.dex, .apk, .jar or .class)"), + protected List<String> files;, +, + @Parameter(names = {"-d", "--output-dir"}, description = "output directory"), + protected String outDirName;, +, + @Parameter(names = {"-j", "--threads-count"}, description = "processing threads count"), + protected int threadsCount = Runtime.getRuntime().availableProcessors();, +, +
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + InputFile inputFile = new InputFile(file);, + inputFiles.add(inputFile);, + while (inputFile.nextDexIndex != -1) {, + inputFile = new InputFile(file, inputFile.nextDexIndex);, + inputFiles.add(inputFile);, + }, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + InputFile inputFile = new InputFile(file);, + inputFiles.add(inputFile);, + while (inputFile.nextDexIndex != -1) {, + inputFile = new InputFile(file, inputFile.nextDexIndex);, + inputFiles.add(inputFile);, + }, +++ b/jadx-core/src/main/java/jadx/core/clsp/ConvertToClsSet.java, + InputFile inputFile = new InputFile(f);, + inputFiles.add(inputFile);, + while (inputFile.nextDexIndex != -1) {, + inputFile = new InputFile(f, inputFile.nextDexIndex);, + inputFiles.add(inputFile);, + }, + InputFile inputFile = new InputFile(file);, + inputFiles.add(inputFile);, + while (inputFile.nextDexIndex != -1) {, + inputFile = new InputFile(file, inputFile.nextDexIndex);, +
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, + passes.add(new CodeShrinkVisitor());, + passes.add(new CodeShrinkVisitor());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, + passes.add(new CodeShrinkVisitor());, + passes.add(new CodeShrinkVisitor());, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, + passes.add(new CodeShrinkVisitor());, + passes.add(new CodeShrinkVisitor());, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, + runAfter = {CodeShrinkVisitor.class, ModVisitor.class}, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, + passes.add(new CodeShrinkVisitor());, + passes.add(new CodeShrinkVisitor());, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, + runAfter = {CodeShrinkVisitor.class, ModVisitor.class}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInlineVisitor.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, + CodeShrinkVisitor.shrinkMethod(mth);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, + passes.add(new CodeShrinkVisitor());, + passes.add(new CodeShrinkVisitor());, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, + runAfter = {CodeShrinkVisitor.class, ModVisitor.class}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInlineVisitor.java, +import jadx.core.dex.visitors.shrink.CodeShrinkVisitor;, + CodeShrinkVisitor.shrinkMethod(mth);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java,
[+++ b/src/main/java/jadx/Consts.java, +package jadx;, +, +public class Consts {, + public static final String JADX_VERSION = "dev";, +, + public static final boolean DEBUG = false;, +, + public static final String CLASS_OBJECT = "java.lang.Object";, + public static final String CLASS_STRING = "java.lang.String";, + public static final String CLASS_CLASS = "java.lang.Class";, + public static final String CLASS_THROWABLE = "java.lang.Throwable";, + public static final String CLASS_ENUM = "java.lang.Enum";, +}, +++ b/src/main/java/jadx/Consts.java, +package jadx;, +, +public class Consts {, + public static final String JADX_VERSION = "dev";, +, + public static final boolean DEBUG = false;, +, + public static final
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, + if (isEmptySyntheticClass(cls)) {, + private static boolean isEmptySyntheticClass(ClassNode cls) {, + return cls.getAccessFlags().isSynthetic(), + && cls.getFields().isEmpty(), + && cls.getMethods().isEmpty(), + && cls.getInnerClasses().isEmpty();, + }, +, + if (argCls.contains(AFlag.DONT_GENERATE) || isEmptySyntheticClass(argCls)) {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, + for (MethodNode mth : cls.getMethods()) {, + mth.getAttributes().add(AttributeFlag.DONT_GENERATE);]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + StringBuilder sb = new StringBuilder();, + sb.append(arg(it.next()));, + if (it.hasNext()) {, + sb.append(" + ");, + }, + // TODO: wrap in braces only if necessary, + if (state.contains(InsnGenState.BODY_ONLY)) {, + code.add('(').add(sb.toString()).add(')');, + } else {, + code.add(sb.toString());, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + StringBuilder sb = new StringBuilder();, + sb.append(arg(it.next()));, + if (it.hasNext()) {, + sb.append(" + ");, + }, + // TODO: wrap in braces only if necessary, + if (state.contains(InsnGenState.BODY_ONLY)) {, + code.add('(').add(sb.toString()).add(')');, + } else {, + code.add(sb.toString());, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, +import jadx.core.dex.instructions.InsnType;, + public InsnArg wrapInstruction(InsnNode insn) {, + InsnArg arg;,
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, + node.addArg(InsnArg.reg(insn, 1, ArgType.array(ArgType.UNKNOWN)));, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, + node.addArg(InsnArg.reg(insn, 1, ArgType.array(ArgType.UNKNOWN)));, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, + LiteralArg litArg;, + if (use.size() == 2) {, + // arg used only in one place, + litArg = InsnArg.lit(literal, arg.getType());, + } else {, + litArg = InsnArg.lit(literal, ArgType.UNKNOWN);, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/InsnDecoder.java, + node.addArg(InsnArg.reg(insn, 1, ArgType.array(ArgType.UNKNOWN)));, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, + LiteralArg litArg;, + if (use.size() == 2) {, + // arg used only in one place, + litArg = InsnArg.lit(literal, arg.getType());, + } else {, + litArg = InsnArg.lit(literal, ArgType.UNKNOWN);, + }, +++ b/jadx-core/src/test/java/jadx/tests/internal/TestWrongCode.java, +package jadx.tests.internal;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"--no-debug-info"}, description = "disable debug info"), + protected boolean debugInfo = true;, +, + args.setDebugInfo(debugInfo);, + public boolean isDebugInfo() {, + return debugInfo;, + }, +, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"--no-debug-info"}, description = "disable debug info"), + protected boolean debugInfo = true;, +, + args.setDebugInfo(debugInfo);, + public boolean isDebugInfo() {, + return debugInfo;, + }, +, +++ b/jadx-cli/src/test/java/jadx/cli/JadxCLIArgsTest.java, + assertThat(override(new JadxCLIArgs(), "--no-debug-info").isDebugInfo(), is(false));, + args.debugInfo = false;, + assertThat(override(args, "--no-debug-info").isDebugInfo(), is(false));, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"--no-debug-info"}, description = "disable debug info"), + protected boolean debugInfo = true;, +, + args.setDebugInfo(debugInfo);, + public
[+++ b/.gitignore, +++ b/.gitignore, +++ b/build.gradle, + google(), +++ b/.gitignore, +++ b/build.gradle, + google(), +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/build.gradle, + google(), +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new DebugInfoVisitor());, + passes.add(new TypeInference());, +, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new FinishTypeInference());, +, +, +++ b/.gitignore, +++ b/build.gradle, + google(), +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new DebugInfoVisitor());, + passes.add(new TypeInference());, +, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, + private final Map<String, Set<String>> ancestorCache =
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/SSAVar.java, + private int startUseAddr;, + private int endUseAddr;, +, +, + startUseAddr = -1;, + endUseAddr = -1;, + public int getStartAddr() {, + if (startUseAddr == -1) {, + calcUsageAddrRange();, + }, + return startUseAddr;, + }, +, + public int getEndAddr() {, + if (endUseAddr == -1) {, + calcUsageAddrRange();, + }, +, + return endUseAddr;, + }, +, + private void calcUsageAddrRange() {, + int start = Integer.MAX_VALUE;, + int end = Integer.MIN_VALUE;, +, + if (assign != null) {, + if (assign.getParentInsn() != null) {, + int insnAddr = assign.getParentInsn().getOffset();, +, + if
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java, +import jadx.core.utils.exceptions.JadxOverflowException;, + private static boolean canRemoveBlock(BlockNode block) {, + return block.getInstructions().isEmpty(), + && block.getSuccessors().size() <= 1, + && !block.getPredecessors().isEmpty();, + }, +, + private static boolean removeEmptyBlock(BlockNode block) {, + if (canRemoveBlock(block)) {, + try {, + } catch (StackOverflowError e) {, + throw new JadxOverflowException("Failed compute block dominance frontier");, + } catch (Exception e) {, + throw new JadxRuntimeException("Failed compute block dominance frontier", e);, + }, + block.getDominatesOn().forEach(domBlock -> computeBlockDF(mth, domBlock));, + if (removeEmptyBlock(basicBlock)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java, +import jadx.core.utils.exceptions.JadxOverflowException;, + private static boolean canRemoveBlock(BlockNode block) {, + return block.getInstructions().isEmpty(), + && block.getSuccessors().size() <= 1, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java, + private IRegion body;, + public IRegion getBody() {, + public void setBody(IRegion body) {, + public boolean replaceSubBlock(IContainer oldBlock, IContainer newBlock) {, + return false;, + }, +, + @Override, +++ b/jadx-core/src/main/java/jadx/core/dex/regions/loops/LoopRegion.java, + private IRegion body;, + public IRegion getBody() {, + public void setBody(IRegion body) {, + public boolean replaceSubBlock(IContainer oldBlock, IContainer newBlock) {, + return false;, + }, +, + @Override, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/ProcessTryCatchRegions.java, +import jadx.core.dex.regions.loops.LoopRegion;, + private static boolean wrapBlocks(IRegion replaceRegion, TryCatchBlock tb, BlockNode dominator) {, + IRegion region = replaceRegion;, + if (region instanceof LoopRegion) {, + LoopRegion loop = (LoopRegion) region;, +
[+++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, +import jadx.core.dex.instructions.InvokeNode;, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.instructions.args.InsnWrapArg;, +import jadx.core.dex.instructions.mods.ConstructorInsn;, +import jadx.core.dex.nodes.InsnNode;, +import java.util.HashMap;, +import java.util.Map;, + private static final Map<String, String> OBJ_ALIAS;, +, + static {, + OBJ_ALIAS = new HashMap<String, String>();, + OBJ_ALIAS.put(Consts.CLASS_STRING, "str");, + OBJ_ALIAS.put(Consts.CLASS_CLASS, "cls");, + OBJ_ALIAS.put(Consts.CLASS_THROWABLE, "th");, + OBJ_ALIAS.put(Consts.CLASS_OBJECT, "obj");, + OBJ_ALIAS.put("java.util.Iterator", "it");, + OBJ_ALIAS.put("java.lang.Boolean", "bool");, + OBJ_ALIAS.put("java.lang.Short", "sh");, + OBJ_ALIAS.put("java.lang.Integer", "num");, + OBJ_ALIAS.put("java.lang.Character", "ch");, + OBJ_ALIAS.put("java.lang.Byte", "b");, + OBJ_ALIAS.put("java.lang.Float", "f");, + OBJ_ALIAS.put("java.lang.Long", "l");, + OBJ_ALIAS.put("java.lang.Double", "d");, + }, +, + if ("this".equals(name)) {, + String alias = getAliasForObject(type.getObject());, + if (alias != null) {, + return alias;, + String vName = fromName(shortName);, +
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"--deobf-use-sourcename"}, description = "use source file name as class name alias"), + protected boolean deobfuscationUseSourceNameAsAlias = false;, +, +, + @Override, + public boolean useSourceNameAsClassAlias() {, + return deobfuscationUseSourceNameAsAlias;, + }, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"--deobf-use-sourcename"}, description = "use source file name as class name alias"), + protected boolean deobfuscationUseSourceNameAsAlias = false;, +, +, + @Override, + public boolean useSourceNameAsClassAlias() {, + return deobfuscationUseSourceNameAsAlias;, + }, +++ b/jadx-core/src/main/java/jadx/api/DefaultJadxArgs.java, +, + @Override, + public boolean useSourceNameAsClassAlias() {, + return false;, + }, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(names = {"--deobf-use-sourcename"}, description = "use source file name
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new BlockProcessor());, + passes.add(new BlockExceptionHandler());, + passes.add(new BlockFinallyExtract());, + passes.add(new BlockFinish());, +, + passes.add(new SSATransform());, + passes.add(new DebugInfoVisitor());, + passes.add(new TypeInference());, +, + passes.add(new FinishTypeInference());, + passes.add(new EliminatePhiNodes());, +, +, + passes.add(new LoopRegionVisitor());, + passes.add(new ProcessVariables());, +, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new BlockProcessor());, +
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + af = af.remove(AccessFlags.ACC_ABSTRACT), + .remove(AccessFlags.ACC_STATIC);, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + af = af.remove(AccessFlags.ACC_ABSTRACT), + .remove(AccessFlags.ACC_STATIC);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/AccessInfo.java, + return new AccessInfo(accFlags & ~flag, type);, + return this;, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + af = af.remove(AccessFlags.ACC_ABSTRACT), + .remove(AccessFlags.ACC_STATIC);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/AccessInfo.java, + return new AccessInfo(accFlags & ~flag, type);, + return this;, +++ b/jadx-core/src/test/java/jadx/tests/integration/TestClassGen.java, + public interface I {, + assertThat(code, containsString("public interface I {"));, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + af = af.remove(AccessFlags.ACC_ABSTRACT), + .remove(AccessFlags.ACC_STATIC);, +++ b/jadx-core/src/main/java/jadx/core/dex/info/AccessInfo.java, + return new AccessInfo(accFlags & ~flag, type);, + return this;, +++ b/jadx-core/src/test/java/jadx/tests/integration/TestClassGen.java, + public interface I {, + assertThat(code, containsString("public interface I {"));, +++ b/jadx-core/src/test/java/jadx/tests/integration/annotations/TestAnnotations2.java, + public @interface
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java, +import jadx.core.Consts;, + if (Consts.DEBUG && result == TypeUpdateResult.REJECT && LOG.isDebugEnabled()) {, + if (Consts.DEBUG && result == TypeUpdateResult.REJECT && LOG.isDebugEnabled()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeInferenceVisitor.java, +import jadx.core.Consts;, + if (Consts.DEBUG && result == TypeUpdateResult.REJECT && LOG.isDebugEnabled()) {, + if (Consts.DEBUG && result == TypeUpdateResult.REJECT && LOG.isDebugEnabled()) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/typeinference/TypeUpdate.java, +import jadx.core.Consts;, + if (Consts.DEBUG && LOG.isDebugEnabled()) {, + return !boundType.isTypeKnown() && checkAssignForUnknown(boundType, candidateType);]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + code.newLine().add("/*");, + code.newLine().add(ErrorsCounter.methodError(mth, "Method generation error", e));, + code.newLine().add(Utils.getStackTrace(e));, + code.newLine().add("*/");, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + code.newLine().add("/*");, + code.newLine().add(ErrorsCounter.methodError(mth, "Method generation error", e));, + code.newLine().add(Utils.getStackTrace(e));, + code.newLine().add("*/");, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + code.add("new ").add(insn.getResult().getType().toString());, + break;, +, + case PHI:, + case MERGE:, + fallbackOnlyInsn(insn);, + code.add(insn.getType().toString()).add("(");, + for (InsnArg insnArg : insn.getArguments()) {, + addArg(code, insnArg);, + code.add(' ');, + }, + code.add(")");, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + code.newLine().add("/*");, + code.newLine().add(ErrorsCounter.methodError(mth, "Method generation error", e));, + code.newLine().add(Utils.getStackTrace(e));, + code.newLine().add("*/");, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + code.add("new ").add(insn.getResult().getType().toString());, + break;, +, + case PHI:, + case MERGE:, + fallbackOnlyInsn(insn);, + code.add(insn.getType().toString()).add("(");, + for (InsnArg insnArg
[+++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/test/java/jadx/api/JadxInternalAccess.java, +package jadx.api;, +, +import jadx.core.dex.nodes.RootNode;, +, +public class JadxInternalAccess {, +, + public static RootNode getRoot(JadxDecompiler d) {, + return d.getRoot();, + }, +}, +++ /dev/null, +++ b/jadx-core/src/test/java/jadx/api/JadxInternalAccess.java, +package jadx.api;, +, +import jadx.core.dex.nodes.RootNode;, +, +public class JadxInternalAccess {, +, + public static RootNode getRoot(JadxDecompiler d) {, + return d.getRoot();, + }, +}, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/test/java/jadx/api/JadxInternalAccess.java, +package jadx.api;, +, +import jadx.core.dex.nodes.RootNode;, +, +public class JadxInternalAccess {, +, + public static RootNode getRoot(JadxDecompiler d) {, + return d.getRoot();, + }, +}, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/jadx-core/src/test/java/jadx/api/JadxInternalAccess.java, +package jadx.api;, +,
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.api.JadxDecompiler;, +import jadx.core.utils.exceptions.JadxException;, +, + } catch (Exception e) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.api.JadxDecompiler;, +import jadx.core.utils.exceptions.JadxException;, +, + } catch (Exception e) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import ch.qos.logback.classic.spi.ILoggingEvent;, +import ch.qos.logback.core.Appender;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import jadx.api.IJadxArgs;, +import jadx.api.JadxDecompiler;, +import jadx.core.utils.exceptions.JadxException;, + private final List<File> input = new ArrayList<>(1);, + Map<String, ParameterDescription> paramsMap = new LinkedHashMap<>(params.size());, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.api.JadxDecompiler;, +import jadx.core.utils.exceptions.JadxException;, +, + } catch (Exception e) {, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, +import ch.qos.logback.classic.spi.ILoggingEvent;, +import ch.qos.logback.core.Appender;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +import jadx.api.IJadxArgs;, +import jadx.api.JadxDecompiler;, +import jadx.core.utils.exceptions.JadxException;, + private final List<File> input = new ArrayList<>(1);, + Map<String, ParameterDescription>
[+++ b/jadx-gui/src/main/java/jadx/gui/utils/Link.java, + new ProcessBuilder(), + .command(new String[] {"rundll32", "url.dll,FileProtocolHandler", url}), + .start();, + new ProcessBuilder(), + .command(new String[] {"open", url}), + .start();, + new ProcessBuilder(), + .command(new String[] {env.get("BROWSER"), url}), + .start();]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, + if (!NameMapper.isValidIdentifier(clsName)) {, + return 'C' + clsName;, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, + if (!NameMapper.isValidIdentifier(clsName)) {, + return 'C' + clsName;, + }, +++ b/jadx-core/src/test/java/jadx/tests/integration/names/TestReservedClassNames.java, +package jadx.tests.integration.names;, +, +import org.junit.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.SmaliTest;, +, +import static org.hamcrest.Matchers.containsString;, +import static org.hamcrest.Matchers.not;, +import static org.junit.Assert.assertThat;, +, +import java.io.File;, +, +public class TestReservedClassNames extends SmaliTest {, + /*, + public class do {, + }, + */, +, + @Test, + public void test() {, + ClassNode cls = getClassNodeFromSmali("names" + File.separatorChar + "TestReservedClassNames", "do");, + String code = cls.getCode().toString();, +, + assertThat(code, not(containsString("public class do")));, +
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.utils.ErrorsCounter;, +import jadx.core.utils.InsnUtils;, + ArgType insnArrayType = insn.getResult().getType();, + ArgType insnElementType = insnArrayType.getArrayElement();, + ArgType elType = insn.getElementType();, + if (!elType.equals(insnElementType) && !insnArrayType.equals(ArgType.OBJECT)) {, + ErrorsCounter.methodError(mth,, + "Incorrect type for fill-array insn " + InsnUtils.formatOffset(insn.getOffset()));, + Object data = insn.getData();, + byte[] array = (byte[]) data;, + short[] sarray = (short[]) data;, + int[] iarray = (int[]) data;, + long[] larray = (long[]) data;, + code.add("new ").add(useType(elType)).add("[]{").add(str.toString()).add('}');, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.utils.ErrorsCounter;, +import jadx.core.utils.InsnUtils;, + ArgType insnArrayType = insn.getResult().getType();, + ArgType insnElementType = insnArrayType.getArrayElement();, + ArgType elType = insn.getElementType();, + if (!elType.equals(insnElementType) && !insnArrayType.equals(ArgType.OBJECT)) {, + ErrorsCounter.methodError(mth,,
[+++ b/.travis.yml, +sudo: false, +]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, +import java.util.LinkedList;, +import java.util.Queue;, + private static class CondStack {, + private final Queue<IfCondition> stack = new LinkedList<IfCondition>();, +, + public Queue<IfCondition> getStack() {, + return stack;, + }, +, + public void push(IfCondition cond) {, + stack.add(cond);, + }, +, + public IfCondition pop() {, + return stack.poll();, + }, + }, +, + add(code, new CondStack(), condition);, + }, +, + void wrap(CodeWriter code, IfCondition condition) throws CodegenException {, + wrap(code, new CondStack(), condition);, + }, +, + private void add(CodeWriter code, CondStack stack, IfCondition condition) throws CodegenException {, + stack.push(condition);, + addCompare(code, stack, condition.getCompare());,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, +import jadx.core.dex.instructions.args.FieldArg;, + return mgen.makeArgName((RegisterArg) arg);, + } else if (arg.isField()) {, + FieldArg f = (FieldArg) arg;, + if (f.isStatic()) {, + return sfield(f.getField());, + } else {, + RegisterArg regArg = new RegisterArg(f.getRegNum());, + regArg.setTypedVar(f.getTypedVar());, + return ifield(f.getField(), regArg);, + }, + public String assignVar(InsnNode insn) throws CodegenException {, + private String ifield(FieldInfo field, InsnArg arg) throws CodegenException {, + return arg(arg) + "." + field.getName();, + private String sfield(FieldInfo field) {, + case IGET: {, + FieldInfo fieldInfo = (FieldInfo) ((IndexInsnNode) insn).getIndex();, + code.add(ifield(fieldInfo, insn.getArg(0)));, + }, + case IPUT: {, + FieldInfo fieldInfo
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, + // all args must be registers passed from method args (allow only casts insns), + for (InsnArg arg : insn.getArguments()) {, + if (!registersAndCastsOnly(arg)) {, + return false;, + }, + }, + private static boolean registersAndCastsOnly(InsnArg arg) {, + if (arg.isRegister()) {, + return true;, + }, + if (arg.isInsnWrap()) {, + InsnNode wrapInsn = ((InsnWrapArg) arg).getWrapInsn();, + if (wrapInsn.getType() == InsnType.CHECK_CAST) {, + return registersAndCastsOnly(wrapInsn.getArg(0));, + }, + }, + return false;, + }, +]
[+++ b/jadx-core/src/main/java/jadx/core/utils/StringUtils.java, + if(c >= 0 && c <= 0x1F) {, + return "\\" + (int) c;, + }, + case '\\':, + return "\\\\";]
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, + passes.add(new DebugInfoParseVisitor());, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new ConstructorVisitor());, + passes.add(new TypeInferenceVisitor());, + passes.add(new DebugInfoApplyVisitor());, +++ b/.gitignore, +*.orig, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ConstructorVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoApplyVisitor;, +import jadx.core.dex.visitors.debuginfo.DebugInfoParseVisitor;, +import jadx.core.dex.visitors.typeinference.TypeInferenceVisitor;, + passes.add(new DebugInfoParseVisitor());, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, +
[+++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, + out.println(code);, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, + out.println(code);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + case MOVE_EXCEPTION:, + assert isFallback();, + code.add("move-exception");, + break;, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, + out.println(code);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + case MOVE_EXCEPTION:, + assert isFallback();, + code.add("move-exception");, + break;, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.instructions.args.NamedArg;, +import jadx.core.dex.regions.TryCatchRegion;, + } else if (cont instanceof TryCatchRegion) {, + makeTryCatch((TryCatchRegion) cont, code);, + private void makeTryCatch(TryCatchRegion region, CodeWriter code) throws CodegenException {, + TryCatchBlock tryCatchBlock = region.geTryCatchBlock();, + makeRegionIndent(code, region.getTryRegion());, + // TODO: move search of 'allHandler' to 'TryCatchRegion', + private void makeCatchBlock(CodeWriter code, ExceptionHandler handler) throws CodegenException {, + if (region == null) {,
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/EncValueParser.java, + int argAndType = readByte();, + return (char) parseUnsignedInt(size);, +, + return Float.intBitsToFloat((int) parseNumber(size, false, 4));, + return Double.longBitsToDouble(parseNumber(size, false, 8));, + return dex.getString(parseUnsignedInt(size));, + return dex.getType(parseUnsignedInt(size));, + return MethodInfo.fromDex(dex, parseUnsignedInt(size));, + return FieldInfo.fromDex(dex, parseUnsignedInt(size));, + private int parseUnsignedInt(int byteCount) {, + return (int) parseNumber(byteCount, false, 0);, +, + private long parseNumber(int byteCount, boolean isSignExtended) {, + return parseNumber(byteCount, isSignExtended, 0);, + }, +, + private long parseNumber(int byteCount, boolean isSignExtended, int fillOnRight) {, + long result = 0;, + long last = 0;, + for (int i = 0; i < byteCount; i++) {, + last
[+++ b/jadx-core/src/test/java/jadx/tests/integration/enums/TestEnumsInterface.java, +package jadx.tests.integration.enums;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +import jadx.tests.api.utils.JadxMatchers;, +import org.junit.Test;, +, +import static org.junit.Assert.assertThat;, +, +public class TestEnumsInterface extends IntegrationTest {, +, + public static class TestCls {, +, + public enum Operation implements IOperation {, + PLUS {, + public int apply(int x, int y) {, + return x + y;, + }, + },, + MINUS {, + public int apply(int x, int y) {, + return x - y;, + }, + };, + }, +, + public interface IOperation {, + int apply(int x, int y);, + }, + }, +, +
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, + private int[] resourceIds;, + int size = is.readInt32();, + int len = (size - 8) / 4;, + resourceIds = new int[len];, + for (int i = 0; i < len; i++) {, + resourceIds[i] = is.readInt32();, + nsMap.computeIfAbsent(getString(beginURI), k -> getString(beginPrefix));, + nsMap.computeIfAbsent(getString(endURI), k -> getString(endPrefix));, + String str = getString(strIndex);, + currentTag = getString(startNSName);, + writer.add(getAttributeNS(attributeNS)).add(':');, + String attrName = getAttributeName(attributeName);, + private String getAttributeNS(int attributeNS) {, + String attrUrl = getString(attributeNS);, + if (attrUrl == null || attrUrl.isEmpty()) {, + if (isResInternalId(attributeNS)) {, + return null;, + } else {, + attrUrl =
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, + public void forceRenameField(FieldNode field) {, + field.getFieldInfo().setAlias(makeFieldAlias(field));, + }, +, + public void forceRenameMethod(MethodNode mth) {, + mth.getMethodInfo().setAlias(makeMethodAlias(mth));, + if (mth.isVirtual()) {, + resolveOverriding(mth);, + }, + }, +, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, + public void forceRenameField(FieldNode field) {, + field.getFieldInfo().setAlias(makeFieldAlias(field));, + }, +, + public void forceRenameMethod(MethodNode mth) {, + mth.getMethodInfo().setAlias(makeMethodAlias(mth));, + if (mth.isVirtual()) {, + resolveOverriding(mth);, + }, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/info/FieldInfo.java, + public boolean equalsNameAndType(FieldInfo other) {, + return name.equals(other.name) && type.equals(other.type);, + }, +, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, + public void forceRenameField(FieldNode field) {, + field.getFieldInfo().setAlias(makeFieldAlias(field));, + }, +, + public void forceRenameMethod(MethodNode mth) {,
[+++ b/.gitignore, +classes/, +++ b/.gitignore, +classes/, +++ b/.travis.yml, +++ b/.gitignore, +classes/, +++ b/.travis.yml, +++ b/jadx-core/build.gradle, + compile files('lib/dx-1.13.jar'), +++ b/.gitignore, +classes/, +++ b/.travis.yml, +++ b/jadx-core/build.gradle, + compile files('lib/dx-1.13.jar'), +++ b/jadx-core/lib/dx-1.13.jar, +++ b/.gitignore, +classes/, +++ b/.travis.yml, +++ b/jadx-core/build.gradle, + compile files('lib/dx-1.13.jar'), +++ b/jadx-core/lib/dx-1.13.jar, +++ b/jadx-core/src/main/java/jadx/core/utils/files/JavaToDex.java, +import com.android.dx.command.dexer.DxContext;, +import jadx.core.utils.exceptions.JadxException;, +, + ByteArrayOutputStream out = new ByteArrayOutputStream();, + DxContext context = new DxContext(out, errOut);, + int result = (new Main(context)).runDx(args);, + if (result != 0) {, + throw new JadxException("Java to dex conversion error, code: " + result);, + }, + dxErrors = errOut.toString(CHARSET_NAME);, + return out.toByteArray();, + } catch (Exception
[+++ b/jadx-core/src/main/java/jadx/core/Consts.java, +, + public static final String MTH_TOSTRING_SIGNATURE = "toString()Ljava/lang/String;";, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, +, + public static final String MTH_TOSTRING_SIGNATURE = "toString()Ljava/lang/String;";, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, + StringBuilder signature = new StringBuilder();, + signature.append(name);, + signature.append('(');, + for (ArgType arg : args) {, + signature.append(TypeGen.signature(arg));, + }, + signature.append(')');, + signature.append(TypeGen.signature(retType));, + shortId = signature.toString();, + return declClass.getFullName() + "." + name, + + "(" + Utils.listToString(args) + "):" + retType;, +++ b/jadx-core/src/main/java/jadx/core/Consts.java, +, + public static final String MTH_TOSTRING_SIGNATURE = "toString()Ljava/lang/String;";, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, + StringBuilder signature = new StringBuilder();, + signature.append(name);, + signature.append('(');, + for (ArgType arg : args) {,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.Consts;, +import jadx.core.dex.info.ClassInfo;, +import jadx.core.utils.Utils;, + if (Consts.DEBUG) {, + code.add(mth.isVirtual() ? "/* virtual */ " : "/* direct */ ");, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.Consts;, +import jadx.core.dex.info.ClassInfo;, +import jadx.core.utils.Utils;, + if (Consts.DEBUG) {, + code.add(mth.isVirtual() ? "/* virtual */ " : "/* direct */ ");, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import com.android.dx.rop.code.AccessFlags;, +, + runAfter = {, + ModVisitor.class,, + FixAccessModifiers.class, + }, + AccessInfo wrappedAccFlags = wrappedMth.getAccessFlags();, + if (wrappedAccFlags.isStatic()) {, + return false;, + }, + if (!wrappedAccFlags.isPublic()) {, + // must be public, + FixAccessModifiers.changeVisibility(wrappedMth, AccessFlags.ACC_PUBLIC);, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, +import jadx.core.Consts;, +import jadx.core.dex.info.ClassInfo;,
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + FieldNode fieldNode = pCls.dex().root().deepResolveField(field);, + if (fieldNode == null) {, + } else {, + code.add(fieldNode.getAlias());, + }, + FieldNode fieldNode = clsGen.getClassNode().dex().root().deepResolveField(field);, + if (fieldNode == null) {, + } else {, + code.add(fieldNode.getAlias());, + }, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + *, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + FieldNode fieldNode = pCls.dex().root().deepResolveField(field);, + if (fieldNode == null) {, + } else {, + code.add(fieldNode.getAlias());, + }, + FieldNode fieldNode = clsGen.getClassNode().dex().root().deepResolveField(field);, + if (fieldNode == null) {, + } else {, + code.add(fieldNode.getAlias());, + }, +++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, + ClassNode superClass = cls.getSuperClassNode();,
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, + // remove public empty constructors (static or default), + && mth.getArguments(false).isEmpty()) {, + if (af.isStatic() && mth.getMethodInfo().isClassInit()) {, + mth.add(AFlag.DONT_GENERATE);, + } else {, + // don't remove default constructor if other constructors exists, + if (mth.isDefaultConstructor() && !isNonDefaultConstructorExists(mth)) {, + }, +, + private static boolean isNonDefaultConstructorExists(MethodNode defCtor) {, + ClassNode parentClass = defCtor.getParentClass();, + for (MethodNode mth : parentClass.getMethods()) {, + if (mth != defCtor, + && mth.getAccessFlags().isConstructor(), + && mth.getMethodInfo().isConstructor(), + && !mth.isDefaultConstructor()) {, + return true;, + }, + }, + return false;, + }, +}, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, + // remove public
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<?> jcw) {, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<?> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<?> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<?> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.CodeShrinker;, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.blocksmaker.BlockFinallyExtract;, +import jadx.core.dex.visitors.regions.ProcessVariables;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new BlockProcessor());, + passes.add(new BlockExceptionHandler());, + passes.add(new BlockFinallyExtract());, + passes.add(new BlockFinish());, +, + passes.add(new SSATransform());, + passes.add(new DebugInfoVisitor());, + passes.add(new TypeInference());, +, + passes.add(new FinishTypeInference());, + passes.add(new
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/EnumVisitor.java, +import jadx.core.dex.instructions.args.RegisterArg;, +import org.jetbrains.annotations.Nullable;, + return castConstructorInsn(((InsnWrapArg) arg).getWrapInsn());, + if (arg.isRegister()) {, + return castConstructorInsn(((RegisterArg) arg).getAssignInsn());, + }, + return null;, + }, +, + @Nullable, + private ConstructorInsn castConstructorInsn(InsnNode coCandidate) {, + if (coCandidate != null && coCandidate.getType() == InsnType.CONSTRUCTOR) {, + return (ConstructorInsn) coCandidate;]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +, +/* TODO:, + Don't die when error occurs, + Check error cases, maybe checked const values are not always the same, + Better error messages, + What to do, when Binary XML Manifest is > size(int)?, + Check for missung chunk size types, + Implement missing data types, + Use linenumbers to recreate EXACT AndroidManifest, + Check Element chunk size, +*/, + private PrintWriter writer;, + private Map<Integer, String> styleMap = null;, +, + count+=4; // TODO: Check element chunk size, + // FIXME: What to do, when data is always -1?]
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java, +import java.io.IOException;, + private static boolean isInSubDirectoryInternal(File baseDir, File canonFile) {, + if (canonFile == null) {, + if (canonFile.equals(baseDir)) {, + return isInSubDirectoryInternal(baseDir, canonFile.getParentFile());, + }, + , + public static boolean isInSubDirectory(File baseDir, File file) {, + try {, + file = file.getCanonicalFile();, + }, + catch(IOException e) {, + return false;, + }, + return isInSubDirectoryInternal(baseDir, file);, + if (isInSubDirectoryInternal(currentPath, canonical)) {, +++ b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java, +import java.io.IOException;, + private static boolean isInSubDirectoryInternal(File baseDir, File canonFile) {, + if (canonFile == null) {, + if (canonFile.equals(baseDir)) {, + return isInSubDirectoryInternal(baseDir, canonFile.getParentFile());, + }, + , +
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + int importsCount = imports.size();, + if (importsCount != 0) {, + List<String> sortImports = new ArrayList<String>(importsCount);, + for (ClassInfo ic : imports) {, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + int importsCount = imports.size();, + if (importsCount != 0) {, + List<String> sortImports = new ArrayList<String>(importsCount);, + for (ClassInfo ic : imports) {, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, + return fullName;, + return fullName.hashCode();]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.nodes.parser.FieldValueAttr;, + // print original value, sometimes replace with incorrect field, + FieldValueAttr valueAttr = fn.get(AType.FIELD_VALUE);, + if (valueAttr != null && valueAttr.getValue() != null) {, + code.add(" /*").add(valueAttr.getValue().toString()).add("*/");, + }, + } else if (k instanceof Integer) {, + } else {, + throw new JadxRuntimeException("Unexpected key in switch: " + (k != null ? k.getClass() : k));, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +import jadx.core.dex.nodes.parser.FieldValueAttr;, + // print original value, sometimes replace with incorrect field, + FieldValueAttr valueAttr = fn.get(AType.FIELD_VALUE);, + if (valueAttr != null && valueAttr.getValue() != null) {, + code.add(" /*").add(valueAttr.getValue().toString()).add("*/");, + }, + } else
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + ClassInfo importClassInfo = ClassInfo.fromName(cls.dex().root(), imp);, + ClassNode classNode = cls.dex().resolveClass(importClassInfo);, + // Clickable element seems to be limited by the next dot, therefore, + // we can't just use the complete class name including packagename, + int clsDotIdx = imp.lastIndexOf('.');, + String pkg = "";, + if (clsDotIdx >= 0) {, + pkg = imp.substring(0, clsDotIdx + 1);, + imp = imp.substring(clsDotIdx + 1);, + }, + clsCode.startLine("import ");, + clsCode.add(pkg);, + if (classNode != null) {, + // attach the clickable link info to the class name, + clsCode.attachAnnotation(classNode);, + }, + clsCode.add(imp);, + clsCode.add(';');]
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.xmlgen.BinaryXMLParser;, +, + BinaryXMLParser bxp = new BinaryXMLParser(args[0]);, + bxp.parse();, + System.exit(4);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.xmlgen.BinaryXMLParser;, +, + BinaryXMLParser bxp = new BinaryXMLParser(args[0]);, + bxp.parse();, + System.exit(4);, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +package jadx.core.xmlgen;, +, +import java.nio.ByteBuffer;, +import java.nio.charset.Charset;, +import java.io.BufferedInputStream;, +import java.io.File;, +import java.io.FileInputStream;, +import java.io.FileNotFoundException;, +import java.io.InputStream;, +import java.io.IOException;, +import java.io.UnsupportedEncodingException;, +, +public class BinaryXMLParser {, + private byte[] bytes;, + private String[] strings;, + private int count;, + private String nsPrefix="ERROR";, + public BinaryXMLParser(String xmlfilepath) {, + System.out.println(xmlfilepath);, + File manifest = new File(xmlfilepath);, + if(null==manifest) die("null==manifest");, + bytes = new byte[(int) manifest.length()];, + try {,
[+++ b/.editorconfig, +# EditorConfig is awesome: https://EditorConfig.org, +root = true, +, +[*], +end_of_line = lf, +insert_final_newline = true, +, +indent_style = tab, +tab_width = 4, +, +charset = utf-8, +trim_trailing_whitespace = true, +, +[*.xml], +indent_size = 1, +, +[*.yml], +indent_style = space, +indent_size = 2, +, +[*.bat], +end_of_line = crlf, +++ b/.editorconfig, +# EditorConfig is awesome: https://EditorConfig.org, +root = true, +, +[*], +end_of_line = lf, +insert_final_newline = true, +, +indent_style = tab, +tab_width = 4, +, +charset = utf-8, +trim_trailing_whitespace = true, +, +[*.xml], +indent_size = 1, +, +[*.yml], +indent_style = space, +indent_size = 2, +, +[*.bat], +end_of_line =
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, + public boolean checkOffset(int dataOffset) {, + return dataOffset >= 0 && dataOffset < dexBuf.getLength();, + }, +, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/DexNode.java, + public boolean checkOffset(int dataOffset) {, + return dataOffset >= 0 && dataOffset < dexBuf.getLength();, + }, +, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DebugInfoVisitor.java, + if (debugOffset > 0 && mth.dex().checkOffset(debugOffset)) {]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new DebugInfoVisitor());, + passes.add(new TypeInference());, +, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new FinishTypeInference());, +, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new DebugInfoVisitor());, + passes.add(new TypeInference());, +, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, + private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new DebugInfoVisitor());,
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.xmlgen.BinaryXMLParser;, + BinaryXMLParser bxp = new BinaryXMLParser(args[0],args[1]);, + bxp.parse();, + System.exit(4);, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.xmlgen.BinaryXMLParser;, + BinaryXMLParser bxp = new BinaryXMLParser(args[0],args[1]);, + bxp.parse();, + System.exit(4);, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, + writer.println("<?xml version=\"1.0\" encoding=\"utf-8\"?>");]
[+++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.xmlgen.ResTableParser;, +public final class ResourcesLoader {, + private static final int LOAD_SIZE_LIMIT = 10 * 1024 * 1024;, +, + case ARSC:, + return new ResTableParser().decodeToCodeWriter(inputStream);, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.xmlgen.ResTableParser;, +public final class ResourcesLoader {, + private static final int LOAD_SIZE_LIMIT = 10 * 1024 * 1024;, +, + case ARSC:, + return new ResTableParser().decodeToCodeWriter(inputStream);, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, +public class BinaryXMLParser extends CommonBinaryParser {, + strings = parseStringPoolNoType();, + writer.add("UNKNOWN_DATA_TYPE_0x" + Integer.toHexString(attrValDataType));, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.xmlgen.ResTableParser;, +public final class ResourcesLoader {, + private static final int LOAD_SIZE_LIMIT = 10 * 1024
[+++ b/.gitignore, +*.orig, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, + outDirName = name + '-' + JadxArgs.DEFAULT_OUT_DIR;, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, + outDirName = name + '-' + JadxArgs.DEFAULT_OUT_DIR;, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + List<IDexTreeVisitor> getPasses() {, + return passes;, + }, +, +++ b/.gitignore, +*.orig, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + private boolean process(JCommanderWrapper<JadxCLIArgs> jcw) {, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +++
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, + case TERNARY:, + addTernary(code, condition);, + break;, +, + throw new JadxRuntimeException("Unknown condition mode: " + condition.getMode());, + private void addTernary(CodeWriter code, IfCondition condition) throws CodegenException {, + add(code, condition.first());, + code.add(" ? ");, + add(code, condition.second());, + code.add(" : ");, + add(code, condition.third());, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, + case TERNARY:, + addTernary(code, condition);, + break;, +, + throw new JadxRuntimeException("Unknown condition mode: " + condition.getMode());, + private void addTernary(CodeWriter code, IfCondition condition) throws CodegenException {, + add(code, condition.first());, + code.add(" ? ");, + add(code, condition.second());, + code.add(" : ");, + add(code, condition.third());, + },
[+++ b/jadx-cli/build.gradle, +++ b/jadx-cli/build.gradle, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, + if(pkg.length() == 0) {, + parClsName = clsName.substring(0, sep);, + }, +, +++ b/jadx-cli/build.gradle, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, + if(pkg.length() == 0) {, + parClsName = clsName.substring(0, sep);, + }, +, +++ b/jadx-gui/build.gradle]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/DepthRegionTraversal.java, +import jadx.core.utils.exceptions.JadxOverflowException;, + private static final int ITERATIVE_LIMIT = 500;, +, + int k = 0;, + if (k++ > ITERATIVE_LIMIT) {, + throw new JadxOverflowException("Iterative traversal limit reached, method: " + mth);, + }]
[+++ b/jadx-core/src/main/java/jadx/api/JavaPackage.java, + if (this == o) {, + if (o == null || getClass() != o.getClass()) {, + return false;, + }, + JavaPackage that = (JavaPackage) o;, + return name.equals(that.name);, + }, +++ b/jadx-core/src/main/java/jadx/api/JavaPackage.java, + if (this == o) {, + if (o == null || getClass() != o.getClass()) {, + return false;, + }, + JavaPackage that = (JavaPackage) o;, + return name.equals(that.name);, + }, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + if (Consts.DEBUG) {, + }, + if (Jadx.class.desiredAssertionStatus()) {, + }, + if (args.isRawCFGOutput()) {, + }, + if (args.isCFGOutput()) {, + }, +, + if (args.isCFGOutput()) {,
[+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, +, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, +, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, + Enumeration en = this.breadthFirstEnumeration();, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, +, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, + Enumeration en = this.breadthFirstEnumeration();, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, + private JList resultsList;, + private static class ResultsModel extends DefaultListModel {, + private static class ResultsCellRenderer implements ListCellRenderer {, + public Component getListCellRendererComponent(JList list,, + resultsList = new JList(resultsModel);, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JNode.java, +, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, + Enumeration en = this.breadthFirstEnumeration();, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, + private JList resultsList;, + private static class ResultsModel extends DefaultListModel {, + private static class ResultsCellRenderer implements ListCellRenderer {, + public Component getListCellRendererComponent(JList list,, + resultsList = new JList(resultsModel);, +++ b/jadx-gui/src/main/java/jadx/gui/utils/Link.java]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/BlockMakerVisitor.java, +import jadx.core.dex.instructions.args.ArgType;, +import java.util.Iterator;, + if (mth.isNoCode()) {, + }, + if (type == InsnType.RETURN || type == InsnType.THROW) {, + }, + if (type == InsnType.MONITOR_ENTER || type == InsnType.MONITOR_EXIT) {, + }, + if (jump.getSrc() == prevInsn.getOffset()) {, + }, + if (jump.getDest() == insn.getOffset()) {, + }, + if (targBlock == curBlock) {, + }, + if (connBlock != destBlock) {, + }, + if (i > 100) {, + }, + if (!from.getSuccessors().contains(to)) {, + }, + if (!to.getPredecessors().contains(from)) {, + }, + if (block == entryBlock) {, + }, + if (!d.equals(dset))
[+++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, + LOG.debug("processing class {} ...", cls);, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, + LOG.debug("processing class {} ...", cls);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ssa.SSATransform;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new SSATransform());, + passes.add(new TypeInference());, + passes.add(new ConstInlinerVisitor());, + passes.add(new FinishTypeInference());, + passes.add(new EliminatePhiNodes());, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, + LOG.debug("processing class {} ...", cls);, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.ssa.SSATransform;, +import jadx.core.dex.visitors.ssa.EliminatePhiNodes;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new SSATransform());, + passes.add(new TypeInference());, + passes.add(new ConstInlinerVisitor());, + passes.add(new FinishTypeInference());, + passes.add(new EliminatePhiNodes());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + instanceField(code, f.getField(), f.getRegisterArg());, + makeArithOneArg((ArithNode) insn, code);, + makeConstructor((ConstructorInsn) insn, code);, + case PHI:, + break;, +, + private void makeConstructor(ConstructorInsn insn,
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * JadxDecompiler jadx = new JadxDecompiler();, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * JadxDecompiler jadx = new JadxDecompiler();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + instanceField(code, f.getField(), f.getInstanceArg());, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + * JadxDecompiler jadx = new JadxDecompiler();, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + instanceField(code, f.getField(), f.getInstanceArg());, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/FieldArg.java, + // instArg equal 'null' for static fields, + private final InsnArg instArg;, + public FieldArg(FieldInfo field, InsnArg reg) {, + this.instArg = reg;, + public InsnArg getInstanceArg() {, + return instArg;, + return instArg == null;, + if (instArg != null ? !instArg.equals(fieldArg.instArg) : fieldArg.instArg != null) {, + result = 31 * result + (instArg !=
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + }, + if (isClassInnerFor(useCls, extClsInfo)) {, + return shortName;, + }, + if (isBothClassesInOneTopClass(useCls, extClsInfo)) {, + private static boolean isBothClassesInOneTopClass(ClassInfo useCls, ClassInfo extClsInfo) {, + ClassInfo a = useCls.getTopParentClass();, + ClassInfo b = extClsInfo.getTopParentClass();, + if (a != null) {, + return a.equals(b);, + }, + // useCls - is a top class, + return useCls.equals(b);, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + }, + if (isClassInnerFor(useCls, extClsInfo)) {, + return shortName;, + }, + if (isBothClassesInOneTopClass(useCls, extClsInfo)) {, + private static boolean isBothClassesInOneTopClass(ClassInfo useCls, ClassInfo extClsInfo) {, + ClassInfo a = useCls.getTopParentClass();, + ClassInfo b
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, + } catch (Exception e) {]
[+++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, + private boolean useImports = true;]
[+++ b/.travis.yml, + - openjdk6, +++ b/.travis.yml, + - openjdk6, +++ b/jadx-core/build.gradle, + compile files('lib/dx-1.10.jar'), +++ b/.travis.yml, + - openjdk6, +++ b/jadx-core/build.gradle, + compile files('lib/dx-1.10.jar'), +++ b/jadx-core/lib/dx-1.10.jar, +++ b/.travis.yml, + - openjdk6, +++ b/jadx-core/build.gradle, + compile files('lib/dx-1.10.jar'), +++ b/jadx-core/lib/dx-1.10.jar, +++ /dev/null, +++ b/.travis.yml, + - openjdk6, +++ b/jadx-core/build.gradle, + compile files('lib/dx-1.10.jar'), +++ b/jadx-core/lib/dx-1.10.jar, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +import java.util.Enumeration;, +, + // Input file could be .apk or .zip files, + // we should consider the input file could contain only one single dex, multi-dex, or instantRun support dex for Android .apk files, + String instantRunDexSuffix = "classes" +
[+++ b/.travis.yml, +script:, + - TERM=dumb ./gradlew clean build dist, +++ b/.travis.yml, +script:, + - TERM=dumb ./gradlew clean build dist, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.utils.exceptions.JadxException;, + private static void checkArgs(JadxCLIArgs jadxArgs) throws JadxException {, + throw new JadxException("Output directory exists as file " + outputDir);, +++ b/.travis.yml, +script:, + - TERM=dumb ./gradlew clean build dist, +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLI.java, +import jadx.core.utils.exceptions.JadxException;, + private static void checkArgs(JadxCLIArgs jadxArgs) throws JadxException {, + throw new JadxException("Output directory exists as file " + outputDir);, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import jadx.core.utils.exceptions.JadxRuntimeException;, + private static final String STRING_CHARSET = "US-ASCII";, +, + throw new JadxRuntimeException("Duplicate class: " + clsRawName);,
[+++ b/jadx-core/src/test/java/jadx/tests/api/utils/TestUtils.java, +import org.junit.jupiter.api.extension.ExtendWith;, +, +import jadx.NotYetImplementedExtension;, +@ExtendWith(NotYetImplementedExtension.class), +++ b/jadx-core/src/test/java/jadx/tests/api/utils/TestUtils.java, +import org.junit.jupiter.api.extension.ExtendWith;, +, +import jadx.NotYetImplementedExtension;, +@ExtendWith(NotYetImplementedExtension.class), +++ b/jadx-core/src/test/java/jadx/tests/integration/generics/MissingGenericsTypesTest.java, +package jadx.tests.integration.generics;, +, +import static org.hamcrest.MatcherAssert.assertThat;, +import static org.hamcrest.Matchers.containsString;, +, +import org.junit.jupiter.api.Test;, +, +import jadx.NotYetImplemented;, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.SmaliTest;, +, +public class MissingGenericsTypesTest extends SmaliTest {, +, + /*, + private int x;, +, + public void test() {, + Map<String, String> map = new HashMap();, + x = 1;, + for (String s : map.keySet()) {, + System.out.println(s);, + }, + }, + */, +, + @Test, + @NotYetImplemented, + public void test() {, + ClassNode cls = getClassNodeFromSmaliWithPath("generics", "MissingGenericsTypesTest");,
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, + if (obj instanceof Integer) {, + ResRefField resField = new ResRefField(dex, str.replace('/', '.'));, + if (field == null) {, + return resField;, + }, + if (!field.getName().equals(resField.getName())) {, + field = resField;, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, + if (obj instanceof Integer) {, + ResRefField resField = new ResRefField(dex, str.replace('/', '.'));, + if (field == null) {, + return resField;, + }, + if (!field.getName().equals(resField.getName())) {, + field = resField;, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ConstInlinerVisitor.java, +import jadx.core.dex.instructions.args.PrimitiveType;, +import jadx.core.dex.visitors.typeinference.PostTypeInference;, + FieldNode f = null;, + ArgType litArgType = litArg.getType();, + if (litArgType.isTypeKnown()) {, + f = mth.getParentClass().getConstFieldByLiteralArg(litArg);, +
[+++ b/jadx-gui/build.gradle, + compile 'com.google.code.gson:gson:2.2.4', +++ b/jadx-gui/build.gradle, + compile 'com.google.code.gson:gson:2.2.4', +++ b/jadx-gui/src/main/java/jadx/gui/ui/AboutDialog.java, +import jadx.api.JadxDecompiler;, +import javax.swing.BorderFactory;, + JLabel name = new JLabel("jadx");, + JLabel version = new JLabel("version: " + JadxDecompiler.getVersion());, + textPane.setBorder(BorderFactory.createEmptyBorder(15, 15, 15, 15));, +++ b/jadx-gui/build.gradle, + compile 'com.google.code.gson:gson:2.2.4', +++ b/jadx-gui/src/main/java/jadx/gui/ui/AboutDialog.java, +import jadx.api.JadxDecompiler;, +import javax.swing.BorderFactory;, + JLabel name = new JLabel("jadx");, + JLabel version = new JLabel("version: " + JadxDecompiler.getVersion());, + textPane.setBorder(BorderFactory.createEmptyBorder(15, 15, 15, 15));, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +import jadx.gui.update.JadxUpdate;, +import jadx.gui.update.data.Release;, +import jadx.gui.utils.Link;, +import javax.swing.Box;, + private Link updateLink;, + JadxUpdate.check(new JadxUpdate.IUpdateCallback() {, + @Override, + public void onUpdate(final Release r) {, + SwingUtilities.invokeLater(new Runnable() {, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +, + assignInsn.getResult().add(AFlag.DONT_GENERATE);, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +, + assignInsn.getResult().add(AFlag.DONT_GENERATE);, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/variables/CollectUsageRegionVisitor.java, + private final List<RegisterArg> args = new ArrayList<>();, + private final Map<SSAVar, VarUsage> usageMap = new LinkedHashMap<>();, + if (!arg.contains(AFlag.DONT_GENERATE)) {, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +, + assignInsn.getResult().add(AFlag.DONT_GENERATE);, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/variables/CollectUsageRegionVisitor.java, + private final List<RegisterArg> args = new ArrayList<>();, + private final Map<SSAVar, VarUsage> usageMap = new LinkedHashMap<>();, + if (!arg.contains(AFlag.DONT_GENERATE)) {, + }, +++ /dev/null, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, +, + assignInsn.getResult().add(AFlag.DONT_GENERATE);, +, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/variables/CollectUsageRegionVisitor.java, + private final List<RegisterArg> args = new ArrayList<>();, + private final Map<SSAVar, VarUsage> usageMap = new LinkedHashMap<>();, + if (!arg.contains(AFlag.DONT_GENERATE)) {,
[+++ b/NOTICE, +Image Viewer (https://github.com/kazocsaba/imageviewer), +, +*******************************************************************************, +Copyright (c) 2008-2012 Kazó Csaba, +, +Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:, +, +The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + root.getClsp().printMissingClasses();, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + root.getClsp().printMissingClasses();, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +import java.util.ArrayList;, + private final Set<String> missingClasses = new HashSet<String>();, +, + missingClasses.add(clsName);, + missingClasses.add(clsName);, +, + public void printMissingClasses() {, + int count = missingClasses.size();, + if (count == 0) {, + return;, + }, + LOG.warn("Found {} references to unknown classes", count);, + if (LOG.isDebugEnabled()) {, + List<String> clsNames = new ArrayList<String>(missingClasses);, + Collections.sort(clsNames);, + for (String cls : clsNames) {, + LOG.debug(" {}", cls);, + }, + }, + }, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + root.getClsp().printMissingClasses();, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, +import java.util.ArrayList;, + private final Set<String> missingClasses = new HashSet<String>();,
[+++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, + if (jadxArgs.getInput().isEmpty()) {, + mainWindow.openFile();, + } else {, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, + if (jadxArgs.getInput().isEmpty()) {, + mainWindow.openFile();, + } else {, +++ b/jadx-gui/src/main/java/jadx/gui/MainWindow.java, + private static final File WORK_DIR = new File(System.getProperty("user.dir"));, +, + public void openFile() {, + JFileChooser fileChooser = new JFileChooser();, + fileChooser.setAcceptAllFileFilterUsed(true);, + fileChooser.setFileFilter(new FileNameExtensionFilter("supported files", "dex", "apk", "jar"));, + fileChooser.setToolTipText(NLS.str("file.open"));, + // fileChooser.setCurrentDirectory(WORK_DIR);, + int ret = fileChooser.showDialog(mainPanel, NLS.str("file.open"));, + if (ret == JFileChooser.APPROVE_OPTION) {, + openFile(fileChooser.getSelectedFile());, + }, + }, +, + fileChooser.setToolTipText(NLS.str("file.save_all_msg"));, + int ret = fileChooser.showDialog(mainPanel, NLS.str("file.select"));, + openFile();, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, + if (jadxArgs.getInput().isEmpty()) {, + mainWindow.openFile();, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockSplitter.java, + connectExceptionHandlers(block, insn, blocksMap);, + private static void connectExceptionHandlers(BlockNode block, InsnNode insn,, + Map<Integer, BlockNode> blocksMap) {, + BlockNode handlerBlock = initHandlerBlock(h, blocksMap);, + private static BlockNode initHandlerBlock(ExceptionHandler excHandler, Map<Integer, BlockNode> blocksMap) {, + BlockNode handlerBlock = excHandler.getHandlerBlock();, + if (handlerBlock != null) {, + return handlerBlock;, + }, + BlockNode blockByOffset = getBlock(excHandler.getHandleOffset(), blocksMap);, + excHandler.setHandlerBlock(blockByOffset);, + return blockByOffset;, + }, +]
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + private Map<ClassNode, JavaClass> classesMap = new java.util.concurrent.ConcurrentHashMap<ClassNode, JavaClass>();, + private Map<MethodNode, JavaMethod> methodsMap = new java.util.concurrent.ConcurrentHashMap<MethodNode, JavaMethod>();, + private Map<FieldNode, JavaField> fieldsMap = new java.util.concurrent.ConcurrentHashMap<FieldNode, JavaField>();, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + private Map<ClassNode, JavaClass> classesMap = new java.util.concurrent.ConcurrentHashMap<ClassNode, JavaClass>();, + private Map<MethodNode, JavaMethod> methodsMap = new java.util.concurrent.ConcurrentHashMap<MethodNode, JavaMethod>();, + private Map<FieldNode, JavaField> fieldsMap = new java.util.concurrent.ConcurrentHashMap<FieldNode, JavaField>();, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, + private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + private Map<ClassNode, JavaClass> classesMap = new java.util.concurrent.ConcurrentHashMap<ClassNode, JavaClass>();, + private Map<MethodNode, JavaMethod> methodsMap = new java.util.concurrent.ConcurrentHashMap<MethodNode, JavaMethod>();, + private Map<FieldNode, JavaField> fieldsMap = new java.util.concurrent.ConcurrentHashMap<FieldNode, JavaField>();,
[+++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, + return regNum;]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java, + || exitBlock.contains(AFlag.SYNTHETIC), + || exitBlock.contains(AType.SPLITTER_BLOCK)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockProcessor.java, + || exitBlock.contains(AFlag.SYNTHETIC), + || exitBlock.contains(AType.SPLITTER_BLOCK)) {, +++ b/jadx-core/src/test/java/jadx/tests/integration/trycatch/TestTryCatchNoMove.java, +package jadx.tests.integration.trycatch;, +, +import org.junit.Test;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.SmaliTest;, +, +import static jadx.tests.api.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestTryCatchNoMove extends SmaliTest {, +, +// private static void test(AutoCloseable closeable) {, +// if (closeable != null) {, +// try {, +// closeable.close();, +// } catch (Exception ignored) {, +// }, +// }, +// }, +, + @Test, + public void test() {, + ClassNode cls = getClassNodeFromSmaliWithPath("trycatch", "TestTryCatchNoMove");, + String code = cls.getCode().toString();, +, + assertThat(code, containsOne("if (autoCloseable
[+++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/SplitterBlockAttr.java, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/SplitterBlockAttr.java, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, + fixSplitterBlock(mth, block);, + private static void fixSplitterBlock(MethodNode mth, BlockNode block) {, + mth.addWarn("Unknown top exception splitter block from list: " + splitters);, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/SplitterBlockAttr.java, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, + fixSplitterBlock(mth, block);, + private static void fixSplitterBlock(MethodNode mth, BlockNode block) {, + mth.addWarn("Unknown top exception splitter block from list: " + splitters);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, + mth.addWarn("Missing block: " + block + ", code skipped:" + CodeWriter.NL + blockCode);, +++ b/jadx-core/src/main/java/jadx/core/dex/trycatch/SplitterBlockAttr.java, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/blocksmaker/BlockFinish.java, + fixSplitterBlock(mth, block);, + private static void fixSplitterBlock(MethodNode mth, BlockNode block) {, + mth.addWarn("Unknown top exception splitter block from list: " + splitters);,
[+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, +import java.util.Enumeration;, + public JClass searchClassInTree(JClass node) {, + Enumeration en = this.breadthFirstEnumeration();, + while (en.hasMoreElements()) {, + Object obj = en.nextElement();, + if (node.equals(obj)) {, + return (JClass) obj;, + }, + }, + return null;, + }, +, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, +import java.util.Enumeration;, + public JClass searchClassInTree(JClass node) {, + Enumeration en = this.breadthFirstEnumeration();, + while (en.hasMoreElements()) {, + Object obj = en.nextElement();, + if (node.equals(obj)) {, + return (JClass) obj;, + }, + }, + return null;, + }, +, +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, + private JRoot treeRoot;, + treeRoot = new JRoot(wrapper);, + if (jCls.getParent() ==
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (thisClass.startsWith(field.getDeclClass().getFullName())) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (thisClass.startsWith(field.getDeclClass().getFullName())) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/RegionGen.java, +, + // FIXME: !!code from InsnGen.sfield, + if (thisClass.startsWith(field.getDeclClass().getFullName())) {]
[+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, + public String getTestName() {, + return this.getClass().getSimpleName();, + }, +, + public String getTestPkg() {, + return this.getClass().getPackage().getName().replace("jadx.tests.integration.", "");, + }, +, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, + public String getTestName() {, + return this.getClass().getSimpleName();, + }, +, + public String getTestPkg() {, + return this.getClass().getPackage().getName().replace("jadx.tests.integration.", "");, + }, +, +++ b/jadx-core/src/test/java/jadx/tests/api/SmaliTest.java, +import jadx.api.JadxInternalAccess;, +import jadx.core.dex.nodes.RootNode;, + protected List<ClassNode> loadFromSmaliFiles() {, + compileSmali(outDex, collectSmaliFiles(getTestPkg(), getTestName()));, + JadxDecompiler d = loadFiles(Collections.singletonList(outDex));, + RootNode root = JadxInternalAccess.getRoot(d);, + List<ClassNode> classes = root.getClasses(false);, + for (ClassNode cls : classes) {, + decompileAndCheckCls(d, cls);, + }, + return classes;, + assertThat("Smali files not
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + char op = insn.getArg(0).getType() == ArgType.BOOLEAN ? '!' : '~';, + oneArgInsn(code, insn, state, op);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + char op = insn.getArg(0).getType() == ArgType.BOOLEAN ? '!' : '~';, + oneArgInsn(code, insn, state, op);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/SimplifyVisitor.java, +import jadx.core.dex.instructions.ArithNode;, +import jadx.core.dex.instructions.ArithOp;, +import jadx.core.dex.instructions.CallMthInterface;, +import jadx.core.dex.instructions.ConstStringNode;, +import jadx.core.dex.instructions.IfNode;, +import jadx.core.dex.instructions.IndexInsnNode;, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.dex.instructions.InvokeNode;, +import jadx.core.dex.instructions.args.RegisterArg;, + return simplifyArith((ArithNode) insn);, + return convertInvoke(mth, (InvokeNode) insn);, + private static InsnNode convertInvoke(MethodNode mth, InvokeNode insn) {, + MethodInfo callMth = insn.getCallMth();, + private static InsnNode simplifyArith(ArithNode arith) {, + arith.getResult(), arith.getArg(0),, + InsnArg firstArg = arith.getArg(0);, + if (arith.getOp() == ArithOp.XOR
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + public void addArgDot(CodeWriter code, InsnArg arg) throws CodegenException {, + int len = code.length();, + addArg(code, arg, true);, + if (len != code.length()) {, + code.add('.');, + }, + }, +, + addArgDot(code, arg);, + addArgDot(code, arg);, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + public void addArgDot(CodeWriter code, InsnArg arg) throws CodegenException {, + int len = code.length();, + addArg(code, arg, true);, + if (len != code.length()) {, + code.add('.');, + }, + }, +, + addArgDot(code, arg);, + addArgDot(code, arg);, +++ b/jadx-core/src/test/java/jadx/api/InternalJadxTest.java, +import jadx.core.codegen.CodeWriter;, + protected String makeIndent(int indent) {, + StringBuilder sb = new StringBuilder(indent * CodeWriter.INDENT.length());, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/regions/conditions/IfCondition.java, +import java.util.Objects;, + return ternary(cond.first(), not(cond.second()), not(cond.third()));, + if (cond.getCompare() != null) {, + return new IfCondition(cond.compare.invert());, + }, +, + @Override, + public boolean equals(Object obj) {, + if (this == obj) {, + return true;, + }, + if (!(obj instanceof IfCondition)) {, + return false;, + }, + IfCondition other = (IfCondition) obj;, + if (mode != other.mode) {, + return false;, + }, + return Objects.equals(other.args, other.args), + && Objects.equals(compare, other.compare);, + }, +, + @Override, + public int hashCode() {, + int result = super.hashCode();, + result = 31 * result +
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + passes.add(new EliminatePhiNodes());, + if (args.isCFGOutput()) {, + passes.add(new DotGraphVisitor(outDir, false));, + }, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, + passes.add(new EliminatePhiNodes());, + if (args.isCFGOutput()) {, + passes.add(new DotGraphVisitor(outDir, false));, + }, +, +++ b/jadx-core/src/main/java/jadx/core/codegen/ConditionGen.java, + boolean wrap = isArgWrapNeeded(firstArg);, + addArg(code, firstArg, isArgWrapNeeded(firstArg));, + addArg(code, secondArg, isArgWrapNeeded(secondArg));, + return !condition.isCompare() && condition.getMode() != IfCondition.Mode.NOT;, + private static boolean isArgWrapNeeded(InsnArg arg) {, + InsnType insnType = insn.getType();, + if (insnType == InsnType.ARITH) {, + } else {, + switch (insnType) {, + case INVOKE:, + case SGET:, + case IGET:, + case AGET:, + case CONST:, + case ARRAY_LENGTH:, +
[+++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.dex.attributes.AttributeFlag;, +, + private List<JavaClass> innerClasses = Collections.emptyList();, + private List<JavaField> fields = Collections.emptyList();, + private List<JavaMethod> methods = Collections.emptyList();, + }, +, + public void decompile() {, + decompiler.processClass(cls);, + if (inClsCount != 0) {, + if (!inner.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, + }, + if (fieldsCount != 0) {, + if (!f.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, + }, + if (methodsCount != 0) {, + if (!m.getAttributes().contains(AttributeFlag.DONT_GENERATE)) {, + mths.add(new JavaMethod(this, m));, + decompile();, +++ b/jadx-core/src/main/java/jadx/api/JavaClass.java, +import jadx.core.dex.attributes.AttributeFlag;, +, + private List<JavaClass> innerClasses = Collections.emptyList();, + private List<JavaField> fields = Collections.emptyList();, + private List<JavaMethod> methods = Collections.emptyList();, + }, +,
[+++ b/build.gradle, + apply plugin: 'groovy', +, + testCompile 'org.spockframework:spock-core:0.7-groovy-2.0' , + // setup coveralls (http://coveralls.io/) see http://github.com/kt3k/coveralls-gradle-plugin, +++ b/build.gradle, + apply plugin: 'groovy', +, + testCompile 'org.spockframework:spock-core:0.7-groovy-2.0' , + // setup coveralls (http://coveralls.io/) see http://github.com/kt3k/coveralls-gradle-plugin, +++ b/jadx-core/build.gradle, +task packTests(type: Jar) {, + classifier = 'tests', + from sourceSets.test.output, +}, +, +++ b/build.gradle, + apply plugin: 'groovy', +, + testCompile 'org.spockframework:spock-core:0.7-groovy-2.0' , + // setup coveralls (http://coveralls.io/) see http://github.com/kt3k/coveralls-gradle-plugin, +++ b/jadx-core/build.gradle, +task packTests(type: Jar) {, + classifier = 'tests', + from sourceSets.test.output, +}, +, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/SignatureParser.java, + return Collections.emptyMap();, +++ b/build.gradle, + apply plugin: 'groovy', +, + testCompile 'org.spockframework:spock-core:0.7-groovy-2.0'
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, + * uses generic type for omit cast after 'AttributeStorage.get' method, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, + * uses generic type for omit cast after 'AttributeStorage.get' method, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java, + attributes = new IdentityHashMap<AType<?>, IAttribute>();]
[+++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, + private MethodInfo(ClassInfo declClass, String name, List<ArgType> args, ArgType retType) {, + this.name = name;, + alias = name;, + aliasFromPreset = false;, + this.declClass = declClass;, +, + this.args = args;, + this.retType = retType;, + shortId = makeSignature(true);, + }, +, + public static MethodInfo externalMth(ClassInfo declClass, String name, List<ArgType> args, ArgType retType) {, + return new MethodInfo(declClass, name, args, retType);, + }, +, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, + private MethodInfo(ClassInfo declClass, String name, List<ArgType> args, ArgType retType) {, + this.name = name;, + alias = name;, + aliasFromPreset = false;, + this.declClass = declClass;, +, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, + boolean badThen = thenBlock.contains(AFlag.LOOP_START) || !allPathsFromIf(thenBlock, info);, + boolean badElse = elseBlock.contains(AFlag.LOOP_START) || !allPathsFromIf(elseBlock, info);, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, + boolean badThen = thenBlock.contains(AFlag.LOOP_START) || !allPathsFromIf(thenBlock, info);, + boolean badElse = elseBlock.contains(AFlag.LOOP_START) || !allPathsFromIf(elseBlock, info);, +++ b/jadx-core/src/test/java/jadx/tests/internal/loops/TestLoopDetection4.java, +package jadx.tests.internal.loops;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import java.util.Iterator;, +, +import org.junit.Test;, +, +import static jadx.tests.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestLoopDetection4 extends InternalJadxTest {, +, + public static class TestCls {, + private Iterator<String> iterator;, + private SomeCls filter;, +, + private String test() {, + while (iterator.hasNext()) {, + String next = iterator.next();, + String filtered =
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (!insn.contains(AFlag.DECLARE_VAR)) {, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + if (!insn.contains(AFlag.DECLARE_VAR)) {, + }, +++ b/jadx-core/src/test/java/jadx/tests/integration/arrays/TestArrayInit.java, +package jadx.tests.integration.arrays;, +, +import jadx.core.dex.nodes.ClassNode;, +import jadx.tests.api.IntegrationTest;, +import org.junit.jupiter.api.Test;, +, +import static org.hamcrest.CoreMatchers.containsString;, +import static org.hamcrest.MatcherAssert.assertThat;, +, +public class TestArrayInit extends IntegrationTest {, +, + public static class TestCls {, +, + byte[] bytes;, +, + @SuppressWarnings("unused"), + public void test() {, + byte[] arr = new byte[]{10, 20, 30};, + }, +, + public void test2() {, + bytes = new byte[]{10, 20, 30};, + }, + }, +, + @Test, + public void test() {, + ClassNode cls =
[+++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, + if (arg.isThis()) {, + return RegisterArg.THIS_ARG_NAME;, + }, + String varName = name != null ? name : guessName(arg);, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, + if (arg.isThis()) {, + return RegisterArg.THIS_ARG_NAME;, + }, + String varName = name != null ? name : guessName(arg);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, + return contains(AFlag.THIS);, +++ b/jadx-core/src/main/java/jadx/core/codegen/NameGen.java, + if (arg.isThis()) {, + return RegisterArg.THIS_ARG_NAME;, + }, + String varName = name != null ? name : guessName(arg);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/InsnArg.java, + return contains(AFlag.THIS);, +++ b/jadx-core/src/main/java/jadx/core/dex/instructions/args/RegisterArg.java, + public static final String THIS_ARG_NAME = "this";, +, + if (isThis()) {, + return THIS_ARG_NAME;, + }, + if (!isAttrStorageEmpty())
[+++ b/jadx-gui/src/main/java/jadx/gui/JadxTextArea.java, +package jadx.gui;, +, +import jadx.api.CodePosition;, +import jadx.gui.treemodel.JClass;, +, +import javax.swing.event.HyperlinkEvent;, +import javax.swing.event.HyperlinkListener;, +import javax.swing.text.BadLocationException;, +import java.awt.Color;, +, +import org.fife.ui.rsyntaxtextarea.LinkGenerator;, +import org.fife.ui.rsyntaxtextarea.LinkGeneratorResult;, +import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;, +import org.fife.ui.rsyntaxtextarea.SyntaxConstants;, +import org.fife.ui.rsyntaxtextarea.SyntaxScheme;, +import org.fife.ui.rsyntaxtextarea.Token;, +import org.fife.ui.rsyntaxtextarea.TokenTypes;, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +public class JadxTextArea extends RSyntaxTextArea {, + private static final Logger LOG = LoggerFactory.getLogger(JadxTextArea.class);, +, + private static final Color BACKGROUND = new Color(0xf7f7f7);, + private static final Color JUMP_FOREGROUND = new Color(0x785523);, + private static final Color JUMP_BACKGROUND = new Color(0xE6E6FF);, +, + private final JClass cls;, + private final MainWindow rootWindow;, +, +, + public JadxTextArea(MainWindow mainWindow, JClass cls)
[+++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.SimplifyVisitor;, + passes.add(new ConstInlinerVisitor());, + passes.add(new FinishTypeResolver());, +, + passes.add(new SimplifyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.SimplifyVisitor;, + passes.add(new ConstInlinerVisitor());, + passes.add(new FinishTypeResolver());, +, + passes.add(new SimplifyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + // TODO: add jadx argument "", + // FIXME: check variable names in scope, + if (false && arg.isThis()) {, + return name;, + if (lit.isInteger() && lit.getLiteral() == 1) {, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.SimplifyVisitor;, + passes.add(new ConstInlinerVisitor());, + passes.add(new FinishTypeResolver());, +, + passes.add(new SimplifyVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + // TODO: add jadx argument "", + // FIXME: check variable names in scope, + if (false && arg.isThis()) {,
[+++ /dev/null, +++ /dev/null, +++ b/jadx-gui/src/main/java/jadx/gui/settings/JadxSettings.java, +import java.util.function.Consumer;, + private void partialSync(Consumer<JadxSettings> updater) {, + updater.accept(settings);]
[+++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JRoot.java, + String rfName = rf.getName().toUpperCase();, + if (rfName.endsWith(".DSA")||rfName.endsWith(".RSA")) {]
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + return mthInfo.getName();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/MethodNode.java, + return mthInfo.getName();, +++ b/jadx-core/src/test/java/jadx/tests/internal/names/TestSameMethodsNames.java, +package jadx.tests.internal.names;, +, +import jadx.api.InternalJadxTest;, +import jadx.core.dex.nodes.ClassNode;, +, +import org.junit.Test;, +, +import static jadx.tests.utils.JadxMatchers.containsOne;, +import static org.junit.Assert.assertThat;, +, +public class TestSameMethodsNames extends InternalJadxTest {, +, + public static class TestCls<V> {, +, + public static void test() {, + new Bug().Bug();, + }, +, + public static class Bug {, + public Bug() {, + System.out.println("constructor");, + }, +, + void Bug() {, + System.out.println("Bug");, + }, + }, + }, +, + @Test, + public void test() {, + ClassNode cls = getClassNode(TestCls.class);, + String code
[+++ b/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java, + deobfClsInfo.getCls().getClassInfo().makeRawFullName(), deobfClsInfo.getAlias()));, + return clsPresetMap.get(cls.makeRawFullName());, +++ b/jadx-core/src/main/java/jadx/core/deobf/DeobfPresets.java, + deobfClsInfo.getCls().getClassInfo().makeRawFullName(), deobfClsInfo.getAlias()));, + return clsPresetMap.get(cls.makeRawFullName());, +++ b/jadx-core/src/main/java/jadx/core/dex/info/ClassInfo.java, + public String makeRawFullName() {, + return makeFullClsName(this.name, true);, + }, +]
[+++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, +import static jadx.core.utils.StringUtils.notEmpty;, +, + return notEmpty(str), + && VALID_JAVA_IDENTIFIER.matcher(str).matches(), + && isAllCharsPrintable(str);, + return notEmpty(str), + && VALID_JAVA_FULL_IDENTIFIER.matcher(str).matches(), + && isAllCharsPrintable(str);, +++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, +import static jadx.core.utils.StringUtils.notEmpty;, +, + return notEmpty(str), + && VALID_JAVA_IDENTIFIER.matcher(str).matches(), + && isAllCharsPrintable(str);, + return notEmpty(str), + && VALID_JAVA_FULL_IDENTIFIER.matcher(str).matches(), + && isAllCharsPrintable(str);, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/parser/DebugInfoParser.java, +import jadx.core.deobf.NameMapper;, + applyDebugInfo(reg, var);, + }, + }, +, + private static void applyDebugInfo(RegisterArg reg, LocalVar var) {, + String varName = var.getName();, + if (NameMapper.isValidIdentifier(varName)) {, + reg.mergeDebugInfo(var.getType(), varName);, +++ b/jadx-core/src/main/java/jadx/core/deobf/NameMapper.java, +import static jadx.core.utils.StringUtils.notEmpty;, +, + return notEmpty(str), + && VALID_JAVA_IDENTIFIER.matcher(str).matches(), + && isAllCharsPrintable(str);, + return notEmpty(str),
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + addImport(classInfo);, + private void addImport(ClassInfo classInfo) {, + if (parentGen != null) {, + parentGen.addImport(classInfo);, + } else {, + imports.add(classInfo);, + }, + }, +, + if (classNode != null) {, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + addImport(classInfo);, + private void addImport(ClassInfo classInfo) {, + if (parentGen != null) {, + parentGen.addImport(classInfo);, + } else {, + imports.add(classInfo);, + }, + }, +, + if (classNode != null) {, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + regArg.replaceTypedVar(f);, + if (wrap) {, + code.add('(');, + }, + code.add(')');, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + addImport(classInfo);, + private void addImport(ClassInfo classInfo) {, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, + && parentClass.equals(fieldsCls.getClassInfo()), + && field.getName().startsWith("this$") /* TODO: don't check name */) {, + if (args.isEmpty() || mth.contains(AFlag.SKIP_FIRST_ARG)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, + && parentClass.equals(fieldsCls.getClassInfo()), + && field.getName().startsWith("this$") /* TODO: don't check name */) {, + if (args.isEmpty() || mth.contains(AFlag.SKIP_FIRST_ARG)) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/MethodInlineVisitor.java, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.dex.instructions.args.ArgType;, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.instructions.args.RegisterArg;, +import java.util.List;, +, + BlockNode returnBlock = mth.getBasicBlocks().get(1);, + if (returnBlock.contains(AFlag.RETURN) || returnBlock.getInstructions().isEmpty()) {, + BlockNode firstBlock = mth.getBasicBlocks().get(0);, + inlineMth(mth, firstBlock, returnBlock);, + private static void inlineMth(MethodNode mth, BlockNode firstBlock, BlockNode returnBlock) {, + List<InsnNode> insnList = firstBlock.getInstructions();, + if (insnList.isEmpty()) {, + return;, + },
[+++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, + if (cls.getFullName().equals(exclude), + || cls.getFullName().startsWith(exclude + '.')) {, + if (excludedPackages.isEmpty()) {, + return Collections.emptyList();, + }, + String newExclusion = settings.getExcludedPackages() + ' ' + packageToExclude;, + settings.setExcludedPackages(newExclusion.trim());, +++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, + if (cls.getFullName().equals(exclude), + || cls.getFullName().startsWith(exclude + '.')) {, + if (excludedPackages.isEmpty()) {, + return Collections.emptyList();, + }, + String newExclusion = settings.getExcludedPackages() + ' ' + packageToExclude;, + settings.setExcludedPackages(newExclusion.trim());, +++ b/jadx-gui/src/main/java/jadx/gui/treemodel/JPackage.java, + || excludedPackages.stream().filter(p -> !p.isEmpty()), + .noneMatch(p -> name.equals(p) || name.startsWith(p + '.'));]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + insertContinue(loop);, + insertBreak(stack, loopExit, exitEdge);, + insertContinue(loop);, + if (insertBreak(stack, exit, exitEdge)) {, + private boolean insertBreak(RegionStack stack, BlockNode loopExit, Edge exitEdge) {, + addBreakLabel(exitEdge, exit, breakInsn);, + private void addBreakLabel(Edge exitEdge, BlockNode exit, InsnNode breakInsn) {, + BlockNode outBlock = BlockUtils.getNextBlock(exitEdge.getTarget());, + if (outBlock == null) {, + return;, + }, + List<LoopInfo> exitLoop = mth.getAllLoopsForBlock(outBlock);, + if (!exitLoop.isEmpty()) {, + return;, + }, + List<LoopInfo> inLoops = mth.getAllLoopsForBlock(exitEdge.getSource());, + if (inLoops.size() < 2) {, + return;, + }, + // search for parent loop, + LoopInfo parentLoop = null;, + for (LoopInfo loop :
[+++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.xmlgen.ResourcesSaver;, + private ExecutorService getSaveExecutor(boolean saveSources, final boolean saveResources) {, + executor.execute(new ResourcesSaver(outDir, resourceFile));, + synchronized BinaryXMLParser getXmlParser() {, +, +++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.xmlgen.ResourcesSaver;, + private ExecutorService getSaveExecutor(boolean saveSources, final boolean saveResources) {, + executor.execute(new ResourcesSaver(outDir, resourceFile));, + synchronized BinaryXMLParser getXmlParser() {, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.xmlgen.ResContainer;, + public ResContainer getContent() {, +++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +import jadx.core.xmlgen.ResourcesSaver;, + private ExecutorService getSaveExecutor(boolean saveSources, final boolean saveResources) {, + executor.execute(new ResourcesSaver(outDir, resourceFile));, + synchronized BinaryXMLParser getXmlParser() {, +, +++ b/jadx-core/src/main/java/jadx/api/ResourceFile.java, +import jadx.core.xmlgen.ResContainer;, + public ResContainer getContent() {, +++ b/jadx-core/src/main/java/jadx/api/ResourceFileContent.java, +package jadx.api;,
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, + if (classInfo.getAlias().getPackage().isEmpty()) {, + String fullName = classInfo.makeFullClsName(classInfo.getAlias().getShortName(), true);, + String newFullName = Consts.DEFAULT_PACKAGE_NAME + "." + fullName;, + classInfo.rename(cls.dex(), newFullName);, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, + if (classInfo.getAlias().getPackage().isEmpty()) {, + String fullName = classInfo.makeFullClsName(classInfo.getAlias().getShortName(), true);, + String newFullName = Consts.DEFAULT_PACKAGE_NAME + "." + fullName;, + classInfo.rename(cls.dex(), newFullName);, + }, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, +import static org.hamcrest.Matchers.containsString;, +import static org.hamcrest.Matchers.empty;, +import static org.hamcrest.Matchers.is;, +import static org.hamcrest.Matchers.not;, +import static org.hamcrest.Matchers.notNullValue;, + assertThat("Class not found: " + clsName, cls, notNullValue());, + assertThat(clsName, is(cls.getClassInfo().getFullName()));, + throw (AssertionError) cause;, + assertThat("File list is empty", list, not(empty()));, + assertThat("Test source file not found: "
[+++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.api.ResourceFile.ZipRef;, +import jadx.core.codegen.CodeWriter;, +import jadx.core.utils.Utils;, +import jadx.core.utils.exceptions.JadxException;, +import jadx.core.utils.files.InputFile;, +import jadx.core.utils.files.ZipSecurity;, +import jadx.core.xmlgen.ResContainer;, +import jadx.core.xmlgen.ResTableParser;, +, + try (InputStream inputStream = new BufferedInputStream(new FileInputStream(file))) {, + return decoder.decode(file.length(), inputStream);, + } else {, + try (ZipFile zipFile = new ZipFile(zipRef.getZipFile())) {, + ZipEntry entry = zipFile.getEntry(zipRef.getEntryName());, + if (!ZipSecurity.isValidZipEntry(entry)) {, + return null;, + try (InputStream inputStream = new BufferedInputStream(zipFile.getInputStream(entry))) {, + return decoder.decode(entry.getSize(), inputStream);, + }, + }, + }, +, + default:, + }, + try (ZipFile zip = new ZipFile(file)) {, + } catch (Exception e) {, +++ b/jadx-core/src/main/java/jadx/api/ResourcesLoader.java, +import jadx.api.ResourceFile.ZipRef;, +import jadx.core.codegen.CodeWriter;,
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java, + protected boolean highlightTextCaseInsensitive = false;, + searchContext.setMatchCase(!highlightTextCaseInsensitive);, +++ b/jadx-gui/src/main/java/jadx/gui/ui/CommonSearchDialog.java, + protected boolean highlightTextCaseInsensitive = false;, + searchContext.setMatchCase(!highlightTextCaseInsensitive);, +++ b/jadx-gui/src/main/java/jadx/gui/ui/SearchDialog.java, + private JCheckBox caseChBox;, + boolean caseInsensitive = caseChBox.isSelected();, + resultsModel.addAll(index.searchClsName(text, caseInsensitive));, + resultsModel.addAll(index.searchMthName(text, caseInsensitive));, + resultsModel.addAll(index.searchFldName(text, caseInsensitive));, + resultsModel.addAll(index.searchCode(text, caseInsensitive));, + highlightTextCaseInsensitive = caseInsensitive;, + caseChBox = new JCheckBox(NLS.str("search_dialog.ignorecase"));, + caseChBox.addItemListener(new ItemListener() {, + public void itemStateChanged(ItemEvent e) {, + performSearch();, + }, + });, +, + JPanel searchInPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));, + searchInPanel.setBorder(BorderFactory.createTitledBorder(NLS.str("search_dialog.search_in")));, + searchInPanel.add(clsChBox);, + searchInPanel.add(mthChBox);, + searchInPanel.add(fldChBox);, + searchInPanel.add(codeChBox);, +, + searchOptions.setBorder(BorderFactory.createTitledBorder(NLS.str("search_dialog.options")));, + searchOptions.add(caseChBox);, +, + Box box = Box.createHorizontalBox();, + box.setAlignmentX(LEFT_ALIGNMENT);,
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, + } else if (b.contains(AFlag.SYNTHETIC)) {, + List<BlockNode> s = b.getSuccessors();, + if (s.size() == 1 && s.get(0).contains(AType.EXC_HANDLER)) {, + toRemove.add(b);, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/BlockNode.java, + } else if (b.contains(AFlag.SYNTHETIC)) {, + List<BlockNode> s = b.getSuccessors();, + if (s.size() == 1 && s.get(0).contains(AType.EXC_HANDLER)) {, + toRemove.add(b);, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, + private static final Logger LOG = LoggerFactory.getLogger(IfMakerHelper.class);, + LOG.debug("Stop processing blocks after bad 'else' in 'if': {}, method: {}", info, mth);, + LOG.debug("Stop processing blocks after bad 'then' in 'if': {}, method: {}", info, mth);, + for (BlockNode pred : preds)
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + private Map<ClassNode, JavaClass> classesMap = new java.util.concurrent.ConcurrentHashMap<ClassNode, JavaClass>();, + private Map<MethodNode, JavaMethod> methodsMap = new java.util.concurrent.ConcurrentHashMap<MethodNode, JavaMethod>();, + private Map<FieldNode, JavaField> fieldsMap = new java.util.concurrent.ConcurrentHashMap<FieldNode, JavaField>();, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + private Map<ClassNode, JavaClass> classesMap = new java.util.concurrent.ConcurrentHashMap<ClassNode, JavaClass>();, + private Map<MethodNode, JavaMethod> methodsMap = new java.util.concurrent.ConcurrentHashMap<MethodNode, JavaMethod>();, + private Map<FieldNode, JavaField> fieldsMap = new java.util.concurrent.ConcurrentHashMap<FieldNode, JavaField>();, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, + if (classInfo.isRenamed(), + && !cls.getShortName().equals(cls.getAlias().getShortName())) {, + code.startLine("/* renamed from: ").add(classInfo.getFullName()).add(" */");, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + private Map<ClassNode, JavaClass> classesMap = new java.util.concurrent.ConcurrentHashMap<ClassNode, JavaClass>();, + private Map<MethodNode, JavaMethod> methodsMap = new java.util.concurrent.ConcurrentHashMap<MethodNode, JavaMethod>();, + private Map<FieldNode, JavaField> fieldsMap =
[+++ b/build.gradle, + tasks.withType(JavaCompile) {, + sourceCompatibility = JavaVersion.VERSION_1_6, + targetCompatibility = JavaVersion.VERSION_1_6, +, +++ b/build.gradle, + tasks.withType(JavaCompile) {, + sourceCompatibility = JavaVersion.VERSION_1_6, + targetCompatibility = JavaVersion.VERSION_1_6, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, + passes.add(new DebugInfoVisitor());, +++ b/build.gradle, + tasks.withType(JavaCompile) {, + sourceCompatibility = JavaVersion.VERSION_1_6, + targetCompatibility = JavaVersion.VERSION_1_6, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, + passes.add(new DebugInfoVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + code.add(mgen.getNameGen().useArg((RegisterArg) arg));, + code.add(mgen.getNameGen().assignArg(arg));, +++ b/build.gradle, + tasks.withType(JavaCompile) {, + sourceCompatibility = JavaVersion.VERSION_1_6, + targetCompatibility = JavaVersion.VERSION_1_6, +, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, + passes.add(new DebugInfoVisitor());, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + code.add(mgen.getNameGen().useArg((RegisterArg) arg));, + code.add(mgen.getNameGen().assignArg(arg));, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + private final NameGen nameGen;, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java, + return Collections.unmodifiableList(attrList.getList());, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java, + return Collections.unmodifiableList(attrList.getList());, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, +import jadx.core.dex.instructions.PhiInsn;, + if (assignInsn == null || assignInsn instanceof PhiInsn) {, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AttributeStorage.java, + return Collections.unmodifiableList(attrList.getList());, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/CodeShrinker.java, +import jadx.core.dex.instructions.PhiInsn;, + if (assignInsn == null || assignInsn instanceof PhiInsn) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/IfMakerHelper.java, +import jadx.core.dex.attributes.nodes.LoopInfo;, + boolean badThen = isBadBranchBlock(info, thenBlock);, + boolean badElse = isBadBranchBlock(info, elseBlock);, + private static boolean isBadBranchBlock(IfInfo info, BlockNode block) {, + // check if block at end of loop edge, + if (block.contains(AFlag.LOOP_START) && block.getPredecessors().size() == 1) {, + BlockNode pred = block.getPredecessors().get(0);, + if (pred.contains(AFlag.LOOP_END)) {, + List<LoopInfo> startLoops =
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + List<BlockNode> basicBlocks = mth.getBasicBlocks();, + BitSet outs = new BitSet(basicBlocks.size());, + BlockNode first = basicBlocks.get(df.nextSetBit(0));, + BlockNode second = basicBlocks.get(df.nextSetBit(first.getId() + 1));, + outs.clear(block.getId());, + if (loop != null) {, + outs.clear(loop.getStart().getId());, + }, +, + BlockNode b = basicBlocks.get(i);, + out = basicBlocks.get(outs.nextSetBit(0));, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/RegionMaker.java, + List<BlockNode> basicBlocks = mth.getBasicBlocks();, + BitSet outs = new BitSet(basicBlocks.size());, + BlockNode first = basicBlocks.get(df.nextSetBit(0));, + BlockNode second = basicBlocks.get(df.nextSetBit(first.getId() + 1));, + outs.clear(block.getId());, + if (loop != null) {, + outs.clear(loop.getStart().getId());, + }, +, + BlockNode b = basicBlocks.get(i);, + out = basicBlocks.get(outs.nextSetBit(0));, +++ b/jadx-core/src/test/java/jadx/tests/integration/switches/TestSwitchInLoop.java, +package jadx.tests.integration.switches;, +,
[+++ b/jadx-core/build.gradle, + compile 'commons-io:commons-io:2.6', +++ b/jadx-core/build.gradle, + compile 'commons-io:commons-io:2.6', +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +import java.io.File;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Set;, +, +import org.apache.commons.io.FilenameUtils;, +, +import jadx.core.utils.files.FileUtils;, + if (dexNodes.isEmpty()) {, + boolean isCaseSensitive = FileUtils.isCaseSensitiveFS(new File(inputPath)); // args.getOutDir() - not set in gui, + checkClasses(root, isCaseSensitive);, + private void checkClasses(RootNode root, boolean caseSensitive) {, + if (!caseSensitive) {, +++ b/jadx-core/build.gradle, + compile 'commons-io:commons-io:2.6', +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/RenameVisitor.java, +import java.io.File;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Set;, +, +import org.apache.commons.io.FilenameUtils;, +, +import jadx.core.utils.files.FileUtils;, + if (dexNodes.isEmpty()) {, + boolean isCaseSensitive = FileUtils.isCaseSensitiveFS(new File(inputPath)); // args.getOutDir() - not set in gui, + checkClasses(root, isCaseSensitive);,
[+++ b/jadx-gui/src/main/java/jadx/gui/JadxWrapper.java, +import java.util.stream.Collectors;, + /**, + * Get the complete list of classes, + * @return, + */, + /**, + * Get all classes that are not excluded by the excluded packages settings, + * @return, + */, + public List<JavaClass> getIncludedClasses() {, + List<JavaClass> classList = decompiler.getClasses();, + String excludedPackages = settings.getExcludedPackages().trim();, + if (excludedPackages.length() == 0), + return classList;, + String[] excluded = excludedPackages.split("[ ]+");, +, + return classList.stream().filter(cls -> {, + for (String exclude : excluded) {, + if (cls.getFullName().startsWith(exclude)), + return false;, + }, + return true;, + }).collect(Collectors.toList());, + }, +, +,
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +import jadx.gui.ui.SearchDialog.SearchOptions;, +import javax.swing.AbstractAction;, +import javax.swing.Action;, +import java.util.EnumSet;, +import static javax.swing.KeyStroke.getKeyStroke;, +, + private void saveAll() {, + tree.requestFocus();, + Action openAction = new AbstractAction(NLS.str("file.open"), ICON_OPEN) {, + openFile();, + };, + openAction.putValue(Action.SHORT_DESCRIPTION, NLS.str("file.open"));, + openAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_O, KeyEvent.CTRL_DOWN_MASK));, +, + Action saveAllAction = new AbstractAction(NLS.str("file.save_all"), ICON_SAVE_ALL) {, + @Override, + public void actionPerformed(ActionEvent e) {, + saveAll();, + }, + };, + saveAllAction.putValue(Action.SHORT_DESCRIPTION, NLS.str("file.save_all"));, + saveAllAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_S, KeyEvent.CTRL_DOWN_MASK));, + Action prefsAction = new AbstractAction(NLS.str("menu.preferences"), ICON_PREF) {, + @Override, + public void actionPerformed(ActionEvent e) {, + new JadxSettingsWindow(MainWindow.this, settings).setVisible(true);, + prefsAction.putValue(Action.SHORT_DESCRIPTION, NLS.str("menu.preferences"));, + prefsAction.putValue(Action.ACCELERATOR_KEY, getKeyStroke(KeyEvent.VK_P,, + KeyEvent.CTRL_DOWN_MASK |
[+++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.utils.CodegenUtils;, + CodegenUtils.addComments(code, cls);, + insertDecompilationProblems(code, cls);, + CodegenUtils.addComments(code, mth);, + private void insertDecompilationProblems(CodeWriter code, AttrNode node) {, + List<JadxError> errors = node.getAll(AType.JADX_ERROR);, + List<JadxWarn> warns = node.getAll(AType.JADX_WARN);, + CodegenUtils.addComments(code, f);, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.utils.CodegenUtils;, + CodegenUtils.addComments(code, cls);, + insertDecompilationProblems(code, cls);, + CodegenUtils.addComments(code, mth);, + private void insertDecompilationProblems(CodeWriter code, AttrNode node) {, + List<JadxError> errors = node.getAll(AType.JADX_ERROR);, + List<JadxWarn> warns = node.getAll(AType.JADX_WARN);, + CodegenUtils.addComments(code, f);, +++ b/jadx-core/src/main/java/jadx/core/dex/attributes/AType.java, + public static final AType<AttrList<String>> COMMENTS = new AType<>();, +++ b/jadx-core/src/main/java/jadx/core/codegen/ClassGen.java, +import jadx.core.utils.CodegenUtils;, + CodegenUtils.addComments(code, cls);, + insertDecompilationProblems(code, cls);, + CodegenUtils.addComments(code, mth);, + private void insertDecompilationProblems(CodeWriter code, AttrNode node)
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + MethodNode callMthNode = mth.dex().deepResolveMethod(callMth);, + if (callMthNode != null) {, + if (inlineMethod(callMthNode, insn, code)) {, + callMth = callMthNode.getMethodInfo();, + }, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + MethodNode callMthNode = mth.dex().deepResolveMethod(callMth);, + if (callMthNode != null) {, + if (inlineMethod(callMthNode, insn, code)) {, + callMth = callMthNode.getMethodInfo();, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/info/MethodInfo.java, + shortId = makeSignature(true);, + public String makeSignature(boolean includeRetType) {, + StringBuilder signature = new StringBuilder();, + signature.append(name);, + signature.append('(');, + for (ArgType arg : args) {, + signature.append(TypeGen.signature(arg));, + }, + signature.append(')');, + if (includeRetType) {, + signature.append(TypeGen.signature(retType));, + }, + return signature.toString();, + }, +,
[+++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, + JadxDecompiler d = loadFiles(Collections.singletonList(file));, + RootNode root = JadxInternalAccess.getRoot(d);, +, + ClassNode cls = root.searchClassByName(clsName);, + assertThat("Class not found: " + clsName, cls, notNullValue());, + assertThat(clsName, is(cls.getClassInfo().getFullName()));, +, + decompileAndCheckCls(d, cls);, + return cls;, + }, +, + protected JadxDecompiler loadFiles(List<File> inputFiles) {, + args.setInputFiles(inputFiles);, + return d;, + }, + protected void decompileAndCheckCls(JadxDecompiler d, ClassNode cls) {, + runAutoCheck(cls.getClassInfo().getFullName());, +++ b/jadx-core/src/test/java/jadx/tests/api/IntegrationTest.java, + JadxDecompiler d = loadFiles(Collections.singletonList(file));, + RootNode root = JadxInternalAccess.getRoot(d);, +, + ClassNode cls = root.searchClassByName(clsName);, + assertThat("Class not found: " + clsName, cls, notNullValue());, + assertThat(clsName, is(cls.getClassInfo().getFullName()));, +, + decompileAndCheckCls(d, cls);, + return
[+++ b/jadx-core/src/main/java/jadx/core/codegen/AnnotationGen.java, + List<AnnotationsList> paramList = paramsAnnotations.getParamList();, + if (n >= paramList.size()) {, + return;, + }, + AnnotationsList aList = paramList.get(n);]
[+++ b/jadx-core/src/main/java/jadx/core/deobf/Deobfuscator.java, + ClassInfo classInfo = cls.getClassInfo();, + String alias = getAliasFromSourceFile(cls);, + if (alias == null) {, + String clsName = classInfo.getShortName();, + alias = String.format("C%04d%s", clsIndex++, makeName(clsName));, + }, + PackageNode pkg = getPackageNode(classInfo.getPackage(), true);, + clsMap.put(classInfo, new DeobfClsInfo(this, cls, pkg, alias));, + return alias;, + }, +, + @Nullable, + private String getAliasFromSourceFile(ClassNode cls) {, + if (sourceFileAttr == null) {, + return null;, + }, + return null;]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, + }, + if (srcDir == null) {, + args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, + }, + if (resDir == null) {, + args.setOutDirRes(new File(args.getOutDir(), JadxArgs.DEFAULT_RES_DIR));, + }, + checkDir(args.getOutDir(), "Output");, + checkDir(args.getOutDirSrc(), "Source output");, + checkDir(args.getOutDirRes(), "Resources output");, + private static void checkDir(File dir, String desc) {, + throw new JadxArgsValidateException(desc + " directory exists as file " + dir);, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxArgs.java, +, +++ b/jadx-core/src/main/java/jadx/api/JadxArgsValidator.java, + }, + if (srcDir == null) {, + args.setOutDirSrc(new File(args.getOutDir(), JadxArgs.DEFAULT_SRC_DIR));, + }, + if (resDir == null)
[+++ b/jadx-gui/build.gradle, + icon = "${projectDir}/src/main/resources/logos/jadx-logo.ico", +++ b/jadx-gui/build.gradle, + icon = "${projectDir}/src/main/resources/logos/jadx-logo.ico", +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +import java.util.ArrayList;, +import java.util.List;, + setWindowIcons();, + }, +, + private void setWindowIcons() {, + List<Image> icons = new ArrayList<>();, + icons.add(Utils.openImage("/logos/jadx-logo-16px.png"));, + icons.add(Utils.openImage("/logos/jadx-logo-32px.png"));, + icons.add(Utils.openImage("/logos/jadx-logo-48px.png"));, + icons.add(Utils.openImage("/logos/jadx-logo.png"));, + setIconImages(icons);, +++ b/jadx-gui/build.gradle, + icon = "${projectDir}/src/main/resources/logos/jadx-logo.ico", +++ b/jadx-gui/src/main/java/jadx/gui/ui/MainWindow.java, +import java.util.ArrayList;, +import java.util.List;, + setWindowIcons();, + }, +, + private void setWindowIcons() {, + List<Image> icons = new ArrayList<>();, + icons.add(Utils.openImage("/logos/jadx-logo-16px.png"));, + icons.add(Utils.openImage("/logos/jadx-logo-32px.png"));, + icons.add(Utils.openImage("/logos/jadx-logo-48px.png"));, + icons.add(Utils.openImage("/logos/jadx-logo.png"));, + setIconImages(icons);, +++ b/jadx-gui/src/main/java/jadx/gui/utils/Utils.java, + public static Image openImage(String path) {, + URL resource = Utils.class.getResource(path);, + if (resource
[+++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(description = "<input file> (.dex, .apk, .jar or .class)"), +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(description = "<input file> (.dex, .apk, .jar or .class)"), +++ b/jadx-core/build.gradle, + compile 'org.ow2.asm:asm:5.0.3', +++ b/jadx-cli/src/main/java/jadx/cli/JadxCLIArgs.java, + @Parameter(description = "<input file> (.dex, .apk, .jar or .class)"), +++ b/jadx-core/build.gradle, + compile 'org.ow2.asm:asm:5.0.3', +++ b/jadx-core/src/main/java/jadx/core/utils/AsmUtils.java, +package jadx.core.utils;, +, +import java.io.File;, +import java.io.FileInputStream;, +import java.io.IOException;, +, +import org.objectweb.asm.ClassReader;, +, +public class AsmUtils {, +, + private AsmUtils() {, + }, +, + public static String getNameFromClassFile(File file) throws IOException {, + FileInputStream in = new FileInputStream(file);, + ClassReader classReader = new ClassReader(in);, + return classReader.getClassName();, + },
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, + private int namespaceDepth = 0;, + if (namespaceDepth == 0) {, + // skip padding on file end, + return;, + }, + namespaceDepth++;, + namespaceDepth--;, + int elementNameId = is.readInt32();, + String elemName = getString(elementNameId);, + if (currentTag.equals(elemName) && isOneLine && !isLastEnd) {, + writer.add(elemName).add(">");]
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, + private static boolean allArgsNull(ConstructorInsn insn) {, + } else {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java, + private static boolean allArgsNull(ConstructorInsn insn) {, + } else {, +++ b/jadx-core/src/test/java/jadx/tests/external/BaseExternalTest.java, +import static org.hamcrest.Matchers.greaterThan;, + processByPatterns(jadx, clsPtrn, mthPtrn);, + private void processByPatterns(JadxDecompiler jadx, Pattern clsPattern, @Nullable Pattern mthPattern) {, + int processed = 0;, + if (processCls(mthPattern, passes, classNode)) {, + processed++;, + }, + }, + }, + assertThat("No classes processed", processed, greaterThan(0));, + }, +, + private boolean processCls(@Nullable Pattern mthPattern, List<IDexTreeVisitor> passes, ClassNode classNode) {, + if (!decompile) {, + return false;, + }, + return true;, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ModVisitor.java,
[+++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import javax.swing.WindowConstants;, + mainWindow.pack();, + mainWindow.setLocationAndPosition();, + mainWindow.setLocationRelativeTo(null);, + mainWindow.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);, +++ b/jadx-gui/src/main/java/jadx/gui/JadxGUI.java, +import javax.swing.WindowConstants;, + mainWindow.pack();, + mainWindow.setLocationAndPosition();, + mainWindow.setLocationRelativeTo(null);, + mainWindow.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);, +++ b/jadx-gui/src/main/java/jadx/gui/MainWindow.java, +import java.awt.Dimension;, +import java.awt.Toolkit;, + private static final double BORDER_RATIO = 0.15;, + private static final double WINDOW_RATIO = 1 - BORDER_RATIO * 2;, +, + splitPane.setResizeWeight(0.2);, + }, +, + public void setLocationAndPosition() {, + Dimension dimension = Toolkit.getDefaultToolkit().getScreenSize();, + double w = dimension.getWidth();, + double h = dimension.getHeight();, + setLocation((int) (w * BORDER_RATIO), (int) (h * BORDER_RATIO));, + setSize((int) (w * WINDOW_RATIO), (int) (h * WINDOW_RATIO));]
[+++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +import java.util.concurrent.ThreadPoolExecutor;, + ExecutorService ex = saveAll(args.getOutDir());, + ex.awaitTermination(100, TimeUnit.DAYS);, + LOG.info("done");, + public ThreadPoolExecutor saveAll(File dir) throws InterruptedException {, + SaveCode savePass = new SaveCode(dir, args);, + ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(threadsCount);, + return executor;, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +import java.util.concurrent.ThreadPoolExecutor;, + ExecutorService ex = saveAll(args.getOutDir());, + ex.awaitTermination(100, TimeUnit.DAYS);, + LOG.info("done");, + public ThreadPoolExecutor saveAll(File dir) throws InterruptedException {, + SaveCode savePass = new SaveCode(dir, args);, + ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(threadsCount);, + return executor;, +++ b/jadx-core/src/main/java/jadx/core/codegen/CodeWriter.java, +++ b/jadx-core/src/main/java/jadx/api/Decompiler.java, +import java.util.concurrent.ThreadPoolExecutor;, + ExecutorService ex = saveAll(args.getOutDir());, + ex.awaitTermination(100, TimeUnit.DAYS);, + LOG.info("done");, + public ThreadPoolExecutor saveAll(File dir) throws InterruptedException
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +import java.util.ArrayList;, +import java.util.List;, + // printRegionsWithBlock(mth, block);, +, + private static void printRegionsWithBlock(MethodNode mth, final BlockNode block) {, + final List<IRegion> regions = new ArrayList<IRegion>();, + DepthRegionTraversal.traverseAll(mth, new TracedRegionVisitor() {, + @Override, + public void processBlockTraced(MethodNode mth, IBlock container, IRegion currentRegion) {, + if (block.equals(container)) {, + regions.add(currentRegion);, + }, + }, + });, + LOG.debug(" Found block: {} in regions: {}", block, regions);, + }, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +import java.util.ArrayList;, +import java.util.List;, + // printRegionsWithBlock(mth, block);, +, + private static void printRegionsWithBlock(MethodNode mth, final BlockNode block) {, + final List<IRegion> regions = new ArrayList<IRegion>();, + DepthRegionTraversal.traverseAll(mth,
[+++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + public static MethodGen getFallbackMethodGen(MethodNode mth) {, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + public static MethodGen getFallbackMethodGen(MethodNode mth) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +++ b/jadx-core/src/main/java/jadx/core/codegen/MethodGen.java, + public static MethodGen getFallbackMethodGen(MethodNode mth) {, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/CheckRegions.java, +++ b/jadx-core/src/main/java/jadx/core/utils/DebugUtils.java, +package jadx.core.utils;, +, +import jadx.core.codegen.CodeWriter;, +import jadx.core.codegen.InsnGen;, +import jadx.core.codegen.MethodGen;, +import jadx.core.dex.attributes.AType;, +import jadx.core.dex.attributes.nodes.PhiListAttr;, +import jadx.core.dex.instructions.InsnType;, +import jadx.core.dex.instructions.PhiInsn;, +import jadx.core.dex.instructions.args.InsnArg;, +import jadx.core.dex.instructions.args.RegisterArg;, +import jadx.core.dex.instructions.args.SSAVar;, +import jadx.core.dex.nodes.BlockNode;, +import jadx.core.dex.nodes.IBlock;, +import jadx.core.dex.nodes.IContainer;, +import jadx.core.dex.nodes.IRegion;, +import jadx.core.dex.nodes.InsnNode;, +import jadx.core.dex.nodes.MethodNode;, +import jadx.core.dex.visitors.DotGraphVisitor;, +import jadx.core.dex.visitors.regions.DepthRegionTraversal;, +import jadx.core.dex.visitors.regions.TracedRegionVisitor;, +import jadx.core.utils.exceptions.CodegenException;, +import jadx.core.utils.exceptions.JadxRuntimeException;, +, +import java.io.File;, +import java.util.ArrayList;, +import java.util.LinkedHashSet;, +import java.util.List;, +import java.util.Set;, +, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, +@Deprecated, +public class DebugUtils
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/BinaryXMLParser.java, + writer.add("@style/").add(name.replaceAll("_", "."));]
[+++ /dev/null, +++ /dev/null, +++ b/.travis.yml, +++ /dev/null, +++ b/.travis.yml, +++ b/README.md, +++ /dev/null, +++ b/.travis.yml, +++ b/README.md, +++ b/jadx-core/build.gradle, + compile files('lib/dx.jar'), +++ /dev/null, +++ b/.travis.yml, +++ b/README.md, +++ b/jadx-core/build.gradle, + compile files('lib/dx.jar'), +++ /dev/null, +++ /dev/null, +++ b/.travis.yml, +++ b/README.md, +++ b/jadx-core/build.gradle, + compile files('lib/dx.jar'), +++ /dev/null, +++ b/jadx-core/lib/dx.jar, +++ /dev/null, +++ b/.travis.yml, +++ b/README.md, +++ b/jadx-core/build.gradle, + compile files('lib/dx.jar'), +++ /dev/null, +++ b/jadx-core/lib/dx.jar, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +++ /dev/null, +++ b/.travis.yml, +++ b/README.md, +++ b/jadx-core/build.gradle, + compile files('lib/dx.jar'), +++ /dev/null, +++ b/jadx-core/lib/dx.jar, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +++ b/jadx-core/src/main/java/jadx/core/utils/files/InputFile.java, +import static jadx.core.utils.files.FileUtils.close;, + if (fileName.endsWith(".apk") || fileName.endsWith(".zip")) {]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java, + if (ri.getTypeName().equals("attr") && !ri.getNamedValues().isEmpty()) {, + if (valueStr == null || valueStr.equals("0")) {, + if (valueStr == null) {, + return;, + }, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/ResXmlGen.java, + if (ri.getTypeName().equals("attr") && !ri.getNamedValues().isEmpty()) {, + if (valueStr == null || valueStr.equals("0")) {, + if (valueStr == null) {, + return;, + }, +++ b/jadx-core/src/main/java/jadx/core/xmlgen/entry/ValuesParser.java, +import org.jetbrains.annotations.Nullable;, +import jadx.core.xmlgen.ParserConstants;, +import jadx.core.xmlgen.ResTableParser;, +, + @Nullable, + @Nullable, + @Nullable, + if (data == 0) {, + return "0";, + }]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/TypeGen.java, +import org.slf4j.Logger;, +import org.slf4j.LoggerFactory;, +, + private static final Logger LOG = LoggerFactory.getLogger(TypeGen.class);, + LOG.warn("Wrong object literal: " + lit + " for type: " + type);, + return Long.toString(lit);]
[+++ b/build.gradle, +version = jadxVersion, + apply plugin: 'jacoco', + if (!"${it}".contains(':jadx-samples:')) {, + options.compilerArgs << '-Xlint' << '-Xlint:unchecked' << '-Xlint:deprecation', + testCompile 'org.mockito:mockito-core:1.9.5', + gradleVersion = '1.11', +++ b/build.gradle, +version = jadxVersion, + apply plugin: 'jacoco', + if (!"${it}".contains(':jadx-samples:')) {, + options.compilerArgs << '-Xlint' << '-Xlint:unchecked' << '-Xlint:deprecation', + testCompile 'org.mockito:mockito-core:1.9.5', + gradleVersion = '1.11', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, +version = jadxVersion, + apply plugin: 'jacoco', + if (!"${it}".contains(':jadx-samples:')) {, + options.compilerArgs << '-Xlint' << '-Xlint:unchecked' << '-Xlint:deprecation', + testCompile 'org.mockito:mockito-core:1.9.5', + gradleVersion = '1.11', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.11-all.zip]
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/ZipSecurity.java, + private static final int MAX_SIZE_DIFF = 100;]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new DebugInfoVisitor());, + passes.add(new TypeInference());, +, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new FinishTypeInference());, +, +, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new DebugInfoVisitor());, + passes.add(new TypeInference());, +, + if (args.isRawCFGOutput()) {, + passes.add(DotGraphVisitor.dumpRaw());, + }, +, + passes.add(new FinishTypeInference());, +, +, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClspGraph.java, + private final Map<String, Set<String>> ancestorCache = Collections.synchronizedMap(new WeakHashMap<String, Set<String>>());, +++ b/.gitignore, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, +++ b/jadx-core/src/main/java/jadx/core/Jadx.java, +import jadx.core.dex.visitors.DebugInfoVisitor;, +import jadx.core.dex.visitors.typeinference.FinishTypeInference;, +import jadx.core.dex.visitors.typeinference.TypeInference;, + passes.add(new DebugInfoVisitor());,
[+++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + public void parseAndSaveXML() {, + if (this.args.isXMLTest()) {, + InputFile inf = inputFiles.get(0);, + try {, + byte[] buffer = InputFile.loadXMLBuffer(inf.getFile());, + if (buffer != null) {, + File out = new File(outDir, "AndroidManifest.xml");, + BinaryXMLParser bxp = new BinaryXMLParser(root);, + bxp.parse(buffer, out);, + }, + } catch (Exception e) {, + LOG.info("Decompiling AndroidManifest.xml failed!", e);, + }, + }, + }, +, + parseAndSaveXML();, +, +++ b/jadx-core/src/main/java/jadx/api/JadxDecompiler.java, + public void parseAndSaveXML() {, + if (this.args.isXMLTest()) {, + InputFile inf = inputFiles.get(0);, + try {, + byte[] buffer = InputFile.loadXMLBuffer(inf.getFile());, + if (buffer != null) {,
[+++ b/jadx-gui/src/main/java/jadx/gui/utils/CertificateManager.java, + StringBuilder buf = new StringBuilder(bytes.length * 3);]
[+++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + assert isFallback() : "if insn in not fallback mode";, +++ b/jadx-core/src/main/java/jadx/core/codegen/InsnGen.java, + assert isFallback() : "if insn in not fallback mode";, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, +import jadx.core.dex.instructions.args.PrimitiveType;, + if (accFlags.isPublic()) {, + }, + public FieldNode getConstField(Object obj) {, + return getConstField(obj, true);, + }, +, + public FieldNode getConstField(Object obj, boolean searchGlobal) {, + field = cn.constFields.get(obj);, + if (field == null && searchGlobal) {, + field = dex.getConstFields().get(obj);, + }, + PrimitiveType type = arg.getType().getPrimitiveType();, + if (type == null) {, + return null;, + }, + switch (type) {, + case BOOLEAN:, + return getConstField(literal
[+++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +import java.util.zip.ZipException;, +import java.util.zip.ZipFile;, +, + public static boolean isZipFile(final File file) throws IOException {, + ZipFile zipFile = null;, + try {, + zipFile = new ZipFile(file);, + return zipFile.entries().hasMoreElements();, + } catch (ZipException e) {, + return false;, + } finally {, + if (zipFile != null) {, + try {, + zipFile.close();, + } catch (IOException e) {, + LOG.error(e.getMessage());, + }, + }, + }, + }, +++ b/jadx-core/src/main/java/jadx/core/utils/files/FileUtils.java, +import java.util.zip.ZipException;, +import java.util.zip.ZipFile;, +, + public static boolean isZipFile(final File file) throws IOException {, + ZipFile zipFile = null;, + try {, +
[+++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/clsp-data/android-5.1.jar, +++ b/jadx-core/src/main/java/jadx/core/clsp/ClsSet.java, +import java.nio.file.Files;, +import java.nio.file.Path;, +import java.nio.file.StandardCopyOption;, +import jadx.core.dex.instructions.args.RegisterArg;, +import jadx.core.dex.nodes.MethodNode;, + private static final int VERSION = 2;, + private enum ARG_TYPE {WILDCARD, GENERIC, GENERIC_TYPE, OBJECT, ARRAY, PRIMITIVE}, +, + cls.load();, + nClass.setMethods(loadMethods(cls, nClass));, + private NMethod[] loadMethods(ClassNode cls, NClass nClass) {, + List<NMethod> methods = new ArrayList<>();, + for (MethodNode m : cls.getMethods()) {, + if (!m.getAccessFlags().isPublic(), + && !m.getAccessFlags().isProtected()) {, + continue;, + }, +, + List<ArgType> args = new ArrayList<>();, +, + boolean genericArg = false;, + for (RegisterArg r: m.getArguments(false)) {, + ArgType argType = r.getType();, + if (argType.isGeneric())
[+++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, + parentClass = parent == null ? this : parent;, + return parent == this ? this : parent.getTopParentClass();, +++ b/jadx-core/src/main/java/jadx/core/dex/nodes/ClassNode.java, + parentClass = parent == null ? this : parent;, + return parent == this ? this : parent.getTopParentClass();, +++ b/jadx-core/src/main/java/jadx/core/dex/visitors/DependencyCollector.java]
[+++ b/jadx-core/src/main/java/jadx/core/xmlgen/CommonBinaryParser.java, + long chunkEnd = start + size;, + long end = stylesStart == 0 ? chunkEnd : start + stylesStart;, + byte[] strArray = is.readInt8Array((int) (end - is.getPos()));, + // don't trust specified string length, read until \0, + // stringsOffset can be same for different indexes, + strings[i] = extractString16(strArray, stringsOffset[i]);, + is.skip(chunkEnd - is.getPos());, + private static String extractString16(byte[] strArray, int offset) {, + int len = strArray.length;, + int start = offset + 2;, + int end = start;, + while (true) {, + if (end + 1 >= len) {, + break;, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/regions/LoopRegionVisitor.java, + if (hasNextCall == null || nextCall == null, + || !checkInvoke(hasNextCall, "java.util.Iterator", "hasNext()Z", 0), + if (castArg != null && castArg.getParentInsn() != null) {, + ArgType iterableType = iterableArg.getType();, + ArgType varType = iterVar.getType();, + if (iterableType.isGeneric()) {, + ArgType[] genericTypes = iterableType.getGenericTypes();, + if (genericTypes == null || genericTypes.length != 1) {, + return false;, + }, + if (gType.equals(varType)) {, + if (gType.isGenericType()) {, + iterVar.setType(gType);, + return true;, + if (ArgType.isInstanceOf(gType, varType)) {, + return true;, + }, + LOG.warn("Generic type differs: {} and {}", gType, varType);, + return false;, + }, +
[+++ b/jadx-core/src/main/java/jadx/core/dex/visitors/ClassModifier.java, +import jadx.core.dex.instructions.InvokeNode;, +import jadx.core.dex.instructions.args.InsnWrapArg;, + cls.getMethods().forEach(mth -> removeSyntheticMethods(cls, mth));, + cls.getMethods().forEach(ClassModifier::removeEmptyMethods);, + private static void removeSyntheticMethods(ClassNode cls, MethodNode mth) {, + return;, + if (!af.isSynthetic()) {, + return;, + }, + if (removeBridgeMethod(cls, mth)) {, + return;, + }, + if (af.isConstructor() && mth.getBasicBlocks().size() == 2) {, + private static boolean removeBridgeMethod(ClassNode cls, MethodNode mth) {, + List<InsnNode> allInsns = BlockUtils.collectAllInsns(mth.getBasicBlocks());, + if (allInsns.size() == 1) {, + InsnNode wrappedInsn = allInsns.get(0);, + if (wrappedInsn.getType() == InsnType.RETURN) {, + InsnArg arg = wrappedInsn.getArg(0);, + if (arg.isInsnWrap()) {, + wrappedInsn = ((InsnWrapArg) arg).getWrapInsn();, + }, + }, +
[+++ b/jadx-gui/src/main/java/jadx/gui/ui/HeapUsageBar.java, +import jadx.gui.utils.Utils;, + if ((used + Utils.MIN_FREE_MEMORY) > r.maxMemory()) {, +++ b/jadx-gui/src/main/java/jadx/gui/ui/HeapUsageBar.java, +import jadx.gui.utils.Utils;, + if ((used + Utils.MIN_FREE_MEMORY) > r.maxMemory()) {, +++ b/jadx-gui/src/main/java/jadx/gui/utils/Utils.java, + /**, + * The minimum about of memory in bytes we are trying to keep free, otherwise the application may run out of heap, + * which ends up in a Java garbage collector running "amok" (CPU utilization 100% for each core and the UI is, + * not responsive)., + *, + * We can calculate and store this value here as the maximum heap is fixed for each JVM instance,
