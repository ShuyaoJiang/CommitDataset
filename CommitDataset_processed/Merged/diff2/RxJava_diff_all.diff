[+++ b/gradle.properties, +version=0.17.0-SNAPSHOT, +++ b/gradle.properties, +version=0.17.0-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/gradle.properties, +version=0.17.0-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/gradle.properties, +version=0.17.0-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/rxjava-core/src/main/java/rx/Observable.java, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not, + * use this file except in compliance with the License. You may obtain a copy of, + * the License at, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
[+++ b/build.gradle, +sourceCompatibility = JavaVersion.VERSION_1_6, +targetCompatibility = JavaVersion.VERSION_1_6, +++ b/build.gradle, +sourceCompatibility = JavaVersion.VERSION_1_6, +targetCompatibility = JavaVersion.VERSION_1_6, +++ b/src/main/java/io/reactivex/BackpressureStrategy.java, + * Copyright 2016 Netflix, Inc., +++ b/build.gradle, +sourceCompatibility = JavaVersion.VERSION_1_6, +targetCompatibility = JavaVersion.VERSION_1_6, +++ b/src/main/java/io/reactivex/BackpressureStrategy.java, + * Copyright 2016 Netflix, Inc., +++ b/src/main/java/io/reactivex/Completable.java, +/**, + * Copyright 2016 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required
[+++ b/language-adaptors/rxjava-scala/README.md, +# Scala Adaptor for RxJava, +This adaptor allows to use RxJava in Scala with anonymous functions, e.g., +, +val o = Observable.interval(200 millis).take(5), +o.subscribe(n => println("n = " + n)), +Observable(1, 2, 3, 4).reduce(_ + _), +For-comprehensions are also supported:, +, +val first = Observable(10, 11, 12), +val second = Observable(10, 11, 12), +val booleans = for ((n1, n2) <- (first zip second)) yield (n1 == n2), +Further, this adaptor attempts to expose an API which is as Scala-idiomatic as possible. This means that certain methods have been renamed, their signature was changed, or static methods were
[+++ b/src/main/java/io/reactivex/Notification.java, + Objects.requireNonNull(value); // TODO this coud instead return an error of NPE, +++ b/src/main/java/io/reactivex/Notification.java, + Objects.requireNonNull(value); // TODO this coud instead return an error of NPE, +++ b/src/test/java/io/reactivex/GroupByTests.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the
[+++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/blocking_test.clj, + (is (thrown? java.lang.IllegalArgumentException (b/single (rx/empty))))), +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/blocking_test.clj, + (is (thrown? java.lang.IllegalArgumentException (b/single (rx/empty))))), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/blocking_test.clj, + (is (thrown? java.lang.IllegalArgumentException (b/single (rx/empty))))), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, + * Returns an Observable that emits only the very first item emitted by the source Observable., + * This is just a shorthand for `take(1)`., + *, + * @return an Observable that emits only the very first item from the source, or none if the, + * source Observable completes without emitting a single item., + def first: Observable[T] = take(1), +, + /*, + , +
[+++ b/src/test/java/io/reactivex/processors/UnicastProcessorTest.java, + UnicastProcessor<Integer>.UnicastQueueSubscription usc = (UnicastProcessor<Integer>.UnicastQueueSubscription)us.wip;]
[+++ b/gradle.properties, +version=0.17.2]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, + return lift(new OperatorGroupBy<K, T>(keySelector));, + return lift(new OperatorGroupByUntil<T, TKey, TValue, TDuration>(keySelector, valueSelector, durationSelector));, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return lift(new OperatorGroupBy<K, T>(keySelector));, + return lift(new OperatorGroupByUntil<T, TKey, TValue, TDuration>(keySelector, valueSelector, durationSelector));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return lift(new OperatorGroupBy<K, T>(keySelector));, + return lift(new OperatorGroupByUntil<T, TKey, TValue, TDuration>(keySelector, valueSelector, durationSelector));, +++ /dev/null, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return lift(new OperatorGroupBy<K, T>(keySelector));, + return lift(new OperatorGroupByUntil<T, TKey, TValue, TDuration>(keySelector, valueSelector, durationSelector));, +++ /dev/null, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorGroupBy.java, + /**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + *
[+++ b/src/main/java/io/reactivex/Completable.java, +import org.reactivestreams.Publisher;, +import io.reactivex.internal.operators.single.SingleDelayWithCompletable;, +import io.reactivex.internal.util.ExceptionHelper;, + throw ExceptionHelper.wrapOrThrow(ex);, +++ b/src/main/java/io/reactivex/Completable.java, +import org.reactivestreams.Publisher;, +import io.reactivex.internal.operators.single.SingleDelayWithCompletable;, +import io.reactivex.internal.util.ExceptionHelper;, + throw ExceptionHelper.wrapOrThrow(ex);, +++ b/src/main/java/io/reactivex/Flowable.java, + throw ExceptionHelper.wrapOrThrow(e);, + throw ExceptionHelper.wrapOrThrow(ex);, +++ b/src/main/java/io/reactivex/Completable.java, +import org.reactivestreams.Publisher;, +import io.reactivex.internal.operators.single.SingleDelayWithCompletable;, +import io.reactivex.internal.util.ExceptionHelper;, + throw ExceptionHelper.wrapOrThrow(ex);, +++ b/src/main/java/io/reactivex/Flowable.java, + throw ExceptionHelper.wrapOrThrow(e);, + throw ExceptionHelper.wrapOrThrow(ex);, +++ b/src/main/java/io/reactivex/Observable.java, + throw ExceptionHelper.wrapOrThrow(e);, + throw ExceptionHelper.wrapOrThrow(ex);, +++ b/src/main/java/io/reactivex/Completable.java, +import org.reactivestreams.Publisher;, +import io.reactivex.internal.operators.single.SingleDelayWithCompletable;, +import io.reactivex.internal.util.ExceptionHelper;, + throw ExceptionHelper.wrapOrThrow(ex);, +++ b/src/main/java/io/reactivex/Flowable.java, + throw ExceptionHelper.wrapOrThrow(e);, + throw ExceptionHelper.wrapOrThrow(ex);, +++ b/src/main/java/io/reactivex/Observable.java, + throw ExceptionHelper.wrapOrThrow(e);, + throw ExceptionHelper.wrapOrThrow(ex);, +++ b/src/main/java/io/reactivex/Scheduler.java, +import io.reactivex.internal.util.ExceptionHelper;, + /**, + * Returns the clock drift tolerance in nanoseconds.,
[+++ b/src/main/java/io/reactivex/Observable.java, + } else, + if ((long)start + (count - 1) > Integer.MAX_VALUE) {, +++ b/src/main/java/io/reactivex/Observable.java, + } else, + if ((long)start + (count - 1) > Integer.MAX_VALUE) {, +++ b/src/main/java/io/reactivex/internal/operators/PublisherIterableSource.java, + , + if (!it.hasNext()) {, + EmptySubscription.complete(s);, + return;, + }, +++ b/src/main/java/io/reactivex/Observable.java, + } else, + if ((long)start + (count - 1) > Integer.MAX_VALUE) {, +++ b/src/main/java/io/reactivex/internal/operators/PublisherIterableSource.java, + , + if (!it.hasNext()) {, + EmptySubscription.complete(s);, + return;, + }, +++ b/src/main/java/io/reactivex/internal/operators/PublisherRangeSource.java, + final long end;, + this.end = (long)start + (count - 1);, + final long end;, + public RangeSubscription(Subscriber<? super Integer> actual, int start,
[+++ b/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/Async.java, +++ b/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/Async.java, +++ /dev/null, +++ b/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/Async.java, +++ /dev/null, +++ b/rxjava-contrib/rxjava-async-util/src/test/java/rx/util/async/AsyncTest.java, +import static org.mockito.Matchers.*;, +++ b/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/Async.java, +++ /dev/null, +++ b/rxjava-contrib/rxjava-async-util/src/test/java/rx/util/async/AsyncTest.java, +import static org.mockito.Matchers.*;, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationZip;, + * <em>Note:</em> Use {@link #create(OnSubscribe)} to create an Observable, instead of this, + * @param f, + * {@link OnSubscribe} to be executed when {@link #subscribe(Subscriber)} is called, + * Returns an Observable that will execute the specified function when a {@link Subscriber}, + * subscribes to it., + * invoke the Subscriber's {@link Subscriber#onNext onNext}, {@link Subscriber#onError onError},, + * and {@link Subscriber#onCompleted onCompleted} methods appropriately., + * A
[+++ b/src/main/java/io/reactivex/Observable.java, + * Converts the current Observable into a Flowable by applying the specified backpressure strategy., + * @return the new Flowable instance]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * If the {@code Flowable} may emit more than one item, use {@code Flowable.toList().toFuture()}., + * to avoid same-pool deadlock because requests may pile up behind an eager/blocking emitter., + * because requests may pile up behind an eager/blocking emitter., + * Returns a Single that emits a single item, a list composed of all the items emitted by the, + * finite upstream source Publisher., + * Note that this operator requires the upstream to signal {@code onComplete} for the accumulated list to, + * be emitted. Sources that are infinite and never complete will
[+++ b/gradle.properties, +version=0.12.0]
[+++ b/src/main/java/io/reactivex/Observable.java, + * s.dispose();, + * final class CustomOperator&lt;T&gt; implements ObservableOperator&lt;String, T&gt; {, + * public Observer&lt;T&gt; apply(Observer&lt;? super String&gt; downstream) {, + * return new CustomObserver&lt;T&gt;(downstream);]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/build.gradle, + srcDir 'src/examples/java', + java.srcDirs = [], + // It seems that in Gradle, the dependency "compileScala depends on compileJava" is hardcoded,, + // or at least not meant to be removed., + // However, compileScala also runs javac at the very end, so we just add the Java sources to, + // the scala source set:, + srcDir 'src/examples/java', + java.srcDirs = [], +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/build.gradle, + srcDir 'src/examples/java', + java.srcDirs = [],
[+++ b/gradlew, +++ b/gradlew, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ b/gradlew, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/gradlew, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +import static rx.lang.scala.JavaConversions.toScalaObservable;, +++ b/gradlew, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +import static rx.lang.scala.JavaConversions.toScalaObservable;, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, + def mountainBikeMedals: Observable[Medal] = Observable(, + Observable(, + Observable(, + Observable(, + Observable(, + Observable(, + Observable(), +++ b/gradlew, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +import static rx.lang.scala.JavaConversions.toScalaObservable;, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, + def mountainBikeMedals: Observable[Medal] = Observable(, + Observable(, + Observable(, + Observable(,
[+++ b/src/main/java/io/reactivex/Observable.java, + public final <U> Observable<U> collectInto(U initialValue, BiConsumer<? super U, ? super T> collector) {]
[+++ b/src/main/java/io/reactivex/Observable.java, + public static <T> Observable<T> merge(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency) {, + public final <U, R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper, BiFunction<? super T, ? super U, ? extends R> resultSelector) {, + return flatMap(mapper, resultSelector, false, bufferSize(), bufferSize());, + }, +, + public final <R> Observable<R> flatMap(, + Function<? super T, ? extends Publisher<? extends R>> onNextMapper, , + Function<? super Throwable, ? extends Publisher<? extends R>> onErrorMapper, , + Supplier<? extends Publisher<? extends R>> onCompleteSupplier) {, + return merge(lift(new OperatorMapNotification<>(onNextMapper, onErrorMapper, onCompleteSupplier)));, + }, +, + public
[+++ b/gradle.properties, +version=0.10.0-SNAPSHOT]
[+++ b/CHANGES.md, +### Version 0.13.4 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.13.4%22)) ###, +, +* [Pull 393](https://github.com/Netflix/RxJava/pull/393) Parallel Operator & ObserveOn/ScheduledObserver Fixes, +* [Pull 394](https://github.com/Netflix/RxJava/pull/394) Change Interval and Sample default Scheduler, +* [Pull 391](https://github.com/Netflix/RxJava/pull/391) Fix OSGI support for rxjava-scala, +, +### Version 0.13.3, +, +* Upload to Sonatype failed so version skipped, +, +### Version 0.13.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.13.2%22)) ###, +, +* [Pull 389](https://github.com/Netflix/RxJava/pull/389) Scala Adaptor Improvements, +* [Pull 382](https://github.com/Netflix/RxJava/pull/382) Removing deprecated RxImplicits from rxjava-scala, +* [Pull 381](https://github.com/Netflix/RxJava/pull/381) Operator: mapWithIndex, +* [Pull 380](https://github.com/Netflix/RxJava/pull/380) Implemented `distinct` and `distinctUntilChanged` variants using a comparator, +* [Pull 379](https://github.com/Netflix/RxJava/pull/379) Make `interval` work with multiple subscribers, +, +++ b/CHANGES.md, +### Version
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorSampleWithObservable;, +import rx.operators.OperatorSampleWithTime;, +import rx.operators.OperatorTimerOnce;, +import rx.operators.OperatorTimerPeriodically;, + return create(new OperatorTimerPeriodically(interval, interval, unit, Schedulers.computation()));, + return create(new OperatorTimerPeriodically(interval, interval, unit, scheduler));, + return create(new OperatorTimerPeriodically(initialDelay, period, unit, scheduler));, + * @return an Observable that emits one item after a specified delay, and then completes, + * @return Observable that emits one item after a specified delay, on a specified Scheduler, and then, + * completes, + return create(new OperatorTimerOnce(delay, unit, scheduler));, + return lift(new OperatorSampleWithTime<T>(period, unit, Schedulers.computation()));, + return lift(new OperatorSampleWithTime<T>(period, unit, scheduler));, + return lift(new OperatorSampleWithObservable<T, U>(sampler));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorSampleWithObservable;, +import rx.operators.OperatorSampleWithTime;, +import rx.operators.OperatorTimerOnce;,
[+++ b/src/main/java/io/reactivex/Single.java, +import io.reactivex.internal.operators.completable.CompletableFromSingle;, +import io.reactivex.internal.operators.flowable.*;, +import io.reactivex.internal.operators.flowable.FlowableConcatMap.ErrorMode;, + * The Single class implements the Reactive Pattern for a single value response. , + * See {@link Flowable} or {@link Observable} for the, + * implementation of the Reactive Pattern for a stream or vector of values., + * <p>, + * {@code Single} behaves the same as {@link Observable} except that it can only emit either a single successful, + * value, or an error (there is no "onComplete" notification as there is for {@link Observable}), + * <p>, + * Like an {@link Observable}, a {@code Single}
[+++ b/gradle.properties, +version=0.11.1-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * This differs from {@code doAfterTerminate} in that this happens <em>before</em> the {@code onComplete} or, +++ b/src/main/java/io/reactivex/Flowable.java, + * This differs from {@code doAfterTerminate} in that this happens <em>before</em> the {@code onComplete} or, +++ b/src/main/java/io/reactivex/Observable.java, + * This differs from {@code doAfterTerminate} in that this happens <em>before</em> the {@code onComplete} or, +++ b/src/main/java/io/reactivex/Flowable.java, + * This differs from {@code doAfterTerminate} in that this happens <em>before</em> the {@code onComplete} or, +++ b/src/main/java/io/reactivex/Observable.java, + * This differs from {@code doAfterTerminate} in that this happens <em>before</em> the {@code onComplete} or, +++ b/src/test/java/io/reactivex/flowable/FlowableNullTests.java, + public void doAfterTerminateNull() {, +++ b/src/main/java/io/reactivex/Flowable.java,
[+++ b/.travis.yml, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/src/main/java/rx/Observable.java, + * For more information see the <a href="https://github.com/ReactiveX/RxJava/wiki/Observable">RxJava wiki</a>, + * @see <a href="https://github.com/ReactiveX/RxJava/wiki/Creating-Observables#create">RxJava wiki: create</a>, + *
[+++ b/gradle.properties, +version=0.17.0]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorFinally;, + return lift(new OperatorFinally<T>(action));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorFinally;, + return lift(new OperatorFinally<T>(action));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorFinally;, + return lift(new OperatorFinally<T>(action));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorFinally.java, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not, + * use this file except in compliance with the License. You may obtain a copy of, + * the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under
[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/ImplicitFunctionConversions.scala, +/**, + * Copyright 2013 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See
[+++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ /dev/null, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null,
[+++ b/src/main/java/io/reactivex/schedulers/TestScheduler.java, +import java.util.concurrent.PriorityBlockingQueue;, + private final Queue<TimedRunnable> queue = new PriorityBlockingQueue<TimedRunnable>(11);, + private volatile long time;, +++ b/src/main/java/io/reactivex/schedulers/TestScheduler.java, +import java.util.concurrent.PriorityBlockingQueue;, + private final Queue<TimedRunnable> queue = new PriorityBlockingQueue<TimedRunnable>(11);, + private volatile long time;, +++ b/src/test/java/io/reactivex/schedulers/TestSchedulerTest.java, +import static org.junit.Assert.fail;, +import java.util.concurrent.BrokenBarrierException;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.CyclicBarrier;, +]
[+++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.internal.operators.flowable.FlowableDelaySubscriptionOther;, +import io.reactivex.internal.operators.observable.ObservableDelaySubscriptionOther;, +import io.reactivex.internal.operators.single.*;, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code amb} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code amb} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code complete} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code concat} does not operate by default on a particular {@link Scheduler}.</dd>, + *
[+++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java, +import io.reactivex.exceptions.Exceptions;, +import io.reactivex.internal.queue.SpscLinkedArrayQueue;, + this.queue = new SpscLinkedArrayQueue<T>(prefetch);, +++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java, +import io.reactivex.exceptions.Exceptions;, +import io.reactivex.internal.queue.SpscLinkedArrayQueue;, + this.queue = new SpscLinkedArrayQueue<T>(prefetch);, +++ b/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybeTest.java, +, + @Test, + public void checkUnboundedInnerQueue() {, + MaybeSubject<Integer> ms = MaybeSubject.create();, + , + @SuppressWarnings("unchecked"), + TestObserver<Integer> to = Observable, + .fromArray(ms, Maybe.just(2), Maybe.just(3), Maybe.just(4)), + .concatMapMaybe(Functions.<Maybe<Integer>>identity(), 2), + .test();, +, + to.assertEmpty();, +, + ms.onSuccess(1);, +, + to.assertResult(1, 2, 3, 4);, + }, +++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java, +import io.reactivex.exceptions.Exceptions;, +import io.reactivex.internal.queue.SpscLinkedArrayQueue;, + this.queue = new SpscLinkedArrayQueue<T>(prefetch);, +++ b/src/test/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybeTest.java, +, + @Test, + public void checkUnboundedInnerQueue() {, + MaybeSubject<Integer> ms = MaybeSubject.create();, + , +
[+++ b/src/main/java/io/reactivex/Observable.java, + return (new ObservableAll<T>(this, predicate));, + return new ObservableAny<T>(this, predicate);, + return new ObservableBuffer<T, U>(this, count, skip, bufferSupplier);, + return new ObservableBufferTimed<T, U>(this, timespan, timeskip, unit, scheduler, bufferSupplier, Integer.MAX_VALUE, false);, + return new ObservableBufferTimed<T, U>(this, timespan, timespan, unit, scheduler, bufferSupplier, count, restartTimerOnMaxSize);, + return new ObservableBufferBoundary<T, U, TOpening, TClosing>(this, bufferOpenings, bufferClosingSelector, bufferSupplier);, + return new ObservableBufferExactBoundary<T, U, B>(this, boundary, bufferSupplier);, + return new ObservableBufferBoundarySupplier<T, U, B>(this, boundarySupplier, bufferSupplier);, +++ b/src/main/java/io/reactivex/Observable.java, + return (new ObservableAll<T>(this, predicate));, + return new ObservableAny<T>(this, predicate);, + return new ObservableBuffer<T, U>(this, count, skip, bufferSupplier);, + return new ObservableBufferTimed<T, U>(this, timespan, timeskip, unit, scheduler,
[+++ b/src/main/java/io/reactivex/processors/ReplayProcessor.java, + long limit = scheduler.now(unit) - maxAge;, + if (h.time < limit) {, + return null;, + }, +, +++ b/src/main/java/io/reactivex/processors/ReplayProcessor.java, + long limit = scheduler.now(unit) - maxAge;, + if (h.time < limit) {, + return null;, + }, +, +++ b/src/main/java/io/reactivex/subjects/ReplaySubject.java, + long limit = scheduler.now(unit) - maxAge;, + if (h.time < limit) {, + return null;, + }, +, +++ b/src/main/java/io/reactivex/processors/ReplayProcessor.java, + long limit = scheduler.now(unit) - maxAge;, + if (h.time < limit) {, + return null;, + }, +, +++ b/src/main/java/io/reactivex/subjects/ReplaySubject.java, + long limit = scheduler.now(unit) - maxAge;, + if (h.time < limit) {,
[+++ b/src/main/java/io/reactivex/observers/SafeObserver.java, +++ b/src/main/java/io/reactivex/observers/SafeObserver.java, +++ b/src/main/java/io/reactivex/subscribers/SafeSubscriber.java, +++ b/src/main/java/io/reactivex/observers/SafeObserver.java, +++ b/src/main/java/io/reactivex/subscribers/SafeSubscriber.java, +++ b/src/test/java/io/reactivex/subscribers/SafeObserverTest.java, + assertSame(actual, s.actual);]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorParallel;, + return bind(new OperatorParallel<T, R>(f, Schedulers.computation()));, + return bind(new OperatorParallel<T, R>(f, s));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorParallel;, + return bind(new OperatorParallel<T, R>(f, Schedulers.computation()));, + return bind(new OperatorParallel<T, R>(f, s));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorParallel;, + return bind(new OperatorParallel<T, R>(f, Schedulers.computation()));, + return bind(new OperatorParallel<T, R>(f, s));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorParallel.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License
[+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableCombineLatest.java, + cancelSources();, + clear(queue);, + cancelSources();, + }, +, + void cancelSources() {, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableCombineLatest.java, + cancelSources();, + clear(queue);, + cancelSources();, + }, +, + void cancelSources() {, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCombineLatestTest.java, +, + @Test, + public void eagerDispose() {, + final PublishProcessor<Integer> pp1 = PublishProcessor.create();, + final PublishProcessor<Integer> pp2 = PublishProcessor.create();, +, + TestSubscriber<Integer> ts = new TestSubscriber<Integer>() {, + @Override, + public void onNext(Integer t) {, + super.onNext(t);, + cancel();, + if (pp1.hasSubscribers()) {, + onError(new IllegalStateException("pp1 not disposed"));, + } else, + if (pp2.hasSubscribers()) {, + onError(new IllegalStateException("pp2 not disposed"));, + } else {, + onComplete();,
[+++ b/src/main/java/io/reactivex/Completable.java, + return RxJavaPlugins.onAssembly(new CompletableWrapper(onSubscribe));, + @SchedulerSupport(SchedulerSupport.NONE), + public static Completable fromFuture(final Future<?> future) {, + Objects.requireNonNull(future, "future is null");, + return fromCallable(new Callable<Object>() {, + @Override, + public Object call() throws Exception {, + future.get();, + return null;, + }, + });, + }, + , + * Returns an Observable which will subscribe to this Completable and once that is completed then , + * will subscribe to the {@code next} Observable. An error event from this Completable will be , + * propagated to the downstream subscriber and will result in skipping the subscription of
[+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/ViewObservable.java, +import rx.operators.OperatorEditTextInput;, +import android.widget.EditText;, + public static Observable<String> input(final EditText input, final boolean emitInitialValue) {, + return Observable.create(new OperatorEditTextInput(input, emitInitialValue));, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/ViewObservable.java, +import rx.operators.OperatorEditTextInput;, +import android.widget.EditText;, + public static Observable<String> input(final EditText input, final boolean emitInitialValue) {, + return Observable.create(new OperatorEditTextInput(input, emitInitialValue));, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorEditTextInput.java, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, +
[+++ b/src/main/java/io/reactivex/internal/operators/OperatorObserveOn.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (SubscriptionHelper.validateSubscription(this.s, s)) {, + , +++ b/src/main/java/io/reactivex/internal/operators/OperatorObserveOn.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (SubscriptionHelper.validateSubscription(this.s, s)) {, + , +++ b/src/main/java/io/reactivex/internal/operators/PublisherAmb.java, + Publisher<? extends T>[] b = new Publisher[count + (count >> 2)];, +++ b/src/main/java/io/reactivex/internal/operators/OperatorObserveOn.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (SubscriptionHelper.validateSubscription(this.s, s)) {, + , +++ b/src/main/java/io/reactivex/internal/operators/PublisherAmb.java, + Publisher<? extends T>[] b = new Publisher[count + (count >> 2)];, +++ b/src/main/java/io/reactivex/internal/operators/PublisherCombineLatest.java, +import java.util.*;, + Publisher<? extends T>[] b = new Publisher[count + (count >> 2)];, + Object last = "1";, + void combine(T value, int index) {, + // see if either all sources completed, + empty
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorAsObservable;, + return lift(new OperatorAsObservable<T>());, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorAsObservable;, + return lift(new OperatorAsObservable<T>());, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorAsObservable;, + return lift(new OperatorAsObservable<T>());, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorAsObservable.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, +
[+++ b/src/test/java/io/reactivex/tck/BehaviorProcessorAsPublisherTckTest.java, + public BehaviorProcessorAsPublisherTckTest() {, + super(50);, + }, +, +++ b/src/test/java/io/reactivex/tck/BehaviorProcessorAsPublisherTckTest.java, + public BehaviorProcessorAsPublisherTckTest() {, + super(50);, + }, +, +++ b/src/test/java/io/reactivex/tck/IntervalTckTest.java, + public IntervalTckTest() {, + super(50);, + }, +]
[+++ b/src/main/java/io/reactivex/BackpressureStrategy.java, + MISSING,, +++ b/src/main/java/io/reactivex/BackpressureStrategy.java, + MISSING,, +++ b/src/main/java/io/reactivex/Observable.java, + case MISSING:, +++ b/src/main/java/io/reactivex/BackpressureStrategy.java, + MISSING,, +++ b/src/main/java/io/reactivex/Observable.java, + case MISSING:, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCreate.java, + case MISSING: {, + emitter = new MissingEmitter<T>(t);, + static final class MissingEmitter<T> extends BaseEmitter<T> {, + MissingEmitter(Subscriber<? super T> actual) {, +++ b/src/main/java/io/reactivex/BackpressureStrategy.java, + MISSING,, +++ b/src/main/java/io/reactivex/Observable.java, + case MISSING:, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCreate.java, + case MISSING: {, + emitter = new MissingEmitter<T>(t);, + static final class MissingEmitter<T> extends BaseEmitter<T> {, + MissingEmitter(Subscriber<? super T> actual) {, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCreateTest.java, + public void createNullValueMissing() {, + }, BackpressureStrategy.MISSING), + public void createNullValueMissingSerialized() {, + }, BackpressureStrategy.MISSING),
[+++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java, + * <p>, + * Note that accessing the items via certain methods of the {@link List}, + * interface while the upstream is still actively emitting, + * more items may result in a {@code ConcurrentModificationException}., + * <p>, + * The {@link List#size()} method will return the number of items, + * already received by this TestObserver/TestSubscriber in a thread-safe, + * manner that can be read via {@link List#get(int)}) method, + * (index range of 0 to {@code List.size() - 1})., + * <p>, + * A view of the returned List can be
[+++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeTakeUntilPublisher.java, + SubscriptionHelper.cancel(this);, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeTakeUntilPublisher.java, + SubscriptionHelper.cancel(this);, +++ b/src/main/java/io/reactivex/internal/operators/single/SingleTakeUntil.java, + other.dispose();, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeTakeUntilPublisher.java, + SubscriptionHelper.cancel(this);, +++ b/src/main/java/io/reactivex/internal/operators/single/SingleTakeUntil.java, + other.dispose();, +++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableAmbTest.java, +, +, + @Test, + public void untilCompletableMainComplete() {, + CompletableSubject main = CompletableSubject.create();, + CompletableSubject other = CompletableSubject.create();, +, + TestObserver<Void> to = main.ambWith(other).test();, +, + assertTrue("Main no observers?", main.hasObservers());, + assertTrue("Other no observers?", other.hasObservers());, +, + main.onComplete();, +, + assertFalse("Main has observers?", main.hasObservers());, + assertFalse("Other has observers?", other.hasObservers());, +, + to.assertResult();, + }, +, + @Test, + public void untilCompletableMainError() {, + CompletableSubject main = CompletableSubject.create();, + CompletableSubject other = CompletableSubject.create();, +, + TestObserver<Void> to
[+++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/blocking_test.clj, + (is (thrown? java.lang.IllegalArgumentException (b/single (rx/empty))))), +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/blocking_test.clj, + (is (thrown? java.lang.IllegalArgumentException (b/single (rx/empty))))), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/blocking_test.clj, + (is (thrown? java.lang.IllegalArgumentException (b/single (rx/empty))))), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, + * Returns an Observable that emits only the very first item emitted by the source Observable., + * This is just a shorthand for `take(1)`., + *, + * @return an Observable that emits only the very first item from the source, or none if the, + * source Observable completes without emitting a single item., + def first: Observable[T] = take(1), +, + /*, + , +
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationDefer;, +import rx.operators.OperatorDematerialize;, + return create(OperationDefer.defer(observableFactory));, + @SuppressWarnings({"unchecked", "rawtypes"}), + return lift(new OperatorDematerialize());, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationDefer;, +import rx.operators.OperatorDematerialize;, + return create(OperationDefer.defer(observableFactory));, + @SuppressWarnings({"unchecked", "rawtypes"}), + return lift(new OperatorDematerialize());, +++ b/rxjava-core/src/main/java/rx/operators/OperationDefer.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to
[+++ b/src/main/java/io/reactivex/Observable.java, + if (onSubscribe instanceof PublisherScalarSource) {, + PublisherScalarSource<T> scalar = (PublisherScalarSource<T>) onSubscribe;, + return create(scalar.flatMap(mapper));, + }, + Objects.requireNonNull(scheduler);, + if (bufferSize <= 0) {, + throw new IllegalArgumentException("bufferSize > 0 required but it was " + bufferSize);, + }, + return lift(new OperatorObserveOn<>(scheduler, delayError, bufferSize));, + return subscribeOn(scheduler, true);, + }, + , + public final Observable<T> subscribeOn(Scheduler scheduler, boolean requestOn) {, + Objects.requireNonNull(scheduler);, + return create(new PublisherSubscribeOn<>(this, scheduler, requestOn));, + Objects.requireNonNull(scheduler);, + return lift(new OperatorUnsubscribeOn<>(scheduler));, + Objects.requireNonNull(selector);, + Objects.requireNonNull(selector);, + Objects.requireNonNull(selector);, + Objects.requireNonNull(selector);, +++ b/src/main/java/io/reactivex/Observable.java, + if (onSubscribe instanceof PublisherScalarSource) {, + PublisherScalarSource<T> scalar =
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC3-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC3-SNAPSHOT, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC3-SNAPSHOT, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyFunctionWrapper.java, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC3-SNAPSHOT, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyFunctionWrapper.java, +++ b/rxjava-core/src/main/java/rx/Observable.java, + * recieves an Observable of notifications with which a user can complete or error, aborting the repeat. , + * recieves an Observable of notifications with which a user can complete or error, aborting the repeat. , + * recieves an Observable of notifications with which a user can complete or error, aborting the, + * recieves an Observable of notifications with which a
[+++ b/src/test/java/io/reactivex/internal/schedulers/SingleSchedulerTest.java, +import io.reactivex.schedulers.AbstractSchedulerTests;, +public class SingleSchedulerTest extends AbstractSchedulerTests {, + @Override protected Scheduler getScheduler() {, + return Schedulers.single();]
[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +, + @Test def liftExample1(): Unit = {, + // Add "No. " in front of each item, + val o = List(1, 2, 3).toObservable.lift {, + subscriber: Subscriber[String] =>, + Subscriber[Int](, + subscriber,, + (v: Int) => subscriber.onNext("No. " + v),, + e => subscriber.onError(e),, + () => subscriber.onCompleted, + ), + }.toBlockingObservable.toList, + println(o), + }, +, + @Test def liftExample2(): Unit = {, + // Split the input Strings with " ", + val splitStringsWithSpace = (subscriber: Subscriber[String]) => {, + Subscriber[String](, + subscriber,, + (v: String) => v.split(" ").foreach(subscriber.onNext(_)),, + e => subscriber.onError(e),,
[+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableRepeatWhen.java, + active = false;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableRepeatWhen.java, + active = false;, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRepeatTest.java, +import io.reactivex.plugins.RxJavaPlugins;, +, + @Test, + public void repeatFloodNoSubscriptionError() {, + List<Throwable> errors = TestHelper.trackPluginErrors();, +, + try {, + final PublishProcessor<Integer> source = PublishProcessor.create();, + final PublishProcessor<Integer> signaller = PublishProcessor.create();, +, + for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) {, +, + TestSubscriber<Integer> ts = source.take(1), + .repeatWhen(new Function<Flowable<Object>, Flowable<Integer>>() {, + @Override, + public Flowable<Integer> apply(Flowable<Object> v), + throws Exception {, + return signaller;, + }, + }).test();, +, + Runnable r1 = new Runnable() {, + @Override, + public void
[+++ b/src/main/java/rx/Notification.java, +public final class Notification<T> {, +++ b/src/main/java/rx/Notification.java, +public final class Notification<T> {, +++ b/src/main/java/rx/Observable.java, + return create(new OnSubscribeDelayWithSelector<T, U, V>(this, subscriptionDelay, itemDelay));, + return create(new OnSubscribeDelayWithSelector<T, U, U>(this, itemDelay));, + return create(new OnSubscribeDelay<T>(this, delay, unit, scheduler));, + * @see <a href="https://github.com/ReactiveX/RxJava/wiki/Transforming-Observables#groupby-and-groupbyuntil">RxJava wiki: groupBy</a>, + * @see <a href="https://github.com/ReactiveX/RxJava/wiki/Transforming-Observables#groupby-and-groupbyuntil">RxJava wiki: groupBy</a>, + * Returns an Observable that counts the total number of items emitted by the source Observable and emits, + * this count as a 64-bit Long., + * <p>, + * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/longCount.png" alt="">, + * <dl>, + * <dt><b>Backpressure Support:</b></dt>, + * <dd>This
[+++ b/src/main/java/io/reactivex/disposables/CompositeDisposable.java, + /**, + * Adds a disposable to this container or disposes it if the, + * container has been disposed., + * @param d the disposable to add, not null, + * @return true if successful, false if this container has been disposed, + */, + /**, + * Removes and disposes the given disposable if it is part of this, + * container., + * @param d the disposable to remove and dispose, not null, + * @return true if the operation was successful, + */, + /**, + * Removes (but does not dispose)
[+++ b/.gitignore, +.gradletasknamecache, +++ b/.gitignore, +.gradletasknamecache, +++ b/rxjava-contrib/rxjava-android-samples-build-wrapper/build.gradle, +def androidHome = System.getenv("ANDROID_HOME"), +tasks.build.doLast {, + if (androidHome.isEmpty()) {, + println("No Android SDK detected; skipping Android samples build"), + } else {, + println("Android SDK detected at $androidHome, running samples build"), + project.exec {, + workingDir '../rxjava-android-samples', +, + def props = new Properties(), + file("$rootDir/gradle.properties").withReader { reader ->, + props.load(reader), + properties.putAll(props), + }, +, + commandLine "./gradlew", "clean", "packageDebug", "-PrxjVersion=${props.getProperty("version")}", + }, + }, +}, +++ b/.gitignore, +.gradletasknamecache, +++ b/rxjava-contrib/rxjava-android-samples-build-wrapper/build.gradle, +def androidHome = System.getenv("ANDROID_HOME"), +tasks.build.doLast {, + if (androidHome.isEmpty()) {, + println("No Android SDK detected; skipping Android samples
[+++ b/gradle.properties, +version=0.8.5, +++ b/gradle.properties, +version=0.8.5, +++ b/language-adaptors/README.md, +, +NOTE: Changes are coming in regards to static and dynamic typing and how language adaptors are used., +, +See https://github.com/Netflix/RxJava/issues/208 and https://github.com/Netflix/RxJava/issues/204, +++ b/gradle.properties, +version=0.8.5, +++ b/language-adaptors/README.md, +, +NOTE: Changes are coming in regards to static and dynamic typing and how language adaptors are used., +, +See https://github.com/Netflix/RxJava/issues/208 and https://github.com/Netflix/RxJava/issues/204, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/gradle.properties, +version=0.8.5, +++ b/language-adaptors/README.md, +, +NOTE: Changes are coming in regards to static and dynamic typing and how language adaptors are used., +, +See https://github.com/Netflix/RxJava/issues/208 and https://github.com/Netflix/RxJava/issues/204, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/concurrency/DiscardableAction.java, +import rx.operators.AtomicObservableSubscription;, +++ b/gradle.properties, +version=0.8.5, +++
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java, +import io.reactivex.internal.fuseable.ConditionalSubscriber;, + static final class WithLatestFromSubscriber<T, U, R> extends AtomicReference<U>, + implements ConditionalSubscriber<T>, Subscription {, + if (!tryOnNext(t)) {, + s.get().request(1);, + }, + }, +, + @Override, + public boolean tryOnNext(T t) {, + return false;, + return true;, + return false;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java, +import io.reactivex.internal.fuseable.ConditionalSubscriber;, + static final class WithLatestFromSubscriber<T, U, R> extends AtomicReference<U>, + implements ConditionalSubscriber<T>, Subscription {, + if (!tryOnNext(t)) {, + s.get().request(1);, + }, + }, +, + @Override, + public boolean tryOnNext(T t) {, + return false;, + return true;, + return false;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFromMany.java, +import io.reactivex.internal.fuseable.ConditionalSubscriber;, + implements ConditionalSubscriber<T>,
[+++ b/src/main/java/io/reactivex/Flowable.java, + * <em>Important note:</em> This Publisher is blocking on the thread it gets subscribed on; you cannot cancel it., + * <em>Important note:</em> This Publisher is blocking on the thread it gets subscribed on; you cannot cancel it., + * <em>Important note:</em> This Publisher is blocking; you cannot cancel it., + * If the outer Publisher signals an onError, the inner Publisher is cancelled and the error delivered in-sequence., + * If the outer Publisher signals an onError, the inner Publisher is cancelled and the error delivered in-sequence., + * one of the sources is shorter than
[+++ b/src/main/java/rx/Observable.java, + return delaySubscription(subscriptionDelay).lift(new OperatorDelayWithSelector<T, V>(this, itemDelay));, + return lift(new OperatorDelayWithSelector<T, U>(this, itemDelay));, + return lift(new OperatorDelay<T>(this, delay, unit, scheduler));, + * Returns an Observable that delays the subscription to the source Observable by a given amount of time., + * <p>, + * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delaySubscription.png" alt="">, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>This version of {@code delay} operates by default on the {@code compuation} {@link Scheduler}.</dd>, + * </dl>, + * , + * @param delay, + * the time to delay the subscription, + * @param unit, + * the time unit
[+++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableFromCallableTest.java, +import java.util.List;, +import io.reactivex.exceptions.TestException;, +import io.reactivex.plugins.RxJavaPlugins;, +, + @Test, + public void disposedOnArrival() {, + final int[] count = { 0 };, + Observable.fromCallable(new Callable<Object>() {, + @Override, + public Object call() throws Exception {, + count[0]++;, + return 1;, + }, + }), + .test(true), + .assertEmpty();, +, + assertEquals(0, count[0]);, + }, +, + @Test, + public void disposedOnCall() {, + final TestObserver<Integer> to = new TestObserver<Integer>();, +, + Observable.fromCallable(new Callable<Integer>() {, + @Override, + public Integer call() throws Exception {, + to.cancel();, + return 1;, + }, + }), + .subscribe(to);, +, + to.assertEmpty();,
[+++ b/build.gradle, + compile 'org.reactivestreams:reactive-streams:1.0.0', +++ b/build.gradle, + compile 'org.reactivestreams:reactive-streams:1.0.0', +++ b/src/main/java/io/reactivex/Observable.java, +import java.util.Objects;, +import java.util.function.*;, +, +import org.reactivestreams.*;, +, +public class Observable<T> implements Publisher<T> {, + final Consumer<Subscriber<? super T>> onSubscribe;, + , + private Observable(Consumer<Subscriber<? super T>> onSubscribe) {, + this.onSubscribe = onSubscribe;, + }, + , + public static <T> Observable<T> create(Consumer<Subscriber<? super T>> onSubscribe) {, + // TODO plugin wrapping, + return new Observable<>(onSubscribe);, + }, + , + @Override, + public final void subscribe(Subscriber<? super T> s) {, + Objects.requireNonNull(s);, + try {, + onSubscribe.accept(s);, + } catch (NullPointerException e) {, + throw e;,
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/README.md, +++ b/CHANGES.md, +++ b/README.md, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.*;, + public static <T> Observable<T> subscribeOn(Observable<T> source, Scheduler scheduler) {, + return _create(OperationSubscribeOn.subscribeOn(source, scheduler));, + }, +, + public static <T> Observable<T> observeOn(Observable<T> source, Scheduler scheduler) {, + return _create(OperationObserveOn.observeOn(source, scheduler));, + }, +, + public Observable<T> subscribeOn(Scheduler scheduler) {, + return subscribeOn(this, scheduler);, + }, +, + public Observable<T> observeOn(Scheduler scheduler) {, + return observeOn(this, scheduler);, + }, +, + public Observable<T> dematerialize() {, + return dematerialize((Observable<Notification<T>>) this);, +++ b/CHANGES.md, +++ b/README.md, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.*;, + public static <T> Observable<T> subscribeOn(Observable<T> source, Scheduler
[+++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, + <activity, + android:name=".ListenInOutActivity">, +, + <intent-filter>, + <category android:name="android.intent.category.LAUNCHER"/>, + <category android:name="android.intent.category.DEFAULT"/>, + <action android:name="android.intent.action.MAIN"/>, + </intent-filter>, + </activity>, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, + <activity, + android:name=".ListenInOutActivity">, +, + <intent-filter>, + <category android:name="android.intent.category.LAUNCHER"/>, + <category android:name="android.intent.category.DEFAULT"/>, + <action android:name="android.intent.action.MAIN"/>, + </intent-filter>, + </activity>, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/ListenInOutActivity.java, +package com.netflix.rxjava.android.samples;, +, +import android.app.Activity;, +import android.os.Bundle;, +import android.view.View;, +import android.widget.TextView;, +import android.widget.Toast;, +import android.widget.ToggleButton;, +, +import rx.Observable;, +import rx.Observer;, +import rx.Subscription;, +import rx.observables.ConnectableObservable;, +, +import static rx.android.observables.AndroidObservable.bindActivity;, +, +/**, + * Activity that binds to a counting sequence and is able to listen in and out to that, + * sequence by
[+++ b/src/main/java/io/reactivex/flowables/ConnectableFlowable.java, + * @param connection the callback Consumer that will receive the Subscription representing the, +++ b/src/main/java/io/reactivex/flowables/ConnectableFlowable.java, + * @param connection the callback Consumer that will receive the Subscription representing the, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java, + // outside of this class thus preventing the Consumer passed, + // Consumer passed to source.connect was not called, +++ b/src/main/java/io/reactivex/flowables/ConnectableFlowable.java, + * @param connection the callback Consumer that will receive the Subscription representing the, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java, + // outside of this class thus preventing the Consumer passed, + // Consumer passed to source.connect was not called, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java, + // outside of this
[+++ b/src/main/java/io/reactivex/internal/operators/single/SingleFromCallable.java, + s.onError(new NullPointerException("The callable returned a null value"));]
[+++ b/CHANGES.md, +### Version 0.14.9 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.9%22)) ###, +, +* [Pull 477](https://github.com/Netflix/RxJava/pull/477) BugFix: CompositeSubscription, +* [Pull 476](https://github.com/Netflix/RxJava/pull/476) BugFix: Don't emit null onComplete when no onNext received in AsyncSubject, +* [Pull 474](https://github.com/Netflix/RxJava/pull/474) BugFix: Reduce an empty observable, +* [Pull 474](https://github.com/Netflix/RxJava/pull/474) BugFix: non-deterministic unit test, +* [Pull 472](https://github.com/Netflix/RxJava/pull/472) BugFix: Issue 431 Unsubscribe with Schedulers.newThread, +* [Pull 470](https://github.com/Netflix/RxJava/pull/470) Operator: Last, +, +++ b/CHANGES.md, +### Version 0.14.9 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.9%22)) ###, +, +* [Pull 477](https://github.com/Netflix/RxJava/pull/477) BugFix: CompositeSubscription, +* [Pull 476](https://github.com/Netflix/RxJava/pull/476) BugFix: Don't emit null onComplete when no onNext received in AsyncSubject, +* [Pull 474](https://github.com/Netflix/RxJava/pull/474) BugFix: Reduce an empty observable, +* [Pull 474](https://github.com/Netflix/RxJava/pull/474) BugFix: non-deterministic
[+++ b/src/main/java/io/reactivex/Completable.java, + * <dt><b>Error handling:</b></dt>, + * <dd> If the {@link Runnable} throws an exception, the respective {@link Throwable} is, + * delivered to the downstream via {@link CompletableObserver#onError(Throwable)},, + * except when the downstream has disposed this {@code Completable} source., + * In this latter case, the {@code Throwable} is delivered to the global error handler via, + * {@link RxJavaPlugins#onError(Throwable)} as an {@link io.reactivex.exceptions.UndeliverableException UndeliverableException}., + * </dd>, +++ b/src/main/java/io/reactivex/Completable.java, + * <dt><b>Error handling:</b></dt>, + * <dd> If the {@link Runnable} throws an exception, the respective {@link Throwable} is, + * delivered to the downstream via
[+++ b/src/main/java/io/reactivex/Completable.java, + * @param sources the array of source Completables. A subscription to each source will, + * occur in the same order as in this array., + * @param sources the array of source Completables. A subscription to each source will, + * occur in the same order as in this Iterable., + * @param other the other Completable, not null. A subscription to this provided source will occur after subscribing, + * to the current source., +++ b/src/main/java/io/reactivex/Completable.java, + * @param sources the array of source Completables. A subscription to each source will, + * occur
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.11-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.11-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/README.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.11-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/README.md, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.11-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/README.md, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/TODO.md, +* Bring `BooleanSubscription`, `CompositeSubscription`, `MultipleAssignmentSubscription` to Scala, `compositeSubscription.subscription = ...`instead of setter method, add on `CompositeSubscription` should be `+=`, +* Java Scheduler methods take `state` arguments (they were needed to schedule work on a different machine, but are now considered a bad idea). Remove these `state` arguments from all Scala schedulers., +* add wrappers or aliases for `AsyncSubject<T>`, `BehaviorSubject<T>`, `PublishSubject<T>`, and `ReplaySubject<T>`, +* go through
[+++ b/language-adaptors/rxjava-scala-java/README.md, +, +rxjava-scala-java, +-----------------, +, +Contains examples illustrating how RxScala code can be used from Java., +++ b/language-adaptors/rxjava-scala-java/README.md, +, +rxjava-scala-java, +-----------------, +, +Contains examples illustrating how RxScala code can be used from Java., +++ b/language-adaptors/rxjava-scala-java/build.gradle, +, +apply plugin: 'osgi', +, +, +project(':language-adaptors:rxjava-scala-java') {, + //sourceSets.test.java.srcDir 'src/examples/java', + sourceSets.main.java.srcDir 'src/main/java', +}, +, +dependencies {, + compile 'org.scala-lang:scala-library:2.10.+', +, + compile project(':rxjava-core'), + , + compile project(':language-adaptors:rxjava-scala'), + , + provided 'junit:junit-dep:4.10', + provided 'org.mockito:mockito-core:1.8.5', + provided 'org.scalatest:scalatest_2.10:1.9.1', +}, +, +jar {, + manifest {, + name = 'rxjava-scala-java', + instruction 'Bundle-Vendor', 'Netflix', + instruction 'Bundle-DocURL', 'https://github.com/Netflix/RxJava', + instruction 'Import-Package',
[+++ b/gradle.properties, +version=0.14.8-SNAPSHOT, +++ b/gradle.properties, +version=0.14.8-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, + * Applies a timeout policy for each element in the observable sequence,, + * using the specified scheduler to run timeout timers. If the next element, + * isn't received within the specified timeout duration starting from its, + * predecessor, a TimeoutException is propagated to the observer., + * Maximum duration between values before a timeout occurs., + * The unit of time which applies to the "timeout" argument., + *, + * @see <a href="http://msdn.microsoft.com/en-us/library/hh244283(v=vs.103).aspx">MSDN: Observable.Timeout</a>, + */, + public Observable<T> timeout(long timeout, TimeUnit timeUnit) {, + return
[+++ b/src/main/java/io/reactivex/Observable.java, + * <p>, + * <img width="640" height="347" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapDelayError.o.png" alt="">, + * <p>, + * <img width="640" height="347" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapDelayError.o.png" alt="">, + * <p>, + * <img width="640" height="360" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapEager.o.png" alt="">, + * <p>, + * <img width="640" height="360" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapEager.o.png" alt="">, + * <p>, + * <img width="640" height="390" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapEagerDelayError.o.png" alt="">, + * <p>, + * <img width="640" height="390" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapEagerDelayError.o.png" alt="">, + * <p>, + * <img width="640" height="505" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapCompletable.o.png" alt="">, + * <p>, + * <img width="640" height="505" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapCompletable.o.png" alt="">, + * <p>, + * <img width="640" height="275" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMapIterable.o.png" alt="">, + * <p>, + * <img width="640"
[+++ b/src/main/java/io/reactivex/disposables/CompositeDisposable.java, + * @param disposables the array of Disposables to start with, + * @throws NullPointerException if {@code disposables} or any of its array items is null, + public CompositeDisposable(@NonNull Disposable... disposables) {, + ObjectHelper.requireNonNull(disposables, "disposables is null");, + this.resources = new OpenHashSet<Disposable>(disposables.length + 1);, + for (Disposable d : disposables) {, + ObjectHelper.requireNonNull(d, "A Disposable in the disposables array is null");, + * @param disposables the Iterable sequence of Disposables to start with, + * @throws NullPointerException if {@code disposables} or any of its items is null, + public CompositeDisposable(@NonNull Iterable<? extends Disposable> disposables) {, + ObjectHelper.requireNonNull(disposables,
[+++ b/src/main/java/io/reactivex/Completable.java, + * <img width="640" height="293" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toObservable.png" alt="">, +++ b/src/main/java/io/reactivex/Completable.java, + * <img width="640" height="293" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toObservable.png" alt="">, +++ b/src/main/java/io/reactivex/Flowable.java, + * <img width="640" height="317" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/legend.png" alt="">, + * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromCallable.png" alt="">, + * <img width="640" height="237" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstOrError.png" alt="">, + * <img width="640" height="236" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/lastOrError.png" alt="">, + * <img width="640" height="547" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flowable.parallel.png" alt="">, + * <img width="640" height="547" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flowable.parallel.png" alt="">, + * <img width="640" height="547" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flowable.parallel.png" alt="">, + * <img width="640" height="445" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.fnts.png" alt="">, + * <img width="640" height="276" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.emitlast.png" alt="">, + * <img width="640" height="276" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.s.emitlast.png" alt="">, + * <img width="640" height="289" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.o.nolast.png" alt="">, + *
[+++ b/CHANGES.md, +### Version 0.7.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.7.0%22)) ###, +, +This release adds the foundations of Rx Schedulers., +, +There are still open questions, portions not implemented and assuredly bugs and behavior we didn't understand and thus implemented wrong., +, +Please provide bug reports, pull requests or feedback to help us on the road to version 1.0 and get schedulers implemented correctly., +, +See https://github.com/Netflix/RxJava/issues/19#issuecomment-15979582 for some known open questions that we could use help answering., +, +* [Issue 19](https://github.com/Netflix/RxJava/issues/19) Schedulers, +, +### Version 0.6.3 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.6.3%22)) ###, +, +* [Pull 224](https://github.com/Netflix/RxJava/pull/224) RxJavaObservableExecutionHook, +, +### Version 0.6.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.6.2%22)) ###,
[+++ b/src/main/java/io/reactivex/Observable.java, + public static <T> Observable<T> generate(Consumer<Subscriber<T>> generator) {, + return generate(() -> null, (s, o) -> {, + generator.accept(o);, + return s;, + }, s -> { });, + }, +, + public static <T, S> Observable<T> generate(Supplier<S> initialState, BiConsumer<S, Subscriber<T>> generator) {, + return generate(initialState, (s, o) -> {, + generator.accept(s, o);, + return s;, + }, s -> { });, + }, +, + public static <T, S> Observable<T> generate(Supplier<S> initialState, BiConsumer<S, Subscriber<T>> generator, Consumer<? super S> disposeState) {, + return generate(initialState, (s, o) -> {, + generator.accept(s, o);, + return s;, + }, disposeState);,
[+++ b/CHANGES.md, +### Version 0.8.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.8.1%22)) ###, +, +* [Pull 250](https://github.com/Netflix/RxJava/pull/250) AsyncSubject, +* [Pull 252](https://github.com/Netflix/RxJava/pull/252) ToFuture, +* [Pull 246](https://github.com/Netflix/RxJava/pull/246) Scheduler.schedulePeriodically, +* [Pull 247](https://github.com/Netflix/RxJava/pull/247) flatMap aliased to mapMany, +, +++ b/CHANGES.md, +### Version 0.8.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.8.1%22)) ###, +, +* [Pull 250](https://github.com/Netflix/RxJava/pull/250) AsyncSubject, +* [Pull 252](https://github.com/Netflix/RxJava/pull/252) ToFuture, +* [Pull 246](https://github.com/Netflix/RxJava/pull/246) Scheduler.schedulePeriodically, +* [Pull 247](https://github.com/Netflix/RxJava/pull/247) flatMap aliased to mapMany, +, +++ b/gradle.properties, +version=0.8.2-SNAPSHOT, +++ b/CHANGES.md, +### Version 0.8.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.8.1%22)) ###, +, +* [Pull 250](https://github.com/Netflix/RxJava/pull/250) AsyncSubject, +* [Pull 252](https://github.com/Netflix/RxJava/pull/252) ToFuture, +* [Pull 246](https://github.com/Netflix/RxJava/pull/246) Scheduler.schedulePeriodically, +* [Pull 247](https://github.com/Netflix/RxJava/pull/247) flatMap aliased to mapMany, +, +++ b/gradle.properties, +version=0.8.2-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationGroupBy;, +import rx.operators.OperationToFuture;,
[+++ b/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java, + } else if (null == lvElement(buffer, calcWrappedOffset(index + 1, mask))) { // buffer is not full]
[+++ b/src/main/java/io/reactivex/Flowable.java, + return subscribeWith(new FutureSubscriber<T>());, +++ b/src/main/java/io/reactivex/Flowable.java, + return subscribeWith(new FutureSubscriber<T>());, +++ b/src/main/java/io/reactivex/Observable.java, + return subscribeWith(new FutureObserver<T>());, +++ b/src/main/java/io/reactivex/Flowable.java, + return subscribeWith(new FutureSubscriber<T>());, +++ b/src/main/java/io/reactivex/Observable.java, + return subscribeWith(new FutureObserver<T>());, +++ b/src/main/java/io/reactivex/disposables/Disposables.java, + * @deprecated use {@link #fromRunnable(Runnable)} to avoid lambda-ambiguity, + @Deprecated, + return fromRunnable(run);, + }, +, + /**, + * Construct a Disposable by wrapping a Runnable that is, + * executed exactly once when the Disposable is disposed., + * @param run the Runnable to wrap, + * @return the new Disposable instance, + */, + public static Disposable fromRunnable(Runnable run) {, + * @deprecated
[+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/ViewObservable.java, +import rx.operators.OperatorTextViewInput;, +import android.widget.TextView;, + public static <T extends TextView> Observable<T> input(final T input, final boolean emitInitialValue) {, + return Observable.create(new OperatorTextViewInput<T>(input, emitInitialValue));, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/ViewObservable.java, +import rx.operators.OperatorTextViewInput;, +import android.widget.TextView;, + public static <T extends TextView> Observable<T> input(final T input, final boolean emitInitialValue) {, + return Observable.create(new OperatorTextViewInput<T>(input, emitInitialValue));, +++ /dev/null, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/ViewObservable.java, +import rx.operators.OperatorTextViewInput;, +import android.widget.TextView;, + public static <T extends TextView> Observable<T> input(final T input, final boolean emitInitialValue) {, + return Observable.create(new OperatorTextViewInput<T>(input, emitInitialValue));, +++ /dev/null, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperatorTextViewInput.java, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0
[+++ b/src/test/java/io/reactivex/tck/DelaySubscriptionTckTest.java, + public DelaySubscriptionTckTest() {, + super(200L);, + }, + ]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java, + s.cancel();, + a.cancel();, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java, + s.cancel();, + a.cancel();, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java, + s.dispose();, + a.cancel();, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java, + s.cancel();, + a.cancel();, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java, + s.dispose();, + a.cancel();, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java, + @Test, + public void switchMapInnerCancelled() {, + PublishProcessor<Integer> pp = PublishProcessor.create();, +, + TestSubscriber<Integer> ts = Flowable.just(1), + .switchMap(Functions.justFunction(pp)), + .test();, +, + assertTrue(pp.hasSubscribers());, +, + ts.cancel();, +, + assertFalse(pp.hasSubscribers());, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java, + s.cancel();, + a.cancel();, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java, + s.dispose();, + a.cancel();, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java, + @Test, + public void switchMapInnerCancelled() {, + PublishProcessor<Integer> pp = PublishProcessor.create();, +, + TestSubscriber<Integer> ts = Flowable.just(1), + .switchMap(Functions.justFunction(pp)),
[+++ b/.travis.yml, +after_success: gradle/publishViaTravis.sh, +++ b/.travis.yml, +after_success: gradle/publishViaTravis.sh, +++ b/gradle/buildViaTravis.sh, +echo -e 'Build Script => Branch ['$TRAVIS_BRANCH'] Tag ['$TRAVIS_TAG']', +, +++ b/.travis.yml, +after_success: gradle/publishViaTravis.sh, +++ b/gradle/buildViaTravis.sh, +echo -e 'Build Script => Branch ['$TRAVIS_BRANCH'] Tag ['$TRAVIS_TAG']', +, +++ b/src/main/java/rx/Observable.java, + * Returns an Observable that first emits items emitted by the source Observable, , + * checks the specified condition after each item, and, + * then completes if the condition is satisfied., + * The difference between this operator and {@link #takeWhile(Func1)} is that here, the condition is evaluated <b>after</b>, + * the item was emitted., + * @return
[+++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.operators.observable.ObservableFromPublisher;, + return distinctUntilChanged(Functions.identity());, + return RxJavaPlugins.onAssembly(new FlowableDistinctUntilChanged<T, K>(this, keySelector, ObjectHelper.equalsPredicate()));, + return RxJavaPlugins.onAssembly(new FlowableDistinctUntilChanged<T, T>(this, Functions.<T>identity(), comparer));, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.operators.observable.ObservableFromPublisher;, + return distinctUntilChanged(Functions.identity());, + return RxJavaPlugins.onAssembly(new FlowableDistinctUntilChanged<T, K>(this, keySelector, ObjectHelper.equalsPredicate()));, + return RxJavaPlugins.onAssembly(new FlowableDistinctUntilChanged<T, T>(this, Functions.<T>identity(), comparer));, +++ b/src/main/java/io/reactivex/Observable.java, + return distinctUntilChanged(Functions.identity());, + return RxJavaPlugins.onAssembly(new ObservableDistinctUntilChanged<T, K>(this, keySelector, ObjectHelper.equalsPredicate()));, + return RxJavaPlugins.onAssembly(new ObservableDistinctUntilChanged<T, T>(this, Functions.<T>identity(), comparer));, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.operators.observable.ObservableFromPublisher;, + return distinctUntilChanged(Functions.identity());, + return RxJavaPlugins.onAssembly(new FlowableDistinctUntilChanged<T, K>(this, keySelector, ObjectHelper.equalsPredicate()));, + return RxJavaPlugins.onAssembly(new FlowableDistinctUntilChanged<T, T>(this, Functions.<T>identity(), comparer));, +++ b/src/main/java/io/reactivex/Observable.java, + return distinctUntilChanged(Functions.identity());, + return RxJavaPlugins.onAssembly(new ObservableDistinctUntilChanged<T, K>(this, keySelector, ObjectHelper.equalsPredicate()));, + return RxJavaPlugins.onAssembly(new ObservableDistinctUntilChanged<T, T>(this,
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/SwingObservable.java, +/**, + * Copyright 2013 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS
[+++ b/gradle.properties, +version=0.5.0-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCount.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (!SubscriptionHelper.validateRequest(n)) {, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCount.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (!SubscriptionHelper.validateRequest(n)) {, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAt.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (!SubscriptionHelper.validateRequest(n)) {, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCount.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (!SubscriptionHelper.validateRequest(n)) {, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAt.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (!SubscriptionHelper.validateRequest(n)) {, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableIntervalRange.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (!SubscriptionHelper.validateRequest(n)) {, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCount.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (!SubscriptionHelper.validateRequest(n)) {, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAt.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (!SubscriptionHelper.validateRequest(n)) {, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableIntervalRange.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (!SubscriptionHelper.validateRequest(n)) {, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureLatest.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (!SubscriptionHelper.validateRequest(n)) {, +
[+++ b/src/main/java/rx/Single.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the
[+++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.util.HashMapSupplier;, + return buffer(count, skip, ArrayListSupplier.<T>asCallable());, + return buffer(timespan, timeskip, unit, Schedulers.computation(), ArrayListSupplier.<T>asCallable());, + return buffer(timespan, timeskip, unit, scheduler, ArrayListSupplier.<T>asCallable());, + return buffer(timespan, unit, count, scheduler, ArrayListSupplier.<T>asCallable(), false);, + return buffer(timespan, unit, Integer.MAX_VALUE, scheduler, ArrayListSupplier.<T>asCallable(), false);, + return buffer(bufferOpenings, bufferClosingSelector, ArrayListSupplier.<T>asCallable());, + return buffer(boundary, ArrayListSupplier.<T>asCallable());, + return buffer(boundarySupplier, ArrayListSupplier.<T>asCallable());, + return collect(HashMapSupplier.<K, T>asCallable(), new BiConsumer<Map<K, T>, T>() {, + return collect(HashMapSupplier.<K, V>asCallable(), new BiConsumer<Map<K, V>, T>() {, + Callable<Map<K, Collection<T>>> mapSupplier = HashMapSupplier.asCallable();, + Function<K, List<T>> collectionFactory = ArrayListSupplier.asFunction();, + Callable<Map<K, Collection<V>>> mapSupplier = HashMapSupplier.asCallable();, + Function<K, List<V>> collectionFactory = ArrayListSupplier.asFunction();, + return toMultimap(keySelector, valueSelector, mapSupplier,
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java, + final Scheduler.Worker worker;, + if (restartTimerOnMaxSize) {, + worker = scheduler.createWorker();, + } else {, + worker = null;, + }, + d = worker.schedulePeriodically(consumerIndexHolder, timespan, timespan, unit);, + Worker w = worker;, + if (w != null) {, + w.dispose();, + }, + if (restartTimerOnMaxSize || producerIndex == consumerIndexHolder.index) {, + count = 0;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java, + final Scheduler.Worker worker;, + if (restartTimerOnMaxSize) {, + worker = scheduler.createWorker();, + } else {, + worker = null;, + }, + d = worker.schedulePeriodically(consumerIndexHolder, timespan, timespan, unit);, + Worker w = worker;, + if (w != null)
[+++ b/src/jmh/java/io/reactivex/EachTypeFlatMapPerf.java, +, +, +, +, +, +++ b/src/jmh/java/io/reactivex/EachTypeFlatMapPerf.java, +, +, +, +, +, +++ b/src/jmh/java/io/reactivex/LatchedSingleObserver.java, +, +, +, +++ b/src/jmh/java/io/reactivex/EachTypeFlatMapPerf.java, +, +, +, +, +, +++ b/src/jmh/java/io/reactivex/LatchedSingleObserver.java, +, +, +, +++ b/src/jmh/java/io/reactivex/PerfObserver.java, +, +, +, +, +++ b/src/jmh/java/io/reactivex/EachTypeFlatMapPerf.java, +, +, +, +, +, +++ b/src/jmh/java/io/reactivex/LatchedSingleObserver.java, +, +, +, +++ b/src/jmh/java/io/reactivex/PerfObserver.java, +, +, +, +, +++ b/src/jmh/java/io/reactivex/PublishProcessorPerf.java, +++ b/src/jmh/java/io/reactivex/EachTypeFlatMapPerf.java, +, +, +, +, +, +++ b/src/jmh/java/io/reactivex/LatchedSingleObserver.java, +, +, +, +++ b/src/jmh/java/io/reactivex/PerfObserver.java, +, +, +, +, +++ b/src/jmh/java/io/reactivex/PublishProcessorPerf.java, +++ b/src/jmh/java/io/reactivex/ToFlowablePerf.java, +, +++ b/src/jmh/java/io/reactivex/EachTypeFlatMapPerf.java, +, +, +, +, +, +++ b/src/jmh/java/io/reactivex/LatchedSingleObserver.java, +, +, +, +++ b/src/jmh/java/io/reactivex/PerfObserver.java, +, +, +, +, +++
[+++ b/src/main/java/io/reactivex/Maybe.java, + return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, MaybeToPublisher.instance(), false, maxConcurrency, 1));, + return mergeDelayError(sources, Integer.MAX_VALUE);, + ObjectHelper.requireNonNull(sources, "source is null");, + ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");, + return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, MaybeToPublisher.instance(), true, maxConcurrency, 1));, +++ b/src/main/java/io/reactivex/Maybe.java, + return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, MaybeToPublisher.instance(), false, maxConcurrency, 1));, + return mergeDelayError(sources, Integer.MAX_VALUE);, + ObjectHelper.requireNonNull(sources, "source is null");, + ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");, + return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, MaybeToPublisher.instance(), true, maxConcurrency, 1));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, + int n = a.length;, + if (n == 0) {, +++ b/src/main/java/io/reactivex/Maybe.java, + return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, MaybeToPublisher.instance(), false, maxConcurrency, 1));, + return mergeDelayError(sources, Integer.MAX_VALUE);, + ObjectHelper.requireNonNull(sources, "source is null");, + ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");, + return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources,
[+++ b/.gitignore, +++ b/.gitignore, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscriptions.empty()!!, +++ b/.gitignore, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscriptions.empty()!!, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscriptions.empty()!!, +++ b/.gitignore, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscriptions.empty()!!, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscriptions.empty()!!, +++ /dev/null, +++ b/.gitignore, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscriptions.empty()!!, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscriptions.empty()!!, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscriptions.empty()!!, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscriptions.empty()!!, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscriptions.empty()!!, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscriptions.empty()!!, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscriptions.empty()!!, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscriptions.empty()!!, +++ /dev/null, +++ /dev/null,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.*;, + return lift(new OperatorAll<T>(predicate));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.*;, + return lift(new OperatorAll<T>(predicate));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.*;, + return lift(new OperatorAll<T>(predicate));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorAll.java, +package rx.operators;, +, +import rx.Observable;, +import rx.Subscriber;, +import rx.exceptions.OnErrorThrowable;, +import rx.functions.Func1;, +, +import java.util.concurrent.atomic.AtomicBoolean;, +, +import static rx.Observable.Operator;, +, +/**, + * Returns an Observable that emits a Boolean that indicates whether all items emitted by an, + * Observable satisfy a condition., + * <p>, + * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/all.png">, + */, +public class OperatorAll<T> implements Operator<Boolean,T>{, +, + private final Func1<? super T, Boolean> predicate;, +, +
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Limits both the number of upstream items (after which the sequence completes), + * and the total downstream request amount requested from the upstream to, + * possibly prevent the creation of excess items by the upstream., + * <p>, + * The operator requests at most the given {@code count} of items from upstream even, + * if the downstream requests more than that. For example, given a {@code limit(5)},, + * if the downstream requests 1, a request of 1 is submitted to the upstream, + * and the operator remembers that only
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Collects items emitted by the finite source Publisher into a single mutable data structure and returns, + * <p>, + * Note that this operator requires the upstream to signal {@code onComplete} for the accumulator object to, + * be emitted. Sources that are infinite and never complete will never emit anything through this, + * operator and an infinite source may lead to a fatal {@code OutOfMemoryError}., + * Collects items emitted by the finite source Publisher into a single mutable data structure and returns, + * <p>, + * Note that this operator
[+++ b/README.md, +# RxJava: Functional Reactive Programming on the JVM, +++ b/README.md, +# RxJava: Functional Reactive Programming on the JVM, +++ b/language-adaptors/rxjava-kotlin/build.gradle, + classpath 'org.jetbrains.kotlin:kotlin-gradle-plugin:0.6.1673', + compile 'org.jetbrains.kotlin:kotlin-stdlib:0.6.1673', +++ b/README.md, +# RxJava: Functional Reactive Programming on the JVM, +++ b/language-adaptors/rxjava-kotlin/build.gradle, + classpath 'org.jetbrains.kotlin:kotlin-gradle-plugin:0.6.1673', + compile 'org.jetbrains.kotlin:kotlin-stdlib:0.6.1673', +++ b/language-adaptors/rxjava-kotlin/src/main/kotlin/rx/lang/kotlin/namespace.kt, +public fun<T> Function1<Observer<in T>, Unit>.asObservable(): Observable<T> {, + return Observable.create(OnSubscribe<T>{ t1 ->, + this(t1!!), +++ b/README.md, +# RxJava: Functional Reactive Programming on the JVM, +++ b/language-adaptors/rxjava-kotlin/build.gradle, + classpath 'org.jetbrains.kotlin:kotlin-gradle-plugin:0.6.1673', + compile 'org.jetbrains.kotlin:kotlin-stdlib:0.6.1673', +++ b/language-adaptors/rxjava-kotlin/src/main/kotlin/rx/lang/kotlin/namespace.kt, +public fun<T> Function1<Observer<in T>, Unit>.asObservable(): Observable<T> {, + return Observable.create(OnSubscribe<T>{ t1 ->, + this(t1!!), +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, +import
[+++ b/src/main/java/rx/internal/operators/OperatorMulticast.java, + private final AtomicReference<Subject<? super T, ? extends R>> connectedSubject;, + private final List<Subscriber<? super R>> waitingForConnect;, + Subscriber<T> subscription;, + boolean shouldSubscribe = false;, +, + // already connected, return as there is nothing to do, + shouldSubscribe = true;, + if (shouldSubscribe) {, + connection.call(Subscriptions.create(new Action0() {, + @Override, + public void call() {, + Subscription s;, + synchronized (guard) {, + s = subscription;, + subscription = null;, + connectedSubject.set(null);, + }, + if (s != null) {, + s.unsubscribe();, + }, + }, + }));, + boolean subscriptionIsNull;, + subscriptionIsNull = subscription ==
[+++ b/gradle.properties, +version=0.11.0]
[+++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java, + if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java, + if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java, + if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java, + if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java, + if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybe.java, + if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java, + if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java, + if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybe.java, + if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java, + if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java, + if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java, + if (getAndIncrement() == 0) {, +++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybe.java, +
[+++ b/.gitignore, +++ b/.gitignore, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/src/main/java/io/reactivex/Single.java, + ObjectHelper.requireNonNull(mapper, "mapper is null");, + return RxJavaPlugins.onAssembly(new SingleFlatMapPublisher<T, R>(this, mapper));, +++ b/src/main/java/io/reactivex/Single.java, + ObjectHelper.requireNonNull(mapper, "mapper is null");, + return RxJavaPlugins.onAssembly(new SingleFlatMapPublisher<T, R>(this, mapper));, +++ b/src/main/java/io/reactivex/internal/operators/single/SingleFlatMapPublisher.java, +/**, + * Copyright (c) 2016-present, RxJava Contributors., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + *
[+++ b/src/main/java/io/reactivex/Flowable.java, + * <pre><code>, + * </code></pre>, +++ b/src/main/java/io/reactivex/Flowable.java, + * <pre><code>, + * </code></pre>, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupBy.java, + @SuppressWarnings({ "unchecked", "rawtypes" }), + Consumer<Object> evictionAction = (Consumer) new EvictionAction<K, V>(evictedGroups);, + groups = (Map) mapFactory.apply(evictionAction);, +++ b/src/main/java/io/reactivex/Flowable.java, + * <pre><code>, + * </code></pre>, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupBy.java, + @SuppressWarnings({ "unchecked", "rawtypes" }), + Consumer<Object> evictionAction = (Consumer) new EvictionAction<K, V>(evictedGroups);, + groups = (Map) mapFactory.apply(evictionAction);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java]
[+++ b/.travis.yml, +# cache between builds, +cache:, + directories:, + - $HOME/.m2, +]
[+++ b/src/main/java/io/reactivex/ObservableEmitter.java, + * @return the serialized ObservableEmitter]
[+++ b/src/main/java/io/reactivex/internal/fuseable/ConditionalSubscriber.java, +/**, + * Copyright 2016 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the
[+++ b/gradle.properties, +version=0.17.4-SNAPSHOT]
[+++ b/gradle.properties, +version=0.16.2-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/CompletableEmitter.java, + * Returns true if the downstream disposed the sequence., + * @return true if the downstream disposed the sequence, + boolean isDisposed();, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, + * Returns true if the downstream disposed the sequence., + * @return true if the downstream disposed the sequence, + boolean isDisposed();, +++ b/src/main/java/io/reactivex/MaybeEmitter.java, + boolean isDisposed();, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, + * Returns true if the downstream disposed the sequence., + * @return true if the downstream disposed the sequence, + boolean isDisposed();, +++ b/src/main/java/io/reactivex/MaybeEmitter.java, + boolean isDisposed();, +++ b/src/main/java/io/reactivex/ObservableEmitter.java, + * Returns true if the downstream disposed the sequence., + *
[+++ b/.gitignore, +.gradletasknamecache, +++ b/.gitignore, +.gradletasknamecache, +++ b/rxjava-contrib/rxjava-android-samples-build-wrapper/build.gradle, +tasks.build.doLast {, + def androidHome = System.getenv("ANDROID_HOME"), + if (project.hasProperty('buildAndroidSamples') && !androidHome.isEmpty()) {, + println("Android SDK detected at $androidHome, running samples build"), + project.exec {, + workingDir '../rxjava-android-samples', +, + commandLine "./gradlew", "clean", "packageDebug", + }, + }, +}, +++ b/.gitignore, +.gradletasknamecache, +++ b/rxjava-contrib/rxjava-android-samples-build-wrapper/build.gradle, +tasks.build.doLast {, + def androidHome = System.getenv("ANDROID_HOME"), + if (project.hasProperty('buildAndroidSamples') && !androidHome.isEmpty()) {, + println("Android SDK detected at $androidHome, running samples build"), + project.exec {, + workingDir '../rxjava-android-samples', +, + commandLine "./gradlew", "clean", "packageDebug", + }, + }, +}, +++ b/rxjava-contrib/rxjava-android-samples/.gitignore, +.gradle, +/local.properties, +/.idea/workspace.xml, +.DS_Store, +++ b/.gitignore,
[+++ b/src/main/java/io/reactivex/Observable.java, + * asynchronously with an unbounded buffer with {@link Flowable#bufferSize()} "island size"., + * <p>"Island size" indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumed, + * on the other side of the asynchronous boundary., + * asynchronously with an unbounded buffer with {@link Flowable#bufferSize()} "island size" and optionally delays onError notifications., + * <p>"Island size" indicates how large chunks the unbounded buffer allocates to store the excess elements waiting to be consumed, + * on the other side of the asynchronous boundary., + * asynchronously with an unbounded
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC3-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC3-SNAPSHOT, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java, + *, + * @param <T1>, + * @param <T2>, + * @param <T3>, + * @param <T4>, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC3-SNAPSHOT, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java, + *, + * @param <T1>, + * @param <T2>, + * @param <T3>, + * @param <T4>, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyFunctionWrapper.java, + *, + * @param <T1>, + * @param <T2>, + * @param <T3>, + * @param <T4>, + * @param <T5>, + * @param <T6>, + * @param <T7>, + * @param <T8>, + * @param <T9>, + *
[+++ b/src/main/java/io/reactivex/Observable.java, +import io.reactivex.observables.*;, + , + public final <K> Observable<GroupedObservable<T, K>> groupBy(Function<? super T, ? extends K> keySelector) {, + return groupBy(keySelector, v -> v, false, bufferSize());, + }, +, + public final <K> Observable<GroupedObservable<T, K>> groupBy(Function<? super T, ? extends K> keySelector, boolean delayError) {, + return groupBy(keySelector, v -> v, delayError, bufferSize());, + }, +, + public final <K, V> Observable<GroupedObservable<V, K>> groupBy(Function<? super T, ? extends K> keySelector, , + Function<? super T, ? extends V> valueSelector) {, + return groupBy(keySelector, valueSelector, false, bufferSize());, + }, +, + public final <K, V> Observable<GroupedObservable<V, K>> groupBy(Function<?
[+++ b/src/main/java/io/reactivex/Flowable.java, + return new FlowableAmb<T>(null, sources);, + return new FlowableAmb<T>(sources, null);, + return new FlowableCombineLatest<T, R>(null, sources, combiner, s, delayError);, + return new FlowableCombineLatest<T, R>(sources, null, combiner, s, delayError);, + if (onSubscribe instanceof Flowable) {, + throw new IllegalArgumentException("create(Flowable) should be upgraded");, + }, + return new FlowableDefer<T>(supplier);, + return FlowableEmpty.empty();, + return new FlowableError<T>(errorSupplier);, + return new FlowableFromArray<T>(values);, + return new FlowableFromCallable<T>(supplier);, + Flowable<T> o = new FlowableFromFuture<T>(future, 0L, null);, + Flowable<T> o = new FlowableFromFuture<T>(future, timeout, unit);, + return new FlowableFromIterable<T>(source);, + return new FlowableGenerate<T, S>(initialState, generator, disposeState);, + return new FlowableInterval(initialDelay, period, unit, scheduler);, +
[+++ b/src/main/java/io/reactivex/internal/observers/BlockingObserver.java, +++ b/src/main/java/io/reactivex/internal/observers/BlockingObserver.java, +++ b/src/main/java/io/reactivex/internal/observers/CallbackCompletableObserver.java, + return;, + lazySet(DisposableHelper.DISPOSED);, + lazySet(DisposableHelper.DISPOSED);, +++ b/src/main/java/io/reactivex/internal/observers/BlockingObserver.java, +++ b/src/main/java/io/reactivex/internal/observers/CallbackCompletableObserver.java, + return;, + lazySet(DisposableHelper.DISPOSED);, + lazySet(DisposableHelper.DISPOSED);, +++ /dev/null, +++ b/src/main/java/io/reactivex/internal/observers/BlockingObserver.java, +++ b/src/main/java/io/reactivex/internal/observers/CallbackCompletableObserver.java, + return;, + lazySet(DisposableHelper.DISPOSED);, + lazySet(DisposableHelper.DISPOSED);, +++ /dev/null, +++ b/src/main/java/io/reactivex/internal/queue/BaseLinkedQueue.java, +++ b/src/main/java/io/reactivex/internal/observers/BlockingObserver.java, +++ b/src/main/java/io/reactivex/internal/observers/CallbackCompletableObserver.java, + return;, + lazySet(DisposableHelper.DISPOSED);, + lazySet(DisposableHelper.DISPOSED);, +++ /dev/null, +++ b/src/main/java/io/reactivex/internal/queue/BaseLinkedQueue.java, +++ b/src/main/java/io/reactivex/internal/queue/MpscLinkedQueue.java, + public boolean offer(final T e) {, + if (null == e) {, + throw new NullPointerException("Null is not a valid element");, + }, + final LinkedQueueNode<T> nextNode = new LinkedQueueNode<T>(e);, +++ b/src/main/java/io/reactivex/internal/observers/BlockingObserver.java, +++ b/src/main/java/io/reactivex/internal/observers/CallbackCompletableObserver.java, + return;, + lazySet(DisposableHelper.DISPOSED);, + lazySet(DisposableHelper.DISPOSED);, +++ /dev/null, +++ b/src/main/java/io/reactivex/internal/queue/BaseLinkedQueue.java,
[+++ b/src/main/java/io/reactivex/internal/observers/InnerQueuedObserver.java, +++ b/src/main/java/io/reactivex/internal/observers/InnerQueuedObserver.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableInternalHelper.java, +++ b/src/main/java/io/reactivex/internal/observers/InnerQueuedObserver.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableInternalHelper.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqual.java, +++ b/src/main/java/io/reactivex/internal/observers/InnerQueuedObserver.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableInternalHelper.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqual.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java, +++ b/src/main/java/io/reactivex/internal/observers/InnerQueuedObserver.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableInternalHelper.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqual.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java, +++ b/src/main/java/io/reactivex/internal/schedulers/ScheduledRunnable.java, +++ b/src/main/java/io/reactivex/internal/observers/InnerQueuedObserver.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableInternalHelper.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSequenceEqual.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java, +++ b/src/main/java/io/reactivex/internal/schedulers/ScheduledRunnable.java, +++ b/src/main/java/io/reactivex/internal/subscribers/SubscriberResourceWrapper.java]
[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, + @Test def ambExample(): Unit = {, + val o1 = List(100L, 200L, 300L).toObservable.delay(4 seconds), + val o2 = List(1000L, 2000L, 3000L).toObservable.delay(2 seconds), + val result = o1.amb(o2).toBlockingObservable.toList, + println(result), + }, +, + @Test def delayExample(): Unit = {, + val o = List(100L, 200L, 300L).toObservable.delay(2 seconds), + val result = o.toBlockingObservable.toList, + println(result), + }, +, + @Test def delayExample2(): Unit = {, + val o = List(100L, 200L, 300L).toObservable.delay(2 seconds, IOScheduler()), + val result = o.toBlockingObservable.toList, + println(result), + }, +, + @Test def delaySubscriptionExample(): Unit = {, + val o = List(100L, 200L,
[+++ b/src/main/java/io/reactivex/Observable.java, +import io.reactivex.subscribers.*;, + public final <U> Observable<T> skipUntil(Publisher<? extends U> other) {, + public final Observable<Timed<T>> timestamp() {, + public final Observable<Timed<T>> timestamp(Scheduler scheduler) {, + public final Observable<Timed<T>> timestamp(TimeUnit unit) {, + public final Observable<Timed<T>> timestamp(TimeUnit unit, Scheduler scheduler) {, + return map(v -> new Timed<>(v, scheduler.now(unit), unit));, + , + public final Observable<T> distinct() {, + return distinct(HashSet::new);, + }, + , + public final Observable<T> distinct(Supplier<? extends Collection<? super T>> collectionSupplier) {, + return lift(OperatorDistinct.withCollection(collectionSupplier));, + }, + , + public final Observable<T> distinctUntilChanged() {, + return lift(OperatorDistinct.untilChanged());, + }, + , + @Deprecated,
[+++ b/src/main/java/io/reactivex/Completable.java, + * Publisher., + * and expects the other {@code Publisher} to honor it as well.</dd>, + * @param next the Publisher to subscribe after this Completable is completed, not null, + * <strong>Advanced use without safeguards:</strong> lifts a CompletableOperator, + * that error through a Flowable and the Publisher should return a value indicating a retry in response, + * @param handler the handler that receives a Flowable delivering Throwables and should return a Publisher that, + * Returns a Flowable which first delivers the events, + * of the other Publisher then runs this Completable.,
[+++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java, + * Removes all handlers and resets to default behavior.]
[+++ b/rxjava-contrib/rxjava-android-samples/gradle/wrapper/gradle-wrapper.properties, +#Wed Mar 12 11:02:06 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip]
[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subscriber.scala, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subscriber.scala, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subscriber.scala, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/ObservableTest.scala, + /*, + val observer = mock(classOf[Observer[Int]]), + val o = Observable().head, + val sub = o.subscribe(observer), + verify(observer, never).onNext(any(classOf[Int])), + verify(observer, never).onCompleted(), + verify(observer, times(1)).onError(any(classOf[NoSuchElementException])), + */, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subscriber.scala, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/ObservableTest.scala, + /*, + val observer = mock(classOf[Observer[Int]]), + val o = Observable().head, + val sub = o.subscribe(observer),
[+++ b/gradle.properties, +version=0.6.3]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Returns a {@code Flowable} that emits the items from this {@code Flowable} followed by the success item or error event, + * of the other {@link SingleSource}., + * <p>, + * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concat.png" alt="">, + * <dl>, + * <dt><b>Backpressure:</b></dt>, + * <dd>The operator supports backpressure and makes sure the success item of the other {@code SingleSource}, + * is only emitted when there is a demand for it.</dd>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code concatWith} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + * @param
[+++ b/src/main/java/io/reactivex/observers/TestObserver.java, + * <p>The TestObserver implements Disposable for convenience where dispose calls cancel., + * Returns true if this TestObserver has been cancelled., + * @return true if this TestObserver has been cancelled, + * Returns the last thread which called the onXXX methods of this TestObserver., + * Returns true if TestObserver received any onError or onComplete events., + * @return true if TestObserver received any onError or onComplete events, + * Returns true if this TestObserver received a subscription., + * @return true if this TestObserver received a subscription, + * Awaits until this TestObserver receives
[+++ b/src/main/java/io/reactivex/Observable.java, + , + public final Observable<T> onBackpressureDrop() {, + return lift(OperatorOnBackpressureDrop.instance());, + }, + , + public final Observable<T> onBackpressureDrop(Consumer<? super T> onDrop) {, + return lift(new OperatorOnBackpressureDrop<>(onDrop));, + }, + , + public final Observable<T> onBackpressureBuffer() {, + return onBackpressureBuffer(bufferSize(), false, true);, + }, + , + public final Observable<T> onBackpressureBuffer(int bufferSize) {, + return onBackpressureBuffer(bufferSize, false, false);, + }, + , + public final Observable<T> onBackpressureBuffer(boolean delayError) {, + return onBackpressureBuffer(bufferSize(), true, true);, + }, + , + public final Observable<T> onBackpressureBuffer(int bufferSize, boolean delayError) {, + return onBackpressureBuffer(bufferSize, true, false);, + }, + ,
[+++ b/src/main/java/io/reactivex/Completable.java, + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>, +++ b/src/main/java/io/reactivex/Completable.java, + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>, +++ b/src/main/java/io/reactivex/Flowable.java, + * Note: named this way because of overload conflict with concat(Publisher&lt;Publisher&gt;)., + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>, + * <dt><b>Backpressure:</b></dt>,
[+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableDelay.java, + }, delayError ? delay : 0, unit));, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableDelay.java, + }, delayError ? delay : 0, unit));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDelay.java, + }, delayError ? delay : 0, unit);, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableDelay.java, + }, delayError ? delay : 0, unit));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDelay.java, + }, delayError ? delay : 0, unit);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDelay.java, + }, delayError ? delay : 0, unit);, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableDelay.java, + }, delayError ? delay : 0, unit));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDelay.java, + }, delayError ? delay : 0, unit);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDelay.java, + }, delayError ? delay : 0, unit);, +++ b/src/main/java/io/reactivex/internal/operators/single/SingleDelay.java, + public void onError(final Throwable e) {,
[+++ b/src/main/java/io/reactivex/Flowable.java, +, + /**, + * Maps the upstream values into {@link CompletableSource}s, subscribes to the newer one while, + * disposing the subscription to the previous {@code CompletableSource}, thus keeping at most one, + * active {@code CompletableSource} running., + * <p>, + * <img width="640" height="521" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapCompletable.f.png" alt="">, + * <p>, + * Since a {@code CompletableSource} doesn't produce any items, the resulting reactive type of, + * this operator is a {@link Completable} that can only indicate successful completion or, + * a failure in any of the inner {@code CompletableSource}s or the failure of
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationSwitch;, +import rx.operators.OperatorTakeTimed;, + return create(OperationSwitch.switchDo(sequenceOfSequences));, + return lift(new OperatorTakeTimed<T>(time, unit, scheduler));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationSwitch;, +import rx.operators.OperatorTakeTimed;, + return create(OperationSwitch.switchDo(sequenceOfSequences));, + return lift(new OperatorTakeTimed<T>(time, unit, scheduler));, +++ b/rxjava-core/src/main/java/rx/operators/OperationSwitch.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorScan;, + return lift(new OperatorScan<T, T>(accumulator));, + return lift(new OperatorScan<R, T>(initialValue, accumulator));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorScan;, + return lift(new OperatorScan<T, T>(accumulator));, + return lift(new OperatorScan<R, T>(initialValue, accumulator));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorScan;, + return lift(new OperatorScan<T, T>(accumulator));, + return lift(new OperatorScan<R, T>(initialValue, accumulator));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorScan.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *
[+++ b/src/main/java/io/reactivex/Flowable.java, + static final Flowable<Object> NEVER = new Flowable<Object>() { // FIXME factor out, + public void subscribeActual(Subscriber<? super Object> s) {, + };, + /**, + * Hides the identity of this Flowable and its Subscription., + * <p>Allows hiding extra features such as {@link Processor}'s, + * {@link Subscriber} methods or preventing certain identity-based , + * optimizations (fusion)., + * @return the new Flowable instance, + * , + * @since 2.0, + */, + @BackpressureSupport(BackpressureKind.PASS_THROUGH), + @SchedulerSupport(SchedulerSupport.NONE), + public final Flowable<T> hide() {, + return new FlowableHide<T>(this);, + }, +, + , +++ b/src/main/java/io/reactivex/Flowable.java,
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null]
[+++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java, + throw fail("expected: " + valueAndClass(value) + " but was: " + values);, + throw fail("expected: " + valueAndClass(value) + " but was: " + valueAndClass(v));, + throw fail("expected: " + valueAndClass(value) + " but was: " + valueAndClass(v));, + throw fail("Value counts differ; expected: " + count + " but was: " + s);, + throw fail("Value count differs; expected: " + values.length + " " + Arrays.toString(values), + + " but was: " + s + " " + this.values);, + throw fail("Values at position " + i + " differ; expected: " + valueAndClass(u)
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.2-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.2-SNAPSHOT, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.2-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.2-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.2-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/README.md, +## Documentation, +, +You can build the documentation as follows: In the RxJava root directory, run, +, + ./gradlew :language-adaptors:rxjava-scala:scaladoc, +, +Then navigate to, +, + RxJava/language-adaptors/rxjava-scala/build/docs/scaladoc/index.html, +, +, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.2-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/README.md, +## Documentation, +, +You can build the documentation as follows:
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorSequenceEqual;, + return OperatorSequenceEqual.sequenceEqual(first, second, equality);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorSequenceEqual;, + return OperatorSequenceEqual.sequenceEqual(first, second, equality);, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorSequenceEqual;, + return OperatorSequenceEqual.sequenceEqual(first, second, equality);, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorSequenceEqual.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in
[+++ b/src/main/java/io/reactivex/Single.java, + * @throws NullPointerException, + * if unit is null, or, + * if scheduler is null, + * @throws NullPointerException, + * if unit is null, or, + * if scheduler is null, + * @throws NullPointerException if scheduler is null, + * @throws NullPointerException, + * if other is null, or, + * if unit is null, or, + * if scheduler is null]
[+++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:4.0.0' }, +apply plugin: 'nebula.rxjava-project', +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:4.0.0' }, +apply plugin: 'nebula.rxjava-project', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:4.0.0' }, +apply plugin: 'nebula.rxjava-project', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 10 13:01:27 PST 2016, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.11-bin.zip, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:4.0.0' }, +apply plugin: 'nebula.rxjava-project', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 10 13:01:27 PST 2016, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.11-bin.zip, +++ b/gradlew, +cd "`dirname \"$PRG\"`/" >/dev/null, +cd "$SAVED" >/dev/null, + JAVACMD=`cygpath --unix "$JAVACMD"`, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:4.0.0' }, +apply plugin: 'nebula.rxjava-project', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 10
[+++ b/src/main/java/rx/Observable.java, +++ b/src/main/java/rx/Observable.java, +++ /dev/null, +++ b/src/main/java/rx/Observable.java, +++ /dev/null, +++ b/src/main/java/rx/internal/util/ScalarSynchronousObservable.java, +import rx.Observable;, +import rx.Subscriber;, +++ b/src/main/java/rx/Observable.java, +++ /dev/null, +++ b/src/main/java/rx/internal/util/ScalarSynchronousObservable.java, +import rx.Observable;, +import rx.Subscriber;, +++ b/src/main/java/rx/observables/AbstractOnSubscribe.java, + * Note: these examples use the lambda-helper factories to avoid boilerplate., +++ b/src/main/java/rx/Observable.java, +++ /dev/null, +++ b/src/main/java/rx/internal/util/ScalarSynchronousObservable.java, +import rx.Observable;, +import rx.Subscriber;, +++ b/src/main/java/rx/observables/AbstractOnSubscribe.java, + * Note: these examples use the lambda-helper factories to avoid boilerplate., +++ b/src/main/java/rx/schedulers/EventLoopsScheduler.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with
[+++ b/src/test/java/io/reactivex/plugins/RxJavaPluginsTest.java, +import static org.junit.Assert.*;, +, +import java.io.IOException;, +import java.lang.Thread.UncaughtExceptionHandler;, +import java.lang.reflect.*;, +import java.util.*;, +import java.util.concurrent.*;, +import java.util.concurrent.atomic.*;, +, +import org.junit.*;, +import org.reactivestreams.*;, +, +import io.reactivex.Observable;, +import io.reactivex.Observer;, +import io.reactivex.disposables.*;, +import io.reactivex.functions.*;, + * @throws Exception on error, + @SuppressWarnings("rawtypes"), +++ b/src/test/java/io/reactivex/plugins/RxJavaPluginsTest.java, +import static org.junit.Assert.*;, +, +import java.io.IOException;, +import java.lang.Thread.UncaughtExceptionHandler;, +import java.lang.reflect.*;, +import java.util.*;, +import java.util.concurrent.*;, +import java.util.concurrent.atomic.*;, +, +import org.junit.*;, +import org.reactivestreams.*;, +, +import io.reactivex.Observable;, +import io.reactivex.Observer;, +import io.reactivex.disposables.*;, +import io.reactivex.functions.*;, + * @throws Exception on error, + @SuppressWarnings("rawtypes"), +++ b/src/test/java/io/reactivex/schedulers/NewThreadSchedulerTest.java, + * @throws Exception on error]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/gradle.properties, +version=0.17.3-SNAPSHOT]
[+++ /dev/null, +++ /dev/null, +++ b/rxjava-contrib/rxjava-async-util/src/test/java/rx/util/async/operators/OperationDeferFutureTest.java, + Observable<Integer> result = Async.deferFuture(func, Schedulers.computation());, +++ /dev/null, +++ b/rxjava-contrib/rxjava-async-util/src/test/java/rx/util/async/operators/OperationDeferFutureTest.java, + Observable<Integer> result = Async.deferFuture(func, Schedulers.computation());, +++ b/rxjava-contrib/rxjava-async-util/src/test/java/rx/util/async/operators/OperationForEachFutureTest.java, + .subscribeOn(Schedulers.computation());, + .subscribeOn(Schedulers.computation());, + .subscribeOn(Schedulers.computation());, + .subscribeOn(Schedulers.computation());, +++ /dev/null, +++ b/rxjava-contrib/rxjava-async-util/src/test/java/rx/util/async/operators/OperationDeferFutureTest.java, + Observable<Integer> result = Async.deferFuture(func, Schedulers.computation());, +++ b/rxjava-contrib/rxjava-async-util/src/test/java/rx/util/async/operators/OperationForEachFutureTest.java, + .subscribeOn(Schedulers.computation());, + .subscribeOn(Schedulers.computation());, + .subscribeOn(Schedulers.computation());, + .subscribeOn(Schedulers.computation());, +++ b/rxjava-contrib/rxjava-async-util/src/test/java/rx/util/async/operators/OperationStartFutureTest.java, + Observable<Integer> result = Async.startFuture(func, Schedulers.computation());, +++ /dev/null, +++ b/rxjava-contrib/rxjava-async-util/src/test/java/rx/util/async/operators/OperationDeferFutureTest.java, + Observable<Integer> result = Async.deferFuture(func, Schedulers.computation());, +++ b/rxjava-contrib/rxjava-async-util/src/test/java/rx/util/async/operators/OperationForEachFutureTest.java, + .subscribeOn(Schedulers.computation());, + .subscribeOn(Schedulers.computation());, + .subscribeOn(Schedulers.computation());, + .subscribeOn(Schedulers.computation());, +++ b/rxjava-contrib/rxjava-async-util/src/test/java/rx/util/async/operators/OperationStartFutureTest.java, + Observable<Integer> result = Async.startFuture(func, Schedulers.computation());, +++ b/rxjava-contrib/rxjava-computation-expressions/src/test/java/rx/operators/OperationConditionalsTest.java, + Observable<Integer> source1 = Observable.from(1, 2, 3).subscribeOn(Schedulers.trampoline());, +++ /dev/null,
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java, + return combiner.apply(new Object[] { t });, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java, + return combiner.apply(new Object[] { t });, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java, + return combiner.apply(new Object[] { t });, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java, + return combiner.apply(new Object[] { t });, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableObserveOn.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java, + return combiner.apply(new Object[] { t });, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableObserveOn.java, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeZipArray.java, + return zipper.apply(new Object[] { t });, + v = ObjectHelper.requireNonNull(zipper.apply(values), "The zipper returned a null value");, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java, +
[+++ b/src/main/java/io/reactivex/Flowable.java, + * specified delay. If {@code delayError} is true, error notifications will also be delayed., + * specified delay. If {@code delayError} is true, error notifications will also be delayed., +++ b/src/main/java/io/reactivex/Flowable.java, + * specified delay. If {@code delayError} is true, error notifications will also be delayed., + * specified delay. If {@code delayError} is true, error notifications will also be delayed., +++ b/src/main/java/io/reactivex/Observable.java, + * specified delay. If {@code delayError} is true, error notifications will also be delayed., + * specified delay. If {@code delayError} is true, error notifications will also be delayed.]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java, + boolean callError = false;, + callError = true;, + } else if(callError) {, + } else {, + drain();, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java, + boolean callError = false;, + callError = true;, + } else if(callError) {, + } else {, + drain();, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategyTest.java, +import org.junit.Test;, +import java.util.concurrent.atomic.AtomicInteger;, +, +import static io.reactivex.BackpressureOverflowStrategy.DROP_LATEST;, +import static io.reactivex.BackpressureOverflowStrategy.DROP_OLDEST;, +import static io.reactivex.internal.functions.Functions.EMPTY_ACTION;, +import static org.junit.Assert.assertEquals;, +, + public void backpressureWithBufferDropOldest() throws InterruptedException {, + int bufferSize = 3;, + TestSubscriber<Long> ts = createTestSubscriber();, + Flowable.fromPublisher(send500ValuesAndComplete.onBackpressureBuffer(bufferSize, incrementOnDrop, DROP_OLDEST)), + .subscribe(ts);, + // we request 10 but only 3 should come from the
[+++ b/CHANGES.md, +### Version 0.9.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.9.1%22)) ###, +, +* [Pull 303](https://github.com/Netflix/RxJava/pull/303) CombineLatest, +* [Pull 290](https://github.com/Netflix/RxJava/pull/290) Zip overload with FuncN, +* [Pull 302](https://github.com/Netflix/RxJava/pull/302) NPE fix when no package on class, +* [Pull 284](https://github.com/Netflix/RxJava/pull/284) GroupBy fixes (items still [oustanding](https://github.com/Netflix/RxJava/issues/282)), +* [Pull 288](https://github.com/Netflix/RxJava/pull/288) PublishSubject concurrent modification fixes, +* [Issue 198](https://github.com/Netflix/RxJava/issues/198) Throw if no onError handler specified, +* [Issue 278](https://github.com/Netflix/RxJava/issues/278) Subscribe argument validation, +* Javadoc improvements and many new marble diagrams, +, +++ b/CHANGES.md, +### Version 0.9.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.9.1%22)) ###, +, +* [Pull 303](https://github.com/Netflix/RxJava/pull/303) CombineLatest, +* [Pull 290](https://github.com/Netflix/RxJava/pull/290) Zip overload with FuncN, +* [Pull 302](https://github.com/Netflix/RxJava/pull/302) NPE fix when no package on class,
[+++ b/gradle.properties, +version=0.7.0-SNAPSHOT]
[+++ b/gradle.properties, +version=0.19.0-SNAPSHOT]
[+++ b/.gitignore, +.gradletasknamecache, +++ b/.gitignore, +.gradletasknamecache, +++ b/CHANGES.md, +++ b/.gitignore, +.gradletasknamecache, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.17.0-RC7-SNAPSHOT, +++ b/.gitignore, +.gradletasknamecache, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.17.0-RC7-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, + val fourYears = 4000.millis, + val neverUsedDummyMedal = Medal(3333, "?", "?", "?", "?", "?"), + def fourYearsEmpty: Observable[Medal] = {, + // Observable.interval(fourYears).take(1).map(i => neverUsedDummyMedal).filter(m => false), + Observable.empty, + }, +++ b/.gitignore, +.gradletasknamecache, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.17.0-RC7-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, + val fourYears = 4000.millis, + val neverUsedDummyMedal = Medal(3333, "?", "?", "?", "?", "?"), + def fourYearsEmpty: Observable[Medal] = {, + // Observable.interval(fourYears).take(1).map(i => neverUsedDummyMedal).filter(m => false), + Observable.empty, +
[+++ b/CHANGES.md, +### Version 0.12.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.12.2%22)) ###, +, +* [Pull 352](https://github.com/Netflix/RxJava/pull/352) Groovy Language Adaptor: Add Func5-9 and N to the wrapper, +, +### Version 0.12.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.12.1%22)) ###, +, +* [Pull 350](https://github.com/Netflix/RxJava/pull/350) Swing module enhancements, +* [Pull 351](https://github.com/Netflix/RxJava/pull/351) Fix Observable.window static/instance bug, +, +++ b/CHANGES.md, +### Version 0.12.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.12.2%22)) ###, +, +* [Pull 352](https://github.com/Netflix/RxJava/pull/352) Groovy Language Adaptor: Add Func5-9 and N to the wrapper, +, +### Version 0.12.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.12.1%22)) ###, +, +* [Pull 350](https://github.com/Netflix/RxJava/pull/350) Swing module enhancements, +* [Pull 351](https://github.com/Netflix/RxJava/pull/351) Fix Observable.window static/instance bug, +, +++ b/gradle.properties, +version=0.12.3-SNAPSHOT, +++ b/CHANGES.md, +### Version 0.12.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.12.2%22)) ###,
[+++ b/src/main/java/io/reactivex/Maybe.java, + return RxJavaPlugins.onAssembly(new MaybeFlatMapIterableFlowable<T, U>(this, mapper));, + return RxJavaPlugins.onAssembly(new MaybeFlatMapIterableObservable<T, U>(this, mapper));, +++ b/src/main/java/io/reactivex/Maybe.java, + return RxJavaPlugins.onAssembly(new MaybeFlatMapIterableFlowable<T, U>(this, mapper));, + return RxJavaPlugins.onAssembly(new MaybeFlatMapIterableObservable<T, U>(this, mapper));, +++ b/src/main/java/io/reactivex/Observable.java, + return RxJavaPlugins.onAssembly(new ObservableDistinct<T, K>(this, keySelector, collectionSupplier));, + return RxJavaPlugins.onAssembly(new ObservablePublishSelector<T, R>(this, selector));, +++ b/src/main/java/io/reactivex/Maybe.java, + return RxJavaPlugins.onAssembly(new MaybeFlatMapIterableFlowable<T, U>(this, mapper));, + return RxJavaPlugins.onAssembly(new MaybeFlatMapIterableObservable<T, U>(this, mapper));, +++ b/src/main/java/io/reactivex/Observable.java, + return RxJavaPlugins.onAssembly(new ObservableDistinct<T, K>(this, keySelector, collectionSupplier));, + return RxJavaPlugins.onAssembly(new ObservablePublishSelector<T, R>(this, selector));, +++ b/src/main/java/io/reactivex/Single.java, + return RxJavaPlugins.onAssembly(new SingleFlatMapIterableFlowable<T, U>(this, mapper));, + return RxJavaPlugins.onAssembly(new SingleFlatMapIterableObservable<T, U>(this, mapper));]
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.8.1-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.8.1-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationGroupBy;, +import rx.operators.OperationTimestamp;, +import rx.util.Timestamped;, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + @Override, + * @param subject the subject to push source elements into., + * @param <R> result type, + * @param source the source sequence whose elements will be pushed
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationMergeMaxConcurrent;, + return Observable.create(OperationMergeMaxConcurrent.merge(source, maxConcurrent));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationMergeMaxConcurrent;, + return Observable.create(OperationMergeMaxConcurrent.merge(source, maxConcurrent));, +++ b/rxjava-core/src/main/java/rx/operators/OperationMergeMaxConcurrent.java, +/**, + * Copyright 2013 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,,
[+++ b/gradle.properties, +version=0.14.4]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySelector.java, + final AtomicBoolean stopWindows = new AtomicBoolean();, +, + if (stopWindows.get()) {, + if (stopWindows.compareAndSet(false, true)) {, + DisposableHelper.dispose(boundary);, + if (windows.decrementAndGet() == 0) {, + upstream.cancel();, + }, + }, + if (stopWindows.get()) {, + cancel();, + cancel();, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundarySelector.java, + final AtomicBoolean stopWindows = new AtomicBoolean();, +, + if (stopWindows.get()) {, + if (stopWindows.compareAndSet(false, true)) {, + DisposableHelper.dispose(boundary);, + if (windows.decrementAndGet() == 0) {, + upstream.cancel();, + }, + }, + if (stopWindows.get()) {, + cancel();, + cancel();, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundarySelector.java, + final AtomicBoolean stopWindows = new AtomicBoolean();, +, + if (stopWindows.get()) {, + if (stopWindows.compareAndSet(false,
[+++ b/src/main/java/io/reactivex/observers/TestObserver.java, + errors.add(new NullPointerException("onNext received a null value"));, +++ b/src/main/java/io/reactivex/observers/TestObserver.java, + errors.add(new NullPointerException("onNext received a null value"));, +++ b/src/main/java/io/reactivex/subscribers/TestSubscriber.java, + errors.add(new NullPointerException("onNext received a null value"));, + errors.add(new IllegalStateException("onError received a null Throwable"));]
[+++ b/gradle.properties, +version=0.17.0-RC8-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Calls the appropriate onXXX method (shared between all Subscribers) for the lifecycle events of, +++ b/src/main/java/io/reactivex/Flowable.java, + * Calls the appropriate onXXX method (shared between all Subscribers) for the lifecycle events of, +++ b/src/main/java/io/reactivex/Observable.java, + Objects.requireNonNull(initialValueSupplier, "initialValueSupplier is null");, + * Calls the appropriate onXXX method (shared between all Subscribers) for the lifecycle events of, + * the number of elements to prefetch from the inner ObservableSources., + * @return a Observable that emits items from the source ObservableSource of type {@code clazz}]
[+++ b/gradle.properties, +version=0.14.2]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java, + node = getHead();, + Node n = getHead();, +, + Node getHead() {, + return get();, + }, +, + @Override, + Node getHead() {, + long timeLimit = scheduler.now(unit) - maxAge;, + Node prev = get();, + Node next = prev.get();, + for (;;) {, + if (next == null) {, + break;, + }, + Timed<?> v = (Timed<?>)next.value;, + if (NotificationLite.isComplete(v.value()) || NotificationLite.isError(v.value())) {, + break;, + }, + if (v.time() <= timeLimit) {, + prev = next;, + next = next.get();, + } else {, + break;, + }, + }, +
[+++ b/src/main/java/io/reactivex/Completable.java, + public final Completable retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<Object>> handler) {, +++ b/src/main/java/io/reactivex/Completable.java, + public final Completable retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<Object>> handler) {, +++ b/src/main/java/io/reactivex/Flowable.java, + final Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) {, +++ b/src/main/java/io/reactivex/Completable.java, + public final Completable retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<Object>> handler) {, +++ b/src/main/java/io/reactivex/Flowable.java, + final Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) {, +++ b/src/main/java/io/reactivex/Maybe.java, + final Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) {, +++ b/src/main/java/io/reactivex/Completable.java, + public final Completable retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<Object>> handler) {, +++ b/src/main/java/io/reactivex/Flowable.java, + final Function<? super Flowable<Throwable>,
[+++ b/src/main/java/io/reactivex/internal/observers/QueueDrainObserver.java, + * @param disposable the resource to dispose if the drain terminates, +++ b/src/main/java/io/reactivex/internal/observers/QueueDrainObserver.java, + * @param disposable the resource to dispose if the drain terminates, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeFlatMapCompletable.java, + * @param <T> the value type of the source MaybeSource, +++ b/src/main/java/io/reactivex/internal/observers/QueueDrainObserver.java, + * @param disposable the resource to dispose if the drain terminates, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeFlatMapCompletable.java, + * @param <T> the value type of the source MaybeSource, +++ b/src/main/java/io/reactivex/internal/operators/single/SingleFlatMapCompletable.java, + * @param <T> the value type of the source SingleSource, +++ b/src/main/java/io/reactivex/internal/observers/QueueDrainObserver.java, + * @param disposable the resource to dispose if the drain terminates, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeFlatMapCompletable.java, + *
[+++ b/src/main/java/io/reactivex/internal/operators/PublisherAutoConnect.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the
[+++ b/src/main/java/io/reactivex/Observable.java, + Objects.requireNonNull(o);, + public final <T2> Observable<T2> dematerialize() {, + Observable<Try<Optional<T2>>> m = (Observable<Try<Optional<T2>>>)this;, + Objects.requireNonNull(v1, "The first value is null");, + Objects.requireNonNull(v2, "The second value is null");, + Objects.requireNonNull(v1, "The first value is null");, + Objects.requireNonNull(v2, "The second value is null");, + Objects.requireNonNull(v3, "The third value is null");, + Objects.requireNonNull(v1, "The first value is null");, + Objects.requireNonNull(v2, "The second value is null");, + Objects.requireNonNull(v3, "The third value is null");, + Objects.requireNonNull(v4, "The fourth value is null");, + Objects.requireNonNull(v1, "The first value is null");, + Objects.requireNonNull(v2, "The second value is null");, + Objects.requireNonNull(v3, "The third value is
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatArray.java, + super(false);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatArray.java, + super(false);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java, + super(false);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatArray.java, + super(false);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java, + super(false);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDelaySubscriptionOther.java, +import java.util.concurrent.atomic.*;, +, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + MainSubscriber<T> parent = new MainSubscriber<T>(child, main);, + child.onSubscribe(parent);, + other.subscribe(parent.other);, + static final class MainSubscriber<T> extends AtomicLong implements FlowableSubscriber<T>, Subscription {, + private static final long serialVersionUID = 2259811067697317255L;, +, + final Subscriber<? super T> downstream;, +, + final Publisher<? extends T> main;, +, + final OtherSubscriber other;, +, + final AtomicReference<Subscription> upstream;, +, + MainSubscriber(Subscriber<? super T> downstream, Publisher<? extends T> main) {, + this.downstream = downstream;, + this.main =
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.11-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.11-SNAPSHOT, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.11-SNAPSHOT, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/language-adaptors/rxjava-scala/README.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.11-SNAPSHOT, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/language-adaptors/rxjava-scala/README.md, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.11-SNAPSHOT, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/language-adaptors/rxjava-scala/README.md, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/TODO.md, +* Bring `BooleanSubscription`, `CompositeSubscription`, `MultipleAssignmentSubscription` to Scala, `compositeSubscription.subscription = ...`instead of setter method, add on `CompositeSubscription` should be `+=`, +* Java Scheduler methods take `state` arguments (they were needed to schedule work on a different machine, but are now considered a bad idea). Remove these `state` arguments from all Scala schedulers., +*
[+++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.Observable;, + * Concatenates an array of Publishers eagerly into a single stream of values., + * <p>, + * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatArrayEager.png" alt="">, + * @param sources an array of Publishers that need to be eagerly concatenated, + * Concatenates an array of Publishers eagerly into a single stream of values., + * <p>, + * <img width="640" height="406" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatArrayEager.nn.png" alt="">, + * @param sources an array of Publishers that need to be eagerly concatenated, + * Concatenates an array of {@link Publisher}s eagerly into a single stream of values, + * and delaying
[+++ b/build.gradle, +def jmhLibVersion = "1.19", + jmhVersion = jmhLibVersion, + includeTests = false, +++ b/build.gradle, +def jmhLibVersion = "1.19", + jmhVersion = jmhLibVersion, + includeTests = false, +++ b/src/jmh/java/io/reactivex/PerfBoundedSubscriber.java, +/**, + * Copyright (c) 2016-present, RxJava Contributors., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is,
[+++ b/src/main/java/io/reactivex/Single.java, + * <p>, + * <img width="640" height="515" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.amb.png" alt="">, + * <p>, + * <img width="640" height="515" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.ambArray.png" alt="">]
[+++ b/CHANGES.md, +### Version 0.14.9 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.9%22)) ###, +, +* [Pull 477](https://github.com/Netflix/RxJava/pull/477) BugFix: CompositeSubscription, +* [Pull 476](https://github.com/Netflix/RxJava/pull/476) BugFix: Don't emit null onComplete when no onNext received in AsyncSubject, +* [Pull 474](https://github.com/Netflix/RxJava/pull/474) BugFix: Reduce an empty observable, +* [Pull 474](https://github.com/Netflix/RxJava/pull/474) BugFix: non-deterministic unit test, +* [Pull 472](https://github.com/Netflix/RxJava/pull/472) BugFix: Issue 431 Unsubscribe with Schedulers.newThread, +* [Pull 470](https://github.com/Netflix/RxJava/pull/470) Operator: Last, +, +++ b/CHANGES.md, +### Version 0.14.9 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.9%22)) ###, +, +* [Pull 477](https://github.com/Netflix/RxJava/pull/477) BugFix: CompositeSubscription, +* [Pull 476](https://github.com/Netflix/RxJava/pull/476) BugFix: Don't emit null onComplete when no onNext received in AsyncSubject, +* [Pull 474](https://github.com/Netflix/RxJava/pull/474) BugFix: Reduce an empty observable, +* [Pull 474](https://github.com/Netflix/RxJava/pull/474) BugFix: non-deterministic
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorToObservableFuture;, + return create(OperatorToObservableFuture.toObservableFuture(future));, + return create(OperatorToObservableFuture.toObservableFuture(future, timeout, unit));, + return create(OperatorToObservableFuture.toObservableFuture(future)).subscribeOn(scheduler);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorToObservableFuture;, + return create(OperatorToObservableFuture.toObservableFuture(future));, + return create(OperatorToObservableFuture.toObservableFuture(future, timeout, unit));, + return create(OperatorToObservableFuture.toObservableFuture(future)).subscribeOn(scheduler);, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorToObservableFuture;, + return create(OperatorToObservableFuture.toObservableFuture(future));, + return create(OperatorToObservableFuture.toObservableFuture(future, timeout, unit));, + return create(OperatorToObservableFuture.toObservableFuture(future)).subscribeOn(scheduler);, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorToObservableFuture.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.12-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.12-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/README.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.12-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/README.md, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.12-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/README.md, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +import org.junit.Test;, +, +, + Action1<Movie> moviePrinter = new Action1<Movie>() {, + };, + , + @Test, + public void test() {, + MovieLib lib = new MovieLib(Observable.from(new Movie(3000), new Movie(1000), new Movie(2000)));, + , + lib.longMovies().subscribe(moviePrinter); , +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.12-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/README.md, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +import org.junit.Test;, +, +, + Action1<Movie> moviePrinter = new Action1<Movie>() {, + };, + , +
[+++ b/src/main/java/io/reactivex/internal/operators/parallel/ParallelDoOnNextTry.java, +/**, + * Copyright (c) 2016-present, RxJava Contributors., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language
[+++ b/src/main/java/io/reactivex/Observable.java, + // using onSubscribe so the fusing has access to the underlying raw Publisher, + return create(new PublisherLift<>(onSubscribe, lifter));, + , + public <U, R> Observable<R> withLatestFrom(Publisher<? extends U> other, BiFunction<? super T, ? super U, ? extends R> combiner) {, + Objects.requireNonNull(other);, + Objects.requireNonNull(combiner);, + , + return lift(new OperatorWithLatestFrom<>(combiner, other));, + }, +++ b/src/main/java/io/reactivex/Observable.java, + // using onSubscribe so the fusing has access to the underlying raw Publisher, + return create(new PublisherLift<>(onSubscribe, lifter));, + , + public <U, R> Observable<R> withLatestFrom(Publisher<? extends U> other, BiFunction<? super T, ? super U, ? extends R> combiner) {,
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/rxjava-contrib/rxjava-swing/build.gradle, +apply plugin: 'java', +apply plugin: 'eclipse', +apply plugin: 'idea', +apply plugin: 'osgi', +, +sourceCompatibility = JavaVersion.VERSION_1_6, +targetCompatibility = JavaVersion.VERSION_1_6, +, +dependencies {, + compile project(':rxjava-core'), + provided 'junit:junit:4.10', + provided 'org.mockito:mockito-core:1.8.5', +}, +, +eclipse {, + classpath {, + // include 'provided' dependencies on the classpath, + plusConfigurations += configurations.provided, +, + downloadSources = true, + downloadJavadoc = true, + }, +}, +, +idea {, + module {, +
[+++ b/rxjava-core/src/main/java/rx/Observable.java, + return create(OperatorAmb.amb(sources));, + return create(OperatorAmb.amb(o1, o2));, + return create(OperatorAmb.amb(o1, o2, o3));, + return create(OperatorAmb.amb(o1, o2, o3, o4));, + return create(OperatorAmb.amb(o1, o2, o3, o4, o5));, + return create(OperatorAmb.amb(o1, o2, o3, o4, o5, o6));, + return create(OperatorAmb.amb(o1, o2, o3, o4, o5, o6, o7));, + return create(OperatorAmb.amb(o1, o2, o3, o4, o5, o6, o7, o8));, + return create(OperatorAmb.amb(o1, o2, o3, o4, o5, o6, o7, o8, o9));, + return create(new OperatorCombineLatest<T, R>(sources, combineFunction));, + return create(new OperatorDefer<T>(observableFactory));, + return create(OperatorToObservableFuture.toObservableFuture(future));, + return create(OperatorToObservableFuture.toObservableFuture(future, timeout, unit));, + return create(OperatorToObservableFuture.toObservableFuture(future)).subscribeOn(scheduler);, + return create(new OperatorTimerPeriodically(interval, interval, unit, Schedulers.computation()));, + return create(new OperatorTimerPeriodically(interval, interval, unit,
[+++ b/CHANGES.md, +### Version 0.12.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.12.2%22)) ###, +, +* [Pull 352](https://github.com/Netflix/RxJava/pull/352) Groovy Language Adaptor: Add Func5-9 and N to the wrapper, +, +### Version 0.12.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.12.1%22)) ###, +, +* [Pull 350](https://github.com/Netflix/RxJava/pull/350) Swing module enhancements, +* [Pull 351](https://github.com/Netflix/RxJava/pull/351) Fix Observable.window static/instance bug, +, +### Version 0.12.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.12.0%22)) ###, +, +This version adds to the static typing changes in 0.11 and adds covariant/contravariant typing via super/extends generics., +, +Additional cleanup was done, particularly related to `BlockingObservable`. Also the `window` operator was added., +, +The largest breaking change is that `Observable.create` now accepts an `OnSubscribeFunc` rather than a `Func1`.,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ /dev/null, +++ b/rxjava-core/src/test/java/rx/SchedulersTest.java, +/**, + * Copyright 2013 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBuffer.java, +import io.reactivex.internal.subscriptions.*;, + static final class BackpressureBufferSubscriber<T> extends BasicIntQueueSubscription<T> implements Subscriber<T> {, +, + boolean outputFused;, +, + if (outputFused) {, + actual.onNext(null);, + } else {, + }, + if (outputFused) {, + actual.onError(t);, + } else {, + }, + if (outputFused) {, + actual.onComplete();, + } else {, + }, + if (!outputFused) {, + }, + s.cancel();, +, + @Override, + public int requestFusion(int mode) {, + if ((mode & ASYNC) != 0) {, + outputFused = true;, + return ASYNC;, + }, + return NONE;, + }, +, + @Override, + public
[+++ b/gradle.properties, +version=0.12.3-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Calls the specified action after this Flowable signals onError or onCompleted or gets cancelled by, + * the downstream., + * <p>In case of a race between a terminal event and a cancellation, the provided {@code onFinally} action, + * is executed at once per subscription., + * <p>Note that the {@code onFinally} action is shared between subscriptions and as such, + * should be thread-safe., + * <dl>, + * <dt><b>Backpressure:</b></dt>, + * <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure, + * behavior.</dd>, + * <dt><b>Scheduler:</b></dt>,
[+++ b/gradle.properties, +version=0.14.9-SNAPSHOT, +++ b/gradle.properties, +version=0.14.9-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationDoOnEach;, + return create(OperationScan.scan(this, accumulator)).takeLast(1);, +, + /**, + * Invokes an action for each element in the observable sequence., + *, + * @param func, + * The action to invoke for each element in the source sequence., + *, + * @return, + * The source sequence with the side-effecting behavior applied., + * @see <a href="http://msdn.microsoft.com/en-us/library/hh229115(v=vs.103).aspx">MSDN: Observable.Amb</a>, + */, + public Observable<T> doOnEach(Observer<? super T> observer) {, + return create(OperationDoOnEach.doOnEach(this, observer));, + }, +, +, +++ b/gradle.properties, +version=0.14.9-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationDoOnEach;, + return create(OperationScan.scan(this, accumulator)).takeLast(1);, +,
[+++ b/build.gradle, +apply plugin: 'pmd', +, +pmd {, + toolVersion = '5.4.2', + ignoreFailures = true, + sourceSets = [sourceSets.main], + ruleSets = [], + ruleSetFiles = files('pmd.xml'), +, +}, +, +pmdMain {, + reports {, + html.enabled = true, + xml.enabled = true, + }, +}, +, +build.dependsOn pmdMain, +, +task pmdPrint(dependsOn: 'pmdMain') << {, + File file = new File('build/reports/pmd/main.xml'), + if (file.exists()) {, +, + println("Listing first 100 PMD violations"), +, + file.eachLine { line, count ->, + if (count <= 100) {, + println(line), + }, + }, +, + } else {, + println("PMD
[+++ b/rxjava/src/main/java/rx/Observable.java, +++ b/rxjava/src/main/java/rx/Observable.java, +++ b/rxjava/src/main/java/rx/Subscriber.java, +++ b/rxjava/src/main/java/rx/Observable.java, +++ b/rxjava/src/main/java/rx/Subscriber.java, +++ b/rxjava/src/main/java/rx/observables/GroupedObservable.java, +++ b/rxjava/src/main/java/rx/Observable.java, +++ b/rxjava/src/main/java/rx/Subscriber.java, +++ b/rxjava/src/main/java/rx/observables/GroupedObservable.java, +++ /dev/null, +++ b/rxjava/src/main/java/rx/Observable.java, +++ b/rxjava/src/main/java/rx/Subscriber.java, +++ b/rxjava/src/main/java/rx/observables/GroupedObservable.java, +++ /dev/null, +++ /dev/null, +++ b/rxjava/src/main/java/rx/Observable.java, +++ b/rxjava/src/main/java/rx/Subscriber.java, +++ b/rxjava/src/main/java/rx/observables/GroupedObservable.java, +++ /dev/null, +++ /dev/null, +++ b/rxjava/src/main/java/rx/plugins/RxJavaPlugins.java, +++ b/rxjava/src/main/java/rx/Observable.java, +++ b/rxjava/src/main/java/rx/Subscriber.java, +++ b/rxjava/src/main/java/rx/observables/GroupedObservable.java, +++ /dev/null, +++ /dev/null, +++ b/rxjava/src/main/java/rx/plugins/RxJavaPlugins.java, +++ b/rxjava/src/main/java/rx/schedulers/Schedulers.java, + Scheduler c = RxJavaPlugins.getInstance().getSchedulersHook().getComputationScheduler();, + Scheduler io = RxJavaPlugins.getInstance().getSchedulersHook().getIOScheduler();, + Scheduler nt = RxJavaPlugins.getInstance().getSchedulersHook().getNewThreadScheduler();, +++ b/rxjava/src/main/java/rx/Observable.java, +++ b/rxjava/src/main/java/rx/Subscriber.java, +++ b/rxjava/src/main/java/rx/observables/GroupedObservable.java, +++ /dev/null, +++ /dev/null, +++ b/rxjava/src/main/java/rx/plugins/RxJavaPlugins.java, +++ b/rxjava/src/main/java/rx/schedulers/Schedulers.java, + Scheduler c = RxJavaPlugins.getInstance().getSchedulersHook().getComputationScheduler();, + Scheduler io = RxJavaPlugins.getInstance().getSchedulersHook().getIOScheduler();, + Scheduler nt =
[+++ b/gradle.properties, +version=0.11.2-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/disposables/BooleanDisposable.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the
[+++ b/gradle.properties, +version=0.17.0-RC1-SNAPSHOT, +++ b/gradle.properties, +version=0.17.0-RC1-SNAPSHOT, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-all.zip, +++ b/gradle.properties, +version=0.17.0-RC1-SNAPSHOT, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-all.zip, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, + @Test def timeoutExample(): Unit = {, + val other = List(100L, 200L, 300L).toObservable, + val result = Observable.interval(100 millis).timeout(50 millis, other).toBlockingObservable.toList, + println(result), + }, +, + @Test def timeoutExample2(): Unit = {, + val firstTimeoutSelector = () => {, + Observable.timer(10 seconds, 10 seconds, ComputationScheduler()).take(1), + }, + val timeoutSelector = (t: Long) => {, + Observable.timer(, + (500 - t * 100) max 1 millis,, + (500 - t * 100) max 1 millis,, + ComputationScheduler()).take(1), + }, +
[+++ b/gradle.properties, +version=0.15.0-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/parallel/ParallelFlowable.java, + return RxJavaPlugins.onAssembly(new ParallelFromPublisher<T>(source, parallelism, prefetch));, + return RxJavaPlugins.onAssembly(new ParallelMap<T, R>(this, mapper));, + return RxJavaPlugins.onAssembly(new ParallelFilter<T>(this, predicate));, + return RxJavaPlugins.onAssembly(new ParallelRunOn<T>(this, scheduler, prefetch));, + return RxJavaPlugins.onAssembly(new ParallelReduce<T, R>(this, initialSupplier, reducer));, + ObjectHelper.requireNonNull(comparator, "comparator is null");, + ObjectHelper.verifyPositive(capacityHint, "capacityHint");, + ObjectHelper.requireNonNull(comparator, "comparator is null");, + ObjectHelper.verifyPositive(capacityHint, "capacityHint");, +, + ObjectHelper.requireNonNull(onNext, "onNext is null");, + return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,, + ));, + ObjectHelper.requireNonNull(onAfterNext, "onAfterNext is null");, + return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,, + ));, + ObjectHelper.requireNonNull(onError, "onError is null");, + return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,, + ));, + ObjectHelper.requireNonNull(onComplete, "onComplete is null");, + return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,, + ));, + ObjectHelper.requireNonNull(onAfterTerminate, "onAfterTerminate is null");, +
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.13.2-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.13.2-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, + * , + * <p>A typical implementation of {@code subscribe} does the following:, + * , + * <p>A typical implementation of {@code subscribe} does the following:, + * , + * Combines the given observables, emitting an event containing an aggregation of the latest values of each of the source observables, + * each time an event is received from one of the source observables, where the aggregation is defined by the given function., + * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/combineLatest.png">, + * , +
[+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java, + U o = svq.poll();, + if (q != null) {, + U o;, + j++;, + if (j == n) {, + j = 0;, + }, +, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java, + U o = svq.poll();, + if (q != null) {, + U o;, + j++;, + if (j == n) {, + j = 0;, + }, +, +++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableFlatMapTest.java, +import io.reactivex.disposables.*;, +import io.reactivex.subjects.*;, +, + @Test, + public void fusedSourceCrashResumeWithNextSource() {, + final UnicastSubject<Integer> fusedSource = UnicastSubject.create();, + TestObserver<Integer> to = new TestObserver<Integer>();, +, + ObservableFlatMap.MergeObserver<Integer, Integer> merger =, + new ObservableFlatMap.MergeObserver<Integer, Integer>(to, new
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java, + s.cancel();, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java, + s.cancel();, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableTimeoutTimed.java, + s.dispose();, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java, + s.cancel();, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableTimeoutTimed.java, + s.dispose();, +++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableTimeoutTest.java, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertTrue;, +import io.reactivex.schedulers.TestScheduler;, +import io.reactivex.subjects.PublishSubject;, +import io.reactivex.subscribers.TestSubscriber;, + @Test, + public void shouldUnsubscribeFromUnderlyingSubscriptionOnDispose() {, + final PublishSubject<String> subject = PublishSubject.create();, + final TestScheduler scheduler = new TestScheduler();, +, + final TestSubscriber<Void> observer = subject.toCompletable(), + .timeout(100, TimeUnit.MILLISECONDS, scheduler), + .test();, +, + assertTrue(subject.hasObservers());, +, + observer.dispose();, +, + assertFalse(subject.hasObservers());, + }, +, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java, + s.cancel();, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableTimeoutTimed.java, + s.dispose();, +++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableTimeoutTest.java, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertTrue;, +import io.reactivex.schedulers.TestScheduler;, +import io.reactivex.subjects.PublishSubject;,
[+++ b/src/main/java/io/reactivex/Observable.java, + * <img width="640" height="236" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/lastOrError.png" alt="">, + * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturn.o.png" alt="">, + * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorReturnItem.o.png" alt="">, + * <p>, + * <img width="640" height="246" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onTerminateDetach.o.png" alt="">, + * <img width="640" height="647" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishFunction.o.png" alt="">, + * <img width="640" height="325" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduceSeed.o.png" alt="">, + * <img width="640" height="325" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/reduceWith.o.png" alt="">, + * <img width="640" height="287" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatInf.o.png" alt="">, + * <img width="640" height="336" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatCount.o.png" alt="">, + * <img width="640" height="262" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/repeatUntil.o.png" alt="">, + * a boolean supplier that is called when the current Observable completes;, + * if it returns true, the returned Observable completes; if
[+++ b/gradle.properties, +version=0.17.4]
[+++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.internal.observers.*;, + BlockingObserver<Void> observer = new BlockingObserver<Void>();, + subscribe(observer);, + observer.blockingGet();, + BlockingObserver<Void> observer = new BlockingObserver<Void>();, + subscribe(observer);, + return observer.blockingAwait(timeout, unit);, + BlockingObserver<Void> observer = new BlockingObserver<Void>();, + subscribe(observer);, + return observer.blockingGetError();, + ObjectHelper.requireNonNull(unit, "unit is null");, + BlockingObserver<Void> observer = new BlockingObserver<Void>();, + subscribe(observer);, + return observer.blockingGetError(timeout, unit);, +++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.internal.observers.*;, + BlockingObserver<Void> observer = new BlockingObserver<Void>();, + subscribe(observer);, + observer.blockingGet();, + BlockingObserver<Void> observer = new BlockingObserver<Void>();, + subscribe(observer);, + return observer.blockingAwait(timeout, unit);, + BlockingObserver<Void> observer = new BlockingObserver<Void>();, + subscribe(observer);, + return observer.blockingGetError();, + ObjectHelper.requireNonNull(unit, "unit is null");, + BlockingObserver<Void> observer
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Returns a Flowable that signals the given (constant reference) item and then completes., + * Note that the item is taken and re-emitted as is and not computed by any means by {@code just}. Use {@link #fromCallable(Callable)}, + * to generate a single item on demand (when {@code Subscriber}s subscribe to it)., + * See the multi-parameter overloads of {@code just} to emit more than one (constant reference) items one after the other., + * Use {@link #fromArray(Object...)} to emit an arbitrary number of items that are known upfront., + * <p>, + * To
[+++ b/gradle.properties, +version=0.10.0]
[+++ b/src/main/java/io/reactivex/Observable.java, + throw new IndexOutOfBoundsException("n >= required but it was " + n);, + throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);, +++ b/src/main/java/io/reactivex/Observable.java, + throw new IndexOutOfBoundsException("n >= required but it was " + n);, + throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorTakeLast.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (SubscriptionHelper.validateRequest(n)) {, + drain();, +++ b/src/main/java/io/reactivex/Observable.java, + throw new IndexOutOfBoundsException("n >= required but it was " + n);, + throw new IndexOutOfBoundsException("count >= 0 required but it was " + count);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorTakeLast.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (SubscriptionHelper.validateRequest(n)) {,
[+++ b/gradle.properties, +version=0.11.0-SNAPSHOT]
[+++ b/CHANGES.md, +### Version 0.20.0-RC1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.20.0-RC1%22)) ###, +, +, +Version 0.20.0-RC1 is a preview release that adds backpressure support to RxJava as per issue [#1000](https://github.com/Netflix/RxJava/issues/1000). It has been done in a way that is mostly additive and most existing code will not be affected by these additions. A section below on "Breaking Changes" will discuss use cases that do break and how to deal with them., +, +This release has been tested successfully in Netflix production canaries, but that does not exercise all use cases or operators, nor does it leverage the newly added backpressure functionality (though the
[+++ b/src/main/java/io/reactivex/Flowable.java, + public final <R> Flowable<R> compose(FlowableTransformer<T, R> composer) {, + return lift(new FlowableOperator<T, T>() {, + public final <R> Flowable<R> lift(FlowableOperator<? extends R, ? super T> lifter) {, + return lift(new FlowableOperator<T, T>() {, +++ b/src/main/java/io/reactivex/Flowable.java, + public final <R> Flowable<R> compose(FlowableTransformer<T, R> composer) {, + return lift(new FlowableOperator<T, T>() {, + public final <R> Flowable<R> lift(FlowableOperator<? extends R, ? super T> lifter) {, + return lift(new FlowableOperator<T, T>() {, +++ b/src/main/java/io/reactivex/FlowableOperator.java, +/**, + * Copyright 2016 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
[+++ b/src/main/java/io/reactivex/Observable.java]
[+++ b/gradle.properties, +version=0.14.9-SNAPSHOT, +++ b/gradle.properties, +version=0.14.9-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +, +, + def doOnEach(observer: Observer[T]): Observable[T] = {, + Observable[T](asJava.doOnEach(observer)), + }, + , + def doOnEach(onNext: T => Unit): Observable[T] = {, + Observable[T](asJava.doOnEach(onNext)), + }, +, + def doOnEach(onNext: T => Unit, onComplete: () => Unit): Observable[T] = {, + Observable[T](asJava.doOnEach(onNext, onComplete)), + }, +, + def doOnEach(onNext: T => Unit, onError: Throwable => Unit): Observable[T] = {, + Observable[T](asJava.doOnEach(onNext, onError)), + }, +, + def doOnEach(onNext: T => Unit, onError: Throwable => Unit, onComplete: () => Unit): Observable[T] = {, + Observable[T](asJava.doOnEach(onNext, onError, onComplete)), + }, +,
[+++ b/src/main/java/io/reactivex/Flowable.java]
[+++ b/src/test/java/io/reactivex/maybe/MaybeTest.java, + public void ambIterable2SignalsSuccessWithOverlap() {, + PublishProcessor<Integer> pp1 = PublishProcessor.create();, + PublishProcessor<Integer> pp2 = PublishProcessor.create();, +, + TestSubscriber<Integer> ts = Maybe.amb(Arrays.asList(pp1.toMaybe(), pp2.toMaybe())), + .test();, +, + ts.assertEmpty();, +, + assertTrue(pp1.hasSubscribers());, + assertTrue(pp2.hasSubscribers());, +, + pp2.onNext(2);, + pp1.onNext(1);, + pp2.onComplete();, +, + assertFalse(pp1.hasSubscribers());, + assertFalse(pp2.hasSubscribers());, +, + ts.assertResult(2);, + }, +, + @SuppressWarnings("unchecked"), + @Test, + public void ambIterable2SignalsErrorWithOverlap() {, + PublishProcessor<Integer> pp1 = PublishProcessor.create();, + PublishProcessor<Integer> pp2 = PublishProcessor.create();, +, + TestSubscriber<Integer> ts = Maybe.amb(Arrays.asList(pp1.toMaybe(), pp2.toMaybe())), + .test();, +, + ts.assertEmpty();, +, + assertTrue(pp1.hasSubscribers());, + assertTrue(pp2.hasSubscribers());, +, + pp2.onError(new TestException("2"));, + pp1.onError(new TestException("1"));, +, + assertFalse(pp1.hasSubscribers());, +
[+++ b/src/main/java/io/reactivex/Observable.java, +, + public final Observable<T> sample(long period, TimeUnit unit) {, + return sample(period, unit, Schedulers.computation());, + }, +, + public final Observable<T> sample(long period, TimeUnit unit, Scheduler scheduler) {, + Objects.requireNonNull(unit);, + Objects.requireNonNull(scheduler);, + return lift(new OperatorSampleTimed<>(period, unit, scheduler));, + }, + , + public final <U> Observable<T> sample(Publisher<U> sampler) {, + Objects.requireNonNull(sampler);, + return lift(new OperatorSamplePublisher<>(sampler));, + }, +++ b/src/main/java/io/reactivex/Observable.java, +, + public final Observable<T> sample(long period, TimeUnit unit) {, + return sample(period, unit, Schedulers.computation());, + }, +, + public final Observable<T> sample(long period, TimeUnit unit, Scheduler scheduler) {, + Objects.requireNonNull(unit);, + Objects.requireNonNull(scheduler);, + return lift(new
[+++ b/src/main/java/io/reactivex/Completable.java, + * <p>, + * Note that the inner {@code Publisher} returned by the handler function should signal, + * either {@code onNext}, {@code onError} or {@code onComplete} in response to the received, + * {@code Throwable} to indicate the operator should retry or terminate. If the upstream to, + * the operator is asynchronous, signalling onNext followed by onComplete immediately may, + * result in the sequence to be completed immediately. Similarly, if this inner, + * {@code Publisher} signals {@code onError} or {@code onComplete} while the upstream is, + * active, the sequence is terminated
[+++ b/gradle.properties, +version=0.14.10-SNAPSHOT]
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC3-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC3-SNAPSHOT, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java, + *, + * @param <T1>, + * @param <T2>, + * @param <T3>, + * @param <T4>, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC3-SNAPSHOT, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java, + *, + * @param <T1>, + * @param <T2>, + * @param <T3>, + * @param <T4>, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyFunctionWrapper.java, + *, + * @param <T1>, + * @param <T2>, + * @param <T3>, + * @param <T4>, + * @param <T5>, + * @param <T6>, + * @param <T7>, + * @param <T8>, + * @param <T9>, + *
[+++ b/src/main/java/io/reactivex/Flowable.java, + return buffer(timespan, unit, Schedulers.computation(), Integer.MAX_VALUE);, + return buffer(timespan, unit, Schedulers.computation(), count);, + * @param count, + * the maximum size of each buffer before it is emitted, + public final Flowable<List<T>> buffer(long timespan, TimeUnit unit, Scheduler scheduler, int count) {, + return buffer(timespan, unit, scheduler, count, ArrayListSupplier.<T>asCallable(), false);, + * @param count, + * the maximum size of each buffer before it is emitted, + Scheduler scheduler, int count,, + return buffer(timespan, unit, scheduler, Integer.MAX_VALUE, ArrayListSupplier.<T>asCallable(), false);, +++ b/src/main/java/io/reactivex/Flowable.java, + return buffer(timespan, unit, Schedulers.computation(), Integer.MAX_VALUE);, + return buffer(timespan, unit, Schedulers.computation(), count);, + * @param count, +
[+++ /dev/null, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/observers/SerializedObserverViaQueueAndCounter.java, +package rx.observers;, +, +import java.util.concurrent.ConcurrentLinkedQueue;, +import java.util.concurrent.atomic.AtomicInteger;, +, +import rx.Observer;, +, +public class SerializedObserverViaQueueAndCounter<T> implements Observer<T> {, + private final Observer<? super T> actual;, + private final AtomicInteger count = new AtomicInteger();, + private final ConcurrentLinkedQueue<Object> queue = new ConcurrentLinkedQueue<Object>();, +, + private static Sentinel NULL_SENTINEL = new Sentinel();, + private static Sentinel COMPLETE_SENTINEL = new Sentinel();, +, + private static class Sentinel {, +, + }, +, + private static class ErrorSentinel extends Sentinel {, + final Throwable e;, +, + ErrorSentinel(Throwable e) {, + this.e = e;, + }, + },
[+++ b/src/main/java/io/reactivex/Observable.java, + * &#64;Override public void onNext(String t) {]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, + return lift(new OperatorWindowWithObservable<T, TClosing>(closingSelector));, + return lift(new OperatorWindowWithSize<T>(count, count));, + return lift(new OperatorWindowWithSize<T>(count, skip));, + return lift(new OperatorWindowWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, Schedulers.computation()));, + return lift(new OperatorWindowWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, scheduler));, + return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, Schedulers.computation()));, + return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, count, Schedulers.computation()));, + return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, count, scheduler));, + return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, scheduler));, + return lift(new OperatorWindowWithStartEndObservable<T, TOpening, TClosing>(windowOpenings, closingSelector));, + return lift(new OperatorWindowWithObservable<T, U>(boundary));, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return lift(new OperatorWindowWithObservable<T, TClosing>(closingSelector));, + return lift(new OperatorWindowWithSize<T>(count, count));, + return lift(new OperatorWindowWithSize<T>(count, skip));, + return lift(new OperatorWindowWithTime<T>(timespan, timeshift,
[+++ b/src/main/java/io/reactivex/NbpObservable.java, +import java.util.concurrent.*;, +import java.util.concurrent.atomic.AtomicReference;, +import java.util.stream.Stream;, +import io.reactivex.annotations.*;, +import io.reactivex.functions.*;, +import io.reactivex.internal.subscribers.nbp.*;, +import io.reactivex.observables.nbp.*;, +import io.reactivex.plugins.RxJavaPlugins;, +import io.reactivex.schedulers.*;, +import io.reactivex.subscribers.nbp.*;, + public interface NbpOperator<Downstream, Upstream> extends Function<NbpSubscriber<? super Downstream>, NbpSubscriber<? super Upstream>> {, + , + }, + , + /** An empty observable instance as there is no need to instantiate this more than once. */, + static final NbpObservable<Object> EMPTY = create(s -> {, + s.onSubscribe(EmptyDisposable.INSTANCE);, + s.onComplete();, + });, + /** A never NbpObservable instance as there is no need to instantiate this more than once. */, + static final NbpObservable<Object> NEVER = create(s
[+++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java, + static volatile Function<? super Runnable, ? extends Runnable> onScheduleHandler;, + static volatile Function<? super Callable<Scheduler>, ? extends Scheduler> onInitComputationHandler;, + static volatile Function<? super Callable<Scheduler>, ? extends Scheduler> onInitSingleHandler;, + static volatile Function<? super Callable<Scheduler>, ? extends Scheduler> onInitIoHandler;, + static volatile Function<? super Callable<Scheduler>, ? extends Scheduler> onInitNewThreadHandler;, + static volatile Function<? super Scheduler, ? extends Scheduler> onComputationHandler;, + static volatile Function<? super Scheduler, ? extends Scheduler> onSingleHandler;, + static volatile Function<? super Scheduler, ? extends Scheduler> onIoHandler;, + static volatile Function<? super Scheduler, ? extends Scheduler> onNewThreadHandler;, + static volatile Function<? super Flowable, ?
[+++ b/CHANGES.md, +### Version 0.15.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.15.0%22)) ###, +, +This release contains a refactor of the Scala Bindings by @headinthebox that results in some breaking changes. , +The previous solution ended up not working well in all cases for idiomatic Scala usage. Java/Scala interop has been changed and is no longer transparent so as to optimize for native Scala usage., +Read the [rxjava-scala README](https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-scala) for more information., +, +* [Pull 503](https://github.com/Netflix/RxJava/pull/503) New Scala Bindings, +* [Pull 502](https://github.com/Netflix/RxJava/pull/502) Fix ObserveOn and add ParallelMerge Scheduler overload, +* [Pull 499](https://github.com/Netflix/RxJava/pull/499) ObserveOn Refactor, +* [Pull 492](https://github.com/Netflix/RxJava/pull/492) Implement the scheduler overloads for Range, From,
[+++ b/src/test/java/io/reactivex/completable/CompletableTest.java, + @Test(timeout = 5000), + @Test(timeout = 5000), + @Test(timeout = 5000), + @Test(timeout = 5000, expected = TestException.class), + @Test(timeout = 5000), + @Test(timeout = 5000, expected = TestException.class), + @Test(timeout = 5000, expected = NullPointerException.class), + @Test(timeout = 5000), + @Test(timeout = 5000, expected = NullPointerException.class), + @Test(timeout = 5000, expected = NullPointerException.class), + @Test(timeout = 5000), + @Test(timeout = 5000), + @Test(timeout = 5000, expected = TestException.class), + @Test(timeout = 5000, expected = TestException.class), + @Test(timeout = 5000), + @Test(timeout = 5000, expected = TestException.class), + @Test(timeout = 5000), + @Test(timeout = 5000, expected
[+++ b/gradle.properties, +version=0.9.1]
[+++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/TestSchedulerExample.scala, +import scala.concurrent.duration._, +import scala.language.postfixOps, +import rx.lang.scala.{ Observable, Observer }, +import rx.lang.scala.concurrency.TestScheduler, + import org.mockito.Matchers._, + import org.mockito.Mockito._, +, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/TestSchedulerExample.scala, +import scala.concurrent.duration._, +import scala.language.postfixOps, +import rx.lang.scala.{ Observable, Observer }, +import rx.lang.scala.concurrency.TestScheduler, + import org.mockito.Matchers._, + import org.mockito.Mockito._, +, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, + implicit def toJavaNotification[T](s: Notification[T]): rx.Notification[_ <:
[+++ b/src/main/java/io/reactivex/Observable.java, + public interface Operator<Downstream, Upstream> extends Function<Observer<? super Downstream>, Observer<? super Upstream>> {, + public interface Transformer<Upstream, Downstream> extends Function<Observable<Upstream>, ObservableConsumable<Downstream>> {, + return lift(new Operator<T, T>() {, + public final <R> Observable<R> lift(Operator<? extends R, ? super T> onLift) {, + return lift(new Operator<T, T>() {, +++ b/src/main/java/io/reactivex/Observable.java, + public interface Operator<Downstream, Upstream> extends Function<Observer<? super Downstream>, Observer<? super Upstream>> {, + public interface Transformer<Upstream, Downstream> extends Function<Observable<Upstream>, ObservableConsumable<Downstream>> {, + return lift(new Operator<T, T>() {, + public final <R> Observable<R> lift(Operator<? extends R, ? super T> onLift) {, + return lift(new Operator<T, T>() {, +++
[+++ b/gradle.properties, +version=0.6.2]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/rxjava-contrib/rxjava-math/src/main/java/rx/math/operators/OperatorAverageDouble.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS
[+++ b/rxjava-core/src/main/java/rx/Observable.java, + return create(new OperatorDelayWithSelector<T, U, V>(this, subscriptionDelay, itemDelay));, + return create(new OperatorDelayWithSelector<T, U, U>(this, itemDelay));, + return create(new OperatorDelay<T>(this, delay, unit, Schedulers.computation()));, + return create(new OperatorDelay<T>(this, delay, unit, scheduler));, + return create(new OperatorDelaySubscription<T>(this, delay, unit, scheduler));, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return create(new OperatorDelayWithSelector<T, U, V>(this, subscriptionDelay, itemDelay));, + return create(new OperatorDelayWithSelector<T, U, U>(this, itemDelay));, + return create(new OperatorDelay<T>(this, delay, unit, Schedulers.computation()));, + return create(new OperatorDelay<T>(this, delay, unit, scheduler));, + return create(new OperatorDelaySubscription<T>(this, delay, unit, scheduler));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return create(new OperatorDelayWithSelector<T, U, V>(this, subscriptionDelay, itemDelay));, + return create(new OperatorDelayWithSelector<T, U, U>(this, itemDelay));, + return create(new OperatorDelay<T>(this,
[+++ b/src/main/java/io/reactivex/Maybe.java, + * Note that the result Maybe is semantically equivalent to a {@code Single}, since it's guaranteed, + * to emit exactly one item or an error. See {@link #toSingle(Object)} for a method with equivalent, + * behavior which returns a {@code Single}., + * <p>, +++ b/src/main/java/io/reactivex/Maybe.java, + * Note that the result Maybe is semantically equivalent to a {@code Single}, since it's guaranteed, + * to emit exactly one item or an error. See {@link #toSingle(Object)} for a method with equivalent, + * behavior which returns a {@code Single}., + * <p>, +++ b/src/test/java/io/reactivex/JavadocWording.java, +
[+++ b/src/main/java/io/reactivex/Observable.java, + return RxJavaPlugins.onAssembly(new ObservableRepeatWhen<T>(this, handler));, + return RxJavaPlugins.onAssembly(new ObservableRetryWhen<T>(this, handler));, +++ b/src/main/java/io/reactivex/Observable.java, + return RxJavaPlugins.onAssembly(new ObservableRepeatWhen<T>(this, handler));, + return RxJavaPlugins.onAssembly(new ObservableRetryWhen<T>(this, handler));, +++ /dev/null, +++ b/src/main/java/io/reactivex/Observable.java, + return RxJavaPlugins.onAssembly(new ObservableRepeatWhen<T>(this, handler));, + return RxJavaPlugins.onAssembly(new ObservableRetryWhen<T>(this, handler));, +++ /dev/null, +++ /dev/null, +++ b/src/main/java/io/reactivex/Observable.java, + return RxJavaPlugins.onAssembly(new ObservableRepeatWhen<T>(this, handler));, + return RxJavaPlugins.onAssembly(new ObservableRetryWhen<T>(this, handler));, +++ /dev/null, +++ /dev/null, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableRepeatWhen.java, +/**, + * Copyright 2016 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy
[+++ b/src/main/java/io/reactivex/Flowable.java, + * <p>, + * <p>, + * <p>]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Returns the first item emitted by this {@code BlockingObservable}, or throws, + * {@code NoSuchElementException} if it emits no items., + * <dd>The operator consumes the source {@code Flowable} in an unbounded manner, + * (i.e., no backpressure applied to it).</dd>, + * <dd>{@code blockingFirst} does not operate by default on a particular {@link Scheduler}.</dd>, + * @return the first item emitted by this {@code BlockingObservable}, + * @throws NoSuchElementException, + * if this {@code BlockingObservable} emits no items, + * @see <a href="http://reactivex.io/documentation/operators/first.html">ReactiveX documentation: First</a>, + public final T blockingFirst() {, + BlockingFirstSubscriber<T> s
[+++ b/src/main/java/io/reactivex/Observable.java, + , + private Observable<T> doOnEach(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Runnable onComplete, Runnable onAfterTerminate) {, + Objects.requireNonNull(onNext);, + Objects.requireNonNull(onError);, + Objects.requireNonNull(onComplete);, + Objects.requireNonNull(onAfterTerminate);, + return lift(new OperatorDoOnEach<>(onNext, onError, onComplete, onAfterTerminate));, + }, + , + public final Observable<T> doOnNext(Consumer<? super T> onNext) {, + return doOnEach(onNext, e -> { }, () -> { }, () -> { });, + }, +, + public final Observable<T> doOnError(Consumer<? super Throwable> onError) {, + return doOnEach(v -> { }, onError, () -> { }, () -> { });, + }, + , + public final Observable<T> doOnComplete(Runnable
[+++ b/build.gradle, + options.links(, + "https://docs.oracle.com/javase/7/docs/api/",, + "http://www.reactive-streams.org/reactive-streams-${reactiveStreamsVersion}-javadoc/", + ), +++ b/build.gradle, + options.links(, + "https://docs.oracle.com/javase/7/docs/api/",, + "http://www.reactive-streams.org/reactive-streams-${reactiveStreamsVersion}-javadoc/", + ), +++ b/src/main/java/io/reactivex/CompletableObserver.java, +++ b/build.gradle, + options.links(, + "https://docs.oracle.com/javase/7/docs/api/",, + "http://www.reactive-streams.org/reactive-streams-${reactiveStreamsVersion}-javadoc/", + ), +++ b/src/main/java/io/reactivex/CompletableObserver.java, +++ b/src/main/java/io/reactivex/MaybeObserver.java, +++ b/build.gradle, + options.links(, + "https://docs.oracle.com/javase/7/docs/api/",, + "http://www.reactive-streams.org/reactive-streams-${reactiveStreamsVersion}-javadoc/", + ), +++ b/src/main/java/io/reactivex/CompletableObserver.java, +++ b/src/main/java/io/reactivex/MaybeObserver.java, +++ b/src/main/java/io/reactivex/Observer.java, +++ b/build.gradle, + options.links(, + "https://docs.oracle.com/javase/7/docs/api/",, + "http://www.reactive-streams.org/reactive-streams-${reactiveStreamsVersion}-javadoc/", + ), +++ b/src/main/java/io/reactivex/CompletableObserver.java, +++ b/src/main/java/io/reactivex/MaybeObserver.java, +++ b/src/main/java/io/reactivex/Observer.java, +++ b/src/main/java/io/reactivex/SingleObserver.java]
[+++ b/src/main/java/io/reactivex/Maybe.java, + * @return an empty Completable that only calls {@code onComplete} or {@code onError}, based on which one is, + public final Completable ignoreElement() {, + return RxJavaPlugins.onAssembly(new MaybeIgnoreElementCompletable<T>(this));, +++ b/src/main/java/io/reactivex/Maybe.java, + * @return an empty Completable that only calls {@code onComplete} or {@code onError}, based on which one is, + public final Completable ignoreElement() {, + return RxJavaPlugins.onAssembly(new MaybeIgnoreElementCompletable<T>(this));, +++ b/src/main/java/io/reactivex/internal/disposables/DisposableHelper.java, + /**, + * Atomically disposes the Disposable in the field if not already disposed., + * @param field the target field, + * @return true if the curren thread managed to dispose the Disposable,
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.12.1-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.12.1-SNAPSHOT, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyFunctionWrapper.java, +public class GroovyFunctionWrapper<T1, T2, T3, T4, R> implements Func0<R>, Func1<T1, R>, Func2<T1, T2, R>, Func3<T1, T2, T3, R>, Func4<T1, T2, T3, T4, R> {, + , +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.12.1-SNAPSHOT, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyFunctionWrapper.java, +public class GroovyFunctionWrapper<T1, T2, T3, T4, R> implements Func0<R>, Func1<T1, R>, Func2<T1, T2, R>, Func3<T1, T2, T3, R>, Func4<T1, T2, T3, T4, R> {, + , +++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/observables/SwingObservable.java, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.12.1-SNAPSHOT, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyFunctionWrapper.java, +public class GroovyFunctionWrapper<T1, T2, T3, T4, R> implements Func0<R>, Func1<T1, R>, Func2<T1, T2, R>, Func3<T1, T2, T3,
[+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableCreate.java, + t = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableCreate.java, + t = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCreate.java, + onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));, + t = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");, + RxJavaPlugins.onError(e);, + if (t != null) {, + } else {, + onError(new NullPointerException("onNext called with null. Null
[+++ b/build.gradle, + perfCompile 'org.openjdk.jmh:jmh-core:1.11.3', + perfCompile 'org.openjdk.jmh:jmh-generator-annprocess:1.11.3', +++ b/build.gradle, + perfCompile 'org.openjdk.jmh:jmh-core:1.11.3', + perfCompile 'org.openjdk.jmh:jmh-generator-annprocess:1.11.3', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.12-bin.zip, +++ b/build.gradle, + perfCompile 'org.openjdk.jmh:jmh-core:1.11.3', + perfCompile 'org.openjdk.jmh:jmh-generator-annprocess:1.11.3', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.12-bin.zip, +++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.Observable.*;, + public static Completable concat(Flowable<? extends Completable> sources) {, + public static Completable concat(Flowable<? extends Completable> sources, int prefetch) {, + public static <T> Completable fromFlowable(final Flowable<T> flowable) {, + public static <T> Completable fromNbpObservable(final Observable<T> observable) {, + observable.subscribe(new Observer<T>() {, + public static Completable merge(Flowable<? extends Completable> sources) {, + public static Completable merge(Flowable<? extends Completable> sources, int maxConcurrency) {, + protected static
[+++ b/.gitignore, +++ b/.gitignore, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.1-bin.zip, +++ b/.gitignore, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.1-bin.zip, +++ b/language-adaptors/rxjava-clojure/build.gradle, +++ b/.gitignore, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.1-bin.zip, +++ b/language-adaptors/rxjava-clojure/build.gradle, +++ b/language-adaptors/rxjava-groovy/build.gradle, +++ b/.gitignore, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.1-bin.zip, +++ b/language-adaptors/rxjava-clojure/build.gradle, +++ b/language-adaptors/rxjava-groovy/build.gradle, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java, +++ b/.gitignore, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.1-bin.zip, +++ b/language-adaptors/rxjava-clojure/build.gradle, +++ b/language-adaptors/rxjava-groovy/build.gradle, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java, +++ b/language-adaptors/rxjava-jruby/build.gradle, +++ b/.gitignore, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.1-bin.zip, +++ b/language-adaptors/rxjava-clojure/build.gradle, +++ b/language-adaptors/rxjava-groovy/build.gradle, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java, +++ b/language-adaptors/rxjava-jruby/build.gradle, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java, +++ b/.gitignore, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.1-bin.zip, +++ b/language-adaptors/rxjava-clojure/build.gradle, +++ b/language-adaptors/rxjava-groovy/build.gradle, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java, +++ b/language-adaptors/rxjava-jruby/build.gradle, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java, +++ b/language-adaptors/rxjava-scala/build.gradle, +++ b/.gitignore, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.1-bin.zip, +++ b/language-adaptors/rxjava-clojure/build.gradle, +++ b/language-adaptors/rxjava-groovy/build.gradle, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java, +++ b/language-adaptors/rxjava-jruby/build.gradle, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java, +++ b/language-adaptors/rxjava-scala/build.gradle, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/ScalaAdaptor.scala, +import
[+++ b/gradle.properties, +version=0.14.0]
[+++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/Observable.java, + return RxJavaPlugins.onAssembly(new ObservableInterval(Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));, + return RxJavaPlugins.onAssembly(new ObservableIntervalRange(start, end, Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));, + return RxJavaPlugins.onAssembly(new ObservableTimer(Math.max(delay, 0L), unit, scheduler));, + verifyPositive(count, "count");, + verifyPositive(skip, "skip");, + verifyPositive(count, "count");, + ObjectHelper.requireNonNull(onTerminate, "onTerminate is null");, + return doOnEach(Functions.emptyConsumer(), , + Functions.actionConsumer(onTerminate), onTerminate, , + Functions.EMPTY_ACTION);, + verifyPositive(maxConcurrency, "maxConcurrency");, + * @param times, + public final Observable<T> repeat(long times) {, + if (times < 0) {, + throw new IllegalArgumentException("times >= 0 required but it was " + times);, + if (times == 0) {, + return RxJavaPlugins.onAssembly(new
[+++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java, + if (errors.size() == 1) {, + ae.initCause(errors.get(0));, + } else {, + }]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/rxjava-contrib/rxjava-math/src/main/java/rx/math/operators/OperatorAverageDouble.java, +/**
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC5-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC5-SNAPSHOT, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, + filter first future, + rx.Observable/flatMap, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC5-SNAPSHOT, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, + filter first future, + rx.Observable/flatMap, +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/core_test.clj, + [:a {:k :a :v 3}], +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC5-SNAPSHOT, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, + filter first future, + rx.Observable/flatMap, +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/core_test.clj, + [:a {:k :a :v 3}], +++ b/rxjava-core/src/main/java/rx/Observable.java, + * Compose Observables together with a function., + * This works on the Observables themselves whereas `lift` works on the internal Subscriber/Observers., + * , + * Lift should be used when creating an
[+++ b/language-adaptors/rxjava-scala-java/README.md, +, +rxjava-scala-java, +-----------------, +, +Contains examples illustrating how RxScala code can be used from Java., +++ b/language-adaptors/rxjava-scala-java/README.md, +, +rxjava-scala-java, +-----------------, +, +Contains examples illustrating how RxScala code can be used from Java., +++ b/language-adaptors/rxjava-scala-java/build.gradle, +, +apply plugin: 'osgi', +, +, +project(':language-adaptors:rxjava-scala-java') {, + //sourceSets.test.java.srcDir 'src/examples/java', + sourceSets.main.java.srcDir 'src/main/java', +}, +, +dependencies {, + compile 'org.scala-lang:scala-library:2.10.+', +, + compile project(':rxjava-core'), + , + compile project(':language-adaptors:rxjava-scala'), + , + provided 'junit:junit-dep:4.10', + provided 'org.mockito:mockito-core:1.8.5', + provided 'org.scalatest:scalatest_2.10:1.9.1', +}, +, +jar {, + manifest {, + name = 'rxjava-scala-java', + instruction 'Bundle-Vendor', 'Netflix', + instruction 'Bundle-DocURL', 'https://github.com/Netflix/RxJava', + instruction 'Import-Package',
[+++ b/gradle.properties, +version=0.17.2-SNAPSHOT]
[+++ b/gradle.properties, +version=0.17.0-RC4-SNAPSHOT]
[+++ b/src/test/java/io/reactivex/flowable/FlowableTests.java, +++ b/src/test/java/io/reactivex/flowable/FlowableTests.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCacheTest.java, +++ b/src/test/java/io/reactivex/flowable/FlowableTests.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCacheTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnUnsubscribeTest.java, +++ b/src/test/java/io/reactivex/flowable/FlowableTests.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCacheTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnUnsubscribeTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsTest.java, +++ b/src/test/java/io/reactivex/flowable/FlowableTests.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCacheTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnUnsubscribeTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMapTest.java, +++ b/src/test/java/io/reactivex/flowable/FlowableTests.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCacheTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnUnsubscribeTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMapTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMaterializeTest.java, +++ b/src/test/java/io/reactivex/flowable/FlowableTests.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCacheTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnUnsubscribeTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMapTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMaterializeTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeTest.java, +++ b/src/test/java/io/reactivex/flowable/FlowableTests.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCacheTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnUnsubscribeTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMapTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMaterializeTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferTest.java, +++ b/src/test/java/io/reactivex/flowable/FlowableTests.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCacheTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnUnsubscribeTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMapTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMaterializeTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java, +++ b/src/test/java/io/reactivex/flowable/FlowableTests.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableCacheTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoOnUnsubscribeTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsTest.java, +++
[+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableDelay.java, +import java.util.concurrent.atomic.AtomicReference;, +import io.reactivex.disposables.Disposable;, +import io.reactivex.internal.disposables.DisposableHelper;, + source.subscribe(new Delay(s, delay, unit, scheduler, delayError));, + static final class Delay extends AtomicReference<Disposable>, + implements CompletableObserver, Runnable, Disposable {, + private static final long serialVersionUID = 465972761105851022L;, + final CompletableObserver downstream;, + final long delay;, + final TimeUnit unit;, +, + final Scheduler scheduler;, +, + final boolean delayError;, +, + Throwable error;, +, + Delay(CompletableObserver downstream, long delay, TimeUnit unit, Scheduler scheduler, boolean delayError) {, + this.downstream = downstream;, + this.delay = delay;, + this.unit = unit;, + this.scheduler = scheduler;, + this.delayError = delayError;, + if (DisposableHelper.setOnce(this, d))
[+++ b/gradle.properties, +version=0.18.0]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * This method executes the {@code Consumer} on the current thread while, +++ b/src/main/java/io/reactivex/Flowable.java, + * This method executes the {@code Consumer} on the current thread while, +++ b/src/main/java/io/reactivex/Observable.java, + * This method executes the {@code Consumer} on the current thread while]
[+++ b/gradle.properties, +version=0.12.1]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/README.md, +RxJava, +======, +++ /dev/null, +++ /dev/null, +++ b/README.md, +RxJava, +======, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/README.md, +RxJava, +======, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/README.md, +RxJava, +======, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/README.md, +RxJava, +======, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/README.md, +RxJava, +======, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/README.md, +RxJava, +======, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/.travis.yml, +language: java, +, +jdk:, + - oraclejdk8, + - oraclejdk7, + - openjdk6]
[+++ b/src/main/java/io/reactivex/Completable.java, + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.COMPUTATION), + @SchedulerSupport(SchedulerSupport.CUSTOM), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.COMPUTATION), + @SchedulerSupport(SchedulerSupport.CUSTOM), + @SchedulerSupport(SchedulerSupport.CUSTOM), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.CUSTOM), + @SchedulerSupport(SchedulerSupport.CUSTOM), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.CUSTOM), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), + @SchedulerSupport(SchedulerSupport.NONE), +
[+++ b/src/main/java/io/reactivex/Scheduler.java, + * units of work provided in the form of {@link Runnable}s to be, + * executed without delay (effectively as soon as possible), after a specified time delay or periodically, + * and represents an abstraction over an asynchronous boundary that ensures, + * these units of work get executed by some underlying task-execution scheme, + * (such as custom Threads, event loop, {@link java.util.concurrent.Executor Executor} or Actor system), + * with some uniform properties and guarantees regardless of the particular underlying, + * scheme., + * <p>, + * You can get various standard, RxJava-specific
[+++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/build.gradle, +// Establish version and status, +ext.githubProjectName = rootProject.name // Change if github project name is not the same as the root project's name, + repositories {, + mavenLocal(), + mavenCentral() // maven { url 'http://jcenter.bintray.com' }, + }, + repositories { , + mavenCentral() // maven { url: 'http://jcenter.bintray.com'
[+++ /dev/null, +++ /dev/null, +++ b/src/main/java/io/reactivex/internal/subscribers/observable/NbpEmptySubscriber.java, + INSTANCE(false),, + DISPOSED(true);, + NbpEmptySubscriber(boolean disposeDisposable) {, +++ /dev/null, +++ b/src/main/java/io/reactivex/internal/subscribers/observable/NbpEmptySubscriber.java, + INSTANCE(false),, + DISPOSED(true);, + NbpEmptySubscriber(boolean disposeDisposable) {, +++ b/src/main/java/io/reactivex/observers/Observers.java, +++ /dev/null, +++ b/src/main/java/io/reactivex/internal/subscribers/observable/NbpEmptySubscriber.java, + INSTANCE(false),, + DISPOSED(true);, + NbpEmptySubscriber(boolean disposeDisposable) {, +++ b/src/main/java/io/reactivex/observers/Observers.java, +++ b/src/main/java/io/reactivex/observers/TestObserver.java, +import io.reactivex.internal.disposables.DisposableHelper;, + this(EmptyObserver.INSTANCE);, +, + /**, + * An observer that ignores all events and does not report errors., + */, + private enum EmptyObserver implements Observer<Object> {, + INSTANCE;, +, + @Override, + public void onSubscribe(Disposable d) {, + }, +, + @Override, + public void onNext(Object t) {, + }, +, +
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableScanSeed.java, +import java.util.concurrent.atomic.*;, +import io.reactivex.internal.fuseable.SimplePlainQueue;, +import io.reactivex.internal.queue.SpscArrayQueue;, +import io.reactivex.internal.subscriptions.*;, +import io.reactivex.internal.util.BackpressureHelper;, + source.subscribe(new ScanSeedSubscriber<T, R>(s, accumulator, r, bufferSize()));, + static final class ScanSeedSubscriber<T, R>, + extends AtomicInteger, + implements Subscriber<T>, Subscription {, + final Subscriber<? super R> actual;, +, + final SimplePlainQueue<R> queue;, + final AtomicLong requested;, +, + final int prefetch;, +, + final int limit;, +, + volatile boolean cancelled;, +, + volatile boolean done;, + Throwable error;, +, + Subscription s;, +, + R value;, +, + int consumed;, +, + ScanSeedSubscriber(Subscriber<? super R> actual, BiFunction<R, ? super T, R> accumulator, R value, int prefetch)
[+++ b/build.gradle, + testCompile 'org.mockito:mockito-core:2.1.0-RC.2', +++ b/build.gradle, + testCompile 'org.mockito:mockito-core:2.1.0-RC.2', +++ b/src/test/java/io/reactivex/TestHelper.java, +import static org.mockito.Mockito.*;, + Subscription s = a.getArgument(0);, +++ b/build.gradle, + testCompile 'org.mockito:mockito-core:2.1.0-RC.2', +++ b/src/test/java/io/reactivex/TestHelper.java, +import static org.mockito.Mockito.*;, + Subscription s = a.getArgument(0);, +++ b/src/test/java/io/reactivex/completable/CompletableTest.java, +++ b/build.gradle, + testCompile 'org.mockito:mockito-core:2.1.0-RC.2', +++ b/src/test/java/io/reactivex/TestHelper.java, +import static org.mockito.Mockito.*;, + Subscription s = a.getArgument(0);, +++ b/src/test/java/io/reactivex/completable/CompletableTest.java, +++ b/src/test/java/io/reactivex/disposables/DisposablesTest.java, +++ b/build.gradle, + testCompile 'org.mockito:mockito-core:2.1.0-RC.2', +++ b/src/test/java/io/reactivex/TestHelper.java, +import static org.mockito.Mockito.*;, + Subscription s = a.getArgument(0);, +++ b/src/test/java/io/reactivex/completable/CompletableTest.java, +++ b/src/test/java/io/reactivex/disposables/DisposablesTest.java, +++ b/src/test/java/io/reactivex/flowable/FlowableTests.java, + any(Throwable.class));, + any(Throwable.class));, + any(Throwable.class));, + any(Throwable.class));, + any(Throwable.class));, + any(Throwable.class));, + any(Throwable.class));, + any(Throwable.class));, + any(Throwable.class));, + any(Throwable.class));, +++ b/build.gradle,
[+++ b/src/main/java/io/reactivex/Observable.java, + public static <T> Observable<T> concat(Publisher<? extends T> p1, Publisher<? extends T> p2) {, + return concatArray(p1, p2);, + }, +, + public static <T> Observable<T> concat(, + Publisher<? extends T> p1, Publisher<? extends T> p2,, + Publisher<? extends T> p3) {, + return concatArray(p1, p2, p3);, + }, +, + public static <T> Observable<T> concat(, + Publisher<? extends T> p1, Publisher<? extends T> p2,, + Publisher<? extends T> p3, Publisher<? extends T> p4) {, + return concatArray(p1, p2, p3, p4);, + }, +, + public static <T> Observable<T> concat(, + Publisher<? extends T> p1, Publisher<? extends
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/rxjava-core/src/test/java/rx/operators/OperatorTimeoutTests.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/src/main/java/rx/Observable.java, + * termination if <code>disposeEagerly</code> is set to true and unsubscription does not occur before termination. Otherwise, + * resource disposal will occur on unsubscription. Eager disposal is particularly appropriate for a synchronous observable, + * that resuses resources. <code>disposeAction</code> will only be called once per subscription., + * if true then disposal will happen either on unsubscription or just before emission of , + * a terminal event (onComplete or onError)., + * @param onDrop the action to invoke for each item dropped. onDrop action should be fast and should never block.,
[+++ b/CHANGES.md, +### Version 0.14.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.0%22)) ###, +, +Further progress to the Scala adaptor and a handful of new operators., +, +Bump to 0.14.0 due to small breaking change to `distinct` operator removing overloaded methods with `Comparator`. These methods were added in 0.13.2 and determined to be incorrect., +, +This release also includes a new contrib module, [rxjava-apache-http](https://github.com/Netflix/RxJava/tree/master/rxjava-contrib/rxjava-apache-http) that provides an Observable API to the Apache HttpAsyncClient., +, +* [Pull 396](https://github.com/Netflix/RxJava/pull/396) Add missing methods to Scala Adaptor, +* [Pull 390](https://github.com/Netflix/RxJava/pull/390) Operators: ElementAt and ElementAtOrDefault, +* [Pull 398](https://github.com/Netflix/RxJava/pull/398) Operators: IsEmpty and Exists (instead of Any), +* [Pull 397](https://github.com/Netflix/RxJava/pull/397) Observable
[+++ b/src/main/java/io/reactivex/Single.java, + public final Single<T> delaySubscription(long time, TimeUnit unit) {, + public final Single<T> delaySubscription(long time, TimeUnit unit, Scheduler scheduler) {]
[+++ b/src/main/java/io/reactivex/Observable.java, + public final <U, R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper, BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayError, int maxConcurrency, int bufferSize) {, +++ b/src/main/java/io/reactivex/Observable.java, + public final <U, R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper, BiFunction<? super T, ? super U, ? extends R> combiner, boolean delayError, int maxConcurrency, int bufferSize) {, +++ b/src/main/java/io/reactivex/Observer.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (SubscriptionHelper.validateSubscription(this.s, s)) {, +++ b/src/main/java/io/reactivex/Observable.java, + public final <U, R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends U>> mapper, BiFunction<? super T, ? super
[+++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/blocking_test.clj, + (is (thrown? java.util.NoSuchElementException (b/single (rx/empty))))), +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/blocking_test.clj, + (is (thrown? java.util.NoSuchElementException (b/single (rx/empty))))), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, + @Test def firstLastSingleExample() {, + assertEquals(1, List(1, 2, 3, 4).toObservable.head.toBlockingObservable.single), + assertEquals(1, List(1, 2, 3, 4).toObservable.first.toBlockingObservable.single), + assertEquals(4, List(1, 2, 3, 4).toObservable.last.toBlockingObservable.single), + assertEquals(1, List(1).toObservable.single.toBlockingObservable.single), +, + assertEquals(1, List(1, 2, 3, 4).toObservable.toBlockingObservable.head), + assertEquals(1, List(1, 2, 3, 4).toObservable.toBlockingObservable.first), + assertEquals(4, List(1, 2, 3, 4).toObservable.toBlockingObservable.last), + assertEquals(1, List(1).toObservable.toBlockingObservable.single), + }, +, +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/blocking_test.clj, + (is (thrown? java.util.NoSuchElementException (b/single (rx/empty))))), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, + @Test def firstLastSingleExample() {, + assertEquals(1, List(1, 2, 3, 4).toObservable.head.toBlockingObservable.single), + assertEquals(1, List(1, 2, 3, 4).toObservable.first.toBlockingObservable.single), + assertEquals(4, List(1,
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.3-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.3-SNAPSHOT, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.3-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.3-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.3-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.3-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.3-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.3-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/src/main/java/io/reactivex/subjects/UnicastSubject.java, +import io.reactivex.annotations.Experimental;, + /** deliver onNext events before error event */, + final boolean delayError;, +, + return new UnicastSubject<T>(bufferSize(), true);, + return new UnicastSubject<T>(capacityHint, true);, + * @param onTerminate the callback to run when the Subject is terminated or cancelled, null not allowed, + public static <T> UnicastSubject<T> create(int capacityHint, Runnable onTerminate) {, + return new UnicastSubject<T>(capacityHint, onTerminate, true);, + * Creates an UnicastSubject with the given internal buffer capacity hint, delay error flag and, + * a callback for the case when the single Subscriber cancels its subscription., + *, + * <p>The callback, if
[+++ b/src/main/java/io/reactivex/Scheduler.java, + final SerialDisposable first = new SerialDisposable();, + final SerialDisposable sd = new SerialDisposable(first);, + first.replace(schedule(new Runnable() {, + sd.replace(schedule(this, delay, unit));, + return sd;, +++ b/src/main/java/io/reactivex/Scheduler.java, + final SerialDisposable first = new SerialDisposable();, + final SerialDisposable sd = new SerialDisposable(first);, + first.replace(schedule(new Runnable() {, + sd.replace(schedule(this, delay, unit));, + return sd;, +++ /dev/null, +++ b/src/main/java/io/reactivex/Scheduler.java, + final SerialDisposable first = new SerialDisposable();, + final SerialDisposable sd = new SerialDisposable(first);, + first.replace(schedule(new Runnable() {, + sd.replace(schedule(this, delay, unit));, + return sd;, +++ /dev/null, +++ b/src/main/java/io/reactivex/disposables/SerialDisposable.java, + public void replace(Disposable d) {, + DisposableHelper.replace(resource, d);, + }, +
[+++ b/gradle.properties, +version=0.11.0]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationThrottleWithTimeout;, + * Throttles by dropping all values that are followed by newer values before the timeout value expires. The timer reset on each `onNext` call., + * <p>, + * NOTE: If the timeout is set higher than the rate of traffic then this will drop all data., + * @param timeout, + * The time each value has to be 'the most recent' of the {@link Observable} to ensure that it's not dropped., + * The {@link TimeUnit} for the timeout., + * , + * @return An {@link Observable} which filters out values
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, + clearScalarQueue();, + clearScalarQueue();, + void clearScalarQueue() {, + SimpleQueue<U> q = queue;, + if (q != null) {, + q.clear();, + }, + }, +, +, + void innerError(InnerSubscriber<T, U> inner, Throwable t) {, + if (errs.addThrowable(t)) {, + inner.done = true;, + if (!delayErrors) {, + s.cancel();, + for (InnerSubscriber<?, ?> a : subscribers.getAndSet(CANCELLED)) {, + a.dispose();, + }, + }, + drain();, + } else {, + RxJavaPlugins.onError(t);, + }, + }, + lazySet(SubscriptionHelper.CANCELLED);, + parent.innerError(this, t);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, + clearScalarQueue();, + clearScalarQueue();, + void clearScalarQueue() {, + SimpleQueue<U> q = queue;, + if
[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, + case OnCompleted() => println("Completed"), + case OnCompleted() => println("Completed"), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, + case OnCompleted() => println("Completed"), + case OnCompleted() => println("Completed"), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Notification.scala, + case Notification.OnCompleted() => onCompleted(), + case Notification.OnCompleted() => observer.onCompleted(), + case rx.Notification.Kind.OnCompleted => new OnCompleted(n), + object OnCompleted {, +, + /**, + * Constructor for onCompleted notifications., + */, + def apply[T](): Notification[T] = {, + Notification(rx.Notification.createOnCompleted[T]()), + }, +, + /**, + * Extractor for onCompleted notifications., + */, + def unapply[U](notification: Notification[U]): Option[Unit] = notification match {, + case onCompleted: OnCompleted[U] => Some(), + case _ => None, +
[+++ b/src/main/java/io/reactivex/Observable.java, + , + public final <B> Observable<Observable<T>> window(Publisher<B> boundary) {, + return window(boundary, bufferSize());, + }, +, + public final <B> Observable<Observable<T>> window(Publisher<B> boundary, int bufferSize) {, + return lift(new OperatorWindowBoundary<>(boundary, bufferSize));, + }, +, + public final <B> Observable<Observable<T>> window(Supplier<? extends Publisher<B>> boundary) {, + return window(boundary, bufferSize());, + }, +, + public final <B> Observable<Observable<T>> window(Supplier<? extends Publisher<B>> boundary, int bufferSize) {, + return lift(new OperatorWindowBoundarySupplier<>(boundary, bufferSize));, + }, + , + public final <U, V> Observable<Observable<T>> window(, + Publisher<U> windowOpen, , + Function<? super U, ? extends Publisher<V>> windowClose) {, + return window(windowOpen, windowClose,
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybe.java, + } else {, + if (maxConcurrency != Integer.MAX_VALUE) {, + s.request(1);, + }, +, + if (maxConcurrency != Integer.MAX_VALUE) {, + s.request(1);, + }, + if (maxConcurrency != Integer.MAX_VALUE) {, + s.request(1);, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybe.java, + } else {, + if (maxConcurrency != Integer.MAX_VALUE) {, + s.request(1);, + }, +, + if (maxConcurrency != Integer.MAX_VALUE) {, + s.request(1);, + }, + if (maxConcurrency != Integer.MAX_VALUE) {, + s.request(1);, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapSingle.java, + } else {, + if (maxConcurrency != Integer.MAX_VALUE) {, + s.request(1);, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybe.java, + } else {, + if (maxConcurrency
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorTake;, +import rx.operators.OperatorTakeTimed;, + return bind(new OperatorTake<T>(num));, + return create(new OperatorTakeTimed.TakeTimed<T>(this, time, unit, scheduler));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorTake;, +import rx.operators.OperatorTakeTimed;, + return bind(new OperatorTake<T>(num));, + return create(new OperatorTakeTimed.TakeTimed<T>(this, time, unit, scheduler));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorTake;, +import rx.operators.OperatorTakeTimed;, + return bind(new OperatorTake<T>(num));, + return create(new OperatorTakeTimed.TakeTimed<T>(this, time, unit, scheduler));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorTake.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy
[+++ b/src/main/java/io/reactivex/exceptions/OnErrorNotImplementedException.java, + this("The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | " + e, e);, +++ b/src/main/java/io/reactivex/exceptions/OnErrorNotImplementedException.java, + this("The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | " + e, e);, +++ b/src/main/java/io/reactivex/exceptions/UndeliverableException.java, + super("The exception could not be delivered to the consumer because it has already canceled/disposed the flow or the exception has nowhere to go to begin with. Further reading: https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling | " + cause, cause);]
[+++ b/src/main/java/io/reactivex/Observable.java, + * <img width="640" height="449" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.f.png" alt="">, + * <img width="640" height="391" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fn.png" alt="">, + * <img width="640" height="350" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fnt.png" alt="">, + * <img width="640" height="328" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fnts.png" alt="">, + * <img width="640" height="362" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fns.png" alt="">, + * <img width="640" height="393" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.ft.png" alt="">, + * <img width="640" height="366" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fts.png" alt="">, + * <img width="640" height="406" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/replay.o.fs.png" alt="">]
[+++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +RxScala Release Notes, +=====================, +, +This release of the RxScala bindings builds on the previous 0.15 release to make the Rx bindings for Scala, +include all Rx types. In particular this release focuses on fleshing out the bindings for the `Subject` and `Scheduler` types., +To makes these notes self-contained, we will start with the `Observer[T]` and `Observable[T]` traits, +that lay at the heart of Rx., +, +Observer, +--------, +, +In this release we have made the `asJavaObserver` property in `Observable[T]`as well the the factory method
[+++ b/.gitignore, +, +# IntelliJ specific files/directories, +++ b/.gitignore, +, +# IntelliJ specific files/directories, +++ b/gradle/convention.gradle, + status = rootProject.status, + // Ensure output is on a new line, + javadoc.doFirst { println "" }, +, +, +++ b/.gitignore, +, +# IntelliJ specific files/directories, +++ b/gradle/convention.gradle, + status = rootProject.status, + // Ensure output is on a new line, + javadoc.doFirst { println "" }, +, +, +++ b/gradle/maven.gradle, +++ b/.gitignore, +, +# IntelliJ specific files/directories, +++ b/gradle/convention.gradle, + status = rootProject.status, + // Ensure output is on a new line, + javadoc.doFirst { println "" }, +, +,
[+++ b/gradle.properties, +version=0.14.3]
[+++ b/CHANGES.md, +### Version 0.15.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.15.0%22)) ###, +, +This release contains a refactor of the Scala Bindings by @headinthebox that results in some breaking changes. , +The previous solution ended up not working well in all cases for idiomatic Scala usage. Java/Scala interop has been changed and is no longer transparent so as to optimize for native Scala usage., +Read the [rxjava-scala README](https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-scala) for more information., +, +* [Pull 503](https://github.com/Netflix/RxJava/pull/503) New Scala Bindings, +* [Pull 502](https://github.com/Netflix/RxJava/pull/502) Fix ObserveOn and add ParallelMerge Scheduler overload, +* [Pull 499](https://github.com/Netflix/RxJava/pull/499) ObserveOn Refactor, +* [Pull 492](https://github.com/Netflix/RxJava/pull/492) Implement the scheduler overloads for Range, From,
[+++ b/src/main/java/io/reactivex/observables/ConnectableObservable.java, + * To disconnect from a synchronous source, use the {@link #connect(java.util.function.Consumer)} method., +++ b/src/main/java/io/reactivex/observables/ConnectableObservable.java, + * To disconnect from a synchronous source, use the {@link #connect(java.util.function.Consumer)} method., +++ b/src/test/java/io/reactivex/MergeTests.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/README.md, +, +## Documentation, +, +The API documentation can be found [here](http://rxscala.github.io/scaladoc/index.html#rx.lang.scala.Observable)., +, +You can build the API documentation yourself by running `./gradlew scaladoc` in the RxJava root directory., +, +Then navigate to `RxJava/language-adaptors/rxjava-scala/build/docs/scaladoc/index.html` to display it., +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/README.md, +, +## Documentation, +, +The API documentation can be found [here](http://rxscala.github.io/scaladoc/index.html#rx.lang.scala.Observable)., +, +You can build the API documentation yourself by running `./gradlew scaladoc` in the RxJava root directory., +, +Then navigate to `RxJava/language-adaptors/rxjava-scala/build/docs/scaladoc/index.html` to display
[+++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableLatest.java, +import io.reactivex.observers.DisposableObserver;, +++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableLatest.java, +import io.reactivex.observers.DisposableObserver;, +++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableNext.java, +import io.reactivex.observers.DisposableObserver;, +++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableLatest.java, +import io.reactivex.observers.DisposableObserver;, +++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableNext.java, +import io.reactivex.observers.DisposableObserver;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferBoundary.java, +import io.reactivex.observers.*;, +++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableLatest.java, +import io.reactivex.observers.DisposableObserver;, +++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableNext.java, +import io.reactivex.observers.DisposableObserver;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferBoundary.java, +import io.reactivex.observers.*;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferBoundarySupplier.java, +import io.reactivex.observers.*;, +++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableLatest.java, +import io.reactivex.observers.DisposableObserver;, +++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableNext.java, +import io.reactivex.observers.DisposableObserver;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferBoundary.java, +import io.reactivex.observers.*;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferBoundarySupplier.java, +import io.reactivex.observers.*;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferExactBoundary.java, +import io.reactivex.observers.*;, +++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableLatest.java, +import io.reactivex.observers.DisposableObserver;, +++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableNext.java, +import io.reactivex.observers.DisposableObserver;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferBoundary.java, +import io.reactivex.observers.*;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferBoundarySupplier.java, +import io.reactivex.observers.*;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferExactBoundary.java, +import io.reactivex.observers.*;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDebounce.java, +import io.reactivex.observers.*;, +++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableLatest.java, +import io.reactivex.observers.DisposableObserver;, +++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableNext.java, +import io.reactivex.observers.DisposableObserver;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferBoundary.java, +import io.reactivex.observers.*;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferBoundarySupplier.java, +import
[+++ b/gradle.properties, +version=0.13.1-SNAPSHOT]
[+++ b/gradle.properties, +version=0.14.9-SNAPSHOT]
[+++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/Rationale.md, +Alternative Rx bindings for Scala, +=================================, +, +The current RxScala binding attempt to optimize for seamless interop between Scala and Java., +The intended interop is illustrated by the following example where in Scala a class is defined that takes, +an `Observable[Movie]` that is transformed using RxScala operators:, +```scala, +class MovieLib(val moviesStream: Observable[Movie]) {, + val threshold = 1200, + def shortMovies: Observable[Movie] = ???, + def longMovies: Observable[Movie] = ???, +}, +```, +which is then called in Java, passing a Java `Observable<Movie>` to the constructor, +```java, +public void test() {, + MovieLib lib
[+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableTimeout.java, + TimeOutObserver(CompositeDisposable set, AtomicBoolean once, CompletableObserver s) {, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableTimeout.java, + TimeOutObserver(CompositeDisposable set, AtomicBoolean once, CompletableObserver s) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDelaySubscriptionOther.java, + DelaySubscription(Subscription s) {, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableTimeout.java, + TimeOutObserver(CompositeDisposable set, AtomicBoolean once, CompletableObserver s) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDelaySubscriptionOther.java, + DelaySubscription(Subscription s) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableInternalHelper.java, + ReplayCallable(Flowable<T> parent) {, + ReplayFunction(Function<? super Flowable<T>, ? extends Publisher<R>> selector, Scheduler scheduler) {, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableTimeout.java, + TimeOutObserver(CompositeDisposable set, AtomicBoolean once, CompletableObserver s) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDelaySubscriptionOther.java, + DelaySubscription(Subscription s) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableInternalHelper.java, + ReplayCallable(Flowable<T> parent) {, + ReplayFunction(Function<? super Flowable<T>, ? extends Publisher<R>> selector, Scheduler scheduler) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java, + Completion(UnicastProcessor<T> processor) {, +++
[+++ b/src/main/java/io/reactivex/Completable.java, + * <p>History: 2.0.4 - experimental, + * @since 2.1, + * <p>History: 2.0.1 - experimental, + * @since 2.1, + * <p>History: 2.0.5 - experimental, + * @since 2.1, +++ b/src/main/java/io/reactivex/Completable.java, + * <p>History: 2.0.4 - experimental, + * @since 2.1, + * <p>History: 2.0.1 - experimental, + * @since 2.1, + * <p>History: 2.0.5 - experimental, + * @since 2.1, +++ b/src/main/java/io/reactivex/Flowable.java, + * <p>History: 2.0.1 - experimental, + * @since 2.1, + * <p>History: 2.0.1 - experimental, + * @since 2.1, + * <p>History: 2.0.5 - experimental, + * @since 2.1 - beta, +
[+++ b/src/main/java/io/reactivex/Observable.java, + static final Observable<Object> EMPTY = new Observable<Object>() {, + protected void subscribeActual(Observer<? super Object> o) {, + o.onSubscribe(EmptyDisposable.INSTANCE);, + o.onComplete();, + };, + /** A never observable instance as there is no need to instantiate this more than once. */, + static final Observable<Object> NEVER = new Observable<Object>() {, + protected void subscribeActual(Observer<? super Object> o) {, + o.onSubscribe(EmptyDisposable.INSTANCE);, + };]
[+++ b/src/main/java/io/reactivex/internal/schedulers/AbstractDirectTask.java, + AbstractDirectTask(Runnable runnable) {, +++ b/src/main/java/io/reactivex/internal/schedulers/AbstractDirectTask.java, + AbstractDirectTask(Runnable runnable) {, +++ b/src/main/java/io/reactivex/subjects/UnicastSubject.java, + /** deliver onNext events before error event. */]
[+++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/TestSchedulerExample.scala, +import scala.concurrent.duration._, +import scala.language.postfixOps, +import rx.lang.scala.{ Observable, Observer }, +import rx.lang.scala.concurrency.TestScheduler, + import org.mockito.Matchers._, + import org.mockito.Mockito._, +, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/TestSchedulerExample.scala, +import scala.concurrent.duration._, +import scala.language.postfixOps, +import rx.lang.scala.{ Observable, Observer }, +import rx.lang.scala.concurrency.TestScheduler, + import org.mockito.Matchers._, + import org.mockito.Mockito._, +, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, + implicit def toJavaNotification[T](s: Notification[T]): rx.Notification[_ <:
[+++ b/gradle.properties, +version=0.14.10]
[+++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-clojure/src/examples/clojure/rx/lang/clojure/examples/rx_examples.txt, +(ns rx.lang.clojure.examples.rx-examples, + (:import rx.Observable rx.subscriptions.Subscriptions), + (:require [clj-http.client :as http])), +, +; NOTE on naming conventions. I'm using camelCase names (against clojure convention), +; in this file as I'm purposefully keeping functions and methods across, +; different language implementations in-sync for easy comparison., +, +; --------------------------------------------------, +; Hello World!, +; --------------------------------------------------, +, +(defn hello, + [& args], + (-> (Observable/toObservable args), + (.subscribe #(println (str "Hello " % "!"))))), +, +; To see output, +(comment, + (hello "Ben" "George")), +, +; --------------------------------------------------, +; Create Observable from Existing Data, +; --------------------------------------------------, +, +(defn
[+++ b/src/main/java/io/reactivex/Completable.java, + public static <T> Completable fromObservable(final ObservableSource<T> observable) {, + public final <T> Observable<T> endWith(ObservableSource<T> next) {, +++ b/src/main/java/io/reactivex/Completable.java, + public static <T> Completable fromObservable(final ObservableSource<T> observable) {, + public final <T> Observable<T> endWith(ObservableSource<T> next) {, +++ b/src/main/java/io/reactivex/Observable.java, +public abstract class Observable<T> implements ObservableSource<T> {, + public static <T> Observable<T> amb(Iterable<? extends ObservableSource<? extends T>> sources) {, + public static <T> Observable<T> amb(ObservableSource<? extends T>... sources) {, + public static <T, R> Observable<R> combineLatest(Function<? super T[], ? extends R> combiner, boolean delayError, int bufferSize, ObservableSource<? extends T>... sources) {, + public static <T, R> Observable<R> combineLatest(Iterable<? extends
[+++ b/gradle.properties, +version=0.18.3]
[+++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java, +, + if (error == null) {, + error = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");, + }, +, +, +++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java, +, + if (error == null) {, + error = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");, + }, +, +, +++ b/src/test/java/io/reactivex/plugins/RxJavaPluginsTest.java, +import java.util.concurrent.atomic.AtomicReference;, + @Test, + public void onErrorNull() {, + try {, + final AtomicReference<Throwable> t = new AtomicReference<Throwable>();, +, + RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {, + @Override, + public void accept(final Throwable throwable) throws
[+++ b/gradle.properties, +version=0.19.5-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Maybe.java, + * <dl>, +++ b/src/main/java/io/reactivex/Maybe.java, + * <dl>, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/Maybe.java, + * <dl>, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/processors/AsyncProcessor.java, + * This processor does not have a public constructor by design; a new empty instance of this, + * {@code AsyncProcessor} can be created via the {@link #create()} method., + * <p>, + * Since an {@code AsyncProcessor} is a Reactive Streams {@code Processor} type,, + * {@code null}s are not allowed (<a href="https://github.com/reactive-streams/reactive-streams-jvm#2.13">Rule 2.13</a>), + * as parameters to {@link #onNext(Object)} and {@link #onError(Throwable)}. Such calls will result in a, + * {@link NullPointerException} being thrown
[+++ b/gradle/stylesheet.css, +++ b/gradle/stylesheet.css, +++ b/src/jmh/java/io/reactivex/XMapYPerf.java, +++ b/gradle/stylesheet.css, +++ b/src/jmh/java/io/reactivex/XMapYPerf.java, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/gradle/stylesheet.css, +++ b/src/jmh/java/io/reactivex/XMapYPerf.java, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/Flowable.java, +++ b/gradle/stylesheet.css, +++ b/src/jmh/java/io/reactivex/XMapYPerf.java, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/Maybe.java, +++ b/gradle/stylesheet.css, +++ b/src/jmh/java/io/reactivex/XMapYPerf.java, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/Maybe.java, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/gradle/stylesheet.css, +++ b/src/jmh/java/io/reactivex/XMapYPerf.java, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/Maybe.java, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/Scheduler.java, +++ b/gradle/stylesheet.css, +++ b/src/jmh/java/io/reactivex/XMapYPerf.java, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/Maybe.java, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/Scheduler.java, +++ b/src/main/java/io/reactivex/Single.java, +++ b/gradle/stylesheet.css, +++ b/src/jmh/java/io/reactivex/XMapYPerf.java, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/Maybe.java, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/Scheduler.java, +++ b/src/main/java/io/reactivex/Single.java, +++ b/src/main/java/io/reactivex/internal/disposables/CancellableDisposable.java, +++ b/gradle/stylesheet.css, +++ b/src/jmh/java/io/reactivex/XMapYPerf.java, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/Flowable.java, +++
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationThrottleFirst;, + * Throttles to first value in each window., + * @param windowDuration, + * Duration of windows within with the first value will be chosen., + * The unit of time for the specified timeout., + * @return Observable which performs the throttle operation., + public Observable<T> throttleFirst(long windowDuration, TimeUnit unit) {, + return create(OperationThrottleFirst.throttleFirst(this, windowDuration, unit));, + * Throttles to first value in each window., + * @param windowDuration, + * Duration of windows within with the first value will be chosen., + * The unit of time for the specified timeout., +
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, + if (addInner(inner)) {, + }, + boolean addInner(InnerSubscriber<T, U> inner) {, + return false;, + return true;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, + if (addInner(inner)) {, + }, + boolean addInner(InnerSubscriber<T, U> inner) {, + return false;, + return true;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapCompletable.java, + if (set.add(inner)) {, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, + if (addInner(inner)) {, + }, + boolean addInner(InnerSubscriber<T, U> inner) {, + return false;, + return true;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapCompletable.java, + if (set.add(inner)) {, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapCompletableCompletable.java, + if (set.add(inner)) {, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, + if (addInner(inner)) {, + }, + boolean addInner(InnerSubscriber<T, U> inner) {, +
[+++ b/.gitignore, +/.nb-gradle/profiles/private/, +.nb-gradle-properties, +/.nb-gradle/private/, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +.nb-gradle-properties, +/.nb-gradle/private/, +++ b/rxjava-contrib/rxjava-quasar/README.md, +# rxjava-quasar, +, +Integrates RxJava with [Quasar](https://github.com/puniverse/quasar)., +Includes a fiber (lightweight-thread) based scheduler, and an Observable API for Quasar channels., +, +Main Classes:, +, +- [NewFiberScheduler](https://github.com/Netflix/RxJava/blob/master/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/NewFiberScheduler.java), +- [ChannelObservable](https://github.com/Netflix/RxJava/blob/master/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/ChannelObservable.java), +- [BlockingObservable](https://github.com/Netflix/RxJava/blob/master/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/BlockingObservable.java), +, +, +# Binaries, +, +Binaries and dependency information for Maven, Ivy, Gradle and others can be found at [http://search.maven.org](http://search.maven.org/#search%7Cga%7C1%7Ccom.netflix.rxjava)., +, +Example for [Maven](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22rxjava-apache-http%22):, +, +```xml, +<dependency>, + <groupId>com.netflix.rxjava</groupId>, + <artifactId>rxjava-quasar</artifactId>, + <version>x.y.z</version>, +</dependency>, +```, +, +and for Ivy:, +, +```xml, +<dependency org="com.netflix.rxjava" name="rxjava-quasar" rev="x.y.z" />, +```, +, +# Usage, +, +As always when using Quasar, the
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java, +, + // if we did emit at least one element, request more to replenish the queue, + if (d != 0) {, + if (sourceMode != QueueSubscription.SYNC) {, + upstream.get().request(d);, + }, + }, +, + if (d != 0) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java, +, + // if we did emit at least one element, request more to replenish the queue, + if (d != 0) {, + if (sourceMode != QueueSubscription.SYNC) {, + upstream.get().request(d);, + }, + }, +, + if (d != 0) {, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowablePublishTest.java, +, + @Test, + @SuppressWarnings("unchecked"), + public void splitCombineSubscriberChangeAfterOnNext()
[+++ b/src/main/java/io/reactivex/subjects/ReplaySubject.java, +import io.reactivex.annotations.*;, + * Note that due to concurrency requirements, a size- and time-bounded {@code ReplaySubject} may hold strong references to more, + * source emissions than specified while it isn't terminated yet. Use the {@link #cleanupBuffer()} to allow, + * such inaccessible items to be cleaned up by GC once no consumer references it anymore., + /**, + * Makes sure the item cached by the head node in a bounded, + * ReplaySubject is released (as it is never part of a replay)., + * <p>, + * By default, live bounded buffers will remember
[+++ b/.gitignore, +++ b/.gitignore, +++ b/gradle.properties, +version=0.17.0-RC2-SNAPSHOT, +++ b/.gitignore, +++ b/gradle.properties, +version=0.17.0-RC2-SNAPSHOT, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-all.zip, +++ b/.gitignore, +++ b/gradle.properties, +version=0.17.0-RC2-SNAPSHOT, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-all.zip, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscriptions.empty()!!, +++ b/.gitignore, +++ b/gradle.properties, +version=0.17.0-RC2-SNAPSHOT, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-all.zip, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscriptions.empty()!!, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscriptions.empty()!!, +++ b/.gitignore, +++ b/gradle.properties, +version=0.17.0-RC2-SNAPSHOT, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-all.zip, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscriptions.empty()!!, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscriptions.empty()!!, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, + @Test def combineLatestExample() {, + val first_counter = Observable.interval(250 millis), + val second_counter = Observable.interval(550 millis), + val combined_counter = first_counter.combineLatest(second_counter,, + (x: Long, y: Long) => List(x,y)) take 10, +, + combined_counter subscribe
[+++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.internal.operators.maybe.*;, + /**, + * Calls the specified action after this Completable signals onError or onComplete or gets disposed by, + * the downstream., + * <p>In case of a race between a terminal event and a dispose call, the provided {@code onFinally} action, + * is executed once per subscription., + * <p>Note that the {@code onFinally} action is shared between subscriptions and as such, + * should be thread-safe., + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code doFinally} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + *
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java, + R r = ObjectHelper.requireNonNull(combiner.apply(a), "The combiner returned a null value");, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java, + R r = ObjectHelper.requireNonNull(combiner.apply(a), "The combiner returned a null value");, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableInternalHelper.java, +import io.reactivex.internal.functions.*;, + Publisher<U> p = ObjectHelper.requireNonNull(itemDelay.apply(v), "The itemDelay returned a null Publisher");, + return new FlowableTakePublisher<U>(p, 1).map(Functions.justFunction(v)).defaultIfEmpty(v);, + Publisher<U> u = (Publisher<U>)ObjectHelper.requireNonNull(mapper.apply(t), "The mapper returned a null Publisher");, + return new FlowableFromIterable<U>(ObjectHelper.requireNonNull(mapper.apply(t), "The mapper returned a null Iterable"));, + Publisher<R> p = ObjectHelper.requireNonNull(selector.apply(t), "The selector returned a null Publisher");, + return Flowable.fromPublisher(p).observeOn(scheduler);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java, + R r = ObjectHelper.requireNonNull(combiner.apply(a), "The combiner returned a null value");, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableInternalHelper.java, +import io.reactivex.internal.functions.*;, +
[+++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableDelaySubscriptionTest.java, +/**, + * Copyright (c) 2016-present, RxJava Contributors., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language
[+++ b/src/main/java/io/reactivex/Observable.java, + static final int BUFFER_SIZE;, + static {, + BUFFER_SIZE = Math.max(16, Integer.getInteger("rx2.buffer-size", 128));, + public static <T> Observable<T> amb(Iterable<? extends Publisher<? extends T>> sources) {, + return create(new PublisherAmb<>(null, sources));, + public static int bufferSize() {, + return BUFFER_SIZE;, + public static <T, R> Observable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner) {, + return combineLatest(sources, combiner, false, bufferSize());, +, + public static <T, R> Observable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner, boolean delayError) {, + return combineLatest(sources, combiner, delayError, bufferSize());, + }, +, + public static
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java, +import java.util.concurrent.atomic.*;, +import io.reactivex.internal.functions.ObjectHelper;, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + serial.onSubscribe(wlf);, +, + final AtomicLong requested = new AtomicLong();, +, + SubscriptionHelper.deferredSetOnce(this.s, requested, s);, + r = ObjectHelper.requireNonNull(combiner.apply(t, u), "The combiner returned a null value");, + SubscriptionHelper.deferredRequest(s, requested, n);, + SubscriptionHelper.cancel(s);, + SubscriptionHelper.cancel(s);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java, +import java.util.concurrent.atomic.*;, +import io.reactivex.internal.functions.ObjectHelper;, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + serial.onSubscribe(wlf);, +, + final AtomicLong requested = new AtomicLong();, +, + SubscriptionHelper.deferredSetOnce(this.s, requested, s);, + r = ObjectHelper.requireNonNull(combiner.apply(t, u), "The combiner returned a null value");, + SubscriptionHelper.deferredRequest(s, requested, n);, + SubscriptionHelper.cancel(s);, + SubscriptionHelper.cancel(s);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableWithLatestFrom.java, +import io.reactivex.internal.functions.ObjectHelper;, + serial.onSubscribe(wlf);, + r = ObjectHelper.requireNonNull(combiner.apply(t, u), "The combiner returned a
[+++ b/src/main/java/io/reactivex/internal/observers/BlockingBaseObserver.java, +import io.reactivex.internal.util.*;, + BlockingHelper.verifyNonBlocking();, +++ b/src/main/java/io/reactivex/internal/observers/BlockingBaseObserver.java, +import io.reactivex.internal.util.*;, + BlockingHelper.verifyNonBlocking();, +++ b/src/main/java/io/reactivex/internal/observers/BlockingMultiObserver.java, +import io.reactivex.internal.util.*;, + BlockingHelper.verifyNonBlocking();, + BlockingHelper.verifyNonBlocking();, + BlockingHelper.verifyNonBlocking();, + BlockingHelper.verifyNonBlocking();, + BlockingHelper.verifyNonBlocking();, +++ b/src/main/java/io/reactivex/internal/observers/BlockingBaseObserver.java, +import io.reactivex.internal.util.*;, + BlockingHelper.verifyNonBlocking();, +++ b/src/main/java/io/reactivex/internal/observers/BlockingMultiObserver.java, +import io.reactivex.internal.util.*;, + BlockingHelper.verifyNonBlocking();, + BlockingHelper.verifyNonBlocking();, + BlockingHelper.verifyNonBlocking();, + BlockingHelper.verifyNonBlocking();, + BlockingHelper.verifyNonBlocking();, +++ b/src/main/java/io/reactivex/internal/observers/FutureObserver.java, +import io.reactivex.internal.util.BlockingHelper;, + BlockingHelper.verifyNonBlocking();, + BlockingHelper.verifyNonBlocking();, +++ b/src/main/java/io/reactivex/internal/observers/BlockingBaseObserver.java, +import io.reactivex.internal.util.*;, + BlockingHelper.verifyNonBlocking();, +++ b/src/main/java/io/reactivex/internal/observers/BlockingMultiObserver.java, +import io.reactivex.internal.util.*;, + BlockingHelper.verifyNonBlocking();, + BlockingHelper.verifyNonBlocking();, + BlockingHelper.verifyNonBlocking();, + BlockingHelper.verifyNonBlocking();, + BlockingHelper.verifyNonBlocking();, +++ b/src/main/java/io/reactivex/internal/observers/FutureObserver.java, +import io.reactivex.internal.util.BlockingHelper;, + BlockingHelper.verifyNonBlocking();, + BlockingHelper.verifyNonBlocking();, +++ b/src/main/java/io/reactivex/internal/observers/FutureSingleObserver.java, +import io.reactivex.internal.util.BlockingHelper;, + BlockingHelper.verifyNonBlocking();, + BlockingHelper.verifyNonBlocking();, +++ b/src/main/java/io/reactivex/internal/observers/BlockingBaseObserver.java, +import io.reactivex.internal.util.*;, + BlockingHelper.verifyNonBlocking();, +++ b/src/main/java/io/reactivex/internal/observers/BlockingMultiObserver.java, +import
[+++ b/src/main/java/io/reactivex/Observable.java, + * <p>, + * <img width="640" height="412" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingFirst.o.png" alt="">, + * <p>, + * <img width="640" height="329" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingFirst.o.default.png" alt="">, + * <img width="640" height="389" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/toFuture.o.png" alt="">, + * <p>, + * <img width="640" height="270" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.0.png" alt="">, + * <img width="640" height="393" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.1.png" alt="">, + * <p>, + * <p>, + * <img width="640" height="396" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.2.png" alt="">, + * <p>, + * <img width="640" height="394" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/blockingSubscribe.o.png" alt="">, + * <img width="640" height="330" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/collectInto.o.png" alt="">, + * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnDispose.png" alt="">, + * <img width="640" height="358" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnComplete.o.png" alt="">, + * <img width="640" height="355" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnError.o.png" alt="">, + *
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorThrottleFirst;, + return lift(new OperatorThrottleFirst<T>(windowDuration, unit, Schedulers.computation()));, + return lift(new OperatorThrottleFirst<T>(skipDuration, unit, scheduler));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorThrottleFirst;, + return lift(new OperatorThrottleFirst<T>(windowDuration, unit, Schedulers.computation()));, + return lift(new OperatorThrottleFirst<T>(skipDuration, unit, scheduler));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorThrottleFirst;, + return lift(new OperatorThrottleFirst<T>(windowDuration, unit, Schedulers.computation()));, + return lift(new OperatorThrottleFirst<T>(skipDuration, unit, scheduler));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorThrottleFirst.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License
[+++ b/src/main/java/io/reactivex/CompletableOnSubscribe.java, + * @param emitter the safe emitter instance, never null, + void subscribe(@NonNull CompletableEmitter emitter) throws Exception;, +++ b/src/main/java/io/reactivex/CompletableOnSubscribe.java, + * @param emitter the safe emitter instance, never null, + void subscribe(@NonNull CompletableEmitter emitter) throws Exception;, +++ b/src/main/java/io/reactivex/FlowableOnSubscribe.java, + * @param emitter the safe emitter instance, never null, + void subscribe(@NonNull FlowableEmitter<T> emitter) throws Exception;, +++ b/src/main/java/io/reactivex/CompletableOnSubscribe.java, + * @param emitter the safe emitter instance, never null, + void subscribe(@NonNull CompletableEmitter emitter) throws Exception;, +++ b/src/main/java/io/reactivex/FlowableOnSubscribe.java, + * @param emitter the safe emitter instance, never null, + void subscribe(@NonNull FlowableEmitter<T> emitter) throws Exception;, +++ b/src/main/java/io/reactivex/MaybeOnSubscribe.java, + *
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +, + sourceSets.test.java.srcDir 'src/main/java', + sourceSets { , + tasks.build { , +++ b/CHANGES.md, +++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +, + sourceSets.test.java.srcDir 'src/main/java', + sourceSets { , + tasks.build { , +++ b/gradle.properties, +version=0.16.1-SNAPSHOT, +++ b/CHANGES.md, +++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +, + sourceSets.test.java.srcDir 'src/main/java', + sourceSets { , + tasks.build { , +++ b/gradle.properties, +version=0.16.1-SNAPSHOT, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.6-bin.zip, +++ b/CHANGES.md, +++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +, + sourceSets.test.java.srcDir 'src/main/java',
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Converts the current Flowable into a non-backpressured {@link Observable}., + * <dd>Observables don't support backpressure thus the current Flowable is consumed in an unbounded, + * @return the new Observable instance]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnErrorNext.java, +import io.reactivex.internal.functions.ObjectHelper;, + s.onSubscribe(parent);, + static final class OnErrorNextSubscriber<T>, + extends SubscriptionArbiter, + implements FlowableSubscriber<T> {, + private static final long serialVersionUID = 4063763155303814625L;, +, +, +, + long produced;, +, + setSubscription(s);, + produced++;, + actual.onNext(t);, + p = ObjectHelper.requireNonNull(nextSupplier.apply(t), "The nextSupplier returned a null Publisher");, + long mainProduced = produced;, + if (mainProduced != 0L) {, + produced(mainProduced);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnErrorNext.java, +import io.reactivex.internal.functions.ObjectHelper;, + s.onSubscribe(parent);, + static final class OnErrorNextSubscriber<T>, + extends SubscriptionArbiter, + implements FlowableSubscriber<T> {, + private static final long serialVersionUID = 4063763155303814625L;, +, +, +, + long produced;, +, + setSubscription(s);, + produced++;,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, + return OperatorTakeUntil.takeUntil(this, other);, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return OperatorTakeUntil.takeUntil(this, other);, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return OperatorTakeUntil.takeUntil(this, other);, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorTakeUntil.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is
[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +/**, + * Copyright 2013 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for
[+++ b/gradle.properties, +version=0.9.0]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupJoin.java, + parent.innerCloseError(t);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupJoin.java, + parent.innerCloseError(t);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableInterval.java, + BackpressureHelper.produced(this, 1);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupJoin.java, + parent.innerCloseError(t);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableInterval.java, + BackpressureHelper.produced(this, 1);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableJoin.java, + JoinSubscription<TLeft, TRight, TLeftEnd, TRightEnd, R> parent =, + new JoinSubscription<TLeft, TRight, TLeftEnd, TRightEnd, R>(s, leftEnd, rightEnd, resultSelector);, + static final class JoinSubscription<TLeft, TRight, TLeftEnd, TRightEnd, R>, + JoinSubscription(Subscriber<? super R> actual, Function<? super TLeft, ? extends Publisher<TLeftEnd>> leftEnd,, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupJoin.java, + parent.innerCloseError(t);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableInterval.java, + BackpressureHelper.produced(this, 1);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableJoin.java, + JoinSubscription<TLeft, TRight, TLeftEnd, TRightEnd, R> parent =, + new JoinSubscription<TLeft, TRight, TLeftEnd, TRightEnd, R>(s, leftEnd, rightEnd, resultSelector);, + static final class JoinSubscription<TLeft, TRight, TLeftEnd,
[+++ b/gradlew, +JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.7.0_40.jdk/Contents/Home", +, +++ b/gradlew, +JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.7.0_40.jdk/Contents/Home", +, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/gradlew, +JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.7.0_40.jdk/Contents/Home", +, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +RxScala Release Notes, +=====================, +, +This release of the RxScala bindings builds on the previous 0.15 release to make the Rx bindings for Scala, +include all Rx types. In particular this release focuses on the `Subject` and `Scheduler` types., +To makes these notes self-contained, we will start with the `Observer[T]` and `Observable[T]` traits, +that lay at the heart of Rx., +, +Observer, +--------, +, +In this release we have made the `asJavaObserver` property
[+++ b/src/main/java/io/reactivex/Observable.java, + * <img width="640" height="235" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.ne.png" alt="">, + * <img width="640" height="325" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.n.png" alt="">, + * <img width="640" height="269" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.nfe.png" alt="">, + * <img width="640" height="248" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retry.o.e.png" alt="">, + * <img width="640" height="261" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/retryUntil.o.png" alt="">, + * <dl>, + * <img width="640" height="510" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/publishRefCount.o.png" alt="">, + * <img width="640" height="531" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapSingle.o.png" alt="">, + * <img width="640" height="467" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapSingleDelayError.o.png" alt="">]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Returns a Maybe that applies a specified accumulator function to the first item emitted by a source, + * @return a Maybe that emits a single item that is the result of accumulating the items emitted by, + public final Maybe<T> reduce(BiFunction<T, T, T> reducer) {, + return RxJavaPlugins.onAssembly(new FlowableReduceMaybe<T>(this, reducer));, +++ b/src/main/java/io/reactivex/Flowable.java, + * Returns a Maybe that applies a specified accumulator function to the first item emitted by a source, + * @return a Maybe that emits a single item that is the result of accumulating the items emitted by, + public final
[+++ b/gradle.properties, +version=0.6.2-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/internal/schedulers/ComputationScheduler.java, + private static final String THREAD_NAME_PREFIX = "RxComputationThreadPool";, + SHUTDOWN_WORKER = new PoolWorker(new RxThreadFactory("RxComputationShutdown"));, +++ b/src/main/java/io/reactivex/internal/schedulers/ComputationScheduler.java, + private static final String THREAD_NAME_PREFIX = "RxComputationThreadPool";, + SHUTDOWN_WORKER = new PoolWorker(new RxThreadFactory("RxComputationShutdown"));, +++ b/src/main/java/io/reactivex/internal/schedulers/IoScheduler.java, + private static final String WORKER_THREAD_NAME_PREFIX = "RxCachedThreadScheduler";, + private static final String EVICTOR_THREAD_NAME_PREFIX = "RxCachedWorkerPoolEvictor";, + SHUTDOWN_THREADWORKER = new ThreadWorker(new RxThreadFactory("RxCachedThreadSchedulerShutdown"));, +++ b/src/main/java/io/reactivex/internal/schedulers/ComputationScheduler.java, + private static final String THREAD_NAME_PREFIX = "RxComputationThreadPool";, + SHUTDOWN_WORKER = new PoolWorker(new RxThreadFactory("RxComputationShutdown"));, +++ b/src/main/java/io/reactivex/internal/schedulers/IoScheduler.java, + private static final String WORKER_THREAD_NAME_PREFIX = "RxCachedThreadScheduler";, + private static final String EVICTOR_THREAD_NAME_PREFIX = "RxCachedWorkerPoolEvictor";, + SHUTDOWN_THREADWORKER = new ThreadWorker(new RxThreadFactory("RxCachedThreadSchedulerShutdown"));, +++ b/src/main/java/io/reactivex/internal/schedulers/NewThreadScheduler.java, +
[+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java, + int innerCompleted = 0;, + innerCompleted++;, + innerCompleted++;, + if (innerCompleted != 0) {, + while (innerCompleted-- != 0) {, + }, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java, + int innerCompleted = 0;, + innerCompleted++;, + innerCompleted++;, + if (innerCompleted != 0) {, + while (innerCompleted-- != 0) {, + }, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java, +, + @Test, + public void maxConcurrencySustained() {, + final PublishProcessor<Integer> pp1 = PublishProcessor.create();, + final PublishProcessor<Integer> pp2 = PublishProcessor.create();, + PublishProcessor<Integer> pp3 = PublishProcessor.create();, + PublishProcessor<Integer> pp4 = PublishProcessor.create();, +, + TestSubscriber<Integer> ts = Flowable.just(pp1, pp2, pp3, pp4), + .flatMap(new Function<PublishProcessor<Integer>, Flowable<Integer>>() {, + @Override, +
[+++ b/.gitignore, +/.nb-gradle/profiles/private/, +.nb-gradle-properties, +/.nb-gradle/private/, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +.nb-gradle-properties, +/.nb-gradle/private/, +++ b/CHANGES.md, +### Version 0.17.5 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.17.5%22)) ###, +, +* [Pull 1010] (https://github.com/Netflix/RxJava/pull/1010) Observable.unsafeSubscribe, +* [Pull 1015] (https://github.com/Netflix/RxJava/pull/1015) Remove Redundant protectivelyWrap Method, +* [Pull 1019] (https://github.com/Netflix/RxJava/pull/1019) Fix: retry() never unsubscribes from source until operator completes , +, +### Version 0.17.4 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.17.4%22)) ###, +, +* [Pull 990] (https://github.com/Netflix/RxJava/pull/990) Quasar Lightweight Threads/Fibers Contrib Module, +* [Pull 1012] (https://github.com/Netflix/RxJava/pull/1012) SerializedObserver: Removed window between the two synchronized blocks, +, +, +### Version 0.17.3 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.17.3%22)) ###, +, +* [Pull 991] (https://github.com/Netflix/RxJava/pull/991) JMH Benchmark Build Config, +* [Pull 993] (https://github.com/Netflix/RxJava/pull/993) JMH Perf Tests,
[+++ b/src/main/java/io/reactivex/Flowable.java, + * <strong>This method requires advanced knowledge about building operators, please consider, + * Returns a {@code Flowable} which, when subscribed to, invokes the {@link FlowableOperator#apply(Subscriber) apply(Subscriber)} method, + * of the provided {@link FlowableOperator} for each individual downstream {@link Subscriber} and allows the, + * insertion of a custom operator by accessing the downstream's {@link Subscriber} during this subscription phase, + * and providing a new {@code Subscriber}, containing the custom operator's intended business logic, that will be , + * used in the subscription process going further upstream., + * Generally, such a new {@code
[+++ b/CHANGES.md, +### Version 0.20.0-RC3 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.20.0-RC3%22)) ###, +, +Version 0.20.0-RC3 preview release fixes several bugs related to backpressure and adds `retryWhen`, `repeatWhen` for more advanced recursion use cases like retry with exponential backoff., +, +This version passed the Netflix API production canary process. Please test this against your code to help us find any issues before we release 0.20.0., +, +* [Pull 1493] (https://github.com/Netflix/RxJava/pull/1493) retryWhen/repeatWhen, +* [Pull 1494] (https://github.com/Netflix/RxJava/pull/1494) zipWith, +* [Pull 1501] (https://github.com/Netflix/RxJava/pull/1501) blocking synchronous next, +* [Pull 1498] (https://github.com/Netflix/RxJava/pull/1498) non-deterministic testUserSubscriberUsingRequestAsync, +* [Pull 1497] (https://github.com/Netflix/RxJava/pull/1497) spsc ring buffer concurrency test, +* [Pull 1496] (https://github.com/Netflix/RxJava/pull/1496) Change RxRingBuffer
[+++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java, + protected CharSequence tag;, +, + ;, +, + CharSequence tag = this.tag;, + if (tag != null) {, + b.append(", tag = "), + .append(tag);, + }, +, + b, +, + /**, + * Set the tag displayed along with an assertion failure's, + * other state information., + * @param tag the string to display (null won't print any tag), + * @return this, + * @since 2.0.7 - experimental, + */, + @SuppressWarnings("unchecked"), + @Experimental, + public final U withTag(CharSequence tag) {, + this.tag = tag;, + return (U)this;, + }, +++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java,
[+++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +, +++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.6-bin.zip, +++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.6-bin.zip, +++ b/rxjava-core/src/main/java/rx/Observable.java, + * Create an Observable which delays the events via another Observable on a per item-basis., + * <p>, + * Note: onError event is immediately propagated., + * , + * @param <U> the item delay value type (ignored), + * @param itemDelay function that returns an Observable for each source item which is, + * then
[+++ b/src/main/java/io/reactivex/Completable.java, +public abstract class Completable implements CompletableConsumable {, + static final Completable COMPLETE = create(new CompletableConsumable() {, + public void subscribe(CompletableSubscriber s) {, + static final Completable NEVER = create(new CompletableConsumable() {, + public void subscribe(CompletableSubscriber s) {, + return create(new CompletableConsumable() {, + public void subscribe(final CompletableSubscriber s) {, + return create(new CompletableConsumable() {, + public void subscribe(final CompletableSubscriber s) {, + public static Completable create(CompletableConsumable onSubscribe) {, + return create(new CompletableConsumable() {, + public void subscribe(CompletableSubscriber s) {, + return create(new CompletableConsumable() {, + public void subscribe(CompletableSubscriber s) {, + return create(new CompletableConsumable() {, + public
[+++ b/gradle.properties, +version=0.16.2-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java, + } else{, + request(1);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFrom.java, + } else{, + request(1);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFromTest.java, + PublishProcessor<Integer> source = PublishProcessor.create();, + source.onNext(1);, +, + source.onNext(2);, + source.onNext(3);, + source.onNext(4);, + source.onNext(5);, + source.onNext(6);, + source.onNext(7);, +, + @Test, + public void testSingleRequestNotForgottenWhenNoData() {, + PublishProcessor<Integer> source = PublishProcessor.create();, + PublishProcessor<Integer> other = PublishProcessor.create();, +, + Flowable<Integer> result = source.withLatestFrom(other, COMBINER);, +, + TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);, +, + result.subscribe(ts);, +, + ts.request(1);, +, + source.onNext(1);, +, + ts.assertNoValues();, +, + other.onNext(1);, +, + ts.assertNoValues();, +, + source.onNext(2);, +, + ts.assertValue((2 << 8) + 1);, + }]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationDematerialize;, +import rx.operators.OperatorDistinct;, + @SuppressWarnings("unchecked"), + return create(OperationDematerialize.dematerialize((Observable<? extends Notification<? extends T2>>) this));, + return lift(new OperatorDistinct<T, T>(Functions.<T>identity()));, + return lift(new OperatorDistinct<T, U>(keySelector));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationDematerialize;, +import rx.operators.OperatorDistinct;, + @SuppressWarnings("unchecked"), + return create(OperationDematerialize.dematerialize((Observable<? extends Notification<? extends T2>>) this));, + return lift(new OperatorDistinct<T, T>(Functions.<T>identity()));, + return lift(new OperatorDistinct<T, U>(keySelector));, +++ b/rxjava-core/src/main/java/rx/operators/OperationDematerialize.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License
[+++ b/src/main/java/io/reactivex/Completable.java, + * Returns a Completable that when this Completable emits an error, retries at most times, + * or until the predicate returns false, whichever happens first and emitting the last error., + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code retry} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + * @param times the number of times the returned Completable should retry this Completable, + * @param predicate the predicate that is called with the latest throwable and should return, + * true to indicate the returned Completable should resubscribe to
[+++ b/.gitignore, +.m2, +target/, +build/, +bin/, +, +# Scala build, +*.cache, +++ b/.gitignore, +.m2, +target/, +build/, +bin/, +, +# Scala build, +*.cache, +++ b/CHANGES.md, +# RxJava Releases #, +, +### Version 0.6.3 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.6.3%22)) ###, +, +* [Pull 224](https://github.com/Netflix/RxJava/pull/224) RxJavaObservableExecutionHook, +, +### Version 0.6.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.6.2%22)) ###, +, +* [Issue 101](https://github.com/Netflix/RxJava/issues/101) Operator: Where (alias to filter), +* [Pull 197](https://github.com/Netflix/RxJava/pull/197) TakeWhile observables do not properly complete, +* [Issue 21](https://github.com/Netflix/RxJava/issues/21) Operator: All, +* [Pull 206](https://github.com/Netflix/RxJava/pull/206) Observable.toList breaks with multiple subscribers, +* [Issue 29](https://github.com/Netflix/RxJava/issues/29) Operator: CombineLatest, +* [Issue 211](https://github.com/Netflix/RxJava/issues/211) Remove use of JSR 305 and dependency on com.google.code.findbugs, +* [Pull 212](https://github.com/Netflix/RxJava/pull/212) Operation
[+++ b/src/main/java/io/reactivex/Completable.java, + * Returns a Completable instance that subscribes to the given publisher, ignores all values and, + * @param <T> the type of the publisher, + * @param publisher the Publisher instance to subscribe to, not null, + * @throws NullPointerException if publisher is null, + public static <T> Completable fromPublisher(final Publisher<T> publisher) {, + Objects.requireNonNull(publisher, "publisher is null");, + return new CompletableFromPublisher<T>(publisher);, + return fromPublisher(toFlowable().repeat());, + return fromPublisher(toFlowable().repeat(times));, + return fromPublisher(toFlowable().repeatUntil(stop));, + return fromPublisher(toFlowable().repeatWhen(handler));, + return fromPublisher(toFlowable().retry());, + return fromPublisher(toFlowable().retry(predicate));, + return fromPublisher(toFlowable().retry(times));, + return fromPublisher(toFlowable().retry(predicate));, + return fromPublisher(toFlowable().retryWhen(handler));, +++ b/src/main/java/io/reactivex/Completable.java, + * Returns a Completable
[+++ b/src/test/java/io/reactivex/internal/functions/FunctionsTest.java, + e.setAccessible(true);, + e.setAccessible(true);]
[+++ b/src/main/java/io/reactivex/Completable.java, + * <dt><b>Error handling:</b></dt>, + * <dd>If the source signals an error, the operator wraps a checked {@link Exception}, + * into {@link RuntimeException} and throws that. Otherwise, {@code RuntimeException}s and, + * {@link Error}s are rethrown as they are.</dd>, + * <dt><b>Error handling:</b></dt>, + * <dd>If the source signals an error, the operator wraps a checked {@link Exception}, + * into {@link RuntimeException} and throws that. Otherwise, {@code RuntimeException}s and, + * {@link Error}s are rethrown as they are.</dd>, +++ b/src/main/java/io/reactivex/Completable.java, + * <dt><b>Error handling:</b></dt>, + * <dd>If the source signals an error, the operator wraps
[+++ b/src/main/java/io/reactivex/Completable.java, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, + @NonNull, +
[+++ b/src/main/java/io/reactivex/Maybe.java, + public final Completable flatMapCompletable(final Function<? super T, ? extends CompletableSource> mapper) {, +++ b/src/main/java/io/reactivex/Maybe.java, + public final Completable flatMapCompletable(final Function<? super T, ? extends CompletableSource> mapper) {, +++ b/src/main/java/io/reactivex/Single.java, + public final Completable flatMapCompletable(final Function<? super T, ? extends CompletableSource> mapper) {]
[+++ b/src/main/java/io/reactivex/CompletableEmitter.java, + * Abstraction over an RxJava {@link CompletableObserver} that allows associating, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, + * Abstraction over an RxJava {@link CompletableObserver} that allows associating, +++ b/src/main/java/io/reactivex/FlowableEmitter.java, + * Abstraction over a Reactive Streams {@link org.reactivestreams.Subscriber} that allows associating, +, +, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, + * Abstraction over an RxJava {@link CompletableObserver} that allows associating, +++ b/src/main/java/io/reactivex/FlowableEmitter.java, + * Abstraction over a Reactive Streams {@link org.reactivestreams.Subscriber} that allows associating, +, +, +++ b/src/main/java/io/reactivex/MaybeEmitter.java, + * Abstraction over an RxJava {@link MaybeObserver} that allows associating, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, + * Abstraction over an RxJava {@link CompletableObserver} that allows associating, +++ b/src/main/java/io/reactivex/FlowableEmitter.java,
[+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableScan.java, +import io.reactivex.plugins.RxJavaPlugins;, + boolean done;, +, + if (done) {, + return;, + }, + onError(e);, + if (done) {, + RxJavaPlugins.onError(t);, + return;, + }, + done = true;, + if (done) {, + return;, + }, + done = true;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableScan.java, +import io.reactivex.plugins.RxJavaPlugins;, + boolean done;, +, + if (done) {, + return;, + }, + onError(e);, + if (done) {, + RxJavaPlugins.onError(t);, + return;, + }, + done = true;, + if (done) {, + return;, + }, + done = true;, +++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableScanTest.java, +import java.util.concurrent.CopyOnWriteArrayList;, +import io.reactivex.disposables.Disposable;, +import io.reactivex.disposables.Disposables;, +import io.reactivex.plugins.RxJavaPlugins;, +
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, + * <p>, + * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/zip.png">, + * <p> {@code zip} applies this function in strict sequence, so the first item emitted by the, + * new Observable will be the result of the function applied to the first item emitted by {@code w0} and the first item emitted by {@code w1}; the second item
[+++ b/gradle.properties, +version=0.8.1]
[+++ /dev/null, +++ /dev/null, +++ b/rxjava-core/src/perf/java/rx/archive/ObservableCreatePerformance.java, +package rx.archive;, +, +import rx.Observable;, +import rx.Observable.OnSubscribe;, +import rx.Subscriber;, +import rx.archive.perf.AbstractPerformanceTester;, +import rx.archive.perf.LongSumObserver;, +import rx.functions.Action0;, +, +public class ObservableCreatePerformance extends AbstractPerformanceTester {, +, + ObservableCreatePerformance() {, + super(REPETITIONS);, + }, +, + public static void main(String args[]) {, +, + final ObservableCreatePerformance spt = new ObservableCreatePerformance();, + try {, + spt.runTest(new Action0() {, +, + @Override, + public void call() {, + spt.timeCreateAndSubscribe();, + }, + });, + } catch (Exception e) {, + e.printStackTrace();, + }, +, + }, +, + /**, + * Observable.create(f).subscribe(), + * , + * With old
[+++ b/src/main/java/io/reactivex/BackpressureStrategy.java, +++ b/src/main/java/io/reactivex/BackpressureStrategy.java, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/BackpressureStrategy.java, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, +++ b/src/main/java/io/reactivex/BackpressureStrategy.java, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, +++ b/src/main/java/io/reactivex/CompletableObserver.java, +++ b/src/main/java/io/reactivex/BackpressureStrategy.java, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, +++ b/src/main/java/io/reactivex/CompletableObserver.java, +++ b/src/main/java/io/reactivex/CompletableOnSubscribe.java, +++ b/src/main/java/io/reactivex/BackpressureStrategy.java, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, +++ b/src/main/java/io/reactivex/CompletableObserver.java, +++ b/src/main/java/io/reactivex/CompletableOnSubscribe.java, +++ b/src/main/java/io/reactivex/CompletableSource.java, +++ b/src/main/java/io/reactivex/BackpressureStrategy.java, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, +++ b/src/main/java/io/reactivex/CompletableObserver.java, +++ b/src/main/java/io/reactivex/CompletableOnSubscribe.java, +++ b/src/main/java/io/reactivex/CompletableSource.java, +++ b/src/main/java/io/reactivex/Emitter.java, +++ b/src/main/java/io/reactivex/BackpressureStrategy.java, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, +++ b/src/main/java/io/reactivex/CompletableObserver.java, +++ b/src/main/java/io/reactivex/CompletableOnSubscribe.java, +++ b/src/main/java/io/reactivex/CompletableSource.java, +++ b/src/main/java/io/reactivex/Emitter.java, +++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/BackpressureStrategy.java, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, +++ b/src/main/java/io/reactivex/CompletableObserver.java, +++ b/src/main/java/io/reactivex/CompletableOnSubscribe.java, +++ b/src/main/java/io/reactivex/CompletableSource.java, +++ b/src/main/java/io/reactivex/Emitter.java, +++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/FlowableEmitter.java, +++ b/src/main/java/io/reactivex/BackpressureStrategy.java, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, +++ b/src/main/java/io/reactivex/CompletableObserver.java, +++
[+++ b/src/main/java/io/reactivex/Completable.java, + return wrap(ObjectHelper.requireNonNull(transformer, "transformer is null").apply(this));, + return ObjectHelper.requireNonNull(converter, "converter is null").apply(this);, +++ b/src/main/java/io/reactivex/Completable.java, + return wrap(ObjectHelper.requireNonNull(transformer, "transformer is null").apply(this));, + return ObjectHelper.requireNonNull(converter, "converter is null").apply(this);, +++ b/src/main/java/io/reactivex/Flowable.java, + return fromPublisher(((FlowableTransformer<T, R>) ObjectHelper.requireNonNull(composer, "composer is null")).apply(this));, + return ObjectHelper.requireNonNull(converter, "converter is null").apply(this);, +++ b/src/main/java/io/reactivex/Completable.java, + return wrap(ObjectHelper.requireNonNull(transformer, "transformer is null").apply(this));, + return ObjectHelper.requireNonNull(converter, "converter is null").apply(this);, +++ b/src/main/java/io/reactivex/Flowable.java, + return fromPublisher(((FlowableTransformer<T, R>) ObjectHelper.requireNonNull(composer, "composer is null")).apply(this));, + return ObjectHelper.requireNonNull(converter, "converter is null").apply(this);, +++ b/src/main/java/io/reactivex/Maybe.java, + return wrap(((MaybeTransformer<T, R>) ObjectHelper.requireNonNull(transformer, "transformer is null")).apply(this));, + return ObjectHelper.requireNonNull(convert, "convert is null").apply(this);, +++ b/src/main/java/io/reactivex/Completable.java, + return wrap(ObjectHelper.requireNonNull(transformer, "transformer is null").apply(this));, +
[+++ b/src/main/java/io/reactivex/Single.java, + * <img width="640" height="307" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatEager.p.png" alt="">, + * <p>, + * <img width="640" height="319" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatEager.i.png" alt="">, + * <p>, + * <img width="640" height="454" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.create.png" alt="">, + * <p>, + * <p>, + * <img width="640" height="319" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.merge.i.png" alt="">, + * <p>, + * <img width="640" height="307" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.merge.p.png" alt="">, + * <img width="640" height="412" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.merge.oo.png" alt="">, + * <img width="640" height="414" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.merge.png" alt="">, + * <img width="640" height="366" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.merge.o3.png" alt="">, + * <img width="640" height="362" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.merge.o4.png" alt="">, + * <p>, + * <img width="640" height="465" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.equals.png" alt="">, + * <p>, + * <img width="640" height="463" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.ambWith.png"
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationFilter;, +import rx.operators.OnSubscribeFromIterable;, + return source.lift(new OperatorMerge(maxConcurrent)); // any idea how to get these generics working?!, + private final Observable<Observable<T>> nest() {, + if (count < 1) {, + throw new IllegalArgumentException("Count must be positive");, + return create(OperationFilter.filter(this, predicate));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationFilter;, +import rx.operators.OnSubscribeFromIterable;, + return source.lift(new OperatorMerge(maxConcurrent)); // any idea how to get these generics working?!, + private final Observable<Observable<T>> nest() {, + if (count < 1) {, + throw new IllegalArgumentException("Count must be positive");, + return create(OperationFilter.filter(this, predicate));, +++ b/rxjava-core/src/main/java/rx/observers/TestSubscriber.java, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationFilter;, +import rx.operators.OnSubscribeFromIterable;, + return source.lift(new OperatorMerge(maxConcurrent)); // any idea
[+++ b/src/main/java/io/reactivex/Completable.java, + public static Completable ambArray(final CompletableSource... sources) {, + return RxJavaPlugins.onAssembly(new CompletableAmbArray(sources));, + return RxJavaPlugins.onAssembly(new CompletableAmbIterable(sources));, + return RxJavaPlugins.onAssembly(CompletableEmpty.INSTANCE);, + public static Completable concatArray(CompletableSource... sources) {, + return RxJavaPlugins.onAssembly(new CompletableConcatArray(sources));, + return RxJavaPlugins.onAssembly(new CompletableConcatIterable(sources));, + return RxJavaPlugins.onAssembly(new CompletableConcat(sources, prefetch));, + return RxJavaPlugins.onAssembly(new CompletableDefer(completableSupplier));, + return RxJavaPlugins.onAssembly(new CompletableErrorSupplier(errorSupplier));, + return RxJavaPlugins.onAssembly(new CompletableError(error));, + return RxJavaPlugins.onAssembly(new CompletableFromAction(run));, + return RxJavaPlugins.onAssembly(new CompletableFromCallable(callable));, + return RxJavaPlugins.onAssembly(new CompletableFromObservable<T>(observable));, + return RxJavaPlugins.onAssembly(new CompletableFromPublisher<T>(publisher));, + return RxJavaPlugins.onAssembly(new CompletableFromSingle<T>(single));, + public static Completable mergeArray(CompletableSource... sources) {, + return RxJavaPlugins.onAssembly(new CompletableMergeArray(sources));, + return RxJavaPlugins.onAssembly(new CompletableMergeIterable(sources));, + return RxJavaPlugins.onAssembly(new CompletableMerge(sources, maxConcurrency, delayErrors));, + public static Completable mergeArrayDelayError(CompletableSource...
[+++ b/gradlew, +++ b/gradlew, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ b/gradlew, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/gradlew, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +import static rx.lang.scala.JavaConversions.toScalaObservable;, +++ b/gradlew, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +import static rx.lang.scala.JavaConversions.toScalaObservable;, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, + def mountainBikeMedals: Observable[Medal] = Observable(, + Observable(, + Observable(, + Observable(, + Observable(, + Observable(, + Observable(), +++ b/gradlew, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +import static rx.lang.scala.JavaConversions.toScalaObservable;, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, + def mountainBikeMedals: Observable[Medal] = Observable(, + Observable(, + Observable(, + Observable(,
[+++ b/gradle.properties, +version=0.1.2-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Flowable.java, + Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);, + Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);, + return subscribe(onNext, onError, Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);, + return subscribe(onNext, onError, onComplete, FlowableInternalHelper.RequestMax.INSTANCE);, +++ b/src/main/java/io/reactivex/Flowable.java, + Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);, + Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);, + return subscribe(onNext, onError, Functions.EMPTY_ACTION, FlowableInternalHelper.RequestMax.INSTANCE);, + return subscribe(onNext, onError, onComplete, FlowableInternalHelper.RequestMax.INSTANCE);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterable.java, +import java.util.*;, +import java.util.concurrent.atomic.AtomicReference;, +import java.util.concurrent.locks.*;, +import org.reactivestreams.*;, +, +import io.reactivex.disposables.Disposable;, +import io.reactivex.exceptions.MissingBackpressureException;, +import io.reactivex.internal.queue.SpscArrayQueue;, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, +import io.reactivex.internal.util.ExceptionHelper;, +, + static final class BlockingFlowableIterator<T>, + extends AtomicReference<Subscription>, + implements Subscriber<T>, Iterator<T>, Runnable, Disposable {, +, + private static final long serialVersionUID = 6695226475494099826L;, +, + final SpscArrayQueue<T> queue;, +, + final long batchSize;, +, + final
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Returns a Flowable that emits all items emitted by the source Publisher that are distinct, + * based on {@link Object#equals(Object)} comparison., + * <p>, + * It is recommended the elements' class {@code T} in the flow overrides the default {@code Object.equals()} and {@link Object#hashCode()} to provide, + * meaningful comparison between items as the default Java implementation only considers reference equivalence., + * <p>, + * By default, {@code distinct()} uses an internal {@link java.util.HashSet} per Subscriber to remember, + * previously seen items and uses {@link java.util.Set#add(Object)} returning {@code false} as the,
[+++ b/gradle.properties, +version=0.14.9-SNAPSHOT, +++ b/gradle.properties, +version=0.14.9-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +, +, + def doOnEach(observer: Observer[T]): Observable[T] = {, + Observable[T](asJava.doOnEach(observer)), + }, + , + def doOnEach(onNext: T => Unit): Observable[T] = {, + Observable[T](asJava.doOnEach(onNext)), + }, +, + def doOnEach(onNext: T => Unit, onComplete: () => Unit): Observable[T] = {, + Observable[T](asJava.doOnEach(onNext, onComplete)), + }, +, + def doOnEach(onNext: T => Unit, onError: Throwable => Unit): Observable[T] = {, + Observable[T](asJava.doOnEach(onNext, onError)), + }, +, + def doOnEach(onNext: T => Unit, onError: Throwable => Unit, onComplete: () => Unit): Observable[T] = {, + Observable[T](asJava.doOnEach(onNext, onError, onComplete)), + }, +,
[+++ b/src/main/java/io/reactivex/Observable.java, + }, +, + public final <U> Observable<U> collect(U initialValue, BiConsumer<? super U, ? super T> collector) {, + return collect(() -> initialValue, collector);, + }, +, + public final <U> Observable<U> collect(Supplier<? extends U> initialValueSupplier, BiConsumer<? super U, ? super T> collector) {, + Objects.requireNonNull(initialValueSupplier);, + Objects.requireNonNull(collector);, + return lift(new OperatorCollect<>(initialValueSupplier, collector));, + }, +, + /**, + *, + * @deprecated is this in use?, + */, + @Deprecated, + public final <K> Observable<Map<K, T>> toMap(Function<? super T, ? extends K> keySelector) {, + return collect(HashMap::new, (m, t) -> {, + K key = keySelector.apply(t);,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationOnErrorResumeNextViaFunction;, +import rx.operators.OperatorObserveOnBounded;, +import rx.operators.OperatorScan;, + return create(OperationOnErrorResumeNextViaFunction.onErrorResumeNextViaFunction(this, resumeFunction));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationOnErrorResumeNextViaFunction;, +import rx.operators.OperatorObserveOnBounded;, +import rx.operators.OperatorScan;, + return create(OperationOnErrorResumeNextViaFunction.onErrorResumeNextViaFunction(this, resumeFunction));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationOnErrorResumeNextViaFunction;, +import rx.operators.OperatorObserveOnBounded;, +import rx.operators.OperatorScan;, + return create(OperationOnErrorResumeNextViaFunction.onErrorResumeNextViaFunction(this, resumeFunction));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperationOnErrorResumeNextViaFunction.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + *
[+++ b/src/main/java/io/reactivex/subscribers/TestSubscriber.java, +import io.reactivex.annotations.Experimental;, +import io.reactivex.internal.util.ExceptionHelper;, + * Calls {@link #request(long)} and returns this., + * @param n the request amount, + * @return this, + * @since 2.0.1 - experimental, + */, + @Experimental, + public final TestSubscriber<T> requestMore(long n) {, + request(n);, + return this;, + }, +, + /**, +++ b/src/main/java/io/reactivex/subscribers/TestSubscriber.java, +import io.reactivex.annotations.Experimental;, +import io.reactivex.internal.util.ExceptionHelper;, + * Calls {@link #request(long)} and returns this., + * @param n the request amount, + * @return this, + * @since 2.0.1 - experimental, + */, + @Experimental, + public final TestSubscriber<T> requestMore(long n) {, + request(n);, + return this;,
[+++ b/CHANGES.md, +### Version 0.12.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.12.2%22)) ###, +, +* [Pull 352](https://github.com/Netflix/RxJava/pull/352) Groovy Language Adaptor: Add Func5-9 and N to the wrapper, +, +### Version 0.12.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.12.1%22)) ###, +, +* [Pull 350](https://github.com/Netflix/RxJava/pull/350) Swing module enhancements, +* [Pull 351](https://github.com/Netflix/RxJava/pull/351) Fix Observable.window static/instance bug, +, +++ b/CHANGES.md, +### Version 0.12.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.12.2%22)) ###, +, +* [Pull 352](https://github.com/Netflix/RxJava/pull/352) Groovy Language Adaptor: Add Func5-9 and N to the wrapper, +, +### Version 0.12.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.12.1%22)) ###, +, +* [Pull 350](https://github.com/Netflix/RxJava/pull/350) Swing module enhancements, +* [Pull 351](https://github.com/Netflix/RxJava/pull/351) Fix Observable.window static/instance bug, +, +++ b/gradle.properties, +version=0.12.3-SNAPSHOT, +++ b/CHANGES.md, +### Version 0.12.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.12.2%22)) ###,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorOnErrorResumeNextViaFunction;, + return create(OperatorOnErrorResumeNextViaFunction.onErrorResumeNextViaFunction(this, resumeFunction));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorOnErrorResumeNextViaFunction;, + return create(OperatorOnErrorResumeNextViaFunction.onErrorResumeNextViaFunction(this, resumeFunction));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorOnErrorResumeNextViaFunction;, + return create(OperatorOnErrorResumeNextViaFunction.onErrorResumeNextViaFunction(this, resumeFunction));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorOnErrorResumeNextViaFunction.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, +
[+++ /dev/null, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/schedulers/EventLoopsScheduler.java, +package rx.schedulers;, +, +import java.util.concurrent.ThreadFactory;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicInteger;, +, +import rx.Scheduler;, +import rx.Subscription;, +import rx.functions.Action0;, +import rx.schedulers.NewThreadScheduler.OnActionComplete;, +import rx.subscriptions.CompositeSubscription;, +import rx.subscriptions.Subscriptions;, +, +/* package */class EventLoopsScheduler extends Scheduler {, +, + private static class ComputationSchedulerPool {, + final int cores = Runtime.getRuntime().availableProcessors();, + final ThreadFactory factory = new ThreadFactory() {, + final AtomicInteger counter = new AtomicInteger();, +, + @Override, + public Thread newThread(Runnable r) {, + Thread t = new Thread(r, "RxComputationThreadPool-" + counter.incrementAndGet());, + t.setDaemon(true);, + return t;, + }, + };, +, + final EventLoopScheduler[] eventLoops;, +, + ComputationSchedulerPool()
[+++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyActionWrapper.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyActionWrapper.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyActionWrapper.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyFunctionWrapper.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyActionWrapper.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, +
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, + int m = qs.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, + int m = qs.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java, + int m = f.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, + int m = qs.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java, + int m = f.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java, + int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, + int m = qs.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableZip.java, + int m = f.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java, + int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java, +import static org.mockito.ArgumentMatchers.any;, +, + @Test, + public void noCrossBoundaryFusion() {, + for (int i =
[+++ b/src/jmh/java/io/reactivex/parallel/ParallelPerf.java, +++ b/src/jmh/java/io/reactivex/parallel/ParallelPerf.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupBy.java, +++ b/src/jmh/java/io/reactivex/parallel/ParallelPerf.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupBy.java, +++ b/src/main/java/io/reactivex/internal/queue/MpscLinkedQueue.java, +++ b/src/jmh/java/io/reactivex/parallel/ParallelPerf.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupBy.java, +++ b/src/main/java/io/reactivex/internal/queue/MpscLinkedQueue.java, +++ b/src/main/java/io/reactivex/internal/queue/SpscArrayQueue.java, +++ b/src/jmh/java/io/reactivex/parallel/ParallelPerf.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupBy.java, +++ b/src/main/java/io/reactivex/internal/queue/MpscLinkedQueue.java, +++ b/src/main/java/io/reactivex/internal/queue/SpscArrayQueue.java, +++ b/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java, +++ b/src/jmh/java/io/reactivex/parallel/ParallelPerf.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupBy.java, +++ b/src/main/java/io/reactivex/internal/queue/MpscLinkedQueue.java, +++ b/src/main/java/io/reactivex/internal/queue/SpscArrayQueue.java, +++ b/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java, +++ b/src/main/java/io/reactivex/internal/schedulers/IoScheduler.java, + * Constructs an IoScheduler with the given thread factory and starts the pool of workers., +++ b/src/jmh/java/io/reactivex/parallel/ParallelPerf.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupBy.java, +++ b/src/main/java/io/reactivex/internal/queue/MpscLinkedQueue.java, +++ b/src/main/java/io/reactivex/internal/queue/SpscArrayQueue.java, +++ b/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java, +++ b/src/main/java/io/reactivex/internal/schedulers/IoScheduler.java, + * Constructs an IoScheduler with the given thread factory and starts the pool of workers., +++ b/src/main/java/io/reactivex/internal/schedulers/SingleScheduler.java, + * Constructs a SingleScheduler with the given ThreadFactory and prepares
[+++ /dev/null]
[+++ b/CHANGES.md, +### Version 1.0.7 – Feburary 21st 2015 ([Maven Central](http://search.maven.org/#artifactdetails%7Cio.reactivex%7Crxjava%7C1.0.7%7C)) ###, +, +This release includes some bug fixes along with a new operator and performance enhancements., +, +#### Experimental Operator, +, +Note that these APIs [may still change or be removed altogether](https://github.com/ReactiveX/RxJava#experimental) since they are marked as `@Experimental`. , +, +##### withLatestFrom(Observable, Selector), +, +This allows combining all values from one `Observable` with the latest value from a second `Observable` at each `onNext`., +, +For example:, +, +```java, +Observable<Long> a = Observable.interval(1, TimeUnit.SECONDS);, +Observable<Long> b = Observable.interval(250, TimeUnit.MILLISECONDS);, +, +, +a.withLatestFrom(b, (x, y) -> new long[] { x,
[+++ b/src/main/java/io/reactivex/Completable.java, + * <p>, + * <img width="640" height="317" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concatWith.png" alt="">, + * <p>, + * <img width="640" height="343" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delay.png" alt="">, + * <p>, + * <img width="640" height="313" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delay.s.png" alt="">, + * <p>, + * <img width="640" height="253" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delay.sb.png" alt="">, + * <p>, + * <img width="640" height="304" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnComplete.png" alt="">, + * <p>, + * <img width="640" height="589" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnDispose.png" alt="">, + * <p>, + * <img width="640" height="304" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnError.png" alt="">, + * <p>, + * <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnEvent.png" alt="">, + * <p>, + * <img width="640" height="304" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.doOnSubscribe.png" alt="">, + * <p>, + * <img width="640"
[+++ b/CHANGES.md, +### Version 1.0.7 – Feburary 21st 2015 ([Maven Central](http://search.maven.org/#artifactdetails%7Cio.reactivex%7Crxjava%7C1.0.7%7C)) ###, +, +This release includes some bug fixes along with a new operator and performance enhancements., +, +#### Experimental Operator, +, +Note that these APIs [may still change or be removed altogether](https://github.com/ReactiveX/RxJava#experimental) since they are marked as `@Experimental`. , +, +##### withLatestFrom(Observable, Selector), +, +This allows combining all values from one `Observable` with the latest value from a second `Observable` at each `onNext`., +, +For example:, +, +```java, +Observable<Long> a = Observable.interval(1, TimeUnit.SECONDS);, +Observable<Long> b = Observable.interval(250, TimeUnit.MILLISECONDS);, +, +, +a.withLatestFrom(b, (x, y) -> new long[] { x,
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java, + static final class ReplaySubscriber<T>, + extends AtomicReference<Subscription>, + implements Subscriber<T>, Disposable {, + private static final long serialVersionUID = 7224554242710036740L;, + SubscriptionHelper.cancel(this);, + if (SubscriptionHelper.setOnce(this, p)) {, + Subscription p = get();, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java, + static final class ReplaySubscriber<T>, + extends AtomicReference<Subscription>, + implements Subscriber<T>, Disposable {, + private static final long serialVersionUID = 7224554242710036740L;, + SubscriptionHelper.cancel(this);, + if (SubscriptionHelper.setOnce(this, p)) {, + Subscription p = get();, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java, + static final class ReplayObserver<T>, + extends AtomicReference<Disposable>, + implements Observer<T>, Disposable {, + private static final long serialVersionUID = -533785617179540163L;, + DisposableHelper.dispose(this);, + if (DisposableHelper.setOnce(this, p))
[+++ b/gradle.properties, +version=0.20.0]
[+++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +import static rx.lang.scala.ImplicitFunctionConversions.toScalaObservable;, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +import static rx.lang.scala.ImplicitFunctionConversions.toScalaObservable;, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.Notification, +import rx.lang.scala.Observable, +import rx.lang.scala.concurrency._, + val o = Observable(1 to 18), + // this will be nicer once we have zipWithIndex, + (for ((o, i) <- Observable(1 to 18).window(5) zip Observable(0 until 4); n <- o), + yield s"Observable#$i emits $n"), + .subscribe(output(_)), + i => println(s"${i}a (on thread #${Thread.currentThread().getId})"), + i => println(s"${i}b (on thread #${Thread.currentThread().getId})"), + o.observeOn(NewThreadScheduler()).subscribe(, + i => println(s"${i}a (on thread #${Thread.currentThread().getId})"), + o.observeOn(NewThreadScheduler()).subscribe(, + i => println(s"${i}b (on thread #${Thread.currentThread().getId})"), + println(s"$x*$x is being calculated on thread ${Thread.currentThread().getId}"), + println(s"map()
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import java.util.concurrent.atomic.AtomicInteger;, +import rx.operators.OperationTake;, +import rx.operators.OperationTakeWhile;, +import rx.operators.OperationWhere;, +import rx.subscriptions.BooleanSubscription;, + this(null);, + /**, + * See https://github.com/Netflix/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls to user code from within an operator", + */, + if (observer.getClass().getPackage().getName().startsWith("rx")) {, + });, + });, + return create(OperationFilter.filter(that, predicate));, + return create(OperationWhere.where(that, predicate));, + return create(OperationDefer.defer(observableFactory));, + return create(OperationDefer.defer(new Func0<Observable<T>>() {, + return create(OperationMap.map(sequence, func));, + return create(OperationMap.mapMany(sequence, func));, + return create(OperationMaterialize.materialize(sequence));, + return create(OperationDematerialize.dematerialize(sequence));, + return create(OperationMerge.merge(source));, + return create(OperationMerge.merge(source));, + return create(OperationMerge.merge(source));, + return create(OperationConcat.concat(source));, + return create(OperatorGroupBy.groupBy(source, keySelector, elementSelector));, + return create(OperatorGroupBy.groupBy(source, keySelector));, + return create(OperationMergeDelayError.mergeDelayError(source));, +
[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, + * Note: this action will cache the latest items arriving in the specified time window., + * Note: this action will cache the latest items arriving in the specified time window., +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, + * Note: this action will cache the latest items arriving in the specified time window., + * Note: this action will cache the latest items arriving in the specified time window., +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationToObservableFuture;, + return create(OperationToObservableFuture.toObservableFuture(future));, + return create(OperationToObservableFuture.toObservableFuture(future, timeout, unit));, + return create(OperationToObservableFuture.toObservableFuture(future)).subscribeOn(scheduler);, + * Note: this action will cache the latest items arriving in the specified time window.,
[+++ b/src/main/java/io/reactivex/Maybe.java, + * @return the new Maybe instance, + * @return the new Maybe instance, + * @return the new Maybe instance, + * @return the new Maybe instance, +++ b/src/main/java/io/reactivex/Maybe.java, + * @return the new Maybe instance, + * @return the new Maybe instance, + * @return the new Maybe instance, + * @return the new Maybe instance, +++ b/src/main/java/io/reactivex/Single.java, + * Provides an API (via a cold Single) that bridges the reactive world with the callback-style world.]
[+++ b/src/main/java/io/reactivex/Single.java, + * <p>, + * <img width="640" height="467" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.fromCallable.png" alt="">, + * <p>, + * <img width="640" height="322" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.fromPublisher.png" alt="">, + * <p>, + * <img width="640" height="343" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.fromObservable.png" alt="">]
[+++ b/.travis.yml, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/src/main/java/rx/Observable.java, + * For more information see the <a href="https://github.com/ReactiveX/RxJava/wiki/Observable">RxJava wiki</a>, + * @see <a href="https://github.com/ReactiveX/RxJava/wiki/Creating-Observables#create">RxJava wiki: create</a>, + * @see <a href="https://github.com/ReactiveX/RxJava/wiki/Conditional-and-Boolean-Operators#amb">RxJava wiki: amb</a>, + * @see <a href="https://github.com/ReactiveX/RxJava/wiki/Conditional-and-Boolean-Operators#amb">RxJava wiki: amb</a>, + * @see <a href="https://github.com/ReactiveX/RxJava/wiki/Conditional-and-Boolean-Operators#amb">RxJava wiki: amb</a>, + * @see <a href="https://github.com/ReactiveX/RxJava/wiki/Conditional-and-Boolean-Operators#amb">RxJava wiki: amb</a>, + * @see <a href="https://github.com/ReactiveX/RxJava/wiki/Conditional-and-Boolean-Operators#amb">RxJava wiki: amb</a>, + * @see <a href="https://github.com/ReactiveX/RxJava/wiki/Conditional-and-Boolean-Operators#amb">RxJava wiki: amb</a>, + * @see <a href="https://github.com/ReactiveX/RxJava/wiki/Conditional-and-Boolean-Operators#amb">RxJava wiki: amb</a>, + * @see <a href="https://github.com/ReactiveX/RxJava/wiki/Conditional-and-Boolean-Operators#amb">RxJava wiki: amb</a>, + * @see <a href="https://github.com/ReactiveX/RxJava/wiki/Conditional-and-Boolean-Operators#amb">RxJava wiki: amb</a>, + * @see <a href="https://github.com/ReactiveX/RxJava/wiki/Combining-Observables#combinelatest">RxJava wiki: combineLatest</a>,
[+++ b/src/main/java/io/reactivex/Single.java, + * Returns an Observable that is based on applying a specified function to the item emitted by the source Single,]
[+++ b/gradle.properties, +version=0.20.0-RC7-SNAPSHOT]
[+++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:2.+' }, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:2.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:2.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Sat Dec 13 00:15:28 PST 2014, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-bin.zip]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java, + QueueDrainHelper.drainMaxLoop(queue, actual, false, null, this);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java, + QueueDrainHelper.drainMaxLoop(queue, actual, false, null, this);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java, + QueueDrainHelper.drainLoop(queue, actual, false, null, this);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java, + QueueDrainHelper.drainMaxLoop(queue, actual, false, null, this);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java, + QueueDrainHelper.drainLoop(queue, actual, false, null, this);, +++ b/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java, + if (disposable != null) {, + }, + if (disposable != null) {, + }, + if (disposable != null) {, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java, + QueueDrainHelper.drainMaxLoop(queue, actual, false, null, this);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBufferTimed.java, + QueueDrainHelper.drainLoop(queue, actual, false, null, this);, +++ b/src/main/java/io/reactivex/internal/util/QueueDrainHelper.java, + if (disposable != null) {, + }, + if (disposable != null) {, +
[+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMap.java, + disposed = true;, + return cancelled;, + cancelled = true;, + cancelled = true;, + cancelled = true;, + cancelled = true;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMap.java, + disposed = true;, + return cancelled;, + cancelled = true;, + cancelled = true;, + cancelled = true;, + cancelled = true;, +++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapTest.java, +import static org.junit.Assert.assertTrue;, +, +import io.reactivex.disposables.*;, +import io.reactivex.internal.functions.Functions;, +, + @SuppressWarnings("unchecked"), + @Test, + public void concatReportsDisposedOnComplete() {, + final Disposable[] disposable = { null };, +, + Observable.fromArray(Observable.just(1), Observable.just(2)), + .hide(), + .concatMap(Functions.<Observable<Integer>>identity()), + .subscribe(new Observer<Integer>() {, +, + @Override, + public void onSubscribe(Disposable d) {,
[+++ b/gradle.properties, +version=0.17.0-RC5-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableAll.java, +public final class ObservableAll<T> extends ObservableWithUpstream<T, Boolean> {, + super(source);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableAll.java, +public final class ObservableAll<T> extends ObservableWithUpstream<T, Boolean> {, + super(source);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableAny.java, +public final class ObservableAny<T> extends ObservableWithUpstream<T, Boolean> {, + super(source);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableAll.java, +public final class ObservableAll<T> extends ObservableWithUpstream<T, Boolean> {, + super(source);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableAny.java, +public final class ObservableAny<T> extends ObservableWithUpstream<T, Boolean> {, + super(source);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBuffer.java, +public final class ObservableBuffer<T, U extends Collection<? super T>> extends ObservableWithUpstream<T, U> {, + super(source);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableAll.java, +public final class ObservableAll<T> extends ObservableWithUpstream<T, Boolean> {, + super(source);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableAny.java, +public final class ObservableAny<T> extends ObservableWithUpstream<T, Boolean> {,
[+++ b/src/main/java/io/reactivex/Completable.java, + onComplete, Functions.EMPTY_RUNNABLE,, + Functions.EMPTY_RUNNABLE, Functions.EMPTY_RUNNABLE);, + Functions.EMPTY_RUNNABLE, Functions.EMPTY_RUNNABLE,, + Functions.EMPTY_RUNNABLE, onDispose);, + Functions.EMPTY_RUNNABLE, Functions.EMPTY_RUNNABLE,, + Functions.EMPTY_RUNNABLE, Functions.EMPTY_RUNNABLE);, + Functions.EMPTY_RUNNABLE, Functions.EMPTY_RUNNABLE,, + Functions.EMPTY_RUNNABLE, Functions.EMPTY_RUNNABLE);, + Functions.EMPTY_RUNNABLE, onTerminate,, + Functions.EMPTY_RUNNABLE, Functions.EMPTY_RUNNABLE);, + onAfterTerminate, Functions.EMPTY_RUNNABLE,, + Functions.EMPTY_RUNNABLE, Functions.EMPTY_RUNNABLE);, + Functions.EMPTY_RUNNABLE, onAfterComplete,, + Functions.EMPTY_RUNNABLE, Functions.EMPTY_RUNNABLE);, +++ b/src/main/java/io/reactivex/Completable.java, + onComplete, Functions.EMPTY_RUNNABLE,, + Functions.EMPTY_RUNNABLE, Functions.EMPTY_RUNNABLE);, + Functions.EMPTY_RUNNABLE, Functions.EMPTY_RUNNABLE,, + Functions.EMPTY_RUNNABLE, onDispose);, + Functions.EMPTY_RUNNABLE, Functions.EMPTY_RUNNABLE,, + Functions.EMPTY_RUNNABLE, Functions.EMPTY_RUNNABLE);, + Functions.EMPTY_RUNNABLE, Functions.EMPTY_RUNNABLE,, + Functions.EMPTY_RUNNABLE, Functions.EMPTY_RUNNABLE);, + Functions.EMPTY_RUNNABLE, onTerminate,, + Functions.EMPTY_RUNNABLE, Functions.EMPTY_RUNNABLE);, + onAfterTerminate, Functions.EMPTY_RUNNABLE,, + Functions.EMPTY_RUNNABLE, Functions.EMPTY_RUNNABLE);, + Functions.EMPTY_RUNNABLE, onAfterComplete,, + Functions.EMPTY_RUNNABLE, Functions.EMPTY_RUNNABLE);, +++ b/src/main/java/io/reactivex/Flowable.java, + return doOnLifecycle(Functions.emptyConsumer(), Functions.EMPTY_LONGCONSUMER, onCancel);, + return doOnEach(Functions.emptyConsumer(), Functions.emptyConsumer(),
[+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java, + if (tryEmitScalar(((Callable<? extends U>)p)) && maxConcurrency != Integer.MAX_VALUE) {, + boolean empty = false;, + empty = true;, + if (empty) {, + drain();, + break;, + }, + boolean tryEmitScalar(Callable<? extends U> value) {, + return true;, + return true;, + return true;, + return true;, + return false;, + return true;, + int nSources = 0;, + if (maxConcurrency != Integer.MAX_VALUE) {, + synchronized (this) {, + nSources = sources.size();, + }, + }, +, + if (d && (svq == null || svq.isEmpty()) && n == 0 && nSources == 0) {, +++
[+++ b/src/main/java/io/reactivex/Observable.java, + * <img width="640" height="186" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.2.png" alt="">, + * <img width="640" height="186" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.3.png" alt="">, + * <img width="640" height="186" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.4.png" alt="">, + * <img width="640" height="186" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.5.png" alt="">, + * <img width="640" height="186" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.6.png" alt="">, + * <img width="640" height="186" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.7.png" alt="">, + * <img width="640" height="186" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.8.png" alt="">, + * <img width="640" height="186" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.9.png" alt="">, + * <img width="640" height="186" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.10.png" alt="">, + * <img width="640" height="370" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchOnNextDelayError.png" alt="">, + * <img width="640" height="370" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchOnNextDelayError.png" alt="">]
[+++ b/gradle.properties, +version=0.7.0]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublishMulticast.java, + long emitted;, +, + int n = current.length;, + if (n == 0) {, + long e = emitted;, + } else {, + n--;, + if (n == 0) {, + r = e;, + }, +, + emitted = e;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublishMulticast.java, + long emitted;, +, + int n = current.length;, + if (n == 0) {, + long e = emitted;, + } else {, + n--;, + if (n == 0) {, + r = e;, + }, +, + emitted = e;, +++ b/src/main/java/io/reactivex/processors/UnicastProcessor.java, +
[+++ b/gradle.properties, +version=0.17.0-SNAPSHOT]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ /dev/null, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ /dev/null, +++ /dev/null, +++ b/rxjava-core/src/test/java/rx/operators/OperationReduceTest.java, +/**, + * Copyright 2013 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS
[+++ b/src/main/java/io/reactivex/disposables/FutureDisposable.java, +import java.util.concurrent.atomic.AtomicReference;, +final class FutureDisposable extends AtomicReference<Future<?>> implements Disposable {, + public boolean isDisposed() {, + Future<?> f = get();, + return f == null || f.isDone();, + }, +, + @Override, + public void dispose() {, + Future<?> f = getAndSet(null);, + if (f != null) {, + f.cancel(allowInterrupt);, + }, +++ b/src/main/java/io/reactivex/disposables/FutureDisposable.java, +import java.util.concurrent.atomic.AtomicReference;, +final class FutureDisposable extends AtomicReference<Future<?>> implements Disposable {, + public boolean isDisposed() {, + Future<?> f = get();, + return f == null || f.isDone();, + }, +, + @Override, + public void dispose() {, + Future<?> f = getAndSet(null);, +
[+++ b/src/main/java/io/reactivex/internal/operators/parallel/ParallelFromPublisher.java, + int m = subscribers.length;, + this.requests = new AtomicLongArray(m + m + 1);, + this.requests.lazySet(m + m, m);, + this.emissions = new long[m];, + Subscriber<? super T>[] subs = subscribers;, + final int m = subs.length;, + subs[i].onSubscribe(new RailSubscription(i, m));, + }, + }, +, + final class RailSubscription implements Subscription {, +, + final int j;, +, + final int m;, +, + RailSubscription(int j, int m) {, + this.j = j;, + this.m = m;, + }, +, + if (requests.compareAndSet(m + j, 0L, 1L)) {, + ParallelDispatcher.this.cancel(m + m);, + void cancel(int m)
[+++ b/src/main/java/io/reactivex/Observable.java, +import io.reactivex.plugins.RxJavaPlugins;, +import io.reactivex.subscribers.SafeSubscriber;, + onSubscribe = RxJavaPlugins.onCreate(onSubscribe);, + private void subscribeActual(Subscriber<? super T> s) {, + s = RxJavaPlugins.onSubscribe(s);, + , + // TODO throw if fatal?, + RxJavaPlugins.onError(e);, + }, + }, + , + // TODO decide if safe subscription or unsafe should be the default, + @Override, + public final void subscribe(Subscriber<? super T> s) {, + subscribeActual(s);, + }, + , + // TODO decide if safe subscription or unsafe should be the default, + public final void unsafeSubscribe(Subscriber<? super T> s) {, + subscribeActual(s);, + }, + , + // TODO
[+++ b/src/main/java/io/reactivex/observables/ConnectableObservable.java, + * connection when all {@code Observer}s have disposed their {@code Disposable}s., + * connection when all {@code Observer}s have disposed their {@code Disposable}s., + * connection when all {@code Observer}s have disposed their {@code Disposable}s.]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * @return a Single that emits a single item that is the result of accumulating the output from the, + * Returns a Single that applies a specified accumulator function to the first item emitted by a source, + * @return a Single that emits a single item that is the result of accumulating the output from the, +++ b/src/main/java/io/reactivex/Flowable.java, + * @return a Single that emits a single item that is the result of accumulating the output from the, + * Returns a Single that applies a specified accumulator function to the first item emitted
[+++ b/gradle.properties, +version=0.14.6-SNAPSHOT]
[+++ b/gradle.properties, +version=0.8.2]
[+++ b/build.gradle, +++ b/build.gradle, +++ b/gradle.properties, +version=0.18.4-SNAPSHOT, +++ b/build.gradle, +++ b/gradle.properties, +version=0.18.4-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorGroupBy.java, + public Subscriber<? super T> call(final Subscriber<? super GroupedObservable<K, T>> childObserver) {, + return new GroupBySubscriber<K, T>(keySelector, childObserver);, + final Subscriber<? super GroupedObservable<K, T>> childObserver;, + public GroupBySubscriber(Func1<? super T, ? extends K> keySelector, Subscriber<? super GroupedObservable<K, T>> childObserver) {, + this.childObserver = childObserver;, + childObserver.onCompleted();, + childObserver.onError(e);, + BufferUntilSubscriber<T> gps = groups.get(key);, + if (gps == null) {, + if (childObserver.isUnsubscribed()) {, + gps = BufferUntilSubscriber.create();, + final BufferUntilSubscriber<T> _gps = gps;, + _gps.unsafeSubscribe(new Subscriber<T>(o) {, + groups.put(key, gps);, + childObserver.onNext(go);, + gps.onNext(t);, +
[+++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/test/java/io/reactivex/flowable/FlowableNullTests.java, +++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/test/java/io/reactivex/flowable/FlowableNullTests.java, +++ b/src/test/java/io/reactivex/flowable/FlowableTests.java, + @Test, + observable.filter(IS_EVEN).take(1).subscribe(w);, + observable.filter(IS_EVEN).take(1).subscribe(w);, +++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/test/java/io/reactivex/flowable/FlowableNullTests.java, +++ b/src/test/java/io/reactivex/flowable/FlowableTests.java, + @Test, + observable.filter(IS_EVEN).take(1).subscribe(w);, + observable.filter(IS_EVEN).take(1).subscribe(w);, +++ b/src/test/java/io/reactivex/observable/ObservableNullTests.java, +++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/test/java/io/reactivex/flowable/FlowableNullTests.java, +++ b/src/test/java/io/reactivex/flowable/FlowableTests.java, + @Test, + observable.filter(IS_EVEN).take(1).subscribe(w);, + observable.filter(IS_EVEN).take(1).subscribe(w);, +++ b/src/test/java/io/reactivex/observable/ObservableNullTests.java, +++ b/src/test/java/io/reactivex/observable/ObservableTest.java, + o.filter(IS_EVEN).take(1).subscribe(w);, + o.filter(IS_EVEN).take(1).subscribe(w);]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorTimeout;, +import rx.operators.OperatorTimeoutWithSelector;, + public final <U, V> Observable<T> timeout(Func0<? extends Observable<U>> firstTimeoutSelector, Func1<? super T, ? extends Observable<V>> timeoutSelector) {, + return timeout(firstTimeoutSelector, timeoutSelector, null);, + public final <U, V> Observable<T> timeout(Func0<? extends Observable<U>> firstTimeoutSelector, Func1<? super T, ? extends Observable<V>> timeoutSelector, Observable<? extends T> other) {, + if(timeoutSelector == null) {, + throw new NullPointerException("timeoutSelector is null");, + return lift(new OperatorTimeoutWithSelector<T, U, V>(firstTimeoutSelector, timeoutSelector, other));, + public final <V> Observable<T> timeout(Func1<? super T, ? extends Observable<V>> timeoutSelector) {, + return timeout(null, timeoutSelector, null);, + public final <V> Observable<T> timeout(Func1<? super T, ? extends Observable<V>>
[+++ b/.travis.yml, + - secure: YcLpYfNc/dyDON+oDvnJK5pFNhpPeJHxlAHV8JBt42e51prAl6njqrg1Qlfdp0pvBiskTPQHUxbFy9DOB1Z+43lPj5vlqz6qBgtS3vtBnsrczr+5Xx7NTdVKq6oZGl45VjfNPT7zdM6GQ5ifdzOid6kJIFu34g9JZkCzOY3BWGM=, + - secure: WVmfSeW1UMNdem7+X4cVDjkEkqdeNavYH4udn3bFN1IFaWdliWFp4FYVBVi+p1T/IgkRSqzoW9Bm43DABe1UMFoErFCbfd7B0Ofgb4NZAsxFgokHGVLCe6k5+rQyASseiO7k0itSj3Kq9TrDueKPhv+g+IG0w1A8yZTnXdhXHvY=, + - secure: Xt8E09nmSr+5r7ly95hG/EiBitZbhFGPRGp8oqPkNn1A2fzG9+hnvlNLgQhVPsISZGzJwkWa3LGBxAVGmuysVOz7eCwkoqlDZaaSLYAPfWXqkr+cmYGPkErgHSp+n/hnQG4TylX0YxzqX8flr6db21zWyNduiyHmo+xFydI5LeM=, + - secure: RmpIsmYa5BdLLWR6DILjhEE/dx2q3O0NIkvnMx5G1cyRCNCrOf1B7fYFHnsTDwpvRA+6H6dZinmeyf6D3G+czOG5q/TW2jcu5nh+YOLhBb6jPIqRDfq/WHAa5Lkdssxs5g9RdWlEDVFMoE62lGc4cnfJz5F5puH29dy2SvXxIQw=]
[+++ b/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/Async.java, + * Copyright 2014 Netflix, Inc., +import rx.util.async.operators.OperatorDeferFuture;, +import rx.util.async.operators.OperatorForEachFuture;, +import rx.util.async.operators.OperatorFromFunctionals;, +import rx.util.async.operators.OperatorStartFuture;, + return OperatorStartFuture.startFuture(functionAsync);, + return OperatorStartFuture.startFuture(functionAsync, scheduler);, + return OperatorDeferFuture.deferFuture(observableFactoryAsync);, + return OperatorDeferFuture.deferFuture(observableFactoryAsync, scheduler);, + * @see #forEachFuture(rx.Observable, rx.functions.Action1, rx.Scheduler), + return OperatorForEachFuture.forEachFuture(source, onNext);, + * @see #forEachFuture(rx.Observable, rx.functions.Action1, rx.functions.Action1, rx.Scheduler), + return OperatorForEachFuture.forEachFuture(source, onNext, onError);, + * @see #forEachFuture(rx.Observable, rx.functions.Action1, rx.functions.Action1, rx.functions.Action0, rx.Scheduler), + return OperatorForEachFuture.forEachFuture(source, onNext, onError, onCompleted);, + FutureTask<Void> task = OperatorForEachFuture.forEachFuture(source, onNext);, + FutureTask<Void> task = OperatorForEachFuture.forEachFuture(source, onNext, onError);, + FutureTask<Void> task = OperatorForEachFuture.forEachFuture(source, onNext, onError, onCompleted);, + return Observable.create(OperatorFromFunctionals.fromAction(action, result)).subscribeOn(scheduler);, + return Observable.create(OperatorFromFunctionals.fromCallable(callable)).subscribeOn(scheduler);, + return Observable.create(OperatorFromFunctionals.fromRunnable(run, result)).subscribeOn(scheduler);, +++
[+++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/Flowable.java, + * <!-- <p> -->, + * <!-- <p> -->, + * <!-- <p> -->, + * <!-- <p> -->, + * <!-- <p> -->, + * <!-- <p> -->, + * <!-- <p> -->, + * to signal the overflow to the producer.</li>, + * <p>, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/Flowable.java, + * <!-- <p> -->, + * <!-- <p> -->, + * <!-- <p> -->, + * <!-- <p> -->, + * <!-- <p> -->, + * <!-- <p> -->, + * <!-- <p> -->, + * to signal the overflow to
[+++ b/src/main/java/io/reactivex/Observable.java, + , + public final Observable<T> switchIfEmpty(Publisher<? extends T> other) {, + return lift(new OperatorSwitchIfEmpty<>(other));, + }, + , + public final Observable<T> defaultIfEmpty(T value) {, + return switchIfEmpty(just(value));, + }, +++ b/src/main/java/io/reactivex/Observable.java, + , + public final Observable<T> switchIfEmpty(Publisher<? extends T> other) {, + return lift(new OperatorSwitchIfEmpty<>(other));, + }, + , + public final Observable<T> defaultIfEmpty(T value) {, + return switchIfEmpty(just(value));, + }, +++ b/src/main/java/io/reactivex/internal/operators/OperatorSwitchIfEmpty.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + *
[+++ b/.gitignore, +++ b/.gitignore, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/src/main/java/io/reactivex/exceptions/OnErrorNotImplementedException.java, + this("The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | " + (e != null ? e.getMessage() : ""), e);, +++ b/src/main/java/io/reactivex/exceptions/OnErrorNotImplementedException.java, + this("The exception was not handled due to missing onError handler in the subscribe() method call. Further reading: https://github.com/ReactiveX/RxJava/wiki/Error-Handling | " + (e != null ? e.getMessage() : ""), e);, +++ b/src/main/java/io/reactivex/exceptions/UndeliverableException.java, + super("The exception could not be delivered to the consumer because it has already canceled/disposed the flow or the exception has nowhere to go to begin with. Further reading: https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling | " +
[+++ b/src/main/java/io/reactivex/Flowable.java, + @BackpressureSupport(BackpressureKind.UNBOUNDED_IN)]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationMulticast;, + return OperationMulticast.multicast(source, subject);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationMulticast;, + return OperationMulticast.multicast(source, subject);, +++ b/rxjava-core/src/main/java/rx/operators/OperationMulticast.java, +/**, + * Copyright 2013 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT
[+++ b/.travis.yml, +++ b/.travis.yml, +++ b/build.gradle, +# support for snapshot/final releases with the various branches RxJava uses, +# the snapshot versioning should increment the path number, +release.scope=patch, +, +++ b/.travis.yml, +++ b/build.gradle, +# support for snapshot/final releases with the various branches RxJava uses, +# the snapshot versioning should increment the path number, +release.scope=patch, +, +++ b/gradle/buildViaTravis.sh, +if [ "$TRAVIS_PULL_REQUEST" == "true" ]; then, + echo -e 'Build Pull Request => Branch ['$TRAVIS_BRANCH']', +elif [ "$TRAVIS_PULL_REQUEST" == "false" ] && [ "$TRAVIS_TAG" == "" ]; then, + echo -e 'Build Branch with Snapshot => Branch ['$TRAVIS_BRANCH']', + ./gradlew -PbintrayUser="${bintrayUser}" -PbintrayKey="${bintrayKey}"
[+++ b/gradle.properties, +version=0.13.5-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java, +import io.reactivex.internal.functions.ObjectHelper;, + coll = ObjectHelper.requireNonNull(collectionSupplier.call(), "The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java, +import io.reactivex.internal.functions.ObjectHelper;, + coll = ObjectHelper.requireNonNull(collectionSupplier.call(), "The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableToListSingle.java, +import io.reactivex.internal.functions.ObjectHelper;, + coll = ObjectHelper.requireNonNull(collectionSupplier.call(), "The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java, +import io.reactivex.internal.functions.ObjectHelper;, + coll = ObjectHelper.requireNonNull(collectionSupplier.call(), "The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and
[+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java, +import rx.operators.OperationObserveFromAndroidComponent;, + return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, activity);, + return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (android.support.v4.app.Fragment) fragment);, + return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (Fragment) fragment);, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java, +import rx.operators.OperationObserveFromAndroidComponent;, + return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, activity);, + return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (android.support.v4.app.Fragment) fragment);, + return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (Fragment) fragment);, +++ /dev/null, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java, +import rx.operators.OperationObserveFromAndroidComponent;, + return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, activity);, + return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (android.support.v4.app.Fragment) fragment);, + return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (Fragment) fragment);, +++ /dev/null, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperationObserveFromAndroidComponent.java, +/**, + * Copyright 2013 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain
[+++ b/src/main/java/io/reactivex/Flowable.java, + @Deprecated // prefetch is unnecessary when the sources is synchronously available, + return concatArray(sources);, + * @return the new Observable instance, + return new FlowableConcatArray<T>(sources, false);, + }, +, + /**, + * Concatenates a variable number of Observable sources and delays errors from any of them, + * till all terminate., + * @param sources the array of sources, + * @param <T> the common base value type, + * @return the new Flowable instance, + * @throws NullPointerException if sources is null, + */, + @BackpressureSupport(BackpressureKind.FULL), + @SchedulerSupport(SchedulerSupport.NONE), + public static <T> Flowable<T> concatArrayDelayError(Publisher<?
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Returns a new {@link Publisher} that multicasts (and shares a single subscription to) the original {@link Publisher}. As long as, + * This is an alias for {@link #publish()}.{@link ConnectableFlowable#refCount() refCount()}., +++ b/src/main/java/io/reactivex/Flowable.java, + * Returns a new {@link Publisher} that multicasts (and shares a single subscription to) the original {@link Publisher}. As long as, + * This is an alias for {@link #publish()}.{@link ConnectableFlowable#refCount() refCount()}., +++ b/src/main/java/io/reactivex/Observable.java, + * Returns a new {@link ObservableSource} that multicasts (and shares a single subscription to) the original {@link ObservableSource}. As long as, + * This is an
[+++ b/gradle.properties, +version=0.19.3-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Maps each element of the upstream Flowable into MaybeSources, subscribes to all of them, + * and merges their onSuccess values, in no particular order, into a single Flowable sequence., + * Maps each element of the upstream Flowable into MaybeSources, subscribes to at most, + * {@code maxConcurrency} MaybeSources at a time and merges their onSuccess values,, + * in no particular order, into a single Flowable sequence, optionally delaying all errors., + * Maps each element of the upstream Flowable into SingleSources, subscribes to all of them, + * and merges their onSuccess
[+++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java, + static volatile Function<Scheduler, Scheduler> onInitNewThreadHandler;, + , + static volatile Function<Scheduler, Scheduler> onNewThreadHandler;, +, + public static Function<Scheduler, Scheduler> getInitNewThreadSchedulerHandler() {, + return onInitNewThreadHandler;, + }, +, + public static Function<Scheduler, Scheduler> getNewThreadSchedulerHandler() {, + return onNewThreadHandler;, + }, +, + public static Scheduler initNewThreadScheduler(Scheduler defaultScheduler) {, + Function<Scheduler, Scheduler> f = onInitNewThreadHandler;, + if (f == null) {, + return defaultScheduler;, + }, + return f.apply(defaultScheduler);, + }, +, + public static Scheduler onNewThreadScheduler(Scheduler defaultScheduler) {, + Function<Scheduler, Scheduler> f = onNewThreadHandler;, + if (f == null) {, + return defaultScheduler;, + }, + return
[+++ b/src/main/java/io/reactivex/Flowable.java, + * <p>, + * The delivery of the item happens on the thread of the first {@code onNext} or {@code onComplete}, + * signal of the generated {@code Publisher} sequence,, + * which if takes too long, a newer item may arrive from the upstream, causing the, + * generated sequence to get cancelled, which may also interrupt any downstream blocking operation, + * (yielding an {@code InterruptedException}). It is recommended processing items, + * that may take long time to be moved to another thread via {@link #observeOn} applied after, + * {@code debounce} itself.,
[+++ b/gradle.properties, +version=0.17.0-RC1-SNAPSHOT, +++ b/gradle.properties, +version=0.17.0-RC1-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, + @Test def timeoutExample(): Unit = {, + val other = List(100L, 200L, 300L).toObservable, + val result = Observable.interval(100 millis).timeout(50 millis, other).toBlockingObservable.toList, + println(result), + }, +, + @Test def timeoutExample2(): Unit = {, + val firstTimeoutSelector = () => {, + Observable.timer(10 seconds, 10 seconds, ComputationScheduler()).take(1), + }, + val timeoutSelector = (t: Long) => {, + Observable.timer(, + (500 - t * 100) max 1 millis,, + (500 - t * 100) max 1 millis,, + ComputationScheduler()).take(1), + }, + val other = List(100L, 200L, 300L).toObservable, + val result
[+++ b/src/main/java/io/reactivex/Completable.java, + BlockingMultiObserver<Void> observer = new BlockingMultiObserver<Void>();, + BlockingMultiObserver<Void> observer = new BlockingMultiObserver<Void>();, + BlockingMultiObserver<Void> observer = new BlockingMultiObserver<Void>();, + BlockingMultiObserver<Void> observer = new BlockingMultiObserver<Void>();, +++ b/src/main/java/io/reactivex/Completable.java, + BlockingMultiObserver<Void> observer = new BlockingMultiObserver<Void>();, + BlockingMultiObserver<Void> observer = new BlockingMultiObserver<Void>();, + BlockingMultiObserver<Void> observer = new BlockingMultiObserver<Void>();, + BlockingMultiObserver<Void> observer = new BlockingMultiObserver<Void>();, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.subscribers.*;, +++ b/src/main/java/io/reactivex/Completable.java, + BlockingMultiObserver<Void> observer = new BlockingMultiObserver<Void>();, + BlockingMultiObserver<Void> observer = new BlockingMultiObserver<Void>();, + BlockingMultiObserver<Void> observer = new BlockingMultiObserver<Void>();, + BlockingMultiObserver<Void> observer = new BlockingMultiObserver<Void>();, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.subscribers.*;, +++ b/src/main/java/io/reactivex/Maybe.java, +import io.reactivex.internal.observers.BlockingMultiObserver;, + BlockingMultiObserver<T> observer = new BlockingMultiObserver<T>();, + BlockingMultiObserver<T> observer
[+++ b/gradlew, +JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.7.0_40.jdk/Contents/Home", +, +++ b/gradlew, +JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.7.0_40.jdk/Contents/Home", +, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, + o.observeOn(NewThreadScheduler()).subscribe(, + o.observeOn(NewThreadScheduler()).subscribe(, +++ b/gradlew, +JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.7.0_40.jdk/Contents/Home", +, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, + o.observeOn(NewThreadScheduler()).subscribe(, + o.observeOn(NewThreadScheduler()).subscribe(, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/ImplicitFunctionConversions.scala, +, +import rx.util.functions._, +, +// implicit def schedulerActionToFunc2[T](action: (Scheduler, T) => Subscription): Func2[rx.Scheduler, T, rx.Subscription] with Object {def call(s: rx.Scheduler, t: T): rx.Subscription} =, +// new Func2[rx.Scheduler, T, rx.Subscription] {, +// def call(s: rx.Scheduler, t: T): rx.Subscription = {, +// action(rx.lang.scala.Scheduler(s), t).asJavaSubscription, +// }, +// }, +, + action(Scheduler(s), t).asJavaSubscription, +++ b/gradlew, +JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.7.0_40.jdk/Contents/Home", +, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, + o.observeOn(NewThreadScheduler()).subscribe(, + o.observeOn(NewThreadScheduler()).subscribe(, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/ImplicitFunctionConversions.scala, +, +import rx.util.functions._, +, +//
[+++ b/src/main/java/io/reactivex/Observable.java, + validateBufferSize(bufferSize);, +++ b/src/main/java/io/reactivex/Observable.java, + validateBufferSize(bufferSize);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorOnBackpressureBuffer.java, +import io.reactivex.exceptions.MissingBackpressureException;, + MissingBackpressureException ex = new MissingBackpressureException("Buffer is full");, + return;, +++ b/src/main/java/io/reactivex/Observable.java, + validateBufferSize(bufferSize);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorOnBackpressureBuffer.java, +import io.reactivex.exceptions.MissingBackpressureException;, + MissingBackpressureException ex = new MissingBackpressureException("Buffer is full");, + return;, +++ b/src/main/java/io/reactivex/internal/operators/OperatorOnBackpressureDrop.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (SubscriptionHelper.validateSubscription(this.s, s)) {, + if (SubscriptionHelper.validateRequest(n)) {, +++ b/src/main/java/io/reactivex/Observable.java, + validateBufferSize(bufferSize);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorOnBackpressureBuffer.java, +import io.reactivex.exceptions.MissingBackpressureException;, + MissingBackpressureException ex = new MissingBackpressureException("Buffer is full");, + return;, +++ b/src/main/java/io/reactivex/internal/operators/OperatorOnBackpressureDrop.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (SubscriptionHelper.validateSubscription(this.s, s)) {, + if (SubscriptionHelper.validateRequest(n)) {, +++ b/src/main/java/io/reactivex/internal/operators/OperatorOnBackpressureLatest.java, + while (r != 0L) {, + if (empty) {, + break;, +
[+++ b/src/main/java/rx/internal/operators/OperatorMulticast.java, + final AtomicReference<Subject<? super T, ? extends R>> connectedSubject;, + final List<Subscriber<? super R>> waitingForConnect;, + private Subscriber<T> subscription;, + // wraps subscription above for unsubscription using guard, + private Subscription guardedSubscription;, + // already connected, + connection.call(guardedSubscription);, + final AtomicReference<Subscription> gs = new AtomicReference<Subscription>();, + gs.set(Subscriptions.create(new Action0() {, + @Override, + public void call() {, + Subscription s;, + synchronized (guard) {, + if ( guardedSubscription == gs.get()) {, + s = subscription;, + subscription = null;, + guardedSubscription = null;, + connectedSubject.set(null);, + } else , + return;, + }, + if (s != null)
[+++ b/src/main/java/io/reactivex/observers/TestObserver.java, + return subscription.get() != null;, + if (subscription.get() == null) {, + if (subscription.get() != null) {]
[+++ b/src/main/java/io/reactivex/Completable.java, + * that error through a Flowable and the Publisher should signal a value indicating a retry in response]
[+++ b/CHANGES.md, +### Version 0.20.0-RC3 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.20.0-RC3%22)) ###, +, +Version 0.20.0-RC3 preview release fixes several bugs related to backpressure and adds `retryWhen`, `repeatWhen` for more advanced recursion use cases like retry with exponential backoff., +, +This version passed the Netflix API production canary process. Please test this against your code to help us find any issues before we release 0.20.0., +, +* [Pull 1493] (https://github.com/Netflix/RxJava/pull/1493) retryWhen/repeatWhen, +* [Pull 1494] (https://github.com/Netflix/RxJava/pull/1494) zipWith, +* [Pull 1501] (https://github.com/Netflix/RxJava/pull/1501) blocking synchronous next, +* [Pull 1498] (https://github.com/Netflix/RxJava/pull/1498) non-deterministic testUserSubscriberUsingRequestAsync, +* [Pull 1497] (https://github.com/Netflix/RxJava/pull/1497) spsc ring buffer concurrency test, +* [Pull 1496] (https://github.com/Netflix/RxJava/pull/1496) Change RxRingBuffer
[+++ b/CHANGES.md, +### Version 0.6.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.6.1%22)) ###, +, +* [Pull 190](https://github.com/Netflix/RxJava/pull/190) Fix generics issue with materialize() that prevented chaining, +, +++ b/CHANGES.md, +### Version 0.6.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.6.1%22)) ###, +, +* [Pull 190](https://github.com/Netflix/RxJava/pull/190) Fix generics issue with materialize() that prevented chaining, +, +++ b/README.md, +## Communication, +, +- Google Group: [RxJava](http://groups.google.com/d/forum/rxjava), +- Twitter: [@RxJava](http://twitter.com/RxJava), +- [GitHub Issues](https://github.com/Netflix/RxJava/issues), +, +++ b/CHANGES.md, +### Version 0.6.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.6.1%22)) ###, +, +* [Pull 190](https://github.com/Netflix/RxJava/pull/190) Fix generics issue with materialize() that prevented chaining, +, +++ b/README.md, +## Communication, +, +- Google Group: [RxJava](http://groups.google.com/d/forum/rxjava), +- Twitter: [@RxJava](http://twitter.com/RxJava), +- [GitHub Issues](https://github.com/Netflix/RxJava/issues), +, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationConcat;,
[+++ b/.travis.yml, + - bash gradle/push_javadoc.sh, +++ b/.travis.yml, + - bash gradle/push_javadoc.sh, +++ b/gradle/push_javadoc.sh, +#!/bin/bash, +# ----------------------------------------------------------, +# Automatically push back the generated JavaDocs to gh-pages, +# ----------------------------------------------------------, +# based on https://gist.github.com/willprice/e07efd73fb7f13f917ea, +, +# specify the common address for the repository, +targetRepo=github.com/ReactiveX/RxJava.git, +# =======================================================================, +, +# only for main pushes, for now, +if [ "$TRAVIS_PULL_REQUEST" != "false" ]; then, + echo -e "Pull request detected, skipping JavaDocs pushback.", + exit 0, +fi, +, +# get the current build tag if any, +buildTag="$TRAVIS_TAG", +echo -e "Travis tag: '$buildTag'", +, +if [ "$buildTag" == "" ]; then, + buildTag="snapshot", +else, +
[+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java, +import io.reactivex.internal.queue.SpscLinkedArrayQueue;, + queue = new SpscLinkedArrayQueue<T>(prefetch);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java, +import io.reactivex.internal.queue.SpscLinkedArrayQueue;, + queue = new SpscLinkedArrayQueue<T>(prefetch);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java, +, + @Test, + @SuppressWarnings("unchecked"), + public void maxConcurrencyOf2() {, + List<Integer>[] list = new ArrayList[100];, + for (int i = 0; i < 100; i++) {, + List<Integer> lst = new ArrayList<Integer>();, + list[i] = lst;, + for (int k = 1; k <= 10; k++) {, + lst.add((i) * 10 + k);, + }, + }, +, + Flowable.range(1, 1000), + .buffer(10), + .concatMapEager(new Function<List<Integer>, Flowable<List<Integer>>>() {, + @Override, + public Flowable<List<Integer>> apply(List<Integer> v), + throws Exception
[+++ b/src/main/java/io/reactivex/processors/UnicastProcessor.java, +import io.reactivex.annotations.Experimental;, + final boolean delayError;, +, +, + * Creates an UnicastProcessor with default internal buffer capacity hint and delay error flag., + * @param <T> the value type, + * @param delayError deliver pending onNext events before onError, + * @return an UnicastProcessor instance, + * @since 2.0.8 - experimental, + */, + @CheckReturnValue, + @Experimental, + public static <T> UnicastProcessor<T> create(boolean delayError) {, + return new UnicastProcessor<T>(bufferSize(), null, delayError);, + }, +, + /**, + ObjectHelper.requireNonNull(onCancelled, "onTerminate");, + * Creates an UnicastProcessor with the given internal buffer capacity hint, delay error flag and a
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Note that due to concurrency requirements, {@code replay(bufferSize)} may hold strong references to more than, + * {@code bufferSize} source emissions., + * <p>, + * Note that due to concurrency requirements, {@code replay(bufferSize)} may hold strong references to more than, + * {@code bufferSize} source emissions., + * <p>, + * Note that due to concurrency requirements, {@code replay(bufferSize)} may hold strong references to more than, + * {@code bufferSize} source emissions., + * <p>, + * Note that due to concurrency requirements, {@code replay(bufferSize)} may hold strong references to more than, + *
[+++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/internal/observers/QueueDrainObserver.java, +import io.reactivex.internal.fuseable.*;, + protected final SimplePlainQueue<U> queue;, + public QueueDrainObserver(Observer<? super V> actual, SimplePlainQueue<U> queue) {, + final SimplePlainQueue<U> q = queue;, + final SimplePlainQueue<U> q = queue;, +++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/internal/observers/QueueDrainObserver.java, +import io.reactivex.internal.fuseable.*;, + protected final SimplePlainQueue<U> queue;, + public QueueDrainObserver(Observer<? super V> actual, SimplePlainQueue<U> queue) {, + final SimplePlainQueue<U> q = queue;, + final SimplePlainQueue<U> q = queue;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundary.java, +import io.reactivex.internal.fuseable.SimplePlainQueue;, + SimplePlainQueue<U> q = queue;, +++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/internal/observers/QueueDrainObserver.java, +import io.reactivex.internal.fuseable.*;, + protected final SimplePlainQueue<U> queue;, + public QueueDrainObserver(Observer<? super V> actual, SimplePlainQueue<U> queue) {, + final SimplePlainQueue<U> q
[+++ b/src/main/java/io/reactivex/observers/LambdaConsumerIntrospection.java, +/**, + * Copyright (c) 2016-present, RxJava Contributors., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language
[+++ b/src/main/java/io/reactivex/Observable.java, + @SchedulerSupport(SchedulerSupport.NONE)]
[+++ b/gradle.properties, +version=0.17.0-RC5-SNAPSHOT, +++ b/gradle.properties, +version=0.17.0-RC5-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, + val fourYears = 4000.millis, + val neverUsedDummyMedal = Medal(3333, "?", "?", "?", "?", "?"), + def fourYearsEmpty: Observable[Medal] = {, + // Observable.interval(fourYears).take(1).map(i => neverUsedDummyMedal).filter(m => false), + Observable.empty, + }, +++ b/gradle.properties, +version=0.17.0-RC5-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, + val fourYears = 4000.millis, + val neverUsedDummyMedal = Medal(3333, "?", "?", "?", "?", "?"), + def fourYearsEmpty: Observable[Medal] = {, + // Observable.interval(fourYears).take(1).map(i => neverUsedDummyMedal).filter(m => false), + Observable.empty, + }, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, + val b1 = (first zip second) map (p => p._1 == p._2) forall (b => b), + val equality
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Note that the {@code seed} is shared among all subscribers to the resulting Publisher, + * Single.defer(() -> source.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)));, + * Flowable.defer(() -> o.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)).toFlowable()), + * ).firstOrError();, + *, + * // or, by using reduceWith instead of reduce, + *, + * source.reduceWith(() -> new ArrayList&lt;>(), (list, item) -> list.add(item)));, + * @see #reduceWith(Callable, BiFunction), + * Publisher and a seed value derived from calling a specified seedSupplier, then feeds the result, + * of that function along with the second item emitted by
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorParallelMerge;, + return OperatorParallelMerge.parallelMerge(source, parallelObservables);, + return OperatorParallelMerge.parallelMerge(source, parallelObservables, scheduler);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorParallelMerge;, + return OperatorParallelMerge.parallelMerge(source, parallelObservables);, + return OperatorParallelMerge.parallelMerge(source, parallelObservables, scheduler);, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorParallelMerge;, + return OperatorParallelMerge.parallelMerge(source, parallelObservables);, + return OperatorParallelMerge.parallelMerge(source, parallelObservables, scheduler);, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorParallelMerge.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + *
[+++ b/src/main/java/io/reactivex/Flowable.java, + return cacheWithInitialCapacity(16);, + return RxJavaPlugins.onAssembly(new FlowableCache<T>(this, initialCapacity));, + return RxJavaPlugins.onAssembly(new FlowableConcatMap<T, R>(this, mapper, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));, + * @return the source {@code Flowable} modified to buffer items up to the given capacity, + public final Flowable<T> onBackpressureBuffer(long capacity, Action onOverflow, BackpressureOverflowStrategy overflowStrategy) {, +++ b/src/main/java/io/reactivex/Flowable.java, + return cacheWithInitialCapacity(16);, + return RxJavaPlugins.onAssembly(new FlowableCache<T>(this, initialCapacity));, + return RxJavaPlugins.onAssembly(new FlowableConcatMap<T, R>(this, mapper, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));, + * @return the source {@code Flowable} modified to buffer items up to the given capacity, + public final Flowable<T> onBackpressureBuffer(long capacity, Action onOverflow, BackpressureOverflowStrategy overflowStrategy) {, +++
[+++ b/src/main/java/io/reactivex/Maybe.java, + * Flowable.create((FlowableEmitter<? super String> s) -> {, + * }, BackpressureStrategy.BUFFER).retryWhen(attempts -> {, +++ b/src/main/java/io/reactivex/Maybe.java, + * Flowable.create((FlowableEmitter<? super String> s) -> {, + * }, BackpressureStrategy.BUFFER).retryWhen(attempts -> {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java, +import io.reactivex.internal.functions.ObjectHelper;, + v = ObjectHelper.requireNonNull(it.next(), "The iterator returned a null value");, + R r = ObjectHelper.requireNonNull(it.next(), "The iterator returned a null value");, +++ b/src/main/java/io/reactivex/Maybe.java, + * Flowable.create((FlowableEmitter<? super String> s) -> {, + * }, BackpressureStrategy.BUFFER).retryWhen(attempts -> {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java, +import io.reactivex.internal.functions.ObjectHelper;, + v = ObjectHelper.requireNonNull(it.next(), "The iterator returned a null value");, + R r = ObjectHelper.requireNonNull(it.next(), "The iterator returned a null value");, +++
[+++ b/CHANGES.md, +### Version 0.13.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.13.2%22)) ###, +, +* [Pull 389](https://github.com/Netflix/RxJava/pull/389) Scala Adaptor Improvements, +* [Pull 382](https://github.com/Netflix/RxJava/pull/382) Removing deprecated RxImplicits from rxjava-scala, +* [Pull 381](https://github.com/Netflix/RxJava/pull/381) Operator: mapWithIndex, +* [Pull 380](https://github.com/Netflix/RxJava/pull/380) Implemented `distinct` and `distinctUntilChanged` variants using a comparator, +* [Pull 379](https://github.com/Netflix/RxJava/pull/379) Make `interval` work with multiple subscribers, +, +++ b/CHANGES.md, +### Version 0.13.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.13.2%22)) ###, +, +* [Pull 389](https://github.com/Netflix/RxJava/pull/389) Scala Adaptor Improvements, +* [Pull 382](https://github.com/Netflix/RxJava/pull/382) Removing deprecated RxImplicits from rxjava-scala, +* [Pull 381](https://github.com/Netflix/RxJava/pull/381) Operator: mapWithIndex, +* [Pull 380](https://github.com/Netflix/RxJava/pull/380) Implemented `distinct` and `distinctUntilChanged` variants using a comparator, +* [Pull 379](https://github.com/Netflix/RxJava/pull/379) Make `interval` work with multiple subscribers, +, +++
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/gradle.properties, +version=0.13.0-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/gradle.properties, +version=0.13.0-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import static rx.util.functions.Functions.*;, +import rx.operators.OperationThrottleFirst;, +import rx.operators.OperationDebounce;, + * Debounces by dropping all values that are followed by newer values before the timeout value expires. The timer resets on each `onNext` call., + * <p>, + * NOTE: If events keep
[+++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.internal.operators.mixed.*;, + return RxJavaPlugins.onAssembly(new CompletableAndThenObservable<T>(this, next));, + return RxJavaPlugins.onAssembly(new CompletableAndThenPublisher<T>(this, next));, +++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.internal.operators.mixed.*;, + return RxJavaPlugins.onAssembly(new CompletableAndThenObservable<T>(this, next));, + return RxJavaPlugins.onAssembly(new CompletableAndThenPublisher<T>(this, next));, +++ b/src/main/java/io/reactivex/Maybe.java, +import io.reactivex.internal.operators.mixed.*;, + ObjectHelper.requireNonNull(mapper, "mapper is null");, + return RxJavaPlugins.onAssembly(new MaybeFlatMapObservable<T, R>(this, mapper));, + ObjectHelper.requireNonNull(mapper, "mapper is null");, + return RxJavaPlugins.onAssembly(new MaybeFlatMapPublisher<T, R>(this, mapper));, +++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.internal.operators.mixed.*;, + return RxJavaPlugins.onAssembly(new CompletableAndThenObservable<T>(this, next));, + return RxJavaPlugins.onAssembly(new CompletableAndThenPublisher<T>(this, next));, +++ b/src/main/java/io/reactivex/Maybe.java, +import io.reactivex.internal.operators.mixed.*;, + ObjectHelper.requireNonNull(mapper, "mapper is null");, + return RxJavaPlugins.onAssembly(new MaybeFlatMapObservable<T, R>(this, mapper));, + ObjectHelper.requireNonNull(mapper, "mapper is null");, + return RxJavaPlugins.onAssembly(new MaybeFlatMapPublisher<T, R>(this, mapper));, +++ b/src/main/java/io/reactivex/Single.java, +import io.reactivex.internal.operators.mixed.*;, +
[+++ b/src/main/java/io/reactivex/Observable.java, + Function<? super T, ? extends T> valueSelector = v -> v;, + Supplier<Map<K, Collection<T>>> mapSupplier = HashMap::new;, + Function<K, Collection<T>> collectionFactory = k -> new ArrayList<>();, + return toMultimap(keySelector, valueSelector, mapSupplier, collectionFactory);, + Supplier<Map<K, Collection<V>>> mapSupplier = HashMap::new;, + Function<K, Collection<V>> collectionFactory = k -> new ArrayList<>();, + return toMultimap(keySelector, valueSelector, mapSupplier, collectionFactory);, +++ b/src/main/java/io/reactivex/Observable.java, + Function<? super T, ? extends T> valueSelector = v -> v;, + Supplier<Map<K, Collection<T>>> mapSupplier = HashMap::new;, + Function<K, Collection<T>> collectionFactory = k -> new ArrayList<>();, + return toMultimap(keySelector, valueSelector, mapSupplier, collectionFactory);, + Supplier<Map<K, Collection<V>>> mapSupplier = HashMap::new;, + Function<K,
[+++ b/gradle.properties, +version=0.20.0-SNAPSHOT]
[+++ b/gradle.properties, +version=0.18.3-SNAPSHOT]
[+++ b/language-adaptors/rxjava-scala-java/README.md, +, +rxjava-scala-java, +-----------------, +, +Contains examples illustrating how RxScala code can be used from Java., +++ b/language-adaptors/rxjava-scala-java/README.md, +, +rxjava-scala-java, +-----------------, +, +Contains examples illustrating how RxScala code can be used from Java., +++ b/language-adaptors/rxjava-scala-java/build.gradle, +, +apply plugin: 'osgi', +, +, +project(':language-adaptors:rxjava-scala-java') {, + //sourceSets.test.java.srcDir 'src/examples/java', + sourceSets.main.java.srcDir 'src/main/java', +}, +, +dependencies {, + compile 'org.scala-lang:scala-library:2.10.+', +, + compile project(':rxjava-core'), + , + compile project(':language-adaptors:rxjava-scala'), + , + provided 'junit:junit-dep:4.10', + provided 'org.mockito:mockito-core:1.8.5', + provided 'org.scalatest:scalatest_2.10:1.9.1', +}, +, +jar {, + manifest {, + name = 'rxjava-scala-java', + instruction 'Bundle-Vendor', 'Netflix', + instruction 'Bundle-DocURL', 'https://github.com/Netflix/RxJava', + instruction 'Import-Package',
[+++ b/src/main/java/io/reactivex/Flowable.java, + * overloads that allow setting their internal buffer size explicitly., + Objects.requireNonNull(v8, "The eighth value is null");, + Objects.requireNonNull(v8, "The eighth value is null");, + Objects.requireNonNull(v8, "The eighth value is null");, + * (i.e., no backpressure applied to it).</dd>, + * @param <R> the type of the inner Publisher sources and thus the output type, + * @param <R> the type of the inner Publisher sources and thus the output type, + * Calls the appropriate onXXX method (shared between all Subscribers) for the lifecylcle events of, + * (i.e., no backpressure applied to it).</dd>, +
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorTimeInterval;, + return lift(new OperatorTimeInterval(Schedulers.immediate()));, + return lift(new OperatorTimeInterval(scheduler));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorTimeInterval;, + return lift(new OperatorTimeInterval(Schedulers.immediate()));, + return lift(new OperatorTimeInterval(scheduler));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorTimeInterval;, + return lift(new OperatorTimeInterval(Schedulers.immediate()));, + return lift(new OperatorTimeInterval(scheduler));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorTimeInterval.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + *
[+++ b/gradle.properties, +version=0.6.1-SNAPSHOT]
[+++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableDelayTest.java, + Completable.error(new Exception())]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Maps the upstream items into {@link CompletableSource}s and subscribes to them one after the, + * Maps the upstream items into {@link CompletableSource}s and subscribes to them one after the, + * Maps the upstream items into {@link CompletableSource}s and subscribes to them one after the, + * Maps the upstream items into {@link CompletableSource}s and subscribes to them one after the, + * Maps the upstream items into {@link CompletableSource}s and subscribes to them one after the, + * Maps the upstream items into {@link MaybeSource}s and subscribes to them one after the, +
[+++ b/src/main/java/io/reactivex/CompletableTransformer.java, + /**, + * Applies a function to the upstream Completable and returns a CompletableSource., + * @param upstream the upstream Completable instance, + * @return the transformed CompletableSource instance, + * @throws Exception in case the transformation throws, checked exceptions will be wrapped, + * into a RuntimeException, + */, + CompletableSource apply(Completable upstream) throws Exception;, +++ b/src/main/java/io/reactivex/CompletableTransformer.java, + /**, + * Applies a function to the upstream Completable and returns a CompletableSource., + * @param upstream the upstream Completable instance, + * @return the transformed CompletableSource instance, + * @throws Exception in case the transformation
[+++ b/rxjava-core/src/test/java/README.txt, +This test folder only contains performance and functional/integration style tests., +, +The unit tests themselves are embedded as inner classes of the Java code (such as here https://github.com/Netflix/RxJava/tree/master/rxjava-core/src/main/java/rx/operators)., +, +Also, each of the language adaptors has a /src/test/ folder which further testing. See Groovy for an example: https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-groovy/src/test]
[+++ b/src/main/java/io/reactivex/Observable.java, + public static <T, R> Observable<R> combineLatest(Function<? super T[], ? extends R> combiner, boolean delayError, int bufferSize, ObservableConsumable<? extends T>... sources) {, + public static <T, R> Observable<R> combineLatest(Iterable<? extends ObservableConsumable<? extends T>> sources, Function<? super T[], ? extends R> combiner) {, + public static <T, R> Observable<R> combineLatest(Iterable<? extends ObservableConsumable<? extends T>> sources, Function<? super T[], ? extends R> combiner, boolean delayError) {, + public static <T, R> Observable<R> combineLatest(Iterable<? extends ObservableConsumable<? extends T>> sources, Function<? super T[], ? extends R> combiner, boolean delayError, int bufferSize) {, + public static <T, R> Observable<R> combineLatest(ObservableConsumable<? extends T>[]
[+++ b/src/main/java/io/reactivex/AsyncEmitter.java, +package io.reactivex;, +, +import io.reactivex.disposables.Disposable;, +, +/**, + * Abstraction over a RxJava Subscriber that allows associating, + * a resource with it and exposes the current number of downstream, + * requested amount., + * <p>, + * The onNext, onError and onComplete methods should be called , + * in a sequential manner, just like the Subscriber's methods. The, + * other methods are threadsafe., + *, + * @param <T> the value type to emit, + */, +public interface AsyncEmitter<T> {, +, + /**, + * Signal a value., + * @param t the
[+++ b/rxjava-core/src/main/java/rx/Subscriber.java, +import rx.internal.util.SubscriptionList;, + private final SubscriptionList cs;, + this.cs = new SubscriptionList();, + this.cs = new SubscriptionList();, + this.cs = op.cs;, +++ b/rxjava-core/src/main/java/rx/Subscriber.java, +import rx.internal.util.SubscriptionList;, + private final SubscriptionList cs;, + this.cs = new SubscriptionList();, + this.cs = new SubscriptionList();, + this.cs = op.cs;, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorGroupBy.java, + super();, +++ b/rxjava-core/src/main/java/rx/Subscriber.java, +import rx.internal.util.SubscriptionList;, + private final SubscriptionList cs;, + this.cs = new SubscriptionList();, + this.cs = new SubscriptionList();, + this.cs = op.cs;, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorGroupBy.java, + super();, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorPivot.java, +import rx.Subscription;, + final PivotSubscriber<K1, K2, T> pivotSubscriber = new PivotSubscriber<K1, K2, T>(child, state);, + private PivotSubscriber(Subscriber<? super GroupedObservable<K2, GroupedObservable<K1,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorAsObservable;, + return lift(new OperatorAsObservable<T>());, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorAsObservable;, + return lift(new OperatorAsObservable<T>());, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorAsObservable;, + return lift(new OperatorAsObservable<T>());, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorAsObservable.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, +
[+++ b/src/jmh/java/io/reactivex/InputWithIncrementingInteger.java, + public Flowable<Integer> flowable;, + flowable = Flowable.range(0, size);, +++ b/src/jmh/java/io/reactivex/InputWithIncrementingInteger.java, + public Flowable<Integer> flowable;, + flowable = Flowable.range(0, size);, +++ b/src/jmh/java/io/reactivex/OperatorFlatMapPerf.java, + input.flowable.flatMap(new Function<Integer, Publisher<Integer>>() {, + input.flowable.flatMap(new Function<Integer, Publisher<Integer>>() {, + return input.flowable;, +++ b/src/jmh/java/io/reactivex/InputWithIncrementingInteger.java, + public Flowable<Integer> flowable;, + flowable = Flowable.range(0, size);, +++ b/src/jmh/java/io/reactivex/OperatorFlatMapPerf.java, + input.flowable.flatMap(new Function<Integer, Publisher<Integer>>() {, + input.flowable.flatMap(new Function<Integer, Publisher<Integer>>() {, + return input.flowable;, +++ b/src/jmh/java/io/reactivex/OperatorMergePerf.java, + Flowable<Flowable<Integer>> os = input.flowable.map(new Function<Integer, Flowable<Integer>>() {, + Flowable<Flowable<Integer>> os = input.flowable.map(new Function<Integer, Flowable<Integer>>() {, +++ b/src/jmh/java/io/reactivex/InputWithIncrementingInteger.java, + public Flowable<Integer> flowable;, + flowable = Flowable.range(0, size);, +++ b/src/jmh/java/io/reactivex/OperatorFlatMapPerf.java, + input.flowable.flatMap(new Function<Integer, Publisher<Integer>>() {,
[+++ b/src/main/java/io/reactivex/Completable.java, + * <dt><b>Backpressure:</b><dt>, + * <dd>The returned {@code Completable} honors the backpressure of the downstream consumer, + * and expects the other {@code Publisher} to honor it as well.</dd>, + * <dt><b>Backpressure:</b><dt>, + * <dd>The returned {@code Completable} honors the backpressure of the downstream consumer, + * and expects the other {@code Publisher} to honor it as well.</dd>, + * @param source the emitter that is called when a CompletableObserver subscribes to the returned {@code Completable}, + * @see CompletableOnSubscribe, + * If the errorSupplier returns null, the child CompletableObservers will receive a, + * <dt><b>Backpressure:</b><dt>, +
[+++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.disposables.Disposable;, +import io.reactivex.internal.subscribers.completable.*;, + static final Completable COMPLETE = new CompletableEmpty();, + static final Completable NEVER = new CompletableNever();, + return new CompletableAmbArray(sources);, + return new CompletableAmbIterable(sources);, + return new CompletableConcatArray(sources);, + return new CompletableConcatIterable(sources);, + return new CompletableConcat(sources, prefetch);, + * @deprecated, + @Deprecated // FIXME temporary, + if (onSubscribe instanceof Completable) {, + throw new IllegalArgumentException("Use of create(Completable)!");, + }, + return new CompletableDefer(completableSupplier);, + return new CompletableErrorSupplier(errorSupplier);, + return new CompletableError(error);, + return new CompletableFromCallable(callable);, + return new CompletableFromFlowable<T>(flowable);, + * Returns a Completable instance that subscribes to the given Observable, ignores all
[+++ b/src/main/java/io/reactivex/Observable.java, + , + public final BlockingObservable<T> toBlocking() {, + return BlockingObservable.from(this);, + }, +++ b/src/main/java/io/reactivex/Observable.java, + , + public final BlockingObservable<T> toBlocking() {, + return BlockingObservable.from(this);, + }, +++ b/src/main/java/io/reactivex/internal/operators/BlockingOperatorLatest.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed
[+++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, + <activity, + android:name=".ListenInOutActivity">, +, + <intent-filter>, + <category android:name="android.intent.category.LAUNCHER"/>, + <category android:name="android.intent.category.DEFAULT"/>, + <action android:name="android.intent.action.MAIN"/>, + </intent-filter>, + </activity>, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, + <activity, + android:name=".ListenInOutActivity">, +, + <intent-filter>, + <category android:name="android.intent.category.LAUNCHER"/>, + <category android:name="android.intent.category.DEFAULT"/>, + <action android:name="android.intent.action.MAIN"/>, + </intent-filter>, + </activity>, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/ListenInOutActivity.java, +package com.netflix.rxjava.android.samples;, +, +import android.app.Activity;, +import android.os.Bundle;, +import android.view.View;, +import android.widget.TextView;, +import android.widget.Toast;, +import android.widget.ToggleButton;, +, +import rx.Observable;, +import rx.Observer;, +import rx.Subscription;, +import rx.observables.ConnectableObservable;, +, +import static rx.android.observables.AndroidObservable.bindActivity;, +, +/**, + * Activity that binds to a counting sequence and is able to listen in and out to that, + * sequence by
[+++ b/src/main/java/io/reactivex/Observable.java, + public Observable<T> take(long n) {, + if (n < 0) {, + throw new IllegalArgumentException("n >= required but it was " + n);, + } else, + if (n == 0) {, + return empty();, + }, + return lift(new OperatorTake<>(n));, + }, + , + public <U> Observable<T> takeUntil(Publisher<U> other) {, + return lift(new OperatorTakeUntil<>(other));, + }, + , + public Observable<T> takeUntil(Predicate<? super T> predicate) {, + return lift(new OperatorTakeUntilPredicate<>(predicate));, + }, + , + public Observable<T> takeLast(int n) {, + if (n < 0) {, + throw new IllegalArgumentException("n >= required but it
[+++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, + def mountainBikeMedals: Observable[Medal] = Observable(, + Observable(, + Observable(, + Observable(, + Observable(, + Observable(, + Observable(), +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, + def mountainBikeMedals: Observable[Medal] = Observable(, + Observable(, + Observable(, + Observable(, + Observable(, + Observable(, + Observable(), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, + val first = Observable(10, 11, 12), + val second = Observable(10, 11, 12), + val first = Observable(10, 11, 12), + val second =
[+++ b/gradle.properties, +version=0.9.1-SNAPSHOT]
[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Notification.scala, +/**, + * Copyright 2013 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for
[+++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.operators.single.SingleReduceFlowable;, + return singleElement().blockingGet();, + return single(defaultItem).blockingGet();, + * Returns a Single that counts the total number of items emitted by the source Publisher and emits, + * @return a Single that emits a single item: the number of items emitted by the source Publisher as a, + public final Single<Long> count() {, + return RxJavaPlugins.onAssembly(new FlowableCountSingle<T>(this));, + * Returns a Maybe that emits the single item at a specified index in a sequence of emissions from a, + * @return a Maybe that emits a single item: the item at the specified position in the
[+++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java, + static volatile Consumer<? super Throwable> errorHandler;, + public static Consumer<? super Throwable> getErrorHandler() {, + Consumer<? super Throwable> f = errorHandler;, + public static void setErrorHandler(@Nullable Consumer<? super Throwable> handler) {, +++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java, + static volatile Consumer<? super Throwable> errorHandler;, + public static Consumer<? super Throwable> getErrorHandler() {, + Consumer<? super Throwable> f = errorHandler;, + public static void setErrorHandler(@Nullable Consumer<? super Throwable> handler) {, +++ b/src/test/java/io/reactivex/plugins/RxJavaPluginsTest.java, + /**, + * Ensure setErrorHandler() accepts a consumer with "? super Throwable", + */, + @Test, + public void onErrorWithSuper() throws Exception {, + try {, + Consumer<?
[+++ b/src/main/java/io/reactivex/Observable.java, + * Observable.defer(() -> source.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)));, + * Observable.defer(() -> o.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item))), + * Observable.defer(() -> source.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item)));, + * Observable.defer(() -> o.reduce(new ArrayList&lt;>(), (list, item) -> list.add(item))), + * Observable.defer(() -> source.scan(new ArrayList&lt;>(), (list, item) -> list.add(item)));, + * Observable.defer(() -> o.scan(new ArrayList&lt;>(), (list, item) -> list.add(item))), + * Observable.defer(() -> source.scan(new ArrayList&lt;>(), (list, item) -> list.add(item)));, + * Observable.defer(() -> o.scan(new ArrayList&lt;>(), (list, item) -> list.add(item)))]
[+++ b/src/main/java/io/reactivex/Scheduler.java, +import io.reactivex.annotations.*;, +import io.reactivex.internal.schedulers.*;, + DisposeTask task = new DisposeTask(decoratedRun, w);, + w.schedule(task, delay, unit);, +, + return task;, + static final class DisposeTask implements Runnable, Disposable {, + Thread runner;, +, + runner = Thread.currentThread();, + dispose();, + runner = null;, + }, + }, +, + @Override, + public void dispose() {, + if (runner == Thread.currentThread() && w instanceof NewThreadWorker) {, + ((NewThreadWorker)w).shutdown();, + } else {, +, + @Override, + public boolean isDisposed() {, + return w.isDisposed();, + }, +++ b/src/main/java/io/reactivex/Scheduler.java, +import io.reactivex.annotations.*;, +import io.reactivex.internal.schedulers.*;, + DisposeTask task = new DisposeTask(decoratedRun, w);, +
[+++ b/.gitattributes, +# Set default behaviour, in case users don't have core.autocrlf set., +* text=auto, +, +# Explicitly declare text files we want to always be normalized and converted , +# to native line endings on checkout., +*.java text, +*.groovy text, +*.scala text, +*.clj text, +*.txt text, +*.md text, +, +# Denote all files that are truly binary and should not be modified., +*.png binary, +*.jpg binary]
[+++ b/src/main/java/io/reactivex/internal/observers/LambdaObserver.java, + lazySet(DisposableHelper.DISPOSED);, + lazySet(DisposableHelper.DISPOSED);, +++ b/src/main/java/io/reactivex/internal/observers/LambdaObserver.java, + lazySet(DisposableHelper.DISPOSED);, + lazySet(DisposableHelper.DISPOSED);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDoFinallyTest.java, +import java.util.*;, +, + @Test, + public void eventOrdering() {, + final List<String> list = new ArrayList<String>();, +, + Flowable.error(new TestException()), + .doOnCancel(new Action() {, + @Override, + public void run() throws Exception {, + list.add("cancel");, + }, + }), + .doFinally(new Action() {, + @Override, + public void run() throws Exception {, + list.add("finally");, + }, + }), + .subscribe(, + new Consumer<Object>() {, + @Override, + public void accept(Object v) throws Exception {, + list.add("onNext");, + }, + },, + new Consumer<Throwable>() {,
[+++ b/rxjava-core/src/main/java/rx/Notification.java, + public void accept(Subscriber<? super T> observer) {, +++ b/rxjava-core/src/main/java/rx/Notification.java, + public void accept(Subscriber<? super T> observer) {, +++ b/rxjava-core/src/main/java/rx/Observable.java, + * {@link OnSubscribeFunc} to be executed when {@link #subscribe(Subscriber)} is called, + * Returns an Observable that will execute the specified function when an {@link Subscriber} subscribes to it., + * invoke the Observer's {@link Subscriber#onNext onNext}, {@link Subscriber#onError onError}, and {@link Subscriber#onCompleted onCompleted} methods appropriately., + * @return an Observable that, when an {@link Subscriber} subscribes to it, will execute the, + * @see <a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#create">RxJava Wiki: create()</a>, + public static interface OnSubscribe<T> extends Action1<Subscriber<?
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorToMap;, +import rx.operators.OperationToMultimap;, + return lift(new OperatorToMap<T, K, T>(keySelector, Functions.<T>identity()));, + return lift(new OperatorToMap<T, K, V>(keySelector, valueSelector));, + return lift(new OperatorToMap<T, K, V>(keySelector, valueSelector, mapFactory));, + return create(OperationToMultimap.toMultimap(this, keySelector));, + return create(OperationToMultimap.toMultimap(this, keySelector, valueSelector));, + return create(OperationToMultimap.toMultimap(this, keySelector, valueSelector, mapFactory));, + return create(OperationToMultimap.toMultimap(this, keySelector, valueSelector, mapFactory, collectionFactory));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorToMap;, +import rx.operators.OperationToMultimap;, + return lift(new OperatorToMap<T, K, T>(keySelector, Functions.<T>identity()));, + return lift(new OperatorToMap<T, K, V>(keySelector, valueSelector));, + return lift(new OperatorToMap<T, K, V>(keySelector, valueSelector, mapFactory));, + return create(OperationToMultimap.toMultimap(this, keySelector));, + return create(OperationToMultimap.toMultimap(this, keySelector, valueSelector));, + return create(OperationToMultimap.toMultimap(this, keySelector, valueSelector, mapFactory));, + return create(OperationToMultimap.toMultimap(this, keySelector, valueSelector, mapFactory,
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableGenerate.java, + boolean hasNext;, +, + state = null;, + hasNext = false;, +, + state = null;, + onError(ex);, + dispose(s);, + state = null;, + S s = state;, + state = null;, + dispose(s);, + if (!terminate) {, + if (hasNext) {, + onError(new IllegalStateException("onNext already called in this generate turn"));, + } else {, + } else {, + hasNext = true;, + }, + }, + }, + if (terminate) {, + RxJavaPlugins.onError(t);, + } else {, + }, + if (!terminate) {, +}, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableGenerate.java, + boolean hasNext;, +, + state =
[+++ b/gradle.properties, +version=0.17.0-RC3]
[+++ b/src/main/java/io/reactivex/Notification.java, + , + public static <T> boolean isNext(Try<Optional<T>> notification) {, + if (notification.hasValue()) {, + return notification.value().isPresent();, + }, + return false;, + }, + , + public static <T> boolean isComplete(Try<Optional<T>> notification) {, + if (notification.hasValue()) {, + return !notification.value().isPresent();, + }, + return false;, + }, + , + public static <T> boolean isError(Try<Optional<T>> notification) {, + return notification.hasError();, + }, + , + public static <T> T getValue(Try<Optional<T>> notification) {, + if (notification.hasValue()) {, + return notification.value.get();, + }, + return null;, + }, +++ b/src/main/java/io/reactivex/Notification.java, + , + public static <T> boolean isNext(Try<Optional<T>>
[+++ b/.travis.yml, +- oraclejdk7, +#addons:, +# apt:, +# packages:, +# - oracle-java8-installer, +, +# prevent travis running gradle assemble; let the build script do it anyway, +install: true, +++ b/.travis.yml, +- oraclejdk7, +#addons:, +# apt:, +# packages:, +# - oracle-java8-installer, +, +# prevent travis running gradle assemble; let the build script do it anyway, +install: true, +++ b/build.gradle, + dependencies { , + classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:4.0.0' , + classpath 'ru.vyarus:gradle-animalsniffer-plugin:1.1.0', + }, +// apply plugin: 'pmd', +apply plugin: 'ru.vyarus.animalsniffer', + signature 'org.codehaus.mojo.signature:java16:1.1@signature', +, +, + exclude "**/rx/internal/**", + exclude "**/test/**", + exclude "**/perf/**", + options {, + windowTitle = "RxJava
[+++ b/gradle.properties, +version=0.19.1-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Flowable.java, + @SchedulerSupport(SchedulerSupport.CUSTOM), + return o.subscribeOn(scheduler);, +++ b/src/main/java/io/reactivex/Flowable.java, + @SchedulerSupport(SchedulerSupport.CUSTOM), + return o.subscribeOn(scheduler);, +++ b/src/main/java/io/reactivex/Observable.java, + @SchedulerSupport(SchedulerSupport.CUSTOM), + return o.subscribeOn(scheduler);, +++ b/src/main/java/io/reactivex/Flowable.java, + @SchedulerSupport(SchedulerSupport.CUSTOM), + return o.subscribeOn(scheduler);, +++ b/src/main/java/io/reactivex/Observable.java, + @SchedulerSupport(SchedulerSupport.CUSTOM), + return o.subscribeOn(scheduler);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableToObservableFutureTest.java, +import io.reactivex.schedulers.*;, + public void testSuccessOperatesOnSuppliedScheduler() throws Exception {, + @SuppressWarnings("unchecked"), + Future<Object> future = mock(Future.class);, + Object value = new Object();, + when(future.get()).thenReturn(value);, +, + Subscriber<Object> o = TestHelper.mockSubscriber();, +, + TestScheduler scheduler = new TestScheduler();, + TestSubscriber<Object> ts = new TestSubscriber<Object>(o);, +, + Flowable.fromFuture(future, scheduler).subscribe(ts);, +, + verify(o, never()).onNext(value);, +, + scheduler.triggerActions();, +, + verify(o, times(1)).onNext(value);, + }, +, +
[+++ b/rxjava-core/src/main/java/rx/Observable.java, + return OperatorTakeUntil.takeUntil(this, other);, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return OperatorTakeUntil.takeUntil(this, other);, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return OperatorTakeUntil.takeUntil(this, other);, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorTakeUntil.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is
[+++ b/language-adaptors/rxjava-scala-java/README.md, +, +rxjava-scala-java, +-----------------, +, +Contains examples illustrating how RxScala code can be used from Java., +++ b/language-adaptors/rxjava-scala-java/README.md, +, +rxjava-scala-java, +-----------------, +, +Contains examples illustrating how RxScala code can be used from Java., +++ b/language-adaptors/rxjava-scala-java/build.gradle, +, +apply plugin: 'osgi', +, +, +project(':language-adaptors:rxjava-scala-java') {, + //sourceSets.test.java.srcDir 'src/examples/java', + sourceSets.main.java.srcDir 'src/main/java', +}, +, +dependencies {, + compile 'org.scala-lang:scala-library:2.10.+', +, + compile project(':rxjava-core'), + , + compile project(':language-adaptors:rxjava-scala'), + , + provided 'junit:junit-dep:4.10', + provided 'org.mockito:mockito-core:1.8.5', + provided 'org.scalatest:scalatest_2.10:1.9.1', +}, +, +jar {, + manifest {, + name = 'rxjava-scala-java', + instruction 'Bundle-Vendor', 'Netflix', + instruction 'Bundle-DocURL', 'https://github.com/Netflix/RxJava', + instruction 'Import-Package',
[+++ b/src/main/java/io/reactivex/processors/AsyncProcessor.java, +public final class AsyncProcessor<T> extends FlowProcessor<T> {, +++ b/src/main/java/io/reactivex/processors/AsyncProcessor.java, +public final class AsyncProcessor<T> extends FlowProcessor<T> {, +++ b/src/main/java/io/reactivex/processors/BehaviorProcessor.java, +public final class BehaviorProcessor<T> extends FlowProcessor<T> {, +++ b/src/main/java/io/reactivex/processors/AsyncProcessor.java, +public final class AsyncProcessor<T> extends FlowProcessor<T> {, +++ b/src/main/java/io/reactivex/processors/BehaviorProcessor.java, +public final class BehaviorProcessor<T> extends FlowProcessor<T> {, +++ b/src/main/java/io/reactivex/processors/FlowProcessor.java, + * @param <T> the item value type, +public abstract class FlowProcessor<T> extends Flowable<T> implements Processor<T, T> {, + public T getValue() {, + public final FlowProcessor<T> toSerialized() {, + return new SerializedProcessor<T>(this);, + T[] a = (T[])EMPTY;, + T[] b = getValues(a);, + public T[] getValues(T[] array) {, +++ b/src/main/java/io/reactivex/processors/AsyncProcessor.java, +public
[+++ b/src/main/java/io/reactivex/Maybe.java, + * Wraps a CompletableSource into a Maybe., + *, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code fromCompletable} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + * @param <T> the target type, + * @param completableSource the CompletableSource to convert from, + * @return the new Maybe instance, + * @throws NullPointerException if completable is null, + */, + @SchedulerSupport(SchedulerSupport.NONE), + public static <T> Maybe<T> fromCompletable(CompletableSource completableSource) {, + ObjectHelper.requireNonNull(completableSource, "completableSource is null");, + return RxJavaPlugins.onAssembly(new MaybeFromCompletable<T>(completableSource));, + }, +, + /**, + * Wraps a SingleSource into a
[+++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Apr 02 11:45:56 PDT 2013, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.5-bin.zip]
[+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableConcatIterable.java, + c = ObjectHelper.requireNonNull(a.next(), "The CompletableSource returned is null");, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableConcatIterable.java, + c = ObjectHelper.requireNonNull(a.next(), "The CompletableSource returned is null");, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableErrorSupplier.java, +import io.reactivex.internal.functions.ObjectHelper;, + error = ObjectHelper.requireNonNull(errorSupplier.call(), "The error returned is null");, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableConcatIterable.java, + c = ObjectHelper.requireNonNull(a.next(), "The CompletableSource returned is null");, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableErrorSupplier.java, +import io.reactivex.internal.functions.ObjectHelper;, + error = ObjectHelper.requireNonNull(errorSupplier.call(), "The error returned is null");, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableMergeDelayErrorIterable.java, + iterator = ObjectHelper.requireNonNull(sources.iterator(), "The source iterator returned is null");, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableConcatIterable.java, + c = ObjectHelper.requireNonNull(a.next(), "The CompletableSource returned is null");, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableErrorSupplier.java, +import io.reactivex.internal.functions.ObjectHelper;, + error = ObjectHelper.requireNonNull(errorSupplier.call(), "The error returned is null");, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableMergeDelayErrorIterable.java, + iterator
[+++ b/src/main/java/io/reactivex/Completable.java, + * <img width="640" height="388" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.using.png" alt="">, + * <p>, + * <img width="640" height="332" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.using.b.png" alt="">, + * <p>, + * <p>, + * <img width="640" height="354" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.wrap.png" alt="">, + * <p>, + * <img width="640" height="484" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.ambWith.png" alt="">, + * <p>, + * <img width="640" height="278" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.o.png" alt="">, + * <p>, + * <img width="640" height="249" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.p.png" alt="">, + * <p>, + * <img width="640" height="437" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.s.png" alt="">, + * <p>, + * <img width="640" height="280" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.m.png" alt="">, + * <img width="640" height="437" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.andThen.c.png" alt="">, + * <p>, + * <img width="640" height="751" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.as.png" alt="">,
[+++ b/gradle.properties, +version=0.17.0-RC6-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Observable.java, + throw new IllegalArgumentException("count >= 0 required but it was " + count);]
[+++ /dev/null, +++ /dev/null, +++ b/src/main/java/io/reactivex/BackpressureOverflowStrategy.java, +/**, + * Copyright 2016 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + *
[+++ b/.travis.yml, +# script for build and release via Travis to Bintray, +after_success: gradle/publishViaTravis.sh, +# secure environment variables for release to Bintray, +env:, + global:, + - secure: "HzRt91B6CLkBCxRXlo7V+F5L8SSHSW8dgkO8nAlTnOIK73k3QelDeBlcm1wnuNa3x+54YS9WBv6QrTNZr9lVi/8IPfKpd+jtjIbCWRvh6aNhqLIXWTL7oTvUd4E8DDUAKB6UMae6SiBSy2wsFELGHXeNwg7EiPfxsd5sKRiS7H4=", + - secure: "MSZLPasqNKAC+8qhKQD3xO+ZbuOy65HpUN+1+KnoOLMkHCu/f4x60W1tpTAzn1DFEVpokHR0n3I4z4HpWybURDQfDHD1bB4IsznjCUBYA9Uo9Sb0U4TS17dQr8s7SORIjHDLGNSWETJjrA9TfuUV6HTVhRO1ECx3H+wuTwCVDN0="]
[+++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/internal/functions/ObjectHelper.java, +, + /**, + * Trap null-check attempts on primitives., + * @param value the value to check, + * @param message the message to print, + * @return the value, + * @deprecated this method should not be used as there is no need, + * to check primitives for nullness., + */, + @Deprecated, + public static long requireNonNull(long value, String message) {, + throw new InternalError("Null check on a primitive: " + message);, + }, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/internal/functions/ObjectHelper.java, +, + /**, + * Trap null-check attempts on primitives., +
[+++ b/gradle.properties, +version=0.14.2-SNAPSHOT]
[+++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/TestParallel.groovy, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/TestParallel.groovy, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/TestParallel.groovy, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/TestParallel.groovy, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Notification.scala, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/TestParallel.groovy, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Notification.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Scheduler.scala, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/TestParallel.groovy, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Notification.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Scheduler.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/concurrency/Schedulers.scala, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/TestParallel.groovy, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Notification.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Scheduler.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/concurrency/Schedulers.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/concurrency/TestScheduler.scala, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/TestParallel.groovy, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Notification.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Scheduler.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/concurrency/Schedulers.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/concurrency/TestScheduler.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/observables/package.scala, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/TestParallel.groovy, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Notification.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Scheduler.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/concurrency/Schedulers.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/concurrency/TestScheduler.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/observables/package.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/subjects/package.scala, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/TestParallel.groovy, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Notification.scala, +++
[+++ b/src/jmh/java/io/reactivex/FlattenRangePerf.java, +/**, + * Copyright (c) 2016-present, RxJava Contributors., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorToMultimap;, + return lift(new OperatorToMultimap<T, K, T>(keySelector, Functions.<T>identity()));, + return lift(new OperatorToMultimap<T, K, V>(keySelector, valueSelector));, + return lift(new OperatorToMultimap<T, K, V>(keySelector, valueSelector, mapFactory));, + return lift(new OperatorToMultimap<T, K, V>(keySelector, valueSelector, mapFactory, collectionFactory));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorToMultimap;, + return lift(new OperatorToMultimap<T, K, T>(keySelector, Functions.<T>identity()));, + return lift(new OperatorToMultimap<T, K, V>(keySelector, valueSelector));, + return lift(new OperatorToMultimap<T, K, V>(keySelector, valueSelector, mapFactory));, + return lift(new OperatorToMultimap<T, K, V>(keySelector, valueSelector, mapFactory, collectionFactory));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorToMultimap;, + return lift(new OperatorToMultimap<T, K, T>(keySelector, Functions.<T>identity()));, + return lift(new OperatorToMultimap<T, K, V>(keySelector, valueSelector));, + return lift(new OperatorToMultimap<T, K, V>(keySelector, valueSelector, mapFactory));, +
[+++ b/gradle.properties, +version=0.20.0-RC6-SNAPSHOT]
[+++ b/src/test/java/io/reactivex/processors/AsyncProcessorTest.java, +import io.reactivex.subscribers.SubscriberFusion;, +import io.reactivex.subscribers.TestSubscriber;, +import org.junit.Ignore;, +import org.junit.Test;, +import org.mockito.InOrder;, +import org.mockito.Mockito;, +import org.reactivestreams.Subscriber;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicReference;, +, +import static org.junit.Assert.*;, +import static org.mockito.ArgumentMatchers.any;, +import static org.mockito.ArgumentMatchers.anyString;, +import static org.mockito.Mockito.*;, +, +public class AsyncProcessorTest extends DelayedFlowableProcessorTest<Object> {, + @Override, + protected FlowableProcessor<Object> create() {, + return AsyncProcessor.create();, + }, +, +++ b/src/test/java/io/reactivex/processors/AsyncProcessorTest.java, +import io.reactivex.subscribers.SubscriberFusion;, +import io.reactivex.subscribers.TestSubscriber;, +import org.junit.Ignore;, +import org.junit.Test;, +import org.mockito.InOrder;, +import org.mockito.Mockito;, +import org.reactivestreams.Subscriber;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicReference;, +, +import static org.junit.Assert.*;, +import static org.mockito.ArgumentMatchers.any;, +import static org.mockito.ArgumentMatchers.anyString;, +import static org.mockito.Mockito.*;, +, +public class AsyncProcessorTest extends DelayedFlowableProcessorTest<Object> {, + @Override, + protected FlowableProcessor<Object> create()
[+++ b/src/main/java/io/reactivex/internal/operators/single/SingleCache.java, +public final class SingleCache<T> extends Single<T> implements SingleObserver<T> {, +, + @SuppressWarnings("rawtypes"), + static final CacheDisposable[] EMPTY = new CacheDisposable[0];, + @SuppressWarnings("rawtypes"), + static final CacheDisposable[] TERMINATED = new CacheDisposable[0];, + final AtomicReference<CacheDisposable<T>[]> observers;, + , + T value;, + , + Throwable error;, + , + @SuppressWarnings("unchecked"), + this.observers = new AtomicReference<CacheDisposable<T>[]>(EMPTY);, + protected void subscribeActual(final SingleObserver<? super T> s) {, + CacheDisposable<T> d = new CacheDisposable<T>(s, this);, + s.onSubscribe(d);, + if (add(d)) {, + if (d.isDisposed()) {, + remove(d);, + }, + Throwable ex = error;, + if (ex != null) {, + s.onError(ex);, +
[+++ b/src/main/java/io/reactivex/functions/Consumer.java, + void accept(T t) throws Exception;]
[+++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/blocking_test.clj, + (is (thrown? java.util.NoSuchElementException (b/single (rx/empty))))), +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/blocking_test.clj, + (is (thrown? java.util.NoSuchElementException (b/single (rx/empty))))), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, + @Test def firstLastSingleExample() {, + assertEquals(1, List(1, 2, 3, 4).toObservable.head.toBlockingObservable.single), + assertEquals(1, List(1, 2, 3, 4).toObservable.first.toBlockingObservable.single), + assertEquals(4, List(1, 2, 3, 4).toObservable.last.toBlockingObservable.single), + assertEquals(1, List(1).toObservable.single.toBlockingObservable.single), +, + assertEquals(1, List(1, 2, 3, 4).toObservable.toBlockingObservable.head), + assertEquals(1, List(1, 2, 3, 4).toObservable.toBlockingObservable.first), + assertEquals(4, List(1, 2, 3, 4).toObservable.toBlockingObservable.last), + assertEquals(1, List(1).toObservable.toBlockingObservable.single), + }, +, +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/blocking_test.clj, + (is (thrown? java.util.NoSuchElementException (b/single (rx/empty))))), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, + @Test def firstLastSingleExample() {, + assertEquals(1, List(1, 2, 3, 4).toObservable.head.toBlockingObservable.single), + assertEquals(1, List(1, 2, 3, 4).toObservable.first.toBlockingObservable.single), + assertEquals(4, List(1,
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java, +import io.reactivex.exceptions.MissingBackpressureException;, +import io.reactivex.functions.Function;, + onError(new MissingBackpressureException("Queue is full?!"));, + Throwable ex = error.get();, + if (ex != null) {, + ex = Exceptions.terminate(error);, + a.onError(ex);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java, +import io.reactivex.exceptions.MissingBackpressureException;, +import io.reactivex.functions.Function;, + onError(new MissingBackpressureException("Queue is full?!"));, + Throwable ex = error.get();, + if (ex != null) {, + ex = Exceptions.terminate(error);, + a.onError(ex);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterableTest.java, +/**, + * Copyright 2016 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of
[+++ b/rxjava-core/build.gradle, +++ b/rxjava-core/build.gradle, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationTake;, + return create(OperationTake.takeWhile(items, predicate));, + return create(OperationTake.takeWhileWithIndex(items, predicate));, + return create(OperationTake.takeWhileWithIndex(items, new Func2<T, Integer, Boolean>() {, + public Boolean call(T t, Integer integer) {, +++ b/rxjava-core/build.gradle, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationTake;, + return create(OperationTake.takeWhile(items, predicate));, + return create(OperationTake.takeWhileWithIndex(items, predicate));, + return create(OperationTake.takeWhileWithIndex(items, new Func2<T, Integer, Boolean>() {, + public Boolean call(T t, Integer integer) {, +++ b/rxjava-core/src/main/java/rx/operators/OperationCombineLatest.java, +import java.util.List;, +import java.util.Set;, + /**, + * Combines the two given observables, emitting an event containing an aggregation of the latest values of each of the source observables, + * each time an event
[+++ b/build.gradle, +// apply plugin: 'pmd' // disabled because runs out of memory on Travis, +// apply plugin: 'findbugs' // disabled because runs out of memory on Travis, +/*, +*/, +++ b/build.gradle, +// apply plugin: 'pmd' // disabled because runs out of memory on Travis, +// apply plugin: 'findbugs' // disabled because runs out of memory on Travis, +/*, +*/, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRefCount.java, + final AtomicInteger subscriptionCount = new AtomicInteger();, + final class ConnectionSubscriber, + extends AtomicReference<Subscription>, + implements Subscriber<T>, Subscription {, + /** */, + private static final long serialVersionUID = 152064694420235350L;, + final AtomicLong requested;, + this.requested =
[+++ b/gradlew, +JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.7.0_40.jdk/Contents/Home", +, +++ b/gradlew, +JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.7.0_40.jdk/Contents/Home", +, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/gradlew, +JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.7.0_40.jdk/Contents/Home", +, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +RxScala Release Notes, +=====================, +, +This release of the RxScala bindings builds on the previous 0.15 release to make the Rx bindings for Scala, +include all Rx types. In particular this release focuses on the `Subject` and `Scheduler` types., +To makes these notes self-contained, we will start with the `Observer[T]` and `Observable[T]` traits, +that lay at the heart of Rx., +, +Observer, +--------, +, +In this release we have made the `asJavaObserver` property
[+++ b/src/main/java/io/reactivex/Scheduler.java, +import io.reactivex.schedulers.SchedulerRunnableIntrospection;, +, +import java.util.concurrent.TimeUnit;, + final class PeriodicTask implements Runnable, SchedulerRunnableIntrospection {, +, + @Override, + public Runnable getWrappedRunnable() {, + return this.decoratedRun;, + }, + implements Disposable, Runnable, SchedulerRunnableIntrospection {, +, + @Override, + public Runnable getWrappedRunnable() {, + return run;, + }, + static final class DisposeTask implements Disposable, Runnable, SchedulerRunnableIntrospection {, +, + @Override, + public Runnable getWrappedRunnable() {, + return this.decoratedRun;, + }, +++ b/src/main/java/io/reactivex/Scheduler.java, +import io.reactivex.schedulers.SchedulerRunnableIntrospection;, +, +import java.util.concurrent.TimeUnit;, + final class PeriodicTask implements Runnable, SchedulerRunnableIntrospection {, +, + @Override, + public Runnable getWrappedRunnable() {, + return this.decoratedRun;, + }, +
[+++ b/src/main/java/io/reactivex/Flowable.java, + * If the provided array of source Publishers is empty, the resulting sequence completes immediately without emitting, + * any items and without any calls to the combiner function., + * any items and without any calls to the combiner function., + * If the provided array of source Publishers is empty, the resulting sequence completes immediately without emitting, + * any items and without any calls to the combiner function., + * If the provided iterable of source Publishers is empty, the resulting sequence completes immediately without emitting, + * any items and without any
[+++ b/gradle.properties, +version=0.11.3]
[+++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.fuseable.ScalarCallable;, + if (this instanceof ScalarCallable) {, + @SuppressWarnings("unchecked"), + T v = ((ScalarCallable<T>)this).call();, + if (v == null) {, + return empty();, + }, + return ScalarXMap.scalarXMap(v, mapper);, + }, + if (this instanceof ScalarCallable) {, + @SuppressWarnings("unchecked"), + T v = ((ScalarCallable<T>)this).call();, + if (v == null) {, + return empty();, + }, + return ScalarXMap.scalarXMap(v, mapper);, + }, + if (this instanceof ScalarCallable) {, + @SuppressWarnings("unchecked"), + T v = ((ScalarCallable<T>)this).call();, + if (v == null) {, + return empty();, + }, + return ScalarXMap.scalarXMap(v, mapper);, + }, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.fuseable.ScalarCallable;, +
[+++ b/src/main/java/io/reactivex/Observable.java, + return toMultimap(keySelector, v -> v, HashMap::new, k -> new ArrayList<>());, + return toMultimap(keySelector, valueSelector, HashMap::new, k -> new ArrayList<>());, + public final <K, V> Observable<Map<K, Collection<V>>> toMultimap(, + Function<? super T, ? extends K> keySelector, , + Supplier<Map<K, Collection<V>>> mapSupplier, + ) {, + return toMultimap(keySelector, valueSelector, mapSupplier, k -> new ArrayList<>());, + }, + , + @SuppressWarnings("unchecked"), + public final <K, V> Observable<Map<K, Collection<V>>> toMultimap(, + Function<? super T, ? extends K> keySelector, , + Function<? super T, ? extends V> valueSelector, , + Supplier<? extends Map<K, Collection<V>>> mapSupplier,, + Function<? super K, ? extends
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorMergeMaxConcurrent;, + return source.lift(new OperatorMergeMaxConcurrent<T>(maxConcurrent));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorMergeMaxConcurrent;, + return source.lift(new OperatorMergeMaxConcurrent<T>(maxConcurrent));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorMergeMaxConcurrent;, + return source.lift(new OperatorMergeMaxConcurrent<T>(maxConcurrent));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorMergeMaxConcurrent.java, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not, + * use this file except in compliance with the License. You may obtain a copy of, + * the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under
[+++ b/build.gradle, +def jmhLibVersion = "1.20", + jvmArgsAppend = ["-Djmh.separateClasspathJAR=true"], +++ b/build.gradle, +def jmhLibVersion = "1.20", + jvmArgsAppend = ["-Djmh.separateClasspathJAR=true"], +++ b/src/jmh/java/io/reactivex/FlowableFlatMapCompletablePerf.java, +/**, + * Copyright (c) 2016-present, RxJava Contributors., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS,
[+++ b/src/main/java/io/reactivex/subjects/PublishSubject.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + TerminalAtomicsHelper.remove(SUBSCRIBERS, this, ps, TERMINATED, EMPTY, this);, + if (SubscriptionHelper.validateRequest(n)) {, +++ b/src/main/java/io/reactivex/subjects/PublishSubject.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + TerminalAtomicsHelper.remove(SUBSCRIBERS, this, ps, TERMINATED, EMPTY, this);, + if (SubscriptionHelper.validateRequest(n)) {, +++ b/src/test/java/io/reactivex/exceptions/TestException.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed
[+++ b/src/main/java/io/reactivex/Flowable.java, + * <p>, + * If provided array of source Publishers is empty, the resulting sequence completes immediately without emitting, + * any items and without any calls to combiner function., + * <p>, + * If there are no source Publishers provided, the resulting sequence completes immediately without emitting, + * any items and without any calls to combiner function., + * <p>, + * If provided array of source Publishers is empty, the resulting sequence completes immediately without emitting, + * any items and without any calls to combiner function., + * <p>, + *
[+++ b/src/main/java/io/reactivex/observers/TestObserver.java, + /**, + * Asserts that this TestObserver received exactly one onNext value for which, + * the provided predicate returns true., + * @param valuePredicate, + * the predicate that receives the onNext value, + * and should return true for the expected value., + * @return this, + */, + public final TestObserver<T> assertValue(Predicate<T> valuePredicate) {, + int s = values.size();, + if (s == 0) {, + throw fail("No values");, + }, +, + boolean found = false;, +, + try {, + if (valuePredicate.test(values.get(0))) {, + found = true;, + }, + }
[+++ b/language-adaptors/rxjava-clojure/build.gradle, +++ b/language-adaptors/rxjava-clojure/build.gradle, +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java, +/**, + * Copyright 2013 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + *
[+++ b/src/main/java/io/reactivex/internal/observers/ToNotificationObserver.java, + onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));, +++ b/src/main/java/io/reactivex/internal/observers/ToNotificationObserver.java, + onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableError.java, + error = new NullPointerException("Callable returned null throwable. Null values are generally not allowed in 2.x operators and sources.");, +++ b/src/main/java/io/reactivex/internal/observers/ToNotificationObserver.java, + onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableError.java, + error = new NullPointerException("Callable returned null throwable. Null values are generally not allowed in 2.x operators and sources.");,
[+++ b/src/main/java/io/reactivex/internal/operators/single/SingleLift.java, +import io.reactivex.exceptions.Exceptions;, +import io.reactivex.internal.disposables.EmptyDisposable;, +import io.reactivex.internal.functions.ObjectHelper;, + SingleObserver<? super T> sr;, + try {, + sr = ObjectHelper.requireNonNull(onLift.apply(s), "The onLift returned a null SingleObserver");, + Exceptions.throwIfFatal(ex);, + EmptyDisposable.error(ex, s);, + return;, +, + source.subscribe(sr);, +++ b/src/main/java/io/reactivex/internal/operators/single/SingleLift.java, +import io.reactivex.exceptions.Exceptions;, +import io.reactivex.internal.disposables.EmptyDisposable;, +import io.reactivex.internal.functions.ObjectHelper;, + SingleObserver<? super T> sr;, + try {, + sr = ObjectHelper.requireNonNull(onLift.apply(s), "The onLift returned a null SingleObserver");, + Exceptions.throwIfFatal(ex);, + EmptyDisposable.error(ex, s);, + return;, +, + source.subscribe(sr);, +++ b/src/main/java/io/reactivex/internal/operators/single/SingleUsing.java, +import java.util.concurrent.atomic.AtomicReference;, +import io.reactivex.disposables.Disposable;, +import io.reactivex.internal.disposables.*;, + Function<? super U, ? extends SingleSource<? extends T>> singleFunction,, + Consumer<? super U> disposer,, + SingleSource<? extends T>
[+++ b/.gitignore, +.m2, +target/, +build/, +bin/, +, +# Scala build, +*.cache, +++ b/.gitignore, +.m2, +target/, +build/, +bin/, +, +# Scala build, +*.cache, +++ b/CHANGES.md, +# RxJava Releases #, +, +### Version 0.10.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.10.0%22)) ###, +, +This release includes a breaking change as it changes `onError(Exception)` to `onError(Throwable)`. This decision was made via discussion at https://github.com/Netflix/RxJava/issues/296., +, +Any statically-typed `Observer` implementations with `onError(Exception)` will need to be updated to `onError(Throwable)` when moving to this version., +, +* [Pull 312](https://github.com/Netflix/RxJava/pull/312) Fix for OperatorOnErrorResumeNextViaObservable and async Resume, +* [Pull 314](https://github.com/Netflix/RxJava/pull/314) Map Error Handling, +* [Pull 315](https://github.com/Netflix/RxJava/pull/315) Change onError(Exception) to onError(Throwable) -
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeat.java, +, + long produced;, +, + produced++;, + long p = produced;, + if (p != 0L) {, + produced = 0L;, + sa.produced(p);, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeat.java, +, + long produced;, +, + produced++;, + long p = produced;, + if (p != 0L) {, + produced = 0L;, + sa.produced(p);, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeatUntil.java, +, + long produced;, +, + produced++;, + if (sa.isCancelled()) {, + return;, + }, +, + long p = produced;, + if (p != 0L) {, + produced = 0L;, + sa.produced(p);, + }, +, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeat.java, +, + long
[+++ b/extensions/rxjava-swing/build.gradle, +apply plugin: 'java', +apply plugin: 'eclipse', +apply plugin: 'idea', +apply plugin: 'osgi', +, +sourceCompatibility = JavaVersion.VERSION_1_6, +targetCompatibility = JavaVersion.VERSION_1_6, +, +dependencies {, + compile project(':rxjava-core'), + provided 'junit:junit:4.10', + provided 'org.mockito:mockito-core:1.8.5', +}, +, +eclipse {, + classpath {, + // include 'provided' dependencies on the classpath, + plusConfigurations += configurations.provided, +, + downloadSources = true, + downloadJavadoc = true, + }, +}, +, +idea {, + module {, + // include 'provided' dependencies on the classpath, + scopes.PROVIDED.plus += configurations.provided, + }, +}, +, +javadoc {, + options {, + doclet = "org.benjchristensen.doclet.DocletExclude", + docletpath = [rootProject.file('./gradle/doclet-exclude.jar')],
[+++ b/.gitignore, +++ b/.gitignore, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/.gitignore, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/.gitignore, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ /dev/null, +++ b/.gitignore, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ /dev/null, +++
[+++ b/src/main/java/io/reactivex/Maybe.java, +import io.reactivex.internal.fuseable.*;, + @SuppressWarnings("unchecked"), + if (this instanceof FuseToFlowable) {, + return ((FuseToFlowable<T>)this).fuseToFlowable();, + }, + @SuppressWarnings("unchecked"), + if (this instanceof FuseToObservable) {, + return ((FuseToObservable<T>)this).fuseToObservable();, + }, +++ b/src/main/java/io/reactivex/Maybe.java, +import io.reactivex.internal.fuseable.*;, + @SuppressWarnings("unchecked"), + if (this instanceof FuseToFlowable) {, + return ((FuseToFlowable<T>)this).fuseToFlowable();, + }, + @SuppressWarnings("unchecked"), + if (this instanceof FuseToObservable) {, + return ((FuseToObservable<T>)this).fuseToObservable();, + }, +++ b/src/main/java/io/reactivex/internal/disposables/EmptyDisposable.java, + INSTANCE,, + /**, + * An empty disposable that returns false for isDisposed., + */, + NEVER, + return this == INSTANCE;, +++ b/src/main/java/io/reactivex/Maybe.java, +import io.reactivex.internal.fuseable.*;, + @SuppressWarnings("unchecked"), + if (this instanceof FuseToFlowable) {, + return
[+++ b/gradle.properties, +version=0.17.0-RC7]
[+++ /dev/null, +++ /dev/null, +++ b/rxjava-core/src/test/java/rx/operators/OperatorAnyTest.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
[+++ b/src/main/java/io/reactivex/Observable.java, + return create(s -> publisher.subscribe(s)); // javac fails to compile publisher::subscribe, Eclipse is just fine]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java, + // make sure the last known node is not retained, + index = null;, + output.index = null;, + output.index = null;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java, + // make sure the last known node is not retained, + index = null;, + output.index = null;, + output.index = null;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java, + // make sure the last known node is not retained, + index = null;, + output.index = null;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java, + // make sure the last known node is not retained, + index = null;, + output.index = null;, + output.index = null;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java, +
[+++ b/rxjava-core/src/main/java/rx/observers/SafeObserver.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See
[+++ b/gradle.properties, +version=0.14.11-SNAPSHOT]
[+++ b/gradle.properties, +version=0.9.2, +++ b/gradle.properties, +version=0.9.2, +++ b/rxjava-core/src/main/java/rx/operators/OperationOnErrorResumeNextViaObservable.java, + // forward the successful calls, + // check that we have not been unsubscribed before we can process the error, + if (currentSubscription != null) {, + // forward the successful calls, + TestObservable w = new TestObservable(s, "one");, + throw new RuntimeException("Forced Failure");]
[+++ b/src/main/java/io/reactivex/subjects/AsyncSubject.java, +import io.reactivex.annotations.Nullable;, + @Nullable, +++ b/src/main/java/io/reactivex/subjects/AsyncSubject.java, +import io.reactivex.annotations.Nullable;, + @Nullable, +++ b/src/main/java/io/reactivex/subjects/BehaviorSubject.java, +import io.reactivex.annotations.Nullable;, + @Nullable, + @Nullable, +++ b/src/main/java/io/reactivex/subjects/AsyncSubject.java, +import io.reactivex.annotations.Nullable;, + @Nullable, +++ b/src/main/java/io/reactivex/subjects/BehaviorSubject.java, +import io.reactivex.annotations.Nullable;, + @Nullable, + @Nullable, +++ b/src/main/java/io/reactivex/subjects/CompletableSubject.java, +import io.reactivex.annotations.Nullable;, + @Nullable, +++ b/src/main/java/io/reactivex/subjects/AsyncSubject.java, +import io.reactivex.annotations.Nullable;, + @Nullable, +++ b/src/main/java/io/reactivex/subjects/BehaviorSubject.java, +import io.reactivex.annotations.Nullable;, + @Nullable, + @Nullable, +++ b/src/main/java/io/reactivex/subjects/CompletableSubject.java, +import io.reactivex.annotations.Nullable;, + @Nullable, +++ b/src/main/java/io/reactivex/subjects/MaybeSubject.java, + @Nullable, + @Nullable, +++ b/src/main/java/io/reactivex/subjects/AsyncSubject.java, +import io.reactivex.annotations.Nullable;, + @Nullable, +++ b/src/main/java/io/reactivex/subjects/BehaviorSubject.java, +import io.reactivex.annotations.Nullable;, + @Nullable, + @Nullable, +++ b/src/main/java/io/reactivex/subjects/CompletableSubject.java, +import io.reactivex.annotations.Nullable;, + @Nullable, +++ b/src/main/java/io/reactivex/subjects/MaybeSubject.java, + @Nullable, + @Nullable, +++ b/src/main/java/io/reactivex/subjects/PublishSubject.java, +import io.reactivex.annotations.Nullable;, + @Nullable, +++
[+++ b/CHANGES.md, +### Version 0.11.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.11.2%22)) ###, +, +* [Commit ccf53e8]( https://github.com/Netflix/RxJava/commit/ccf53e84835d99136cce80a4c508bae787d5da45) Update to Scala 2.10.2, +, +++ b/CHANGES.md, +### Version 0.11.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.11.2%22)) ###, +, +* [Commit ccf53e8]( https://github.com/Netflix/RxJava/commit/ccf53e84835d99136cce80a4c508bae787d5da45) Update to Scala 2.10.2, +, +++ b/build.gradle, +, +ext.githubProjectName = 'RxJava', +, + repositories {, + mavenLocal(), + mavenCentral() // maven { url 'http://jcenter.bintray.com' }, + }, + repositories { , + mavenLocal(), + mavenCentral() // maven { url: 'http://jcenter.bintray.com' }, +}, +++ b/CHANGES.md, +### Version 0.11.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.11.2%22)) ###, +, +* [Commit ccf53e8]( https://github.com/Netflix/RxJava/commit/ccf53e84835d99136cce80a4c508bae787d5da45) Update to Scala 2.10.2, +, +++ b/build.gradle, +, +ext.githubProjectName = 'RxJava', +, +
[+++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java, +import io.reactivex.annotations.Experimental;, + * the given value with respect to null-safe Object.equals., + * which is equal to the given value with respect to null-safe Object.equals., + * @param index the position to assert on, + * @param value the value to expect, + * @return this, + * @since 2.1.3 - experimental, + */, + @SuppressWarnings("unchecked"), + @Experimental, + public final U assertValueAt(int index, T value) {, + int s = values.size();, + if (s == 0) {, + throw fail("No values");, + }, +, + if (index >= s) {, + throw fail("Invalid index: "
[+++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeUnsubscribeOnTest.java, + int times = 10;, +, + while (times-- > 0 && pp.hasSubscribers()) {, + Thread.sleep(100);, + }, +]
[+++ b/src/main/java/io/reactivex/Observable.java, + return (Observable<T>) ObservableEmpty.INSTANCE;, + return new ObservableFromPublisher<T>(publisher);, + return (Observable<T>) ObservableNever.INSTANCE;, + return new ObservableRange(start, count);, + return new ObservableWrapper<T>(this);, +++ b/src/main/java/io/reactivex/Observable.java, + return (Observable<T>) ObservableEmpty.INSTANCE;, + return new ObservableFromPublisher<T>(publisher);, + return (Observable<T>) ObservableNever.INSTANCE;, + return new ObservableRange(start, count);, + return new ObservableWrapper<T>(this);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableEmpty.java, +/**, + * Copyright 2016 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, +
[+++ /dev/null, +++ /dev/null, +++ b/.gitignore, +, +# Build output directies, +/target, +*/target, +/build, +*/build, +#, +# # IntelliJ specific files/directories, +out, +.idea, +*.ipr, +*.iws, +*.iml, +atlassian-ide-plugin.xml, +, +# Eclipse specific files/directories, +.classpath, +.project, +.settings, +.metadata, +, +# NetBeans specific files/directories, +.nbattrs, +++ /dev/null, +++ b/.gitignore, +, +# Build output directies, +/target, +*/target, +/build, +*/build, +#, +# # IntelliJ specific files/directories, +out, +.idea, +*.ipr, +*.iws, +*.iml, +atlassian-ide-plugin.xml, +, +# Eclipse specific files/directories, +.classpath, +.project, +.settings, +.metadata, +, +# NetBeans specific files/directories, +.nbattrs, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +, +# Build output directies, +/target, +*/target, +/build, +*/build, +#, +#
[+++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.internal.operators.maybe.MaybeFromCompletable;, + * Converts this Single into a {@link Maybe}., + * <p>, + * <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.toObservable.png" alt="">, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code toCompletable} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + * , + * @param <T> the value type, + * @return an {@link Maybe} that emits a single item T or an error., + */, + public final <T> Maybe<T> toMaybe() {, + return RxJavaPlugins.onAssembly(new MaybeFromCompletable<T>(this));, + }, +, + /**, +++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.internal.operators.maybe.MaybeFromCompletable;, + * Converts this Single into
[+++ b/src/main/java/io/reactivex/Single.java, + * Delays the emission of the success signal from the current Single by the specified amount., + * @param time the time amount to delay the emission of the success signal]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorToMap;, + return lift(new OperatorToMap<T, K, T>(keySelector, Functions.<T>identity()));, + return lift(new OperatorToMap<T, K, V>(keySelector, valueSelector));, + return lift(new OperatorToMap<T, K, V>(keySelector, valueSelector, mapFactory));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorToMap;, + return lift(new OperatorToMap<T, K, T>(keySelector, Functions.<T>identity()));, + return lift(new OperatorToMap<T, K, V>(keySelector, valueSelector));, + return lift(new OperatorToMap<T, K, V>(keySelector, valueSelector, mapFactory));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorToMap;, + return lift(new OperatorToMap<T, K, T>(keySelector, Functions.<T>identity()));, + return lift(new OperatorToMap<T, K, V>(keySelector, valueSelector));, + return lift(new OperatorToMap<T, K, V>(keySelector, valueSelector, mapFactory));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorDebounceWithTime.java, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorToMap;, + return lift(new OperatorToMap<T, K, T>(keySelector, Functions.<T>identity()));, + return lift(new OperatorToMap<T,
[+++ b/classes/production/rxjava-core/rx/operators/README.txt, +This package "rx.operators" is for internal implementation details and can change at any time., +, +It is excluded from the public Javadocs (http://netflix.github.io/RxJava/javadoc/) and should not be relied upon by any code., +, +In short, changes to public signatures of these classes will not be accounted for in the versioning of RxJava., +++ b/classes/production/rxjava-core/rx/operators/README.txt, +This package "rx.operators" is for internal implementation details and can change at any time., +, +It is excluded from the public Javadocs (http://netflix.github.io/RxJava/javadoc/) and should not be relied upon by any code., +, +In short, changes to public signatures of these classes will
[+++ b/src/main/java/io/reactivex/Notification.java, +++ b/src/main/java/io/reactivex/Notification.java, +++ b/src/main/java/io/reactivex/Observable.java, + return lift(OperatorMaterialize.instance());, + @SuppressWarnings("unchecked"), + Observable<Try<Optional<T>>> m = (Observable<Try<Optional<T>>>)this;, + return m.lift(OperatorDematerialize.instance());, +++ b/src/main/java/io/reactivex/Notification.java, +++ b/src/main/java/io/reactivex/Observable.java, + return lift(OperatorMaterialize.instance());, + @SuppressWarnings("unchecked"), + Observable<Try<Optional<T>>> m = (Observable<Try<Optional<T>>>)this;, + return m.lift(OperatorDematerialize.instance());, +++ b/src/main/java/io/reactivex/internal/operators/OperatorDematerialize.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or
[+++ b/src/main/java/io/reactivex/Single.java, + * @return the Single returned from {@code mapper} when applied to the item emitted by the source Single, + * Returns a Maybe that is based on applying a specified function to the item emitted by the source Single,, + * where that function returns a MaybeSource., + * <p>, + * <img width="640" height="300" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMapMaybe.png" alt="">, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code flatMapMaybe} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + *, + * @param <R> the result value type, + * @param mapper, + *
[+++ b/src/test/java/io/reactivex/processors/UnicastProcessorTest.java, +import org.junit.Test;, +, +import io.reactivex.Observable;, +import io.reactivex.disposables.Disposable;, +++ b/src/test/java/io/reactivex/processors/UnicastProcessorTest.java, +import org.junit.Test;, +, +import io.reactivex.Observable;, +import io.reactivex.disposables.Disposable;, +++ b/src/test/java/io/reactivex/subjects/UnicastSubjectTest.java, +, +import java.util.concurrent.atomic.AtomicBoolean;, +, +import io.reactivex.Observable;, +import io.reactivex.disposables.Disposable;]
[+++ b/src/main/java/io/reactivex/Completable.java, + * The {@code Completable} class represents a deferred computation without any value but, + * only indication for completion or exception., + * <p>, + * {@code Completable} behaves similarly to {@link Observable} except that it can only emit either, + * a completion or error signal (there is no {@code onNext} or {@code onSuccess} as with the other, + * reactive types)., + * <p>, + * The {@code Completable} class implements the {@link CompletableSource} base interface and the default consumer, + * type it interacts with is the {@link CompletableObserver} via the {@link #subscribe(CompletableObserver)}
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeout.java, +import java.util.concurrent.atomic.*;, +import io.reactivex.internal.disposables.SequentialDisposable;, +import io.reactivex.internal.operators.flowable.FlowableTimeoutTimed.TimeoutSupport;, + TimeoutSubscriber<T> parent = new TimeoutSubscriber<T>(s, itemTimeoutIndicator);, + s.onSubscribe(parent);, + parent.startFirstTimeout(firstTimeoutIndicator);, + source.subscribe(parent);, + TimeoutFallbackSubscriber<T> parent = new TimeoutFallbackSubscriber<T>(s, itemTimeoutIndicator, other);, + s.onSubscribe(parent);, + parent.startFirstTimeout(firstTimeoutIndicator);, + source.subscribe(parent);, + interface TimeoutSelectorSupport extends TimeoutSupport {, + void onTimeoutError(long idx, Throwable ex);, + }, +, + static final class TimeoutSubscriber<T> extends AtomicLong, + implements FlowableSubscriber<T>, Subscription, TimeoutSelectorSupport {, +, + private static final long serialVersionUID = 3764492702657003550L;, +, + final Function<? super T, ? extends Publisher<?>> itemTimeoutIndicator;, + final SequentialDisposable task;, + final AtomicReference<Subscription> upstream;, + final AtomicLong requested;, + TimeoutSubscriber(Subscriber<? super T> actual,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorMergeDelayError;, + return source.lift(new OperatorMergeDelayError<T>());, + return mergeDelayError(from(t1, t2));, + return mergeDelayError(from(t1, t2, t3));, + return mergeDelayError(from(t1, t2, t3, t4));, + return mergeDelayError(from(t1, t2, t3, t4, t5));, + return mergeDelayError(from(t1, t2, t3, t4, t5, t6));, + return mergeDelayError(from(t1, t2, t3, t4, t5, t6, t7));, + return mergeDelayError(from(t1, t2, t3, t4, t5, t6, t7, t8));, + return mergeDelayError(from(t1, t2, t3, t4, t5, t6, t7, t8, t9));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorMergeDelayError;, + return source.lift(new OperatorMergeDelayError<T>());, + return mergeDelayError(from(t1, t2));, + return mergeDelayError(from(t1, t2, t3));, + return mergeDelayError(from(t1, t2, t3, t4));, + return mergeDelayError(from(t1, t2, t3, t4, t5));, +
[+++ b/src/main/java/io/reactivex/Completable.java, + * <p>, + * <img width="640" height="518" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.ambArray.png" alt="">, + * <p>, + * <img width="640" height="518" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.amb.png" alt="">, + * <p>, + * <img width="640" height="472" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.complete.png" alt="">, + * <p>, + * <img width="640" height="283" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concatArray.png" alt="">, + * <p>, + * <img width="640" height="303" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concat.png" alt="">, + * <p>, + * <img width="640" height="237" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concat.p.png" alt="">, + * <p>, + * <img width="640" height="237" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concat.pn.png" alt="">, + * <p>, + * <img width="640" height="298" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.defer.png" alt="">, + * <img width="640" height="462" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.error.f.png" alt="">, + * <p>, + * <p>, + * <img width="640"
[+++ b/src/main/java/io/reactivex/internal/operators/PublisherCombineLatest.java, + q.clear();, + Object last = "1";, +++ b/src/main/java/io/reactivex/internal/operators/PublisherCombineLatest.java, + q.clear();, + Object last = "1";, +++ b/src/main/java/io/reactivex/internal/operators/nbp/NbpOnSubscribeCombineLatest.java, +import java.util.Queue;, + q.clear();, + Object last = "1";, +++ b/src/main/java/io/reactivex/internal/operators/PublisherCombineLatest.java, + q.clear();, + Object last = "1";, +++ b/src/main/java/io/reactivex/internal/operators/nbp/NbpOnSubscribeCombineLatest.java, +import java.util.Queue;, + q.clear();, + Object last = "1";, +++ b/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java, + } else if (null == lvElement(buffer, calcWrappedOffset(index + 1, mask))) { // buffer is not full]
[+++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/gradle.properties, +version=0.17.0-SNAPSHOT, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/gradle.properties, +version=0.17.0-SNAPSHOT, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/gradle.properties, +version=0.17.0-SNAPSHOT, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/gradle.properties, +version=0.17.0-SNAPSHOT, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscription { }, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/gradle.properties, +version=0.17.0-SNAPSHOT, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscription { }, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/gradle.properties, +version=0.17.0-SNAPSHOT, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, +
[+++ /dev/null, +++ /dev/null, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java, +package rx.android.observables;, +, +import rx.Observable;, +import rx.operators.OperationObserveFromAndroidComponent;, +, +import android.app.Activity;, +import android.app.Fragment;, +, +public final class AndroidObservable {, +, + private AndroidObservable() {}, +, + public static <T> Observable<T> fromActivity(Activity activity, Observable<T> sourceObservable) {, + return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, activity);, + }, +, + public static <T> Observable<T> fromFragment(Fragment fragment, Observable<T> sourceObservable) {, + return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, fragment);, + }, +, + public static <T> Observable<T> fromFragment(android.support.v4.app.Fragment fragment, Observable<T> sourceObservable) {, + return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, fragment);, + }, +, +}]
[+++ b/gradle.properties, +version=0.17.1-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Observable.java, + , + @SafeVarargs, + public static <T> Observable<T> amb(Publisher<? extends T>... sources) {, + Objects.requireNonNull(sources);, + int len = sources.length;, + if (len == 0) {, + return empty();, + } else, + if (len == 1) {, + return fromPublisher(sources[0]);, + }, + return create(new PublisherAmb<>(sources, null));, + }, + , + public static <T> Observable<T> amb(Iterable<? extends Publisher<? extends T>> sources) {, + Objects.requireNonNull(sources);, + return create(new PublisherAmb<>(null, sources));, + }, + , + public Observable<T> ambWith(Publisher<? extends T> other) {, + return amb(this, other);, + }, +++ b/src/main/java/io/reactivex/Observable.java, + , + @SafeVarargs, +
[+++ /dev/null, +++ /dev/null, +++ b/src/main/java/io/reactivex/internal/schedulers/IoScheduler.java, +/**, + * Copyright 2016 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
[+++ b/src/main/java/io/reactivex/Observable.java, + * Unlike 1.x, disposing the Observable won't cancel the future. If necessary, one can use composition to achieve the, + * cancellation effect: {@code futureObservableSource.doOnDispose(() -> future.cancel(true));}., + * Unlike 1.x, disposing the Observable won't cancel the future. If necessary, one can use composition to achieve the, + * cancellation effect: {@code futureObservableSource.doOnDispose(() -> future.cancel(true));}., + * Unlike 1.x, disposing the Observable won't cancel the future. If necessary, one can use composition to achieve the, + * cancellation effect: {@code futureObservableSource.doOnDispose(() -> future.cancel(true));}., + * Unlike 1.x, disposing the Observable won't cancel the future. If necessary,
[+++ b/src/main/java/io/reactivex/observers/package-info.java, + * the {@link io.reactivex.observers.TestObserver} that allows unit testing, +++ b/src/main/java/io/reactivex/observers/package-info.java, + * the {@link io.reactivex.observers.TestObserver} that allows unit testing, +++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapCompletableTest.java, + TestObserver<Void> to = us.concatMapCompletable(completableComplete(), 2).test();, + TestObserver<Void> to = us.hide().concatMapCompletable(completableComplete(), 2).test();, + TestObserver<Void> to = ps1.concatMapCompletable(new Function<Integer, CompletableSource>() {]
[+++ b/.travis.yml, + , +sudo: false, +# as per http://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/, +++ b/.travis.yml, + , +sudo: false, +# as per http://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/, +++ b/CHANGES.md, +### Version 1.0.4 – December 29th 2014 ([Maven Central](http://search.maven.org/#artifactdetails%7Cio.reactivex%7Crxjava%7C1.0.4%7C)) ###, +, +* [Pull 2156] (https://github.com/ReactiveX/RxJava/pull/2156) Fix the issue that map may swallow fatal exceptions, +* [Pull 1967] (https://github.com/ReactiveX/RxJava/pull/1967) Fix the issue that GroupBy may not call 'unsubscribe', +* [Pull 2052] (https://github.com/ReactiveX/RxJava/pull/2052) OperatorDoOnRequest.ParentSubscriber should be static class, +* [Pull 2237] (https://github.com/ReactiveX/RxJava/pull/2237) Make Publish Operator Release RingBuffer, +* [Pull 2053] (https://github.com/ReactiveX/RxJava/pull/2053) Fixed wrong bounded ReplaySubject use in test, +, +### Version 1.0.3 – December 15th 2014 ([Maven Central](http://search.maven.org/#artifactdetails%7Cio.reactivex%7Crxjava%7C1.0.3%7C)) ###,
[+++ b/gradle.properties, +version=0.13.2-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * if {@code onComplete} is null, or, + * if {@code onSubscribe} is null, +++ b/src/main/java/io/reactivex/Flowable.java, + * if {@code onComplete} is null, or, + * if {@code onSubscribe} is null, +++ b/src/main/java/io/reactivex/Observable.java, + * if {@code onComplete} is null, or, + * if {@code onSubscribe} is null]
[+++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java, + ObjectHelper.requireNonNull(run, "run is null");, +, +++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java, + ObjectHelper.requireNonNull(run, "run is null");, +, +++ b/src/test/java/io/reactivex/plugins/RxJavaPluginsTest.java, +++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java, + ObjectHelper.requireNonNull(run, "run is null");, +, +++ b/src/test/java/io/reactivex/plugins/RxJavaPluginsTest.java, +++ b/src/test/java/io/reactivex/schedulers/AbstractSchedulerTests.java, +, + @Test, + public void scheduleDirectNullRunnable() {, + try {, + getScheduler().scheduleDirect(null);, + fail();, + } catch (NullPointerException npe) {, + assertEquals("run is null", npe.getMessage());, + }, + }, +, + @Test, + public void scheduleDirectWithDelayNullRunnable() {, + try {, + getScheduler().scheduleDirect(null, 10, TimeUnit.MILLISECONDS);, + fail();, + } catch (NullPointerException npe) {, + assertEquals("run is null", npe.getMessage());, + }, + }, +, + @Test, + public void schedulePeriodicallyDirectNullRunnable()
[+++ b/src/main/java/io/reactivex/Completable.java, + , + /**, + * Returns a Completable instance that runs the given Action for each subscriber and, + * emits either an unchecked exception or simply completes., + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code fromAction} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + * @param run the runnable to run for each subscriber, + * @return the new Completable instance, + * @throws NullPointerException if run is null, + */, + @SchedulerSupport(SchedulerSupport.NONE), + public static Completable fromAction(final Action run) {, + Objects.requireNonNull(run, "run is null");, + return
[+++ b/gradle.properties, +version=0.20.0-RC3-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableTimer.java, +import java.util.concurrent.atomic.AtomicReference;, +import io.reactivex.disposables.Disposable;, +import io.reactivex.internal.disposables.DisposableHelper;, +/**, + * Signals an {@code onCompleted} event after the specified delay, + */, + TimerDisposable parent = new TimerDisposable(s);, + s.onSubscribe(parent);, + parent.setFuture(scheduler.scheduleDirect(parent, delay, unit));, + static final class TimerDisposable extends AtomicReference<Disposable> implements Disposable, Runnable {, + /** */, + private static final long serialVersionUID = 3167244060586201109L;, + final CompletableObserver actual;, +, + TimerDisposable(final CompletableObserver actual) {, + this.actual = actual;, + }, +, + @Override, + public void run() {, + actual.onComplete();, + }, +, + @Override, + public void dispose() {, + DisposableHelper.dispose(this);, + }, +, + @Override,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorTimeInterval;, +import rx.operators.OperationUsing;, + public final static <T, RESOURCE extends Subscription> Observable<T> using(Func0<RESOURCE> resourceFactory, Func1<RESOURCE, Observable<T>> observableFactory) {, + return create(OperationUsing.using(resourceFactory, observableFactory));, + return lift(new OperatorTimeInterval(Schedulers.immediate()));, + return lift(new OperatorTimeInterval(scheduler));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorTimeInterval;, +import rx.operators.OperationUsing;, + public final static <T, RESOURCE extends Subscription> Observable<T> using(Func0<RESOURCE> resourceFactory, Func1<RESOURCE, Observable<T>> observableFactory) {, + return create(OperationUsing.using(resourceFactory, observableFactory));, + return lift(new OperatorTimeInterval(Schedulers.immediate()));, + return lift(new OperatorTimeInterval(scheduler));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorTimeInterval;, +import rx.operators.OperationUsing;, + public final static <T, RESOURCE extends Subscription> Observable<T> using(Func0<RESOURCE> resourceFactory, Func1<RESOURCE, Observable<T>> observableFactory) {, + return create(OperationUsing.using(resourceFactory, observableFactory));, + return lift(new OperatorTimeInterval(Schedulers.immediate()));, + return
[+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java, +, + @Test, + public void oneDelayed() {, + Flowable.just(1, 2, 3, 4, 5), + .concatMapEager(new Function<Integer, Flowable<Integer>>() {, + @Override, + public Flowable<Integer> apply(Integer i) throws Exception {, + return i == 3 ? Flowable.just(i) : Flowable, + .just(i), + .delay(1, TimeUnit.MILLISECONDS, Schedulers.io());, + }, + }), + .observeOn(Schedulers.io()), + .test(), + .awaitDone(5, TimeUnit.SECONDS), + .assertResult(1, 2, 3, 4, 5), + ;, + }, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEagerTest.java, +, + @Test, + public void oneDelayed() {, + Flowable.just(1, 2, 3, 4, 5), + .concatMapEager(new Function<Integer, Flowable<Integer>>() {, + @Override, + public Flowable<Integer>
[+++ b/gradle.properties, +version=0.5.5-SNAPSHOT, +++ b/gradle.properties, +version=0.5.5-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.observables.GroupedObservable;, + /*package*/ Observable(Func1<Observer<T>, Subscription> onSubscribe, boolean isTrusted) {, + * Groups the elements of an observable and selects the resulting elements by using a specified function., + *, + * @param source an observable whose elements to group., + * @param keySelector a function to extract the key for each element., + * @param elementSelector a function to map each source element to an element in an observable group., + * @param <K> the key type., + * @param <T> the source type., + * @param <R> the resulting
[+++ b/.gitignore, +, +#PMD files, +.pmd, +.ruleset, +, +#Android Studio, +local.properties]
[+++ b/gradle.properties, +version=0.1.1-SNAPSHOT]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationWindow;, +import rx.util.Closing;, +import rx.util.Opening;, + * For more information see the <a href="https://github.com/Netflix/RxJava/wiki/Observable">RxJava, + * Wiki</a>, + //TODO use a consistent parameter naming scheme (for example: for all operators that modify a source Observable, the parameter representing that source Observable should have the same name, e.g. "source" -- currently such parameters are named any of "sequence", "that", "source", "items", or "observable"), + private final static RxJavaObservableExecutionHook hook = RxJavaPlugins.getInstance().getObservableExecutionHook();, + private final Func1<Observer<T>, Subscription> onSubscribe;, + * NOTE: Use {@link #create(Func1)} to create an Observable instead of this method unless you, + * {@link Func1}
[+++ b/src/jmh/java/io/reactivex/MemoryPerf.java, + org.reactivestreams.Subscription upstream;, + this.upstream = s;, + Disposable upstream;, + public void onSubscribe(Disposable d) {, + this.upstream = d;, +++ b/src/jmh/java/io/reactivex/MemoryPerf.java, + org.reactivestreams.Subscription upstream;, + this.upstream = s;, + Disposable upstream;, + public void onSubscribe(Disposable d) {, + this.upstream = d;, +++ b/src/main/java/io/reactivex/Completable.java, + * public void onSubscribe(Disposable d) {, + * d.dispose();, + * upstream = d;, +++ b/src/jmh/java/io/reactivex/MemoryPerf.java, + org.reactivestreams.Subscription upstream;, + this.upstream = s;, + Disposable upstream;, + public void onSubscribe(Disposable d) {, + this.upstream = d;, +++ b/src/main/java/io/reactivex/Completable.java, + * public void onSubscribe(Disposable d) {, + * d.dispose();, + * upstream =
[+++ b/src/main/java/io/reactivex/internal/operators/single/SingleFlatMap.java, +import io.reactivex.internal.disposables.DisposableHelper;, +import io.reactivex.internal.functions.ObjectHelper;, +import java.util.concurrent.atomic.AtomicReference;, + protected void subscribeActual(SingleObserver<? super R> actual) {, + source.subscribe(new SingleFlatMapCallback<T, R>(actual, mapper));, + static final class SingleFlatMapCallback<T, R>, + extends AtomicReference<Disposable>, + implements SingleObserver<T>, Disposable {, + }, +, + @Override, + public void dispose() {, + DisposableHelper.dispose(this);, + }, +, + @Override, + public boolean isDisposed() {, + return DisposableHelper.isDisposed(get());, + if (DisposableHelper.setOnce(this, d)) {, + actual.onSubscribe(this);, + }, + o = ObjectHelper.requireNonNull(mapper.apply(value), "The single returned by the mapper is null");, + o.subscribe(new FlatMapSingleObserver<R>(this, actual));, + public void onError(Throwable e) {, + actual.onError(e);, + }, +, + static final
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java, + collection = ObjectHelper.requireNonNull(collectionSupplier.call(), "The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java, + collection = ObjectHelper.requireNonNull(collectionSupplier.call(), "The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDistinct.java, + collection = ObjectHelper.requireNonNull(collectionSupplier.call(), "The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java, + collection = ObjectHelper.requireNonNull(collectionSupplier.call(), "The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDistinct.java, + collection = ObjectHelper.requireNonNull(collectionSupplier.call(), "The
[+++ b/.travis.yml, + , +sudo: false, +# as per http://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/, +++ b/.travis.yml, + , +sudo: false, +# as per http://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/, +++ b/CHANGES.md, +### Version 1.0.4 – December 29th 2014 ([Maven Central](http://search.maven.org/#artifactdetails%7Cio.reactivex%7Crxjava%7C1.0.4%7C)) ###, +, +* [Pull 2156] (https://github.com/ReactiveX/RxJava/pull/2156) Fix the issue that map may swallow fatal exceptions, +* [Pull 1967] (https://github.com/ReactiveX/RxJava/pull/1967) Fix the issue that GroupBy may not call 'unsubscribe', +* [Pull 2052] (https://github.com/ReactiveX/RxJava/pull/2052) OperatorDoOnRequest.ParentSubscriber should be static class, +* [Pull 2237] (https://github.com/ReactiveX/RxJava/pull/2237) Make Publish Operator Release RingBuffer, +* [Pull 2053] (https://github.com/ReactiveX/RxJava/pull/2053) Fixed wrong bounded ReplaySubject use in test, +, +### Version 1.0.3 – December 15th 2014 ([Maven Central](http://search.maven.org/#artifactdetails%7Cio.reactivex%7Crxjava%7C1.0.3%7C)) ###,
[+++ b/build.gradle, + // perf //-> Not working so commented out, +++ b/build.gradle, + // perf //-> Not working so commented out, +++ b/rxjava-core/build.gradle, +++ b/build.gradle, + // perf //-> Not working so commented out, +++ b/rxjava-core/build.gradle, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.observers.SafeSubscriber;, +import rx.operators.OperationTakeTimed;, + * {@link OnSubscribeFunc} to be executed when {@link #subscribe(Subscriber)} is called, + * Returns an Observable that will execute the specified function when an {@link Subscriber} subscribes to it., + * invoke the Observer's {@link Subscriber#onNext onNext}, {@link Subscriber#onError onError}, and {@link Subscriber#onCompleted onCompleted} methods appropriately., + * @return an Observable that, when an {@link
[+++ b/build.gradle, +project(':rxjava') {, +++ b/build.gradle, +project(':rxjava') {, +++ b/gradle.properties, +version=1.0.0-RC1-SNAPSHOT, +++ b/build.gradle, +project(':rxjava') {, +++ b/gradle.properties, +version=1.0.0-RC1-SNAPSHOT, +++ /dev/null, +++ b/build.gradle, +project(':rxjava') {, +++ b/gradle.properties, +version=1.0.0-RC1-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ b/build.gradle, +project(':rxjava') {, +++ b/gradle.properties, +version=1.0.0-RC1-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/build.gradle, +project(':rxjava') {, +++ b/gradle.properties, +version=1.0.0-RC1-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/build.gradle, +project(':rxjava') {, +++ b/gradle.properties, +version=1.0.0-RC1-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/build.gradle, +project(':rxjava') {, +++ b/gradle.properties, +version=1.0.0-RC1-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/build.gradle, +project(':rxjava') {,
[+++ b/src/main/java/io/reactivex/Maybe.java, + public static <T> Maybe<T> fromSingle(SingleSource<T> singleSource) {, +++ b/src/main/java/io/reactivex/Maybe.java, + public static <T> Maybe<T> fromSingle(SingleSource<T> singleSource) {, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeDoOnEvent.java, + this.d = d;, +, +++ b/src/main/java/io/reactivex/Maybe.java, + public static <T> Maybe<T> fromSingle(SingleSource<T> singleSource) {, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeDoOnEvent.java, + this.d = d;, +, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeEqualSingle.java, + return DisposableHelper.isDisposed(observer1.get());, + implements MaybeObserver<T> {, +++ b/src/main/java/io/reactivex/Maybe.java, + public static <T> Maybe<T> fromSingle(SingleSource<T> singleSource) {, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeDoOnEvent.java, + this.d = d;, +, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeEqualSingle.java, + return DisposableHelper.isDisposed(observer1.get());, + implements MaybeObserver<T> {, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeFlatMapIterableFlowable.java, + void fastPath(Subscriber<? super R> a, Iterator<? extends R> iter) {, + void drain() {, + if (getAndIncrement()
[+++ b/gradle.properties, +version=0.15.1-SNAPSHOT]
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.8.2-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.8.2-SNAPSHOT, +++ b/language-adaptors/README.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.8.2-SNAPSHOT, +++ b/language-adaptors/README.md, +++ b/language-adaptors/rxjava-clojure/build.gradle, + provided 'junit:junit:4.10', +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.8.2-SNAPSHOT, +++ b/language-adaptors/README.md, +++ b/language-adaptors/rxjava-clojure/build.gradle, + provided 'junit:junit:4.10', +++ b/language-adaptors/rxjava-groovy/README.md, + Observable.toObservable("one", "two", "three"), +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.8.2-SNAPSHOT, +++ b/language-adaptors/README.md, +++ b/language-adaptors/rxjava-clojure/build.gradle, + provided 'junit:junit:4.10', +++ b/language-adaptors/rxjava-groovy/README.md, + Observable.toObservable("one", "two", "three"), +++ b/language-adaptors/rxjava-groovy/build.gradle, + provided 'junit:junit:4.10', +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.8.2-SNAPSHOT, +++ b/language-adaptors/README.md, +++ b/language-adaptors/rxjava-clojure/build.gradle, + provided 'junit:junit:4.10', +++ b/language-adaptors/rxjava-groovy/README.md, + Observable.toObservable("one", "two", "three"), +++ b/language-adaptors/rxjava-groovy/build.gradle, + provided 'junit:junit:4.10', +++ b/language-adaptors/rxjava-groovy/src/examples/groovy/rx/lang/groovy/examples/RxExamples.groovy, + Observable.toObservable(names), + Observable<Integer> o = Observable.toObservable(1,
[+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java, +, + @Test, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java, +, + @Test, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilTest.java, +, + @Test, + until.onNext(5);, +, + ts.assertComplete();, + ts.assertNoErrors();, +, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java, +, + @Test, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTakeUntilTest.java, +, + @Test, + until.onNext(5);, +, + ts.assertComplete();, + ts.assertNoErrors();, +, +++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableDelayTest.java, + @Test]
[+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableFromCallable.java, +import io.reactivex.plugins.RxJavaPlugins;, + } else {, + RxJavaPlugins.onError(e);]
[+++ b/gradle.properties, +version=0.5.2-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Completable.java, + * Note that by design, subscriptions via {@link #subscribe(CompletableObserver)} can't be disposed, + * terminates (normally or with an error) and disposes all other Completables., + * terminates (normally or with an error) and disposes all other Completables., + * to downstream disposal</strong>., + * Note that if any of the observers to this Completable call dispose, this Completable will cancel the future., + * {@code Completable} terminates with that {@code Throwable} and all other source {@code CompletableSource}s are disposed., + * signaled by source(s) after the returned {@code Completable} has been disposed or terminated with
[+++ b/src/main/java/io/reactivex/Observable.java, + public interface NbpTransformer<Upstream, Downstream> extends Function<Observable<Upstream>, ObservableConsumable<Downstream>> {, + public static <T> Observable<T> amb(Iterable<? extends ObservableConsumable<? extends T>> sources) {, + public static <T> Observable<T> amb(ObservableConsumable<? extends T>... sources) {, + return (Observable<T>)sources[0]; // FIXME wrap(), + public static <T, R> Observable<R> combineLatest(Function<? super Object[], ? extends R> combiner, boolean delayError, int bufferSize, ObservableConsumable<? extends T>... sources) {, + public static <T, R> Observable<R> combineLatest(Iterable<? extends ObservableConsumable<? extends T>> sources, Function<? super Object[], ? extends R> combiner) {, + public static <T, R> Observable<R> combineLatest(Iterable<? extends ObservableConsumable<? extends T>> sources, Function<? super Object[], ? extends R>
[+++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/observables/ConnectableObservable.java, +]
[+++ b/src/main/java/io/reactivex/Maybe.java, + * @param transformer the transformer function, not null, + public final <R> Maybe<R> compose(MaybeTransformer<T, R> transformer) {, +++ b/src/main/java/io/reactivex/Maybe.java, + * @param transformer the transformer function, not null, + public final <R> Maybe<R> compose(MaybeTransformer<T, R> transformer) {, +++ b/src/main/java/io/reactivex/Single.java, + * @param transformer the transformer function, not null, + public final <R> Single<R> compose(SingleTransformer<T, R> transformer) {, +++ b/src/main/java/io/reactivex/Maybe.java, + * @param transformer the transformer function, not null, + public final <R> Maybe<R> compose(MaybeTransformer<T, R> transformer) {, +++ b/src/main/java/io/reactivex/Single.java, + * @param transformer the transformer function, not null, + public final <R> Single<R> compose(SingleTransformer<T, R> transformer)
[+++ b/gradle.properties, +version=0.19.0]
[+++ /dev/null, +++ /dev/null, +++ b/src/main/java/io/reactivex/Completable.java, + return new CompletableFromUnsafeSource(source);, + * Constructs a Completable instance by wrapping the given source callback., + * @param source the callback which will receive the CompletableObserver instances, + * when the Completable is subscribed to., + * @return the created Completable instance, + * @throws NullPointerException if source is null, + */, + @SchedulerSupport(SchedulerSupport.NONE), + public static Completable unsafeCreate(CompletableSource source) {, + Objects.requireNonNull(source, "source is null");, + if (source instanceof Completable) {, + throw new IllegalArgumentException("Use of unsafeCreate(Completable)!");, + }, + try {, + // TODO plugin wrapping source, + , +
[+++ b/src/main/java/io/reactivex/Flowable.java, + * for example using {@code map(CharSequence::toString)} or {@code map(list -> Collections.unmodifiableList(new ArrayList<>(list)))}., + * for example using {@code map(CharSequence::toString)} or {@code map(list -> Collections.unmodifiableList(new ArrayList<>(list)))}., + * for example using {@code map(CharSequence::toString)} or {@code map(list -> Collections.unmodifiableList(new ArrayList<>(list)))}., +++ b/src/main/java/io/reactivex/Flowable.java, + * for example using {@code map(CharSequence::toString)} or {@code map(list -> Collections.unmodifiableList(new ArrayList<>(list)))}., + * for example using {@code map(CharSequence::toString)} or {@code map(list -> Collections.unmodifiableList(new ArrayList<>(list)))}., + * for example using {@code map(CharSequence::toString)} or {@code map(list -> Collections.unmodifiableList(new ArrayList<>(list)))}., +++ b/src/main/java/io/reactivex/Observable.java, + * for example using {@code map(CharSequence::toString)} or {@code map(list -> Collections.unmodifiableList(new ArrayList<>(list)))}., + *
[+++ b/rxjava-core/src/main/java/rx/internal/util/MpscPaddedQueue.java, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not, + * use this file except in compliance with the License. You may obtain a copy of, + * the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for
[+++ b/src/main/java/io/reactivex/MaybeObserver.java, + * @param t, + void onSuccess(T t);, +++ b/src/main/java/io/reactivex/MaybeObserver.java, + * @param t, + void onSuccess(T t);, +++ b/src/main/java/io/reactivex/Observer.java, + * @param t, + void onNext(T t);, +++ b/src/main/java/io/reactivex/MaybeObserver.java, + * @param t, + void onSuccess(T t);, +++ b/src/main/java/io/reactivex/Observer.java, + * @param t, + void onNext(T t);, +++ b/src/main/java/io/reactivex/SingleObserver.java, + * @param t, + void onSuccess(T t);]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, + return create(new OperatorDelayWithSelector<T, U, V>(this, subscriptionDelay, itemDelay));
[+++ b/src/main/java/io/reactivex/subscribers/SafeSubscriber.java, + if (t2 == null) {, + t2 = new CompositeException(t, e);, + } else {, + }]
[+++ b/gradle.properties, +version=0.13.4-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/internal/operators/OperatorFlatMap.java, + // safeguard against misbehaving sources, + if (done) {, + return;, + }, + // safeguard against misbehaving sources, + if (done) {, + return;, + }, + // safeguard against misbehaving sources, + if (done) {, + return;, + }, +++ b/src/main/java/io/reactivex/internal/operators/OperatorFlatMap.java, + // safeguard against misbehaving sources, + if (done) {, + return;, + }, + // safeguard against misbehaving sources, + if (done) {, + return;, + }, + // safeguard against misbehaving sources, + if (done) {, + return;, + }, +++ b/src/main/java/io/reactivex/subscribers/TestSubscriber.java, + * @see #awaitTerminalEvent(), + * @return true if
[+++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +import rx.util.functions.Action1;, + lib.longMovies().asJavaObservable().subscribe(new Action1<Movie>() {, +, + @Override, + public void call(Movie m) {, + System.out.println("A movie of length " + m.lengthInSeconds() + "s");, + }, + });, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +import rx.util.functions.Action1;, + lib.longMovies().asJavaObservable().subscribe(new Action1<Movie>() {, +, + @Override, + public void call(Movie m) {, + System.out.println("A movie of length " + m.lengthInSeconds() + "s");, + }, + });, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +import rx.util.functions.Action1;, + lib.longMovies().asJavaObservable().subscribe(new Action1<Movie>() {, +, + @Override, + public void call(Movie m) {, + System.out.println("A movie of length " + m.lengthInSeconds() + "s");, + }, + });, +++ /dev/null, +++ /dev/null,
[+++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java, + @SuppressWarnings({ "unchecked", "rawtypes", "cast" }), + return (U)assertError((Predicate)Functions.isInstanceOf(errorClass));]
[+++ b/gradle.properties, +version=0.18.4-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Throttles items from the upstream {@code Flowable} by first emitting the next, + * item from upstream, then periodically emitting the latest item (if any) when, + * the specified timeout elapses between them., + * <p>, + * <img width="640" height="325" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLatest.png" alt="">, + * <p>, + * Unlike the option with {@link #throttleLatest(long, TimeUnit, boolean)}, the very last item being held back, + * (if any) is not emitted when the upstream completes., + * <p>, + * If no items were emitted from the upstream during this timeout phase, the next, +
[+++ b/src/main/java/io/reactivex/Observable.java, + public final Observable<T> just(T v1, T v2) {, + Objects.requireNonNull(v1);, + Objects.requireNonNull(v2);, + , + return fromArray(v1, v2);, + }, + , + public final Observable<T> just(T v1, T v2, T v3) {, + Objects.requireNonNull(v1);, + Objects.requireNonNull(v2);, + Objects.requireNonNull(v3);, + , + return fromArray(v1, v2, v3);, + }, + , + public final Observable<T> just(T v1, T v2, T v3, T v4) {, + Objects.requireNonNull(v1);, + Objects.requireNonNull(v2);, + Objects.requireNonNull(v3);, + Objects.requireNonNull(v4);, + , + return fromArray(v1, v2, v3, v4);, + }, + , + public final Observable<T> just(T v1, T v2, T v3, T v4, T
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java, +import java.util.concurrent.atomic.AtomicReference;, +import io.reactivex.internal.disposables.DisposableHelper;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java, +import java.util.concurrent.atomic.AtomicReference;, +import io.reactivex.internal.disposables.DisposableHelper;, +++ b/src/main/java/io/reactivex/processors/ReplayProcessor.java, +import io.reactivex.annotations.CheckReturnValue;, + b.add(t);, + Object o = NotificationLite.error(t);, + ReplayBuffer<T> b = buffer;, +, + b.addFinal(o);, + Object o = NotificationLite.complete();, +, + b.addFinal(o);, + Object o = buffer.get();, + if (NotificationLite.isError(o)) {, + return NotificationLite.getError(o);, + Object o = buffer.get();, + return NotificationLite.isComplete(o);, + Object o = buffer.get();, + return NotificationLite.isError(o);, + void add(T value);, + void addFinal(Object notificationLite);, + /**, + * Returns the terminal NotificationLite object or null if not yet terminated., + * @return the terminal NotificationLite object or null
[+++ b/rxjava-core/src/main/java/rx/observables/Observable.java, + private final boolean isTrusted;, + this(onSubscribe, false);, + }, +, + private Observable(Func1<Observer<T>, Subscription> onSubscribe, boolean isTrusted) {, + this.isTrusted = isTrusted;, + if (isTrusted) {, + AtomicObservableSubscription subscription = new AtomicObservableSubscription();, + return subscription.wrap(onSubscribe.call(new AtomicObserver<T>(subscription, observer)));, + /*, + * Private version that creates a 'trusted' Observable to allow performance optimizations., + */, + private static <T> Observable<T> _create(Func1<Observer<T>, Subscription> func) {, + return new Observable<T>(func, true);, + }, +, + return _create(new Func1<Observer<T>, Subscription>() {, + return _create(OperationFilter.filter(that, predicate));, + return _create(OperationLast.last(that));, + return _create(OperationMap.map(sequence, func));, + return _create(OperationMap.mapMany(sequence, func));, + return _create(OperationMaterialize.materialize(sequence));, +
[+++ b/src/main/java/io/reactivex/functions/Function.java]
[+++ b/src/main/java/io/reactivex/Observable.java, + , + // TODO would result in ambiguity with onErrorReturn(Function), + public Observable<T> onErrorReturnValue(T value) {, + Objects.requireNonNull(value);, + return onErrorReturn(e -> value);, + }, + , + public Observable<T> onErrorReturn(Function<? super Throwable, ? extends T> valueSupplier) {, + Objects.requireNonNull(valueSupplier);, + return lift(new OperatorOnErrorReturn<>(valueSupplier));, + }, + , + public Observable<T> onErrorResumeNext(Publisher<? extends T> next) {, + Objects.requireNonNull(next);, + return onErrorResumeNext(e -> next);, + }, + , + public Observable<T> onErrorResumeNext(Function<? super Throwable, ? extends Publisher<? extends T>> resumeFunction) {, + Objects.requireNonNull(resumeFunction);, + return lift(new OperatorOnErrorNext<>(resumeFunction, false));, + }, + , + public Observable<T> onExceptionResumeNext(Publisher<? extends
[+++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.observers.TestObserver;, + * Creates a TestObserver and subscribes, + * @return the new TestObserver instance, + public final TestObserver<Void> test() {, + TestObserver<Void> ts = new TestObserver<Void>();, + subscribe(ts);, + * Creates a TestObserver optionally in cancelled state, then subscribes it to this Completable., + * @param cancelled if true, the TestObserver will be cancelled before subscribing to this, + * @return the new TestObserver instance, + public final TestObserver<Void> test(boolean cancelled) {, + TestObserver<Void> ts = new TestObserver<Void>();, + subscribe(ts);, +++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.observers.TestObserver;, + * Creates a TestObserver and subscribes, + * @return the
[+++ b/src/main/java/io/reactivex/internal/observers/LambdaObserver.java, + } else {, + RxJavaPlugins.onError(t);, +++ b/src/main/java/io/reactivex/internal/observers/LambdaObserver.java, + } else {, + RxJavaPlugins.onError(t);, +++ b/src/test/java/io/reactivex/internal/observers/LambdaObserverTest.java, +import java.io.IOException;, +, + @Test, + public void disposedObserverShouldReportErrorOnGlobalErrorHandler() {, + List<Throwable> errors = TestHelper.trackPluginErrors();, + try {, + final List<Throwable> observerErrors = Collections.synchronizedList(new ArrayList<Throwable>());, +, + LambdaObserver<Integer> o = new LambdaObserver<Integer>(Functions.<Integer>emptyConsumer(),, + new Consumer<Throwable>() {, + @Override, + public void accept(Throwable t) {, + observerErrors.add(t);, + }, + },, + Functions.EMPTY_ACTION,, + Functions.<Disposable>emptyConsumer());, +, + o.dispose();, + o.onError(new IOException());, + o.onError(new IOException());, +, + assertTrue(observerErrors.isEmpty());, + TestHelper.assertUndeliverable(errors, 0, IOException.class);, + TestHelper.assertUndeliverable(errors, 1, IOException.class);, + } finally {, + RxJavaPlugins.reset();, +
[+++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip]
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.9.1-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.9.1-SNAPSHOT, +++ b/gradle/convention.gradle, + configurations.add('sources'), + configurations.add('javadoc'), +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.9.1-SNAPSHOT, +++ b/gradle/convention.gradle, + configurations.add('sources'), + configurations.add('javadoc'), +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.9.1-SNAPSHOT, +++ b/gradle/convention.gradle, + configurations.add('sources'), + configurations.add('javadoc'), +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationBuffer;, +import rx.util.BufferClosing;, +import rx.util.BufferOpening;, + * It provides overloaded methods for subscribing as well as delegate methods to the various operators., + * For more information see the <a href="https://github.com/Netflix/RxJava/wiki/Observable">RxJava Wiki</a>, + protected Observable() {, + this(null);, + }, +, + * Construct an Observable with Function to execute when subscribed
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublishMulticast.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublishMulticast.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java, + s.cancel();, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublishMulticast.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java, + s.cancel();, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableTimeoutTimed.java, + s.dispose();, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublishMulticast.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java, + s.cancel();, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableTimeoutTimed.java, + s.dispose();, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowablePublishFunctionTest.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublishMulticast.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java, + s.cancel();, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableTimeoutTimed.java, + s.dispose();, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowablePublishFunctionTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTests.java, +, + @Test, + public void timedTake() {, + PublishProcessor<Integer> ps = PublishProcessor.create();, +, + TestSubscriber<Integer> to = ps.timeout(1, TimeUnit.DAYS), + .take(1), + .test();, +, + assertTrue(ps.hasSubscribers());, +, + ps.onNext(1);, +, + assertFalse(ps.hasSubscribers());, +, + to.assertResult(1);, + }, +, + @Test, + public void timedFallbackTake() {, + PublishProcessor<Integer> ps = PublishProcessor.create();, +, + TestSubscriber<Integer> to
[+++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/TestParallel.groovy, +/**, + * Copyright 2013 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java, + final void trimHead() {, + Node head = get();, + if (head.value != null) {, + Node n = new Node(null, 0L);, + n.lazySet(head.get());, + set(n);, + }, + }, +, + trimHead();, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java, + final void trimHead() {, + Node head = get();, + if (head.value != null) {, + Node n = new Node(null, 0L);, + n.lazySet(head.get());, + set(n);, + }, + }, +, + trimHead();, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java, +, + final void trimHead() {, + Node head = get();, + if (head.value != null) {, + Node n = new Node(null);, + n.lazySet(head.get());,
[+++ b/language-adaptors/rxjava-scala-java/README.md, +, +rxjava-scala-java, +-----------------, +, +Contains examples illustrating how RxScala code can be used from Java., +++ b/language-adaptors/rxjava-scala-java/README.md, +, +rxjava-scala-java, +-----------------, +, +Contains examples illustrating how RxScala code can be used from Java., +++ b/language-adaptors/rxjava-scala-java/build.gradle, +, +apply plugin: 'osgi', +, +, +project(':language-adaptors:rxjava-scala-java') {, + //sourceSets.test.java.srcDir 'src/examples/java', + sourceSets.main.java.srcDir 'src/main/java', +}, +, +dependencies {, + compile 'org.scala-lang:scala-library:2.10.+', +, + compile project(':rxjava-core'), + , + compile project(':language-adaptors:rxjava-scala'), + , + provided 'junit:junit-dep:4.10', + provided 'org.mockito:mockito-core:1.8.5', + provided 'org.scalatest:scalatest_2.10:1.9.1', +}, +, +jar {, + manifest {, + name = 'rxjava-scala-java', + instruction 'Bundle-Vendor', 'Netflix', + instruction 'Bundle-DocURL', 'https://github.com/Netflix/RxJava', + instruction 'Import-Package',
[+++ b/gradle.properties, +version=0.16.1-SNAPSHOT, +++ b/gradle.properties, +version=0.16.1-SNAPSHOT, +++ b/rxjava-contrib/rxjava-android/src/test/java/rx/android/operators/OperationObserveFromAndroidComponentTest.java, +package rx.android.operators;, +import static org.junit.Assert.*;, +import static org.mockito.Matchers.*;, +import static org.mockito.Mockito.*;, +, +import java.lang.reflect.Constructor;, +import java.lang.reflect.Field;, +import java.lang.reflect.InvocationTargetException;, +import java.util.concurrent.Callable;, +import java.util.concurrent.Executors;, +import java.util.concurrent.Future;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.atomic.AtomicReference;, +import org.junit.Ignore;, +import rx.Observable.OnSubscribeFunc;, +import rx.operators.OperationObserveFromAndroidComponent;, +import rx.schedulers.Schedulers;, +import rx.subscriptions.BooleanSubscription;, +import rx.util.functions.Action1;, + final Observable<Integer> testObservable = Observable.from(1);, + testObservable, mockFragment).subscribe(mockObserver);, + // TODO needs to be fixed, see comments inline below, + @Ignore, + final Observable<Integer> testObservable = Observable.from(1), + .observeOn(Schedulers.newThread()), + .doOnNext(new Action1<Integer>() {, +, + @Override, + public void call(Integer t1) {, + System.out.println("threadA: " + Thread.currentThread());, + }, +
[+++ b/gradle.properties, +version=0.9.0-SNAPSHOT]
[+++ b/gradle.properties, +version=0.20.0-RC5]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java, + if (it == null) {, + return queue.isEmpty();, + }, + return !it.hasNext();, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterable.java, + if (it == null) {, + return queue.isEmpty();, + }, + return !it.hasNext();, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlattenIterableTest.java, +, + @Test, + public void doubleShare() {, + Iterable<Integer> it = Flowable.range(1, 300).blockingIterable();, + Flowable.just(it, it), + .flatMapIterable(Functions.<Iterable<Integer>>identity()), + .share(), + .share(), + .count(), + .test(), + .assertResult(600L);, + }, +, + @Test, + public void multiShare() {, + Iterable<Integer> it = Flowable.range(1, 300).blockingIterable();, + for (int i = 0; i < 5; i++) {, + Flowable<Integer> f = Flowable.just(it, it), + .flatMapIterable(Functions.<Iterable<Integer>>identity());, +,
[+++ b/.travis.yml, +, +script: gradle/buildViaTravis.sh, +after_success:, +- gradle/publishViaTravis.sh, +, +secure: "HzRt91B6CLkBCxRXlo7V+F5L8SSHSW8dgkO8nAlTnOIK73k3QelDeBlcm1wnuNa3x+54YS9WBv6QrTNZr9lVi/8IPfKpd+jtjIbCWRvh6aNhqLIXWTL7oTvUd4E8DDUAKB6UMae6SiBSy2wsFELGHXeNwg7EiPfxsd5sKRiS7H4=", +secure: "MSZLPasqNKAC+8qhKQD3xO+ZbuOy65HpUN+1+KnoOLMkHCu/f4x60W1tpTAzn1DFEVpokHR0n3I4z4HpWybURDQfDHD1bB4IsznjCUBYA9Uo9Sb0U4TS17dQr8s7SORIjHDLGNSWETJjrA9TfuUV6HTVhRO1ECx3H+wuTwCVDN0=", +++ b/.travis.yml, +, +script: gradle/buildViaTravis.sh, +after_success:, +- gradle/publishViaTravis.sh, +, +secure: "HzRt91B6CLkBCxRXlo7V+F5L8SSHSW8dgkO8nAlTnOIK73k3QelDeBlcm1wnuNa3x+54YS9WBv6QrTNZr9lVi/8IPfKpd+jtjIbCWRvh6aNhqLIXWTL7oTvUd4E8DDUAKB6UMae6SiBSy2wsFELGHXeNwg7EiPfxsd5sKRiS7H4=", +secure: "MSZLPasqNKAC+8qhKQD3xO+ZbuOy65HpUN+1+KnoOLMkHCu/f4x60W1tpTAzn1DFEVpokHR0n3I4z4HpWybURDQfDHD1bB4IsznjCUBYA9Uo9Sb0U4TS17dQr8s7SORIjHDLGNSWETJjrA9TfuUV6HTVhRO1ECx3H+wuTwCVDN0=", +++ b/gradle/buildViaTravis.sh, +#!/bin/bash, +# This script will build the project., +, +echo -e 'Build Script => Branch ['$TRAVIS_BRANCH'] Tag ['$TRAVIS_TAG']', +, +./gradlew -Prelease.useLastTag=true build, +++ b/.travis.yml, +, +script: gradle/buildViaTravis.sh, +after_success:, +- gradle/publishViaTravis.sh, +, +secure: "HzRt91B6CLkBCxRXlo7V+F5L8SSHSW8dgkO8nAlTnOIK73k3QelDeBlcm1wnuNa3x+54YS9WBv6QrTNZr9lVi/8IPfKpd+jtjIbCWRvh6aNhqLIXWTL7oTvUd4E8DDUAKB6UMae6SiBSy2wsFELGHXeNwg7EiPfxsd5sKRiS7H4=", +secure: "MSZLPasqNKAC+8qhKQD3xO+ZbuOy65HpUN+1+KnoOLMkHCu/f4x60W1tpTAzn1DFEVpokHR0n3I4z4HpWybURDQfDHD1bB4IsznjCUBYA9Uo9Sb0U4TS17dQr8s7SORIjHDLGNSWETJjrA9TfuUV6HTVhRO1ECx3H+wuTwCVDN0=", +++ b/gradle/buildViaTravis.sh, +#!/bin/bash, +# This script will build the project., +, +echo -e 'Build Script => Branch ['$TRAVIS_BRANCH'] Tag ['$TRAVIS_TAG']', +, +./gradlew -Prelease.useLastTag=true build, +++ b/gradle/publishViaTravis.sh, +#!/bin/bash, +# This script will upload to Bintray. It is
[+++ b/gradle.properties, +version=0.18.1]
[+++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java, + * Assert that the TestObserver/TestSubscriber received only the specified values in any order without terminating., + * @param expected the collection of values expected in any order, + * @return this;, + * @since 2.1.14 - experimental, + */, + @SuppressWarnings("unchecked"), + @Experimental, + public final U assertValueSetOnly(Collection<? extends T> expected) {, + return assertSubscribed(), + .assertValueSet(expected), + .assertNoErrors(), + .assertNotComplete();, + }, +, + /**, + * Assert that the TestObserver/TestSubscriber received only the specified values in the specified order without terminating., + * @param sequence the sequence of expected values in order, + *
[+++ b/.gitignore, +/.nb-gradle/profiles/private/, +.nb-gradle-properties, +/.nb-gradle/private/, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +.nb-gradle-properties, +/.nb-gradle/private/, +++ b/CHANGES.md, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +.nb-gradle-properties, +/.nb-gradle/private/, +++ b/CHANGES.md, +++ b/build.gradle, + mavenCentral() // maven { url 'http://jcenter.bintray.com' }, + mavenCentral() // maven { url: 'http://jcenter.bintray.com' }, + //include /src/examples folder, + //include /src/perf folder, + java {, + srcDir 'src/perf/java', + compileClasspath += main.output, + runtimeClasspath += main.output, + }, +, + dependencies {, + perfCompile 'org.openjdk.jmh:jmh-core:0.2', + }, + //include 'perf' in build task, + // dependsOn(perfClasses) //-> Not working so commented out, + // include 'provided' dependencies on the classpath, + plusConfigurations += configurations.provided, + //
[+++ b/src/main/java/io/reactivex/schedulers/TestScheduler.java, + /**, + * Creates a new TestScheduler with initial virtual time of zero., + */, + public TestScheduler() {, + // No-op., + }, +, + /**, + * Creates a new TestScheduler with the specified initial virtual time., + *, + * @param delayTime, + * the point in time to move the Scheduler's clock to, + * @param unit, + * the units of time that {@code delayTime} is expressed in, + */, + public TestScheduler(long delayTime, TimeUnit unit) {, + time = unit.toNanos(delayTime);, + }, +, +++ b/src/main/java/io/reactivex/schedulers/TestScheduler.java, + /**, + * Creates
[+++ b/.gitignore, +.m2, +target/, +build/, +bin/, +, +# Scala build, +*.cache, +++ b/.gitignore, +.m2, +target/, +build/, +bin/, +, +# Scala build, +*.cache, +++ b/CHANGES.md, +# RxJava Releases #, +, +### Version 0.6.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.6.1%22)) ###, +, +* [Pull 190](https://github.com/Netflix/RxJava/pull/190) Fix generics issue with materialize() that prevented chaining, +, +### Version 0.6.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.6.0%22)) ###, +, +* [Issue 154](https://github.com/Netflix/RxJava/issues/154) Add OSGi manifest headers, +* [Issue 173](https://github.com/Netflix/RxJava/issues/173) Subscription Utilities and Default Implementations, +* [Pull 184](https://github.com/Netflix/RxJava/pull/184) Convert 'last' from non-blocking to blocking to match Rx.Net (see [Issue 57](https://github.com/Netflix/RxJava/issues/57)), +, +*NOTE:* This is a version bump from 0.5 to 0.6 because [Issue 173](https://github.com/Netflix/RxJava/issues/173)
[+++ b/src/main/java/io/reactivex/disposables/BooleanDisposable.java, +import io.reactivex.internal.functions.Objects;, + private static final Runnable EMPTY = new Runnable() {, + private final AtomicReference<Runnable> run;, + Objects.requireNonNull(run, "run is null");, + this.run = new AtomicReference<Runnable>(run);, + if (r != null) {, + r = run.getAndSet(null);, + if (r != null) {, + return run.get() == null;, +++ b/src/main/java/io/reactivex/disposables/BooleanDisposable.java, +import io.reactivex.internal.functions.Objects;, + private static final Runnable EMPTY = new Runnable() {, + private final AtomicReference<Runnable> run;, + Objects.requireNonNull(run, "run is null");, + this.run = new AtomicReference<Runnable>(run);, + if (r != null) {, + r = run.getAndSet(null);, + if (r != null) {, + return run.get() ==
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationDebounce;, + * Debounces by dropping all values that are followed by newer values before the timeout value expires. The timer resets on each `onNext` call., + * <p>, + * Information on debounce vs throttle:, + * <p>, + * <ul>, + * <li>http://drupalmotion.com/article/debounce-and-throttle-visual-explanation</li>, + * <li>http://unscriptable.com/2009/03/20/debouncing-javascript-methods/</li>, + * <li>http://www.illyriad.co.uk/blog/index.php/2011/09/javascript-dont-spam-your-server-debounce-and-throttle/</li>, + * </ul>, + * @see {@link #throttleWithTimeout};, + public Observable<T> debounce(long timeout, TimeUnit unit) {, + return create(OperationDebounce.debounce(this, timeout, unit));, + * Debounces by dropping all values that are followed by newer values before the timeout value expires. The timer resets on each `onNext`
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Returns a Flowable that emits the item found at a specified index in a sequence of emissions from a, + * source Publisher., + * If the source Publisher does not contain the item at the specified index a {@link NoSuchElementException} will be thrown., + * <p>, + * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtOrDefault.png" alt="">, + * <dl>, + * <dt><b>Backpressure:</b></dt>, + * <dd>The operator honors backpressure from downstream and consumes the source {@code Publisher} in an unbounded manner, + * (i.e., no backpressure applied to it).</dd>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code elementAtOrError} does not
[+++ b/src/main/java/io/reactivex/Flowable.java, + private static void verifyPositive(int value, String paramName) {, + private static void verifyPositive(long value, String paramName) {, +++ b/src/main/java/io/reactivex/Flowable.java, + private static void verifyPositive(int value, String paramName) {, + private static void verifyPositive(long value, String paramName) {, +++ b/src/main/java/io/reactivex/Observable.java, + private static void verifyPositive(int value, String paramName) {, + private static void verifyPositive(long value, String paramName) {, +++ b/src/main/java/io/reactivex/Flowable.java, + private static void verifyPositive(int value, String paramName) {, + private static void verifyPositive(long value, String paramName) {, +++ b/src/main/java/io/reactivex/Observable.java, + private static void verifyPositive(int value, String paramName) {, + private static void verifyPositive(long value, String paramName)
[+++ b/rxjava-core/src/main/java/rx/Observable.java, + return create(OnSubscribeAmb.amb(sources));, + return create(OnSubscribeAmb.amb(o1, o2));, + return create(OnSubscribeAmb.amb(o1, o2, o3));, + return create(OnSubscribeAmb.amb(o1, o2, o3, o4));, + return create(OnSubscribeAmb.amb(o1, o2, o3, o4, o5));, + return create(OnSubscribeAmb.amb(o1, o2, o3, o4, o5, o6));, + return create(OnSubscribeAmb.amb(o1, o2, o3, o4, o5, o6, o7));, + return create(OnSubscribeAmb.amb(o1, o2, o3, o4, o5, o6, o7, o8));, + return create(OnSubscribeAmb.amb(o1, o2, o3, o4, o5, o6, o7, o8, o9));, + return create(new OnSubscribeCombineLatest<T, R>(sources, combineFunction));, + return create(new OnSubscribeDefer<T>(observableFactory));, + return create(OnSubscribeToObservableFuture.toObservableFuture(future));, + return create(OnSubscribeToObservableFuture.toObservableFuture(future, timeout, unit));, + return create(OnSubscribeToObservableFuture.toObservableFuture(future)).subscribeOn(scheduler);, + return create(new OnSubscribeTimerPeriodically(interval, interval, unit, Schedulers.computation()));, + return create(new OnSubscribeTimerPeriodically(interval, interval, unit,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorCast;, +import rx.operators.OperatorMap;, +import rx.operators.OperatorTimestamp;, + return bind(new OperatorCast<T, R>(klass));, + return bind(new OperatorMap<T, R>(func));, +<<<<<<< HEAD, +=======, + * Turns all of the emissions and notifications from a source Observable, + * into emissions marked with their original types within {@link Notification} objects., +>>>>>>> Bind implementation of Map, Cast, Timestamp, + return timestamp(Schedulers.immediate());, + return bind(new OperatorTimestamp<T>(scheduler));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorCast;, +import rx.operators.OperatorMap;, +import rx.operators.OperatorTimestamp;, + return bind(new OperatorCast<T, R>(klass));, + return bind(new OperatorMap<T, R>(func));, +<<<<<<< HEAD, +=======, + * Turns all of the emissions and notifications from a source Observable, + * into emissions
[+++ b/classes/production/rxjava-core/rx/operators/README.txt, +This package "rx.operators" is for internal implementation details and can change at any time., +, +It is excluded from the public Javadocs (http://netflix.github.io/RxJava/javadoc/) and should not be relied upon by any code., +, +In short, changes to public signatures of these classes will not be accounted for in the versioning of RxJava., +++ b/classes/production/rxjava-core/rx/operators/README.txt, +This package "rx.operators" is for internal implementation details and can change at any time., +, +It is excluded from the public Javadocs (http://netflix.github.io/RxJava/javadoc/) and should not be relied upon by any code., +, +In short, changes to public signatures of these classes will
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.observers.SafeSubscriber;, +import rx.operators.OperationTakeTimed;, + * time as an Observer subscribes to the Observable. This allows an {@link Observer} to easily, + * the Observable factory function to invoke for each {@link Observer} that, + * @return an Observable whose {@link Observer}s' subscriptions trigger an invocation of the, + * Returns an Observable that emits no items to the {@link Observer} and immediately invokes its {@link Observer#onCompleted onCompleted} method., + * @return an Observable that emits no items to the {@link Observer} but immediately invokes the {@link Observer}'s {@link Observer#onCompleted() onCompleted} method, + * Returns an Observable
[+++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.subscribers.TestSubscriber;, + * Provides an API (via a cold Completable) that bridges the reactive world with the callback-style world., + * <p>, + * Example:, + * <pre><code>, + * Completable.create(emitter -&gt; {, + * Callback listener = new Callback() {, + * &#64;Override, + * public void onEvent(Event e) {, + * emitter.onComplete();, + * }, + * , + * &#64;Override, + * public void onFailure(Exception e) {, + * emitter.onError(e);, + * }, + * };, + * , + * AutoCloseable c = api.someMethod(listener);, + * , + * emitter.setCancellable(c::close);, + *
[+++ b/rxjava-contrib/rxjava-android/build.gradle, +, +test {, + testLogging {, + exceptionFormat "full", + events "started", + displayGranularity 2, + }, +}, +++ b/rxjava-contrib/rxjava-android/build.gradle, +, +test {, + testLogging {, + exceptionFormat "full", + events "started", + displayGranularity 2, + }, +}, +++ /dev/null, +++ b/rxjava-contrib/rxjava-android/build.gradle, +, +test {, + testLogging {, + exceptionFormat "full", + events "started", + displayGranularity 2, + }, +}, +++ /dev/null, +++ b/rxjava-contrib/rxjava-android/src/test/java/rx/android/testsupport/R.java, +package rx.android.testsupport;, +, +public class R {, + // resource stub for Robolectric, +}]
[+++ b/src/main/java/io/reactivex/internal/observers/BlockingMultiObserver.java, +import static io.reactivex.internal.util.ExceptionHelper.timeoutMessage;, +, + throw ExceptionHelper.wrapOrThrow(new TimeoutException(timeoutMessage(timeout, unit)));, +++ b/src/main/java/io/reactivex/internal/observers/BlockingMultiObserver.java, +import static io.reactivex.internal.util.ExceptionHelper.timeoutMessage;, +, + throw ExceptionHelper.wrapOrThrow(new TimeoutException(timeoutMessage(timeout, unit)));, +++ b/src/main/java/io/reactivex/internal/observers/FutureObserver.java, +import static io.reactivex.internal.util.ExceptionHelper.timeoutMessage;, +, + throw new TimeoutException(timeoutMessage(timeout, unit));, +++ b/src/main/java/io/reactivex/internal/observers/BlockingMultiObserver.java, +import static io.reactivex.internal.util.ExceptionHelper.timeoutMessage;, +, + throw ExceptionHelper.wrapOrThrow(new TimeoutException(timeoutMessage(timeout, unit)));, +++ b/src/main/java/io/reactivex/internal/observers/FutureObserver.java, +import static io.reactivex.internal.util.ExceptionHelper.timeoutMessage;, +, + throw new TimeoutException(timeoutMessage(timeout, unit));, +++ b/src/main/java/io/reactivex/internal/observers/FutureSingleObserver.java, +import static io.reactivex.internal.util.ExceptionHelper.timeoutMessage;, +, + throw new TimeoutException(timeoutMessage(timeout, unit));, +++ b/src/main/java/io/reactivex/internal/observers/BlockingMultiObserver.java, +import static io.reactivex.internal.util.ExceptionHelper.timeoutMessage;, +, + throw ExceptionHelper.wrapOrThrow(new TimeoutException(timeoutMessage(timeout, unit)));, +++ b/src/main/java/io/reactivex/internal/observers/FutureObserver.java, +import static io.reactivex.internal.util.ExceptionHelper.timeoutMessage;, +, + throw new TimeoutException(timeoutMessage(timeout, unit));, +++ b/src/main/java/io/reactivex/internal/observers/FutureSingleObserver.java, +import static io.reactivex.internal.util.ExceptionHelper.timeoutMessage;, +, + throw new TimeoutException(timeoutMessage(timeout, unit));,
[+++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/build.gradle, +// Establish version and status, +ext.githubProjectName = rootProject.name // Change if github project name is not the same as the root project's name, + repositories {, + mavenLocal(), + mavenCentral() // maven { url 'http://jcenter.bintray.com' }, + }, + repositories { , + mavenLocal(), + mavenCentral() // maven {
[+++ b/src/main/java/io/reactivex/functions/Function7.java, +import io.reactivex.annotations.NonNull;, +, + @NonNull, + R apply(@NonNull T1 t1, @NonNull T2 t2, @NonNull T3 t3, @NonNull T4 t4, @NonNull T5 t5, @NonNull T6 t6, @NonNull T7 t7) throws Exception;]
[+++ b/.gitignore, +*.swp, +++ b/.gitignore, +*.swp, +++ b/gradle/release.gradle, +[, + uploadIvyLocal: 'uploadLocal', , + uploadArtifactory: 'artifactoryPublish', // Call out to compile against internal repository, + buildWithArtifactory: 'build' // Build against internal repository, +].each { key, value ->, + task "${key}"(type: GradleBuild) {, + tasks = [ 'build', value ], + }]
[+++ b/rxjava-core/src/main/java/rx/concurrency/TestScheduler.java, +/**, + * Copyright 2013 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.13.2-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.13.2-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/RxImplicits.scala, +/**, + * Copyright 2013 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF
[+++ b/src/main/java/rx/Observable.java, + return create(new OnSubscribeDelayWithSelector<T, U, V>(this, subscriptionDelay, itemDelay));, + return create(new OnSubscribeDelayWithSelector<T, U, U>(this, itemDelay));, + return create(new OnSubscribeDelay<T>(this, delay, unit, scheduler));, +++ b/src/main/java/rx/Observable.java, + return create(new OnSubscribeDelayWithSelector<T, U, V>(this, subscriptionDelay, itemDelay));, + return create(new OnSubscribeDelayWithSelector<T, U, U>(this, itemDelay));, + return create(new OnSubscribeDelay<T>(this, delay, unit, scheduler));, +++ b/src/main/java/rx/internal/operators/OnSubscribeDelay.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * ,
[+++ b/src/main/java/io/reactivex/exceptions/CompositeException.java, + if (root == null || e == root) {, +++ b/src/main/java/io/reactivex/exceptions/CompositeException.java, + if (root == null || e == root) {, +++ b/src/test/java/io/reactivex/exceptions/CompositeExceptionTest.java, + assertSame(ex0, ex.getRootCause(ex));, + }, +, + @Test, + public void rootCauseSelf() {, + Throwable throwable = new Throwable() {, +, + private static final long serialVersionUID = -4398003222998914415L;, +, + @Override, + public synchronized Throwable getCause() {, + return this;, + }, + };, + CompositeException tmp = new CompositeException(new TestException());, + assertSame(throwable, tmp.getRootCause(throwable));]
[+++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +import rx.lang.scala.examples.Movie;, +import rx.lang.scala.examples.MovieLib;, +import static rx.lang.scala.ImplicitFunctionConversions.toScalaObservable;, + public static void main(String[] args) {, + Observable<Movie> movies = Observable.from(, + new Movie(3000),, + new Movie(1000),, + new Movie(2000), + );, + MovieLib lib = new MovieLib(toScalaObservable(movies));, +, + lib.longMovies().asJavaObservable().subscribe(m ->, + System.out.println("A movie of length " + m.lengthInSeconds() + "s"), + );, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +import rx.lang.scala.examples.Movie;, +import rx.lang.scala.examples.MovieLib;, +import static rx.lang.scala.ImplicitFunctionConversions.toScalaObservable;, + public static void main(String[] args) {, + Observable<Movie> movies = Observable.from(, + new Movie(3000),, + new Movie(1000),, + new Movie(2000), + );, + MovieLib lib = new MovieLib(toScalaObservable(movies));, +, + lib.longMovies().asJavaObservable().subscribe(m ->, + System.out.println("A movie
[+++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java, +import java.util.concurrent.Callable;, +import io.reactivex.internal.functions.ObjectHelper;, + static volatile Function<Callable<Scheduler>, Scheduler> onInitComputationHandler;, + static volatile Function<Callable<Scheduler>, Scheduler> onInitSingleHandler;, + static volatile Function<Callable<Scheduler>, Scheduler> onInitIoHandler;, + static volatile Function<Callable<Scheduler>, Scheduler> onInitNewThreadHandler;, + public static Function<Callable<Scheduler>, Scheduler> getInitComputationSchedulerHandler() {, + public static Function<Callable<Scheduler>, Scheduler> getInitIoSchedulerHandler() {, + public static Function<Callable<Scheduler>, Scheduler> getInitNewThreadSchedulerHandler() {, + public static Function<Callable<Scheduler>, Scheduler> getInitSingleSchedulerHandler() {, + * @param defaultScheduler a {@link Callable} which returns the hook's input value, + * @return the value returned by the hook, not null, + * @throws NullPointerException if the callable parameter or its result are null, + public static Scheduler
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorSkipTimed;, + return lift(new OperatorSkipTimed<T>(time, unit, scheduler));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorSkipTimed;, + return lift(new OperatorSkipTimed<T>(time, unit, scheduler));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorSkipTimed;, + return lift(new OperatorSkipTimed<T>(time, unit, scheduler));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorSkipTimed.java, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not, + * use this file except in compliance with the License. You may obtain a copy of, + * the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in
[+++ b/src/main/java/io/reactivex/Completable.java, + return fromAction(Functions.futureAction(future));, +++ b/src/main/java/io/reactivex/Completable.java, + return fromAction(Functions.futureAction(future));, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.subscribers.flowable.*;, + return error(Functions.justCallable(exception));, + return new FlowableFromFuture<T>(future, 0L, null);, + return fromFuture(future, timeout, unit).subscribeOn(scheduler);, + return fromFuture(future).subscribeOn(scheduler);, + FlowableInternalHelper.<T, Object>simpleGenerator(generator), , + Functions.emptyConsumer());, + return generate(initialState, FlowableInternalHelper.<T, S>simpleBiGenerator(generator), , + Functions.emptyConsumer());, + return generate(initialState, FlowableInternalHelper.<T, S>simpleBiGenerator(generator), , + disposeState);, + return fromPublisher(sources).toList().flatMap(FlowableInternalHelper.<T, R>zipIterable(zipper));, + return buffer(boundary, Functions.<T>createArrayList(initialCapacity));, + return map(Functions.castFunction(clazz));, + return collect(Functions.justCallable(initialValue), collector);, + return any(Functions.equalsWith(element));, + return flatMap(FlowableInternalHelper.itemDelay(itemDelay));, + return distinct((Function)Functions.identity(), Functions.<T>createHashSet());, + return distinct(keySelector, Functions.<K>createHashSet());, + Functions.notificationOnNext(onNotification),, + Functions.notificationOnError(onNotification),, + Functions.notificationOnComplete(onNotification),, + return doOnEach(, + FlowableInternalHelper.subscriberOnNext(observer),, + FlowableInternalHelper.subscriberOnError(observer),, + FlowableInternalHelper.subscriberOnComplete(observer),, + Functions.EMPTY_ACTION);,
[+++ b/gradle.properties, +version=0.8.5]
[+++ b/src/main/java/io/reactivex/Observable.java, +// if (n < 0) {, +// throw new IllegalArgumentException("n >= 0 required but it was " + n);, +// } else, + // FIXME negative skip allowed?!, + if (n <= 0) {, + throw new IndexOutOfBoundsException("n >= 0 required but it was " + n);, +++ b/src/main/java/io/reactivex/Observable.java, +// if (n < 0) {, +// throw new IllegalArgumentException("n >= 0 required but it was " + n);, +// } else, + // FIXME negative skip allowed?!, + if (n <= 0) {, + throw new IndexOutOfBoundsException("n >= 0 required but it was " + n);, +++
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorSkipLast;, + return lift(new OperatorSkipLast<T>(count));, + return create(new OperatorSkipLast.SkipLastTimed<T>(this, time, unit, scheduler));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorSkipLast;, + return lift(new OperatorSkipLast<T>(count));, + return create(new OperatorSkipLast.SkipLastTimed<T>(this, time, unit, scheduler));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorSkipLast;, + return lift(new OperatorSkipLast<T>(count));, + return create(new OperatorSkipLast.SkipLastTimed<T>(this, time, unit, scheduler));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorSkipLast.java, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, +
[+++ b/gradle.properties, +version=0.11.1]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, + * @warn description may be out-of-date, +++ b/rxjava-core/src/main/java/rx/Observable.java, + * @warn description may be out-of-date, +++ b/rxjava-core/src/main/java/rx/Subscriber.java, + * Provides a mechanism for receiving push-based notifications., + * Registers an unsubscribe callback., + * @warn param "s" undescribed, + * Indicates whether this Subscriber has unsubscribed from its Observable., + * @return {@code true} if this Subscriber has unsubscribed from its Observable, {@code false} otherwise, +++ b/rxjava-core/src/main/java/rx/Observable.java, + * @warn description may be out-of-date, +++ b/rxjava-core/src/main/java/rx/Subscriber.java, + * Provides a mechanism for receiving push-based notifications., + * Registers an unsubscribe callback., + * @warn param "s"
[+++ b/src/main/java/io/reactivex/Observable.java, + return ObservablePublish.create(this);, + return new ObservablePublishSelector<T, R>(this, selector);, +++ b/src/main/java/io/reactivex/Observable.java, + return ObservablePublish.create(this);, + return new ObservablePublishSelector<T, R>(this, selector);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBuffer.java, + if (b != null) {, + }, + b = ObjectHelper.requireNonNull(bufferSupplier.call(), "The bufferSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");, +++ b/src/main/java/io/reactivex/Observable.java, + return ObservablePublish.create(this);, + return new ObservablePublishSelector<T, R>(this, selector);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableBuffer.java, + if (b != null) {, + }, + b = ObjectHelper.requireNonNull(bufferSupplier.call(), "The bufferSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.");, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java, +, +++
[+++ b/README.md, +#### Version 2.x, +, +Version 2.x and 1.x will live side-by-side for several years. They will have different namespaces (io.reactivex vs rx). , +, +The purpose for 2.x is:, +, +- leverage Java 8+ features, +- [Reactive Streams](http://www.reactive-streams.org) compatibility, +- performance gains through design changes learned through the 1.x cycle, +, +#### Version 1.x, +, +Version 2.x has started development. , +, +++ b/README.md, +#### Version 2.x, +, +Version 2.x and 1.x will live side-by-side for several years. They will have different namespaces (io.reactivex vs rx). , +, +The purpose for 2.x is:, +, +- leverage Java
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Returns a Flowable that emits {@code 0L} after a specified delay, and then completes., + * @return a Flowable that emits {@code 0L} after a specified delay, and then completes, + * Returns a Flowable that emits {@code 0L} after a specified delay, on a specified Scheduler, and then, + * @return a Flowable that emits {@code 0L} after a specified delay, on a specified Scheduler, and then, +++ b/src/main/java/io/reactivex/Flowable.java, + * Returns a Flowable that emits {@code 0L} after a specified delay, and then completes., + * @return a Flowable that emits {@code 0L}
[+++ b/src/main/java/io/reactivex/observers/ResourceCompletableObserver.java, +/**, + * Copyright 2016 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language governing
[+++ b/rxjava-core/src/main/java/rx/operators/AbstractOperation.java, +package rx.operators;, +, +import static org.junit.Assert.*;, +, +import java.lang.Thread.UncaughtExceptionHandler;, +import java.util.ArrayList;, +import java.util.List;, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicReference;, +, +import org.junit.Test;, +, +import rx.Observable;, +import rx.Observer;, +import rx.Subscription;, +import rx.subscriptions.Subscriptions;, +import rx.util.functions.Func1;, +, +/**, + * Common utility functions for operator implementations and tests., + */, +/* package */class AbstractOperation, +{, + private AbstractOperation() {, + }, +, + public static class UnitTest {, +, + public static <T> Func1<Observer<T>, Subscription> assertTrustedObservable(final Func1<Observer<T>, Subscription> source), + {, + return new Func1<Observer<T>, Subscription>(), + {, + @Override, + public Subscription call(Observer<T> observer), + {, + return source.call(new TestingObserver<T>(observer));, +
[+++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/build.gradle, +// Establish version and status, +ext.githubProjectName = rootProject.name // Change if github project name is not the same as the root project's name, + repositories {, + mavenLocal(), + maven { url 'http://jcenter.bintray.com' }, + }, + repositories { mavenRepo url: 'http://jcenter.bintray.com' }, +apply from: file('gradle/check.gradle'), + group =
[+++ b/build.gradle, + // everything defaults to 1.6, + sourceCompatibility = JavaVersion.VERSION_1_6, + targetCompatibility = JavaVersion.VERSION_1_6, +, +++ b/build.gradle, + // everything defaults to 1.6, + sourceCompatibility = JavaVersion.VERSION_1_6, + targetCompatibility = JavaVersion.VERSION_1_6, +, +++ b/gradle.properties, +version=0.19.0-SNAPSHOT, +++ b/build.gradle, + // everything defaults to 1.6, + sourceCompatibility = JavaVersion.VERSION_1_6, + targetCompatibility = JavaVersion.VERSION_1_6, +, +++ b/gradle.properties, +version=0.19.0-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorGroupBy.java, + public Subscriber<? super T> call(final Subscriber<? super GroupedObservable<K, T>> child) {, + return new GroupBySubscriber<K, T>(keySelector, child);, + final Subscriber<? super GroupedObservable<K, T>> child;, + public GroupBySubscriber(Func1<? super T, ? extends K> keySelector, Subscriber<? super GroupedObservable<K, T>> child) {,
[+++ b/src/test/java/io/reactivex/XFlatMapTest.java, + Thread.sleep(5000);, +++ b/src/test/java/io/reactivex/XFlatMapTest.java, + Thread.sleep(5000);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/BlockingFlowableNextTest.java, +import io.reactivex.disposables.SerialDisposable;, + int repeat = 0;, + for (;;) {, + final SerialDisposable task = new SerialDisposable();, + try {, + task.replace(Schedulers.single().scheduleDirect(new Runnable() {, + while (running.get() && !task.isDisposed()) {, + }));, + break;, + } catch (AssertionError ex) {, + if (++repeat == 3) {, + throw ex;, + }, + Thread.sleep((int)(1000 * Math.pow(2, repeat - 1)));, + } finally {, + task.dispose();, + }, + }, +++ b/src/test/java/io/reactivex/XFlatMapTest.java, + Thread.sleep(5000);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/BlockingFlowableNextTest.java, +import io.reactivex.disposables.SerialDisposable;, + int repeat = 0;, + for (;;) {, + final SerialDisposable
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC6-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC6-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/README.md, +Observable.items(1, 2, 3, 4).reduce(_ + _), +val first = Observable.items(10, 11, 12), +val second = Observable.items(10, 11, 12), +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC6-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/README.md, +Observable.items(1, 2, 3, 4).reduce(_ + _), +val first = Observable.items(10, 11, 12), +val second = Observable.items(10, 11, 12), +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC6-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/README.md, +Observable.items(1, 2, 3, 4).reduce(_ + _), +val first = Observable.items(10, 11, 12), +val second = Observable.items(10, 11, 12), +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC6-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/README.md, +Observable.items(1, 2, 3, 4).reduce(_
[+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsTest.java, + .subscribe(new DisposableCompletableObserver() {, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsTest.java, + .subscribe(new DisposableCompletableObserver() {, +++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableBufferTest.java, + DisposableObserver<Object> s = new DisposableObserver<Object>() {, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableIgnoreElementsTest.java, + .subscribe(new DisposableCompletableObserver() {, +++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableBufferTest.java, + DisposableObserver<Object> s = new DisposableObserver<Object>() {, +++ b/src/test/java/io/reactivex/observers/SerializedObserverTest.java, + DisposableObserver<String> as1 = new DisposableObserver<String>() {, + DisposableObserver<String> as2 = new DisposableObserver<String>() {]
[+++ b/src/main/java/rx/Observable.java, + return delaySubscription(subscriptionDelay).lift(new OperatorDelayWithSelector<T, V>(this, itemDelay));, + return lift(new OperatorDelayWithSelector<T, U>(this, itemDelay));, + return lift(new OperatorDelay<T>(this, delay, unit, scheduler));, + * Returns an Observable that delays the subscription to the source Observable by a given amount of time., + * <p>, + * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/delaySubscription.png" alt="">, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>This version of {@code delay} operates by default on the {@code compuation} {@link Scheduler}.</dd>, + * </dl>, + * , + * @param delay, + * the time to delay the subscription, + * @param unit, + * the time unit
[+++ b/CHANGES.md, +### Version 0.8.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.8.2%22)) ###, +, +* [Issue 74](https://github.com/Netflix/RxJava/issues/74) Operator: Sample, +* [Issue 93](https://github.com/Netflix/RxJava/issues/93) Operator: Timestamp, +* [Pull 253](https://github.com/Netflix/RxJava/pull/253) Fix multiple subscription bug on operation filter, +* [Pull 254](https://github.com/Netflix/RxJava/pull/254) SwingScheduler (new rxjava-swing module), +* [Pull 256](https://github.com/Netflix/RxJava/pull/256) BehaviorSubject, +* [Pull 257](https://github.com/Netflix/RxJava/pull/257) Improved scan, reduce, aggregate, +* [Pull 262](https://github.com/Netflix/RxJava/pull/262) SwingObservable (new rxjava-swing module), +* [Pull 264](https://github.com/Netflix/RxJava/pull/263) Publish, Replay and Cache Operators, +* , +++ b/CHANGES.md, +### Version 0.8.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.8.2%22)) ###, +, +* [Issue 74](https://github.com/Netflix/RxJava/issues/74) Operator: Sample, +* [Issue 93](https://github.com/Netflix/RxJava/issues/93) Operator: Timestamp, +* [Pull 253](https://github.com/Netflix/RxJava/pull/253) Fix multiple subscription bug on operation filter, +* [Pull 254](https://github.com/Netflix/RxJava/pull/254) SwingScheduler (new rxjava-swing
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBlockingSubscribe.java, + if (v == BlockingSubscriber.TERMINATED]
[+++ b/rxjava-core/src/perf/java/rx/jmh/README.txt, +http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * @param itemTimeoutIndicator, + public final <V> Flowable<T> timeout(Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator) {, + return timeout0(null, itemTimeoutIndicator, null);, + * @param itemTimeoutIndicator, + public final <V> Flowable<T> timeout(Function<? super T, ? extends Publisher<V>> itemTimeoutIndicator, Flowable<? extends T> other) {, + return timeout0(null, itemTimeoutIndicator, other);, + * @param other, + * the Publisher to use as the fallback in case of a timeout, + public final Flowable<T> timeout(long timeout, TimeUnit timeUnit, Scheduler scheduler, Flowable<? extends T> other) {, + * @param firstTimeoutIndicator, + * @param itemTimeoutIndicator, + public final <U, V> Flowable<T> timeout(Publisher<U> firstTimeoutIndicator,,
[+++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java, + return assertError(Functions.equalsWith(error));, + @SuppressWarnings({ "unchecked", "rawtypes" }), + return assertError((Predicate)Functions.isInstanceOf(errorClass));]
[+++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +RxScala Release Notes, +=====================, +, +This release of the RxScala bindings builds on the previous 0.15 release to make the Rx bindings for Scala, +include all Rx types. In particular this release focuses on fleshing out the bindings for the `Subject` and `Scheduler`, +types, as well as aligning the constructor functions for `Observable` with those in the RxJava., +, +Expect to see ongoing additions to make the Scala binding match the equivalent underlying Java API,, +as well as minor changes in the existing API as
[+++ b/CHANGES.md, +### Version 0.14.3 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.3%22)) ###, +, +* [Pull 407](https://github.com/Netflix/RxJava/pull/407) Operator: RefCount, +* [Pull 410](https://github.com/Netflix/RxJava/pull/410) Operator: Contains, +* [Pull 411](https://github.com/Netflix/RxJava/pull/411) Unit Test fix: update counter before triggering latch , +* [Pull 413](https://github.com/Netflix/RxJava/pull/413) Fixed the issues of takeLast(items, 0) and null values, +* [Pull 414](https://github.com/Netflix/RxJava/pull/414) Operator: SkipLast, +* [Pull 415](https://github.com/Netflix/RxJava/pull/415) Operator: Empty with scheduler, +* [Pull 416](https://github.com/Netflix/RxJava/pull/416) Operator: Throw with scheduler , +* [Pull 420](https://github.com/Netflix/RxJava/pull/420) Scala Adaptor Improvements, +* [Pull 422](https://github.com/Netflix/RxJava/pull/422) JRuby function wrapping support, +* [Pull 424](https://github.com/Netflix/RxJava/pull/424) Operator: IgnoreElements, +* [Pull 426](https://github.com/Netflix/RxJava/pull/426) PublishSubject ReSubscribe for publish().refCount() Behavior, +, +++ b/CHANGES.md, +### Version 0.14.3 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.3%22)) ###, +,
[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.observable, +import rx.lang.scala.concurrency.Schedulers, + i => println(s"${i}a (on thread #${Thread.currentThread().getId()})"), + i => println(s"${i}b (on thread #${Thread.currentThread().getId()})"), + o.observeOn(Schedulers.newThread).subscribe(, + i => println(s"${i}a (on thread #${Thread.currentThread().getId()})"), + o.observeOn(Schedulers.newThread).subscribe(, + i => println(s"${i}b (on thread #${Thread.currentThread().getId()})"), + println(s"$x*$x is being calculated on thread ${Thread.currentThread().getId()}"), + println(s"map() is being called on thread ${Thread.currentThread().getId()}"), + @Test def observableLikeFuture1() {, + implicit val scheduler = Schedulers.threadPoolForIO, + val o1 = observable {, + Thread.sleep(1000), + 5, + }, + val o2 = observable {, + Thread.sleep(500), + 4, + }, + Thread.sleep(500), + val t1 = System.currentTimeMillis, + println((o1 merge
[+++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/TestParallel.groovy, +import rx.schedulers.Schedulers, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/TestParallel.groovy, +import rx.schedulers.Schedulers, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/TestParallel.groovy, +import rx.schedulers.Schedulers, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +RxScala Release Notes, +=====================, +, +This release of the RxScala bindings builds on the previous 0.15 release to make the Rx bindings for Scala, +include all Rx types. In particular this release focuses on fleshing out the bindings for the `Subject` and `Scheduler`, +types, as well as aligning the constructor functions for `Observable` with those in the RxJava., +, +Expect to see ongoing additions to make the Scala binding match the equivalent underlying
[+++ b/CHANGES.md, +### Version 0.13.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.13.2%22)) ###, +, +* [Pull 389](https://github.com/Netflix/RxJava/pull/389) Scala Adaptor Improvements, +* [Pull 382](https://github.com/Netflix/RxJava/pull/382) Removing deprecated RxImplicits from rxjava-scala, +* [Pull 381](https://github.com/Netflix/RxJava/pull/381) Operator: mapWithIndex, +* [Pull 380](https://github.com/Netflix/RxJava/pull/380) Implemented `distinct` and `distinctUntilChanged` variants using a comparator, +* [Pull 379](https://github.com/Netflix/RxJava/pull/379) Make `interval` work with multiple subscribers, +, +++ b/CHANGES.md, +### Version 0.13.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.13.2%22)) ###, +, +* [Pull 389](https://github.com/Netflix/RxJava/pull/389) Scala Adaptor Improvements, +* [Pull 382](https://github.com/Netflix/RxJava/pull/382) Removing deprecated RxImplicits from rxjava-scala, +* [Pull 381](https://github.com/Netflix/RxJava/pull/381) Operator: mapWithIndex, +* [Pull 380](https://github.com/Netflix/RxJava/pull/380) Implemented `distinct` and `distinctUntilChanged` variants using a comparator, +* [Pull 379](https://github.com/Netflix/RxJava/pull/379) Make `interval` work with multiple subscribers, +, +++
[+++ b/README.md, +and <a href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-jruby">JRuby</a>. , +++ b/README.md, +and <a href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-jruby">JRuby</a>. , +++ b/language-adaptors/rxjava-clojure/build.gradle, +apply plugin: 'clojure', + , + // clojure, + testCompile 'clj-http:clj-http:0.6.4' // https://clojars.org/clj-http, +/*, + * Clojure, + */, +aotCompile = true, +warnOnReflection = true, +, +buildscript {, + repositories { maven { url "http://clojars.org/repo" } }, + dependencies { classpath "clojuresque:clojuresque:1.5.4" }, +}, +, +repositories {, + mavenCentral(), + clojarsRepo(), +}, +, +/*, + * Add Counterclockwise and include 'provided' dependencies, + */, +eclipse {, + project {, + natures "ccw.nature", + }, + classpath {, + plusConfigurations += configurations.provided, + downloadSources = true,
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/README.md, +, +## Documentation, +, +The API documentation can be found [here](http://rxscala.github.io/scaladoc/index.html#rx.lang.scala.Observable)., +, +You can build the API documentation yourself by running `./gradlew scaladoc` in the RxJava root directory., +, +Then navigate to `RxJava/language-adaptors/rxjava-scala/build/docs/scaladoc/index.html` to display it., +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/README.md, +, +## Documentation, +, +The API documentation can be found [here](http://rxscala.github.io/scaladoc/index.html#rx.lang.scala.Observable)., +, +You can build the API documentation yourself by running `./gradlew scaladoc` in the RxJava root directory., +, +Then navigate to `RxJava/language-adaptors/rxjava-scala/build/docs/scaladoc/index.html` to display
[+++ b/rxjava-core/src/main/java/rx/operators/README.txt, +This package "rx.operators" is for internal implementation details and can change at any time., +, +It is excluded from the public Javadocs (http://netflix.github.io/RxJava/javadoc/) and should not be relied upon by any code., +, +In short, changes to public signatures of these classes will not be accounted for in the versioning of RxJava.]
[+++ b/src/main/java/io/reactivex/Completable.java, + * Calls the shared {@code Action} if a CompletableObserver subscribed to the current, + * Completable disposes the common Disposable it received via onSubscribe., + * @param onDispose the action to call when the child subscriber disposes the subscription, +++ b/src/main/java/io/reactivex/Completable.java, + * Calls the shared {@code Action} if a CompletableObserver subscribed to the current, + * Completable disposes the common Disposable it received via onSubscribe., + * @param onDispose the action to call when the child subscriber disposes the subscription, +++ b/src/main/java/io/reactivex/Maybe.java, + * Calls the shared {@code Action} if a MaybeObserver subscribed to the
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.util.BufferClosing;, +import rx.util.BufferOpening;, + * NOTE: Use {@link #create(OnSubscribeFunc)} to create an Observable instead of this constructor unless you, +, + * @deprecated Being renamed to {@link #switchOnNext}, + @Deprecated, + * Given an Observable that emits Observables, creates a single Observable that, + * @param sequenceOfSequences, + * the source Observable that emits Observables, + public static <T> Observable<T> switchOnNext(Observable<? extends Observable<? extends T>> sequenceOfSequences) {, + return create(OperationSwitch.switchDo(sequenceOfSequences));, +, + * emitted and replaced with a new buffer when the Observable produced by the specified {@link Func0} produces a {@link BufferClosing} object. The *
[+++ b/src/main/java/io/reactivex/internal/operators/OperatorScanSeed.java, + s.request(n);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorScanSeed.java, + s.request(n);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorSingle.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (SubscriptionHelper.validateRequest(n)) {, +++ b/src/main/java/io/reactivex/internal/operators/OperatorScanSeed.java, + s.request(n);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorSingle.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (SubscriptionHelper.validateRequest(n)) {, +++ b/src/main/java/io/reactivex/internal/operators/OperatorTakeLastOne.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (SubscriptionHelper.validateSubscription(this.s, s)) {, +++ b/src/main/java/io/reactivex/internal/operators/OperatorScanSeed.java, + s.request(n);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorSingle.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (SubscriptionHelper.validateRequest(n)) {, +++ b/src/main/java/io/reactivex/internal/operators/OperatorTakeLastOne.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (SubscriptionHelper.validateSubscription(this.s, s)) {, +++ b/src/main/java/io/reactivex/internal/subscribers/QueueDrainSubscriber.java, +import io.reactivex.internal.util.*;, + BackpressureHelper.add(REQUESTED, this, n);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorScanSeed.java, + s.request(n);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorSingle.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (SubscriptionHelper.validateRequest(n)) {, +++ b/src/main/java/io/reactivex/internal/operators/OperatorTakeLastOne.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (SubscriptionHelper.validateSubscription(this.s, s)) {, +++ b/src/main/java/io/reactivex/internal/subscribers/QueueDrainSubscriber.java, +import io.reactivex.internal.util.*;, + BackpressureHelper.add(REQUESTED, this, n);, +++ b/src/main/java/io/reactivex/subscribers/TestSubscriber.java, + *
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC1-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC1-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC1-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/Producer.java, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC1-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/Producer.java, +++ b/rxjava-core/src/main/java/rx/Subscriber.java, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC1-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/Producer.java, +++ b/rxjava-core/src/main/java/rx/Subscriber.java, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorZip.java, +import java.util.concurrent.atomic.AtomicLong;, +import rx.Producer;, +import rx.exceptions.MissingBackpressureException;, +import rx.internal.util.RxRingBuffer;, + * , + * @param <R>, + * the result type, + public Subscriber<? super Observable[]> call(final Subscriber<? super R> child) {, + final Zip<R> zipper = new Zip<R>(child, zipFunction);, + final ZipProducer<R> producer = new ZipProducer<R>(zipper);, + child.setProducer(producer);, + final ZipSubscriber subscriber
[+++ b/gradle.properties, +version=0.10.1]
[+++ b/gradle.properties, +version=0.17.0-SNAPSHOT, +++ b/gradle.properties, +version=0.17.0-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/gradle.properties, +version=0.17.0-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/gradle.properties, +version=0.17.0-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/rxjava-core/src/main/java/rx/Observable.java, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not, + * use this file except in compliance with the License. You may obtain a copy of, + * the License at, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
[+++ b/gradle.properties, +release.version=2.0.0-DP0]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.SafeObservableSubscription;, +import rx.operators.SafeObserver;, + SafeObservableSubscription subscription = new SafeObservableSubscription();, + subscription.wrap(onSubscribeFunction.call(new SafeObserver<T>(subscription, observer)));, + SafeObservableSubscription subscription = new SafeObservableSubscription();, + return subscription.wrap(subscribe(new SafeObserver<T>(subscription, o)));, + if (o instanceof SafeObserver), +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.SafeObservableSubscription;, +import rx.operators.SafeObserver;, + SafeObservableSubscription subscription = new SafeObservableSubscription();, + subscription.wrap(onSubscribeFunction.call(new SafeObserver<T>(subscription, observer)));, + SafeObservableSubscription subscription = new SafeObservableSubscription();, + return subscription.wrap(subscribe(new SafeObserver<T>(subscription, o)));, + if (o instanceof SafeObserver), +++ b/rxjava-core/src/main/java/rx/concurrency/DiscardableAction.java, +import rx.operators.SafeObservableSubscription;, + private final SafeObservableSubscription wrapper = new SafeObservableSubscription();, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.SafeObservableSubscription;, +import rx.operators.SafeObserver;, + SafeObservableSubscription subscription = new SafeObservableSubscription();, + subscription.wrap(onSubscribeFunction.call(new SafeObserver<T>(subscription, observer)));, + SafeObservableSubscription subscription = new SafeObservableSubscription();, +
[+++ b/rxjava-contrib/rxjava-joins/build.gradle, +apply plugin: 'osgi', +, +sourceCompatibility = JavaVersion.VERSION_1_6, +targetCompatibility = JavaVersion.VERSION_1_6, +, +dependencies {, + compile project(':rxjava-core'), + testCompile project(":rxjava-core").sourceSets.test.output , + provided 'junit:junit-dep:4.10', + provided 'org.mockito:mockito-core:1.8.5', +}, +, +jar {, + manifest {, + name = 'rxjava-joins', + instruction 'Bundle-Vendor', 'Netflix', + instruction 'Bundle-DocURL', 'https://github.com/Netflix/RxJava', + instruction 'Import-Package', '!org.junit,!junit.framework,!org.mockito.*,*', + instruction 'Fragment-Host', 'com.netflix.rxjava.core', + }, +}, +++ b/rxjava-contrib/rxjava-joins/build.gradle, +apply plugin: 'osgi', +, +sourceCompatibility = JavaVersion.VERSION_1_6, +targetCompatibility = JavaVersion.VERSION_1_6, +, +dependencies {, + compile project(':rxjava-core'), + testCompile project(":rxjava-core").sourceSets.test.output , + provided 'junit:junit-dep:4.10', + provided 'org.mockito:mockito-core:1.8.5', +}, +, +jar {, + manifest {, + name = 'rxjava-joins', + instruction
[+++ b/src/main/java/io/reactivex/Completable.java, + public static Completable wrap(CompletableConsumable source) {, +++ b/src/main/java/io/reactivex/Completable.java, + public static Completable wrap(CompletableConsumable source) {, +++ b/src/main/java/io/reactivex/disposables/CompositeDisposable.java, +import io.reactivex.internal.disposables.DisposableContainer;, +public final class CompositeDisposable implements Disposable, DisposableContainer {, + public int size() {, + if (disposed) {, + return 0;, + }, + synchronized (this) {, + if (disposed) {, + return 0;, + }, + return resources.size();, + }, + }, + , +++ b/src/main/java/io/reactivex/Completable.java, + public static Completable wrap(CompletableConsumable source) {, +++ b/src/main/java/io/reactivex/disposables/CompositeDisposable.java, +import io.reactivex.internal.disposables.DisposableContainer;, +public final class CompositeDisposable implements Disposable, DisposableContainer {, + public int size() {, + if (disposed) {, + return 0;,
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/build.gradle, +ext.githubProjectName = rootProject.name, +, + repositories { mavenCentral() }, + repositories { mavenCentral() }, +, +, +++ b/CHANGES.md, +++ b/build.gradle, +ext.githubProjectName = rootProject.name, +, + repositories { mavenCentral() }, + repositories { mavenCentral() }, +, +, +++ b/codequality/checkstyle.xml, + <module name="DoubleCheckedLocking"/> <!-- MY FAVOURITE -->, +++ b/CHANGES.md, +++ b/build.gradle, +ext.githubProjectName = rootProject.name, +, + repositories { mavenCentral() }, + repositories { mavenCentral() }, +, +, +++ b/codequality/checkstyle.xml, + <module name="DoubleCheckedLocking"/> <!-- MY FAVOURITE -->, +++ b/gradle.properties, +version=0.11.2-SNAPSHOT, +++ b/CHANGES.md, +++ b/build.gradle, +ext.githubProjectName = rootProject.name, +, + repositories { mavenCentral() }, + repositories {
[+++ b/src/main/java/io/reactivex/Flowable.java, + public final Observable<T> toObservable() {]
[+++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java, + @Nullable]
[+++ b/build.gradle, + compile 'org.reactivestreams:reactive-streams:1.0.0', +++ b/build.gradle, + compile 'org.reactivestreams:reactive-streams:1.0.0', +++ b/src/main/java/io/reactivex/Observable.java, +import java.util.Objects;, +import java.util.function.*;, +, +import org.reactivestreams.*;, +, +public class Observable<T> implements Publisher<T> {, + final Consumer<Subscriber<? super T>> onSubscribe;, + , + private Observable(Consumer<Subscriber<? super T>> onSubscribe) {, + this.onSubscribe = onSubscribe;, + }, + , + public static <T> Observable<T> create(Consumer<Subscriber<? super T>> onSubscribe) {, + // TODO plugin wrapping, + return new Observable<>(onSubscribe);, + }, + , + @Override, + public final void subscribe(Subscriber<? super T> s) {, + Objects.requireNonNull(s);, + try {, + onSubscribe.accept(s);, + } catch (NullPointerException e) {, + throw e;,
[+++ b/gradle.properties, +version=0.17.0-RC1]
[+++ b/src/main/java/io/reactivex/Single.java, +import io.reactivex.internal.operators.observable.*;, + * Wraps a specific ObservableSource into a Single and signals its single element or error., + * <p>If the ObservableSource is empty, a NoSuchElementException is signalled., + * If the source has more than one element, an IndexOutOfBoundsException is signalled., + * <p>, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code fromObservable} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + *, + * @param observableSource the source Observable, not null, + * @param <T>, + * the type of the item emitted by the {@link Single}., +
[+++ b/src/main/java/io/reactivex/Observable.java, + public static <T, D> Observable<T> using(Supplier<? extends D> resourceSupplier, Function<? super D, ? extends Publisher<? extends T>> sourceSupplier, Consumer<? super D> disposer) {, + return using(resourceSupplier, sourceSupplier, disposer, true);, + }, +, + public static <T, D> Observable<T> using(Supplier<? extends D> resourceSupplier, Function<? super D, ? extends Publisher<? extends T>> sourceSupplier, Consumer<? super D> disposer, boolean eager) {, + Objects.requireNonNull(resourceSupplier);, + Objects.requireNonNull(sourceSupplier);, + Objects.requireNonNull(disposer);, + return create(new PublisherUsing<>(resourceSupplier, sourceSupplier, disposer, eager));, + }, +++ b/src/main/java/io/reactivex/Observable.java, + public static <T, D> Observable<T> using(Supplier<? extends D> resourceSupplier, Function<? super D, ? extends Publisher<? extends T>> sourceSupplier, Consumer<? super
[+++ b/src/main/java/io/reactivex/Completable.java, + * Calls the specified converter function during assembly time and returns its resulting value., + * <p>, + * This allows fluent conversion to any other type., + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code as} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + *, + * @param <R> the resulting object type, + * @param converter the function that receives the current Completable instance and returns a value, + * @return the converted value, + * @throws NullPointerException if converter is null, + * @since 2.1.7 - experimental,
[+++ b/src/main/java/io/reactivex/exceptions/Exceptions.java, + if (t instanceof VirtualMachineError) {]
[+++ b/gradle.properties, +version=0.17.6-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Observable.java, + Objects.requireNonNull(generator);, + Objects.requireNonNull(generator);, + Objects.requireNonNull(generator);]
[+++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java, + assertValueAt(0, valuePredicate);, +, + if (values.size() > 1) {, + throw fail("Value present but other values as well");, + }, +, + return (U)this;, + }, +, + /**, + * Asserts that this TestObserver/TestSubscriber received an onNext value at the given index, + * for the provided predicate returns true., + * @param valuePredicate, + * the predicate that receives the onNext value, + * and should return true for the expected value., + * @return this, + */, + @SuppressWarnings("unchecked"), + public final U assertValueAt(int index, Predicate<T> valuePredicate) {, + if (index >= values.size())
[+++ b/src/main/java/io/reactivex/Single.java, + * For more information see the <a href="http://reactivex.io/documentation/single.html">ReactiveX]
[+++ b/src/main/java/io/reactivex/Observable.java, + return new Observable<T>() {, + protected void subscribeActual(final Observer<? super T> o) {, + o.onComplete();, + o.onError(t);, + o.onNext(t);, + o.onSubscribe(Disposables.from(inner));, + };, + return new Observable<Integer>() {, + protected void subscribeActual(Observer<? super Integer> o) {, + o.onSubscribe(d);, + o.onNext((int)i);, + o.onComplete();, + };, + final Observable<T> outer = this;, + return new Observable<T>() {, + protected void subscribeActual(Observer<? super T> o) {, + outer.subscribe(o);, + };, +++ b/src/main/java/io/reactivex/Observable.java, + return new Observable<T>() {, + protected void subscribeActual(final Observer<? super T> o) {, + o.onComplete();, + o.onError(t);, + o.onNext(t);, + o.onSubscribe(Disposables.from(inner));, + };, + return new
[+++ b/.gitignore, +++ b/.gitignore, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/CHANGES.md, +### Version 0.17.6 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.17.6%22)) ###, +, +* [Pull 1031] (https://github.com/Netflix/RxJava/pull/1031) Fix NPE in SubjectSubscriptionManager, +* [Pull 1030] (https://github.com/Netflix/RxJava/pull/1030) Benchmarking: Add JMH benchmark for ReplaySubject, +* [Pull 1033] (https://github.com/Netflix/RxJava/pull/1033) isolate subscriber used for retries, cleanup tests, +* [Pull 1021] (https://github.com/Netflix/RxJava/pull/1021) OperatorWeakBinding to not use WeakReferences anymore, +* [Pull 1005] (https://github.com/Netflix/RxJava/pull/1005) add toMap from Java Observable, +* [Pull 1040] (https://github.com/Netflix/RxJava/pull/1040) Fixed deadlock in Subjects + OperatorCache, +* [Pull 1042] (https://github.com/Netflix/RxJava/pull/1042) Kotlin M7 and full compatibility with 0.17.0, +* [Pull 1035] (https://github.com/Netflix/RxJava/pull/1035) Scala cleanup, +* [Pull 1009] (https://github.com/Netflix/RxJava/pull/1009) Android - Adding a new RetainedFragment example, +* [Pull 1020] (https://github.com/Netflix/RxJava/pull/1020)
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorDefer;, + return create(new OperatorDefer<T>(observableFactory));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorDefer;, + return create(new OperatorDefer<T>(observableFactory));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorDefer;, + return create(new OperatorDefer<T>(observableFactory));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorDefer.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, +
[+++ b/language-adaptors/rxjava-clojure/build.gradle, +clojureTest.dependsOn compileTestJava, +++ b/language-adaptors/rxjava-clojure/build.gradle, +clojureTest.dependsOn compileTestJava, +++ /dev/null, +++ b/language-adaptors/rxjava-clojure/build.gradle, +clojureTest.dependsOn compileTestJava, +++ /dev/null, +++ b/language-adaptors/rxjava-clojure/src/test/java/rx/lang/clojure/interop/DummyObservable.java, +/**, + * Copyright 2013 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT
[+++ b/language-adaptors/rxjava-clojure/build.gradle, +clojureTest.dependsOn compileTestJava, +++ b/language-adaptors/rxjava-clojure/build.gradle, +clojureTest.dependsOn compileTestJava, +++ /dev/null, +++ b/language-adaptors/rxjava-clojure/build.gradle, +clojureTest.dependsOn compileTestJava, +++ /dev/null, +++ b/language-adaptors/rxjava-clojure/src/test/java/rx/lang/clojure/interop/DummyObservable.java, +/**, + * Copyright 2013 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT
[+++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/gradle.properties, +version=0.17.0-SNAPSHOT, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/gradle.properties, +version=0.17.0-SNAPSHOT, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/gradle.properties, +version=0.17.0-SNAPSHOT, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/interop.clj, + ~@(if (and (= prefix "rx.util.functions.Func"), + ~@(if (and (= prefix "rx.util.functions.Action"), + "Given function f, returns an object that implements rx.util.functions.Func0-9, + http://netflix.github.io/RxJava/javadoc/rx/util/functions/Func0.html, + (reify-callable "rx.util.functions.Func" [0 1 2 3 4 5 6 7 8 9] f)), + "Given function f, returns an object that implements rx.util.functions.FuncN, + http://netflix.github.io/RxJava/javadoc/rx/util/functions/FuncN.html, + (reify rx.util.functions.FuncN, + "Like clojure.core/fn, but returns the appropriate rx.util.functions.Func*, + "Given function f, returns an object that implements
[+++ b/src/main/java/io/reactivex/Single.java, +import org.reactivestreams.Publisher;, +, + * Returns a Single which makes sure when a SingleObserver disposes the Disposable,, + * that call is propagated up on the specified scheduler, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code unsubscribeOn} calls dispose() of the upstream on the {@link Scheduler} you specify.</dd>, + * </dl>, + * @param scheduler the target scheduler where to execute the cancellation, + * @return the new Single instance, + * @throws NullPointerException if scheduler is null, + * @since 2.0.9 - experimental, + */, + @CheckReturnValue, + @SchedulerSupport(SchedulerSupport.CUSTOM), + @Experimental, + public final Single<T>
[+++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.parallel.ParallelFlowable;, + * Parallelizes the flow by creating multiple 'rails' (equal to the number of CPUs), + * and dispatches the upstream items to them in a round-robin fashion., + * <p>, + * Note that the rails don't execute in parallel on their own and one needs to, + * apply {@link ParallelFlowable#runOn(Scheduler)} to specify the Scheduler where, + * each rail will execute., + * <p>, + * To merge the parallel 'rails' back into a single sequence, use {@link ParallelFlowable#sequential()}., + * <p>, + * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flowable.parallel.png" alt="">, + * <dl>,
[+++ b/gradle.properties, +version=0.20.1-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java, + U v = value;, + if (v != null) {, + v.add(t);, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableToList.java, + U v = value;, + if (v != null) {, + v.add(t);, + }, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableToListTest.java, +import static org.mockito.ArgumentMatchers.any;, +, + @Test, + public void onNextCancelRace() {, + for (int i = 0; i < 1000; i++) {, + final PublishProcessor<Integer> pp = PublishProcessor.create();, + final TestObserver<List<Integer>> ts = pp.toList().test();, + , + Runnable r1 = new Runnable() {, + @Override, + public void run() {, + pp.onNext(1);, + }, + };, + Runnable r2 = new Runnable() {,
[+++ b/CHANGES.md, +### Version 0.20.0-RC5 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.20.0-RC5%22)) ###, +, +Version 0.20.0-RC5 updates `parallel`, `buffer(size)`, `switchOnNext`, `repeat`, and `retry` to support "reactive pull" backpressure. It adds a `groupBy` overload with an element selector, a new `compose` method as an alternative to `lift` for custom operators, fixes bugs and other general improvements., +, +There are still oustanding items being tracked for 0.20 that need to be completed for the final release., +, +* [Pull 1573] (https://github.com/Netflix/RxJava/pull/1573) Backpressure: parallel , +* [Pull 1572] (https://github.com/Netflix/RxJava/pull/1572) Remove Timeout in Blocking Iterator, +* [Pull 1570] (https://github.com/Netflix/RxJava/pull/1570) RxClojure: Fix for mapcat, +* [Pull 1568] (https://github.com/Netflix/RxJava/pull/1568) Compose/Transformer,
[+++ b/src/main/java/io/reactivex/exceptions/CompositeException.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the
[+++ b/gradle.properties, +version=0.14.1]
[+++ b/src/main/java/io/reactivex/Completable.java]
[+++ b/.gitignore, +.m2, +target/, +build/, +bin/, +++ b/.gitignore, +.m2, +target/, +build/, +bin/, +++ b/build.gradle, +ext.githubProjectName = rootProject.name, +//apply from: file('gradle/check.gradle'), + group = "com.netflix.${githubProjectName}", + sourceSets.test.java.srcDir 'src/main/java', + tasks.withType(Javadoc).each {, + it.classpath = sourceSets.main.compileClasspath, +++ b/.gitignore, +.m2, +target/, +build/, +bin/, +++ b/build.gradle, +ext.githubProjectName = rootProject.name, +//apply from: file('gradle/check.gradle'), + group = "com.netflix.${githubProjectName}", + sourceSets.test.java.srcDir 'src/main/java', + tasks.withType(Javadoc).each {, + it.classpath = sourceSets.main.compileClasspath, +++ b/settings.gradle, +rootProject.name='rxjava', +include 'rxjava-core']
[+++ b/CHANGES.md, +### Version 0.6.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.6.1%22)) ###, +, +* [Pull 190](https://github.com/Netflix/RxJava/pull/190) Fix generics issue with materialize() that prevented chaining, +, +++ b/CHANGES.md, +### Version 0.6.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.6.1%22)) ###, +, +* [Pull 190](https://github.com/Netflix/RxJava/pull/190) Fix generics issue with materialize() that prevented chaining, +, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationConcat;, +import rx.operators.OperationDefer;, +import rx.operators.OperationDematerialize;, +import rx.operators.OperationFilter;, +import rx.operators.OperationMap;, +import rx.operators.OperationMaterialize;, +import rx.operators.OperationMerge;, +import rx.operators.OperationMergeDelayError;, +import rx.operators.OperationMostRecent;, +import rx.operators.OperationNext;, +import rx.operators.OperationOnErrorResumeNextViaFunction;, +import rx.operators.OperationOnErrorResumeNextViaObservable;, +import rx.operators.OperationOnErrorReturn;, +import rx.operators.OperationScan;, +import rx.operators.OperationSkip;, +import rx.operators.OperationSynchronize;, +import rx.operators.OperationTake;, +import rx.operators.OperationTakeLast;, +import rx.operators.OperationToObservableFuture;, +import rx.operators.OperationToObservableIterable;, +import rx.operators.OperationToObservableList;, +import rx.operators.OperationToObservableSortedList;, +import rx.operators.OperationZip;, +import rx.operators.OperatorGroupBy;, +import rx.operators.OperatorTakeUntil;, +import rx.operators.OperatorToIterator;, + public <T2>
[+++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, +import rx.Observable.OnSubscribe;, +import rx.Observer;, +public class GroovyCreateWrapper<T> implements OnSubscribe<T> {, + public void call(Observer<? super T> op) {, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, +import rx.Observable.OnSubscribe;, +import rx.Observer;, +public class GroovyCreateWrapper<T> implements OnSubscribe<T> {, + public void call(Observer<? super T> op) {, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, +import rx.Observable.OnSubscribe;, +import rx.Observer;, +public class GroovyCreateWrapper<T> implements OnSubscribe<T> {, + public void call(Observer<? super T> op) {, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subject.scala, + val asJavaObservable: rx.Observable[_ <: T] = asJavaSubject.toObservable(), +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, +import rx.Observable.OnSubscribe;, +import rx.Observer;, +public class GroovyCreateWrapper<T> implements OnSubscribe<T> {, + public void call(Observer<? super T> op) {, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subject.scala, +
[+++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeConcatArray.java, + Disposable cancelled = disposables;, + if (cancelled.isDisposed()) {, + if (goNextSource && !cancelled.isDisposed()) {, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeConcatArray.java, + Disposable cancelled = disposables;, + if (cancelled.isDisposed()) {, + if (goNextSource && !cancelled.isDisposed()) {, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeConcatArrayDelayError.java, + Disposable cancelled = disposables;, + if (cancelled.isDisposed()) {, + if (goNextSource && !cancelled.isDisposed()) {, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeConcatArray.java, + Disposable cancelled = disposables;, + if (cancelled.isDisposed()) {, + if (goNextSource && !cancelled.isDisposed()) {, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeConcatArrayDelayError.java, + Disposable cancelled = disposables;, + if (cancelled.isDisposed()) {, + if (goNextSource && !cancelled.isDisposed()) {, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeConcatIterable.java, + Disposable cancelled = disposables;, + if (cancelled.isDisposed()) {, + if (goNextSource
[+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableCollect.java, +import io.reactivex.plugins.RxJavaPlugins;, + boolean done;, + , + if (done) {, + return;, + }, + onError(e);, + if (done) {, + RxJavaPlugins.onError(t);, + return;, + }, + done = true;, + if (done) {, + return;, + }, + done = true;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableCollect.java, +import io.reactivex.plugins.RxJavaPlugins;, + boolean done;, + , + if (done) {, + return;, + }, + onError(e);, + if (done) {, + RxJavaPlugins.onError(t);, + return;, + }, + done = true;, + if (done) {, + return;, + }, + done = true;, +++ b/src/test/java/io/reactivex/flowable/FlowableCollectTest.java, +import static io.reactivex.internal.util.TestingHelper.addToList;, +import static io.reactivex.internal.util.TestingHelper.biConsumerThrows;, +import
[+++ b/src/main/java/io/reactivex/Maybe.java, + * <p>, + * <img width="640" height="519" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.amb.png" alt="">, + * <p>, + * <img width="640" height="519" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.ambArray.png" alt="">, + * <p>, + * <img width="640" height="526" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concat.i.png" alt="">, + * <p>, + * <img width="640" height="416" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concat.p.png" alt="">, + * <p>, + * <img width="640" height="416" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concat.pn.png" alt="">, + * <p>, + * <img width="640" height="526" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatArray.png" alt="">, + * <img width="640" height="425" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatArrayDelayError.png" alt="">, + * <p>, + * <img width="640" height="489" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatArrayEager.png" alt="">, + * <p>, + * <img width="640" height="469" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatDelayError.i.png" alt="">, + * <p>, + * <img width="640" height="360" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatDelayError.p.png" alt="">,
[+++ b/src/main/java/io/reactivex/Maybe.java, + * through and turning an empty Maybe into a signal of NoSuchElementException., + * through and turning an empty Maybe into a signal of NoSuchElementException.]
[+++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/build.gradle, +// Establish version and status, +ext.githubProjectName = rootProject.name // Change if github project name is not the same as the root project's name, + repositories {, + mavenLocal(), + mavenCentral() // maven { url 'http://jcenter.bintray.com' }, + }, + repositories { , + mavenCentral() // maven { url: 'http://jcenter.bintray.com'
[+++ b/src/main/java/io/reactivex/Maybe.java, + * Returns a Maybe instance that calls the given onTerminate callback, + * just before this Maybe completes normally or with an exception., + * <p>, + * <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnTerminate.png" alt="">, + * <p>, + * This differs from {@code doAfterTerminate} in that this happens <em>before</em> the {@code onComplete} or, + * {@code onError} notification., + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code doOnTerminate} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + * @param onTerminate the action to invoke when the consumer calls {@code onComplete} or {@code
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationGroupBy;, +import rx.operators.OperationTakeUntil;, +import rx.operators.OperationToIterator;, + return OperationTakeUntil.takeUntil(source, other);, + return create(OperationGroupBy.groupBy(source, keySelector, elementSelector));, + return create(OperationGroupBy.groupBy(source, keySelector));, + return OperationToIterator.toIterator(that);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationGroupBy;, +import rx.operators.OperationTakeUntil;, +import rx.operators.OperationToIterator;, + return OperationTakeUntil.takeUntil(source, other);, + return create(OperationGroupBy.groupBy(source, keySelector, elementSelector));, + return create(OperationGroupBy.groupBy(source, keySelector));, + return OperationToIterator.toIterator(that);, +++ b/rxjava-core/src/main/java/rx/operators/OperationAll.java, + private final AtomicBoolean status = new AtomicBoolean(true);, + return subscription.wrap(sequence.subscribe(new Observer<T>() {, + observer.onNext(true);, + observer.onCompleted();, + observer.onError(e);, + observer.onNext(false);, + observer.onCompleted();, + }));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationGroupBy;, +import rx.operators.OperationTakeUntil;, +import rx.operators.OperationToIterator;, + return OperationTakeUntil.takeUntil(source, other);, + return create(OperationGroupBy.groupBy(source, keySelector, elementSelector));, + return create(OperationGroupBy.groupBy(source, keySelector));, + return OperationToIterator.toIterator(that);,
[+++ b/pmd.xml, +++ b/pmd.xml, +++ b/src/main/java/io/reactivex/Completable.java, + /** Single instance of a complete Completable. */, + static final Completable COMPLETE = new CompletableEmpty();, + , + /** Single instance of a never Completable. */, + static final Completable NEVER = new CompletableNever();, + , + } catch (NullPointerException ex) { // NOPMD, + } catch (NullPointerException ex) { // NOPMD, +++ b/pmd.xml, +++ b/src/main/java/io/reactivex/Completable.java, + /** Single instance of a complete Completable. */, + static final Completable COMPLETE = new CompletableEmpty();, + , + /** Single instance of a never Completable. */, + static final Completable NEVER = new
[+++ b/CHANGES.md, +### Version 0.15.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.15.1%22)) ###, +, +This release should be additive functionality and bug fixes., +, +* [Pull 510](https://github.com/Netflix/RxJava/pull/506) Operators: And, Then, When, +* [Pull 514](https://github.com/Netflix/RxJava/pull/514) Operator: Join, +* [Pull 525](https://github.com/Netflix/RxJava/pull/526) Operators: toMap/toMultiMap, +* [Pull 510](https://github.com/Netflix/RxJava/pull/510) BugFix: Zip, +* [Pull 512](https://github.com/Netflix/RxJava/pull/512) Scala Adaptor Details, +* [Pull 512](https://github.com/Netflix/RxJava/pull/529) Scala fixes, +* [Pull 508](https://github.com/Netflix/RxJava/pull/508) Empty subscribe , +* [Pull 522](https://github.com/Netflix/RxJava/pull/522) Unsubscribe from takeLast, +* [Pull 525](https://github.com/Netflix/RxJava/pull/525) BugFix: Handling of Terminal State for Behavior/Publish Subjects, +, +++ b/CHANGES.md, +### Version 0.15.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.15.1%22)) ###, +, +This release should be additive functionality and bug fixes., +, +* [Pull 510](https://github.com/Netflix/RxJava/pull/506) Operators:
[+++ b/src/main/java/io/reactivex/Observable.java, +import io.reactivex.functions.*;, + , + , + @SuppressWarnings("unchecked"), + public static <T1, T2, R> Observable<R> zip(, + Publisher<? extends T1> p1, Publisher<? extends T2> p2, , + BiFunction<? super T1, ? super T2, ? extends R> zipper) {, + Function<Object[], R> f = a -> {, + if (a.length != 2) {, + throw new IllegalArgumentException("Array of size 2 expected but got " + a.length);, + }, + return ((BiFunction<Object, Object, R>)zipper).apply(a[0], a[1]);, + };, + return zipArray(f, false, bufferSize(), (Publisher<Object>)p1, (Publisher<Object>)p2);, + }, +, + public static <T1, T2, T3, R> Observable<R> zip(, + Publisher<? extends
[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subscription.scala, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for
[+++ b/rxjava-contrib/rxjava-android/build.gradle, + provided 'org.robolectric:robolectric:2.1.1', +++ b/rxjava-contrib/rxjava-android/build.gradle, + provided 'org.robolectric:robolectric:2.1.1', +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/concurrency/HandlerThreadScheduler.java, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, + @RunWith(RobolectricTestRunner.class), + @Config(manifest=Config.NONE), +++ b/rxjava-contrib/rxjava-android/build.gradle, + provided 'org.robolectric:robolectric:2.1.1', +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/concurrency/HandlerThreadScheduler.java, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, + @RunWith(RobolectricTestRunner.class), + @Config(manifest=Config.NONE), +++ /dev/null, +++ b/rxjava-contrib/rxjava-android/build.gradle, + provided 'org.robolectric:robolectric:2.1.1', +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/concurrency/HandlerThreadScheduler.java, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, + @RunWith(RobolectricTestRunner.class), + @Config(manifest=Config.NONE), +++ /dev/null, +++ /dev/null, +++ b/rxjava-contrib/rxjava-android/build.gradle, + provided 'org.robolectric:robolectric:2.1.1', +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/concurrency/HandlerThreadScheduler.java, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, + @RunWith(RobolectricTestRunner.class), + @Config(manifest=Config.NONE), +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/rxjava-contrib/rxjava-android/build.gradle, + provided 'org.robolectric:robolectric:2.1.1', +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/concurrency/HandlerThreadScheduler.java, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, + @RunWith(RobolectricTestRunner.class), + @Config(manifest=Config.NONE), +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/README.md, +## Documentation, +, +You can build the documentation as follows: In the RxJava root directory, run, +, + ./gradlew :language-adaptors:rxjava-scala:scaladoc, +, +Then navigate to, +, + RxJava/language-adaptors/rxjava-scala/build/docs/scaladoc/index.html, +, +, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/README.md, +## Documentation, +, +You can build the documentation as follows: In the RxJava root directory, run, +, + ./gradlew :language-adaptors:rxjava-scala:scaladoc, +, +Then navigate to, +, + RxJava/language-adaptors/rxjava-scala/build/docs/scaladoc/index.html, +, +, +++ b/language-adaptors/rxjava-scala/build.gradle, + main { , + test { , + scala {
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.12.2-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.12.2-SNAPSHOT, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyFunctionWrapper.java, +public class GroovyFunctionWrapper<T1, T2, T3, T4, R> implements Func0<R>, Func1<T1, R>, Func2<T1, T2, R>, Func3<T1, T2, T3, R>, Func4<T1, T2, T3, T4, R> {, + , +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.12.2-SNAPSHOT, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyFunctionWrapper.java, +public class GroovyFunctionWrapper<T1, T2, T3, T4, R> implements Func0<R>, Func1<T1, R>, Func2<T1, T2, R>, Func3<T1, T2, T3, R>, Func4<T1, T2, T3, T4, R> {, + , +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/ConnectableObservable.scala, +package rx.lang.scala, +, +, +class ConnectableObservable[+T](val asJava: rx.observables.ConnectableObservable[_ <: T]) {, + import All._, + import All.util._, + import rx.{Observable => JObservable}, + import
[+++ b/gradle/convention.gradle, + gradleVersion = '1.4', +++ b/gradle/convention.gradle, + gradleVersion = '1.4', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/convention.gradle, + gradleVersion = '1.4', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Mar 05 10:18:48 PST 2013, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.4-bin.zip, +++ b/gradle/convention.gradle, + gradleVersion = '1.4', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Mar 05 10:18:48 PST 2013, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.4-bin.zip, +++ b/gradlew, +#!/usr/bin/env bash, +cd "`dirname \"$PRG\"`/" >&-, +cd "$SAVED" >&-]
[+++ b/rxjava-contrib/rxjava-computation-expressions/src/main/java/rx/Statement.java, +import rx.operators.OperatorIfThen;, +import rx.operators.OperatorSwitchCase;, +import rx.operators.OperatorWhileDoWhile;, +public final class Statement {, + private Statement() { throw new IllegalStateException("No instances!"); }, + return Observable.create(new OperatorSwitchCase<K, R>(caseSelector, mapOfCases, defaultCase));, + public static <T> Observable<T> doWhile(Observable<? extends T> source, Func0<Boolean> postCondition) {, + return Observable.create(new OperatorWhileDoWhile<T>(source, TRUE, postCondition));, + public static <T> Observable<T> whileDo(Observable<? extends T> source, Func0<Boolean> preCondition) {, + return Observable.create(new OperatorWhileDoWhile<T>(source, preCondition, preCondition));, + return Observable.create(new OperatorIfThen<R>(condition, then, orElse));, + }, + /** Returns always true. */, + private static final class Func0True implements Func0<Boolean> {, + @Override, + public Boolean call() {, + return true;, +
[+++ b/build.gradle, + toolVersion ="6.19" , +++ b/build.gradle, + toolVersion ="6.19" , +++ b/checkstyle.xml, +<property name="severity" value="warning"/>, + <property name="severity" value="warning"/>, + <!-- , + <module name="ExplicitInitialization"/>, + <module name="SummaryJavadoc"/>, + <module name="ModifierOrder"/>, + <module name="RedundantModifier"/>, + <module name="NeedBraces"/>, + <module name="EqualsHashCode"/>, + <module name="FallThrough"/>, + <module name="MultipleVariableDeclarations">, + <property name="severity" value="ignore"/>, + <metadata name="net.sf.eclipsecs.core.lastEnabledSeverity" value="inherit"/>, + <module name="PackageDeclaration"/>, + <module name="FinalClass"/>, + <module name="HideUtilityClassConstructor"/>, + <module name="WhitespaceAround">, + <property name="tokens" value="ASSIGN,BAND,BAND_ASSIGN,BOR,BOR_ASSIGN,BSR,BSR_ASSIGN,BXOR,BXOR_ASSIGN,COLON,DIV,DIV_ASSIGN,DO_WHILE,EQUAL,GE,GT,LAMBDA,LAND,LCURLY,LE,LITERAL_ASSERT,LITERAL_CATCH,LITERAL_DO,LITERAL_ELSE,LITERAL_FINALLY,LITERAL_FOR,LITERAL_IF,LITERAL_RETURN,LITERAL_SYNCHRONIZED,LITERAL_TRY,LITERAL_WHILE,LOR,LT,MINUS,MINUS_ASSIGN,MOD,MOD_ASSIGN,NOT_EQUAL,PLUS,PLUS_ASSIGN,QUESTION,SL,SLIST,SL_ASSIGN,SR,SR_ASSIGN,STAR,STAR_ASSIGN,TYPE_EXTENSION_AND"/>, + </module>, + -->, + </module>, + <!-- , + <module name="JavadocPackage">, + <property name="severity" value="ignore"/>, + <metadata name="net.sf.eclipsecs.core.lastEnabledSeverity" value="inherit"/>, + </module>, + <module name="FileTabCharacter">, + <property
[+++ b/.travis.yml, + , +sudo: false, +# as per http://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/, +++ b/.travis.yml, + , +sudo: false, +# as per http://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/, +++ b/CHANGES.md, +### Version 1.0.4 – December 29th 2014 ([Maven Central](http://search.maven.org/#artifactdetails%7Cio.reactivex%7Crxjava%7C1.0.4%7C)) ###, +, +* [Pull 2156] (https://github.com/ReactiveX/RxJava/pull/2156) Fix the issue that map may swallow fatal exceptions, +* [Pull 1967] (https://github.com/ReactiveX/RxJava/pull/1967) Fix the issue that GroupBy may not call 'unsubscribe', +* [Pull 2052] (https://github.com/ReactiveX/RxJava/pull/2052) OperatorDoOnRequest.ParentSubscriber should be static class, +* [Pull 2237] (https://github.com/ReactiveX/RxJava/pull/2237) Make Publish Operator Release RingBuffer, +* [Pull 2053] (https://github.com/ReactiveX/RxJava/pull/2053) Fixed wrong bounded ReplaySubject use in test, +, +### Version 1.0.3 – December 15th 2014 ([Maven Central](http://search.maven.org/#artifactdetails%7Cio.reactivex%7Crxjava%7C1.0.3%7C)) ###,
[+++ b/gradle.properties, +version=0.8.2-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * <p>, + * Note that if element type {@code T} in the flow is mutable, the comparison of the previous and current, + * item may yield unexpected results if the items are mutated externally. Common cases are mutable, + * {@code CharSequence}s or {@code List}s where the objects will actually have the same, + * references when they are modified and {@code distinctUntilChanged} will evaluate subsequent items as same., + * To avoid such situation, it is recommended that mutable data is converted to an immutable one,, + * for example using `map(CharSequence::toString)` or
[+++ b/src/main/java/io/reactivex/Flowable.java, + return new FlowableSubscribeOn<T>(this, scheduler);, +++ b/src/main/java/io/reactivex/Flowable.java, + return new FlowableSubscribeOn<T>(this, scheduler);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSubscribeOn.java, +import java.util.concurrent.atomic.*;, +import io.reactivex.internal.util.BackpressureHelper;, + public FlowableSubscribeOn(Publisher<? extends T> source, Scheduler scheduler) {, + s.onSubscribe(sos);, + , + sos.lazySet(Thread.currentThread());, + static final class SubscribeOnSubscriber<T> extends AtomicReference<Thread>, + implements Subscriber<T>, Subscription {, + final AtomicReference<Subscription> s;, + , + final AtomicLong requested;, + this.s = new AtomicReference<Subscription>();, + this.requested = new AtomicLong();, + if (SubscriptionHelper.setOnce(this.s, s)) {, + long r = requested.getAndSet(0L);, + if (r != 0L) {, + requestUpstream(r, s);, + }, + Subscription s = this.s.get();, + if (s != null) {,
[+++ b/src/main/java/io/reactivex/Maybe.java, + * Note that {@code onSuccess}, {@code onError} and {@code onComplete} are mutually exclusive events; unlike {@code Observable},, + * {@code onSuccess} is never followed by {@code onError} or {@code onComplete}., + * <img width="640" height="358" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnComplete.m.png" alt="">, + * <p>, + * <img width="640" height="358" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnError.m.png" alt="">, + * <p>, + * <img width="640" height="358" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnSuccess.m.png" alt="">, + * MaybeSource's signals., + * that call is propagated up on the specified scheduler.]
[+++ b/src/main/java/io/reactivex/processors/AsyncProcessor.java, + * @deprecated in 2.1.14; put the result of {@link #getValue()} into an array manually, will be removed in 3.x, + @Deprecated, + * @deprecated in 2.1.14; put the result of {@link #getValue()} into an array manually, will be removed in 3.x, + @Deprecated, +++ b/src/main/java/io/reactivex/processors/AsyncProcessor.java, + * @deprecated in 2.1.14; put the result of {@link #getValue()} into an array manually, will be removed in 3.x, + @Deprecated, + * @deprecated in 2.1.14; put the result of {@link #getValue()} into an array manually, will be removed in 3.x, + @Deprecated, +++ b/src/main/java/io/reactivex/processors/BehaviorProcessor.java, + * @deprecated in 2.1.14;
[+++ b/.gitattributes, +# Set default behaviour, in case users don't have core.autocrlf set., +* text=auto, +, +# Explicitly declare text files we want to always be normalized and converted , +# to native line endings on checkout., +*.java text, +*.groovy text, +*.scala text, +*.clj text, +*.txt text, +*.md text, +, +# Denote all files that are truly binary and should not be modified., +*.png binary, +*.jpg binary, +++ b/.gitattributes, +# Set default behaviour, in case users don't have core.autocrlf set., +* text=auto, +, +# Explicitly declare text files we want to always be normalized and converted , +# to
[+++ b/src/main/java/io/reactivex/Observable.java, + throw new IndexOutOfBoundsException("index >= 0 required but it was " + index);, + throw new IndexOutOfBoundsException("index >= 0 required but it was " + index);, +++ b/src/main/java/io/reactivex/Observable.java, + throw new IndexOutOfBoundsException("index >= 0 required but it was " + index);, + throw new IndexOutOfBoundsException("index >= 0 required but it was " + index);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorElementAt.java, + if (index <= count && !done) {, + actual.onError(new IndexOutOfBoundsException());, +++ b/src/main/java/io/reactivex/Observable.java, + throw new IndexOutOfBoundsException("index >= 0 required but it was " + index);, + throw new IndexOutOfBoundsException("index >= 0 required but it was " + index);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorElementAt.java,
[+++ b/src/main/java/io/reactivex/Flowable.java, + * within periodic time intervals and optionally emit the very last upstream item when the upstream completes., + * <p>, + * <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.png" alt="">, + * <dl>, + * <dt><b>Backpressure:</b></dt>, + * <dd>This operator does not support backpressure as it uses time to control data flow.</dd>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code sample} operates by default on the {@code computation} {@link Scheduler}.</dd>, + * </dl>, + *, + * @param period, + * the sampling rate, + * @param unit, + * the {@link TimeUnit} in which {@code period} is defined, + *
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Calls the specified consumer with the current item after this item has been emitted to the downstream., + * <p>Note that the {@code onAfterNext} action is shared between subscriptions and as such, + * should be thread-safe., + * <dl>, + * <dt><b>Backpressure:</b></dt>, + * <dd>The operator doesn't interfere with backpressure which is determined by the source {@code Publisher}'s backpressure, + * behavior.</dd>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code doAfterNext} does not operate by default on a particular {@link Scheduler}.</dd>, + * <td><b>Operator-fusion:</b></dt>, + * <dd>This operator supports normal and conditional Subscribers as well as
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ /dev/null, +++ b/CHANGES.md, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/gradle.properties, +version=0.17.0-RC4]
[+++ b/src/main/java/io/reactivex/processors/BehaviorProcessor.java, + * is required to be serialized (called from the same thread or called non-overlappingly from different threads, +++ b/src/main/java/io/reactivex/processors/BehaviorProcessor.java, + * is required to be serialized (called from the same thread or called non-overlappingly from different threads, +++ b/src/main/java/io/reactivex/subjects/AsyncSubject.java, + * A Subject that emits the very last value followed by a completion event or the received error to Observers., + * <p>, + * This subject does not have a public constructor by design; a new empty instance of this, + * {@code AsyncSubject} can be created via the {@link #create()} method., + * <p>,
[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +, + @Test def liftExample1(): Unit = {, + // Add "No. " in front of each item, + val o = List(1, 2, 3).toObservable.lift {, + subscriber: Subscriber[String] =>, + Subscriber(, + subscriber,, + v => subscriber.onNext("No. " + v),, + e => subscriber.onError(e),, + () => subscriber.onCompleted, + ), + }.toBlockingObservable.toList, + println(o), + }, +, + @Test def liftExample2(): Unit = {, + val o = Observable {, + subscriber: Subscriber[Int] => {, + for (i <- 1 to 10 if !subscriber.isUnsubscribed) {, + println("emit " + i), + subscriber.onNext(i), + }, + if
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAll.java, + if (!SubscriptionHelper.validateRequest(n)) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAll.java, + if (!SubscriptionHelper.validateRequest(n)) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAmb.java, + if (!SubscriptionHelper.validateRequest(n)) {, + } else if (SubscriptionHelper.validateRequest(n)) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAll.java, + if (!SubscriptionHelper.validateRequest(n)) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAmb.java, + if (!SubscriptionHelper.validateRequest(n)) {, + } else if (SubscriptionHelper.validateRequest(n)) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAny.java, + if (!SubscriptionHelper.validateRequest(n)) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAll.java, + if (!SubscriptionHelper.validateRequest(n)) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAmb.java, + if (!SubscriptionHelper.validateRequest(n)) {, + } else if (SubscriptionHelper.validateRequest(n)) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAny.java, + if (!SubscriptionHelper.validateRequest(n)) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java, + }, + if (!SubscriptionHelper.validateRequest(n)) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAll.java, + if (!SubscriptionHelper.validateRequest(n)) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAmb.java, + if (!SubscriptionHelper.validateRequest(n)) {, + } else if (SubscriptionHelper.validateRequest(n)) {, +++
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorFromIterable;, +import rx.operators.OperatorTake;, +import rx.operators.OperatorToObservableList;, +import rx.operators.OperatorToObservableSortedList;, + final Action2<Observer<? super T>, OperatorSubscription> f;, +, + /**, + * Observable with Function to execute when subscribed to., + * <p>, + * NOTE: Use {@link #create(OnSubscribeFunc)} to create an Observable, + * instead of this constructor unless you specifically have a need for, + * inheritance., + * , + * @param onSubscribe, + * {@link OnSubscribeFunc} to be executed when {@link #subscribe(Observer)} is called, + */, + protected Observable(Action2<Observer<? super T>, OperatorSubscription> f) {, + this.f = f;, + }, +, +<<<<<<< HEAD, +=======, +>>>>>>>
[+++ b/src/main/java/io/reactivex/internal/fuseable/SimplePlainQueue.java, + * Override of the SimpleQueue interface with no throws Exception on poll()., +++ b/src/main/java/io/reactivex/internal/fuseable/SimplePlainQueue.java, + * Override of the SimpleQueue interface with no throws Exception on poll()., +++ b/src/main/java/io/reactivex/internal/fuseable/SimpleQueue.java, +import io.reactivex.annotations.*;, + /**, + * Atomically enqueue a single., + * @param value the value to enqueue, not null, + * @return true if successful, false if the value was not enqueued, + * likely due to reaching the queue capacity), + */, + boolean offer(@NonNull T value);, + * Atomically enqueue two values., + * @param v1 the first value to enqueue, not null, +
[+++ b/src/main/java/io/reactivex/Flowable.java, + return fromPublisher(sources).toList().flatMapPublisher(FlowableInternalHelper.<T, R>zipIterable(zipper));, + * Returns a Single that emits a Boolean that indicates whether all of the items emitted by the source, + * Returns a Single that emits {@code true} if any item emitted by the source Publisher satisfies a, + * Collects items emitted by the source Publisher into a single mutable data structure and returns, + * a Single that emits this structure., + * @return a Single that emits the result of collecting the values emitted by the source Publisher, + public final <U> Single<U> collect(Callable<? extends U> initialItemSupplier, BiConsumer<? super
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorMerge;, + return source.bind(new OperatorMerge()); // any idea how to get these generics working?!, + return source.bind(new OperatorMerge(maxConcurrent)); // any idea how to get these generics working?!, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorMerge;, + return source.bind(new OperatorMerge()); // any idea how to get these generics working?!, + return source.bind(new OperatorMerge(maxConcurrent)); // any idea how to get these generics working?!, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorMerge;, + return source.bind(new OperatorMerge()); // any idea how to get these generics working?!, + return source.bind(new OperatorMerge(maxConcurrent)); // any idea how to get these generics working?!, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperationMergeDelayError.java, + * This
[+++ b/src/main/java/io/reactivex/observables/ConnectableObservable.java, + * @return an {@link Observable}]
[+++ b/src/main/java/io/reactivex/Observable.java, + , + public final Observable<T> mergeWith(Publisher<? extends T> other) {, + return merge(this, other);, + }, + , + public final <R> Observable<R> concatMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {, + return concatMap(mapper, 2);, + }, + , + public final <R> Observable<R> concatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int prefetch) {, + Objects.requireNonNull(mapper);, + if (prefetch <= 0) {, + throw new IllegalArgumentException("prefetch > 0 required but it was " + prefetch);, + }, + return lift(new ConcatMap<>(mapper, prefetch));, + }, + , + public final Observable<T> concatWith(Publisher<? extends
[+++ b/.gitignore, +, +# Scala build, +*.cache]
[+++ b/src/main/java/io/reactivex/Observable.java, + * <p>, + * <img width="640" height="410" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.nce.png" alt="">, + * <p>, + * <img width="640" height="390" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.r.png" alt="">, + * <p>, + * <img width="640" height="390" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.r.png" alt="">, + * <p>, + * <img width="640" height="390" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/mergeMap.r.png" alt="">, + * <p>, + * <img width="640" height="424" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapCompletable.o.png" alt="">, + * <p>, + * <img width="640" height="361" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapCompletableDelayError.o.png" alt="">, + * <img width="640" height="343" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.o.png" alt="">, + * <img width="640" height="410" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.o.r.png" alt="">, + * <img width="640" height="264" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/forEach.o.png" alt="">, + * <p>, + * <img width="640" height="272" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/forEachWhile.o.png" alt="">, + * <p>, + * <p>,
[+++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, + android:name=".UIBindingActivity">, +, + <intent-filter>, + <category android:name="android.intent.category.LAUNCHER"/>, + <category android:name="android.intent.category.DEFAULT"/>, + <action android:name="android.intent.action.MAIN"/>, + </intent-filter>, + </activity>, + <activity, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, + android:name=".UIBindingActivity">, +, + <intent-filter>, + <category android:name="android.intent.category.LAUNCHER"/>, + <category android:name="android.intent.category.DEFAULT"/>, + <action android:name="android.intent.action.MAIN"/>, + </intent-filter>, + </activity>, + <activity, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/UIBindingActivity.java, +package com.netflix.rxjava.android.samples;, +, +import android.app.Activity;, +import android.app.Fragment;, +import android.os.Bundle;, +import android.view.LayoutInflater;, +import android.view.View;, +import android.view.ViewGroup;, +import android.view.Window;, +import android.widget.Button;, +import android.widget.TextView;, +import org.json.JSONException;, +import org.json.JSONObject;, +import rx.Observable;, +import rx.Subscription;, +import rx.android.schedulers.AndroidSchedulers;, +import rx.functions.Action1;, +import rx.functions.Func1;, +import rx.subscriptions.Subscriptions;, +, +/**, + * Problem:, + * You have a data source (where that data is
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/CHANGES.md, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, + * This Observable produces connected non-overlapping buffers. The current buffer is, + * emitted and replaced with a new buffer when the Observable produced by the specified function produces an object. The function will then, + * be used to create a new Observable to listen for the end of the next buffer., + *, + * @param closings, + * The function which is used to produce an [[rx.lang.scala.Observable]] for every buffer created., + * When this [[rx.lang.scala.Observable]] produces an object, the associated buffer, +
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationOnErrorResumeNextViaObservable;, +import rx.operators.OperatorOnErrorReturn;, + return create(OperationOnErrorResumeNextViaObservable.onErrorResumeNextViaObservable(this, resumeSequence));, + return lift(new OperatorOnErrorReturn<T>(resumeFunction));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationOnErrorResumeNextViaObservable;, +import rx.operators.OperatorOnErrorReturn;, + return create(OperationOnErrorResumeNextViaObservable.onErrorResumeNextViaObservable(this, resumeSequence));, + return lift(new OperatorOnErrorReturn<T>(resumeFunction));, +++ b/rxjava-core/src/main/java/rx/operators/OperationOnErrorResumeNextViaObservable.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, +
[+++ b/src/main/java/io/reactivex/Flowable.java, + * <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed, + * in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items). , + * The inner {@code Publisher}s are expected to honor backpressure; if violated, , + * the operator <em>may</em> signal {@code MissingBackpressureException}.</dd>, + * <dd>The operator honors backpressure from downstream. The upstream Flowable is consumed, + * in a bounded manner (up to {@link #bufferSize()} outstanding request amount for items). , + * The inner {@code Publisher}s are expected to honor backpressure; if violated, , + * the
[+++ b/src/main/java/io/reactivex/Flowable.java, + @SchedulerSupport(SchedulerSupport.NONE) // Trampoline scheduler is only used for creating timestamps., + @SchedulerSupport(SchedulerSupport.NONE) // Supplied scheduler is only used for creating timestamps., + @SchedulerSupport(SchedulerSupport.NONE) // Trampoline scheduler is only used for creating timestamps., + @SchedulerSupport(SchedulerSupport.NONE) // Supplied scheduler is only used for creating timestamps., + @SchedulerSupport(SchedulerSupport.NONE) // Trampoline scheduler is only used for creating timestamps., + @SchedulerSupport(SchedulerSupport.NONE) // Supplied scheduler is only used for creating timestamps., + @SchedulerSupport(SchedulerSupport.NONE) // Trampoline scheduler is only used for creating timestamps., + @SchedulerSupport(SchedulerSupport.NONE) // Supplied scheduler is only used for creating timestamps., +++ b/src/main/java/io/reactivex/Flowable.java, + @SchedulerSupport(SchedulerSupport.NONE) // Trampoline scheduler is only
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.internal.operators.*;, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.internal.operators.*;, +++ b/rxjava-core/src/main/java/rx/internal/operators/BlockingOperatorLatest.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY
[+++ b/.travis.yml, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/src/main/java/rx/Observable.java, + * @Beta, + * @Beta, + return Subscriptions.empty();, + return Subscriptions.empty();, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/build.gradle, +
[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, + * Note: this action will cache the latest items arriving in the specified time window., + * Note: this action will cache the latest items arriving in the specified time window., +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, + * Note: this action will cache the latest items arriving in the specified time window., + * Note: this action will cache the latest items arriving in the specified time window., +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationAsObservable;, + return create(new OperationAsObservable<T>(this));, + * Note: this action will cache the latest items arriving in the specified time window., + * Note: this action will cache
[+++ b/gradle.properties, +version=0.13.0]
[+++ b/gradle.properties, +version=0.14.10-SNAPSHOT, +++ b/gradle.properties, +version=0.14.10-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import java.util.Comparator;, +import rx.operators.OperationMax;, +import rx.operators.OperationMin;, + * @throws IllegalArgumentException, + * if Observable sequence is empty., + /*, + * Discussion and confirmation of implementation at https://github.com/Netflix/RxJava/issues/423#issuecomment-27642532, + * , + * It should use last() not takeLast(1) since it needs to emit an error if the sequence is empty., + */, + return create(OperationScan.scan(this, accumulator)).last();, + * Returns the minimum element in an observable sequence., + * For an empty source, it causes an {@link IllegalArgumentException}., + *, + * @param source, + * an observable sequence to determine
[+++ b/README.md, +<a href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-jruby">and JRuby</a>. , +++ b/README.md, +<a href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-jruby">and JRuby</a>. , +++ b/language-adaptors/rxjava-clojure/build.gradle, +++ b/README.md, +<a href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-jruby">and JRuby</a>. , +++ b/language-adaptors/rxjava-clojure/build.gradle, +++ /dev/null, +++ b/README.md, +<a href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-jruby">and JRuby</a>. , +++ b/language-adaptors/rxjava-clojure/build.gradle, +++ /dev/null, +++ /dev/null, +++ b/README.md, +<a href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-jruby">and JRuby</a>. , +++ b/language-adaptors/rxjava-clojure/build.gradle, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-groovy/build.gradle, + provided 'org.codehaus.groovy:groovy-all:2.+', +++ b/README.md, +<a href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-jruby">and JRuby</a>. , +++ b/language-adaptors/rxjava-clojure/build.gradle, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-groovy/build.gradle, + provided 'org.codehaus.groovy:groovy-all:2.+', +++ /dev/null, +++ b/README.md, +<a href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-jruby">and JRuby</a>. , +++ b/language-adaptors/rxjava-clojure/build.gradle, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-groovy/build.gradle, + provided 'org.codehaus.groovy:groovy-all:2.+', +++ /dev/null, +++ /dev/null, +++ b/README.md, +<a href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-jruby">and JRuby</a>. ,
[+++ b/.travis.yml, + - $HOME/.gradle]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDoOnEach.java, +import io.reactivex.internal.fuseable.ConditionalSubscriber;, +import io.reactivex.internal.subscribers.flowable.*;, +import io.reactivex.internal.util.Exceptions;, + if (s instanceof ConditionalSubscriber) {, + source.subscribe(new DoOnEachConditionalSubscriber<T>(, + (ConditionalSubscriber<? super T>)s, onNext, onError, onComplete, onAfterTerminate));, + } else {, + source.subscribe(new DoOnEachSubscriber<T>(, + s, onNext, onError, onComplete, onAfterTerminate));, + }, + static final class DoOnEachSubscriber<T> extends BasicFuseableSubscriber<T, T> {, + super(actual);, + , + if (sourceMode != NONE) {, + actual.onNext(null);, + return;, + }, + , + fail(e);, + Exceptions.throwIfFatal(e);, + fail(e);, + public int requestFusion(int mode) {, + return transitiveBoundaryFusion(mode);, + public T poll() {, + T v = qs.poll();, + , + if (v != null)
[+++ b/gradle.properties, +version=0.13.6-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java, + boolean doReplay = true;, + if (state.addChild(rp)) {, + if (rp.requested.get() == ReplaySubscription.CANCELLED) {, + state.removeChild(rp);, + doReplay = false;, + }, + }, +, + if (doReplay) {, + rp.replay();, + }, + * @return true if the ReplaySubscription was added or false if the cache is already terminated, + public boolean addChild(ReplaySubscription<T> p) {, + return false;, + return true;, + private static final long CANCELLED = Long.MIN_VALUE;, + /**, + * Number of items requested and also the cancelled indicator if, + * it contains {@link #CANCELLED}., + */, + /** Number of
[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, + o.observeOn(NewThreadScheduler()).subscribe(, + o.observeOn(NewThreadScheduler()).subscribe(, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, + o.observeOn(NewThreadScheduler()).subscribe(, + o.observeOn(NewThreadScheduler()).subscribe(, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/ImplicitFunctionConversions.scala, +, +import rx.util.functions._, +, +// implicit def schedulerActionToFunc2[T](action: (Scheduler, T) => Subscription): Func2[rx.Scheduler, T, rx.Subscription] with Object {def call(s: rx.Scheduler, t: T): rx.Subscription} =, +// new Func2[rx.Scheduler, T, rx.Subscription] {, +// def call(s: rx.Scheduler, t: T): rx.Subscription = {, +// action(rx.lang.scala.Scheduler(s), t).asJavaSubscription, +// }, +// }, +, + action(Scheduler(s), t).asJavaSubscription, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, + o.observeOn(NewThreadScheduler()).subscribe(, + o.observeOn(NewThreadScheduler()).subscribe(, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/ImplicitFunctionConversions.scala, +, +import rx.util.functions._, +, +// implicit def schedulerActionToFunc2[T](action: (Scheduler, T) => Subscription): Func2[rx.Scheduler, T, rx.Subscription] with Object {def call(s: rx.Scheduler, t:
[+++ b/src/main/java/io/reactivex/processors/BehaviorProcessor.java, +import io.reactivex.annotations.*;, + /**, + * Tries to emit the item to all currently subscribed Subscribers if all of them, + * has requested some value, returns false otherwise., + * <p>, + * This method should be called in a sequential manner just like the onXXX methods, + * of the PublishProcessor., + * <p>, + * Calling with null will terminate the PublishProcessor and a NullPointerException, + * is signalled to the Subscribers., + * @param t the item to emit, not null, + * @return true if the item was emitted to all Subscribers,
[+++ b/src/main/java/io/reactivex/Observable.java, + * the sequence (subscription, disposal)., +++ b/src/main/java/io/reactivex/Observable.java, + * the sequence (subscription, disposal)., +++ b/src/main/java/io/reactivex/internal/observers/DisposableLambdaObserver.java, + upstream = DisposableHelper.DISPOSED;, + upstream = DisposableHelper.DISPOSED;, + Disposable d = upstream;, + if (d != DisposableHelper.DISPOSED) {, + upstream = DisposableHelper.DISPOSED;, + d.dispose();, + }, +++ b/src/main/java/io/reactivex/Observable.java, + * the sequence (subscription, disposal)., +++ b/src/main/java/io/reactivex/internal/observers/DisposableLambdaObserver.java, + upstream = DisposableHelper.DISPOSED;, + upstream = DisposableHelper.DISPOSED;, + Disposable d = upstream;, + if (d != DisposableHelper.DISPOSED) {, + upstream = DisposableHelper.DISPOSED;, + d.dispose();, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDoOnLifecycle.java, + Subscription s = upstream;, + if (s != SubscriptionHelper.CANCELLED) {, + upstream = SubscriptionHelper.CANCELLED;,
[+++ b/.gitignore, +/.nb-gradle/profiles/private/, +.nb-gradle-properties, +/.nb-gradle/private/, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +.nb-gradle-properties, +/.nb-gradle/private/, +++ b/CHANGES.md, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +.nb-gradle-properties, +/.nb-gradle/private/, +++ b/CHANGES.md, +++ b/build.gradle, + mavenCentral() // maven { url 'http://jcenter.bintray.com' }, + mavenCentral() // maven { url: 'http://jcenter.bintray.com' }, + perfCompile.extendsFrom compile, + perfRuntime.extendsFrom runtime, + //include /src/examples folder, + //include /src/perf folder, + perf {, + java {, + srcDir 'src/perf/java', + compileClasspath += main.output, + runtimeClasspath += main.output, + }, + }, + }, +, + dependencies {, + perfCompile 'org.openjdk.jmh:jmh-core:0.2', + //include 'perf' in build task, + // dependsOn(perfClasses) //-> Not working so commented out, + // include
[+++ b/gradlew, +++ b/gradlew, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ b/gradlew, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/gradlew, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +import static rx.lang.scala.JavaConversions.toScalaObservable;, +++ b/gradlew, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +import static rx.lang.scala.JavaConversions.toScalaObservable;, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, + def mountainBikeMedals: Observable[Medal] = Observable(, + Observable(, + Observable(, + Observable(, + Observable(, + Observable(, + Observable(), +++ b/gradlew, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +import static rx.lang.scala.JavaConversions.toScalaObservable;, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, + def mountainBikeMedals: Observable[Medal] = Observable(, + Observable(, + Observable(, + Observable(,
[+++ b/src/main/java/io/reactivex/Observable.java, + Objects.requireNonNull(scheduler);, + , + public final Observable<Boolean> any(Predicate<? super T> predicate) {, + Objects.requireNonNull(predicate);, + return lift(new OperatorAny<>(predicate));, + }, + , + public final Observable<Boolean> all(Predicate<? super T> predicate) {, + Objects.requireNonNull(predicate);, + return lift(new OperatorAny<>(predicate));, + }, + , + public final Observable<Long> count() {, + return lift(OperatorCount.instance());, + }, + , + public final Observable<T> elementAt(long index) {, + if (index < 0) {, + throw new IllegalArgumentException("index >= 0 required but it was " + index);, + }, + return lift(new OperatorElementAt<>(index, null));, + }, +, + public final Observable<T> elementAt(long index,
[+++ b/src/main/java/io/reactivex/Observable.java, + public final <K> Observable<GroupedObservable<K, T>> groupBy(Function<? super T, ? extends K> keySelector) {, + public final <K> Observable<GroupedObservable<K, T>> groupBy(Function<? super T, ? extends K> keySelector, boolean delayError) {, + public final <K, V> Observable<GroupedObservable<K, V>> groupBy(Function<? super T, ? extends K> keySelector, , + public final <K, V> Observable<GroupedObservable<K, V>> groupBy(Function<? super T, ? extends K> keySelector, , + public final <K, V> Observable<GroupedObservable<K, V>> groupBy(Function<? super T, ? extends K> keySelector, , +++ b/src/main/java/io/reactivex/Observable.java, + public final <K> Observable<GroupedObservable<K, T>> groupBy(Function<? super T, ? extends K> keySelector) {, + public final <K> Observable<GroupedObservable<K, T>>
[+++ b/src/main/java/io/reactivex/internal/functions/Functions.java, + * Utility methods to convert the BiFunction, Function3..Function9 instances to Function of Object array., +++ b/src/main/java/io/reactivex/internal/functions/Functions.java, + * Utility methods to convert the BiFunction, Function3..Function9 instances to Function of Object array., +++ b/src/test/java/io/reactivex/internal/functions/FunctionsTest.java, + @SuppressWarnings({"unchecked", "rawtypes"}), + @Test(expected = NullPointerException.class), + public void biFunctionFail() throws Exception {, + BiFunction biFunction = null;, + Functions.toFunction(biFunction);, + }, +, + @SuppressWarnings({"unchecked", "rawtypes"}), + @Test(expected = NullPointerException.class), + public void function3Fail() throws Exception {, + Function3 function3 = null;, + Functions.toFunction(function3);, + }, +, + @SuppressWarnings({"unchecked", "rawtypes"}), + @Test(expected = NullPointerException.class), + public void function4Fail() throws Exception {, +
[+++ b/src/main/java/io/reactivex/Observable.java, + * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sequenceEqual.2.png" alt="">, + * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sequenceEqual.2.png" alt="">, + * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sequenceEqual.2.png" alt="">, + * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sequenceEqual.2.png" alt="">, + * <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/all.2.png" alt="">, + * <img width="640" height="330" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/collect.2.png" alt="">, + * <img width="640" height="330" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/collect.2.png" alt="">, + * <img width="640" height="320" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/contains.2.png" alt="">, + * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/count.2.png" alt="">, + * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAt.2m.png" alt="">, + * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAt.2s.png" alt="">, + * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAt.2s.png" alt="">, + * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstElement.png" alt="">, + * <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/first.2.png"
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAny.java, +import io.reactivex.plugins.RxJavaPlugins;, + if (done) {, + RxJavaPlugins.onError(t);, + return;, + }, +, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAny.java, +import io.reactivex.plugins.RxJavaPlugins;, + if (done) {, + RxJavaPlugins.onError(t);, + return;, + }, +, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAnySingle.java, + if (done) {, + RxJavaPlugins.onError(t);, + return;, + }, +, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAny.java, +import io.reactivex.plugins.RxJavaPlugins;, + if (done) {, + RxJavaPlugins.onError(t);, + return;, + }, +, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAnySingle.java, + if (done) {, + RxJavaPlugins.onError(t);, + return;, + }, +, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, +import io.reactivex.plugins.RxJavaPlugins;, + RxJavaPlugins.onError(t);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAny.java, +import io.reactivex.plugins.RxJavaPlugins;, + if (done) {, + RxJavaPlugins.onError(t);, + return;, + }, +, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAnySingle.java, + if (done) {, +
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterable.java, + return get() == SubscriptionHelper.CANCELLED;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterable.java, + return get() == SubscriptionHelper.CANCELLED;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupJoin.java, + return get() == SubscriptionHelper.CANCELLED;, + return get() == SubscriptionHelper.CANCELLED;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterable.java, + return get() == SubscriptionHelper.CANCELLED;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupJoin.java, + return get() == SubscriptionHelper.CANCELLED;, + return get() == SubscriptionHelper.CANCELLED;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublishMulticast.java, + return upstream.get() == SubscriptionHelper.CANCELLED;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterable.java, + return get() == SubscriptionHelper.CANCELLED;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupJoin.java, + return get() == SubscriptionHelper.CANCELLED;, + return get() == SubscriptionHelper.CANCELLED;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublishMulticast.java, + return upstream.get() == SubscriptionHelper.CANCELLED;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRepeatWhen.java, + if (upstream.get() == SubscriptionHelper.CANCELLED) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterable.java, + return get() == SubscriptionHelper.CANCELLED;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableGroupJoin.java, + return get() ==
[+++ b/src/main/java/io/reactivex/internal/observers/ConsumerSingleObserver.java, + lazySet(DisposableHelper.DISPOSED);, + lazySet(DisposableHelper.DISPOSED);, +++ b/src/main/java/io/reactivex/internal/observers/ConsumerSingleObserver.java, + lazySet(DisposableHelper.DISPOSED);, + lazySet(DisposableHelper.DISPOSED);, +++ b/src/test/java/io/reactivex/single/SingleSubscribeTest.java, +, + @Test, + public void successIsDisposed() {, + assertTrue(Single.just(1).subscribe().isDisposed());, + }, +, + @Test, + public void errorIsDisposed() {, + assertTrue(Single.error(new TestException()).subscribe(Functions.emptyConsumer(), Functions.emptyConsumer()).isDisposed());, + }]
[+++ b/gradle.properties, +version=0.12.1-SNAPSHOT, +++ b/gradle.properties, +version=0.12.1-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/ConnectableObservable.scala, +package rx.lang.scala, +, +, +class ConnectableObservable[+T](val asJava: rx.observables.ConnectableObservable[_ <: T]) {, + import All._, + import All.util._, + import rx.{Observable => JObservable}, + import ImplicitFunctionConversions._, + , +}, +++ b/gradle.properties, +version=0.12.1-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/ConnectableObservable.scala, +package rx.lang.scala, +, +, +class ConnectableObservable[+T](val asJava: rx.observables.ConnectableObservable[_ <: T]) {, + import All._, + import All.util._, + import rx.{Observable => JObservable}, + import ImplicitFunctionConversions._, + , +}, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/ImplicitFunctionConversions.scala, +, +/*, + * These function conversions are only used by the ScalaAdapter, users of RxScala don't need them., + */, +package rx.lang.scala, +, +, +import java.{lang =>
[+++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ /dev/null, +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java, +import rx.util.functions.FunctionLanguageAdaptor;, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/observables/Observable.java, +import org.mockito.Mockito;, +import rx.util.AtomicObservableSubscription;, +import rx.util.AtomicObserver;, +import rx.util.functions.Action0;, +import rx.util.functions.Action1;, +import rx.util.functions.Func1;, +import rx.util.functions.Func2;, +import rx.util.functions.Func3;, +import rx.util.functions.Func4;, +import rx.util.functions.FuncN;, +import rx.util.functions.Functions;, +public class Observable<T> {, + private final Func1<Observer<T>, Subscription> onSubscribe;, +, + public Observable(Func1<Observer<T>, Subscription> onSubscribe) {, + this.onSubscribe = onSubscribe;, + public
[+++ b/src/main/java/io/reactivex/Observable.java, + * Returns a Single that emits a Boolean value that indicates whether two ObservableSource sequences are the, + * @return a Single that emits a Boolean value that indicates whether the two sequences are the same, + public static <T> Single<Boolean> sequenceEqual(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2) {, + * Returns a Single that emits a Boolean value that indicates whether two ObservableSource sequences are the, + * @return a Single that emits a Boolean value that indicates whether the two ObservableSource two sequences, + public static <T> Single<Boolean> sequenceEqual(ObservableSource<? extends T> source1, ObservableSource<?
[+++ b/src/test/java/io/reactivex/schedulers/SchedulerLifecycleTest.java, +import org.junit.*;, + Set<Thread> rxThreadsBefore = new HashSet<Thread>();, + rxThreadsBefore.add(t);, + Set<Thread> rxThreadsAfter = new HashSet<Thread>();, + rxThreadsAfter.add(t);, + // cached threads may get dropped between the two checks, + rxThreadsAfter.removeAll(rxThreadsBefore);, + , + Assert.assertTrue("Some new threads appeared: " + rxThreadsAfter, rxThreadsAfter.isEmpty());]
[+++ b/gradle.properties, +version=0.14.5-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Observable.java, + * <p>, + * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png" alt="">, + * <p>, + * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png" alt="">, + * <p>, + * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png" alt="">, + * <p>, + * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png" alt="">, + * <p>, + * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatest.png" alt="">, + * <p>, + * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatestDelayError.png" alt="">, + * <p>, + * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatestDelayError.png" alt="">, + * <p>, + * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatestDelayError.png" alt="">, + * <p>, + * <img width="640" height="290" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArray.png" alt="">, + * <img width="640" height="290" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArray.png" alt="">,
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC6-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC6-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/README.md, +Observable.items(1, 2, 3, 4).reduce(_ + _), +val first = Observable.items(10, 11, 12), +val second = Observable.items(10, 11, 12), +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC6-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/README.md, +Observable.items(1, 2, 3, 4).reduce(_ + _), +val first = Observable.items(10, 11, 12), +val second = Observable.items(10, 11, 12), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, + def mountainBikeMedals: Observable[Medal] = Observable.items(, + Observable.items(, + Observable.items(, + Observable.items(, + Observable.items(, + Observable.items(, + (Observable.from(1996 to 2014) zip (Observable.items(-1) ++ Observable.interval(oneYear))).map(_._1), +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC6-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/README.md, +Observable.items(1, 2, 3, 4).reduce(_ + _), +val first =
[+++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java, + Iterator<T> actualIterator = values.iterator();, + Iterator<? extends T> expectedIterator = sequence.iterator();, + expectedNext = expectedIterator.hasNext();, + actualNext = actualIterator.hasNext();, + T u = expectedIterator.next();, + T v = actualIterator.next();, +++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java, + Iterator<T> actualIterator = values.iterator();, + Iterator<? extends T> expectedIterator = sequence.iterator();, + expectedNext = expectedIterator.hasNext();, + actualNext = actualIterator.hasNext();, + T u = expectedIterator.next();, + T v = actualIterator.next();, +++ b/src/test/java/io/reactivex/observers/TestObserverTest.java, + } catch (AssertionError expected) {, + assertTrue(expected.getMessage(), expected.getMessage().startsWith("More values received than expected (0)"));, + } catch (AssertionError expected) {, + assertTrue(expected.getMessage(), expected.getMessage().startsWith("More values received than expected (1)"));, + } catch (AssertionError expected)
[+++ b/gradle.properties, +version=0.8.3, +++ b/gradle.properties, +version=0.8.3, +++ b/language-adaptors/README.md, +++ b/gradle.properties, +version=0.8.3, +++ b/language-adaptors/README.md, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationCombineLatest;, + * Combines the given observables, emitting an event containing an aggregation of the latest values of each of the source observables, + * each time an event is received from one of the source observables, where the aggregation is defined by the given function., + * @param w0 , + * The first source observable., + * @param w1 , + * The second source observable., + * @param combineFunction , + * The aggregation function used to combine the source
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationGroupByUntil;, +import rx.operators.OperatorGroupJoin;, + return create(new OperationGroupByUntil<T, TKey, TValue, TDuration>(this, keySelector, valueSelector, durationSelector));, + return create(new OperatorGroupJoin<T, T2, D1, D2, R>(this, right, leftDuration, rightDuration, resultSelector));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationGroupByUntil;, +import rx.operators.OperatorGroupJoin;, + return create(new OperationGroupByUntil<T, TKey, TValue, TDuration>(this, keySelector, valueSelector, durationSelector));, + return create(new OperatorGroupJoin<T, T2, D1, D2, R>(this, right, leftDuration, rightDuration, resultSelector));, +++ b/rxjava-core/src/main/java/rx/operators/OperationGroupByUntil.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a
[+++ b/src/main/java/io/reactivex/Completable.java, + ObjectHelper.requireNonNull(sources, "sources is null");, + ObjectHelper.requireNonNull(sources, "sources is null");, + ObjectHelper.requireNonNull(sources, "sources is null");, + ObjectHelper.requireNonNull(sources, "sources is null");, + ObjectHelper.requireNonNull(sources, "sources is null");, + ObjectHelper.requireNonNull(source, "source is null");, + ObjectHelper.requireNonNull(source, "source is null");, + ObjectHelper.requireNonNull(completableSupplier, "completableSupplier");, + ObjectHelper.requireNonNull(errorSupplier, "errorSupplier is null");, + ObjectHelper.requireNonNull(error, "error is null");, + ObjectHelper.requireNonNull(run, "run is null");, + ObjectHelper.requireNonNull(callable, "callable is null");, + ObjectHelper.requireNonNull(future, "future is null");, + ObjectHelper.requireNonNull(observable, "observable is null");, + ObjectHelper.requireNonNull(publisher, "publisher is null");, + ObjectHelper.requireNonNull(single, "single is null");, + ObjectHelper.requireNonNull(sources, "sources is null");, + ObjectHelper.requireNonNull(sources, "sources is null");, + ObjectHelper.requireNonNull(sources, "sources is null");, + ObjectHelper.requireNonNull(sources, "sources is
[+++ b/gradle.properties, +version=0.14.6]
[+++ b/src/main/java/io/reactivex/Completable.java, + public interface CompletableTransformer extends Function<Completable, CompletableConsumable> {, + * Wraps the given CompletableConsumable into a Completable, + * if not already Completable., + * @param source the source to wrap, + * @return the source or its wrapper Completable, + * @throws NullPointerException if source is null, + */, + static Completable wrap(CompletableConsumable source) {, + Objects.requireNonNull(source, "source is null");, + if (source instanceof Completable) {, + return (Completable)source;, + }, + return new CompletableWrapper(source);, + }, + , + /**, + public static Completable amb(final CompletableConsumable... sources) {, + return wrap(sources[0]);, + for (CompletableConsumable c
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationGroupBy;, +import rx.operators.OperationTakeUntil;, +import rx.operators.OperationToIterator;, + return OperationTakeUntil.takeUntil(source, other);, + return create(OperationGroupBy.groupBy(source, keySelector, elementSelector));, + return create(OperationGroupBy.groupBy(source, keySelector));, + return OperationToIterator.toIterator(that);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationGroupBy;, +import rx.operators.OperationTakeUntil;, +import rx.operators.OperationToIterator;, + return OperationTakeUntil.takeUntil(source, other);, + return create(OperationGroupBy.groupBy(source, keySelector, elementSelector));, + return create(OperationGroupBy.groupBy(source, keySelector));, + return OperationToIterator.toIterator(that);, +++ b/rxjava-core/src/main/java/rx/Scheduler.java, +import rx.subscriptions.Subscriptions;, +import rx.util.functions.Func1;, +import rx.util.functions.Func2;, + * <p>, + * The methods left to implement are:, + * <ul>, + * <li>{@code <T> Subscription schedule(T state, Func2<Scheduler, T, Subscription> action, long delayTime, TimeUnit unit)}</li>, + * <li>{@code <T> Subscription schedule(T state, Func2<Scheduler, T, Subscription> action)}</li>, + * </ul>,
[+++ b/src/main/java/io/reactivex/Completable.java, + * Returns a Completable instance that fires its onComplete event after the given delay elapsed., + * Returns a Completable instance that fires its onComplete event after the given delay elapsed, + * false if the timeout elapsed before this Completable terminated., + * elapses, then returns null for normal termination or the emitted exception if any., + * TimeoutException if the specified timeout elapsed before it, + * Returns a Completable which calls the given onDispose callback if the child subscriber cancels, + return doOnLifecycle(, + Functions.emptyConsumer(),, + Functions.emptyConsumer(),, + Functions.EMPTY_ACTION,, + Functions.EMPTY_ACTION,, + onAfterTerminate,,
[+++ b/build.gradle, + repositories { jcenter() }, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +group = 'io.reactivex', +description = 'RxJava: Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.', +apply plugin: 'rxjava-project', + testCompile 'junit:junit-dep:4.10', + testCompile 'org.mockito:mockito-core:1.8.5', +++ b/build.gradle, + repositories { jcenter() }, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +group = 'io.reactivex', +description = 'RxJava: Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.', +apply plugin: 'rxjava-project', + testCompile 'junit:junit-dep:4.10', + testCompile 'org.mockito:mockito-core:1.8.5', +++
[+++ b/src/main/java/io/reactivex/processors/AsyncProcessor.java, +import org.reactivestreams.*;, +, +import io.reactivex.internal.functions.ObjectHelper;, + ObjectHelper.requireNonNull(t, "onNext called with null. Null values are generally not allowed in 2.x operators and sources.");, + ObjectHelper.requireNonNull(t, "onError called with null. Null values are generally not allowed in 2.x operators and sources.");, +++ b/src/main/java/io/reactivex/processors/AsyncProcessor.java, +import org.reactivestreams.*;, +, +import io.reactivex.internal.functions.ObjectHelper;, + ObjectHelper.requireNonNull(t, "onNext called with null. Null values are generally not allowed in 2.x operators and sources.");, + ObjectHelper.requireNonNull(t, "onError called with null. Null values are generally not allowed in 2.x operators and sources.");, +++ b/src/main/java/io/reactivex/processors/BehaviorProcessor.java, + ObjectHelper.requireNonNull(t, "onNext called with null. Null values are generally not allowed in 2.x operators
[+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java, +import rx.operators.OperationObserveFromAndroidComponent;, + return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, activity);, + return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (android.support.v4.app.Fragment) fragment);, + return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (Fragment) fragment);, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java, +import rx.operators.OperationObserveFromAndroidComponent;, + return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, activity);, + return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (android.support.v4.app.Fragment) fragment);, + return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (Fragment) fragment);, +++ /dev/null, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java, +import rx.operators.OperationObserveFromAndroidComponent;, + return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, activity);, + return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (android.support.v4.app.Fragment) fragment);, + return OperationObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (Fragment) fragment);, +++ /dev/null, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/operators/OperationObserveFromAndroidComponent.java, +/**, + * Copyright 2013 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain
[+++ b/src/main/java/io/reactivex/Observable.java, +import java.util.*;, + , + public final Observable<List<T>> toList() {, + return lift(OperatorToList.defaultInstance());, + }, + , + public final Observable<List<T>> toList(int capacityHint) {, + if (capacityHint <= 0) {, + throw new IllegalArgumentException("capacityHint > 0 required but it was " + capacityHint);, + }, + return lift(new OperatorToList<>(() -> new ArrayList<>(capacityHint)));, + }, + , + public final <U extends Collection<? super T>> Observable<U> toList(Supplier<U> collectionSupplier) {, + Objects.requireNonNull(collectionSupplier);, + return lift(new OperatorToList<>(collectionSupplier));, + }, + , + @SuppressWarnings({ "unchecked", "rawtypes"}), + public final Observable<List<T>> toSortedList() {, + return toSortedList((Comparator)Comparator.naturalOrder());, + }, +, + @SuppressWarnings({ "unchecked",
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSingle.java, +import java.util.NoSuchElementException;, +, + final boolean failOnEmpty;, +, + public FlowableSingle(Flowable<T> source, T defaultValue, boolean failOnEmpty) {, + this.failOnEmpty = failOnEmpty;, + source.subscribe(new SingleElementSubscriber<T>(s, defaultValue, failOnEmpty));, + final boolean failOnEmpty;, +, + SingleElementSubscriber(Subscriber<? super T> actual, T defaultValue, boolean failOnEmpty) {, + this.failOnEmpty = failOnEmpty;, + if (failOnEmpty) {, + actual.onError(new NoSuchElementException());, + } else {, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSingle.java, +import java.util.NoSuchElementException;, +, + final boolean failOnEmpty;, +, + public FlowableSingle(Flowable<T> source, T defaultValue, boolean failOnEmpty) {, + this.failOnEmpty = failOnEmpty;, + source.subscribe(new SingleElementSubscriber<T>(s, defaultValue, failOnEmpty));, + final boolean failOnEmpty;, +, + SingleElementSubscriber(Subscriber<? super T> actual, T
[+++ b/src/main/java/io/reactivex/Single.java, + * Registers an {@link Action} to be called after this Single invokes either onSuccess or onError., + * * <p>Note that the {@code doAfterSuccess} action is shared between subscriptions and as such, + * should be thread-safe.</p>, + * <p>, + * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doAfterTerminate.png" alt="">, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code doAfterTerminate} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + *, + * @param onAfterTerminate, + * an {@link Action} to be invoked when the source Single finishes, + * @return a Single that emits
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.16.1-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.16.1-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.16.1-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, + * Wraps each item emitted by a source Observable in a timestamped tuple, + * with timestamps provided by the given Scheduler., + * <p>, + * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/timestamp.s.png">, + * , + * @param scheduler [[rx.lang.scala.Scheduler]] to use as a time source., + * @return an Observable that emits timestamped items from the source, + * Observable with timestamps provided by the given Scheduler, + */, + def timestamp(scheduler: Scheduler): Observable[(Long, T)] =
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.2-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.2-SNAPSHOT, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.2-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.2-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.2-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.2-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.2-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.2-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/src/main/java/io/reactivex/observers/DisposableObserver.java, + * <p>Like all other consumers, {@code DisposableObserver} can be subscribed only once., +++ b/src/main/java/io/reactivex/observers/DisposableObserver.java, + * <p>Like all other consumers, {@code DisposableObserver} can be subscribed only once., +++ b/src/main/java/io/reactivex/subscribers/DisposableSubscriber.java, + * <p>Like all other consumers, {@code DisposableSubscriber} can be subscribed only once.]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationDistinct;, +import rx.operators.OperatorDistinctUntilChanged;, + return create(OperationDistinct.distinct(this));, + return create(OperationDistinct.distinct(this, keySelector));, + return lift(new OperatorDistinctUntilChanged<T, T>(Functions.<T>identity()));, + return lift(new OperatorDistinctUntilChanged<T, U>(keySelector));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationDistinct;, +import rx.operators.OperatorDistinctUntilChanged;, + return create(OperationDistinct.distinct(this));, + return create(OperationDistinct.distinct(this, keySelector));, + return lift(new OperatorDistinctUntilChanged<T, T>(Functions.<T>identity()));, + return lift(new OperatorDistinctUntilChanged<T, U>(keySelector));, +++ b/rxjava-core/src/main/java/rx/operators/OperationDistinct.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + *
[+++ b/rxjava-core/src/main/java/rx/Observable.java, + public final Observable<Boolean> contains(final Object element) {, + return OperationTakeUntil.takeUntil(this, other);, +++ b/rxjava-core/src/main/java/rx/Observable.java, + public final Observable<Boolean> contains(final Object element) {, + return OperationTakeUntil.takeUntil(this, other);, +++ b/rxjava-core/src/main/java/rx/operators/OperationTakeUntil.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, +
[+++ b/gradle.properties, +version=0.14.7]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorSingle;, + return lift(new OperatorSingle<T>());, + return lift(new OperatorSingle<T>(defaultValue));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorSingle;, + return lift(new OperatorSingle<T>());, + return lift(new OperatorSingle<T>(defaultValue));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorSingle;, + return lift(new OperatorSingle<T>());, + return lift(new OperatorSingle<T>(defaultValue));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorSingle.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + *
[+++ b/.gitignore, +++ b/.gitignore, +++ b/CHANGES.md, +++ b/.gitignore, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.17.4-SNAPSHOT, +++ b/.gitignore, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.17.4-SNAPSHOT, +++ /dev/null, +++ b/.gitignore, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.17.4-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.17.4-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.17.4-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.17.4-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.17.4-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore,
[+++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/gradle.properties, +version=0.17.0-SNAPSHOT, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/gradle.properties, +version=0.17.0-SNAPSHOT, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/gradle.properties, +version=0.17.0-SNAPSHOT, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/interop.clj, + ~@(if (and (= prefix "rx.util.functions.Func"), + ~@(if (and (= prefix "rx.util.functions.Action"), + "Given function f, returns an object that implements rx.util.functions.Func0-9, + http://netflix.github.io/RxJava/javadoc/rx/util/functions/Func0.html, + (reify-callable "rx.util.functions.Func" [0 1 2 3 4 5 6 7 8 9] f)), + "Given function f, returns an object that implements rx.util.functions.FuncN, + http://netflix.github.io/RxJava/javadoc/rx/util/functions/FuncN.html, + (reify rx.util.functions.FuncN, + "Like clojure.core/fn, but returns the appropriate rx.util.functions.Func*, + "Given function f, returns an object that implements
[+++ b/src/main/java/io/reactivex/Observable.java, + }, + , + public final Single<T> toSingle() {, + return Single.fromPublisher(this);, + }, + , + public final NbpObservable<T> toNbpObservable() {, + return NbpObservable.fromPublisher(this);, +++ b/src/main/java/io/reactivex/Observable.java, + }, + , + public final Single<T> toSingle() {, + return Single.fromPublisher(this);, + }, + , + public final NbpObservable<T> toNbpObservable() {, + return NbpObservable.fromPublisher(this);, +++ b/src/main/java/io/reactivex/internal/disposables/SetCompositeResource.java, + public int size() {, + synchronized (this) {, + OpenHashSet<T> a = set;, + if (a == null) {, + return 0;, + }, + int[] c = new int[1];, + a.forEach(v -> c[0]++);, + return c[0];, + }, +
[+++ b/rxjava-contrib/rxjava-android/src/test/resources/res/values/.gitignore, +# dummy so that git checks out this directory]
[+++ b/gradle.properties, +version=0.8.0-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFromCallable.java, +import io.reactivex.plugins.RxJavaPlugins;, + if (deferred.isCancelled()) {, + RxJavaPlugins.onError(ex);, + } else {, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFromCallable.java, +import io.reactivex.plugins.RxJavaPlugins;, + if (deferred.isCancelled()) {, + RxJavaPlugins.onError(ex);, + } else {, + }, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromCallableTest.java, +import static org.junit.Assert.assertEquals;, +import static org.mockito.ArgumentMatchers.any;, +import java.util.List;, +import io.reactivex.exceptions.TestException;, +import io.reactivex.plugins.RxJavaPlugins;, +, + @Test(timeout = 5000), + public void undeliverableUponCancellation() throws Exception {, + List<Throwable> errors = TestHelper.trackPluginErrors();, + try {, + final TestSubscriber<Integer> ts = new TestSubscriber<Integer>();, +, + Flowable.fromCallable(new Callable<Integer>() {, + @Override, + public Integer call() throws Exception {, + ts.cancel();, + throw new TestException();, + }, + }), + .subscribe(ts);,
[+++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +RxScala Release Notes, +=====================, +, +This release of the RxScala bindings builds on the previous 0.15 release to make the Rx bindings for Scala, +include all Rx types. In particular this release focuses on the `Subject` and `Scheduler` types., +To makes these notes self-contained, we will start with the `Observer[T]` and `Observable[T]` traits, +that lay at the heart of Rx., +, +Observer, +--------, +, +In this release we have made the `asJavaObserver` property in `Observable[T]`as well the the factory method in the, + companion object
[+++ b/gradlew, +++ b/gradlew, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.observable, +import rx.lang.scala.concurrency.Schedulers, + o.observeOn(Schedulers.newThread).subscribe(, + o.observeOn(Schedulers.newThread).subscribe(, + @Test def observableLikeFuture1() {, + implicit val scheduler = Schedulers.threadPoolForIO, + val o1 = observable {, + Thread.sleep(1000), + 5, + }, + val o2 = observable {, + Thread.sleep(500), + 4, + }, + Thread.sleep(500), + val t1 = System.currentTimeMillis, + println((o1 merge o2).first.toBlockingObservable.single), + println(System.currentTimeMillis - t1), + }, +, + @Test def observableLikeFuture2() {, + class Friend {}, + val session = new Object {, + def getFriends: List[Friend] = List(new Friend, new Friend), + }, +, + implicit val scheduler
[+++ b/src/main/java/io/reactivex/CompletableEmitter.java, +import io.reactivex.annotations.*;, + void onError(@NonNull Throwable t);, + void setDisposable(@Nullable Disposable d);, + void setCancellable(@Nullable Cancellable c);, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, +import io.reactivex.annotations.*;, + void onError(@NonNull Throwable t);, + void setDisposable(@Nullable Disposable d);, + void setCancellable(@Nullable Cancellable c);, +++ b/src/main/java/io/reactivex/CompletableObserver.java, +import io.reactivex.annotations.NonNull;, + void onSubscribe(@NonNull Disposable d);, + void onError(@NonNull Throwable e);, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, +import io.reactivex.annotations.*;, + void onError(@NonNull Throwable t);, + void setDisposable(@Nullable Disposable d);, + void setCancellable(@Nullable Cancellable c);, +++ b/src/main/java/io/reactivex/CompletableObserver.java, +import io.reactivex.annotations.NonNull;, + void onSubscribe(@NonNull Disposable d);, + void onError(@NonNull Throwable e);, +++ b/src/main/java/io/reactivex/CompletableOnSubscribe.java, +import io.reactivex.annotations.*;, +, + void subscribe(@NonNull CompletableEmitter e) throws Exception;, +++ b/src/main/java/io/reactivex/CompletableEmitter.java,
[+++ b/src/main/java/io/reactivex/Completable.java, + * Subscribes a given CompletableObserver (subclass) to this Completable and returns the given, + * CompletableObserver as is., + * <p>Usage example:, + * <pre><code>, + * Completable<Integer> source = Completable.complete().delay(1, TimeUnit.SECONDS);, + * CompositeDisposable composite = new CompositeDisposable();, + * , + * class ResourceCompletableObserver implements CompletableObserver, Disposable {, + * // ..., + * }, + * , + * composite.add(source.subscribeWith(new ResourceCompletableObserver()));, + * </code></pre>, + * @param <E> the type of the CompletableObserver to use and return, + * @param observer the CompletableObserver (subclass) to use and return, not null, + * @return
[+++ b/src/main/java/io/reactivex/Completable.java, + * Terminates the downstream if this or the other {@code Completable}, + * terminates (wins the termination race) while disposing the connection to the losing source., + * <p>, + * <img width="640" height="468" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.takeuntil.c.png" alt="">, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code takeUntil} does not operate by default on a particular {@link Scheduler}.</dd>, + * <dt><b>Error handling:</b></dt>, + * <dd>If both this and the other sources signal an error, only one of the errors, + * is signaled to the downstream and the other error is signaled to the global, + * error
[+++ b/rxjava-contrib/rxjava-string/build.gradle, +apply plugin: 'osgi', +, +sourceCompatibility = JavaVersion.VERSION_1_6, +targetCompatibility = JavaVersion.VERSION_1_6, +, +dependencies {, + compile project(':rxjava-core'), + provided 'junit:junit-dep:4.10', + provided 'org.mockito:mockito-core:1.8.5', +}, +, +javadoc {, + options {, + doclet = "org.benjchristensen.doclet.DocletExclude", + docletpath = [rootProject.file('./gradle/doclet-exclude.jar')], + stylesheetFile = rootProject.file('./gradle/javadocStyleSheet.css'), + windowTitle = "RxJava Javadoc ${project.version}", + }, + options.addStringOption('top').value = '<h2 class="title" style="padding-top:40px">RxJava</h2>', +}, +, +jar {, + manifest {, + name = 'rxjava-string', + instruction 'Bundle-Vendor', 'Netflix', + instruction 'Bundle-DocURL', 'https://github.com/Netflix/RxJava', + instruction 'Import-Package', '!org.junit,!junit.framework,!org.mockito.*,*', + }, +}, +++ b/rxjava-contrib/rxjava-string/build.gradle, +apply plugin: 'osgi', +, +sourceCompatibility = JavaVersion.VERSION_1_6, +targetCompatibility = JavaVersion.VERSION_1_6, +, +dependencies {, +
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Returns a Flowable that emits a sequence of Longs within a specified range., + * <p>, + * <img width="640" height="195" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/range.png" alt="">, + * <dl>, + * <dt><b>Backpressure:</b></dt>, + * <dd>The operator honors backpressure from downstream and signals values on-demand (i.e., when requested).</dd>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code rangeLong} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + *, + * @param start, + * the value of the first Long in the sequence, + * @param count, + * the number of sequential Longs to generate, +
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorSequenceEqual;, + return OperatorSequenceEqual.sequenceEqual(first, second, equality);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorSequenceEqual;, + return OperatorSequenceEqual.sequenceEqual(first, second, equality);, +++ b/rxjava-core/src/main/java/rx/observables/ConnectableObservable.java, +import rx.operators.OperationRefCount;, + return Observable.create(OperationRefCount.refCount(this));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorSequenceEqual;, + return OperatorSequenceEqual.sequenceEqual(first, second, equality);, +++ b/rxjava-core/src/main/java/rx/observables/ConnectableObservable.java, +import rx.operators.OperationRefCount;, + return Observable.create(OperationRefCount.refCount(this));, +++ b/rxjava-core/src/main/java/rx/operators/OperationRefCount.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , +
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Runs the source Flowable to a terminal event, ignoring any values and rethrowing any exception., + * Merges the sequence of items of this Flowable with the success value of the other SingleSource., + * <p>, + * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/merge.png" alt="">, + * <p>, + * The success value of the other {@code SingleSource} can get interleaved at any point of this, + * {@code Flowable} sequence., + * <dl>, + * <dt><b>Backpressure:</b></dt>, + * <dd>The operator honors backpressure from downstream and ensures the success item from the, + * {@code SingleSource} is
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/AbstractFlowableWithUpstream.java, +/**, + * Copyright 2016 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the
[+++ b/src/main/java/io/reactivex/processors/PublishProcessor.java, + BackpressureHelper.producedCancel(this, 1);, +++ b/src/main/java/io/reactivex/processors/PublishProcessor.java, + BackpressureHelper.producedCancel(this, 1);, +++ b/src/test/java/io/reactivex/processors/BehaviorProcessorTest.java, +, + @Test(timeout = 10000), + public void subscriberCancelOfferRace() {, + for (int i = 0; i < 1000; i++) {, + final BehaviorProcessor<Integer> pp = BehaviorProcessor.create();, +, + final TestSubscriber<Integer> ts = pp.test(1);, +, + Runnable r1 = new Runnable() {, + @Override, + public void run() {, + for (int i = 0; i < 2; i++) {, + while (!pp.offer(i)) ;, + }, + }, + };, +, + Runnable r2 = new Runnable() {, + @Override, + public void run() {, + ts.cancel();,
[+++ b/src/main/java/io/reactivex/Observable.java, + return create(new PublisherZipIterable<>(this, other, zipper));, +++ b/src/main/java/io/reactivex/Observable.java, + return create(new PublisherZipIterable<>(this, other, zipper));, +++ b/src/main/java/io/reactivex/internal/operators/OperatorObserveOn.java, +++ b/src/main/java/io/reactivex/Observable.java, + return create(new PublisherZipIterable<>(this, other, zipper));, +++ b/src/main/java/io/reactivex/internal/operators/OperatorObserveOn.java, +++ b/src/main/java/io/reactivex/internal/operators/OperatorUnsubscribeOn.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (SubscriptionHelper.validateSubscription(this.s, s)) {, + scheduler.scheduleDirect(() -> {, + s.cancel();, + });, +++ b/src/main/java/io/reactivex/Observable.java, + return create(new PublisherZipIterable<>(this, other, zipper));, +++ b/src/main/java/io/reactivex/internal/operators/OperatorObserveOn.java, +++ b/src/main/java/io/reactivex/internal/operators/OperatorUnsubscribeOn.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (SubscriptionHelper.validateSubscription(this.s, s)) {, + scheduler.scheduleDirect(() -> {, + s.cancel();, + });, +++ b/src/main/java/io/reactivex/internal/operators/OperatorWithLatestFrom.java, +++ b/src/main/java/io/reactivex/Observable.java, + return create(new PublisherZipIterable<>(this, other, zipper));, +++ b/src/main/java/io/reactivex/internal/operators/OperatorObserveOn.java, +++ b/src/main/java/io/reactivex/internal/operators/OperatorUnsubscribeOn.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + if (SubscriptionHelper.validateSubscription(this.s, s)) {, + scheduler.scheduleDirect(() -> {, + s.cancel();,
[+++ b/src/main/java/io/reactivex/annotations/NonNull.java, +/**, + * Copyright (c) 2016-present, RxJava Contributors., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language
[+++ b/src/main/java/io/reactivex/internal/fuseable/QueueDisposable.java, +/**, + * Copyright 2016 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java, + InnerQueuedSubscriber<R> inner = current;, + current = null;, +, + if (inner != null) {, + inner.cancel();, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java, + InnerQueuedSubscriber<R> inner = current;, + current = null;, +, + if (inner != null) {, + inner.cancel();, + }, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java, + if (cancelled) {, + return;, + }, + upstream.dispose();, +, + drainAndDispose();, + }, +, + void drainAndDispose() {, + do {, + } while (decrementAndGet() != 0);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java, + InnerQueuedSubscriber<R> inner = current;, + current = null;, +, + if (inner != null) {, + inner.cancel();, + }, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMapEager.java,
[+++ b/src/main/java/io/reactivex/Observable.java, + , + public final Observable<T> first() {, + return take(1).single();, + }, + , + public final Observable<T> first(T defaultValue) {, + return take(1).single(defaultValue);, + }, + , + public final Observable<T> last() {, + return takeLast(1).single();, + }, + , + public final Observable<T> last(T defaultValue) {, + return takeLast(1).single(defaultValue);, + }, +++ b/src/main/java/io/reactivex/Observable.java, + , + public final Observable<T> first() {, + return take(1).single();, + }, + , + public final Observable<T> first(T defaultValue) {, + return take(1).single(defaultValue);, + }, + , + public final Observable<T> last() {, + return takeLast(1).single();, + }, +
[+++ b/.gitignore, +/.nb-gradle/profiles/private/, +.nb-gradle-properties, +/.nb-gradle/private/, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +.nb-gradle-properties, +/.nb-gradle/private/, +++ b/rxjava-contrib/rxjava-quasar/README.md, +# rxjava-quasar, +, +Integrates RxJava with [Quasar](https://github.com/puniverse/quasar)., +Includes a fiber (lightweight-thread) based scheduler, and an Observable API for Quasar channels., +, +Main Classes:, +, +- [NewFiberScheduler](https://github.com/Netflix/RxJava/blob/master/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/NewFiberScheduler.java), +- [ChannelObservable](https://github.com/Netflix/RxJava/blob/master/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/ChannelObservable.java), +- [BlockingObservable](https://github.com/Netflix/RxJava/blob/master/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/BlockingObservable.java), +, +, +# Binaries, +, +Binaries and dependency information for Maven, Ivy, Gradle and others can be found at [http://search.maven.org](http://search.maven.org/#search%7Cga%7C1%7Ccom.netflix.rxjava)., +, +Example for [Maven](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22rxjava-apache-http%22):, +, +```xml, +<dependency>, + <groupId>com.netflix.rxjava</groupId>, + <artifactId>rxjava-quasar</artifactId>, + <version>x.y.z</version>, +</dependency>, +```, +, +and for Ivy:, +, +```xml, +<dependency org="com.netflix.rxjava" name="rxjava-quasar" rev="x.y.z" />, +```, +, +# Usage, +, +As always when using Quasar, the
[+++ b/gradle.properties, +version=0.16.0-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Completable.java, + * <strong>This method requires advanced knowledge about building operators, please consider, + * other standard composition methods first;</strong>, + * Returns a {@code Completable} which, when subscribed to, invokes the {@link CompletableOperator#apply(CompletableObserver) apply(CompletableObserver)} method, + * of the provided {@link CompletableOperator} for each individual downstream {@link Completable} and allows the, + * insertion of a custom operator by accessing the downstream's {@link CompletableObserver} during this subscription phase, + * and providing a new {@code CompletableObserver}, containing the custom operator's intended business logic, that will be, + * used in the subscription process going further upstream., +
[+++ b/gradle.properties, +version=0.14.1-SNAPSHOT]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/rxjava-contrib/rxjava-debug/build.gradle, +apply plugin: 'osgi', +, +sourceCompatibility = JavaVersion.VERSION_1_6, +targetCompatibility = JavaVersion.VERSION_1_6, +, +dependencies {, + compile project(':rxjava-core'), + testCompile project(":rxjava-core").sourceSets.test.output , + provided 'junit:junit-dep:4.10', + provided 'org.mockito:mockito-core:1.8.5', +}, +, +javadoc {, + options {, + doclet = "org.benjchristensen.doclet.DocletExclude", + docletpath = [rootProject.file('./gradle/doclet-exclude.jar')], + stylesheetFile = rootProject.file('./gradle/javadocStyleSheet.css'), + windowTitle = "RxJava Javadoc ${project.version}", + }, + options.addStringOption('top').value = '<h2 class="title" style="padding-top:40px">RxJava</h2>', +}, +, +jar {, + manifest {, + name = 'rxjava-debug', + instruction 'Bundle-Vendor', 'Netflix', + instruction 'Bundle-DocURL', 'https://github.com/Netflix/RxJava', + instruction 'Import-Package', '!org.junit,!junit.framework,!org.mockito.*,*', + }, +}, +++ b/.gitignore, +++ b/rxjava-contrib/rxjava-debug/build.gradle, +apply plugin: 'osgi', +,
[+++ b/src/main/java/io/reactivex/Observable.java, + /**, + * Interface to compose observables., + *, + * @param <T> the upstream value type, + * @param <R> the downstream value type, + */, + @FunctionalInterface, + public interface Transformer<T, R> extends Function<Observable<T>, Publisher<? extends R>> {, + , + }, +, +, + public final <R> Observable<R> compose(Transformer<T, R> composer) {, + public static final <T> Observable<T> just(T v1, T v2) {, + public static final <T> Observable<T> just(T v1, T v2, T v3) {, + public static final <T> Observable<T> just(T v1, T v2, T v3, T v4) {, + public
[+++ b/gradle.properties, +version=0.12.2-SNAPSHOT, +++ b/gradle.properties, +version=0.12.2-SNAPSHOT, +++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/observables/SwingObservable.java, +import java.awt.Point;, + * Creates an observable corresponding to relative mouse motion., + * @param component, + * The component to register the observable for., + * @return A point whose x and y coordinate represent the relative horizontal and vertical mouse motion., + */, + public static Observable<Point> fromRelativeMouseMotion(Component component) {, + return MouseEventSource.fromRelativeMouseMotion(component);, + }, + , + /**, +++ b/gradle.properties, +version=0.12.2-SNAPSHOT, +++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/observables/SwingObservable.java, +import java.awt.Point;, + * Creates an observable corresponding to relative mouse motion., + * @param component, + * The component to register the observable for.,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationConcat;, +import rx.operators.OperatorCombineLatest;, + public static final <T1, T2, R> Observable<R> combineLatest(Observable<? extends T1> o1, Observable<? extends T2> o2, Func2<? super T1, ? super T2, ? extends R> combineFunction) {, + return combineLatest(Arrays.asList(o1, o2), Functions.fromFunc(combineFunction));, + public static final <T1, T2, T3, R> Observable<R> combineLatest(Observable<? extends T1> o1, Observable<? extends T2> o2, Observable<? extends T3> o3, Func3<? super T1, ? super T2, ? super T3, ? extends R> combineFunction) {, + return combineLatest(Arrays.asList(o1, o2, o3), Functions.fromFunc(combineFunction));, + public static final <T1, T2, T3, T4, R> Observable<R> combineLatest(Observable<? extends T1> o1, Observable<? extends T2> o2, Observable<? extends
[+++ b/.gitignore, +.m2, +target/, +build/, +bin/, +, +# Scala build, +*.cache, +++ b/.gitignore, +.m2, +target/, +build/, +bin/, +, +# Scala build, +*.cache, +++ b/CHANGES.md, +# RxJava Releases #, +, +### Version 0.9.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.9.0%22)) ###, +, +This release includes breaking changes that move all blocking operators (such as `single`, `last`, `forEach`) to `BlockingObservable`., +, +This means `Observable` has only non-blocking operators on it. The blocking operators can now be accessed via `.toBlockingObservable()` or `BlockingObservable.from(observable)`., +, +Notes and link to the discussion of this change can be found at https://github.com/Netflix/RxJava/pull/272., +, +* [Pull 272](https://github.com/Netflix/RxJava/pull/272) Move blocking operators into BlockingObservable, +*
[+++ b/src/main/java/io/reactivex/Flowable.java, + * @return the value, + protected static int verifyPositive(int value, String paramName) {, + return value;, + * @return the value, + protected static long verifyPositive(long value, String paramName) {, + return value;, +++ b/src/main/java/io/reactivex/Flowable.java, + * @return the value, + protected static int verifyPositive(int value, String paramName) {, + return value;, + * @return the value, + protected static long verifyPositive(long value, String paramName) {, + return value;, +++ b/src/main/java/io/reactivex/Observable.java, + * @return value, + protected static int verifyPositive(int value, String paramName) {, + return value;, + * @return value, + protected static long verifyPositive(long
[+++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/flowables/ConnectableFlowable.java, +import io.reactivex.internal.util.ConnectConsumer;, + ConnectConsumer cc = new ConnectConsumer();, + connect(cc);, + return cc.disposable;, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/flowables/ConnectableFlowable.java, +import io.reactivex.internal.util.ConnectConsumer;, + ConnectConsumer cc = new ConnectConsumer();, + connect(cc);, + return cc.disposable;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDebounceTimed.java, + if (timer.compareAndSet(d, de)) {, + }, +, + if (de != null) {, + de.run();, + }, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/flowables/ConnectableFlowable.java, +import io.reactivex.internal.util.ConnectConsumer;, + ConnectConsumer cc = new ConnectConsumer();, + connect(cc);, + return cc.disposable;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDebounceTimed.java, + if (timer.compareAndSet(d, de)) {, + }, +, + if (de != null) {, + de.run();, + }, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableJoin.java, + if (!cancelled) {,
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java, +++ b/src/main/java/io/reactivex/processors/ReplayProcessor.java, +import io.reactivex.annotations.CheckReturnValue;, + b.next(t);, + b.error(t);, + b.complete();, + ReplayBuffer<T> b = buffer;, + if (b.isDone()) {, + return b.getError();, + ReplayBuffer<T> b = buffer;, + return b.isDone() && b.getError() == null;, + ReplayBuffer<T> b = buffer;, + return b.isDone() && b.getError() != null;, + void next(T value);, + void error(Throwable ex);, +, + void complete();, + boolean isDone();, +, + Throwable getError();, + long emitted;, +, + final List<T> buffer;, + Throwable error;, + this.buffer = new ArrayList<T>(ObjectHelper.verifyPositive(capacityHint, "capacityHint"));, + public void next(T value) {, + public void error(Throwable ex) {, +
[+++ b/src/main/java/io/reactivex/internal/operators/single/SingleMap.java, +import io.reactivex.internal.functions.ObjectHelper;, + v = ObjectHelper.requireNonNull(mapper.apply(value), "The mapper function returned a null value.");, +++ b/src/main/java/io/reactivex/internal/operators/single/SingleMap.java, +import io.reactivex.internal.functions.ObjectHelper;, + v = ObjectHelper.requireNonNull(mapper.apply(value), "The mapper function returned a null value.");, +++ b/src/test/java/io/reactivex/internal/operators/single/SingleMapTest.java, +/**, + * Copyright (c) 2016-present, RxJava Contributors., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationSkip;, +import rx.operators.OperatorSkipUntil;, + return create(new OperationSkip.SkipTimed<T>(this, time, unit, scheduler));, + return lift(new OperatorSkipUntil<T, U>(other));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationSkip;, +import rx.operators.OperatorSkipUntil;, + return create(new OperationSkip.SkipTimed<T>(this, time, unit, scheduler));, + return lift(new OperatorSkipUntil<T, U>(other));, +++ b/rxjava-core/src/main/java/rx/operators/OperationSkip.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable
[+++ b/gradle.properties, +version=0.18.2]
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC5-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC5-SNAPSHOT, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, + filter first future, + rx.Observable/flatMap, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC5-SNAPSHOT, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, + filter first future, + rx.Observable/flatMap, +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/core_test.clj, + [:a {:k :a :v 3}], +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC5-SNAPSHOT, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, + filter first future, + rx.Observable/flatMap, +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/core_test.clj, + [:a {:k :a :v 3}], +++ b/language-adaptors/rxjava-kotlin/src/main/kotlin/rx/lang/kotlin/namespace.kt, +public fun<T> Function0<Observable<out T>>.defer(): Observable<T> {, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC5-SNAPSHOT, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/core.clj, + filter first future, + rx.Observable/flatMap, +++ b/language-adaptors/rxjava-clojure/src/test/clojure/rx/lang/clojure/core_test.clj, + [:a {:k :a :v 3}], +++ b/language-adaptors/rxjava-kotlin/src/main/kotlin/rx/lang/kotlin/namespace.kt, +public fun<T> Function0<Observable<out T>>.defer(): Observable<T> {,
[+++ b/src/main/java/io/reactivex/Maybe.java, + * @param <R> the result value type, +++ b/src/main/java/io/reactivex/Maybe.java, + * @param <R> the result value type, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeFlatMapSingle.java, + * @param <T> the input value type, + * @param <R> the result value type]
[+++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/src/main/java/rx/internal/operators/OperatorMerge.java, + if (!isUnsubscribed()) {, + }, + int emitted = s.drainQueue();, + long emitted = 0;, + // request upstream what we just emitted, + if(emitted > 0) {, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties,
[+++ b/src/main/java/io/reactivex/Maybe.java, + * <img width="640" height="354" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMap.mmm.png" alt="">]
[+++ b/DESIGN.md, +Terminology, principles, contracts, and other aspects of the design of RxJava v2., +##### Reactive, +##### Interactive, +##### Push, +Producer emits when it wishes to. Related to "reactive". Callbacks are an instance of push., +##### Pull, +Consumer requests data when it wishes to. Related to "interactive". An `Iterable` is an instance of pull., +##### Async Pull, +Consumer requests data when it wishes, and the data is then pushed when the producer wishes to. The Reactive Streams `Publisher` is an instance of "async pull", as is the 'AsyncEnumerable' in .Net., +Stream that supports async and synchronous push. It does
[+++ b/src/main/java/io/reactivex/internal/disposables/ObserverFullArbiter.java, + if (!cancelled) {, + } else {, + next.dispose();, + }, +++ b/src/main/java/io/reactivex/internal/disposables/ObserverFullArbiter.java, + if (!cancelled) {, + } else {, + next.dispose();, + }, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableMap.java, +import io.reactivex.internal.functions.ObjectHelper;, +import io.reactivex.internal.subscribers.observable.BasicFuseableObserver;, + source.subscribe(new MapObserver<T, U>(t, function));, + static final class MapObserver<T, U> extends BasicFuseableObserver<T, U> {, + final Function<? super T, ? extends U> mapper;, + public MapObserver(Observer<? super U> actual, Function<? super T, ? extends U> mapper) {, + super(actual);, + this.mapper = mapper;, + }, + , + if (sourceMode != NONE) {, + actual.onNext(null);, + return;, + }, + , + U v;,
[+++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +, +++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.6-bin.zip, +++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.6-bin.zip, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, + @Test def groupByUntilExample() {, + val numbers = Observable.interval(250 millis) take 14, + val grouped = numbers.groupByUntil[Long, Long](, + {case x => x % 2},, + {case (key, obs) => obs filter {case x => x == 7}}, + ), + val sequenced = (grouped map {case (key, obs) => obs.toSeq}).flatten, + sequenced subscribe {x => println(s"Emitted
[+++ b/src/main/java/io/reactivex/Flowable.java, + * <p>, + * Unlike 1.x, this operator doesn't emit the seed value unless the upstream signals an event., +++ b/src/main/java/io/reactivex/Flowable.java, + * <p>, + * Unlike 1.x, this operator doesn't emit the seed value unless the upstream signals an event., +++ b/src/main/java/io/reactivex/internal/observers/ForEachWhileObserver.java, +import io.reactivex.exceptions.*;, + RxJavaPlugins.onError(new CompositeException(t, ex));, +++ b/src/main/java/io/reactivex/Flowable.java, + * <p>, + * Unlike 1.x, this operator doesn't emit the seed value unless the upstream signals an event., +++ b/src/main/java/io/reactivex/internal/observers/ForEachWhileObserver.java, +import io.reactivex.exceptions.*;, + RxJavaPlugins.onError(new CompositeException(t, ex));, +++ b/src/main/java/io/reactivex/internal/observers/LambdaObserver.java, +import io.reactivex.exceptions.*;, +import io.reactivex.internal.disposables.DisposableHelper;, + onError(ex);, + if (!isDisposed()) {, + }, + if (!isDisposed())
[+++ b/src/main/java/io/reactivex/functions/BiConsumer.java, + void accept(T1 t1, T2 t2) throws Exception;]
[+++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.operators.mixed.*;, + * Maps the upstream intems into {@link CompletableSource}s and subscribes to them one after the, + * other completes., + * <p>, + * <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMap.png" alt="">, + * <dl>, + * <dt><b>Backpressure:</b></dt>, + * <dd>The operator expects the upstream to support backpressure. If this {@code Flowable} violates the rule, the operator will, + * signal a {@code MissingBackpressureException}.</dd>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code concatMapCompletable} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + * @param mapper the function called with the upstream item and should
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAt.java, +import java.util.NoSuchElementException;, +, + final boolean errorOnFewer;, +, + public FlowableElementAt(Publisher<T> source, long index, T defaultValue, boolean errorOnFewer) {, + this.errorOnFewer = errorOnFewer;, + source.subscribe(new ElementAtSubscriber<T>(s, index, defaultValue, errorOnFewer));, + final boolean errorOnFewer;, + ElementAtSubscriber(Subscriber<? super T> actual, long index, T defaultValue, boolean errorOnFewer) {, + this.errorOnFewer = errorOnFewer;, + if (errorOnFewer) {, + actual.onError(new NoSuchElementException());, + } else {, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAt.java, +import java.util.NoSuchElementException;, +, + final boolean errorOnFewer;, +, + public FlowableElementAt(Publisher<T> source, long index, T defaultValue, boolean errorOnFewer) {, + this.errorOnFewer = errorOnFewer;, + source.subscribe(new ElementAtSubscriber<T>(s, index, defaultValue, errorOnFewer));, + final boolean errorOnFewer;,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorZip;, + return from(Arrays.asList(value));, + List<Observable<?>> os = new ArrayList<Observable<?>>();, + for (Observable<?> o : ws) {, + os.add(o);, + }, + return Observable.just(os.toArray(new Observable<?>[os.size()])).lift(new OperatorZip<R>(zipFunction));, + return ws.toList().map(new Func1<List<? extends Observable<?>>, Observable<?>[]>() {, +, + public Observable<?>[] call(List<? extends Observable<?>> o) {, + return o.toArray(new Observable<?>[o.size()]);, +, + }).lift(new OperatorZip<R>(zipFunction));, + public final static <T1, T2, R> Observable<R> zip(Observable<? extends T1> o1, Observable<? extends T2> o2, final Func2<? super T1, ? super T2, ? extends R> zipFunction) {, + return just(new Observable<?>[] { o1, o2 }).lift(new OperatorZip<R>(zipFunction));, + return just(new Observable<?>[] { o1, o2, o3
[+++ b/src/main/java/io/reactivex/Single.java, + * @param scheduler the target scheduler to use for the non-blocking wait and emission]
[+++ b/src/test/java/io/reactivex/schedulers/TimedTest.java, + , + @Test(expected = NullPointerException.class), + public void timeUnitNullFail() throws Exception {, + new Timed<Integer>(1, 5, null);, + }]
[+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowBoundary.java, +import io.reactivex.internal.util.AtomicThrowable;, +import io.reactivex.observers.DisposableObserver;, + final int capacityHint;, + public ObservableWindowBoundary(ObservableSource<T> source, ObservableSource<B> other, int capacityHint) {, + this.capacityHint = capacityHint;, + public void subscribeActual(Observer<? super Observable<T>> observer) {, + WindowBoundaryMainObserver<T, B> parent = new WindowBoundaryMainObserver<T, B>(observer, capacityHint);, +, + observer.onSubscribe(parent);, + other.subscribe(parent.boundaryObserver);, +, + source.subscribe(parent);, + extends AtomicInteger, + implements Observer<T>, Disposable, Runnable {, + private static final long serialVersionUID = 2233020065421370272L;, + final Observer<? super Observable<T>> downstream;, + final int capacityHint;, +, + final WindowBoundaryInnerObserver<T, B> boundaryObserver;, +, + final AtomicReference<Disposable> upstream;, +, + final AtomicInteger windows;, +, + final MpscLinkedQueue<Object> queue;, +, + final
[+++ b/language-adaptors/rxjava-scala/README.md, +# Scala Adaptor for RxJava, +This adaptor allows to use RxJava in Scala with anonymous functions, e.g., +, +val o = Observable.interval(200 millis).take(5), +o.subscribe(n => println("n = " + n)), +Observable(1, 2, 3, 4).reduce(_ + _), +For-comprehensions are also supported:, +, +val first = Observable(10, 11, 12), +val second = Observable(10, 11, 12), +val booleans = for ((n1, n2) <- (first zip second)) yield (n1 == n2), +Further, this adaptor attempts to expose an API which is as Scala-idiomatic as possible. This means that certain methods have been renamed, their signature was changed, or static methods were
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorRepeat;, + * Convert the current Observable<T> into an Observable<Observable<T>>., + * , + * @return, + */, + private final Observable<Observable<T>> nest() {, + return from(this);, + }, + , + /**, + return nest().lift(new OperatorRepeat<T>());, + return nest().lift(new OperatorRepeat<T>(scheduler));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorRepeat;, + * Convert the current Observable<T> into an Observable<Observable<T>>., + * , + * @return, + */, + private final Observable<Observable<T>> nest() {, + return from(this);, + }, + , + /**, + return nest().lift(new OperatorRepeat<T>());, + return nest().lift(new OperatorRepeat<T>(scheduler));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorRepeat;, + * Convert the current
[+++ b/src/main/java/io/reactivex/processors/BehaviorProcessor.java, + final AtomicReference<Throwable> terminalEvent;, + this.terminalEvent = new AtomicReference<Throwable>();, + Throwable ex = terminalEvent.get();, + if (ex == ExceptionHelper.TERMINATED) {, + s.onError(ex);, + if (terminalEvent.get() != null) {, + if (terminalEvent.get() != null) {, + if (!terminalEvent.compareAndSet(null, t)) {, + if (!terminalEvent.compareAndSet(null, ExceptionHelper.TERMINATED)) {, +++ b/src/main/java/io/reactivex/processors/BehaviorProcessor.java, + final AtomicReference<Throwable> terminalEvent;, + this.terminalEvent = new AtomicReference<Throwable>();, + Throwable ex = terminalEvent.get();, + if (ex == ExceptionHelper.TERMINATED) {, + s.onError(ex);, + if (terminalEvent.get() != null) {, + if (terminalEvent.get() != null) {, + if (!terminalEvent.compareAndSet(null, t)) {, + if (!terminalEvent.compareAndSet(null, ExceptionHelper.TERMINATED)) {, +++ b/src/main/java/io/reactivex/subjects/BehaviorSubject.java, + final AtomicReference<Throwable> terminalEvent;, +
[+++ b/src/main/java/io/reactivex/flowables/package-info.java, + * Classes supporting the Flowable base reactive class:, + * {@link io.reactivex.flowables.ConnectableFlowable} and, + * {@link io.reactivex.flowables.GroupedFlowable}., +++ b/src/main/java/io/reactivex/flowables/package-info.java, + * Classes supporting the Flowable base reactive class:, + * {@link io.reactivex.flowables.ConnectableFlowable} and, + * {@link io.reactivex.flowables.GroupedFlowable}., +++ b/src/main/java/io/reactivex/internal/operators/single/SingleFromCallable.java, +++ b/src/main/java/io/reactivex/flowables/package-info.java, + * Classes supporting the Flowable base reactive class:, + * {@link io.reactivex.flowables.ConnectableFlowable} and, + * {@link io.reactivex.flowables.GroupedFlowable}., +++ b/src/main/java/io/reactivex/internal/operators/single/SingleFromCallable.java, +++ b/src/main/java/io/reactivex/observables/package-info.java, + * Classes supporting the Observable base reactive class:, + * {@link io.reactivex.observable.ConnectableObservable} and, + * {@link io.reactivex.observable.GroupedObservable}., +++ b/src/main/java/io/reactivex/flowables/package-info.java, + * Classes supporting the Flowable base reactive class:, + * {@link io.reactivex.flowables.ConnectableFlowable}
[+++ b/src/main/java/rx/Observable.java, + if (this instanceof ScalarSynchronousObservable) {, + return ((ScalarSynchronousObservable<T>)this).scalarScheduleOn(scheduler);, + }, + if (this instanceof ScalarSynchronousObservable) {, + return ((ScalarSynchronousObservable<T>)this).scalarScheduleOn(scheduler);, + }, +++ b/src/main/java/rx/Observable.java, + if (this instanceof ScalarSynchronousObservable) {, + return ((ScalarSynchronousObservable<T>)this).scalarScheduleOn(scheduler);, + }, + if (this instanceof ScalarSynchronousObservable) {, + return ((ScalarSynchronousObservable<T>)this).scalarScheduleOn(scheduler);, + }, +++ b/src/main/java/rx/internal/schedulers/EventLoopsScheduler.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * ,
[+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSampleTest.java, +import static org.junit.Assert.assertFalse;, + PublishProcessor<Integer> pp1 = PublishProcessor.create();, + PublishProcessor<Integer> pp2 = PublishProcessor.create();, +, + TestSubscriber<Integer> ts = pp1, + .sample(pp2), + .test(0L);, +, + pp1.onNext(1);, + pp2.onNext(2);, +, + ts.assertFailure(MissingBackpressureException.class);, +, + assertFalse(pp1.hasSubscribers());, + assertFalse(pp2.hasSubscribers());, +, + TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Flowable<Object>>() {, + @Override, + public Flowable<Object> apply(Flowable<Object> f), + throws Exception {, + return f.sample(PublishProcessor.create());, + }, + });, + }, +, + @Test, + public void badRequest() {, + TestHelper.assertBadRequestReported(PublishProcessor.create(), + .sample(PublishProcessor.create()));]
[+++ b/gradle.properties, +version=0.8.1-SNAPSHOT]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OnSubscribeFromIterable;, + return create(new OnSubscribeFromIterable<T>(iterable));, + return create(new OnSubscribeFromIterable<T>(iterable)).subscribeOn(scheduler);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OnSubscribeFromIterable;, + return create(new OnSubscribeFromIterable<T>(iterable));, + return create(new OnSubscribeFromIterable<T>(iterable)).subscribeOn(scheduler);, +++ b/rxjava-core/src/main/java/rx/operators/OnSubscribeFromIterable.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the
[+++ b/src/perf/java/io/reactivex/BlockingPerf.java, +/**, + * Copyright 2016 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the
[+++ b/src/main/java/io/reactivex/Maybe.java, + * <img width="640" height="389" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.ignoreElement.png" alt="">, +++ b/src/main/java/io/reactivex/Maybe.java, + * <img width="640" height="389" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.ignoreElement.png" alt="">, +++ b/src/main/java/io/reactivex/Single.java, + * <img width="640" height="436" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.toCompletable.png" alt="">, + * @deprecated see {@link #ignoreElement()} instead, will be removed in 3.0, + @Deprecated, + * Returns a {@link Completable} that ignores the success value of this {@link Single}, + * and calls {@code onComplete} instead on the returned {@code Completable}., + * <p>, + * <img width="640" height="436" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.ignoreElement.png" alt="">, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code ignoreElement} does not operate by default on a particular {@link Scheduler}.</dd>, +
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDoOnLifecycle.java, +import org.reactivestreams.*;, +import io.reactivex.Flowable;, +import io.reactivex.exceptions.Exceptions;, +import io.reactivex.functions.*;, +import io.reactivex.internal.subscriptions.*;, +import io.reactivex.plugins.RxJavaPlugins;, +, + static final class SubscriptionLambdaSubscriber<T> implements Subscriber<T>, Subscription {, + final Subscriber<? super T> actual;, + final Consumer<? super Subscription> onSubscribe;, + final LongConsumer onRequest;, + final Action onCancel;, +, + Subscription s;, +, + public SubscriptionLambdaSubscriber(Subscriber<? super T> actual,, + Consumer<? super Subscription> onSubscribe,, + LongConsumer onRequest,, + Action onCancel) {, + this.actual = actual;, + this.onSubscribe = onSubscribe;, + this.onCancel = onCancel;, + this.onRequest = onRequest;, + }, +, + @Override, + public void onSubscribe(Subscription s) {, + // this way, multiple
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java, + w.onComplete();, +, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java, + w.onComplete();, +, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowTimed.java, + w.onComplete();, +, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java, + w.onComplete();, +, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowTimed.java, + w.onComplete();, +, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java, +, + @Test, + public void sizeTimeTimeout() {, + TestScheduler scheduler = new TestScheduler();, + PublishProcessor<Integer> ps = PublishProcessor.<Integer>create();, +, + TestSubscriber<Flowable<Integer>> ts = ps.window(5, TimeUnit.MILLISECONDS, scheduler, 100), + .test(), + .assertValueCount(1);, +, + scheduler.advanceTimeBy(5, TimeUnit.MILLISECONDS);, +, + ts.assertValueCount(2), + .assertNoErrors(), + .assertNotComplete();, +, + ts.values().get(0).test().assertResult();, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowTimed.java, + w.onComplete();, +, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableWindowTimed.java, + w.onComplete();, +, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java, +, + @Test, + public void sizeTimeTimeout() {, + TestScheduler scheduler =
[+++ b/gradle.properties, +version=0.6.0-SNAPSHOT, +++ b/gradle.properties, +version=0.6.0-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return new NoOpObservableSubscription();, + /**, + * A {@link Subscription} that does nothing when its unsubscribe method is called., + */, + private static class NoOpObservableSubscription implements Subscription {, + public void unsubscribe() {, + }, + }, + return new NoOpObservableSubscription();, + * A {@link Subscription} that does nothing., + * , + * //TODO should this be moved to a Subscriptions utility class?, + * , + * @return, + */, + public static Subscription noOpSubscription() {, + return new NoOpObservableSubscription();, + }, +, + /**, + *
[+++ b/src/main/java/io/reactivex/Scheduler.java, +import io.reactivex.annotations.NonNull;, + @NonNull, + public long now(@NonNull TimeUnit unit) {, + @NonNull, + public Disposable scheduleDirect(@NonNull Runnable run) {, + @NonNull, + public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) {, + @NonNull, + public Disposable schedulePeriodicallyDirect(@NonNull Runnable run, long initialDelay, long period, @NonNull TimeUnit unit) {, + @NonNull, + public <S extends Scheduler & Disposable> S when(@NonNull Function<Flowable<Flowable<Completable>>, Completable> combine) {, + @NonNull, + public Disposable schedule(@NonNull Runnable run) {, + @NonNull, + public abstract Disposable schedule(@NonNull Runnable run, long delay, @NonNull TimeUnit unit);, + @NonNull, + public Disposable schedulePeriodically(@NonNull Runnable run, final
[+++ b/CHANGES.md, +### Version 0.10.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.10.0%22)) ###, +, +This release includes a breaking change as it changes `onError(Exception)` to `onError(Throwable)`. This decision was made via discussion at https://github.com/Netflix/RxJava/issues/296., +, +Any statically-typed `Observer` implementations with `onError(Exception)` will need to be updated to `onError(Throwable)` when moving to this version., +, +* [Pull 312](https://github.com/Netflix/RxJava/pull/312) Fix for OperatorOnErrorResumeNextViaObservable and async Resume, +* [Pull 314](https://github.com/Netflix/RxJava/pull/314) Map Error Handling, +* [Pull 315](https://github.com/Netflix/RxJava/pull/315) Change onError(Exception) to onError(Throwable) - Issue #296, +, +### Version 0.9.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.9.2%22)) ###, +, +* [Pull 308](https://github.com/Netflix/RxJava/pull/308) Ensure now() is always updated in TestScheduler.advanceTo/By, +* [Pull 281](https://github.com/Netflix/RxJava/pull/281) Operator: Buffer, +, +###
[+++ b/src/main/java/io/reactivex/exceptions/ProtocolViolationException.java, +/**, + * Copyright (c) 2016-present, RxJava Contributors., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language
[+++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/build.gradle, +// Establish version and status, +ext.githubProjectName = rootProject.name // Change if github project name is not the same as the root project's name, + repositories {, + mavenLocal(), + maven { url 'http://jcenter.bintray.com' }, + }, + repositories { mavenRepo url: 'http://jcenter.bintray.com' }, +apply from: file('gradle/check.gradle'), + group =
[+++ b/src/main/java/io/reactivex/Observable.java, + , + public static <T> Observable<Boolean> sequenceEqual(Publisher<? extends T> p1, Publisher<? extends T> p2) {, + return sequenceEqual(p1, p2, Objects::equals, bufferSize());, + }, +, + public static <T> Observable<Boolean> sequenceEqual(Publisher<? extends T> p1, Publisher<? extends T> p2, int bufferSize) {, + return sequenceEqual(p1, p2, Objects::equals, bufferSize);, + }, +, + public static <T> Observable<Boolean> sequenceEqual(Publisher<? extends T> p1, Publisher<? extends T> p2, BiPredicate<? super T, ? super T> isEqual) {, + return sequenceEqual(p1, p2, isEqual, bufferSize());, + }, +, + public static <T> Observable<Boolean> sequenceEqual(Publisher<? extends T> p1, Publisher<? extends T> p2, BiPredicate<? super T, ?
[+++ b/.gitignore, +++ b/.gitignore, +++ b/gradle.properties, +version=0.17.0-RC6-SNAPSHOT, +++ b/.gitignore, +++ b/gradle.properties, +version=0.17.0-RC6-SNAPSHOT, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-all.zip, +++ b/.gitignore, +++ b/gradle.properties, +version=0.17.0-RC6-SNAPSHOT, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-all.zip, +++ b/language-adaptors/rxjava-clojure/README.md, +Clojure bindings for RxJava., +Example for Leiningen:, +, +```clojure, +[com.netflix.rxjava/rxjava-clojure "x.y.z"], +```, +, +and for Gradle:, +, +```groovy, +compile 'com.netflix.rxjava:rxjava-clojure:x.y.z', +```, +, +and for Maven:, +# Clojure Bindings, +This library provides convenient, idiomatic Clojure bindings for RxJava., +, +The bindings try to present an API that will be comfortable and familiar to a Clojure programmer that's familiar with the sequence operations in `clojure.core`. It "fixes" several issues with using RxJava with raw Java interop,
[+++ b/src/main/java/io/reactivex/Single.java, + * <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMapPublisher.png" alt="">]
[+++ b/src/main/java/io/reactivex/Completable.java, + * @param onDispose the callback to call when the child subscriber disposes the subscription, + * @param onDispose the runnable called when the child disposes the subscription, + final Action onDispose) {, + ObjectHelper.requireNonNull(onDispose, "onDispose is null");, + return RxJavaPlugins.onAssembly(new CompletablePeek(this, onSubscribe, onError, onComplete, onTerminate, onAfterTerminate, onDispose));, +++ b/src/main/java/io/reactivex/Completable.java, + * @param onDispose the callback to call when the child subscriber disposes the subscription, + * @param onDispose the runnable called when the child disposes the subscription, + final Action onDispose) {, + ObjectHelper.requireNonNull(onDispose, "onDispose is null");, + return RxJavaPlugins.onAssembly(new CompletablePeek(this, onSubscribe, onError, onComplete, onTerminate, onAfterTerminate,
[+++ b/build.gradle, + , + afterEvaluate {, + classDirectories = files(classDirectories.files.collect {, + fileTree(dir: it,, + exclude: ['io/reactivex/tck/**']), + }), + }, +++ b/build.gradle, + , + afterEvaluate {, + classDirectories = files(classDirectories.files.collect {, + fileTree(dir: it,, + exclude: ['io/reactivex/tck/**']), + }), + }, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.operators.observable.*;, + * Maps each element of the upstream Flowable into CompletableSources, subscribes to them and, + * waits until the upstream and all CompletableSources complete., + * <dl>, + * <dt><b>Backpressure:</b></dt>, + * <dd>The operator consumes the upstream in an unbounded manner.</dd>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code flatMapCompletable} does not
[+++ b/gradle.properties, +version=0.11.3-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Completable.java, + * <p>, + * The {@link Publisher} must follow the, + * <a href="https://github.com/reactive-streams/reactive-streams-jvm#reactive-streams">Reactive-Streams specification</a>., + * Violating the specification may result in undefined behavior., + * <p>, + * If possible, use {@link #create(CompletableOnSubscribe)} to create a, + * source-like {@code Completable} instead., + * <p>, + * Note that even though {@link Publisher} appears to be a functional interface, it, + * is not recommended to implement it through a lambda as the specification requires, + * state management that is not achievable with a stateless lambda., + * @see #create(CompletableOnSubscribe), +++ b/src/main/java/io/reactivex/Completable.java, +
[+++ b/gradle.properties, +version=0.15.0]
[+++ b/.gitignore, +.m2, +target/, +build/, +bin/, +, +# Scala build, +*.cache, +++ b/.gitignore, +.m2, +target/, +build/, +bin/, +, +# Scala build, +*.cache, +++ b/CHANGES.md, +# RxJava Releases #, +, +### Version 0.6.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.6.1%22)) ###, +, +* [Pull 190](https://github.com/Netflix/RxJava/pull/190) Fix generics issue with materialize() that prevented chaining, +, +### Version 0.6.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.6.0%22)) ###, +, +* [Issue 154](https://github.com/Netflix/RxJava/issues/154) Add OSGi manifest headers, +* [Issue 173](https://github.com/Netflix/RxJava/issues/173) Subscription Utilities and Default Implementations, +* [Pull 184](https://github.com/Netflix/RxJava/pull/184) Convert 'last' from non-blocking to blocking to match Rx.Net (see [Issue 57](https://github.com/Netflix/RxJava/issues/57)), +, +*NOTE:* This is a version bump from 0.5 to 0.6 because [Issue 173](https://github.com/Netflix/RxJava/issues/173)
[+++ b/src/main/java/io/reactivex/Observable.java, +import io.reactivex.schedulers.*;, + public static Observable<Long> timer(long delay, TimeUnit unit) {, + return timer(delay, unit, Schedulers.computation());, + public static Observable<Long> timer(long delay, TimeUnit unit, Scheduler scheduler) {, + public static Observable<Long> interval(long period, TimeUnit unit) {, + return interval(period, period, unit, Schedulers.computation());, + }, +, + public static Observable<Long> interval(long period, TimeUnit unit, Scheduler scheduler) {, + return interval(period, period, unit, scheduler);, + }, + private static <T1, T2, R> Function<Object[], R> toFunction(BiFunction<? super T1, ? super T2, ? extends R> biFunction) {, + return a -> {, + return ((BiFunction<Object, Object, R>)biFunction).apply(a[0], a[1]);, + public static
[+++ b/src/main/java/io/reactivex/Flowable.java, + * If there is a {@link #create(FlowableOnSubscribe, BackpressureStrategy)} type source up in the, + * chain, it is recommended to use {@code subscribeOn(scheduler, false)} instead, + * to avoid same-pool deadlock because requests may pile up behind a eager/blocking emitter., + * <p>, + * @see #subscribeOn(Scheduler, boolean), + public final Flowable<T> subscribeOn(@NonNull Scheduler scheduler) {, + return subscribeOn(scheduler, !(this instanceof FlowableCreate));, + }, +, + /**, + * Asynchronously subscribes Subscribers to this Publisher on the specified {@link Scheduler}, + * optionally reroutes requests from other threads to the same {@link Scheduler} thread., + *
[+++ b/gradle.properties, +version=0.15.1-SNAPSHOT, +++ b/gradle.properties, +version=0.15.1-SNAPSHOT, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/gradle.properties, +version=0.15.1-SNAPSHOT, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/language-adaptors/rxjava-scala/README.md, +Alternative Rx bindings for Scala, +=================================, +The current RxScala binding attempt to optimize for seamless interop between Scala and Java., +The intended interop is illustrated by the following example where in Scala a class is defined that takes, +an `Observable[Movie]` that is transformed using RxScala operators:, +class MovieLib(val moviesStream: Observable[Movie]) {, + val threshold = 1200, + def shortMovies: Observable[Movie] = ???, + def longMovies: Observable[Movie] = ???, +}, +which is then called in Java, passing a Java `Observable<Movie>` to the constructor, +```java, +public
[+++ b/src/jmh/java/io/reactivex/xmapz/ObservableSwitchMapCompletablePerf.java, + Observable<Integer> observableConvert;, + Completable observableDedicated;, + observableConvert = source.switchMap(new Function<Integer, Observable<? extends Integer>>() {, + observableDedicated = source.switchMapCompletable(new Function<Integer, Completable>() {, + public Object observableConvert(Blackhole bh) {, + return observableConvert.subscribeWith(new PerfConsumer(bh));, + public Object observableDedicated(Blackhole bh) {, + return observableDedicated.subscribeWith(new PerfConsumer(bh));, +++ b/src/jmh/java/io/reactivex/xmapz/ObservableSwitchMapCompletablePerf.java, + Observable<Integer> observableConvert;, + Completable observableDedicated;, + observableConvert = source.switchMap(new Function<Integer, Observable<? extends Integer>>() {, + observableDedicated = source.switchMapCompletable(new Function<Integer, Completable>() {, + public Object observableConvert(Blackhole bh) {, + return observableConvert.subscribeWith(new PerfConsumer(bh));, + public Object observableDedicated(Blackhole bh) {, + return observableDedicated.subscribeWith(new PerfConsumer(bh));, +++ b/src/main/java/io/reactivex/internal/observers/DeferredScalarDisposable.java, + Observer<? super T> a = actual;, + a.onNext(null);,
[+++ b/src/main/java/io/reactivex/internal/observers/BiConsumerSingleObserver.java, + lazySet(DisposableHelper.DISPOSED);, + lazySet(DisposableHelper.DISPOSED);, +++ b/src/main/java/io/reactivex/internal/observers/BiConsumerSingleObserver.java, + lazySet(DisposableHelper.DISPOSED);, + lazySet(DisposableHelper.DISPOSED);, +++ b/src/test/java/io/reactivex/single/SingleSubscribeTest.java, +import java.io.IOException;, +, + @Test, + public void biConsumerIsDisposedOnSuccess() {, + final Object[] result = { null, null };, + , + Disposable d = Single.just(1), + .subscribe(new BiConsumer<Integer, Throwable>() {, + @Override, + public void accept(Integer t1, Throwable t2) throws Exception {, + result[0] = t1;, + result[1] = t2;, + }, + });, + , + assertTrue("Not disposed?!", d.isDisposed());, + assertEquals(1, result[0]);, + assertNull(result[1]);, + }, +, + @Test, + public void biConsumerIsDisposedOnError() {, + final Object[] result = { null, null };,
[+++ b/gradle.properties, +version=0.15.2-SNAPSHOT, +++ b/gradle.properties, +version=0.15.2-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return merge(from(t1, t2));, + return merge(from(t1, t2, t3));, + return merge(from(t1, t2, t3, t4));, + return merge(from(t1, t2, t3, t4, t5));, + return merge(from(t1, t2, t3, t4, t5, t6));, + return merge(from(t1, t2, t3, t4, t5, t6, t7));, + return merge(from(t1, t2, t3, t4, t5, t6, t7, t8));, + return merge(from(t1, t2, t3, t4, t5, t6, t7, t8, t9));, + }, +, + /**, + * Flattens a sequence of Observables emitted by an Observable into one Observable, without any transformation., + * The number of concurrent subscriptions to the
[+++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java, + * <p>, + * Undeliverable errors are those {@code Observer.onError()} invocations that are not allowed to happen on, + * the given consumer type ({@code Observer}, {@code Subscriber}, etc.) due to protocol restrictions, + * because the consumer has either disposed/cancelled its {@code Disposable}/{@code Subscription} or, + * has already terminated with an {@code onError()} or {@code onComplete()} signal., + * <p>, + * By default, this global error handler prints the stacktrace via {@link Throwable#printStackTrace()}, + * and calls {@link java.lang.Thread.UncaughtExceptionHandler#uncaughtException(Thread, Throwable)}, + * on the current thread., + * <p>, + * Note that
[+++ b/src/main/java/io/reactivex/Completable.java, + * <img width="640" height="422" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromPublisher.png" alt="">, + * <p>, + * <img width="640" height="293" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toObservable.png" alt="">]
[+++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java, + break;, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java, + break;, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java, + break;, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java, + break;, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java, + break;, +++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybe.java, + break;, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java, + break;, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java, + break;, +++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybe.java, + break;, +++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java, + break;, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybe.java, + break;, +++ b/src/main/java/io/reactivex/internal/operators/mixed/FlowableConcatMapSingle.java, + break;, +++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapMaybe.java, + break;, +++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapSingle.java, + break;, +++ b/src/test/java/io/reactivex/internal/operators/mixed/FlowableConcatMapMaybeTest.java, +, + @Test, + public void innerSuccessDisposeRace() {, + for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {, +, + final MaybeSubject<Integer> ms = MaybeSubject.create();, +, + final TestSubscriber<Integer> ts = Flowable.just(1), + .hide(), + .concatMapMaybe(Functions.justFunction(ms)), + .test();, +, +
[+++ b/CHANGES.md, +### Version 0.17.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.17.0%22)) ###, +, +, +Version 0.17.0 contains some significant signature changes that allow us to significantly improve handling of synchronous Observables and simplify Schedulers. Many of the changes have backwards compatible deprecated methods to ease the migration while some are breaking. , +, +The new signatures related to `Observable` in this release are:, +, +```java, +// A new create method takes `OnSubscribe` instead of `OnSubscribeFunc`, +public final static <T> Observable<T> create(OnSubscribe<T> f), +, +// The new OnSubscribe type accepts a Subscriber instead of Observer and does not return a Subscription, +public static interface
[+++ b/src/main/java/io/reactivex/CompletableEmitter.java, +, + /**, + * Attempts to emit the specified {@code Throwable} error if the downstream, + * hasn't cancelled the sequence or is otherwise terminated, returning false, + * if the emission is not allowed to happen due to lifecycle restrictions., + * <p>, + * Unlike {@link #onError(Throwable)}, the {@code RxJavaPlugins.onError} is not called, + * if the error could not be delivered., + * @param t the throwable error to signal if possible, + * @return true if successful, false if the downstream is not able to accept further, + * events, + *
[+++ b/src/main/java/io/reactivex/Observable.java, + * Returns a Single that emits a Boolean that indicates whether all of the items emitted by the source, + * Returns a Single that emits {@code true} if any item emitted by the source ObservableSource satisfies a, + * Returns a Single that emits a Boolean that indicates whether the source ObservableSource emitted a, + * Returns a Single that emits {@code true} if the source ObservableSource is empty, otherwise {@code false}.]
[+++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/build.gradle, +// Establish version and status, +ext.githubProjectName = rootProject.name // Change if github project name is not the same as the root project's name, + repositories {, + mavenLocal(), + mavenCentral() // maven { url 'http://jcenter.bintray.com' }, + }, + repositories { , + mavenCentral() // maven { url: 'http://jcenter.bintray.com'
[+++ b/CHANGES.md, +### Version 0.14.3 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.3%22)) ###, +, +* [Pull 407](https://github.com/Netflix/RxJava/pull/407) Implemented RefCount Operator, +* [Pull 410](https://github.com/Netflix/RxJava/pull/410) Implemented the 'Contains' operator, +* [Pull 411](https://github.com/Netflix/RxJava/pull/411) Unit Test fix: update counter before triggering latch , +* [Pull 413](https://github.com/Netflix/RxJava/pull/413) Fixed the issues of takeLast(items, 0) and null values, +* [Pull 414](https://github.com/Netflix/RxJava/pull/414) Implemented the 'SkipLast' operator, +* [Pull 415](https://github.com/Netflix/RxJava/pull/415) Implemented the 'Empty' operator with scheduler, +* [Pull 416](https://github.com/Netflix/RxJava/pull/416) Implemented the 'Throw' operator with scheduler , +* [Pull 420](https://github.com/Netflix/RxJava/pull/420) Scala Adaptor Improvements, +* [Pull 422](https://github.com/Netflix/RxJava/pull/422) JRuby function wrapping support, +* [Pull 424](https://github.com/Netflix/RxJava/pull/424) Implemented the 'IgnoreElements' operator, +* [Pull 426](https://github.com/Netflix/RxJava/pull/426) PublishSubject ReSubscribe for publish().refCount()
[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, + * item. If the source Observable emits more than one item or no items, notify of an `IllegalArgumentException`, + * or `NoSuchElementException` respectively., + * @throws IllegalArgumentException if the source emits more than one item, + * @throws NoSuchElementException if the source emits no items, + new BlockingObservable[T](this), + new BlockingObservable[T](this), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, + * item. If the source Observable emits more than one item or no items, notify of an `IllegalArgumentException`, + * or `NoSuchElementException` respectively., + * @throws IllegalArgumentException if the source emits more than one item, + * @throws NoSuchElementException if the source
[+++ b/CHANGES.md, +### Version 0.15.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.15.0%22)) ###, +, +This release contains a refactor of the Scala Bindings by @headinthebox that results in some breaking changes. , +The previous solution ended up not working well in all cases for idiomatic Scala usage. Java/Scala interop has been changed and is no longer transparent so as to optimize for native Scala usage., +Read the [rxjava-scala README](https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-scala) for more information., +, +* [Pull 503](https://github.com/Netflix/RxJava/pull/503) New Scala Bindings, +* [Pull 502](https://github.com/Netflix/RxJava/pull/502) Fix ObserveOn and add ParallelMerge Scheduler overload, +* [Pull 499](https://github.com/Netflix/RxJava/pull/499) ObserveOn Refactor, +* [Pull 492](https://github.com/Netflix/RxJava/pull/492) Implement the scheduler overloads for Range, From,
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.9.1-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.9.1-SNAPSHOT, +++ b/gradle/convention.gradle, + configurations.add('sources'), + configurations.add('javadoc'), +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.9.1-SNAPSHOT, +++ b/gradle/convention.gradle, + configurations.add('sources'), + configurations.add('javadoc'), +++ b/language-adaptors/rxjava-clojure/src/examples/clojure/rx/lang/clojure/examples/video_example.clj, +; just use a simple lock to keep multi-threaded output fr beiom ng a interlea llved, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.9.1-SNAPSHOT, +++ b/gradle/convention.gradle, + configurations.add('sources'), + configurations.add('javadoc'), +++ b/language-adaptors/rxjava-clojure/src/examples/clojure/rx/lang/clojure/examples/video_example.clj, +; just use a simple lock to keep multi-threaded output fr beiom ng a interlea llved, +++ b/rxjava-contrib/rxjava-android/build.gradle, +apply plugin: 'java', +apply plugin: 'eclipse', +apply plugin: 'idea', +apply plugin: 'osgi', +, +sourceCompatibility = JavaVersion.VERSION_1_6, +targetCompatibility = JavaVersion.VERSION_1_6, +, +dependencies
[+++ b/src/main/java/io/reactivex/Observable.java, + return window(timespan, unit, scheduler, count, restart, bufferSize());, + public final Observable<Observable<T>> window(, + long timespan, TimeUnit unit, Scheduler scheduler, , + long count, boolean restart, int bufferSize) {, +++ b/src/main/java/io/reactivex/Observable.java, + return window(timespan, unit, scheduler, count, restart, bufferSize());, + public final Observable<Observable<T>> window(, + long timespan, TimeUnit unit, Scheduler scheduler, , + long count, boolean restart, int bufferSize) {, +++ b/src/main/java/io/reactivex/internal/operators/OperatorConcatMap.java, + }, +++ b/src/main/java/io/reactivex/Observable.java, + return window(timespan, unit, scheduler, count, restart, bufferSize());, + public final Observable<Observable<T>> window(, + long timespan, TimeUnit unit, Scheduler scheduler, , + long count, boolean restart, int bufferSize) {, +++ b/src/main/java/io/reactivex/internal/operators/OperatorConcatMap.java,
[+++ b/src/main/java/io/reactivex/Completable.java, + * This overload disposes eagerly before the terminal event is emitted., + * If this overload performs a lazy cancellation after the terminal event is emitted., + return RxJavaPlugins.onAssembly(new CompletableDisposeOn(this, scheduler));, +++ b/src/main/java/io/reactivex/Completable.java, + * This overload disposes eagerly before the terminal event is emitted., + * If this overload performs a lazy cancellation after the terminal event is emitted., + return RxJavaPlugins.onAssembly(new CompletableDisposeOn(this, scheduler));, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, + * or Cancellation will be disposed/cancelled., + * or Cancellation will be disposed/cancelled., +++ b/src/main/java/io/reactivex/Completable.java, + * This overload disposes eagerly before the terminal event is emitted., +
[+++ b/gradle.properties, +version=0.14.4-SNAPSHOT]
[+++ b/CHANGES.md, +### Version 0.7.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.7.0%22)) ###, +, +This release adds the foundations of Rx Schedulers., +, +There are still open questions, portions not implemented and assuredly bugs and behavior we didn't understand and thus implemented wrong., +, +Please provide bug reports, pull requests or feedback to help us on the road to version 1.0 and get schedulers implemented correctly., +, +See https://github.com/Netflix/RxJava/issues/19#issuecomment-15979582 for some known open questions that we could use help answering., +, +* [Issue 19](https://github.com/Netflix/RxJava/issues/19) Schedulers, +, +++ b/CHANGES.md, +### Version 0.7.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.7.0%22)) ###, +, +This release adds the foundations of Rx Schedulers., +,
[+++ b/build.gradle, +ext.githubProjectName = rootProject.name // Change if github project name is not the same as the root project's name, +apply from: file('gradle/release.gradle'), +++ b/build.gradle, +ext.githubProjectName = rootProject.name // Change if github project name is not the same as the root project's name, +apply from: file('gradle/release.gradle'), +++ b/gradle.properties, +version=1.4-SNAPSHOT, +++ b/build.gradle, +ext.githubProjectName = rootProject.name // Change if github project name is not the same as the root project's name, +apply from: file('gradle/release.gradle'), +++ b/gradle.properties, +version=1.4-SNAPSHOT, +++ b/gradle/buildscript.gradle, +repositories {, + ivy {, + name = 'gradle_release', + artifactPattern 'http://launchpad.net/[organization]/trunk/[revision]/+download/[artifact]-[revision].jar', + }, +}, + classpath 'gradle-release:gradle-release:1.0pre', +++ b/build.gradle, +ext.githubProjectName =
[+++ b/build.gradle, + // perf //-> Not working so commented out, +++ b/build.gradle, + // perf //-> Not working so commented out, +++ b/gradle.properties, +version=0.17.0-SNAPSHOT, +++ b/build.gradle, + // perf //-> Not working so commented out, +++ b/gradle.properties, +version=0.17.0-SNAPSHOT, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/build.gradle, + // perf //-> Not working so commented out, +++ b/gradle.properties, +version=0.17.0-SNAPSHOT, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/language-adaptors/rxjava-groovy/src/examples/groovy/rx/lang/groovy/examples/RxExamples.groovy, +import rx.util.functions.Action0, + return Subscriptions.create(new Action0() {, + public void call() {, + });, +++ b/build.gradle, + // perf //-> Not working so commented out, +++
[+++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Sep 03 10:20:57 PDT 2013, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Sep 03 10:20:57 PDT 2013, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, + , +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Sep 03 10:20:57 PDT 2013, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, + , +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Notification.scala, + Notification(new rx.Notification[T](value)), + Notification(new rx.Notification[T](error)), + Notification(new rx.Notification()), +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Sep 03 10:20:57 PDT 2013, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, + , +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Notification.scala, + Notification(new rx.Notification[T](value)), + Notification(new rx.Notification[T](error)), + Notification(new rx.Notification()), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, + * @param duration, + def interval(duration: Duration, scheduler: Scheduler): Observable[Long] = {, + toScalaObservable[java.lang.Long](rx.Observable.interval(duration.length, duration.unit, scheduler)).map(_.longValue()), +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Sep 03 10:20:57 PDT 2013, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java, + int m = qs.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java, + int m = qs.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java, + int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSwitchMap.java, + int m = qs.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java, + int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);, +++ b/src/test/java/io/reactivex/TestHelper.java, +, + static final class FlowableStripBoundary<T> extends Flowable<T> implements FlowableTransformer<T, T> {, +, + final Flowable<T> source;, +, + FlowableStripBoundary(Flowable<T> source) {, + this.source = source;, + }, +, + @Override, + public Flowable<T> apply(Flowable<T> upstream) {, + return new FlowableStripBoundary<T>(upstream);, + }, +, + @Override, + protected void subscribeActual(Subscriber<? super T>
[+++ b/src/main/java/io/reactivex/Completable.java, + return RxJavaPlugins.onAssembly(new CompletableAmb(sources, null));, + return RxJavaPlugins.onAssembly(new CompletableAmb(null, sources));, +++ b/src/main/java/io/reactivex/Completable.java, + return RxJavaPlugins.onAssembly(new CompletableAmb(sources, null));, + return RxJavaPlugins.onAssembly(new CompletableAmb(null, sources));, +++ b/src/main/java/io/reactivex/Maybe.java, + return RxJavaPlugins.onAssembly(new MaybeAmb<T>(null, sources));, + return RxJavaPlugins.onAssembly(new MaybeAmb<T>(sources, null));, +++ b/src/main/java/io/reactivex/Completable.java, + return RxJavaPlugins.onAssembly(new CompletableAmb(sources, null));, + return RxJavaPlugins.onAssembly(new CompletableAmb(null, sources));, +++ b/src/main/java/io/reactivex/Maybe.java, + return RxJavaPlugins.onAssembly(new MaybeAmb<T>(null, sources));, + return RxJavaPlugins.onAssembly(new MaybeAmb<T>(sources, null));, +++ b/src/main/java/io/reactivex/Single.java, + return RxJavaPlugins.onAssembly(new SingleAmb<T>(null, sources));, + return RxJavaPlugins.onAssembly(new SingleAmb<T>(sources, null));, +++ b/src/main/java/io/reactivex/Completable.java, + return RxJavaPlugins.onAssembly(new CompletableAmb(sources, null));, + return RxJavaPlugins.onAssembly(new CompletableAmb(null, sources));, +++ b/src/main/java/io/reactivex/Maybe.java, + return RxJavaPlugins.onAssembly(new MaybeAmb<T>(null, sources));, + return RxJavaPlugins.onAssembly(new MaybeAmb<T>(sources, null));, +++ b/src/main/java/io/reactivex/Single.java, +
[+++ b/src/main/java/io/reactivex/Flowable.java, + validateBufferSize(bufferSize, "bufferSize");, + validateBufferSize(bufferSize, "bufferSize");, + validateBufferSize(bufferSize, "bufferSize");, + validateBufferSize(bufferSize, "bufferSize");, + throw new IllegalArgumentException("count >= 0 required but it was " + count);, + validateBufferSize(bufferSize, "bufferSize");, + private static void validateBufferSize(int bufferSize, String paramName) {, + throw new IllegalArgumentException(paramName + " > 0 required but it was " + bufferSize);, + validateBufferSize(bufferSize, "bufferSize");, + validateBufferSize(bufferSize, "bufferSize");, + if (maxConcurrency <= 0) {, + throw new IllegalArgumentException("maxConcurrency > 0 required but it was " + maxConcurrency);, + }, + validateBufferSize(prefetch, "prefetch");, + public final Flowable<T> doAfterTerminate(Runnable onFinally) {, + validateBufferSize(bufferSize, "bufferSize");, + validateBufferSize(bufferSize, "bufferSize");, + validateBufferSize(bufferSize,
[+++ b/src/main/java/io/reactivex/exceptions/CompositeException.java, + /*private */Throwable getRootCause(Throwable e) {, +++ b/src/main/java/io/reactivex/exceptions/CompositeException.java, + /*private */Throwable getRootCause(Throwable e) {, +++ b/src/main/java/io/reactivex/internal/functions/ObjectHelper.java, + * Compares two long values similar to Long.compare., +++ b/src/main/java/io/reactivex/exceptions/CompositeException.java, + /*private */Throwable getRootCause(Throwable e) {, +++ b/src/main/java/io/reactivex/internal/functions/ObjectHelper.java, + * Compares two long values similar to Long.compare., +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundarySupplier.java, + if (DisposableHelper.replace(other, bs)) {, + }, +++ b/src/main/java/io/reactivex/exceptions/CompositeException.java, + /*private */Throwable getRootCause(Throwable e) {, +++ b/src/main/java/io/reactivex/internal/functions/ObjectHelper.java, + * Compares two long values similar to Long.compare., +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundarySupplier.java, + if (DisposableHelper.replace(other, bs)) {, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java, + cancelled = true;, + buffer = next;, + }, + cancelled = true;,
[+++ b/src/main/java/io/reactivex/Observable.java, + return distinct(v -> v, HashSet::new);, + public final <K> Observable<T> distinct(Function<? super T, K> keySelector) {, + return distinct(keySelector, HashSet::new);, + }, +, + public final <K> Observable<T> distinct(Function<? super T, K> keySelector, Supplier<? extends Collection<? super K>> collectionSupplier) {, + return lift(OperatorDistinct.withCollection(keySelector, collectionSupplier));, + public final <K> Observable<T> distinctUntilChanged(Function<? super T, K> keySelector) {, + return lift(OperatorDistinct.untilChanged(keySelector));, + }, +, + public final Observable<T> doOnEach(Subscriber<? super T> observer) {, +++ b/src/main/java/io/reactivex/Observable.java, + return distinct(v -> v, HashSet::new);, + public final <K> Observable<T> distinct(Function<? super T, K> keySelector) {, + return distinct(keySelector, HashSet::new);, + }, +,
[+++ b/.gitignore, +.gradletasknamecache, +++ b/.gitignore, +.gradletasknamecache, +++ b/rxjava-contrib/rxjava-android-samples-build-wrapper/build.gradle, +tasks.build.doLast {, + def androidHome = System.getenv("ANDROID_HOME"), + if (project.hasProperty('buildAndroidSamples') && !androidHome.isEmpty()) {, + println("Android SDK detected at $androidHome, running samples build"), + project.exec {, + workingDir '../rxjava-android-samples', +, + commandLine "./gradlew", "clean", "packageDebug", + }, + }, +}, +++ b/.gitignore, +.gradletasknamecache, +++ b/rxjava-contrib/rxjava-android-samples-build-wrapper/build.gradle, +tasks.build.doLast {, + def androidHome = System.getenv("ANDROID_HOME"), + if (project.hasProperty('buildAndroidSamples') && !androidHome.isEmpty()) {, + println("Android SDK detected at $androidHome, running samples build"), + project.exec {, + workingDir '../rxjava-android-samples', +, + commandLine "./gradlew", "clean", "packageDebug", + }, + }, +}, +++ b/rxjava-contrib/rxjava-android-samples/.gitignore, +.gradle, +/local.properties, +/.idea/workspace.xml, +.DS_Store, +++ b/.gitignore,
[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, + i => println(s"${i}a (on thread #${Thread.currentThread().getId})"), + i => println(s"${i}b (on thread #${Thread.currentThread().getId})"), + o.observeOn(NewThreadScheduler()).subscribe(, + i => println(s"${i}a (on thread #${Thread.currentThread().getId})"), + o.observeOn(NewThreadScheduler()).subscribe(, + i => println(s"${i}b (on thread #${Thread.currentThread().getId})"), + println(s"$x*$x is being calculated on thread ${Thread.currentThread().getId}"), + println(s"map() is being called on thread ${Thread.currentThread().getId}"), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, + i => println(s"${i}a (on thread #${Thread.currentThread().getId})"), + i => println(s"${i}b (on thread #${Thread.currentThread().getId})"), + o.observeOn(NewThreadScheduler()).subscribe(, + i => println(s"${i}a (on thread #${Thread.currentThread().getId})"), + o.observeOn(NewThreadScheduler()).subscribe(, + i => println(s"${i}b (on thread #${Thread.currentThread().getId})"), + println(s"$x*$x is being calculated on thread ${Thread.currentThread().getId}"), + println(s"map() is
[+++ b/src/test/java/io/reactivex/plugins/RxJavaPluginsTest.java, + * Ensure set*() accepts a consumers/functions with wider bounds., +++ b/src/test/java/io/reactivex/plugins/RxJavaPluginsTest.java, + * Ensure set*() accepts a consumers/functions with wider bounds., +++ b/src/test/java/io/reactivex/schedulers/NewThreadSchedulerTest.java, + * Regression test to ensure there is no NPE when the worker has been disposed.]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Returns a Single that emits the item found at a specified index in a sequence of emissions from, + * @return a Single that emits the item at the specified position in the sequence emitted by the source, + * Returns a Single that emits the item found at a specified index in a sequence of emissions from, + * @return a Single that emits the item at the specified position in the sequence emitted by the source, +++ b/src/main/java/io/reactivex/Flowable.java, + * Returns a Single that emits the item found at a specified index in
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationMergeDelayError;, +import rx.operators.OperatorMergeMaxConcurrent;, + return source.lift(new OperatorMergeMaxConcurrent<T>(maxConcurrent));, + return create(OperationMergeDelayError.mergeDelayError(source));, + @SuppressWarnings("unchecked"), + // suppress because the types are checked by the method signature before using a vararg, + return create(OperationMergeDelayError.mergeDelayError(t1, t2));, + @SuppressWarnings("unchecked"), + // suppress because the types are checked by the method signature before using a vararg, + return create(OperationMergeDelayError.mergeDelayError(t1, t2, t3));, + @SuppressWarnings("unchecked"), + // suppress because the types are checked by the method signature before using a vararg, + return create(OperationMergeDelayError.mergeDelayError(t1, t2, t3, t4));, + @SuppressWarnings("unchecked"), + // suppress because the types are checked by the method signature before using a
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorConcat;, + return observables.lift(new OperatorConcat<T>());, + return concat(from(t1, t2));, + return concat(from(t1, t2, t3));, + return concat(from(t1, t2, t3, t4));, + return concat(from(t1, t2, t3, t4, t5));, + return concat(from(t1, t2, t3, t4, t5, t6));, + return concat(from(t1, t2, t3, t4, t5, t6, t7));, + return concat(from(t1, t2, t3, t4, t5, t6, t7, t8));, + return concat(from(t1, t2, t3, t4, t5, t6, t7, t8, t9));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorConcat;, + return observables.lift(new OperatorConcat<T>());, + return concat(from(t1, t2));, + return concat(from(t1, t2, t3));, + return concat(from(t1, t2, t3, t4));, + return concat(from(t1, t2, t3, t4, t5));, +
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java, + final AtomicReference<InnerSubscriber<T>[]> subscribers;, + @SuppressWarnings("unchecked"), + this.subscribers = new AtomicReference<InnerSubscriber<T>[]>(EMPTY);, + @SuppressWarnings("unchecked"), + InnerSubscriber<T>[] c = subscribers.get();, + @SuppressWarnings("unchecked"), + InnerSubscriber<T>[] u = new InnerSubscriber[len + 1];, + @SuppressWarnings("unchecked"), + InnerSubscriber<T>[] c = subscribers.get();, + InnerSubscriber<T>[] u;, + @SuppressWarnings("unchecked"), +, + // saving a local copy because this will be accessed after every item, + // delivered to detect changes in the subscribers due to an onNext, + // and thus not dropping items, + AtomicReference<InnerSubscriber<T>[]> subscribers = this.subscribers;, +, + // We take a snapshot of the current child subscribers., + // Concurrent subscribers may
[+++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.functions.*;, +import io.reactivex.internal.fuseable.ScalarCallable;, +import io.reactivex.internal.operators.single.*;, + * If the source is empty, a {@code NoSuchElementException} is signalled., + * <p>, + * @return a Single that emits a single item that is the result of accumulating the items emitted by, + * the source Flowable, + public final Single<T> reduce(BiFunction<T, T, T> reducer) {, + ObjectHelper.requireNonNull(reducer, "reducer is null");, +// return RxJavaPlugins.onAssembly(new FlowableReduce<T>(this, reducer));, + return RxJavaPlugins.onAssembly(new SingleReduceFlowable<T>(this, reducer));, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.functions.*;, +import io.reactivex.internal.fuseable.ScalarCallable;, +import io.reactivex.internal.operators.single.*;, + * If the source is empty, a {@code NoSuchElementException} is signalled., + * <p>, + * @return a
[+++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java, + , + static volatile Consumer<Throwable> errorHandler;, + , + static volatile Function<Subscriber<Object>, Subscriber<Object>> onSubscribeHandler;, + , + static volatile Function<Publisher<Object>, Publisher<Object>> onCreateHandler;, +, + static volatile Function<Runnable, Runnable> onScheduleHandler;, +, + static volatile Function<Scheduler, Scheduler> onInitComputationHandler;, + , + static volatile Function<Scheduler, Scheduler> onInitSingleHandler;, + , + static volatile Function<Scheduler, Scheduler> onInitIOHandler;, + , + static volatile Function<Scheduler, Scheduler> onComputationHandler;, + , + static volatile Function<Scheduler, Scheduler> onSingleHandler;, + , + static volatile Function<Scheduler, Scheduler> onIOHandler;, + , + /** Prevents changing the plugins. */, + private static volatile boolean lockdown;, + , + /**, +
[+++ b/src/main/java/io/reactivex/Observable.java, + Objects.requireNonNull(other);, + Objects.requireNonNull(value);, + , + /*, + * It doesn't add cancellation support by default like 1.x, + * if necessary, one can use composition to achieve it:, + * futureObservable.doOnCancel(() -> future.cancel(true));, + */, + public static <T> Observable<T> fromFuture(Future<? extends T> future) {, + if (future instanceof CompletableFuture) {, + return fromFuture((CompletableFuture<? extends T>)future);, + }, + Objects.requireNonNull(future);, + Observable<T> o = create(new PublisherFutureSource<>(future, 0L, null));, + , + return o;, + }, +, + public static <T> Observable<T> fromFuture(Future<? extends T> future, long timeout, TimeUnit unit) {, + Objects.requireNonNull(future);, + Objects.requireNonNull(unit);, +
[+++ b/gradle.properties, +version=0.20.0-RC3]
[+++ b/gradle.properties, +version=0.10.1-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Observable.java, +import java.util.concurrent.atomic.AtomicReference;, +import io.reactivex.disposables.Disposable;, +import io.reactivex.internal.subscribers.*;, + , + public final Disposable subscribe() {, + return subscribe(v -> { }, RxJavaPlugins::onError, () -> { }, s -> s.request(Long.MAX_VALUE));, + }, + , + public final Disposable subscribe(Consumer<? super T> onNext) {, + return subscribe(onNext, RxJavaPlugins::onError, () -> { }, s -> s.request(Long.MAX_VALUE));, + }, +, + public final Disposable forEach(Consumer<? super T> onNext) {, + return subscribe(onNext);, + }, + , + public final Disposable forEachWhile(Predicate<? super T> onNext) {, + return forEachWhile(onNext, RxJavaPlugins::onError, () -> { });, + }, +, + public final Disposable forEachWhile(Predicate<? super
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableJoin.java, +/**, + * Copyright 2016 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language governing
[+++ b/build.gradle, +apply plugin: 'checkstyle', +checkstyle {, + configFile file('checkstyle.xml'), +}, +, +++ b/build.gradle, +apply plugin: 'checkstyle', +checkstyle {, + configFile file('checkstyle.xml'), +}, +, +++ b/checkstyle.xml, +<?xml version="1.0"?>, +<!DOCTYPE module PUBLIC, + "-//Puppy Crawl//DTD Check Configuration 1.2//EN", + "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">, +<module name="Checker">, + <module name="TreeWalker">, + <module name="RegexpSinglelineJava">, + <property name="format" value="^(?!\s+\* $).*?\s+$"/>, + <property name="message" value="Line has trailing spaces."/>, + </module>, + </module>, +</module>]
[+++ b/.travis.yml, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/src/main/java/rx/Observable.java, + * For more information see the <a href="https://github.com/ReactiveX/RxJava/wiki/Observable">RxJava wiki</a>, + * @see <a href="https://github.com/ReactiveX/RxJava/wiki/Creating-Observables#create">RxJava wiki: create</a>, + *
[+++ b/src/main/java/io/reactivex/MaybeObserver.java, + * {@link #onComplete} methods to provide notifications.]
[+++ /dev/null, +++ /dev/null, +++ b/rxjava-contrib/rxjava-joins/src/main/java/rx/joins/operators/OperatorJoinPatterns.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not, + * use this file except in compliance with the License. You may obtain a copy of, + * the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or
[+++ b/src/main/java/io/reactivex/internal/observers/BasicFuseableObserver.java]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, + return create(OperationTakeLast.takeLast(this, count));, + if (count < 0) {, + throw new IllegalArgumentException("count >= 0 required");, + }, + return create(OperationTakeLast.takeLast(this, count, time, unit, scheduler));, + return create(OperationTakeLast.takeLast(this, time, unit, scheduler));, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return create(OperationTakeLast.takeLast(this, count));, + if (count < 0) {, + throw new IllegalArgumentException("count >= 0 required");, + }, + return create(OperationTakeLast.takeLast(this, count, time, unit, scheduler));, + return create(OperationTakeLast.takeLast(this, time, unit, scheduler));, +++ b/rxjava-core/src/main/java/rx/observers/Subscribers.java, + return from(Observers.empty());, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return create(OperationTakeLast.takeLast(this, count));, + if (count < 0) {, + throw new IllegalArgumentException("count >= 0 required");, + }, + return create(OperationTakeLast.takeLast(this, count, time,
[+++ b/src/main/java/io/reactivex/Observable.java, + public final Observable<T> endWith(Publisher<? extends T> other) {, + Objects.requireNonNull(other);, + return concatArray(this, other);, + }, +, + public final Observable<T> endWith(T value) {, + Objects.requireNonNull(value);, + return concatArray(this, just(value));, + }, +, + public final Observable<T> endWithArray(T... values) {, + public final Observable<T> startWith(Publisher<? extends T> other) {, + Objects.requireNonNull(other);, + return concatArray(other, this);, + }, +, + public final Observable<T> startWith(T value) {, + Objects.requireNonNull(value);, + return concatArray(just(value), this);, + }, +, + public final Observable<T> startWithArray(T... values) {, +++ b/src/main/java/io/reactivex/Observable.java, + public final Observable<T> endWith(Publisher<? extends T> other) {, + Objects.requireNonNull(other);, + return
[+++ b/src/main/java/io/reactivex/internal/schedulers/ScheduledRunnable.java, + /** Indicates that the parent tracking this task has been notified about its completion. */, + static final Object PARENT_DISPOSED = new Object();, + /** Indicates the dispose() was called from within the run/call method. */, + static final Object SYNC_DISPOSED = new Object();, + /** Indicates the dispose() was called from another thread. */, + static final Object ASYNC_DISPOSED = new Object();, + if (o != PARENT_DISPOSED && compareAndSet(PARENT_INDEX, o, DONE) && o != null) {, + if (o == SYNC_DISPOSED || o == ASYNC_DISPOSED || compareAndSet(FUTURE_INDEX, o, DONE)) {, + if (o == SYNC_DISPOSED)
[+++ b/src/main/java/io/reactivex/internal/operators/single/SingleFromCallable.java, +import io.reactivex.disposables.Disposable;, +import io.reactivex.disposables.Disposables;, +import io.reactivex.internal.functions.ObjectHelper;, +import io.reactivex.plugins.RxJavaPlugins;, + protected void subscribeActual(SingleObserver<? super T> observer) {, + Disposable d = Disposables.empty();, + observer.onSubscribe(d);, + if (d.isDisposed()) {, + return;, + }, + T value;, +, + value = ObjectHelper.requireNonNull(callable.call(), "The callable returned a null value");, + } catch (Throwable ex) {, + Exceptions.throwIfFatal(ex);, + if (!d.isDisposed()) {, + observer.onError(ex);, + RxJavaPlugins.onError(ex);, + return;, + if (!d.isDisposed()) {, + observer.onSuccess(value);, + }, + }, +++ b/src/main/java/io/reactivex/internal/operators/single/SingleFromCallable.java, +import io.reactivex.disposables.Disposable;, +import io.reactivex.disposables.Disposables;, +import io.reactivex.internal.functions.ObjectHelper;, +import io.reactivex.plugins.RxJavaPlugins;, + protected void subscribeActual(SingleObserver<? super T> observer) {, + Disposable d = Disposables.empty();, +
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationWindow;, +import rx.util.Closing;, +import rx.util.Opening;, + * NOTE: Use {@link #create(Func1)} to create an Observable instead of this method unless you, + // TODO should this static remain? I have left it because it is an Observable<Observable>, + * On an Observable that emits Observables, creates a single Observable that, + * @throws ClassCastException, + * if sequence not of type {@code Observable<Observable<T>}, + @SuppressWarnings("unchecked"), + public Observable<T> switchDo() {, + // TODO can we come up with a better name than this? It should be 'switch' but that is reserved., + // Perhaps 'switchOnNext'?, +
[+++ b/src/main/java/io/reactivex/Flowable.java, + * <p>, + * When the upstream signals an {@link Notification#createOnError(Throwable) onError} or, + * {@link Notification#createOnComplete() onComplete} item, the, + * returned Flowable cancels the flow and terminates with that type of terminal event:, + * <pre><code>, + * Flowable.just(createOnNext(1), createOnComplete(), createOnNext(2)), + * .doOnCancel(() -&gt; System.out.println("Cancelled!"));, + * .test(), + * .assertResult(1);, + * </code></pre>, + * If the upstream signals {@code onError} or {@code onComplete} directly, the flow is terminated, + * with the same event., + * <pre><code>, + * Flowable.just(createOnNext(1), createOnNext(2)), + * .test(), + * .assertResult(1, 2);, + * </code></pre>,
[+++ b/src/main/java/io/reactivex/CompletableSubscriber.java, +/**, + * Copyright 2016 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the
[+++ b/src/main/java/io/reactivex/internal/operators/OperatorReplay.java, +import io.reactivex.internal.subscriptions.*;, +import io.reactivex.internal.util.*;, + if (SubscriptionHelper.validateRequest(n)) {, + long u = BackpressureHelper.addCap(r, n);, + , + BackpressureHelper.add(totalRequested, n);, + final Subscriber<? super T> child = output.child;, + , + if (NotificationLite.accept(o, child)) {, + child.onError(err);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorReplay.java, +import io.reactivex.internal.subscriptions.*;, +import io.reactivex.internal.util.*;, + if (SubscriptionHelper.validateRequest(n)) {, + long u = BackpressureHelper.addCap(r, n);, + , + BackpressureHelper.add(totalRequested, n);, + final Subscriber<? super T> child = output.child;, + , + if (NotificationLite.accept(o, child)) {, + child.onError(err);, +++ b/src/main/java/io/reactivex/internal/queue/MpscLinkedQueue.java, + final LinkedQueueNode<T> nextNode = new LinkedQueueNode<>(nextValue);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorReplay.java, +import io.reactivex.internal.subscriptions.*;, +import io.reactivex.internal.util.*;, + if (SubscriptionHelper.validateRequest(n)) {, + long u =
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationJoin;, +import rx.operators.OperatorMergeDelayError;, + return source.lift(new OperatorMergeDelayError<T>());, + return mergeDelayError(from(t1, t2));, + return mergeDelayError(from(t1, t2, t3));, + return mergeDelayError(from(t1, t2, t3, t4));, + return mergeDelayError(from(t1, t2, t3, t4, t5));, + return mergeDelayError(from(t1, t2, t3, t4, t5, t6));, + return mergeDelayError(from(t1, t2, t3, t4, t5, t6, t7));, + return mergeDelayError(from(t1, t2, t3, t4, t5, t6, t7, t8));, + return mergeDelayError(from(t1, t2, t3, t4, t5, t6, t7, t8, t9));, + return create(new OperationJoin<T, TRight, TLeftDuration, TRightDuration, R>(this, right, leftDurationSelector, rightDurationSelector, resultSelector));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationJoin;, +import rx.operators.OperatorMergeDelayError;, + return source.lift(new OperatorMergeDelayError<T>());, + return mergeDelayError(from(t1, t2));, + return mergeDelayError(from(t1,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationInterval;, +import rx.operators.OperationSample;, +import rx.operators.OperationTimer;, +import rx.operators.OperatorToMultimap;, + return create(OperationInterval.interval(interval, unit));, + return create(OperationInterval.interval(interval, unit, scheduler));, + return create(new OperationTimer.TimerPeriodically(initialDelay, period, unit, scheduler));, + return create(new OperationTimer.TimerOnce(delay, unit, scheduler));, + return create(OperationSample.sample(this, period, unit));, + return create(OperationSample.sample(this, period, unit, scheduler));, + return create(new OperationSample.SampleWithObservable<T, U>(this, sampler));, + return lift(new OperatorToMultimap<T, K, T>(keySelector, Functions.<T>identity()));, + return lift(new OperatorToMultimap<T, K, V>(keySelector, valueSelector));, + return lift(new OperatorToMultimap<T, K, V>(keySelector, valueSelector, mapFactory));, + return lift(new OperatorToMultimap<T, K, V>(keySelector, valueSelector, mapFactory, collectionFactory));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationInterval;, +import rx.operators.OperationSample;, +import rx.operators.OperationTimer;, +import rx.operators.OperatorToMultimap;, + return create(OperationInterval.interval(interval, unit));, + return create(OperationInterval.interval(interval, unit, scheduler));,
[+++ b/src/main/java/io/reactivex/Observable.java, + * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatestDelayError.png" alt="">, + * <p>, + * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/combineLatestDelayError.png" alt="">, + * <p>, + * <img width="640" height="410" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArrayEager.png" alt="">, + * <img width="640" height="220" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/error.supplier.png" alt="">, + * <img width="640" height="220" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/error.item.png" alt="">, + * <img width="640" height="284" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.noarg.png" alt="">, + * <img width="640" height="287" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.timeout.png" alt="">, + * <img width="640" height="287" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.timeout.scheduler.png" alt="">, + * <img width="640" height="294" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromFuture.scheduler.png" alt="">, + * <img width="640" height="186" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromIterable.png" alt="">, + * <img width="640" height="228" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/singleOrError.png" alt="">]
[+++ b/src/main/java/io/reactivex/Observable.java, + * The Observable class is the non-backpressured, optionally multi-valued base reactive class that, + * offers factory methods, intermediate operators and the ability to consume synchronous, + * and/or asynchronous reactive dataflows., + * Many operators in the class accept {@code ObservableSource}(s), the base reactive interface, + * for such non-backpressured flows, which {@code Observable} itself implements as well., + * The design of this class was derived from the, + * <a href="https://github.com/reactive-streams/reactive-streams-jvm">Reactive-Streams design and specification</a>, + * by removing any backpressure-related infrastructure and implementation detail, replacing the, + * {@code org.reactivestreams.Subscription} with {@link Disposable}
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorReplay;, +import rx.operators.OperatorMulticast;, +import rx.operators.OperatorMulticastSelector;, + return create(new OperatorMulticastSelector<T, TIntermediate, TResult>(this, subjectFactory, selector));, + return new OperatorMulticast<T, R>(this, subject);, + return new OperatorMulticast<T, T>(this, PublishSubject.<T> create());, + return new OperatorMulticast<T, T>(this, BehaviorSubject.<T> create(initialValue));, + return new OperatorMulticast<T, T>(this, AsyncSubject.<T> create());, + return new OperatorMulticast<T, T>(this, ReplaySubject.<T> create());, + return create(new OperatorMulticastSelector<T, T, R>(this, new Func0<Subject<T, T>>() {, + }, selector));, + return create(new OperatorMulticastSelector<T, T, R>(this, new Func0<Subject<T, T>>() {, + return OperatorReplay.replayBuffered(bufferSize);, + }, selector));, + return create(new OperatorMulticastSelector<T, T, R>(this, new Func0<Subject<T, T>>() {, + return OperatorReplay.replayWindowed(time, unit, bufferSize, scheduler);, + }, selector));, +
[+++ b/build.gradle, + testCompile 'junit:junit:4.12', + testCompile 'org.mockito:mockito-core:1.10.19', +, + perfCompile 'org.openjdk.jmh:jmh-core:1.10.5', + perfCompile 'org.openjdk.jmh:jmh-generator-annprocess:1.10.5', + // perfCompile 'org.reactivex:rxjava:1.0.14', + exclude "**/io/reactivex/internal/**", +++ b/build.gradle, + testCompile 'junit:junit:4.12', + testCompile 'org.mockito:mockito-core:1.10.19', +, + perfCompile 'org.openjdk.jmh:jmh-core:1.10.5', + perfCompile 'org.openjdk.jmh:jmh-generator-annprocess:1.10.5', + // perfCompile 'org.reactivex:rxjava:1.0.14', + exclude "**/io/reactivex/internal/**", +++ b/src/main/java/io/reactivex/exceptions/MissingBackpressureException.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * ,
[+++ b/gradle.properties, +version=0.8.3]
[+++ b/src/main/java/io/reactivex/Single.java, + * <p>, + * <img width="640" height="463" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.repeatUntil.png" alt="">]
[+++ b/build.gradle, + jvmArgs '-XX:AutoBoxCacheMax=1000000', +++ b/build.gradle, + jvmArgs '-XX:AutoBoxCacheMax=1000000', +++ b/gradle.properties, +version=0.20.0-RC1-SNAPSHOT, +++ b/build.gradle, + jvmArgs '-XX:AutoBoxCacheMax=1000000', +++ b/gradle.properties, +version=0.20.0-RC1-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.internal.util.ScalarSynchronousObservable;, + return from(iterable).subscribeOn(scheduler);, + return ScalarSynchronousObservable.create(value);, + if(count == 1) {, + return Observable.just(start);, + }, + public final Observable<T> onBackpressureBuffer() {, + return lift(new OperatorOnBackpressureBuffer<T>());, + }, + , + public final Observable<T> onBackpressureDrop() {, + return lift(new OperatorOnBackpressureDrop<T>());, + }, + , +++ b/build.gradle, + jvmArgs '-XX:AutoBoxCacheMax=1000000', +++ b/gradle.properties, +version=0.20.0-RC1-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.internal.util.ScalarSynchronousObservable;, + return from(iterable).subscribeOn(scheduler);, + return ScalarSynchronousObservable.create(value);, + if(count == 1) {, + return Observable.just(start);, + }, + public
[+++ b/src/main/java/io/reactivex/Scheduler.java, +import io.reactivex.plugins.RxJavaPlugins;, + Runnable decoratedRun = RxJavaPlugins.onSchedule(run);, + , + decoratedRun.run();, + Runnable decoratedRun = RxJavaPlugins.onSchedule(run);, + , + decoratedRun.run();, + Runnable decoratedRun = RxJavaPlugins.onSchedule(run);, + , + decoratedRun.run();, +++ b/src/main/java/io/reactivex/Scheduler.java, +import io.reactivex.plugins.RxJavaPlugins;, + Runnable decoratedRun = RxJavaPlugins.onSchedule(run);, + , + decoratedRun.run();, + Runnable decoratedRun = RxJavaPlugins.onSchedule(run);, + , + decoratedRun.run();, + Runnable decoratedRun = RxJavaPlugins.onSchedule(run);, + , + decoratedRun.run();, +++ b/src/main/java/io/reactivex/internal/schedulers/ComputationScheduler.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License.,
[+++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java, + @Test(timeout = 30000), + executor.awaitTermination(20000, TimeUnit.MILLISECONDS);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java, + @Test(timeout = 30000), + executor.awaitTermination(20000, TimeUnit.MILLISECONDS);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java, + Flowable<Long> output = cached.observeOn(Schedulers.computation(), false, 1024);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java, + @Test(timeout = 30000), + executor.awaitTermination(20000, TimeUnit.MILLISECONDS);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java, + Flowable<Long> output = cached.observeOn(Schedulers.computation(), false, 1024);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithSizeTest.java, + // assertTrue(count.get() < 100000); // disabled: a small hiccup in the consumption may allow the source to run to completion, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatTest.java, + @Test(timeout = 30000), + executor.awaitTermination(20000, TimeUnit.MILLISECONDS);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableReplayTest.java, + Flowable<Long> output = cached.observeOn(Schedulers.computation(), false, 1024);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithSizeTest.java, + // assertTrue(count.get() < 100000); // disabled: a small hiccup in
[+++ b/src/main/java/io/reactivex/Maybe.java, + * Returns a Maybe that mirrors the source Maybe but applies a timeout policy for each emitted, + * item. If the next item isn't emitted within the specified timeout duration starting from its predecessor,, + * the resulting Maybe terminates and notifies MaybeObservers of a {@code TimeoutException}., + * <p>, + * <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/timeout.1.png" alt="">, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>This version of {@code timeout} operates by default on the {@code computation} {@link Scheduler}.</dd>, + * </dl>, + *, + * @param timeout, + * maximum duration between emitted items
[+++ b/src/main/java/io/reactivex/Observable.java, + final Publisher<T> onSubscribe;, + protected Observable(Publisher<T> onSubscribe) {, + public static <T> Observable<T> create(Publisher<T> onSubscribe) {, + onSubscribe.subscribe(s);, + /**, + * Interface to map/wrap a downstream subscriber to an upstream subscriber., + *, + * @param <Downstream> the value type of the downstream, + * @param <Upstream> the value type of the upstream, + */, + public interface Operator<Downstream, Upstream> extends Function<Subscriber<? super Downstream>, Subscriber<? super Upstream>> {, + , + }, + , + public final <R> Observable<R> lift(Operator<? extends R, ? super T> lifter) {, + onSubscribe.subscribe(st);, +++ b/src/main/java/io/reactivex/Observable.java, + final Publisher<T> onSubscribe;,
[+++ b/src/main/java/io/reactivex/Observable.java, +import java.util.concurrent.*;, +import java.util.stream.Stream;, +import io.reactivex.internal.operators.*;, +import io.reactivex.internal.subscriptions.EmptySubscription;, +, + static final int BUFFER_SIZE;, + static {, + BUFFER_SIZE = Math.max(16, Integer.getInteger("rx2.buffer-size", 128));, + }, + , + @FunctionalInterface, + , + public static int bufferSize() {, + return BUFFER_SIZE;, + }, + , + public static <T> Observable<T> just(T value) {, + Objects.requireNonNull(value);, + return create(new PublisherScalarSource<>(value));, + }, + , + static final Observable<Object> EMPTY = create(PublisherEmptySource.INSTANCE);, + , + @SuppressWarnings("unchecked"), + public static <T> Observable<T> empty() {, + return (Observable<T>)EMPTY;, + }, + , + public static <T> Observable<T> error(Throwable e) {, + return
[+++ b/src/main/java/io/reactivex/internal/functions/Functions.java, +import org.reactivestreams.Subscription;, +, +, + public static final Consumer<Subscription> REQUEST_MAX = new Consumer<Subscription>() {, + @Override, + public void accept(Subscription t) throws Exception {, + t.request(Long.MAX_VALUE);, + }, + };, +++ b/src/main/java/io/reactivex/internal/functions/Functions.java, +import org.reactivestreams.Subscription;, +, +, + public static final Consumer<Subscription> REQUEST_MAX = new Consumer<Subscription>() {, + @Override, + public void accept(Subscription t) throws Exception {, + t.request(Long.MAX_VALUE);, + }, + };, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBlockingSubscribe.java, + if (o == BlockingSubscriber.TERMINATED, + || NotificationLite.acceptFull(v, subscriber)) {, + subscriber.onError(e);, + BlockingIgnoringReceiver callback = new BlockingIgnoringReceiver();, + callback, callback, Functions.REQUEST_MAX);, + BlockingHelper.awaitForComplete(callback, ls);, + Throwable e = callback.error;, + subscribe(o, new
[+++ b/gradlew, +JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.7.0_40.jdk/Contents/Home", +, +++ b/gradlew, +JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.7.0_40.jdk/Contents/Home", +, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/gradlew, +JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.7.0_40.jdk/Contents/Home", +, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +RxScala Release Notes, +=====================, +, +This release of the RxScala bindings builds on the previous 0.15 release to make the Rx bindings for Scala, +include all Rx types. In particular this release focuses on the `Subject` and `Scheduler` types., +To makes these notes self-contained, we will start with the `Observer[T]` and `Observable[T]` traits, +that lay at the heart of Rx., +, +Observer, +--------, +, +In this release we have made the constructor in
[+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableConcatArray.java, + sd.replace(d);, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableConcatArray.java, + sd.replace(d);, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableConcatIterable.java, + sd.replace(d);, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableConcatArray.java, + sd.replace(d);, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableConcatIterable.java, + sd.replace(d);, +++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableAndThenTest.java, +import io.reactivex.functions.Action;, +import io.reactivex.schedulers.Schedulers;, +, +import java.util.concurrent.CountDownLatch;, +, +import static org.junit.Assert.*;, +, + @Test, + public void andThenNoInterrupt() throws InterruptedException {, + for (int k = 0; k < 100; k++) {, + final int count = 10;, + final CountDownLatch latch = new CountDownLatch(count);, + final boolean[] interrupted = { false };, +, + for (int i = 0; i < count; i++) {, + Completable.complete(), + .subscribeOn(Schedulers.io()), + .observeOn(Schedulers.io()), + .andThen(Completable.fromAction(new Action() {, + @Override,
[+++ b/src/main/java/io/reactivex/Completable.java, + return this.<T>toObservable().concatWith(next);, + return other.concatWith(this.<T>toObservable());, +++ b/src/main/java/io/reactivex/Completable.java, + return this.<T>toObservable().concatWith(next);, + return other.concatWith(this.<T>toObservable());, +++ b/src/main/java/io/reactivex/Observable.java, +import io.reactivex.Observer;, +import io.reactivex.flowables.*;, +import io.reactivex.internal.fuseable.*;, +import io.reactivex.internal.operators.flowable.*;, + * The Observable class that is designed similar to the Reactive-Streams Pattern, minus the backpressure,, + * and offers factory methods, intermediate operators and the ability to consume reactive dataflows., + * <p>, + * Reactive-Streams operates with {@code ObservableSource}s which {@code Observable} extends. Many operators, + * therefore accept general {@code ObservableSource}s directly and allow direct interoperation with other, + * Reactive-Streams implementations., + * <p>, + * The Observable's operators,
[+++ b/src/main/java/io/reactivex/Observable.java, + return new ObservableScalarSource<>(value);, + if (this instanceof ObservableScalarSource) {, + ObservableScalarSource<T> scalar = (ObservableScalarSource<T>) this;, + return create(scalar.scalarFlatMap(mapper));, +++ b/src/main/java/io/reactivex/Observable.java, + return new ObservableScalarSource<>(value);, + if (this instanceof ObservableScalarSource) {, + ObservableScalarSource<T> scalar = (ObservableScalarSource<T>) this;, + return create(scalar.scalarFlatMap(mapper));, +++ b/src/main/java/io/reactivex/internal/operators/ObservableScalarSource.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + *
[+++ b/src/main/java/io/reactivex/Maybe.java, + * Runs multiple MaybeSources and signals the events of the first one that signals (cancelling, + * Runs multiple MaybeSources and signals the events of the first one that signals (cancelling, + * Concatenates a Publisher sequence of MaybeSources eagerly into a single stream of values., +++ b/src/main/java/io/reactivex/Maybe.java, + * Runs multiple MaybeSources and signals the events of the first one that signals (cancelling, + * Runs multiple MaybeSources and signals the events of the first one that signals (cancelling, + * Concatenates a Publisher sequence of MaybeSources eagerly into a single stream of values., +++
[+++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java, + * Assert that the TestObserver/TestSubscriber received only the specified values in the specified order without terminating., + * @param values the values expected, + * @return this;, + * @since 2.1.4, + */, + @SuppressWarnings("unchecked"), + @Experimental, + public final U assertValuesOnly(T... values) {, + return assertSubscribed(), + .assertValues(values), + .assertNoErrors(), + .assertNotComplete();, + }, +, + /**, +++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java, + * Assert that the TestObserver/TestSubscriber received only the specified values in the specified order without terminating., + * @param values the values expected, + * @return this;, + * @since 2.1.4, + */, + @SuppressWarnings("unchecked"),
[+++ b/src/main/java/io/reactivex/Flowable.java, + * @return a Single that emits the last item from the source Publisher or notifies Subscribers of an, + public final Single<T> last() {, + return RxJavaPlugins.onAssembly(new FlowableLastSingle<T>(this, null));, + * @return a Single that emits only the last item emitted by the source Publisher, or a default item, + public final Single<T> last(T defaultItem) {, + ObjectHelper.requireNonNull(defaultItem, "defaultItem");, + return RxJavaPlugins.onAssembly(new FlowableLastSingle<T>(this, defaultItem));, + return scan(seed, reducer).takeLast(1).single(); // TODO, + return scanWith(seedSupplier, reducer).takeLast(1).single();, +++ b/src/main/java/io/reactivex/Flowable.java, + * @return a Single that emits the last item from the source Publisher or notifies Subscribers of an, +
[+++ b/src/main/java/io/reactivex/Completable.java, + * @return a {@link Maybe} that only calls {@code onComplete} or {@code onError}, based on which one is, + * called by the source Completable.]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * <p>, + * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the, + * implementation of this operator has to create an {@code Object[]} instead. Unfortunately, a, + * {@code Function<Integer[], R>} passed to the method would trigger a {@code ClassCastException}., + *, + public static <T, R> Flowable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner) {, + * <p>, + * Note on method signature: since Java doesn't allow creating a generic array with {@code new T[]}, the, + * implementation of
[+++ b/src/main/java/io/reactivex/internal/observers/CallbackCompletableObserver.java, +import io.reactivex.observers.LambdaConsumerIntrospection;, +extends AtomicReference<Disposable>, + implements CompletableObserver, Disposable, Consumer<Throwable>, LambdaConsumerIntrospection {, +, + @Override, + public boolean hasCustomOnError() {, + return onError != this;, + }, +++ b/src/main/java/io/reactivex/internal/observers/CallbackCompletableObserver.java, +import io.reactivex.observers.LambdaConsumerIntrospection;, +extends AtomicReference<Disposable>, + implements CompletableObserver, Disposable, Consumer<Throwable>, LambdaConsumerIntrospection {, +, + @Override, + public boolean hasCustomOnError() {, + return onError != this;, + }, +++ b/src/main/java/io/reactivex/internal/observers/ConsumerSingleObserver.java, +import io.reactivex.internal.functions.Functions;, +import io.reactivex.observers.LambdaConsumerIntrospection;, +implements SingleObserver<T>, Disposable, LambdaConsumerIntrospection {, +, + @Override, + public boolean hasCustomOnError() {, + return onError != Functions.ON_ERROR_MISSING;, + }, +++ b/src/main/java/io/reactivex/internal/observers/CallbackCompletableObserver.java, +import io.reactivex.observers.LambdaConsumerIntrospection;, +extends AtomicReference<Disposable>, + implements CompletableObserver, Disposable, Consumer<Throwable>, LambdaConsumerIntrospection {, +, + @Override, +
[+++ b/CHANGES.md, +### Version 0.14.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.2%22)) ###, +, +* [Pull 403](https://github.com/Netflix/RxJava/pull/403) Operators: Cast and OfType, +* [Pull 401](https://github.com/Netflix/RxJava/pull/401) Operator: DefaultIfEmpty, +* [Pull 409](https://github.com/Netflix/RxJava/pull/409) Operator: Synchronize with object, +, +++ b/CHANGES.md, +### Version 0.14.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.2%22)) ###, +, +* [Pull 403](https://github.com/Netflix/RxJava/pull/403) Operators: Cast and OfType, +* [Pull 401](https://github.com/Netflix/RxJava/pull/401) Operator: DefaultIfEmpty, +* [Pull 409](https://github.com/Netflix/RxJava/pull/409) Operator: Synchronize with object, +, +++ b/gradle.properties, +version=0.14.3-SNAPSHOT, +++ b/CHANGES.md, +### Version 0.14.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.2%22)) ###, +, +* [Pull 403](https://github.com/Netflix/RxJava/pull/403) Operators: Cast and OfType, +* [Pull 401](https://github.com/Netflix/RxJava/pull/401) Operator: DefaultIfEmpty, +* [Pull 409](https://github.com/Netflix/RxJava/pull/409) Operator: Synchronize with object, +, +++ b/gradle.properties, +version=0.14.3-SNAPSHOT, +++ b/language-adaptors/rxjava-jruby/build.gradle, +apply plugin: 'osgi', +,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationGroupBy;, +import rx.operators.OperationTakeUntil;, +import rx.operators.OperationToIterator;, + return OperationTakeUntil.takeUntil(source, other);, + return create(OperationGroupBy.groupBy(source, keySelector, elementSelector));, + return create(OperationGroupBy.groupBy(source, keySelector));, + return OperationToIterator.toIterator(that);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationGroupBy;, +import rx.operators.OperationTakeUntil;, +import rx.operators.OperationToIterator;, + return OperationTakeUntil.takeUntil(source, other);, + return create(OperationGroupBy.groupBy(source, keySelector, elementSelector));, + return create(OperationGroupBy.groupBy(source, keySelector));, + return OperationToIterator.toIterator(that);, +++ b/rxjava-core/src/main/java/rx/operators/OperationGroupBy.java, +/**, + * Copyright 2013 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * ,
[+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/concurrency/AndroidSchedulers.java, +import android.os.Handler;, + * Deprecated. Package changed from rx.android.concurrency to rx.android.schedulers., + * , + * @deprecated Use {@link rx.android.schedulers.AndroidSchedulers} instead. This will be removed before 1.0 release., +@Deprecated, + @Deprecated, + return rx.android.schedulers.AndroidSchedulers.handlerThread(handler);, + @Deprecated, + return rx.android.schedulers.AndroidSchedulers.mainThread();, +, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/concurrency/AndroidSchedulers.java, +import android.os.Handler;, + * Deprecated. Package changed from rx.android.concurrency to rx.android.schedulers., + * , + * @deprecated Use {@link rx.android.schedulers.AndroidSchedulers} instead. This will be removed before 1.0 release., +@Deprecated, + @Deprecated, + return rx.android.schedulers.AndroidSchedulers.handlerThread(handler);, + @Deprecated, + return rx.android.schedulers.AndroidSchedulers.mainThread();, +, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/concurrency/HandlerThreadScheduler.java, + * Deprecated. Package changed from rx.android.concurrency to rx.android.schedulers., + * @deprecated Use
[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subscriber.scala, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subscriber.scala, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subscriber.scala, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/ObservableTest.scala, + /*, + val observer = mock(classOf[Observer[Int]]), + val o = Observable().head, + val sub = o.subscribe(observer), + verify(observer, never).onNext(any(classOf[Int])), + verify(observer, never).onCompleted(), + verify(observer, times(1)).onError(any(classOf[NoSuchElementException])), + */, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subscriber.scala, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/ObservableTest.scala, + /*, + val observer = mock(classOf[Observer[Int]]), + val o = Observable().head, + val sub = o.subscribe(observer),
[+++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java, +import org.jruby.RubyProc;, +import org.jruby.javasupport.JavaUtil;, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java, +import org.jruby.RubyProc;, +import org.jruby.javasupport.JavaUtil;, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyFunctionWrapper.java, +import org.jruby.RubyProc;, +import org.jruby.javasupport.JavaUtil;, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java, +import org.jruby.RubyProc;, +import org.jruby.javasupport.JavaUtil;, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyFunctionWrapper.java, +import org.jruby.RubyProc;, +import org.jruby.javasupport.JavaUtil;, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java, +import org.jruby.RubyProc;, +import org.jruby.javasupport.JavaUtil;, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyFunctionWrapper.java, +import org.jruby.RubyProc;, +import org.jruby.javasupport.JavaUtil;, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/schedulers/AndroidSchedulers.java, +import rx.Scheduler;, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java, +import org.jruby.RubyProc;, +import org.jruby.javasupport.JavaUtil;, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyFunctionWrapper.java, +import org.jruby.RubyProc;, +import org.jruby.javasupport.JavaUtil;, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/schedulers/AndroidSchedulers.java, +import rx.Scheduler;, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/schedulers/HandlerThreadScheduler.java, +import java.util.concurrent.TimeUnit;, +import android.os.Handler;, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java, +import org.jruby.RubyProc;, +import org.jruby.javasupport.JavaUtil;, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyFunctionWrapper.java, +import org.jruby.RubyProc;, +import org.jruby.javasupport.JavaUtil;, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/schedulers/AndroidSchedulers.java, +import rx.Scheduler;, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/schedulers/HandlerThreadScheduler.java, +import java.util.concurrent.TimeUnit;, +import android.os.Handler;, +++
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorMergeMapPair;, +import rx.operators.OperatorMergeMapTransform;, + return lift(new OperatorMergeMapTransform<T, R>(onNext, onError, onCompleted));, + return lift(new OperatorMergeMapPair<T, U, R>(collectionSelector, resultSelector));, + return merge(map(OperatorMergeMapPair.convertSelector(collectionSelector)));, + return mergeMap(OperatorMergeMapPair.convertSelector(collectionSelector), resultSelector);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorMergeMapPair;, +import rx.operators.OperatorMergeMapTransform;, + return lift(new OperatorMergeMapTransform<T, R>(onNext, onError, onCompleted));, + return lift(new OperatorMergeMapPair<T, U, R>(collectionSelector, resultSelector));, + return merge(map(OperatorMergeMapPair.convertSelector(collectionSelector)));, + return mergeMap(OperatorMergeMapPair.convertSelector(collectionSelector), resultSelector);, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorMergeMapPair;, +import rx.operators.OperatorMergeMapTransform;, + return lift(new OperatorMergeMapTransform<T, R>(onNext, onError, onCompleted));, + return lift(new OperatorMergeMapPair<T, U, R>(collectionSelector, resultSelector));, + return merge(map(OperatorMergeMapPair.convertSelector(collectionSelector)));, + return mergeMap(OperatorMergeMapPair.convertSelector(collectionSelector), resultSelector);, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorMergeMapPair.java, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed
[+++ b/src/main/java/io/reactivex/internal/operators/single/SingleTimeout.java, +import java.util.concurrent.atomic.AtomicReference;, +import io.reactivex.disposables.Disposable;, +import io.reactivex.internal.disposables.DisposableHelper;, +import io.reactivex.plugins.RxJavaPlugins;, + TimeoutMainObserver<T> parent = new TimeoutMainObserver<T>(s, other);, + s.onSubscribe(parent);, + DisposableHelper.replace(parent.task, scheduler.scheduleDirect(parent, timeout, unit));, + source.subscribe(parent);, + static final class TimeoutMainObserver<T> extends AtomicReference<Disposable>, + implements SingleObserver<T>, Runnable, Disposable {, + private static final long serialVersionUID = 37497744973048446L;, +, + final SingleObserver<? super T> actual;, +, + final AtomicReference<Disposable> task;, +, + final TimeoutFallbackObserver<T> fallback;, +, + SingleSource<? extends T> other;, +, + static final class TimeoutFallbackObserver<T> extends AtomicReference<Disposable>, + implements SingleObserver<T> {, +, + private static final long serialVersionUID = 2071387740092105509L;, + final SingleObserver<? super T> actual;, +, +
[+++ b/gradle.properties, +version=0.17.0-RC3-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Observable.java, + return (new ObservableAmb<T>(null, sources));, + return (new ObservableAmb<T>(sources, null));, + return (new ObservableCombineLatest<T, R>(null, sources, combiner, s, delayError));, + return (new ObservableCombineLatest<T, R>(sources, null, combiner, s, delayError));, + return new ObservableLift<T, ObservableConsumable<? extends T>>(sources, new NbpOperatorConcatMap(Functions.identity(), bufferSize));, + return (new ObservableDefer<T>(supplier));, + return (new ObservableError<T>(errorSupplier));, + return (new ObservableFromArray<T>(values));, + return (new ObservableFromCallable<T>(supplier));, + return (new ObservableFromFuture<T>(future, 0L, null));, + Observable<T> o = create(new ObservableFromFuture<T>(future, timeout, unit));, + return (new ObservableFromIterable<T>(source));, + return (new ObservableGenerate<T, S>(initialState, generator, disposeState));, + return (new ObservableInterval(initialDelay, period, unit, scheduler));, + return (new ObservableIntervalRange(start, end, initialDelay, period, unit, scheduler));, + return
[+++ b/src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java, + return;, +++ b/src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java, + return;, +++ b/src/test/java/io/reactivex/internal/util/MiscUtilTest.java, + list.forEachWhile(new NonThrowingPredicate<Integer>() {, + @Override, + public boolean test(Integer t2) {, + out.add(t2);, + return t2 == 2;, + }, + });, +, + assertEquals(Arrays.asList(1, 2), out);, + }, +, + @Test, + public void appendOnlyLinkedArrayListForEachWhileBi() throws Exception {, + AppendOnlyLinkedArrayList<Integer> list = new AppendOnlyLinkedArrayList<Integer>(2);, +, + list.add(1);, + list.add(2);, + list.add(3);, +, + final List<Integer> out = new ArrayList<Integer>();, +]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.exceptions.Exceptions;, +import rx.exceptions.OnErrorNotImplementedException;, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.exceptions.Exceptions;, +import rx.exceptions.OnErrorNotImplementedException;, +++ b/rxjava-core/src/main/java/rx/exceptions/CompositeException.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES
[+++ b/.travis.yml, +sudo: required]
[+++ b/gradle.properties, +version=0.17.0-RC6]
[+++ /dev/null, +++ /dev/null, +++ b/gradlew.bat, +++ /dev/null, +++ b/gradlew.bat, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ /dev/null, +++ b/gradlew.bat, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +RxScala Release Notes, +=====================, +, +This release of the RxScala bindings builds on the previous 0.15 release to make the Rx bindings for Scala, +include all Rx types. In particular this release focuses on the `Subject` and `Scheduler` types., +To makes these notes self-contained, we will start with the `Observer[T]` and `Observable[T]` traits, +that lay at the heart of Rx., +, +Observer, +--------, +, +In this release we have made the
[+++ b/src/main/java/io/reactivex/internal/disposables/DisposableHelper.java, + /**, + * Checks if the given Disposable is the common {@link #DISPOSED} enum value., + * @param d the disposable to check, + * @return true if d is {@link #DISPOSED}, + */, + /**, + * Atomically sets the field and disposes the old contents., + * @param field the target field, + * @param d the new Disposable to set, + * @return true if successful, false if the field contains the {@link #DISPOSED} instance., + */, + /**, + * Atomically tries to set the given Disposable on the field if it
[+++ b/src/main/java/io/reactivex/internal/operators/OperatorTake.java, + if (!done && remaining-- > 0) {, + boolean stop = remaining == 0;, + if (stop) {, +++ b/src/main/java/io/reactivex/internal/operators/OperatorTake.java, + if (!done && remaining-- > 0) {, + boolean stop = remaining == 0;, + if (stop) {, +++ b/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java, + } else if (null != lvElement(buffer, calcWrappedOffset(index + 1, mask))) { // buffer is not full, +++ b/src/main/java/io/reactivex/internal/operators/OperatorTake.java, + if (!done && remaining-- > 0) {, + boolean stop = remaining == 0;, + if (stop) {, +++ b/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java, + } else if (null != lvElement(buffer, calcWrappedOffset(index + 1, mask))) { // buffer is
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/build.gradle, +++ b/CHANGES.md, +++ b/build.gradle, +++ b/gradle.properties, +version=0.18.4-SNAPSHOT, +++ b/CHANGES.md, +++ b/build.gradle, +++ b/gradle.properties, +version=0.18.4-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/CHANGES.md, +++ b/build.gradle, +++ b/gradle.properties, +version=0.18.4-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/CHANGES.md, +++ b/build.gradle, +++ b/gradle.properties, +version=0.18.4-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subscriber.scala, +++ b/CHANGES.md, +++ b/build.gradle, +++ b/gradle.properties, +version=0.18.4-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subscriber.scala, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +++ b/CHANGES.md, +++ b/build.gradle, +++ b/gradle.properties, +version=0.18.4-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subscriber.scala, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/SubscriberTests.scala, +++ b/CHANGES.md, +++ b/build.gradle, +++ b/gradle.properties, +version=0.18.4-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subscriber.scala, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/CompletenessTest.scala, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/SubscriberTests.scala, +++ b/rxjava-core/src/main/java/rx/Subscriber.java, +import rx.subscriptions.ChainedSubscription;,
[+++ b/.gitignore, +# Compiled source #, +###################, +*.com, +*.class, +*.dll, +*.exe, +*.o, +*.so, +, +# Packages #, +############, +# it's better to unpack these files and commit the raw source, +# git has its own built in compression methods, +*.7z, +*.dmg, +*.gz, +*.iso, +*.jar, +*.rar, +*.tar, +*.zip, +, +# Logs and databases #, +######################, +*.log, +, +# OS generated files #, +######################, +.DS_Store*, +ehthumbs.db, +Icon?, +Thumbs.db, +, +# Editor Files #, +################, +*~, +*.swp, +, +# Gradle Files #, +################, +.gradle, +, +# Build output directies, +/target, +*/target, +/build, +*/build, +, +# IntelliJ specific files/directories, +out, +.idea, +*.ipr, +*.iws,
[+++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java, +import io.reactivex.annotations.Experimental;, + * Assert that this TestObserver/TestSubscriber did not receive an onNext value which is equal to, + * the given value with respect to Objects.equals., + *, + * @since 2.0.5 - experimental, + * @param value the value to expect not being received, + * @return this;, + */, + @Experimental, + @SuppressWarnings("unchecked"), + public final U assertNever(T value) {, + int s = values.size();, +, + for (int i = 0; i < s; i++) {, + T v = this.values.get(i);, + if (ObjectHelper.equals(v, value)) {, + throw fail("Value at position " +
[+++ b/CHANGES.md, +### Version 0.13.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.13.2%22)) ###, +, +* [Pull 389](https://github.com/Netflix/RxJava/pull/389) Scala Adaptor Improvements, +* [Pull 382](https://github.com/Netflix/RxJava/pull/382) Removing deprecated RxImplicits from rxjava-scala, +* [Pull 381](https://github.com/Netflix/RxJava/pull/381) Operator: mapWithIndex, +* [Pull 380](https://github.com/Netflix/RxJava/pull/380) Implemented `distinct` and `distinctUntilChanged` variants using a comparator, +* [Pull 379](https://github.com/Netflix/RxJava/pull/379) Make `interval` work with multiple subscribers, +, +++ b/CHANGES.md, +### Version 0.13.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.13.2%22)) ###, +, +* [Pull 389](https://github.com/Netflix/RxJava/pull/389) Scala Adaptor Improvements, +* [Pull 382](https://github.com/Netflix/RxJava/pull/382) Removing deprecated RxImplicits from rxjava-scala, +* [Pull 381](https://github.com/Netflix/RxJava/pull/381) Operator: mapWithIndex, +* [Pull 380](https://github.com/Netflix/RxJava/pull/380) Implemented `distinct` and `distinctUntilChanged` variants using a comparator, +* [Pull 379](https://github.com/Netflix/RxJava/pull/379) Make `interval` work with multiple subscribers, +, +++
[+++ b/src/main/java/io/reactivex/Completable.java, + * Wraps the given CompletableSource into a Completable, + return new CompletableFromSource(source);, + * Constructs a Completable instance by wrapping the given source callback., + * @param source the callback which will receive the CompletableObserver instances, + * @throws NullPointerException if source is null, + public static Completable create(CompletableSource source) {, + Objects.requireNonNull(source, "source is null");, + if (source instanceof Completable) {, + // TODO plugin wrapping source, + return RxJavaPlugins.onAssembly(new CompletableFromSource(source));, +++ b/src/main/java/io/reactivex/Completable.java, + * Wraps the given CompletableSource into a Completable, + return new CompletableFromSource(source);, + * Constructs a Completable instance by wrapping the
[+++ b/CHANGES.md, +### Version 1.0.3 – December 15th 2014 ([Maven Central](http://search.maven.org/#artifactdetails%7Cio.reactivex%7Crxjava%7C1.0.3%7C)) ###, +, +* [Pull 1928] (https://github.com/ReactiveX/RxJava/pull/1928) Experimental: Add onBackpressureBuffer with capacity, +* [Pull 1946] (https://github.com/ReactiveX/RxJava/pull/1946) Experimental: AbstractOnSubscribe to help build Observables one onNext at a time. , +* [Pull 1960] (https://github.com/ReactiveX/RxJava/pull/1960) Beta: doOnRequest, +* [Pull 1965] (https://github.com/ReactiveX/RxJava/pull/1965) Fix the issue that Sample doesn't call 'unsubscribe' , +* [Pull 1966] (https://github.com/ReactiveX/RxJava/pull/1966) Fix NPE when the key is null in GroupBy, +* [Pull 1964] (https://github.com/ReactiveX/RxJava/pull/1964) Handle 0 or negative request in Buffer, +* [Pull 1957] (https://github.com/ReactiveX/RxJava/pull/1957) Fix 'request(0)' issue in Scan, +* [Pull 1950] (https://github.com/ReactiveX/RxJava/pull/1950) Add "Subscriptions.unsubscribed" to fix the
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorMulticast;, +import rx.operators.OperatorMulticastSelector;, +import rx.operators.OperatorReplay;, + return create(new OperatorMulticastSelector<T, TIntermediate, TResult>(this, subjectFactory, selector));, + return new OperatorMulticast<T, R>(this, subject);, + return new OperatorMulticast<T, T>(this, PublishSubject.<T> create());, + return new OperatorMulticast<T, T>(this, BehaviorSubject.<T> create(initialValue));, + return new OperatorMulticast<T, T>(this, AsyncSubject.<T> create());, + return new OperatorMulticast<T, T>(this, ReplaySubject.<T> create());, + return create(new OperatorMulticastSelector<T, T, R>(this, new Func0<Subject<T, T>>() {, + }, selector));, + return create(new OperatorMulticastSelector<T, T, R>(this, new Func0<Subject<T, T>>() {, + return OperatorReplay.replayBuffered(bufferSize);, + }, selector));, + return create(new OperatorMulticastSelector<T, T, R>(this, new Func0<Subject<T, T>>() {, + return OperatorReplay.replayWindowed(time, unit, bufferSize, scheduler);, + }, selector));, +
[+++ b/src/main/java/io/reactivex/Observable.java, + , + public final Observable<T> share() {, + return publish().refCount();, + }, +, + public final Observable<T> delaySubscription(long delay, TimeUnit unit) {, + return delaySubscription(delay, unit, Schedulers.computation());, + }, + , + // TODO a more efficient implementation if necessary, + public final Observable<T> delaySubscription(long delay, TimeUnit unit, Scheduler scheduler) {, + Objects.requireNonNull(unit);, + Objects.requireNonNull(scheduler);, + , + return timer(delay, unit, scheduler).flatMap(v -> this);, + }, + , + public final <U> Observable<T> delaySubscription(Supplier<? extends Publisher<U>> delaySupplier) {, + return fromCallable(delaySupplier::get).take(1).flatMap(v -> this);, + }, + , + // TODO a more efficient implementation if necessary,
[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +, + @Test def liftExample1(): Unit = {, + // Add "No. " in front of each item, + val o = List(1, 2, 3).toObservable.lift {, + subscriber: Subscriber[String] =>, + Subscriber[Int](, + subscriber,, + (v: Int) => subscriber.onNext("No. " + v),, + e => subscriber.onError(e),, + () => subscriber.onCompleted, + ), + }.toBlockingObservable.toList, + println(o), + }, +, + @Test def liftExample2(): Unit = {, + // Split the input Strings with " ", + val splitStringsWithSpace = (subscriber: Subscriber[String]) => {, + Subscriber[String](, + subscriber,, + (v: String) => v.split(" ").foreach(subscriber.onNext(_)),, + e => subscriber.onError(e),,
[+++ b/rxjava-core/src/main/java/org/rx/operations/AtomicObservableSubscription.java, +package org.rx.operations;, +, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicReference;, +, +import javax.annotation.concurrent.ThreadSafe;, +, +import org.rx.reactive.Subscription;, +, +/**, + * Thread-safe wrapper around ObservableSubscription that ensures unsubscribe can be called only once., + */, +@ThreadSafe, +/* package */final class AtomicObservableSubscription implements Subscription {, +, + private AtomicReference<Subscription> actualSubscription = new AtomicReference<Subscription>();, + private AtomicBoolean unsubscribed = new AtomicBoolean(false);, +, + public AtomicObservableSubscription() {, +, + }, +, + public AtomicObservableSubscription(Subscription actualSubscription) {, + this.actualSubscription.set(actualSubscription);, + }, +, + /**, + * Set the actual subscription once it exists (if it wasn't available when constructed), + * , + * @param
[+++ b/gradle.properties, +version=0.5.3-SNAPSHOT]
[+++ b/gradle.properties, +version=0.16.1-SNAPSHOT, +++ b/gradle.properties, +version=0.16.1-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, + @SuppressWarnings("unchecked"), + // suppress because the types are checked by the method signature before using a vararg, + return create(OperationMerge.merge(t1, t2));, + @SuppressWarnings("unchecked"), + // suppress because the types are checked by the method signature before using a vararg, + return create(OperationMerge.merge(t1, t2, t3));, + @SuppressWarnings("unchecked"), + // suppress because the types are checked by the method signature before using a vararg, + return create(OperationMerge.merge(t1, t2, t3, t4));, + @SuppressWarnings("unchecked"), + // suppress because the types are checked by the method signature before using a vararg, + return create(OperationMerge.merge(t1, t2,
[+++ b/src/main/java/io/reactivex/Observable.java, + Objects.requireNonNull(onSubscribe);, + Objects.requireNonNull(s);, + Objects.requireNonNull(s);, + Objects.requireNonNull(s);, + Objects.requireNonNull(lifter);, + Objects.requireNonNull(e);, + Objects.requireNonNull(errorSupplier);, + public final Observable<T> asObservable() {, + Objects.requireNonNull(source);, + Objects.requireNonNull(stream);, + Objects.requireNonNull(future);, + , + public final <R> Observable<R> map(Function<? super T, ? extends R> mapper) {, + return lift(new OperatorMap<>(mapper));, + }, + , + public final <R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {, + return flatMap(mapper, false, bufferSize(), bufferSize());, + }, + , + public final <R> Observable<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int maxConcurrency) {, + return flatMap(mapper, false, maxConcurrency, bufferSize());,
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureError.java, + private static final long serialVersionUID = -3176480756392482682L;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureError.java, + private static final long serialVersionUID = -3176480756392482682L;, +++ b/src/test/java/io/reactivex/TransformerTest.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureError.java, + private static final long serialVersionUID = -3176480756392482682L;, +++ b/src/test/java/io/reactivex/TransformerTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromSourceTest.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureError.java, + private static final long serialVersionUID = -3176480756392482682L;, +++ b/src/test/java/io/reactivex/TransformerTest.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromSourceTest.java, +++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableToXTest.java, + Observable.range(1, 5)]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorDoOnEach;, +import rx.operators.OperatorObserveOn;, +import rx.operators.OperatorRepeat;, +import rx.operators.OperatorSubscribeOn;, +import rx.operators.OperatorZip;, + return lift(new OperatorObserveOn<T>(scheduler));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorDoOnEach;, +import rx.operators.OperatorObserveOn;, +import rx.operators.OperatorRepeat;, +import rx.operators.OperatorSubscribeOn;, +import rx.operators.OperatorZip;, + return lift(new OperatorObserveOn<T>(scheduler));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorDoOnEach;, +import rx.operators.OperatorObserveOn;, +import rx.operators.OperatorRepeat;, +import rx.operators.OperatorSubscribeOn;, +import rx.operators.OperatorZip;, + return lift(new OperatorObserveOn<T>(scheduler));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorObserveOn.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License
[+++ b/src/main/java/io/reactivex/Observable.java, + public static <T> Observable<T> merge(Publisher<? extends Publisher<? extends T>> sources) {, + return merge(sources, bufferSize());, + }, +, + public static <T> Observable<T> merge(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency) {, + return fromPublisher(sources).flatMap(v -> v, maxConcurrency);, + }, +, + public static <T> Observable<T> mergeDelayError(Publisher<? extends Publisher<? extends T>> sources) {, + return mergeDelayError(sources, bufferSize());, + }, +, + public static <T> Observable<T> mergeDelayError(Publisher<? extends Publisher<? extends T>> sources, int maxConcurrency) {, + return fromPublisher(sources).flatMap(v -> v, true, maxConcurrency);, + }, +, + , + return lift(new OperatorConcatMap<>(mapper, prefetch));, + public final Observable<T> concat(Publisher<?
[+++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscriptions.empty()!!, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscriptions.empty()!!, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscriptions.empty()!!, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscriptions.empty()!!, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscriptions.empty()!!, +++ b/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/ObservableHttp.java, +import org.apache.http.protocol.Http.HttpContext;, +import org.apache.http.protocol.BasicHttpContext;, + return createRequest(requestProducer, client, new BasicHttpContext());, + }, +, + /**, + * Execute request using {@link HttpAsyncRequestProducer} to define HTTP Method, URI and payload (if applicable)., + * <p>, + * If the response is chunked (or flushed progressively such as with <i>text/event-stream</i> <a href="http://www.w3.org/TR/2009/WD-eventsource-20091029/">Server-Sent Events</a>) this will call, + * {@link Observer#onNext} multiple times., + * <p>, + * Use {@code HttpAsyncMethods.create* } factory methods to create {@link
[+++ b/src/main/java/io/reactivex/Observable.java, + public final <R> Observable<R> compose(ObservableTransformer<T, R> composer) {, +++ b/src/main/java/io/reactivex/Observable.java, + public final <R> Observable<R> compose(ObservableTransformer<T, R> composer) {, +++ b/src/test/java/io/reactivex/internal/operators/single/SingleAmbTest.java, +++ b/src/main/java/io/reactivex/Observable.java, + public final <R> Observable<R> compose(ObservableTransformer<T, R> composer) {, +++ b/src/test/java/io/reactivex/internal/operators/single/SingleAmbTest.java, +++ b/src/test/java/io/reactivex/observable/ObservableCovarianceTest.java, + .compose(new ObservableTransformer<Movie, Movie>() {, + Observable<Movie> movie2 = movie.compose(new ObservableTransformer<HorrorMovie, Movie>() {, + Observable<HorrorMovie> movie2 = movie.compose(new ObservableTransformer<Movie, HorrorMovie>() {, + Observable<HorrorMovie> movie2 = movie.compose(new ObservableTransformer<Movie, HorrorMovie>() {, + Observable<HorrorMovie> movie2 = movie.compose(new ObservableTransformer<HorrorMovie, HorrorMovie>() {, +++ b/src/main/java/io/reactivex/Observable.java, + public final <R> Observable<R> compose(ObservableTransformer<T, R> composer) {, +++ b/src/test/java/io/reactivex/internal/operators/single/SingleAmbTest.java, +++ b/src/test/java/io/reactivex/observable/ObservableCovarianceTest.java, + .compose(new ObservableTransformer<Movie, Movie>() {, + Observable<Movie> movie2
[+++ b/src/main/java/io/reactivex/NbpObservable.java, + s.onError(e);, + s.onError(new NoSuchElementException());, +++ b/src/main/java/io/reactivex/NbpObservable.java, + s.onError(e);, + s.onError(new NoSuchElementException());, +++ b/src/main/java/io/reactivex/Single.java, +import java.util.concurrent.atomic.*;, +import io.reactivex.disposables.*;, +import io.reactivex.functions.*;, +import io.reactivex.internal.util.*;, +import io.reactivex.plugins.RxJavaPlugins;, +import io.reactivex.schedulers.Schedulers;, + public interface SingleOnSubscribe<T> extends Consumer<SingleSubscriber<? super T>> {, + , + }, + , + public interface SingleOperator<Downstream, Upstream> extends Function<SingleSubscriber<? super Downstream>, SingleSubscriber<? super Upstream>> {, + , + }, + , + public interface SingleSubscriber<T> {, + , + void onError(Throwable e);, + public static <T> Single<T> amb(Iterable<? extends Single<? extends T>> sources) {, + return create(s -> {, + AtomicBoolean once = new AtomicBoolean();, + CompositeDisposable set
[+++ b/rxjava-core/src/main/java/rx/concurrency/AbstractScheduler.java, + return schedule(new SleepingAction(action, this, timespan, unit));, +++ b/rxjava-core/src/main/java/rx/concurrency/AbstractScheduler.java, + return schedule(new SleepingAction(action, this, timespan, unit));, +++ b/rxjava-core/src/main/java/rx/concurrency/CurrentThreadScheduler.java, +import org.mockito.InOrder;, +, +import static org.mockito.Mockito.*;, +, + boolean exec = queue == null;, + if (exec) {, + if (exec) {, + while (!queue.isEmpty()) {, +, + QUEUE.set(null);, + }, + public void testOrdering() {, + final Action0 firstStepStart = mock(Action0.class);, + final Action0 firstStepEnd = mock(Action0.class);, +, + final Action0 secondStepStart = mock(Action0.class);, + final Action0 secondStepEnd = mock(Action0.class);, +, + final Action0 thirdStepStart = mock(Action0.class);, + final Action0 thirdStepEnd = mock(Action0.class);, +, + firstStepStart.call();, + firstStepEnd.call();,
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/README.md, +<a href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-scala">Scala</a> , +and <a href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-jruby">JRuby</a>. , +- Support Java 5 (to include Android support) and higher with an eventual goal to target a build for Java 8 with its lambda support., +- <a href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-jruby">JRuby Adaptor</a> , +++ b/CHANGES.md, +++ b/README.md, +<a href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-scala">Scala</a> , +and <a href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-jruby">JRuby</a>. , +- Support Java 5 (to include Android support) and higher with an eventual goal to target a build for Java 8 with its lambda support., +- <a href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-jruby">JRuby Adaptor</a> , +++ b/build.gradle, +ext.githubProjectName = rootProject.name, +, +buildscript {, + repositories { mavenCentral() }, + apply
[+++ b/gradle.properties, +version=0.20.0-RC5-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableScan.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableScan.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableScanSeed.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableScan.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableScanSeed.java, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableScan.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableScan.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableScanSeed.java, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableScan.java, +++ b/src/test/java/io/reactivex/flowable/FlowableScanTests.java, +import java.util.*;, +import java.util.concurrent.*;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableScan.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableScanSeed.java, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableScan.java, +++ b/src/test/java/io/reactivex/flowable/FlowableScanTests.java, +import java.util.*;, +import java.util.concurrent.*;, +++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableScanTest.java]
[+++ b/src/main/java/io/reactivex/Observable.java, + * <img width="640" height="327" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doOnTerminate.o.png" alt="">, + * <img width="640" height="363" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAt.o.png" alt="">, + * <img width="640" height="353" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtDefault.o.png" alt="">, + * <img width="640" height="362" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAtOrError.o.png" alt="">, + * <img width="640" height="286" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstElement.m.png" alt="">, + * <img width="640" height="434" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstOrError.o.png" alt="">, + * <img width="640" height="356" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapDelayError.o.png" alt="">, + * <p>, + * <img width="640" height="441" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapMaxConcurrency.o.png" alt="">, + * <p>, + * <img width="640" height="441" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapMaxConcurrency.o.png" alt="">, + * <p>, + * <img width="640" height="441" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapMaxConcurrency.o.png" alt="">]
[+++ b/build.gradle, +def jacocoVersion = "0.8.0", + toolVersion = jacocoVersion // See http://www.eclemma.org/jacoco/., +++ b/build.gradle, +def jacocoVersion = "0.8.0", + toolVersion = jacocoVersion // See http://www.eclemma.org/jacoco/., +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWindowBoundary.java, +import io.reactivex.*;, +import io.reactivex.internal.util.*;, +import io.reactivex.subscribers.DisposableSubscriber;, + final int capacityHint;, + public FlowableWindowBoundary(Flowable<T> source, Publisher<B> other, int capacityHint) {, + this.capacityHint = capacityHint;, + protected void subscribeActual(Subscriber<? super Flowable<T>> subscriber) {, + WindowBoundaryMainSubscriber<T, B> parent = new WindowBoundaryMainSubscriber<T, B>(subscriber, capacityHint);, +, + subscriber.onSubscribe(parent);, +, + parent.innerNext();, +, + other.subscribe(parent.boundarySubscriber);, +, + source.subscribe(parent);, + extends AtomicInteger, + implements FlowableSubscriber<T>, Subscription, Runnable {, + private static final long serialVersionUID = 2233020065421370272L;, + final
[+++ b/src/main/java/io/reactivex/Observable.java, + Objects.requireNonNull(bufferOpenings);, + Objects.requireNonNull(bufferClosingSelector);, + Objects.requireNonNull(bufferSupplier);, + return lift(new OperatorBufferBoundary<>(bufferOpenings, bufferClosingSelector, bufferSupplier));, + , + public final <B, U extends Collection<? super T>> Observable<U> buffer(Observable<B> boundary, Supplier<U> bufferSupplier) {, + Objects.requireNonNull(boundary);, + Objects.requireNonNull(bufferSupplier);, + return lift(new OperatorBufferExactBoundary<>(boundary, bufferSupplier));, +++ b/src/main/java/io/reactivex/Observable.java, + Objects.requireNonNull(bufferOpenings);, + Objects.requireNonNull(bufferClosingSelector);, + Objects.requireNonNull(bufferSupplier);, + return lift(new OperatorBufferBoundary<>(bufferOpenings, bufferClosingSelector, bufferSupplier));, + , + public final <B, U extends Collection<? super T>> Observable<U> buffer(Observable<B> boundary, Supplier<U> bufferSupplier) {, + Objects.requireNonNull(boundary);, + Objects.requireNonNull(bufferSupplier);, + return lift(new OperatorBufferExactBoundary<>(boundary, bufferSupplier));, +++ b/src/main/java/io/reactivex/Try.java, + * @param value the value to wrap , + * @return the created Try instance, +
[+++ b/CHANGES.md, +, +### Version 0.20.0-RC6 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.20.0-RC6%22)) ###, +, +Further fixes and enhancements bringing us close to completing 0.20.0 and almost ready for 1.0., +, +A more major change in this release is the deprecation of `Observable.from(T)`. The full discussion can be seen in [#1563](https://github.com/Netflix/RxJava/issues/1563)., +, +* [Pull 1575] (https://github.com/Netflix/RxJava/pull/1575) combineLatest with backpressure, +* [Pull 1569] (https://github.com/Netflix/RxJava/pull/1569) Compose/Transform Covariance, +* [Pull 1577] (https://github.com/Netflix/RxJava/pull/1577) Fix the compose covariance, +* [Pull 1581] (https://github.com/Netflix/RxJava/pull/1581) zip(Iterable) -> zipWith(Iterable), +* [Pull 1582] (https://github.com/Netflix/RxJava/pull/1582) Deprecate GroupedObservable.from, +* [Pull 1583] (https://github.com/Netflix/RxJava/pull/1583) Redo/Repeat Backpressure, +* [Pull 1576] (https://github.com/Netflix/RxJava/pull/1576) from(T) -> just(T), +* [Pull 1545] (https://github.com/Netflix/RxJava/pull/1545) Make
[+++ b/build.gradle, + //perfCompile project, + args '1', +// args '.*OperatorSerializePerf.*' // for running only a specific test, +++ b/build.gradle, + //perfCompile project, + args '1', +// args '.*OperatorSerializePerf.*' // for running only a specific test, +++ b/gradle/buildscript.gradle, +++ b/build.gradle, + //perfCompile project, + args '1', +// args '.*OperatorSerializePerf.*' // for running only a specific test, +++ b/gradle/buildscript.gradle, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, +++ b/build.gradle, + //perfCompile project, + args '1', +// args '.*OperatorSerializePerf.*' // for running only a specific test, +++ b/gradle/buildscript.gradle, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, +++ /dev/null, +++ b/build.gradle, + //perfCompile project, + args '1', +// args '.*OperatorSerializePerf.*' // for running only
[+++ b/.gitignore, +.gradletasknamecache, +++ b/.gitignore, +.gradletasknamecache, +++ b/rxjava-contrib/rxjava-android-samples-build-wrapper/build.gradle, +def androidHome = System.getenv("ANDROID_HOME"), +tasks.build.doLast {, + if (androidHome.isEmpty()) {, + println("No Android SDK detected; skipping Android samples build"), + } else {, + println("Android SDK detected at $androidHome, running samples build"), + project.exec {, + workingDir '../rxjava-android-samples', +, + commandLine "./gradlew", "clean", "packageDebug", "-PrxjVersion=${version}", + }, + }, +}, +++ b/.gitignore, +.gradletasknamecache, +++ b/rxjava-contrib/rxjava-android-samples-build-wrapper/build.gradle, +def androidHome = System.getenv("ANDROID_HOME"), +tasks.build.doLast {, + if (androidHome.isEmpty()) {, + println("No Android SDK detected; skipping Android samples build"), + } else {, + println("Android SDK detected at $androidHome, running samples build"), + project.exec {, +
[+++ b/.travis.yml, + , +sudo: false, +# as per http://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/, +++ b/.travis.yml, + , +sudo: false, +# as per http://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/, +++ b/CHANGES.md, +### Version 1.0.4 – December 29th 2014 ([Maven Central](http://search.maven.org/#artifactdetails%7Cio.reactivex%7Crxjava%7C1.0.4%7C)) ###, +, +* [Pull 2156] (https://github.com/ReactiveX/RxJava/pull/2156) Fix the issue that map may swallow fatal exceptions, +* [Pull 1967] (https://github.com/ReactiveX/RxJava/pull/1967) Fix the issue that GroupBy may not call 'unsubscribe', +* [Pull 2052] (https://github.com/ReactiveX/RxJava/pull/2052) OperatorDoOnRequest.ParentSubscriber should be static class, +* [Pull 2237] (https://github.com/ReactiveX/RxJava/pull/2237) Make Publish Operator Release RingBuffer, +* [Pull 2053] (https://github.com/ReactiveX/RxJava/pull/2053) Fixed wrong bounded ReplaySubject use in test, +, +### Version 1.0.3 – December 15th 2014 ([Maven Central](http://search.maven.org/#artifactdetails%7Cio.reactivex%7Crxjava%7C1.0.3%7C)) ###,
[+++ b/src/main/java/io/reactivex/Flowable.java, + public static <T> Flowable<T> mergeArray(int maxConcurrency, int bufferSize, Publisher<? extends T>... sources) {, + public static <T> Flowable<T> mergeArray(Publisher<? extends T>... sources) {, + public static <T> Flowable<T> mergeArrayDelayError(int maxConcurrency, int bufferSize, Publisher<? extends T>... sources) {, + public static <T> Flowable<T> mergeArrayDelayError(Publisher<? extends T>... sources) {, +++ b/src/main/java/io/reactivex/Flowable.java, + public static <T> Flowable<T> mergeArray(int maxConcurrency, int bufferSize, Publisher<? extends T>... sources) {, + public static <T> Flowable<T> mergeArray(Publisher<? extends T>... sources) {, + public static <T> Flowable<T> mergeArrayDelayError(int maxConcurrency, int bufferSize, Publisher<? extends T>... sources) {, + public static <T> Flowable<T> mergeArrayDelayError(Publisher<? extends T>... sources)
[+++ b/.travis.yml, +- oraclejdk8, +, +# force upgrade Java8 as per https://github.com/travis-ci/travis-ci/issues/4042 (fixes compilation issue), +addons:, + apt:, + packages:, + - oracle-java8-installer, + ]
[+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableResumeNext.java, +import java.util.concurrent.atomic.AtomicReference;, +, +import io.reactivex.internal.disposables.DisposableHelper;, +import io.reactivex.internal.functions.ObjectHelper;, + ResumeNextObserver parent = new ResumeNextObserver(observer, errorMapper);, + observer.onSubscribe(parent);, + source.subscribe(parent);, + static final class ResumeNextObserver, + extends AtomicReference<Disposable>, + implements CompletableObserver, Disposable {, +, + private static final long serialVersionUID = 5018523762564524046L;, + final Function<? super Throwable, ? extends CompletableSource> errorMapper;, +, + boolean once;, +, + ResumeNextObserver(CompletableObserver observer, Function<? super Throwable, ? extends CompletableSource> errorMapper) {, + this.errorMapper = errorMapper;, + }, +, +, + @Override, + public void onSubscribe(Disposable d) {, + DisposableHelper.replace(this, d);, + if (once) {, + downstream.onError(e);, + return;, + }, + once =
[+++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.fuseable.*;, +import io.reactivex.internal.operators.flowable.FlowableStrict.StrictSubscriber;, + return RxJavaPlugins.onAssembly(new FlowableConcatMapEagerPublisher(sources, Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE));, + subscribe((SafeSubscriber<? super T>)s);, + * @deprecated 2.0.7, will be removed in 2.1.0; by default, the Publisher interface is always strict, + @Deprecated, + return this;, + if (s instanceof FlowableSubscriber) {, + subscribe((FlowableSubscriber<? super T>)s);, + } else {, + ObjectHelper.requireNonNull(s, "s is null");, + subscribe(new StrictSubscriber<T>(s));, + }, + }, +, + /**, + * Establish a connection between this Flowable and the given FlowableSubscriber and, + * start streaming events based on the demand of the FlowableSubscriber., + * <p>, + *
[+++ b/src/main/java/io/reactivex/Observable.java, + , +, + public static Observable<Long> interval(long delay, TimeUnit unit) {, + return interval(delay, unit, Schedulers.computation());, + }, +, + public static Observable<Long> interval(long delay, TimeUnit unit, Scheduler scheduler) {, + if (delay < 0) {, + delay = 0L;, + }, + Objects.requireNonNull(unit);, + Objects.requireNonNull(scheduler);, + , + return create(new PublisherIntervalOnceSource(delay, unit, scheduler));, + }, +, + public static Observable<Long> interval(long initialDelay, long period, TimeUnit unit) {, + return interval(initialDelay, period, unit, Schedulers.computation());, + }, + , + public static Observable<Long> interval(long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {, + if (initialDelay < 0)
[+++ b/src/main/java/io/reactivex/Completable.java, + public final Completable repeatWhen(Function<? super Flowable<Object>, ? extends Publisher<?>> handler) {, + public final Completable retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) {, +++ b/src/main/java/io/reactivex/Completable.java, + public final Completable repeatWhen(Function<? super Flowable<Object>, ? extends Publisher<?>> handler) {, + public final Completable retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) {, +++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/Completable.java, + public final Completable repeatWhen(Function<? super Flowable<Object>, ? extends Publisher<?>> handler) {, + public final Completable retryWhen(Function<? super Flowable<Throwable>, ? extends Publisher<?>> handler) {, +++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/Single.java, + public final Flowable<T> repeatWhen(Function<? super Flowable<Object>, ? extends Publisher<?>> handler) {, + public final
[+++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/operators/OperationDelay.java, +++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/operators/OperationDelay.java, +++ b/rxjava-core/src/main/java/rx/operators/OperationSwitch.java, + }, +++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/operators/OperationDelay.java, +++ b/rxjava-core/src/main/java/rx/operators/OperationSwitch.java, + }, +++ b/rxjava-core/src/test/java/rx/operators/OperationDelayTest.java,
[+++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Jun 28 11:19:41 CEST 2016, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.14-bin.zip, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Jun 28 11:19:41 CEST 2016, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.14-bin.zip, +++ b/gradlew, +# Attempt to set APP_HOME, +# Resolve links: $0 may be a link, +PRG="$0", +# Need this for relative symlinks., +while [ -h "$PRG" ] ; do, + ls=`ls -ld "$PRG"`, + link=`expr "$ls" : '.*-> \(.*\)$'`, + if expr "$link" : '/.*' > /dev/null; then, + PRG="$link", + else, + PRG=`dirname "$PRG"`"/$link", + fi, +done, +SAVED="`pwd`", +cd "`dirname \"$PRG\"`/" >/dev/null, +APP_HOME="`pwd -P`", +cd "$SAVED" >/dev/null, +# Add default JVM options here. You
[+++ b/gradlew, +JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.7.0_40.jdk/Contents/Home", +, +++ b/gradlew, +JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.7.0_40.jdk/Contents/Home", +, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/gradlew, +JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.7.0_40.jdk/Contents/Home", +, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +RxScala Release Notes, +=====================, +, +This release of the RxScala bindings builds on the previous 0.15 release to make the Rx bindings for Scala, +include all Rx types. In particular this release focuses on the `Subject` and `Scheduler` types., +To makes these notes self-contained, we will start with the `Observer[T]` and `Observable[T]` traits, +that lay at the heart of Rx., +, +Observer, +--------, +, +In this release we have made the `asJavaObserver` property
[+++ b/src/main/java/io/reactivex/flowables/GroupedFlowable.java, +++ b/src/main/java/io/reactivex/flowables/GroupedFlowable.java, +++ b/src/main/java/io/reactivex/observables/GroupedObservable.java, +++ b/src/main/java/io/reactivex/flowables/GroupedFlowable.java, +++ b/src/main/java/io/reactivex/observables/GroupedObservable.java, +++ b/src/main/java/io/reactivex/observers/DisposableMaybeObserver.java, +++ b/src/main/java/io/reactivex/flowables/GroupedFlowable.java, +++ b/src/main/java/io/reactivex/observables/GroupedObservable.java, +++ b/src/main/java/io/reactivex/observers/DisposableMaybeObserver.java, +++ b/src/main/java/io/reactivex/observers/DisposableObserver.java, +++ b/src/main/java/io/reactivex/flowables/GroupedFlowable.java, +++ b/src/main/java/io/reactivex/observables/GroupedObservable.java, +++ b/src/main/java/io/reactivex/observers/DisposableMaybeObserver.java, +++ b/src/main/java/io/reactivex/observers/DisposableObserver.java, +++ b/src/main/java/io/reactivex/observers/DisposableSingleObserver.java, +++ b/src/main/java/io/reactivex/flowables/GroupedFlowable.java, +++ b/src/main/java/io/reactivex/observables/GroupedObservable.java, +++ b/src/main/java/io/reactivex/observers/DisposableMaybeObserver.java, +++ b/src/main/java/io/reactivex/observers/DisposableObserver.java, +++ b/src/main/java/io/reactivex/observers/DisposableSingleObserver.java, +++ b/src/test/java/io/reactivex/internal/functions/ObjectHelperTest.java]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorSwitch;, + * , + * @param <T> the element type, + return sequenceOfSequences.lift(new OperatorSwitch<T>());, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorSwitch;, + * , + * @param <T> the element type, + return sequenceOfSequences.lift(new OperatorSwitch<T>());, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorSwitch;, + * , + * @param <T> the element type, + return sequenceOfSequences.lift(new OperatorSwitch<T>());, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorSwitch.java, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not, + * use this file except in compliance with the License. You may obtain a copy
[+++ b/src/main/java/io/reactivex/Observable.java, + return buffer(boundarySupplier, ArrayList::new);, + , + }, +, + public final <B, U extends Collection<? super T>> Observable<U> buffer(Supplier<? extends Observable<B>> boundarySupplier, Supplier<U> bufferSupplier) {, + Objects.requireNonNull(bufferSupplier);, + return lift(new OperatorBufferBoundarySupplier<>(boundarySupplier, bufferSupplier));, +++ b/src/main/java/io/reactivex/Observable.java, + return buffer(boundarySupplier, ArrayList::new);, + , + }, +, + public final <B, U extends Collection<? super T>> Observable<U> buffer(Supplier<? extends Observable<B>> boundarySupplier, Supplier<U> bufferSupplier) {, + Objects.requireNonNull(bufferSupplier);, + return lift(new OperatorBufferBoundarySupplier<>(boundarySupplier, bufferSupplier));, +++ b/src/main/java/io/reactivex/internal/operators/OperatorBufferBoundarySupplier.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
[+++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java, + * Assert that the TestObserver/TestSubscriber received only items that are in the specified, + * collection as well, irrespective of the order they were received., + * <p>, + * This helps asserting when the order of the values is not guaranteed, i.e., when merging, + * <p>, + * To ensure that only the expected items have been received, no more and no less, in any order,, + * apply {@link #assertValueCount(int)} with {@code expected.size()}., +++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java, + * Assert that the TestObserver/TestSubscriber received only items that are in the specified, + * collection as
[+++ b/src/main/java/io/reactivex/Completable.java, + @Nullable, + @Nullable]
[+++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java, +import rx.Observer;, +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java, +import rx.Observer;, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java, +import rx.Notification;, +import rx.Observable;, +import rx.Observer;, +import rx.Subscription;, + binding.setVariable("o", rx.Observable.class);, +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java, +import rx.Observer;, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java, +import rx.Notification;, +import rx.Observable;, +import rx.Observer;, +import rx.Subscription;, + binding.setVariable("o", rx.Observable.class);, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java, +import rx.Notification;, +import rx.Observable;, +import rx.Observer;, +import rx.Subscription;, +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java, +import rx.Observer;, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java, +import rx.Notification;, +import rx.Observable;, +import rx.Observer;, +import rx.Subscription;, + binding.setVariable("o", rx.Observable.class);, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyAdaptor.java, +import rx.Notification;, +import rx.Observable;, +import rx.Observer;, +import rx.Subscription;, +++ b/rxjava-core/src/main/java/rx/Notification.java, +/**, + * Copyright 2013 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, +
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTake.java, +import io.reactivex.plugins.RxJavaPlugins;, + } else {, + RxJavaPlugins.onError(t);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTake.java, +import io.reactivex.plugins.RxJavaPlugins;, + } else {, + RxJavaPlugins.onError(t);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableLimitTest.java, +, + @Test, + public void errorAfterLimitReached() {, + List<Throwable> errors = TestHelper.trackPluginErrors();, + try {, + Flowable.error(new TestException()), + .limit(0), + .test(), + .assertResult();, +, + TestHelper.assertUndeliverable(errors, 0, TestException.class);, + } finally {, + RxJavaPlugins.reset();, + }, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTake.java, +import io.reactivex.plugins.RxJavaPlugins;, + } else {, + RxJavaPlugins.onError(t);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableLimitTest.java, +, + @Test, + public void errorAfterLimitReached() {, + List<Throwable> errors = TestHelper.trackPluginErrors();, + try {, + Flowable.error(new TestException()), + .limit(0), + .test(), + .assertResult();,
[+++ b/.gitignore, +, +# Scala build, +*.cache, +++ b/.gitignore, +, +# Scala build, +*.cache, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.3-bin.zip, +++ b/.gitignore, +, +# Scala build, +*.cache, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.3-bin.zip, +++ b/language-adaptors/rxjava-clojure/build.gradle, +apply plugin: 'eclipse', +apply plugin: 'idea', +, +++ b/.gitignore, +, +# Scala build, +*.cache, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.3-bin.zip, +++ b/language-adaptors/rxjava-clojure/build.gradle, +apply plugin: 'eclipse', +apply plugin: 'idea', +, +++ b/language-adaptors/rxjava-groovy/build.gradle, +apply plugin: 'eclipse', +apply plugin: 'idea', +, +++ b/.gitignore, +, +# Scala build, +*.cache, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.3-bin.zip, +++ b/language-adaptors/rxjava-clojure/build.gradle, +apply plugin: 'eclipse', +apply plugin: 'idea', +, +++ b/language-adaptors/rxjava-groovy/build.gradle, +apply plugin: 'eclipse', +apply plugin: 'idea', +, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyAdaptor.java, +import rx.util.functions.Func1;, + super(new Func1<Observer<String>,
[+++ b/.gitignore, +++ b/.gitignore, +++ b/gradle.properties, +version=0.17.0-RC4-SNAPSHOT, +++ b/.gitignore, +++ b/gradle.properties, +version=0.17.0-RC4-SNAPSHOT, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-all.zip, +++ b/.gitignore, +++ b/gradle.properties, +version=0.17.0-RC4-SNAPSHOT, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-all.zip, +++ b/language-adaptors/rxjava-clojure/src/main/clojure/rx/lang/clojure/interop.clj, + ~@(if (and (= prefix "rx.functions.Func"), + ~@(if (and (= prefix "rx.functions.Action"), + "Given function f, returns an object that implements rx.functions.Func0-9, + http://netflix.github.io/RxJava/javadoc/rx/functions/Func0.html, + (reify-callable "rx.functions.Func" [0 1 2 3 4 5 6 7 8 9] f)), + "Given function f, returns an object that implements rx.functions.FuncN, + http://netflix.github.io/RxJava/javadoc/rx/functions/FuncN.html, + (reify rx.functions.FuncN, + "Like clojure.core/fn, but returns the appropriate rx.functions.Func*, + "Given function f, returns an object that implements rx.functions.Action0-3, + http://netflix.github.io/RxJava/javadoc/rx/functions/Action0.html, +
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableTimeout.java, +import java.util.concurrent.atomic.*;, +import io.reactivex.internal.functions.ObjectHelper;, +import io.reactivex.internal.operators.observable.ObservableTimeoutTimed.TimeoutSupport;, + Observable<T> source,, + protected void subscribeActual(Observer<? super T> s) {, + TimeoutObserver<T> parent = new TimeoutObserver<T>(s, itemTimeoutIndicator);, + s.onSubscribe(parent);, + parent.startFirstTimeout(firstTimeoutIndicator);, + source.subscribe(parent);, + TimeoutFallbackObserver<T> parent = new TimeoutFallbackObserver<T>(s, itemTimeoutIndicator, other);, + s.onSubscribe(parent);, + parent.startFirstTimeout(firstTimeoutIndicator);, + source.subscribe(parent);, + interface TimeoutSelectorSupport extends TimeoutSupport {, + void onTimeoutError(long idx, Throwable ex);, + }, + static final class TimeoutObserver<T> extends AtomicLong, + implements Observer<T>, Disposable, TimeoutSelectorSupport {, +, + private static final long serialVersionUID = 3764492702657003550L;, +, + final Function<? super T, ?
[+++ b/README.md, +# RxJava: Reactive Extensions for the JVM, +++ b/README.md, +# RxJava: Reactive Extensions for the JVM, +++ b/language-adaptors/rxjava-kotlin/README.md, +Observable.create(OnSubscribeFunc<String> { observer ->, + observer!!.onNext("Hello"), + observer.onCompleted(), +In RxJava [0.17.0](https://github.com/Netflix/RxJava/releases/tag/0.17.0) version a new Subscriber type was included, +, +```kotlin, +Observable.create(object:OnSubscribe<String> {, + override fun call(subscriber: Subscriber<in String>?) {, + subscriber!!.onNext("Hello"), + subscriber.onCompleted(), + }, +})!!.subscribe { result ->, + a!!.received(result), +}, +```, +, +(Due to a [bug in Kotlin's compiler](http://youtrack.jetbrains.com/issue/KT-4753) you can't use SAM with OnSubscribe), +, +{(subscriber: Subscriber<in String>) ->, + subscriber.onNext("Hello"), + subscriber.onCompleted(), +}.asObservable().subscribe { result ->, +++ b/README.md, +# RxJava: Reactive Extensions for the JVM,
[+++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java, +import io.reactivex.internal.functions.Functions;, + return (U)assertError(Functions.equalsWith(error));, + return (U)assertError((Predicate)Functions.isInstanceOf(errorClass));, +++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java, +import io.reactivex.internal.functions.Functions;, + return (U)assertError(Functions.equalsWith(error));, + return (U)assertError((Predicate)Functions.isInstanceOf(errorClass));, +++ b/src/test/java/io/reactivex/observers/TestObserverTest.java, + ts.assertValueSequence(Collections.singletonList(1));, + ts.assertValueSequence(Collections.singletonList(2));, + // expected, + // expected, + // expected, + // expected, + assertEquals(Collections.emptyList(), ts.values());, + assertEquals(Collections.singletonList(1), ts.values());, + assertEquals(Arrays.asList(Collections.singletonList(1), Collections.emptyList(), Collections.emptyList()), ts.getEvents());, + assertEquals(Arrays.asList(Collections.singletonList(1), Collections.emptyList(), Collections.singletonList(Notification.createOnComplete())), ts.getEvents());, + ts.assertValueSequence(Collections.<Integer>emptyList());, + ts.assertValueSequence(Collections.singletonList(1));, +++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java, +import io.reactivex.internal.functions.Functions;, + return (U)assertError(Functions.equalsWith(error));, + return (U)assertError((Predicate)Functions.isInstanceOf(errorClass));, +++ b/src/test/java/io/reactivex/observers/TestObserverTest.java, + ts.assertValueSequence(Collections.singletonList(1));, + ts.assertValueSequence(Collections.singletonList(2));, + // expected, + // expected, + // expected, + // expected, + assertEquals(Collections.emptyList(), ts.values());, + assertEquals(Collections.singletonList(1), ts.values());, + assertEquals(Arrays.asList(Collections.singletonList(1), Collections.emptyList(), Collections.emptyList()), ts.getEvents());, + assertEquals(Arrays.asList(Collections.singletonList(1),
[+++ b/rxjava-core/src/main/java/rx/Observable.java, + return lift(new OperatorAll<T>(predicate));, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return lift(new OperatorAll<T>(predicate));, +++ b/rxjava-core/src/main/java/rx/operators/OperatorAll.java, +package rx.operators;, +, +import rx.Observable;, +import rx.Subscriber;, +import rx.exceptions.OnErrorThrowable;, +import rx.functions.Func1;, +, +import java.util.concurrent.atomic.AtomicBoolean;, +, +import static rx.Observable.Operator;, +, +/**, + * Returns an Observable that emits a Boolean that indicates whether all items emitted by an, + * Observable satisfy a condition., + * <p>, + * <img width="640" src="https://github.com/Netflix/RxJava/wiki/images/rx-operators/all.png">, + */, +public class OperatorAll<T> implements Operator<Boolean,T>{, +, + private final Func1<? super T, Boolean> predicate;, +, + public OperatorAll(Func1<? super T, Boolean> predicate) {, + this.predicate = predicate;, + }, +, + @Override,
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC3-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC3-SNAPSHOT, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java, + *, + * @param <T1>, + * @param <T2>, + * @param <T3>, + * @param <T4>, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC3-SNAPSHOT, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java, + *, + * @param <T1>, + * @param <T2>, + * @param <T3>, + * @param <T4>, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyFunctionWrapper.java, + *, + * @param <T1>, + * @param <T2>, + * @param <T3>, + * @param <T4>, + * @param <T5>, + * @param <T6>, + * @param <T7>, + * @param <T8>, + * @param <T9>, + *
[+++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscription { }, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscription { }, +++ b/rxjava-contrib/rxjava-quasar/README.md, +# rxjava-quasar, +, +Integrates RxJava with [Quasar](https://github.com/puniverse/quasar)., +Includes a fiber (lightweight-thread) based scheduler, and an Observable API for Quasar channels., +, +Main Classes:, +, +- [NewFiberScheduler](https://github.com/Netflix/RxJava/blob/master/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/NewFiberScheduler.java), +- [ChannelObservable](https://github.com/Netflix/RxJava/blob/master/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/ChannelObservable.java), +, +, +# Binaries, +, +Binaries and dependency information for Maven, Ivy, Gradle and others can be found at [http://search.maven.org](http://search.maven.org/#search%7Cga%7C1%7Ccom.netflix.rxjava)., +, +Example for [Maven](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22rxjava-apache-http%22):,
[+++ b/src/main/java/io/reactivex/internal/observers/ResumeSingleObserver.java, +/**, + * Copyright 2016 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language governing
[+++ b/src/main/java/io/reactivex/Completable.java, + * Returns a Completable instance that runs the given Runnable for each subscriber and, + * emits either its exception or simply completes., + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code fromRunnable} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + * @param run the runnable to run for each subscriber, + * @return the new Completable instance, + * @throws NullPointerException if run is null, + */, + @SchedulerSupport(SchedulerSupport.NONE), + public static Completable fromRunnable(final Runnable run) {, + ObjectHelper.requireNonNull(run, "run is null");, + return RxJavaPlugins.onAssembly(new CompletableFromRunnable(run));, + }, +,
[+++ b/gradle.properties, +version=0.14.7-SNAPSHOT]
[+++ b/.travis.yml, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/src/main/java/rx/Observable.java, + * For more information see the <a href="https://github.com/ReactiveX/RxJava/wiki/Observable">RxJava wiki</a>, + * @see <a href="https://github.com/ReactiveX/RxJava/wiki/Creating-Observables#create">RxJava wiki: create</a>, + *
[+++ b/src/main/java/io/reactivex/Flowable.java, + @SuppressWarnings("unchecked"), + public final <R> Flowable<R> compose(FlowableTransformer<? super T, ? extends R> composer) {, + return fromPublisher(((FlowableTransformer<T, R>) composer).apply(this));, +++ b/src/main/java/io/reactivex/Flowable.java, + @SuppressWarnings("unchecked"), + public final <R> Flowable<R> compose(FlowableTransformer<? super T, ? extends R> composer) {, + return fromPublisher(((FlowableTransformer<T, R>) composer).apply(this));, +++ b/src/main/java/io/reactivex/Maybe.java, + @SuppressWarnings("unchecked"), + public final <R> Maybe<R> compose(MaybeTransformer<? super T, ? extends R> transformer) {, + return wrap(((MaybeTransformer<T, R>) transformer).apply(this));, +++ b/src/main/java/io/reactivex/Flowable.java, + @SuppressWarnings("unchecked"), + public final <R> Flowable<R> compose(FlowableTransformer<? super T, ? extends R> composer) {, + return fromPublisher(((FlowableTransformer<T, R>) composer).apply(this));, +++ b/src/main/java/io/reactivex/Maybe.java, + @SuppressWarnings("unchecked"), + public final <R> Maybe<R> compose(MaybeTransformer<? super
[+++ b/src/main/java/io/reactivex/Flowable.java, + BUFFER_SIZE = Math.max(1, Integer.getInteger("rx2.buffer-size", 128));]
[+++ b/rxjava-core/build.gradle, + instruction 'Eclipse-ExtensibleAPI', 'true', +++ b/rxjava-core/build.gradle, + instruction 'Eclipse-ExtensibleAPI', 'true', +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OnSubscribeFromIterable;, +import rx.operators.OnSubscribeRange;, +import rx.operators.OperationAll;, +import rx.operators.OperationAmb;, +import rx.operators.OperationAny;, +import rx.operators.OperationAsObservable;, +import rx.operators.OperationAverage;, +import rx.operators.OperationBuffer;, +import rx.operators.OperationCache;, +import rx.operators.OperationCombineLatest;, +import rx.operators.OperationConcat;, +import rx.operators.OperationDebounce;, +import rx.operators.OperationDefaultIfEmpty;, +import rx.operators.OperationDefer;, +import rx.operators.OperationDelay;, +import rx.operators.OperationDematerialize;, +import rx.operators.OperationDistinct;, +import rx.operators.OperationDistinctUntilChanged;, +import rx.operators.OperationElementAt;, +import rx.operators.OperationFinally;, +import rx.operators.OperationFlatMap;, +import rx.operators.OperationGroupByUntil;, +import rx.operators.OperationGroupJoin;, +import rx.operators.OperationInterval;, +import rx.operators.OperationJoin;, +import rx.operators.OperationJoinPatterns;, +import rx.operators.OperationMaterialize;, +import rx.operators.OperationMergeDelayError;, +import rx.operators.OperationMergeMaxConcurrent;, +import rx.operators.OperationMinMax;, +import rx.operators.OperationMulticast;, +import rx.operators.OperationOnErrorResumeNextViaObservable;, +import rx.operators.OperationOnErrorReturn;, +import rx.operators.OperationOnExceptionResumeNextViaObservable;, +import rx.operators.OperationParallelMerge;, +import rx.operators.OperationReplay;, +import rx.operators.OperationSample;, +import rx.operators.OperationSequenceEqual;, +import rx.operators.OperationSingle;, +import rx.operators.OperationSkip;, +import rx.operators.OperationSkipLast;, +import rx.operators.OperationSkipUntil;, +import
[+++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.schedulers.ImmediateThinScheduler;, + public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources) {, + public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency, int bufferSize) {, + public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<? extends T>> sources, int maxConcurrency) {, + return merge(new FlowableMapNotification<T, Publisher<? extends R>>(this, onNextMapper, onErrorMapper, onCompleteSupplier));, + return merge(new FlowableMapNotification<T, Publisher<? extends R>>(this, onNextMapper, onErrorMapper, onCompleteSupplier), maxConcurrency);, + @BackpressureSupport(BackpressureKind.FULL), + @SchedulerSupport(SchedulerSupport.NONE), + public final Flowable<T> rebatchRequests(int bufferSize) {, + return observeOn(ImmediateThinScheduler.INSTANCE, true, bufferSize);, + }, + , +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.schedulers.ImmediateThinScheduler;, + public static <T> Flowable<T> mergeDelayError(Iterable<? extends Publisher<?
[+++ b/.travis.yml, + - secure: YcLpYfNc/dyDON+oDvnJK5pFNhpPeJHxlAHV8JBt42e51prAl6njqrg1Qlfdp0pvBiskTPQHUxbFy9DOB1Z+43lPj5vlqz6qBgtS3vtBnsrczr+5Xx7NTdVKq6oZGl45VjfNPT7zdM6GQ5ifdzOid6kJIFu34g9JZkCzOY3BWGM=, + - secure: WVmfSeW1UMNdem7+X4cVDjkEkqdeNavYH4udn3bFN1IFaWdliWFp4FYVBVi+p1T/IgkRSqzoW9Bm43DABe1UMFoErFCbfd7B0Ofgb4NZAsxFgokHGVLCe6k5+rQyASseiO7k0itSj3Kq9TrDueKPhv+g+IG0w1A8yZTnXdhXHvY=, + - secure: Xt8E09nmSr+5r7ly95hG/EiBitZbhFGPRGp8oqPkNn1A2fzG9+hnvlNLgQhVPsISZGzJwkWa3LGBxAVGmuysVOz7eCwkoqlDZaaSLYAPfWXqkr+cmYGPkErgHSp+n/hnQG4TylX0YxzqX8flr6db21zWyNduiyHmo+xFydI5LeM=, + - secure: RmpIsmYa5BdLLWR6DILjhEE/dx2q3O0NIkvnMx5G1cyRCNCrOf1B7fYFHnsTDwpvRA+6H6dZinmeyf6D3G+czOG5q/TW2jcu5nh+YOLhBb6jPIqRDfq/WHAa5Lkdssxs5g9RdWlEDVFMoE62lGc4cnfJz5F5puH29dy2SvXxIQw=, +++ b/.travis.yml, + - secure: YcLpYfNc/dyDON+oDvnJK5pFNhpPeJHxlAHV8JBt42e51prAl6njqrg1Qlfdp0pvBiskTPQHUxbFy9DOB1Z+43lPj5vlqz6qBgtS3vtBnsrczr+5Xx7NTdVKq6oZGl45VjfNPT7zdM6GQ5ifdzOid6kJIFu34g9JZkCzOY3BWGM=, + - secure: WVmfSeW1UMNdem7+X4cVDjkEkqdeNavYH4udn3bFN1IFaWdliWFp4FYVBVi+p1T/IgkRSqzoW9Bm43DABe1UMFoErFCbfd7B0Ofgb4NZAsxFgokHGVLCe6k5+rQyASseiO7k0itSj3Kq9TrDueKPhv+g+IG0w1A8yZTnXdhXHvY=, + - secure: Xt8E09nmSr+5r7ly95hG/EiBitZbhFGPRGp8oqPkNn1A2fzG9+hnvlNLgQhVPsISZGzJwkWa3LGBxAVGmuysVOz7eCwkoqlDZaaSLYAPfWXqkr+cmYGPkErgHSp+n/hnQG4TylX0YxzqX8flr6db21zWyNduiyHmo+xFydI5LeM=, + - secure: RmpIsmYa5BdLLWR6DILjhEE/dx2q3O0NIkvnMx5G1cyRCNCrOf1B7fYFHnsTDwpvRA+6H6dZinmeyf6D3G+czOG5q/TW2jcu5nh+YOLhBb6jPIqRDfq/WHAa5Lkdssxs5g9RdWlEDVFMoE62lGc4cnfJz5F5puH29dy2SvXxIQw=, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:2.+' }]
[+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableCollect.java, +public final class ObservableCollect<T, U> extends ObservableWithUpstream<T, U> {, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableCollect.java, +public final class ObservableCollect<T, U> extends ObservableWithUpstream<T, U> {, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMap.java, +public final class ObservableConcatMap<T, U> extends ObservableWithUpstream<T, U> {, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableCollect.java, +public final class ObservableCollect<T, U> extends ObservableWithUpstream<T, U> {, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMap.java, +public final class ObservableConcatMap<T, U> extends ObservableWithUpstream<T, U> {, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableCount.java, +public final class ObservableCount<T> extends ObservableWithUpstream<T, Long> {, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableCollect.java, +public final class ObservableCollect<T, U> extends ObservableWithUpstream<T, U> {, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableConcatMap.java, +public final class ObservableConcatMap<T, U> extends ObservableWithUpstream<T, U> {, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableCount.java, +public final class ObservableCount<T> extends ObservableWithUpstream<T, Long> {, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDebounce.java,
[+++ b/src/test/java/io/reactivex/maybe/MaybeTest.java, +, + @Test, + public void onErrorResumeNextEmpty() {, + Maybe.empty(), + .onErrorResumeNext(Maybe.just(1)), + .test(), + .assertNoValues(), + .assertNoErrors(), + .assertComplete();, + }, +, + @Test, + public void onErrorResumeNextValue() {, + Maybe.just(1), + .onErrorResumeNext(Maybe.<Integer>empty()), + .test(), + .assertNoErrors(), + .assertValue(1);, + }, +, + @Test, + public void onErrorResumeNextError() {, + Maybe.error(new RuntimeException("some error")), + .onErrorResumeNext(Maybe.empty()), + .test(), + .assertNoValues(), + .assertNoErrors(), + .assertComplete();, + }, +, + @Test, + public void valueConcatWithValue() {, + Maybe.just(1), + .concatWith(Maybe.just(2)), + .test(), + .assertNoErrors(), + .assertComplete(), + .assertValues(1, 2);, + }, +, + @Test, + public void errorConcatWithValue() {,
[+++ b/gradle.properties, +version=0.5.6-SNAPSHOT, +++ b/gradle.properties, +version=0.5.6-SNAPSHOT, +++ /dev/null, +++ b/gradle.properties, +version=0.5.6-SNAPSHOT, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, + private Observable(Func1<Observer<T>, Subscription> onSubscribe, boolean isTrusted) {, +++ b/gradle.properties, +version=0.5.6-SNAPSHOT, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, + private Observable(Func1<Observer<T>, Subscription> onSubscribe, boolean isTrusted) {, +++ /dev/null, +++ b/gradle.properties, +version=0.5.6-SNAPSHOT, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, + private Observable(Func1<Observer<T>, Subscription> onSubscribe, boolean isTrusted) {, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/util/functions/Functions.java]
[+++ b/src/main/java/io/reactivex/subscribers/SerializedSubscriber.java, + done = true;, +++ b/src/main/java/io/reactivex/subscribers/SerializedSubscriber.java, + done = true;, +++ b/src/test/java/io/reactivex/internal/operators/OperatorSerializeTest.java, +package io.reactivex.internal.operators;, +, +import static org.junit.Assert.*;, +import static org.mockito.Matchers.any;, +import static org.mockito.Mockito.*;, +, +import java.util.concurrent.*;, +import java.util.concurrent.atomic.AtomicInteger;, +, +import org.junit.*;, +import org.reactivestreams.*;, +, +import io.reactivex.*;, +import io.reactivex.internal.subscriptions.EmptySubscription;, +, +public class OperatorSerializeTest {, +, + Subscriber<String> observer;, +, + @Before, + public void before() {, + observer = TestHelper.mockSubscriber();, + }, +, + @Test, + public void testSingleThreadedBasic() {, + TestSingleThreadedObservable onSubscribe = new TestSingleThreadedObservable("one", "two", "three");, + Observable<String> w = Observable.create(onSubscribe);, +, + w.serialize().subscribe(observer);, + onSubscribe.waitToFinish();, +, + verify(observer, times(1)).onNext("one");, + verify(observer, times(1)).onNext("two");, + verify(observer,
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC3-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC3-SNAPSHOT, +++ b/rxjava-core/src/test/java/rx/internal/util/RxRingBufferWithoutUnsafeTest.java, + @Test, + final CountDownLatch emitLatch = new CountDownLatch(255);, + final CountDownLatch drainLatch = new CountDownLatch(2);, + // System.out.println("request[" + c.incrementAndGet() + "]: " + n + " Thread: " + Thread.currentThread());, + if (emitLatch.getCount() == 0) {, + emit.incrementAndGet();, + emitLatch.countDown();, + Action0 drainer = new Action0() {, + if (emitLatch.getCount() == 0) {, + // this works with SynchronizedQueue, if changing to a non-blocking Queue, + // then this will likely need to change like the SpmcTest version, + drainLatch.countDown();, + return;, +
[+++ b/src/main/java/io/reactivex/internal/operators/mixed/ObservableConcatMapCompletable.java, +import java.util.concurrent.Callable;, +import io.reactivex.exceptions.Exceptions;, +import io.reactivex.internal.disposables.*;, +import io.reactivex.internal.fuseable.*;, + if (!tryScalarSource(source, mapper, s)) {, + }, + SimpleQueue<T> queue;, + if (s instanceof QueueDisposable) {, + @SuppressWarnings("unchecked"), + QueueDisposable<T> qd = (QueueDisposable<T>) s;, +, + int m = qd.requestFusion(QueueDisposable.ANY);, + if (m == QueueDisposable.SYNC) {, + queue = qd;, + done = true;, + downstream.onSubscribe(this);, + drain();, + return;, + }, + if (m == QueueDisposable.ASYNC) {, + queue = qd;, + downstream.onSubscribe(this);, + return;, + }, + }, + queue = new SpscLinkedArrayQueue<T>(prefetch);, + if (t != null) {, + }, + AtomicThrowable errors = this.errors;,
[+++ b/src/main/java/io/reactivex/Observable.java, + return new BlockingObservableLatest<T>(this);, + return new BlockingObservableMostRecent<T>(this, initialValue);, + return new BlockingObservableNext<T>(this);, +++ b/src/main/java/io/reactivex/Observable.java, + return new BlockingObservableLatest<T>(this);, + return new BlockingObservableMostRecent<T>(this, initialValue);, + return new BlockingObservableNext<T>(this);, +++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableIterator.java, +implements io.reactivex.Observer<T>, Iterator<T>, Disposable {, + try {, + while (!done && queue.isEmpty()) {, + } catch (InterruptedException ex) {, + DisposableHelper.dispose(this);, + signalConsumer();, + throw ExceptionHelper.wrapOrThrow(ex);, + }, + return queue.poll();, + queue.offer(t);, +++ b/src/main/java/io/reactivex/Observable.java, + return new BlockingObservableLatest<T>(this);, + return new BlockingObservableMostRecent<T>(this, initialValue);, + return new BlockingObservableNext<T>(this);, +++ b/src/main/java/io/reactivex/internal/operators/observable/BlockingObservableIterator.java, +implements io.reactivex.Observer<T>, Iterator<T>, Disposable {, + try {, + while (!done && queue.isEmpty()) {, + }
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/README.md, +## Documentation, +, +You can build the documentation as follows: In the RxJava root directory, run, +, + ./gradlew :language-adaptors:rxjava-scala:scaladoc, +, +Then navigate to, +, + RxJava/language-adaptors/rxjava-scala/build/docs/scaladoc/index.html, +, +, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/README.md, +## Documentation, +, +You can build the documentation as follows: In the RxJava root directory, run, +, + ./gradlew :language-adaptors:rxjava-scala:scaladoc, +, +Then navigate to, +, + RxJava/language-adaptors/rxjava-scala/build/docs/scaladoc/index.html, +, +, +++ b/language-adaptors/rxjava-scala/build.gradle, + main { , + test { , + scala {
[+++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/TestSchedulerExample.scala, +import scala.concurrent.duration._, +import scala.language.postfixOps, +import rx.lang.scala.{ Observable, Observer }, +import rx.lang.scala.concurrency.TestScheduler, + import org.mockito.Matchers._, + import org.mockito.Mockito._, +, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/TestSchedulerExample.scala, +import scala.concurrent.duration._, +import scala.language.postfixOps, +import rx.lang.scala.{ Observable, Observer }, +import rx.lang.scala.concurrency.TestScheduler, + import org.mockito.Matchers._, + import org.mockito.Mockito._, +, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, + implicit def toJavaNotification[T](s: Notification[T]): rx.Notification[_ <:
[+++ b/.travis.yml, + , +sudo: false, +# as per http://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/, +++ b/.travis.yml, + , +sudo: false, +# as per http://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/, +++ b/src/main/java/rx/internal/operators/OperatorMap.java, +++ b/.travis.yml, + , +sudo: false, +# as per http://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/, +++ b/src/main/java/rx/internal/operators/OperatorMap.java, +++ b/src/test/java/rx/internal/operators/OperatorMapTest.java]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * <dt><b>Error handling:</b></dt>, + * <dd>If any of the source {@code Publisher}s signal a {@code Throwable} via {@code onError}, the resulting, + * {@code Flowable} terminates with that {@code Throwable} and all other source {@code Publisher}s are cancelled., + * If more than one {@code Publisher} signals an error, the resulting {@code Flowable} may terminate with the, + * first one's error or, depending on the concurrency of the sources, may terminate with a, + * {@code CompositeException} containing two or more of the various error signals., + * {@code Throwable}s that didn't make into the
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationDefaultIfEmpty;, +import rx.operators.OperatorDefer;, + return create(new OperatorDefer<T>(observableFactory));, + return create(OperationDefaultIfEmpty.defaultIfEmpty(this, defaultValue));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationDefaultIfEmpty;, +import rx.operators.OperatorDefer;, + return create(new OperatorDefer<T>(observableFactory));, + return create(OperationDefaultIfEmpty.defaultIfEmpty(this, defaultValue));, +++ b/rxjava-core/src/main/java/rx/operators/OperationDefaultIfEmpty.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, +
[+++ b/src/main/java/io/reactivex/Flowable.java, + Flowable<Notification<T2>> m = (Flowable<Notification<T2>>)this;, + public final Flowable<T> doOnEach(final Consumer<? super Notification<T>> onNotification) {, + public final Flowable<Notification<T>> materialize() {, +++ b/src/main/java/io/reactivex/Flowable.java, + Flowable<Notification<T2>> m = (Flowable<Notification<T2>>)this;, + public final Flowable<T> doOnEach(final Consumer<? super Notification<T>> onNotification) {, + public final Flowable<Notification<T>> materialize() {, +++ b/src/main/java/io/reactivex/Notification.java, +import io.reactivex.internal.util.NotificationLite;, + * Represents the reactive signal types: onNext, onError and onComplete and, + * holds their parameter values (a value, a Throwable, nothing)., + * @param <T> the value type, +public final class Notification<T> {, + final Object value;, + , + /** Not meant to be implemented externally.
[+++ b/src/main/java/io/reactivex/Observable.java, + public final Observable<T> take(long n) {, + public final <U> Observable<T> takeUntil(Publisher<U> other) {, + Objects.requireNonNull(other);, + public final Observable<T> takeUntil(Predicate<? super T> predicate) {, + Objects.requireNonNull(predicate);, + public final Observable<T> takeLast(int n) {, + public final Observable<T> ignoreElements() {, + , + public final Observable<T> skip(long n) {, + if (n < 0) {, + throw new IllegalArgumentException("n >= 0 required but it was " + n);, + } else, + if (n == 0) {, + return this;, + }, + return lift(new OperatorSkip<>(n));, + }, + , + public final Observable<T> skipLast(int n)
[+++ b/build.gradle, + // everything defaults to 1.6, + sourceCompatibility = JavaVersion.VERSION_1_6, + targetCompatibility = JavaVersion.VERSION_1_6, +, +++ b/build.gradle, + // everything defaults to 1.6, + sourceCompatibility = JavaVersion.VERSION_1_6, + targetCompatibility = JavaVersion.VERSION_1_6, +, +++ b/gradle.properties, +version=0.19.0-SNAPSHOT, +++ b/build.gradle, + // everything defaults to 1.6, + sourceCompatibility = JavaVersion.VERSION_1_6, + targetCompatibility = JavaVersion.VERSION_1_6, +, +++ b/gradle.properties, +version=0.19.0-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorGroupBy.java, + public Subscriber<? super T> call(final Subscriber<? super GroupedObservable<K, T>> child) {, + return new GroupBySubscriber<K, T>(keySelector, child);, + final Subscriber<? super GroupedObservable<K, T>> child;, + public GroupBySubscriber(Func1<? super T, ? extends K> keySelector, Subscriber<? super GroupedObservable<K, T>> child) {,
[+++ b/gradle.properties, +version=0.14.11-SNAPSHOT, +++ b/gradle.properties, +version=0.14.11-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not, + * use this file except in compliance with the License. You may obtain a copy of, + * the License at, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, + * License for the specific language governing permissions and limitations, + * under the License., + * This interface provides overloaded methods for subscribing as well
[+++ b/language-adaptors/rxjava-clojure/build.gradle, +++ b/language-adaptors/rxjava-clojure/build.gradle, +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java, +/**, + * Copyright 2013 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + *
[+++ b/src/main/java/io/reactivex/disposables/Disposables.java, + * Construct a Disposable by wrapping a Future that is, + * cancelled exactly once when the Disposable is disposed., + * @param future the Future to wrap]
[+++ b/src/main/java/io/reactivex/Notification.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the
[+++ b/build.gradle, + perfCompile.extendsFrom compile, + perfRuntime.extendsFrom runtime, + //include /src/examples folder, + //include /src/perf folder, + // perf //-> Not working so commented out, + //include 'examples' in build task, + //include 'perf' in build task, + // dependsOn(perfClasses) //-> Not working so commented out, +++ b/build.gradle, + perfCompile.extendsFrom compile, + perfRuntime.extendsFrom runtime, + //include /src/examples folder, + //include /src/perf folder, + // perf //-> Not working so commented out, + //include 'examples' in build task, + //include 'perf' in build task, + // dependsOn(perfClasses) //-> Not working so commented out, +++ b/rxjava-core/src/perf/java/rx/performance/PerformanceTest.java, +/**, + * Copyright 2014
[+++ b/gradle.properties, +version=0.17.6]
[+++ b/src/main/java/io/reactivex/Completable.java, + * <p>, + * <img width="640" height="686" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.subscribeOn.png" alt="">, + * <p>, + * <img width="640" height="585" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toFlowable.png" alt="">, + * <p>, + * <img width="640" height="585" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toMaybe.png" alt="">, + * <p>, + * <img width="640" height="583" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toSingle.png" alt="">, + * <p>, + * <img width="640" height="583" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.toSingleDefault.png" alt="">, + * <p>, + * <img width="640" height="716" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.unsubscribeOn.png" alt="">]
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/src/main/java/rx/Observable.java, + * @Beta, + * @Beta, + return Subscriptions.empty();, + return Subscriptions.empty();, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET
[+++ b/gradle.properties, +version=0.13.3-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * @return the value, + protected static int verifyPositive(int value, String paramName) {, + return value;, + * @return the value, + protected static long verifyPositive(long value, String paramName) {, + return value;, +++ b/src/main/java/io/reactivex/Flowable.java, + * @return the value, + protected static int verifyPositive(int value, String paramName) {, + return value;, + * @return the value, + protected static long verifyPositive(long value, String paramName) {, + return value;, +++ b/src/main/java/io/reactivex/Observable.java, + * @return value, + protected static int verifyPositive(int value, String paramName) {, + return value;, + * @return value, + protected static long verifyPositive(long
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableTimeoutTimed.java, +++ b/src/main/java/io/reactivex/processors/ReplayProcessor.java, +import io.reactivex.annotations.CheckReturnValue;, + b.next(t);, + b.error(t);, + b.complete();, + ReplayBuffer<T> b = buffer;, + if (b.isDone()) {, + return b.getError();, + ReplayBuffer<T> b = buffer;, + return b.isDone() && b.getError() == null;, + ReplayBuffer<T> b = buffer;, + return b.isDone() && b.getError() != null;, + void next(T value);, + void error(Throwable ex);, +, + void complete();, + boolean isDone();, +, + Throwable getError();, + long emitted;, +, + final List<T> buffer;, + Throwable error;, + this.buffer = new ArrayList<T>(ObjectHelper.verifyPositive(capacityHint, "capacityHint"));, + public void next(T value) {, + public void error(Throwable ex) {, +
[+++ b/src/main/java/io/reactivex/internal/util/VolatileSizeArrayList.java, +/**, + * Copyright (c) 2016-present, RxJava Contributors., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language
[+++ b/.travis.yml, + , +sudo: false, +# as per http://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/, +++ b/.travis.yml, + , +sudo: false, +# as per http://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/, +++ b/CHANGES.md, +### Version 1.0.4 – December 29th 2014 ([Maven Central](http://search.maven.org/#artifactdetails%7Cio.reactivex%7Crxjava%7C1.0.4%7C)) ###, +, +* [Pull 2156] (https://github.com/ReactiveX/RxJava/pull/2156) Fix the issue that map may swallow fatal exceptions, +* [Pull 1967] (https://github.com/ReactiveX/RxJava/pull/1967) Fix the issue that GroupBy may not call 'unsubscribe', +* [Pull 2052] (https://github.com/ReactiveX/RxJava/pull/2052) OperatorDoOnRequest.ParentSubscriber should be static class, +* [Pull 2237] (https://github.com/ReactiveX/RxJava/pull/2237) Make Publish Operator Release RingBuffer, +* [Pull 2053] (https://github.com/ReactiveX/RxJava/pull/2053) Fixed wrong bounded ReplaySubject use in test, +, +### Version 1.0.3 – December 15th 2014 ([Maven Central](http://search.maven.org/#artifactdetails%7Cio.reactivex%7Crxjava%7C1.0.3%7C)) ###,
[+++ b/src/main/java/io/reactivex/Flowable.java, + * <img width="408" height="177" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.emitlast.png" alt="">, + * <img width="408" height="177" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.s.emitlast.png" alt="">, + * <img width="437" height="198" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.o.nolast.png" alt="">, + * <img width="437" height="198" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.o.emitlast.png" alt="">, + * <img width="410" height="164" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchifempty.png" alt="">, +++ b/src/main/java/io/reactivex/Flowable.java, + * <img width="408" height="177" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.emitlast.png" alt="">, + * <img width="408" height="177" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.s.emitlast.png" alt="">, + * <img width="437" height="198" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.o.nolast.png" alt="">, + * <img width="437" height="198" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.o.emitlast.png" alt="">, + * <img width="410" height="164" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchifempty.png" alt="">, +++ b/src/main/java/io/reactivex/Maybe.java, + * <img width="403" height="233" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/maybe.png" alt="">, + * <p>, + * <p>, + * <img width="441" height="307" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchifempty.m.png" alt="">, +++ b/src/main/java/io/reactivex/Flowable.java, +
[+++ b/src/main/java/io/reactivex/Completable.java, + * Subscribes to this Completable only once, when the first CompletableObserver, + * subscribes to the result Completable, caches its terminal event, + * and relays/replays it to observers., + * <p>, + * Note that this operator doesn't allow disposing the connection, + * of the upstream source., + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code cache} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + * @return the new Completable instance, + * @since 2.0.4 - experimental, + */, + @CheckReturnValue, + @SchedulerSupport(SchedulerSupport.NONE), + @Experimental, + public final
[+++ b/src/test/java/io/reactivex/XFlatMapTest.java, + static final int SLEEP_AFTER_CANCEL = 500;]
[+++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, + <activity, + android:name=".ListFragmentActivity">, +, + <intent-filter>, + <category android:name="android.intent.category.LAUNCHER"/>, + <category android:name="android.intent.category.DEFAULT"/>, + <action android:name="android.intent.action.MAIN"/>, + </intent-filter>, + </activity>, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, + <activity, + android:name=".ListFragmentActivity">, +, + <intent-filter>, + <category android:name="android.intent.category.LAUNCHER"/>, + <category android:name="android.intent.category.DEFAULT"/>, + <action android:name="android.intent.action.MAIN"/>, + </intent-filter>, + </activity>, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/ListFragmentActivity.java, +package com.netflix.rxjava.android.samples;, +, +import android.app.Activity;, +import android.app.ListFragment;, +import android.os.Bundle;, +import android.widget.ArrayAdapter;, +, +import rx.Observable;, +import rx.Subscriber;, +, +import static rx.android.schedulers.AndroidSchedulers.mainThread;, +, +/**, + * Problem:, + * You have an asynchronous sequence that emits items to be displayed in a list. You want the data, + * to survive rotation changes., + *
[+++ b/src/main/java/io/reactivex/Maybe.java, + * Returns a {@link Maybe} based on applying a specified function to the item emitted by the, + * source {@link Maybe}, where that function returns a {@link Single}., + * When this Maybe just completes the resulting {@code Maybe} completes as well., + * <p>, + * <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMapSingle.png" alt="">, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code flatMapSingleElement} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + *, + * @param <R> the result value type, + * @param mapper, + * a function that, when
[+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableCreate.java, +, + @Override, + public String toString() {, + return String.format("%s{%s}", getClass().getSimpleName(), super.toString());, + }, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableCreate.java, +, + @Override, + public String toString() {, + return String.format("%s{%s}", getClass().getSimpleName(), super.toString());, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCreate.java, +, + @Override, + public String toString() {, + return emitter.toString();, + }, +, + @Override, + public String toString() {, + return String.format("%s{%s}", getClass().getSimpleName(), super.toString());, + }, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableCreate.java, +, + @Override, + public String toString() {, + return String.format("%s{%s}", getClass().getSimpleName(), super.toString());, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCreate.java, +, + @Override, + public String toString() {, + return emitter.toString();, + }, +, + @Override,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorUsing;, + public final static <T, Resource extends Subscription> Observable<T> using(Func0<Resource> resourceFactory, Func1<Resource, ? extends Observable<? extends T>> observableFactory) {, + return create(new OperatorUsing<T, Resource>(resourceFactory, observableFactory));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorUsing;, + public final static <T, Resource extends Subscription> Observable<T> using(Func0<Resource> resourceFactory, Func1<Resource, ? extends Observable<? extends T>> observableFactory) {, + return create(new OperatorUsing<T, Resource>(resourceFactory, observableFactory));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorUsing;, + public final static <T, Resource extends Subscription> Observable<T> using(Func0<Resource> resourceFactory, Func1<Resource, ? extends Observable<? extends T>> observableFactory) {, + return create(new OperatorUsing<T, Resource>(resourceFactory, observableFactory));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorUsing.java, +/**, + * Copyright 2014 Netflix,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorJoin;, + return create(new OperatorJoin<T, TRight, TLeftDuration, TRightDuration, R>(this, right, leftDurationSelector, rightDurationSelector, resultSelector));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorJoin;, + return create(new OperatorJoin<T, TRight, TLeftDuration, TRightDuration, R>(this, right, leftDurationSelector, rightDurationSelector, resultSelector));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorJoin;, + return create(new OperatorJoin<T, TRight, TLeftDuration, TRightDuration, R>(this, right, leftDurationSelector, rightDurationSelector, resultSelector));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorJoin.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License
[+++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, +import rx.Operator;, +import rx.util.functions.Action1;, +public class GroovyCreateWrapper<T> implements Action1<Operator<? super T>> {, + public void call(Operator<? super T> op) {, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, +import rx.Operator;, +import rx.util.functions.Action1;, +public class GroovyCreateWrapper<T> implements Action1<Operator<? super T>> {, + public void call(Operator<? super T> op) {, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, + * Correlates the items emitted by two Observables based on overlapping durations., + * <p>, + * <img width="640" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/join_.png">, + *, + * @param inner, + * the second Observable to join items from, + * @param leftDurationSelector, + * a function to select a duration for each item emitted by
[+++ b/src/main/java/io/reactivex/Single.java, + * * <p>Note that the {@code doAfterTerminate} action is shared between subscriptions and as such]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublishMulticast.java, + final int limit;, +, + int consumed;, +, + this.limit = prefetch - (prefetch >> 2); // request after 75% consumption, + int upstreamConsumed = consumed;, + int localLimit = limit;, + boolean canRequest = sourceMode != QueueSubscription.SYNC;, + , +, + if (canRequest && ++upstreamConsumed == localLimit) {, + upstreamConsumed = 0;, + s.get().request(localLimit);, + }, + consumed = upstreamConsumed;, + if (getAndSet(Long.MIN_VALUE) != Long.MIN_VALUE) {, + parent.drain(); // unblock the others, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublishMulticast.java, + final int limit;, +, + int consumed;, +, + this.limit = prefetch - (prefetch >> 2); // request
[+++ b/src/main/java/io/reactivex/Observable.java, + , + public final Observable<T> takeWhile(Predicate<? super T> predicate) {, + Objects.requireNonNull(predicate);, + return lift(new OperatorTakeWhile<>(predicate));, + }, +++ b/src/main/java/io/reactivex/Observable.java, + , + public final Observable<T> takeWhile(Predicate<? super T> predicate) {, + Objects.requireNonNull(predicate);, + return lift(new OperatorTakeWhile<>(predicate));, + }, +++ b/src/main/java/io/reactivex/internal/subscribers/ConditionalSubscriber.java]
[+++ b/src/main/java/io/reactivex/Observable.java, + * <img width="640" height="365" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toList.o.c.png" alt="">, + * <p>, + * Marble diagrams for the various backpressure strategies are as follows:, + * <ul>, + * <li>{@link BackpressureStrategy#BUFFER}, + * <p>, + * <img width="640" height="274" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.buffer.png" alt="">, + * </li>, + * <li>{@link BackpressureStrategy#DROP}, + * <p>, + * <img width="640" height="389" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.drop.png" alt="">, + * </li>, + * <li>{@link BackpressureStrategy#LATEST}, + * <p>, + * <img width="640" height="296" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.latest.png" alt="">, + * </li>, + * <li>{@link BackpressureStrategy#ERROR}, + * <p>, + * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/toFlowable.o.error.png" alt="">, + * </li>, + * <li>{@link BackpressureStrategy#MISSING},
[+++ b/language-adaptors/rxjava-clojure/src/main/java/org/rx/lang/clojure/ClojureAdaptor.java, +, +import rx.observables.Observer;, +import rx.util.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-clojure/src/main/java/org/rx/lang/clojure/ClojureAdaptor.java, +, +import rx.observables.Observer;, +import rx.util.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-groovy/src/main/java/org/rx/lang/groovy/GroovyAdaptor.java, +, +import rx.observables.Notification;, +import rx.observables.Observable;, +import rx.observables.Observer;, +import rx.observables.Subscription;, +import rx.util.FunctionLanguageAdaptor;, + binding.setVariable("o", rx.observables.Observable.class);, +++ b/language-adaptors/rxjava-clojure/src/main/java/org/rx/lang/clojure/ClojureAdaptor.java, +, +import rx.observables.Observer;, +import rx.util.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-groovy/src/main/java/org/rx/lang/groovy/GroovyAdaptor.java, +, +import rx.observables.Notification;, +import rx.observables.Observable;, +import rx.observables.Observer;, +import rx.observables.Subscription;, +import rx.util.FunctionLanguageAdaptor;, + binding.setVariable("o", rx.observables.Observable.class);, +++ b/language-adaptors/rxjava-jruby/src/main/java/org/rx/lang/jruby/JRubyAdaptor.java, +, +import rx.observables.Notification;, +import rx.observables.Observable;, +import rx.observables.Observer;, +import rx.observables.Subscription;, +import rx.util.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-clojure/src/main/java/org/rx/lang/clojure/ClojureAdaptor.java, +, +import rx.observables.Observer;, +import rx.util.FunctionLanguageAdaptor;, +++ b/language-adaptors/rxjava-groovy/src/main/java/org/rx/lang/groovy/GroovyAdaptor.java, +, +import rx.observables.Notification;, +import rx.observables.Observable;, +import rx.observables.Observer;, +import rx.observables.Subscription;, +import rx.util.FunctionLanguageAdaptor;, + binding.setVariable("o", rx.observables.Observable.class);, +++ b/language-adaptors/rxjava-jruby/src/main/java/org/rx/lang/jruby/JRubyAdaptor.java, +, +import rx.observables.Notification;, +import rx.observables.Observable;, +import rx.observables.Observer;, +import
[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +, + @Test def liftExample1(): Unit = {, + // Add "No. " in front of each item, + val o = List(1, 2, 3).toObservable.lift {, + subscriber: Subscriber[String] =>, + Subscriber[Int](, + subscriber,, + (v: Int) => subscriber.onNext("No. " + v),, + e => subscriber.onError(e),, + () => subscriber.onCompleted, + ), + }.toBlockingObservable.toList, + println(o), + }, +, + @Test def liftExample2(): Unit = {, + // Split the input Strings with " ", + val splitStringsWithSpace = (subscriber: Subscriber[String]) => {, + Subscriber[String](, + subscriber,, + (v: String) => v.split(" ").foreach(subscriber.onNext(_)),, + e => subscriber.onError(e),,
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/README.md, +, +## Documentation, +, +The API documentation can be found [here](http://rxscala.github.io/scaladoc/index.html#rx.lang.scala.Observable)., +, +You can build the API documentation yourself by running `./gradlew scaladoc` in the RxJava root directory., +, +Then navigate to `RxJava/language-adaptors/rxjava-scala/build/docs/scaladoc/index.html` to display it., +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/README.md, +, +## Documentation, +, +The API documentation can be found [here](http://rxscala.github.io/scaladoc/index.html#rx.lang.scala.Observable)., +, +You can build the API documentation yourself by running `./gradlew scaladoc` in the RxJava root directory., +, +Then navigate to `RxJava/language-adaptors/rxjava-scala/build/docs/scaladoc/index.html` to display
[+++ b/src/main/java/io/reactivex/parallel/ParallelFlowable.java, + * Use {@code runOn()} to introduce where each 'rail' should run on thread-vise.]
[+++ b/src/main/java/io/reactivex/Observable.java, + return RxJavaPlugins.onAssembly(new ObservableFlattenIterable<T, U>(this, mapper));, + return RxJavaPlugins.onAssembly(new ObservableFlattenIterable<T, U>(this, mapper));, +++ b/src/main/java/io/reactivex/Observable.java, + return RxJavaPlugins.onAssembly(new ObservableFlattenIterable<T, U>(this, mapper));, + return RxJavaPlugins.onAssembly(new ObservableFlattenIterable<T, U>(this, mapper));, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlattenIterable.java, +/**, + * Copyright 2016 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, +
[+++ b/src/main/java/io/reactivex/Completable.java, + TestObserver<Void> to = new TestObserver<Void>();, + subscribe(to);, + return to;, + TestObserver<Void> to = new TestObserver<Void>();, + to.cancel();, + subscribe(to);, + return to;, +++ b/src/main/java/io/reactivex/Completable.java, + TestObserver<Void> to = new TestObserver<Void>();, + subscribe(to);, + return to;, + TestObserver<Void> to = new TestObserver<Void>();, + to.cancel();, + subscribe(to);, + return to;, +++ b/src/main/java/io/reactivex/Maybe.java, + TestObserver<T> to = new TestObserver<T>();, + subscribe(to);, + return to;, + TestObserver<T> to = new TestObserver<T>();, + to.cancel();, + subscribe(to);, + return to;, +++ b/src/main/java/io/reactivex/Completable.java, + TestObserver<Void> to = new TestObserver<Void>();, + subscribe(to);, + return to;, + TestObserver<Void> to = new TestObserver<Void>();, + to.cancel();,
[+++ b/.gitignore, +++ b/.gitignore, +++ b/build.gradle, + maxHeapSize = "512m", +// args '-h' // help output, + args '-f' // fork, + args '1' , + args '-tu' // time unit, + args 'ns', + args '-bm' // benchmark mode, + args 'avgt', + args '-wi' // warmup iterations, + args '5' , + args '-i' // test iterations, + args '5' , + args '-r' // time per execution in seconds, + args '1', +// args '-prof' // profilers, +// args 'HS_GC' // HotSpot (tm) memory manager (GC) profiling via implementation-specific MBeans, +// args 'HS_RT' // HotSpot (tm)
[+++ b/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/Async.java, +import rx.Observer;, +import rx.Subscriber;, +import rx.Subscription;, +import rx.subjects.PublishSubject;, +import rx.subjects.Subject;, +import rx.subscriptions.SerialSubscription;, + /**, + * Runs the provided action on the given scheduler and allows propagation, + * of multiple events to the observers of the returned StoppableObservable., + * The action is immediately executed and unobserved values will be lost., + * @param <T> the output value type, + * @param scheduler the scheduler where the action is executed, + * @param action the action to execute, receives an Observer where the events can be pumped, + * and a Subscription which lets check for
[+++ b/gradle.properties, +version=0.12.2-SNAPSHOT]
[+++ b/rxjava-core/src/main/java/rx/concurrency/CurrentThreadScheduler.java, +package rx.concurrency;, +, +import java.util.concurrent.TimeUnit;, +, +import rx.Scheduler;, +import rx.Subscription;, +import rx.util.functions.Func2;, +, +/**, + * Deprecated. Package changed from rx.concurrency to rx.schedulers., + * , + * @deprecated Use {@link rx.schedulers.CurrentThreadScheduler} instead. This will be removed before 1.0 release., + */, +@Deprecated, +public class CurrentThreadScheduler extends Scheduler {, +, + private final static CurrentThreadScheduler INSTANCE = new CurrentThreadScheduler();, +, + public static CurrentThreadScheduler getInstance() {, + return INSTANCE;, + }, +, + private final rx.schedulers.CurrentThreadScheduler actual;, +, + private CurrentThreadScheduler() {, + actual = rx.schedulers.CurrentThreadScheduler.getInstance();, + }, +, + @Override, + public <T> Subscription schedule(T state,
[+++ b/src/main/java/io/reactivex/Observable.java, + * <img width="640" height="290" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/just.item.png" alt="">, + * <img width="640" height="195" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/rangeLong.png" alt="">, + * <p>, + * <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sorted.png" alt="">, + * <p>, + * If any item emitted by this Observable does not implement {@link Comparable} with respect to, + * <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWith.item.png" alt="">, + * <img width="640" height="315" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/startWithArray.png" alt="">]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * for example using `map(CharSequence::toString)` or `map(list -> Collections.unmodifiableList(new ArrayList<>(list)))`., + * for example using `map(CharSequence::toString)` or `map(list -> Collections.unmodifiableList(new ArrayList<>(list)))`., + * for example using `map(CharSequence::toString)` or `map(list -> Collections.unmodifiableList(new ArrayList<>(list)))`., +++ b/src/main/java/io/reactivex/Flowable.java, + * for example using `map(CharSequence::toString)` or `map(list -> Collections.unmodifiableList(new ArrayList<>(list)))`., + * for example using `map(CharSequence::toString)` or `map(list -> Collections.unmodifiableList(new ArrayList<>(list)))`., + * for example using `map(CharSequence::toString)` or `map(list -> Collections.unmodifiableList(new ArrayList<>(list)))`., +++ b/src/main/java/io/reactivex/Observable.java, + * for example using `map(CharSequence::toString)` or `map(list -> Collections.unmodifiableList(new ArrayList<>(list)))`., + * for example using `map(CharSequence::toString)` or `map(list -> Collections.unmodifiableList(new ArrayList<>(list)))`., + * for example using
[+++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscription { }, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscription { }, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorFilter;, + return lift(new OperatorFilter<T>(predicate));, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscription { }, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorFilter;, + return lift(new OperatorFilter<T>(predicate));, +++ /dev/null, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscription { }, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorFilter;, + return lift(new OperatorFilter<T>(predicate));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorFilter.java, +/**, + * Copyright 2014 Netflix, Inc., + * ,
[+++ b/DESIGN.md, +This document explains the terminology, principles, contracts, and other aspects of the design of RxJava v2., +Its intended audience is the implementers of the library., +##### Interactive, +, +Producer obeys consumer-driven flow control., +Consumer manages capacity by requesting data., +, +, +##### Reactive, +, +Producer is in charge. Consumer has to do whatever it needs to keep up., +, +, +, +, +##### Reactive/Push, +Examples:, +, +- `Observable` (RxJS, Rx.Net, RxJava v1.x without backpressure, RxJava v2), +- Callbacks (the producer calls the function at its convenience), +- IRQ, mouse events, IO interrupts, +- 2.x `Flowable` (with `request(n)`
[+++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.operators.observable.*;, + * .dematerialize(), + * .dematerialize(), + * @see #dematerialize(Function), + * @deprecated in 2.2.4; inherently type-unsafe as it overrides the output generic type. Use {@link #dematerialize(Function)} instead., + @BackpressureSupport(BackpressureKind.PASS_THROUGH), + @Deprecated, + @SuppressWarnings({ "unchecked", "rawtypes" }), + return RxJavaPlugins.onAssembly(new FlowableDematerialize(this, Functions.identity()));, + }, +, + /**, + * Returns a Flowable that reverses the effect of {@link #materialize materialize} by transforming the, + * {@link Notification} objects extracted from the source items via a selector function, + * into their respective {@code Subscriber} signal types., + * <p>, + * <img width="640" height="335" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/dematerialize.png"
[+++ b/src/main/java/io/reactivex/Single.java, + * Delays the emission of the success signal from the current Single by the specified amount., + * An error signal will not be delayed., + * @param time the amount of time the success signal should be delayed for, + return delay(time, unit, Schedulers.computation(), false);, + }, +, + /**, + * Delays the emission of the success or error signal from the current Single by the specified amount., + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code delay} operates by default on the {@code computation} {@link Scheduler}.</dd>, + * </dl>, + *, + *
[+++ b/gradle/convention.gradle, + gradleVersion = '1.6', +++ b/gradle/convention.gradle, + gradleVersion = '1.6', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/convention.gradle, + gradleVersion = '1.6', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Sep 03 10:20:57 PDT 2013]
[+++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, + <activity, + android:name=".ListeningFragmentActivity">, +, + <intent-filter>, + <category android:name="android.intent.category.LAUNCHER"/>, + <category android:name="android.intent.category.DEFAULT"/>, + <action android:name="android.intent.action.MAIN"/>, + </intent-filter>, + </activity>, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, + <activity, + android:name=".ListeningFragmentActivity">, +, + <intent-filter>, + <category android:name="android.intent.category.LAUNCHER"/>, + <category android:name="android.intent.category.DEFAULT"/>, + <action android:name="android.intent.action.MAIN"/>, + </intent-filter>, + </activity>, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/ListeningFragmentActivity.java, +package com.netflix.rxjava.android.samples;, +, +import android.app.Activity;, +import android.app.Fragment;, +import android.os.Bundle;, +import android.view.LayoutInflater;, +import android.view.View;, +import android.view.ViewGroup;, +import android.widget.TextView;, +import android.widget.Toast;, +, +import rx.Subscriber;, +import rx.Subscription;, +import rx.observables.ConnectableObservable;, +import rx.subscriptions.Subscriptions;, +, +import static rx.android.schedulers.AndroidSchedulers.mainThread;, +, +/**, + * Problem:, + * You have a background sequence which keeps emitting items (either a limited or unlimited
[+++ b/src/main/java/io/reactivex/Maybe.java, + * Maps the success value of the upstream {@link Maybe} into an {@link Iterable} and emits its items as a, + * {@link Flowable} sequence., + * Maps the success value of the upstream {@link Maybe} into an {@link Iterable} and emits its items as an, + * {@link Observable} sequence., +++ b/src/main/java/io/reactivex/Maybe.java, + * Maps the success value of the upstream {@link Maybe} into an {@link Iterable} and emits its items as a, + * {@link Flowable} sequence., + * Maps the success value of the upstream {@link Maybe} into an {@link Iterable} and emits
[+++ b/src/main/java/io/reactivex/Observable.java, + return new SubscriptionLambdaObserver<T>(s, onSubscribe, onCancel);, + LambdaObserver<T> ls = new LambdaObserver<T>(onNext, onError, onComplete, onSubscribe);, +++ b/src/main/java/io/reactivex/Observable.java, + return new SubscriptionLambdaObserver<T>(s, onSubscribe, onCancel);, + LambdaObserver<T> ls = new LambdaObserver<T>(onNext, onError, onComplete, onSubscribe);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableAll.java, + static final class AllSubscriber<T> implements Observer<T>, Disposable {, + actual.onSubscribe(this);, + , + @Override, + public void dispose() {, + s.dispose();, + }, + , + @Override, + public boolean isDisposed() {, + return s.isDisposed();, + }, +++ b/src/main/java/io/reactivex/Observable.java, + return new SubscriptionLambdaObserver<T>(s, onSubscribe, onCancel);, + LambdaObserver<T> ls = new LambdaObserver<T>(onNext, onError, onComplete, onSubscribe);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableAll.java, + static final class AllSubscriber<T> implements
[+++ b/src/main/java/io/reactivex/observers/DefaultObserver.java, + s = null;, +++ b/src/main/java/io/reactivex/observers/DefaultObserver.java, + s = null;, +++ b/src/main/java/io/reactivex/subscribers/DefaultSubscriber.java, + Subscription s = this.s;, + if (s != null) {, + }, + s = null;]
[+++ b/gradle.properties, +version=0.20.0-RC2-SNAPSHOT]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationGroupJoin;, +import rx.operators.OperatorSampleWithObservable;, +import rx.operators.OperatorSampleWithTime;, +import rx.operators.OperatorTimerOnce;, +import rx.operators.OperatorTimerPeriodically;, + return create(new OperatorTimerPeriodically(interval, interval, unit, Schedulers.computation()));, + return create(new OperatorTimerPeriodically(interval, interval, unit, scheduler));, + return create(new OperatorTimerPeriodically(initialDelay, period, unit, scheduler));, + * @return an Observable that emits one item after a specified delay, and then completes, + * @return Observable that emits one item after a specified delay, on a specified Scheduler, and then, + * completes, + return create(new OperatorTimerOnce(delay, unit, scheduler));, + return create(new OperationGroupJoin<T, T2, D1, D2, R>(this, right, leftDuration, rightDuration, resultSelector));, + return lift(new OperatorSampleWithTime<T>(period, unit, Schedulers.computation()));, + return lift(new OperatorSampleWithTime<T>(period, unit,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationOnErrorReturn;, +import rx.operators.OperatorUsing;, + public final static <T, Resource extends Subscription> Observable<T> using(Func0<Resource> resourceFactory, Func1<Resource, ? extends Observable<? extends T>> observableFactory) {, + return create(new OperatorUsing<T, Resource>(resourceFactory, observableFactory));, + return create(OperationOnErrorReturn.onErrorReturn(this, resumeFunction));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationOnErrorReturn;, +import rx.operators.OperatorUsing;, + public final static <T, Resource extends Subscription> Observable<T> using(Func0<Resource> resourceFactory, Func1<Resource, ? extends Observable<? extends T>> observableFactory) {, + return create(new OperatorUsing<T, Resource>(resourceFactory, observableFactory));, + return create(OperationOnErrorReturn.onErrorReturn(this, resumeFunction));, +++ b/rxjava-core/src/main/java/rx/operators/OperationOnErrorReturn.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use
[+++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.operators.flowable.FlowableConcatMap.ErrorMode;, + return new FlowableConcatMap<T, R>(this, mapper, prefetch, ErrorMode.IMMEDIATE);, + return new FlowableFlattenIterable<T, U>(this, mapper, prefetch);, + return flatMapIterable(mapper, bufferSize());, + return new FlowableFlattenIterable<T, U>(this, mapper, bufferSize);, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.operators.flowable.FlowableConcatMap.ErrorMode;, + return new FlowableConcatMap<T, R>(this, mapper, prefetch, ErrorMode.IMMEDIATE);, + return new FlowableFlattenIterable<T, U>(this, mapper, prefetch);, + return flatMapIterable(mapper, bufferSize());, + return new FlowableFlattenIterable<T, U>(this, mapper, bufferSize);, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableConcat.java, + if (SubscriptionHelper.validate(this.s, s)) {, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.operators.flowable.FlowableConcatMap.ErrorMode;, + return new FlowableConcatMap<T, R>(this, mapper, prefetch, ErrorMode.IMMEDIATE);, + return new FlowableFlattenIterable<T, U>(this, mapper, prefetch);, + return flatMapIterable(mapper, bufferSize());, + return new FlowableFlattenIterable<T, U>(this, mapper, bufferSize);, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableConcat.java,
[+++ b/src/main/java/io/reactivex/Observable.java, + , + public final Observable<T> repeat() {, + return repeat(Long.MAX_VALUE);, + }, + , + public final Observable<T> repeat(long times) {, + if (times < 0) {, + throw new IllegalArgumentException("times >= 0 required but it was " + times);, + }, + if (times == 0) {, + return empty();, + }, + return create(new PublisherRepeat<>(this, times));, + }, + , + public final Observable<T> repeatUntil(BooleanSupplier stop) {, + return create(new PublisherRepeatUntil<>(this, stop));, + }, + , + public final Observable<T> retry() {, + return retry(Long.MAX_VALUE, e -> true);, + }, +, + public final
[+++ b/gradle.properties, +version=0.17.5-SNAPSHOT]
[+++ b/src/test/java/io/reactivex/tck/LimitTckTest.java, +/**, + * Copyright (c) 2016-present, RxJava Contributors., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.3-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.3-SNAPSHOT, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.3-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.3-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.3-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.3-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.3-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.3-SNAPSHOT, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Consumes the upstream {@code Flowable} in a blocking fashion and invokes the given, + * {@code Consumer} with each upstream item on the <em>current thread</em> until the, + * upstream terminates., + * <em>Note:</em> the method will only return if the upstream terminates or the current, + * thread is interrupted., + * <p>, + * <p>This method executes the {@code Consumer} on the current thread while, + * {@link #subscribe(Consumer)} executes the consumer on the original caller thread of the, + * sequence., +++ b/src/main/java/io/reactivex/Flowable.java, + * Consumes the upstream {@code Flowable} in a
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java, +import io.reactivex.internal.fuseable.QueueFuseable;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java, +import io.reactivex.internal.fuseable.QueueFuseable;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDistinct.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java, +import io.reactivex.internal.fuseable.QueueFuseable;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDistinct.java, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFilter.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDistinct.java, +import io.reactivex.internal.fuseable.QueueFuseable;, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDistinct.java, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFilter.java, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableWindowWithTimeTest.java, +import java.util.concurrent.atomic.*;, + public void restartTimerMany() throws Exception {, + final AtomicBoolean cancel1 = new AtomicBoolean();, + .doOnCancel(new Action() {, + @Override, + public void run() throws Exception {, + cancel1.set(true);, + }, + }), +, + int timeout = 20;, + while (timeout-- > 0 && !cancel1.get()) {, + Thread.sleep(100);, + }, +, + assertTrue("intervalRange was not cancelled!", cancel1.get());]
[+++ b/gradle.properties, +version=0.11.2]
[+++ b/src/test/java/io/reactivex/TestHelper.java, + * @param <R> the output value type, + * @param transform the transform to drive an operator, + */, + public static <T, R> void checkDoubleOnSubscribeSingleToFlowable(Function<Single<T>, ? extends Publisher<R>> transform) {, + List<Throwable> errors = trackPluginErrors();, + try {, + final Boolean[] b = { null, null };, + final CountDownLatch cdl = new CountDownLatch(1);, +, + Single<T> source = new Single<T>() {, + @Override, + protected void subscribeActual(SingleObserver<? super T> observer) {, + try {, + Disposable d1 = Disposables.empty();, +, + observer.onSubscribe(d1);, +, + Disposable d2 = Disposables.empty();, +, + observer.onSubscribe(d2);, +, + b[0]
[+++ b/CHANGES.md, +### Version 0.20.0-RC5 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.20.0-RC5%22)) ###, +, +Version 0.20.0-RC5 updates `parallel`, `buffer(size)`, `switchOnNext`, `repeat`, and `retry` to support "reactive pull" backpressure. It adds a `groupBy` overload with an element selector, a new `compose` method as an alternative to `lift` for custom operators, fixes bugs and other general improvements., +, +There are still oustanding items being tracked for 0.20 that need to be completed for the final release., +, +* [Pull 1573] (https://github.com/Netflix/RxJava/pull/1573) Backpressure: parallel , +* [Pull 1572] (https://github.com/Netflix/RxJava/pull/1572) Remove Timeout in Blocking Iterator, +* [Pull 1570] (https://github.com/Netflix/RxJava/pull/1570) RxClojure: Fix for mapcat, +* [Pull 1568] (https://github.com/Netflix/RxJava/pull/1568) Compose/Transformer,
[+++ /dev/null, +++ /dev/null, +++ b/rxjava-core/src/test/java/rx/util/AssertObservable.java, +package rx.util;, +, +import rx.Notification;, +import rx.Observable;, +import rx.util.functions.Func1;, +import rx.util.functions.Func2;, +, +public class AssertObservable {, + /**, + * Asserts that two Observables are equal. If they are not, an {@link AssertionError} is thrown, + * with the given message. If <code>expecteds</code> and <code>actuals</code> are, + * <code>null</code>, they are considered equal., + * , + * @param expected, + * Observable with expected values., + * @param actual, + * Observable with actual values, + */, + public static <T> void assertObservableEqualsBlocking(Observable<T> expected, Observable<T> actual) {, + assertObservableEqualsBlocking(null, expected, actual);, +
[+++ b/src/main/java/io/reactivex/Flowable.java, + ObjectHelper.verifyPositive(bufferSize, "bufferSize");, + ObjectHelper.verifyPositive(bufferSize, "bufferSize");, + ObjectHelper.verifyPositive(bufferSize, "bufferSize");, + ObjectHelper.verifyPositive(bufferSize, "bufferSize");, + ObjectHelper.verifyPositive(bufferSize, "bufferSize");, + ObjectHelper.verifyPositive(bufferSize, "bufferSize");, + ObjectHelper.verifyPositive(bufferSize, "bufferSize");, + ObjectHelper.verifyPositive(bufferSize, "bufferSize");, + ObjectHelper.verifyPositive(count, "count");, + ObjectHelper.verifyPositive(initialCapacity, "initialCapacity");, + ObjectHelper.verifyPositive(prefetch, "prefetch");, + ObjectHelper.verifyPositive(prefetch, "prefetch");, + ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");, + ObjectHelper.verifyPositive(prefetch, "prefetch");, + ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");, + ObjectHelper.verifyPositive(bufferSize, "bufferSize");, + ObjectHelper.verifyPositive(bufferSize, "bufferSize");, + ObjectHelper.verifyPositive(bufferSize, "bufferSize");, + ObjectHelper.verifyPositive(capacity, "bufferSize");, + ObjectHelper.verifyPositive(capacity, "capacity");, + ObjectHelper.verifyPositive(prefetch, "prefetch");, + ObjectHelper.verifyPositive(bufferSize, "bufferSize");, + ObjectHelper.verifyPositive(bufferSize, "bufferSize");, + * @return a {@link Disposable} reference with which the caller can stop receiving items before, + * @return a {@link Disposable} reference with which the caller can
[+++ b/.gitignore, +.m2, +target/, +build/, +bin/, +, +# Scala build, +*.cache, +++ b/.gitignore, +.m2, +target/, +build/, +bin/, +, +# Scala build, +*.cache, +++ b/CHANGES.md, +# RxJava Releases #, +, +### Version 0.6.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.6.1%22)) ###, +, +* [Pull 190](https://github.com/Netflix/RxJava/pull/190) Fix generics issue with materialize() that prevented chaining, +, +### Version 0.6.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.6.0%22)) ###, +, +* [Issue 154](https://github.com/Netflix/RxJava/issues/154) Add OSGi manifest headers, +* [Issue 173](https://github.com/Netflix/RxJava/issues/173) Subscription Utilities and Default Implementations, +* [Pull 184](https://github.com/Netflix/RxJava/pull/184) Convert 'last' from non-blocking to blocking to match Rx.Net (see [Issue 57](https://github.com/Netflix/RxJava/issues/57)), +, +*NOTE:* This is a version bump from 0.5 to 0.6 because [Issue 173](https://github.com/Netflix/RxJava/issues/173)
[+++ b/rxjava-contrib/rxjava-joins/src/main/java/rx/joins/operators/OperationJoinPatterns.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not, + * use this file except in compliance with the License. You may obtain a copy of, + * the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the, +
[+++ b/src/main/java/io/reactivex/internal/util/EndConsumerHelper.java, +/**, + * Copyright (c) 2016-present, RxJava Contributors., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language
[+++ b/src/main/java/io/reactivex/subscribers/DefaultSubscriber.java, + * .subscribe(new DefaultSubscriber&lt;Integer>() {]
[+++ b/src/main/java/io/reactivex/internal/schedulers/NewThreadWorker.java, + f = executor.submit(sr);, + f = executor.schedule(sr, delayTime, unit);, +++ b/src/main/java/io/reactivex/internal/schedulers/NewThreadWorker.java, + f = executor.submit(sr);, + f = executor.schedule(sr, delayTime, unit);, +++ b/src/main/java/io/reactivex/subjects/AsyncSubject.java, + Object o = state.get();, + return state.subscribers() == State.TERMINATED && !NotificationLite.isError(o);, + return NotificationLite.getError(o);, + if (o != null && !NotificationLite.isError(o) && !NotificationLite.isComplete(o)) {, + } else {, + if (array.length != 0) {, + array[0] = null;, + }, + if (value != null) {, + }, + if (v != null) {, + }, +++ b/src/main/java/io/reactivex/internal/schedulers/NewThreadWorker.java, + f = executor.submit(sr);, + f = executor.schedule(sr, delayTime, unit);, +++ b/src/main/java/io/reactivex/subjects/AsyncSubject.java, + Object
[+++ b/rxjava-core/src/main/java/rx/Observable.java, + public final Observable<Boolean> contains(final T element) {, + return lift(new OperatorWindowWithObservable<T, TClosing>(closingSelector));, + return lift(new OperatorWindowWithSize<T>(count, count));, + return lift(new OperatorWindowWithSize<T>(count, skip));, + return lift(new OperatorWindowWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, Schedulers.computation()));, + return lift(new OperatorWindowWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, scheduler));, + return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, Schedulers.computation()));, + return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, count, Schedulers.computation()));, + return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, count, scheduler));, + return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, scheduler));, + return lift(new OperatorWindowWithStartEndObservable<T, TOpening, TClosing>(windowOpenings, closingSelector));, + return lift(new OperatorWindowWithObservable<T, U>(boundary));, +++ b/rxjava-core/src/main/java/rx/Observable.java, + public final Observable<Boolean> contains(final T element) {, + return lift(new OperatorWindowWithObservable<T,
[+++ b/src/main/java/io/reactivex/Observable.java, + return OperatorReplay.createFrom(this);, +++ b/src/main/java/io/reactivex/Observable.java, + return OperatorReplay.createFrom(this);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorReplay.java, + // TODO javac 1.8 fails with ambiguity error if this method is called create(), works properly, + public static <T> ConnectableObservable<T> createFrom(Observable<? extends T> source) {, + return createFrom(source);]
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/README.md, +++ b/CHANGES.md, +++ b/README.md, +++ b/gradle.properties, +version=0.6.1-SNAPSHOT, +++ b/CHANGES.md, +++ b/README.md, +++ b/gradle.properties, +version=0.6.1-SNAPSHOT, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/CHANGES.md, +++ b/README.md, +++ b/gradle.properties, +version=0.6.1-SNAPSHOT, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/rxjava-core/build.gradle, + compile 'com.google.code.findbugs:jsr305:2.0.0', +++ b/CHANGES.md, +++ b/README.md, +++ b/gradle.properties, +version=0.6.1-SNAPSHOT, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/rxjava-core/build.gradle, + compile 'com.google.code.findbugs:jsr305:2.0.0', +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.*;, + private final boolean isTrusted;, + this(null, false);, + this(onSubscribe, false);, + }, +, + /**, + * @param onSubscribe, + * {@link Func1} to be executed when {@link #subscribe(Observer)} is called., + * @param isTrusted, + * boolean true if the <code>onSubscribe</code> function is
[+++ b/.travis.yml, + - secure: Joj/k9B4q1BttgP7rY1DFR9flURcvT2b4PFnxYwxljQuu6NHwz/3yLM1b711Kv9oAXlo1D/ZTXsCzle8tLs5yC3GakDCpapqZP4Gmen4zGLuHB851gejH134dJj4bEWigrSM6NJMzjbl7qmlMAc8R+DlLi/J7AxNicOrhOT5MGw=, + - secure: jxpzSkzSBnTqlAAY6r8QmX4b/Gf36NTshQ7xWQ8UWkWHHjm4GTnCoR71nXCIqhtZRgXvteR2AKYbraXU3ROGkZZXR4KkEwjhkf2FVr16bmUWbiqQrVvIdBPljcV9m3OevNEzCqd3QPod/Jma5s8WIDvuOv2z/cnpN/HQiHaRFEM=, +++ b/.travis.yml, + - secure: Joj/k9B4q1BttgP7rY1DFR9flURcvT2b4PFnxYwxljQuu6NHwz/3yLM1b711Kv9oAXlo1D/ZTXsCzle8tLs5yC3GakDCpapqZP4Gmen4zGLuHB851gejH134dJj4bEWigrSM6NJMzjbl7qmlMAc8R+DlLi/J7AxNicOrhOT5MGw=, + - secure: jxpzSkzSBnTqlAAY6r8QmX4b/Gf36NTshQ7xWQ8UWkWHHjm4GTnCoR71nXCIqhtZRgXvteR2AKYbraXU3ROGkZZXR4KkEwjhkf2FVr16bmUWbiqQrVvIdBPljcV9m3OevNEzCqd3QPod/Jma5s8WIDvuOv2z/cnpN/HQiHaRFEM=, +++ b/gradle/buildViaTravis.sh, + ./gradlew -Prelease.travisci=true -PbintrayUser="${bintrayUser}" -PbintrayKey="${bintrayKey}" -PsonatypeUsername="${sonatypeUsername}" -PsonatypePassword="${sonatypePassword}" build snapshot --stacktrace, + ./gradlew -Prelease.travisci=true -Prelease.useLastTag=true -PbintrayUser="${bintrayUser}" -PbintrayKey="${bintrayKey}" -PsonatypeUsername="${sonatypeUsername}" -PsonatypePassword="${sonatypePassword}" final --stacktrace, +++ b/.travis.yml, + - secure: Joj/k9B4q1BttgP7rY1DFR9flURcvT2b4PFnxYwxljQuu6NHwz/3yLM1b711Kv9oAXlo1D/ZTXsCzle8tLs5yC3GakDCpapqZP4Gmen4zGLuHB851gejH134dJj4bEWigrSM6NJMzjbl7qmlMAc8R+DlLi/J7AxNicOrhOT5MGw=, + - secure: jxpzSkzSBnTqlAAY6r8QmX4b/Gf36NTshQ7xWQ8UWkWHHjm4GTnCoR71nXCIqhtZRgXvteR2AKYbraXU3ROGkZZXR4KkEwjhkf2FVr16bmUWbiqQrVvIdBPljcV9m3OevNEzCqd3QPod/Jma5s8WIDvuOv2z/cnpN/HQiHaRFEM=, +++ b/gradle/buildViaTravis.sh, + ./gradlew -Prelease.travisci=true -PbintrayUser="${bintrayUser}" -PbintrayKey="${bintrayKey}" -PsonatypeUsername="${sonatypeUsername}" -PsonatypePassword="${sonatypePassword}" build snapshot --stacktrace, + ./gradlew -Prelease.travisci=true -Prelease.useLastTag=true -PbintrayUser="${bintrayUser}" -PbintrayKey="${bintrayKey}" -PsonatypeUsername="${sonatypeUsername}" -PsonatypePassword="${sonatypePassword}" final --stacktrace, +++ b/src/main/java/rx/Observable.java, + * <dd>This operator does not support backpressure as it uses {@code count} to control data flow.</dd>, + * <dd>This operator does not
[+++ b/src/main/java/io/reactivex/Completable.java, + * @see #andThen(MaybeSource), + * @see #andThen(ObservableSource), + * @see #andThen(SingleSource), + * @see #andThen(Publisher), + * @see #doFinally(Action), + * @see #doFinally(Action), + * @see #doFinally(Action), + * @see #doFinally(Action), +++ b/src/main/java/io/reactivex/Completable.java, + * @see #andThen(MaybeSource), + * @see #andThen(ObservableSource), + * @see #andThen(SingleSource), + * @see #andThen(Publisher), + * @see #doFinally(Action), + * @see #doFinally(Action), + * @see #doFinally(Action), + * @see #doFinally(Action), +++ b/src/test/java/io/reactivex/JavadocWording.java, +import java.util.regex.Pattern;, + Pattern p = Pattern.compile("@see\\s+#[A-Za-z0-9 _.,()]*Flowable");, + if (!p.matcher(m.javadoc).find()) {, + }, + Pattern p = Pattern.compile("@see\\s+#[A-Za-z0-9 _.,()]*Single");, + if (!p.matcher(m.javadoc).find()) {, + }, + Pattern p
[+++ b/src/main/java/io/reactivex/Completable.java, + ObjectHelper.requireNonNull(observer, "observer is null");, +++ b/src/main/java/io/reactivex/Completable.java, + ObjectHelper.requireNonNull(observer, "observer is null");, +++ b/src/main/java/io/reactivex/Flowable.java, + ObjectHelper.requireNonNull(supplier, "supplier is null");, + ObjectHelper.requireNonNull(source, "source is null");, + ObjectHelper.requireNonNull(item1, "item1 is null");, + ObjectHelper.requireNonNull(item2, "item2 is null");, + ObjectHelper.requireNonNull(item1, "item1 is null");, + ObjectHelper.requireNonNull(item2, "item2 is null");, + ObjectHelper.requireNonNull(item3, "item3 is null");, + ObjectHelper.requireNonNull(item1, "item1 is null");, + ObjectHelper.requireNonNull(item2, "item2 is null");, + ObjectHelper.requireNonNull(item3, "item3 is null");, + ObjectHelper.requireNonNull(item4, "item4 is null");, + ObjectHelper.requireNonNull(item1, "item1 is null");, + ObjectHelper.requireNonNull(item2, "item2 is null");, + ObjectHelper.requireNonNull(item3, "item3 is null");, + ObjectHelper.requireNonNull(item4, "item4 is null");, + ObjectHelper.requireNonNull(item5, "item5 is null");, + ObjectHelper.requireNonNull(item1, "item1
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationMulticast;, +import rx.operators.OperationReplay;, +import rx.operators.OperatorOnErrorResumeNextViaObservable;, + return OperationMulticast.multicast(this, subjectFactory, selector);, + return OperationMulticast.multicast(this, subject);, + return lift(new OperatorOnErrorResumeNextViaObservable<T>(resumeSequence));, + return OperationMulticast.multicast(this, PublishSubject.<T> create());, + return OperationMulticast.multicast(this, BehaviorSubject.<T> create(initialValue));, + return OperationMulticast.multicast(this, AsyncSubject.<T> create());, + return OperationMulticast.multicast(this, ReplaySubject.<T> create());, + return OperationMulticast.multicast(this, new Func0<Subject<T, T>>() {, + }, selector);, + return OperationMulticast.multicast(this, new Func0<Subject<T, T>>() {, + return OperationReplay.replayBuffered(bufferSize);, + }, selector);, + return OperationMulticast.multicast(this, new Func0<Subject<T, T>>() {, + return OperationReplay.replayWindowed(time, unit, bufferSize, scheduler);, + }, selector);, + return OperationMulticast.multicast(this, new Func0<Subject<T, T>>() {, + return OperationReplay.<T> createScheduledSubject(OperationReplay.<T> replayBuffered(bufferSize), scheduler);, + }, selector);, + return OperationMulticast.multicast(this,
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAll.java, +public final class FlowableAll<T> extends FlowableWithUpstream<T, Boolean> {, + super(source);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAll.java, +public final class FlowableAll<T> extends FlowableWithUpstream<T, Boolean> {, + super(source);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAny.java, +public final class FlowableAny<T> extends FlowableWithUpstream<T, Boolean> {, + super(source);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAll.java, +public final class FlowableAll<T> extends FlowableWithUpstream<T, Boolean> {, + super(source);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAny.java, +public final class FlowableAny<T> extends FlowableWithUpstream<T, Boolean> {, + super(source);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundary.java, +extends FlowableWithUpstream<T, U> {, + super(source);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAll.java, +public final class FlowableAll<T> extends FlowableWithUpstream<T, Boolean> {, + super(source);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAny.java, +public final class FlowableAny<T> extends FlowableWithUpstream<T, Boolean> {, + super(source);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundary.java, +extends FlowableWithUpstream<T, U> {, +
[+++ b/classes/production/rxjava-core/rx/operators/README.txt, +This package "rx.operators" is for internal implementation details and can change at any time., +, +It is excluded from the public Javadocs (http://netflix.github.io/RxJava/javadoc/) and should not be relied upon by any code., +, +In short, changes to public signatures of these classes will not be accounted for in the versioning of RxJava., +++ b/classes/production/rxjava-core/rx/operators/README.txt, +This package "rx.operators" is for internal implementation details and can change at any time., +, +It is excluded from the public Javadocs (http://netflix.github.io/RxJava/javadoc/) and should not be relied upon by any code., +, +In short, changes to public signatures of these classes will
[+++ b/src/main/java/io/reactivex/Observable.java, + Disposable d = Disposables.empty();, +++ b/src/main/java/io/reactivex/Observable.java, + Disposable d = Disposables.empty();, +++ b/src/main/java/io/reactivex/Scheduler.java, + @Override, + public boolean isDisposed() {, + return disposed;, + }, +++ b/src/main/java/io/reactivex/Observable.java, + Disposable d = Disposables.empty();, +++ b/src/main/java/io/reactivex/Scheduler.java, + @Override, + public boolean isDisposed() {, + return disposed;, + }, +++ b/src/main/java/io/reactivex/disposables/BooleanDisposable.java, +final class BooleanDisposable implements Disposable {, + BooleanDisposable() {, + BooleanDisposable(Runnable run) {, + @Override, +++ b/src/main/java/io/reactivex/Observable.java, + Disposable d = Disposables.empty();, +++ b/src/main/java/io/reactivex/Scheduler.java, + @Override, + public boolean isDisposed() {, + return disposed;, + }, +++ b/src/main/java/io/reactivex/disposables/BooleanDisposable.java, +final class BooleanDisposable implements Disposable {, + BooleanDisposable() {, +
[+++ b/src/main/java/io/reactivex/Emitter.java, +import io.reactivex.annotations.NonNull;, +, + void onNext(@NonNull T value);, + void onError(@NonNull Throwable error);]
[+++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyActionWrapper.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyActionWrapper.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyActionWrapper.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyFunctionWrapper.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyActionWrapper.java, + * Copyright 2014 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, +
[+++ /dev/null, +++ /dev/null, +++ b/rxjava-core/src/test/java/rx/operators/OperatorConcatTest.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
[+++ b/src/main/java/io/reactivex/Observable.java, + Objects.requireNonNull(debounceSelector);, + Objects.requireNonNull(unit);, + Objects.requireNonNull(scheduler);, + Objects.requireNonNull(seed);, + Objects.requireNonNull(seedSupplier);, + Objects.requireNonNull(accumulator);, + , + public final Observable<T> throttleFirst(long windowDuration, TimeUnit unit) {, + return throttleFirst(windowDuration, unit, Schedulers.computation());, + }, +, + public final Observable<T> throttleFirst(long skipDuration, TimeUnit unit, Scheduler scheduler) {, + return lift(new OperatorThrottleFirstTimed<T>(skipDuration, unit, scheduler));, + }, + , + public final Observable<T> throttleLast(long intervalDuration, TimeUnit unit) {, + return sample(intervalDuration, unit);, + }, + , + public final Observable<T> throttleLast(long intervalDuration, TimeUnit unit, Scheduler scheduler) {, + return sample(intervalDuration, unit, scheduler);, + }, +++ b/src/main/java/io/reactivex/Observable.java, + Objects.requireNonNull(debounceSelector);, + Objects.requireNonNull(unit);, + Objects.requireNonNull(scheduler);, + Objects.requireNonNull(seed);,
[+++ b/src/main/java/io/reactivex/Observable.java, + * ObservableSource that returns a SingleSource, and then emitting the item emitted by the most recently emitted, + * of these SingleSources., + * <p>, + * The resulting ObservableSource completes if both the upstream ObservableSource and the last inner SingleSource, if any, complete., + * If the upstream ObservableSource signals an onError, the inner SingleSource is unsubscribed and the error delivered in-sequence., + * <p>, + * <img width="640" height="350" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMap.png" alt="">, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code switchMapSingle} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>,
[+++ b/src/main/java/io/reactivex/observers/completable/CompletableSerializedObserver.java, +/**, + * Copyright 2016 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the
[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subject.scala, +/**, + * Copyright 2013 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for
[+++ b/src/main/java/io/reactivex/Completable.java, + ObjectHelper.requireNonNull(unit, "unit is null");, +++ b/src/main/java/io/reactivex/Completable.java, + ObjectHelper.requireNonNull(unit, "unit is null");, +++ b/src/main/java/io/reactivex/Flowable.java, + ObjectHelper.requireNonNull(source1, "source1 is null");, + ObjectHelper.requireNonNull(source2, "source2 is null");, + ObjectHelper.requireNonNull(source1, "source1 is null");, + ObjectHelper.requireNonNull(source2, "source2 is null");, + ObjectHelper.requireNonNull(source3, "source3 is null");, + ObjectHelper.requireNonNull(source1, "source1 is null");, + ObjectHelper.requireNonNull(source2, "source2 is null");, + ObjectHelper.requireNonNull(source3, "source3 is null");, + ObjectHelper.requireNonNull(source4, "source4 is null");, + ObjectHelper.requireNonNull(sources, "sources is null");, + ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");, + ObjectHelper.verifyPositive(prefetch, "prefetch");, + ObjectHelper.requireNonNull(sources, "sources is null");, + ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");, + ObjectHelper.verifyPositive(prefetch, "prefetch");, + ObjectHelper.requireNonNull(sources, "sources is null");, + ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");, + ObjectHelper.verifyPositive(prefetch, "prefetch");, + ObjectHelper.verifyPositive(initialCapacity, "initialCapacity");, + ObjectHelper.verifyPositive(prefetch,
[+++ b/src/main/java/io/reactivex/Completable.java, + * // The downstream's CompletableObserver that will receive the onXXX events, +++ b/src/main/java/io/reactivex/Completable.java, + * // The downstream's CompletableObserver that will receive the onXXX events, +++ b/src/main/java/io/reactivex/Flowable.java, + * resulting sequence terminates immediately (normally or with all the errors accumulated until that point)., + * resulting sequence terminates immediately (normally or with all the errors accumulated until that point)., + * resulting sequence terminates immediately (normally or with all the errors accumulated until that point)., + * resulting sequence terminates immediately (normally or with all the errors accumulated until that point)., + * resulting sequence terminates
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java, +import io.reactivex.annotations.NonNull;, + @Nullable, + @Nullable, + public FlowableCombineLatest(@NonNull Publisher<? extends T>[] array,, + @NonNull Function<? super Object[], ? extends R> combiner,, + public FlowableCombineLatest(@NonNull Iterable<? extends Publisher<? extends T>> iterable,, + @NonNull Function<? super Object[], ? extends R> combiner,, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java, +import io.reactivex.annotations.NonNull;, + @Nullable, + @Nullable, + public FlowableCombineLatest(@NonNull Publisher<? extends T>[] array,, + @NonNull Function<? super Object[], ? extends R> combiner,, + public FlowableCombineLatest(@NonNull Iterable<? extends Publisher<? extends T>> iterable,, + @NonNull Function<? super Object[], ? extends R> combiner,, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableWithLatestFromMany.java, +import io.reactivex.annotations.NonNull;, +import io.reactivex.annotations.Nullable;, + @Nullable, + @Nullable, + public FlowableWithLatestFromMany(@NonNull Publisher<T> source,
[+++ b/src/main/java/io/reactivex/functions/Function3.java, + * @param <T3> the third value type, +++ b/src/main/java/io/reactivex/functions/Function3.java, + * @param <T3> the third value type, +++ b/src/main/java/io/reactivex/functions/Function4.java, + * @param <T3> the third value type, + * @param <T4> the fourth value type, +++ b/src/main/java/io/reactivex/functions/Function3.java, + * @param <T3> the third value type, +++ b/src/main/java/io/reactivex/functions/Function4.java, + * @param <T3> the third value type, + * @param <T4> the fourth value type, +++ b/src/main/java/io/reactivex/functions/Function5.java, + * @param <T3> the third value type, + * @param <T4> the fourth value type, + * @param <T5> the fifth value type, +++ b/src/main/java/io/reactivex/functions/Function3.java, + * @param <T3> the
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorSkipUntil;, +import rx.operators.OperatorTakeTimed;, + return lift(new OperatorTakeTimed<T>(time, unit, scheduler));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorSkipUntil;, +import rx.operators.OperatorTakeTimed;, + return lift(new OperatorTakeTimed<T>(time, unit, scheduler));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorSkipUntil;, +import rx.operators.OperatorTakeTimed;, + return lift(new OperatorTakeTimed<T>(time, unit, scheduler));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorTakeTimed.java, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not, + * use this file except in compliance with the License. You may obtain a copy of, + * the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by
[+++ b/gradle.properties, +version=0.18.1-SNAPSHOT]
[+++ b/build.gradle, + repositories {, + mavenLocal(), + mavenCentral() // maven { url 'http://jcenter.bintray.com' }, + }, + repositories { , + mavenLocal(), + mavenCentral() // maven { url: 'http://jcenter.bintray.com' }, + }, +++ b/build.gradle, + repositories {, + mavenLocal(), + mavenCentral() // maven { url 'http://jcenter.bintray.com' }, + }, + repositories { , + mavenLocal(), + mavenCentral() // maven { url: 'http://jcenter.bintray.com' }, + }, +++ b/codequality/checkstyle.xml, +++ b/build.gradle, + repositories {, + mavenLocal(), + mavenCentral() // maven { url 'http://jcenter.bintray.com' }, + }, + repositories { , + mavenLocal(), + mavenCentral() // maven { url: 'http://jcenter.bintray.com' },
[+++ b/src/main/java/io/reactivex/Completable.java, + return RxJavaPlugins.onAssembly(new CompletableDoOnEvent(this, onEvent));, +++ b/src/main/java/io/reactivex/Completable.java, + return RxJavaPlugins.onAssembly(new CompletableDoOnEvent(this, onEvent));, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableDoOnEvent.java, +/**, + * Copyright 2016 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS
[+++ b/src/main/java/io/reactivex/internal/operators/OperatorConcatMap.java, + volatile long index;, + , + if (done) {, + return;, + }, + if (done) {, + RxJavaPlugins.onError(t);, + return;, + }, + done = true;, + if (done) {, + return;, + }, + index++;, +, + /*, + * FIXME this is a workaround for now, but doesn't work , + * for async non-conforming sources., + * Such sources require individual instances of InnerSubscriber and a, + * done field., + */, + , + long index;, + , + this.index = 1;, + if (index == parent.index) {, + }, +
[+++ b/src/main/java/io/reactivex/internal/schedulers/InstantPeriodicTask.java, +/**, + * Copyright (c) 2016-present, RxJava Contributors., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + *
[+++ b/src/main/java/io/reactivex/internal/observers/CallbackCompletableObserver.java, + RxJavaPlugins.onError(ex);, +++ b/src/main/java/io/reactivex/internal/observers/CallbackCompletableObserver.java, + RxJavaPlugins.onError(ex);, +++ b/src/main/java/io/reactivex/observers/DisposableObserver.java, + * <p>Use the public {@link #dispose()} method to dispose the sequence from within an, +++ b/src/main/java/io/reactivex/internal/observers/CallbackCompletableObserver.java, + RxJavaPlugins.onError(ex);, +++ b/src/main/java/io/reactivex/observers/DisposableObserver.java, + * <p>Use the public {@link #dispose()} method to dispose the sequence from within an, +++ b/src/main/java/io/reactivex/observers/ResourceCompletableObserver.java, + * <p>Use the public {@link #dispose()} method to dispose the sequence externally and release, +++ b/src/main/java/io/reactivex/internal/observers/CallbackCompletableObserver.java, + RxJavaPlugins.onError(ex);, +++ b/src/main/java/io/reactivex/observers/DisposableObserver.java, + * <p>Use the public {@link #dispose()} method to dispose the sequence from within an, +++ b/src/main/java/io/reactivex/observers/ResourceCompletableObserver.java, + * <p>Use the public {@link #dispose()} method to dispose the sequence externally
[+++ b/gradle.properties, +version=0.17.0-RC5-SNAPSHOT, +++ b/gradle.properties, +version=0.17.0-RC5-SNAPSHOT, +++ b/rxjava-contrib/rxjava-debug/src/main/java/rx/operators/DebugSubscriber.java, +import rx.functions.Action2;, +public final class DebugSubscriber<T, C> extends Subscriber<T> {, + private final Func1<DebugNotification, C> start;, + private final Action1<C> complete;, + private final Action2<C, Throwable> error;, + private final Observer<? super T> o;, + private Operator<? extends T, ?> from = null;, + private Operator<?, ? super T> to = null;, + Func1<DebugNotification, C> start,, + Action1<C> complete,, + Action2<C, Throwable> error,, + this.start = start;, + this.complete = complete;, + this.error = error;, + this.add(new DebugSubscription<T, C>(this, start, complete, error));, + final DebugNotification<T, C> n = DebugNotification.createOnCompleted(o, from, to);,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationThrottleLast;, + * Throttles to last value in each window., + public Observable<T> throttleLast(long timeout, TimeUnit unit) {, + return create(OperationThrottleLast.throttleLast(this, timeout, unit));, + * Throttles to last value in each window., + public Observable<T> throttleLast(long timeout, TimeUnit unit, Scheduler scheduler) {, + return create(OperationThrottleLast.throttleLast(this, timeout, unit, scheduler));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationThrottleLast;, + * Throttles to last value in each window., + public Observable<T> throttleLast(long timeout, TimeUnit unit) {, + return create(OperationThrottleLast.throttleLast(this, timeout, unit));, + * Throttles to last value in each window., + public Observable<T> throttleLast(long timeout, TimeUnit unit, Scheduler scheduler) {, + return create(OperationThrottleLast.throttleLast(this,
[+++ b/gradle.properties, +version=0.17.0-SNAPSHOT]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, + return lift(new OperatorWindowWithObservable<T, TClosing>(closingSelector));, + return lift(new OperatorWindowWithSize<T>(count, count));, + return lift(new OperatorWindowWithSize<T>(count, skip));, + return lift(new OperatorWindowWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, Schedulers.computation()));, + return lift(new OperatorWindowWithTime<T>(timespan, timeshift, unit, Integer.MAX_VALUE, scheduler));, + return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, Schedulers.computation()));, + return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, count, Schedulers.computation()));, + return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, count, scheduler));, + return lift(new OperatorWindowWithTime<T>(timespan, timespan, unit, Integer.MAX_VALUE, scheduler));, + return lift(new OperatorWindowWithStartEndObservable<T, TOpening, TClosing>(windowOpenings, closingSelector));, + return lift(new OperatorWindowWithObservable<T, U>(boundary));, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return lift(new OperatorWindowWithObservable<T, TClosing>(closingSelector));, + return lift(new OperatorWindowWithSize<T>(count, count));, + return lift(new OperatorWindowWithSize<T>(count, skip));, + return lift(new OperatorWindowWithTime<T>(timespan, timeshift,
[+++ b/gradle.properties, +version=0.14.5]
[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subscriber.scala, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subscriber.scala, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/ObservableTest.scala, + /*, + val observer = mock(classOf[Observer[Int]]), + val o = Observable().head, + val sub = o.subscribe(observer), + verify(observer, never).onNext(any(classOf[Int])), + verify(observer, never).onCompleted(), + verify(observer, times(1)).onError(any(classOf[NoSuchElementException])), + */, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subscriber.scala, +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/ObservableTest.scala, + /*, + val observer = mock(classOf[Observer[Int]]), + val o = Observable().head, + val sub = o.subscribe(observer), + verify(observer, never).onNext(any(classOf[Int])), + verify(observer, never).onCompleted(), + verify(observer, times(1)).onError(any(classOf[NoSuchElementException])), + */, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import
[+++ b/gradle.properties, +version=0.20.0-RC4-SNAPSHOT]
[+++ b/.travis.yml]
[+++ b/src/main/java/io/reactivex/Observable.java, +import io.reactivex.annotations.*;, + /** The default buffer size. */, + /** An empty observable instance as there is no need to instantiate this more than once. */, + /** A never observable instance as there is no need to instantiate this more than once. */, + @BackpressureSupport(BackpressureKind.FULL), + @SchedulerSupport(SchedulerKind.NONE), + @BackpressureSupport(BackpressureKind.FULL), + @SchedulerSupport(SchedulerKind.NONE), + @BackpressureSupport(BackpressureKind.FULL), + @SchedulerSupport(SchedulerKind.NONE), + @BackpressureSupport(BackpressureKind.FULL), + @SchedulerSupport(SchedulerKind.NONE), + @BackpressureSupport(BackpressureKind.FULL), + @SchedulerSupport(SchedulerKind.NONE), + @BackpressureSupport(BackpressureKind.FULL), + @SchedulerSupport(SchedulerKind.NONE), + @BackpressureSupport(BackpressureKind.FULL), + @SchedulerSupport(SchedulerKind.NONE), + @BackpressureSupport(BackpressureKind.FULL), + @SchedulerSupport(SchedulerKind.NONE), + @BackpressureSupport(BackpressureKind.FULL), + @SchedulerSupport(SchedulerKind.NONE), + @BackpressureSupport(BackpressureKind.FULL), + @SchedulerSupport(SchedulerKind.NONE), + @BackpressureSupport(BackpressureKind.FULL), + @SchedulerSupport(SchedulerKind.NONE), + @BackpressureSupport(BackpressureKind.FULL), + @SchedulerSupport(SchedulerKind.NONE), + @BackpressureSupport(BackpressureKind.FULL), + @SchedulerSupport(SchedulerKind.NONE),
[+++ b/rxjava-contrib/rxjava-android/build.gradle, + exclude "rx/android/testsupport", + //Excluding the test support directory causes an error when generating docs, + failOnError false;, + windowTitle = "RxJava Android Javadoc ${project.version}", + options.addStringOption('top').value = '<h2 class="title" style="padding-top:40px">RxJava Android</h2>', + exclude "rx/android/testsupport", +, +++ b/rxjava-contrib/rxjava-android/build.gradle, + exclude "rx/android/testsupport", + //Excluding the test support directory causes an error when generating docs, + failOnError false;, + windowTitle = "RxJava Android Javadoc ${project.version}", + options.addStringOption('top').value = '<h2 class="title" style="padding-top:40px">RxJava Android</h2>', + exclude "rx/android/testsupport", +, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/concurrency/AndroidSchedulers.java, +package rx.android.concurrency;, +, +import android.os.Handler;, +import android.os.Looper;, +import rx.Scheduler;, +, +/**, + * Schedulers that have Android specific functionality, + */,
[+++ b/src/main/java/io/reactivex/Observable.java, + * <img width="640" height="315" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingIterable.o.png" alt="">, + * <img width="640" height="350" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingLatest.o.png" alt="">, + * <p>]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java, + boolean callError = false;, + dq.pollLast();, + dq.poll();, + callError = true;, + } else if(callError) {, + } else {, + drain();, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategy.java, + boolean callError = false;, + dq.pollLast();, + dq.poll();, + callError = true;, + } else if(callError) {, + } else {, + drain();, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableOnBackpressureBufferStrategyTest.java, +/**, + * Copyright 2016 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorGroupBy;, +import rx.operators.OperatorTakeUntil;, +import rx.operators.OperatorToIterator;, + return OperatorTakeUntil.takeUntil(source, other);, + return create(OperatorGroupBy.groupBy(source, keySelector, elementSelector));, + return create(OperatorGroupBy.groupBy(source, keySelector));, + return OperatorToIterator.toIterator(that);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorGroupBy;, +import rx.operators.OperatorTakeUntil;, +import rx.operators.OperatorToIterator;, + return OperatorTakeUntil.takeUntil(source, other);, + return create(OperatorGroupBy.groupBy(source, keySelector, elementSelector));, + return create(OperatorGroupBy.groupBy(source, keySelector));, + return OperatorToIterator.toIterator(that);, +++ b/rxjava-core/src/main/java/rx/Scheduler.java, + * Schedules an action to be executed in dueTime., + Subscription schedule(Action0 action, long dueTime, TimeUnit unit);, + * Schedules a cancelable action to be executed in dueTime., + Subscription schedule(Func0<Subscription> action, long dueTime, TimeUnit unit);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorGroupBy;, +import rx.operators.OperatorTakeUntil;, +import rx.operators.OperatorToIterator;, + return OperatorTakeUntil.takeUntil(source, other);,
[+++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.operators.maybe.MaybeFromPublisher;, + @BackpressureSupport(BackpressureKind.UNBOUNDED_IN), + @SchedulerSupport(SchedulerSupport.NONE), + public final Maybe<T> toMaybe() {, + return new MaybeFromPublisher<T>(this);, + }, +, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.operators.maybe.MaybeFromPublisher;, + @BackpressureSupport(BackpressureKind.UNBOUNDED_IN), + @SchedulerSupport(SchedulerSupport.NONE), + public final Maybe<T> toMaybe() {, + return new MaybeFromPublisher<T>(this);, + }, +, +++ b/src/main/java/io/reactivex/Maybe.java, +/**, + * Copyright 2016 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + *
[+++ b/CHANGES.md, +### Version 0.16.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.16.1%22)) ###, +, +* [Pull 730](https://github.com/Netflix/RxJava/pull/730) Improve Error Handling and Stacktraces When Unsubscribe Fails, +* [Pull 720](https://github.com/Netflix/RxJava/pull/720) Added `Observable.timeout` wrappers to scala adapter, +* [Pull 731](https://github.com/Netflix/RxJava/pull/731) Fix non-deterministic unit test, +* [Pull 742](https://github.com/Netflix/RxJava/pull/742) Build with Gradle 1.10, +* [Pull 718](https://github.com/Netflix/RxJava/pull/718) Merge overloads, +* [Pull 733](https://github.com/Netflix/RxJava/pull/733) Buffer with Observable boundary, +* [Pull 734](https://github.com/Netflix/RxJava/pull/734) Delay with subscription and item delaying observables, +* [Pull 735](https://github.com/Netflix/RxJava/pull/735) Window with Observable boundary, +* [Pull 736](https://github.com/Netflix/RxJava/pull/736) MergeMap with Iterable and resultSelector overloads, +* [Pull 738](https://github.com/Netflix/RxJava/pull/738) Publish and PublishLast overloads, +* [Pull 739](https://github.com/Netflix/RxJava/pull/739) Debounce with selector, +* [Pull 740](https://github.com/Netflix/RxJava/pull/740) Timeout with
[+++ b/gradle.properties, +version=0.15.1]
[+++ b/src/main/java/io/reactivex/internal/operators/single/SingleTakeUntil.java, + parent.otherError(new CancellationException());, + if (get() != SubscriptionHelper.CANCELLED) {, + lazySet(SubscriptionHelper.CANCELLED);, + }, +++ b/src/main/java/io/reactivex/internal/operators/single/SingleTakeUntil.java, + parent.otherError(new CancellationException());, + if (get() != SubscriptionHelper.CANCELLED) {, + lazySet(SubscriptionHelper.CANCELLED);, + }, +++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeTakeUntilPublisherTest.java, +, + @Test, + public void otherSignalsAndCompletes() {, + List<Throwable> errors = TestHelper.trackPluginErrors();, + try {, + Maybe.just(1).takeUntil(Flowable.just(1).take(1)), + .test(), + .assertResult();, +, + assertTrue(errors.toString(), errors.isEmpty());, + } finally {, + RxJavaPlugins.reset();, + }, + }, +++ b/src/main/java/io/reactivex/internal/operators/single/SingleTakeUntil.java, + parent.otherError(new CancellationException());, + if (get() != SubscriptionHelper.CANCELLED) {, + lazySet(SubscriptionHelper.CANCELLED);, + }, +++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeTakeUntilPublisherTest.java, +, + @Test, + public void otherSignalsAndCompletes() {, + List<Throwable> errors = TestHelper.trackPluginErrors();, +
[+++ b/CHANGES.md, +### Version 0.14.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.2%22)) ###, +, +* [Pull 403](https://github.com/Netflix/RxJava/pull/403) Operators: Cast and OfType, +* [Pull 401](https://github.com/Netflix/RxJava/pull/401) Operator: DefaultIfEmpty, +* [Pull 409](https://github.com/Netflix/RxJava/pull/409) Operator: Synchronize with object, +, +++ b/CHANGES.md, +### Version 0.14.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.2%22)) ###, +, +* [Pull 403](https://github.com/Netflix/RxJava/pull/403) Operators: Cast and OfType, +* [Pull 401](https://github.com/Netflix/RxJava/pull/401) Operator: DefaultIfEmpty, +* [Pull 409](https://github.com/Netflix/RxJava/pull/409) Operator: Synchronize with object, +, +++ b/gradle.properties, +version=0.14.3-SNAPSHOT]
[+++ b/src/test/java/io/reactivex/processors/AsyncProcessorTest.java, + AsyncProcessor<String> processor = AsyncProcessor.create();, + processor.subscribe(observer);, + processor.onNext("one");, + processor.onNext("two");, + processor.onNext("three");, + AsyncProcessor<String> processor = AsyncProcessor.create();, + processor.subscribe(observer);, + processor.onNext("one");, + processor.onNext("two");, + processor.onNext("three");, + processor.onComplete();, + AsyncProcessor<String> processor = AsyncProcessor.create();, + processor.subscribe(observer);, + processor.onNext(null);, + processor.onComplete();, + AsyncProcessor<String> processor = AsyncProcessor.create();, + processor.onNext("one");, + processor.onNext("two");, + processor.onNext("three");, + processor.onComplete();, + processor.subscribe(observer);, + AsyncProcessor<String> processor = AsyncProcessor.create();, + processor.onNext("one");, + processor.onNext("two");, + processor.onNext("three");, + processor.onError(re);, + processor.subscribe(observer);, + AsyncProcessor<String> processor = AsyncProcessor.create();, + processor.subscribe(observer);, + processor.onNext("one");, + processor.onNext("two");, + processor.onNext("three");, + processor.onError(testException);, + processor.onNext("four");, + processor.onError(new Throwable());, + processor.onComplete();, + AsyncProcessor<String> processor = AsyncProcessor.create();, +
[+++ b/src/test/java/io/reactivex/maybe/MaybeCreateTest.java, +import java.util.List;, +, +import io.reactivex.plugins.RxJavaPlugins;, + List<Throwable> errors = TestHelper.trackPluginErrors();, + try {, + TestHelper.assertUndeliverable(errors, 0, TestException.class);, + } finally {, + RxJavaPlugins.reset();, + }, + List<Throwable> errors = TestHelper.trackPluginErrors();, + try {, +, + TestHelper.assertUndeliverable(errors, 0, TestException.class);, + } finally {, + RxJavaPlugins.reset();, + }, + List<Throwable> errors = TestHelper.trackPluginErrors();, + try {, +, + TestHelper.assertUndeliverable(errors, 0, TestException.class);, + } finally {, + RxJavaPlugins.reset();, + }, + List<Throwable> errors = TestHelper.trackPluginErrors();, + try {, +, + TestHelper.assertUndeliverable(errors, 0, TestException.class);, + } finally {, + RxJavaPlugins.reset();, + }, +++ b/src/test/java/io/reactivex/maybe/MaybeCreateTest.java, +import java.util.List;, +, +import io.reactivex.plugins.RxJavaPlugins;, + List<Throwable>
[+++ b/src/main/java/io/reactivex/internal/util/VolatileSizeArrayList.java, +public final class VolatileSizeArrayList<T> extends AtomicInteger implements List<T>, RandomAccess {]
[+++ b/src/jmh/java/io/reactivex/BinaryFlatMapPerf.java, +/**, + * Copyright (c) 2016-present, RxJava Contributors., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language
[+++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/TestSchedulerExample.scala, +import scala.concurrent.duration._, +import scala.language.postfixOps, +import rx.lang.scala.{ Observable, Observer }, +import rx.lang.scala.concurrency.TestScheduler, + import org.mockito.Matchers._, + import org.mockito.Mockito._, +, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/TestSchedulerExample.scala, +import scala.concurrent.duration._, +import scala.language.postfixOps, +import rx.lang.scala.{ Observable, Observer }, +import rx.lang.scala.concurrency.TestScheduler, + import org.mockito.Matchers._, + import org.mockito.Mockito._, +, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, + implicit def toJavaNotification[T](s: Notification[T]): rx.Notification[_ <:
[+++ b/src/main/java/io/reactivex/Flowable.java, + * @return a Flowable which nulls out references to the upstream producer and downstream Subscriber if, +++ b/src/main/java/io/reactivex/Flowable.java, + * @return a Flowable which nulls out references to the upstream producer and downstream Subscriber if, +++ b/src/main/java/io/reactivex/Observable.java, + * @return an Observable which nulls out references to the upstream producer and downstream Observer if]
[+++ b/CHANGES.md, +### Version 0.14.11 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.11%22)) ###, +, +* [Pull 486](https://github.com/Netflix/RxJava/pull/486) BugFix: AsyncSubject, +* [Pull 483](https://github.com/Netflix/RxJava/pull/483) Tweaks to DoOnEach and added DoOnError/DoOnCompleted, +, +This has a very slight breaking change by removing one `doOnEach` overload. The version was not bumped from 0.14 to 0.15 as it is so minor and the offending method was just released in the previous version., +, +++ b/CHANGES.md, +### Version 0.14.11 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.11%22)) ###, +, +* [Pull 486](https://github.com/Netflix/RxJava/pull/486) BugFix: AsyncSubject, +* [Pull 483](https://github.com/Netflix/RxJava/pull/483) Tweaks to DoOnEach and added DoOnError/DoOnCompleted, +, +This has a very slight breaking change by removing one `doOnEach` overload. The
[+++ b/src/main/java/io/reactivex/Observable.java, + * @throws NullPointerException, + * if {@code unit} is null, or, + * if {@code scheduler} is null, +++ b/src/main/java/io/reactivex/Observable.java, + * @throws NullPointerException, + * if {@code unit} is null, or, + * if {@code scheduler} is null, +++ b/src/test/java/io/reactivex/internal/functions/ObjectHelperTest.java, + public void verifyPositiveInt() throws Exception{, + assertEquals(1, ObjectHelper.verifyPositive(1, "param"));, + }, + @Test, + public void verifyPositiveLong() throws Exception{, + assertEquals(1L, ObjectHelper.verifyPositive(1L, "param"));, + }, +, + @Test(expected = IllegalArgumentException.class), + public void verifyPositiveIntFail() throws Exception{, + assertEquals(-1, ObjectHelper.verifyPositive(-1, "param"));, + }, +, + @Test(expected = IllegalArgumentException.class), + public void verifyPositiveLongFail() throws Exception{, +
[+++ b/src/main/java/io/reactivex/Observable.java, + return RxJavaPlugins.onAssembly(new ObservableRedo<T>(this, ObservableInternalHelper.repeatWhenHandler(handler), false));, + return RxJavaPlugins.onAssembly(new ObservableRedo<T>(this, ObservableInternalHelper.retryWhenHandler(handler), true));, +++ b/src/main/java/io/reactivex/Observable.java, + return RxJavaPlugins.onAssembly(new ObservableRedo<T>(this, ObservableInternalHelper.repeatWhenHandler(handler), false));, + return RxJavaPlugins.onAssembly(new ObservableRedo<T>(this, ObservableInternalHelper.retryWhenHandler(handler), true));, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableRedo.java, + final boolean retryMode;, +, + Function<? super Observable<Notification<Object>>, ? extends ObservableSource<?>> manager,, + boolean retryMode) {, + this.retryMode = retryMode;, + final RedoObserver<T> parent = new RedoObserver<T>(s, subject, source, retryMode);, + final boolean retryMode;, +, + RedoObserver(Observer<? super T> actual, Subject<Notification<Object>> subject, ObservableSource<? extends T> source, boolean retryMode) {, + this.retryMode = retryMode;, + if (retryMode) {, + } else {, + subject.onError(t);, + }, + if (retryMode)
[+++ b/build.gradle, +apply from: file('gradle/convention.gradle'), +apply from: file('gradle/maven.gradle'), +//apply from: file('gradle/check.gradle'), +apply from: file('gradle/license.gradle'), +apply from: file('gradle/release.gradle'), +, + apply plugin: 'java', + apply plugin: 'eclipse', + apply plugin: 'idea', + // make 'examples' use the same classpath, + configurations { , + examplesCompile.extendsFrom compile, + examplesRuntime.extendsFrom runtime, + }, +, +, + //include /src/examples folder, + sourceSets { , + examples, + }, + , + //include 'examples' in build task, + tasks.build { , + dependsOn(examplesClasses), + }, + , + eclipse { , + classpath { , + // include 'provided' dependencies on the classpath, +
[+++ b/src/main/java/io/reactivex/Maybe.java, + * Returns a {@link Maybe} that invokes the given {@link Callable} for each individual {@link MaybeObserver} that, + * subscribes and emits the resulting non-null item via {@code onSuccess} while, + * considering a {@code null} result from the {@code Callable} as indication for valueless completion, + * via {@code onComplete}., + * This operator allows you to defer the execution of the given {@code Callable} until a {@code MaybeObserver}, + * subscribes to the returned {@link Maybe}. In other terms, this source operator evaluates the given, + * {@code Callable} "lazily"., + * <p>, +
[+++ b/src/main/java/io/reactivex/Completable.java, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, + @CheckReturnValue, +
[+++ b/src/main/java/io/reactivex/Single.java, + * where that function returns an ObservableSource.]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * If time runs out before the {@code Flowable} completes normally, the {@code onComplete} event will be, + * signaled on the default {@code computation} {@link Scheduler}., + * <p>, + * If time runs out before the {@code Flowable} completes normally, the {@code onComplete} event will be, + * signaled on the provided {@link Scheduler}., + * <p>, +++ b/src/main/java/io/reactivex/Flowable.java, + * If time runs out before the {@code Flowable} completes normally, the {@code onComplete} event will be, + * signaled on the default {@code computation} {@link Scheduler}., + * <p>, + * If time
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/rxjava-core/src/test/java/rx/operators/OperatorFirstTest.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS
[+++ b/gradle.properties, +version=0.8.2-SNAPSHOT, +++ b/gradle.properties, +version=0.8.2-SNAPSHOT, +++ b/language-adaptors/rxjava-clojure/build.gradle, + provided 'junit:junit-dep:4.10', +++ b/gradle.properties, +version=0.8.2-SNAPSHOT, +++ b/language-adaptors/rxjava-clojure/build.gradle, + provided 'junit:junit-dep:4.10', +++ b/language-adaptors/rxjava-groovy/build.gradle, + provided 'junit:junit-dep:4.10', +++ b/gradle.properties, +version=0.8.2-SNAPSHOT, +++ b/language-adaptors/rxjava-clojure/build.gradle, + provided 'junit:junit-dep:4.10', +++ b/language-adaptors/rxjava-groovy/build.gradle, + provided 'junit:junit-dep:4.10', +++ b/language-adaptors/rxjava-jruby/build.gradle, + provided 'junit:junit-dep:4.10', +++ b/gradle.properties, +version=0.8.2-SNAPSHOT, +++ b/language-adaptors/rxjava-clojure/build.gradle, + provided 'junit:junit-dep:4.10', +++ b/language-adaptors/rxjava-groovy/build.gradle, + provided 'junit:junit-dep:4.10', +++ b/language-adaptors/rxjava-jruby/build.gradle, + provided 'junit:junit-dep:4.10', +++ b/language-adaptors/rxjava-scala/build.gradle, + provided 'junit:junit-dep:4.10', +++ b/gradle.properties, +version=0.8.2-SNAPSHOT, +++ b/language-adaptors/rxjava-clojure/build.gradle, + provided 'junit:junit-dep:4.10', +++ b/language-adaptors/rxjava-groovy/build.gradle, + provided 'junit:junit-dep:4.10', +++ b/language-adaptors/rxjava-jruby/build.gradle, + provided 'junit:junit-dep:4.10', +++ b/language-adaptors/rxjava-scala/build.gradle, + provided 'junit:junit-dep:4.10', +++ b/rxjava-contrib/rxjava-swing/build.gradle, + provided 'junit:junit-dep:4.10', +++ b/gradle.properties, +version=0.8.2-SNAPSHOT, +++ b/language-adaptors/rxjava-clojure/build.gradle, +
[+++ b/src/main/java/io/reactivex/Completable.java, + * DisposableCompletableObserver ds = new DisposableCompletableObserver() {, + * };, + * composite.add(source.subscribeWith(ds));, +++ b/src/main/java/io/reactivex/Completable.java, + * DisposableCompletableObserver ds = new DisposableCompletableObserver() {, + * };, + * composite.add(source.subscribeWith(ds));, +++ b/src/main/java/io/reactivex/Maybe.java, + * DisposableMaybeObserver&lt;Integer&gt; ds = new DisposableMaybeObserver&lt;&gt;() {, + * composite.add(source.subscribeWith(ds));, +++ b/src/main/java/io/reactivex/Completable.java, + * DisposableCompletableObserver ds = new DisposableCompletableObserver() {, + * };, + * composite.add(source.subscribeWith(ds));, +++ b/src/main/java/io/reactivex/Maybe.java, + * DisposableMaybeObserver&lt;Integer&gt; ds = new DisposableMaybeObserver&lt;&gt;() {, + * composite.add(source.subscribeWith(ds));, +++ b/src/main/java/io/reactivex/Observable.java, + * DisposableObserver&lt;Integer&gt; ds = new DisposableObserver&lt;&gt;() {, + * composite.add(source.subscribeWith(ds));, +++ b/src/main/java/io/reactivex/Completable.java, + * DisposableCompletableObserver ds = new DisposableCompletableObserver() {, + *
[+++ b/.gitignore, +++ b/.gitignore, +++ b/CHANGES.md, +++ b/.gitignore, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.17.3-SNAPSHOT, +++ b/.gitignore, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.17.3-SNAPSHOT, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, + android:name=".UIBindingActivity">, +, + <intent-filter>, + <category android:name="android.intent.category.LAUNCHER"/>, + <category android:name="android.intent.category.DEFAULT"/>, + <action android:name="android.intent.action.MAIN"/>, + </intent-filter>, + </activity>, + <activity, +++ b/.gitignore, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.17.3-SNAPSHOT, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, + android:name=".UIBindingActivity">, +, + <intent-filter>, + <category android:name="android.intent.category.LAUNCHER"/>, + <category android:name="android.intent.category.DEFAULT"/>, + <action android:name="android.intent.action.MAIN"/>, + </intent-filter>, + </activity>, + <activity, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/UIBindingActivity.java, +package com.netflix.rxjava.android.samples;, +, +import android.app.Activity;, +import android.app.Fragment;, +import android.os.Bundle;, +import android.view.LayoutInflater;, +import android.view.View;, +import android.view.ViewGroup;, +import android.view.Window;, +import android.widget.Button;, +import android.widget.TextView;, +import org.json.JSONException;, +import org.json.JSONObject;, +import
[+++ b/src/test/java/io/reactivex/exceptions/ExceptionsTest.java, + @Test, + public void errorNotImplementedNull1() {, + OnErrorNotImplementedException ex = new OnErrorNotImplementedException(null);, +, + assertTrue("" + ex.getCause(), ex.getCause() instanceof NullPointerException);, + }, +, + @Test, + public void errorNotImplementedNull2() {, + OnErrorNotImplementedException ex = new OnErrorNotImplementedException("Message", null);, +, + assertTrue("" + ex.getCause(), ex.getCause() instanceof NullPointerException);, + }, +, + @Test, + public void errorNotImplementedWithCause() {, + OnErrorNotImplementedException ex = new OnErrorNotImplementedException("Message", new TestException("Forced failure"));, +, + assertTrue("" + ex.getCause(), ex.getCause() instanceof TestException);, +, + assertEquals("" + ex.getCause(), "Forced failure", ex.getCause().getMessage());, + }, +++ b/src/test/java/io/reactivex/exceptions/ExceptionsTest.java, + @Test, + public void errorNotImplementedNull1() {, + OnErrorNotImplementedException ex = new
[+++ b/src/main/java/io/reactivex/Single.java, + * <p>, + * <img width="640" height="319" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concat.i.png" alt="">, + * <p>, + * <img width="640" height="319" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concat.o.png" alt="">, + * <p>, + * <img width="640" height="308" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concat.p.png" alt="">, + * <p>, + * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concat.pn.png" alt="">, + * <img width="640" height="366" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concat.png" alt="">, + * <img width="640" height="366" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concat.o3.png" alt="">, + * <img width="640" height="362" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concat.o4.png" alt="">, + * <p>, + * <img width="640" height="319" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatArray.png" alt="">]
[+++ b/src/main/java/io/reactivex/Maybe.java, + * Calls the specified consumer with the success item after this item has been emitted to the downstream., + * <p>Note that the {@code onAfterNext} action is shared between subscriptions and as such, + * should be thread-safe., + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code doAfterSuccess} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + * @param onAfterSuccess the Consumer that will be called after emitting an item from upstream to the downstream, + * @return the new Maybe instance, + * @since 2.0.1 - experimental, + */, +
[+++ /dev/null, +++ /dev/null, +++ b/src/test/java/rx/internal/operators/BufferUntilSubscriberTest.java, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + *
[+++ b/src/main/java/io/reactivex/Completable.java, + * <dd>If any of the source {@code CompletableSource}s signal a {@code Throwable} via {@code onError}, the resulting, + * {@code Completable} terminates with that {@code Throwable} and all other source {@code CompletableSource}s are cancelled., + * If more than one {@code CompletableSource} signals an error, the resulting {@code Completable} may terminate with the, + * first one's error or, depending on the concurrency of the sources, may terminate with a, + * {@code CompositeException} containing two or more of the various error signals., + * {@code Throwable}s that didn't make into the composite will be sent
[+++ /dev/null, +++ /dev/null, +++ b/rxjava-contrib/rxjava-joins/src/main/java/rx/joins/operators/OperatorJoinPatterns.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not, + * use this file except in compliance with the License. You may obtain a copy of, + * the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT, + * WARRANTIES OR CONDITIONS OF ANY KIND, either express or
[+++ b/codequality/HEADER, +++ b/codequality/HEADER, +++ b/template-client/.classpath, +<?xml version="1.0" encoding="UTF-8"?>, +<classpath>, + <classpathentry kind="src" path="src/main/java"/>, + <classpathentry kind="src" path="src/test/java"/>, + <classpathentry exported="true" kind="con" path="GROOVY_DSL_SUPPORT"/>, + <classpathentry kind="con" path="GROOVY_SUPPORT"/>, + <classpathentry exported="true" kind="con" path="com.springsource.sts.gradle.classpathcontainer"/>, + <classpathentry kind="con" path="com.springsource.sts.gradle.dsld.classpathcontainer"/>, + <classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>, + <classpathentry kind="output" path="bin"/>, +</classpath>, +++ b/codequality/HEADER, +++ b/template-client/.classpath, +<?xml version="1.0" encoding="UTF-8"?>, +<classpath>, + <classpathentry kind="src" path="src/main/java"/>, + <classpathentry kind="src" path="src/test/java"/>, + <classpathentry exported="true" kind="con" path="GROOVY_DSL_SUPPORT"/>, + <classpathentry kind="con" path="GROOVY_SUPPORT"/>, + <classpathentry exported="true" kind="con" path="com.springsource.sts.gradle.classpathcontainer"/>, + <classpathentry kind="con" path="com.springsource.sts.gradle.dsld.classpathcontainer"/>, + <classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>, + <classpathentry kind="output" path="bin"/>, +</classpath>, +++ b/template-client/.project, +<?xml version="1.0" encoding="UTF-8"?>, +<projectDescription>, + <name>template-client</name>, + <comment></comment>, +
[+++ b/rxjava-contrib/rxjava-android-samples/gradle/wrapper/gradle-wrapper.properties, +#Wed Mar 12 12:09:46 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/rxjava-contrib/rxjava-android-samples/gradle/wrapper/gradle-wrapper.properties, +#Wed Mar 12 12:09:46 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, + <activity, + android:name=".ListenInOutActivity">, +, + <intent-filter>, + <category android:name="android.intent.category.LAUNCHER"/>, + <category android:name="android.intent.category.DEFAULT"/>, + <action android:name="android.intent.action.MAIN"/>, + </intent-filter>, + </activity>, +++ b/rxjava-contrib/rxjava-android-samples/gradle/wrapper/gradle-wrapper.properties, +#Wed Mar 12 12:09:46 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, + <activity, + android:name=".ListenInOutActivity">, +, + <intent-filter>, + <category android:name="android.intent.category.LAUNCHER"/>, + <category android:name="android.intent.category.DEFAULT"/>, + <action android:name="android.intent.action.MAIN"/>, + </intent-filter>, + </activity>, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/ListenInOutActivity.java, +package com.netflix.rxjava.android.samples;, +, +import android.app.Activity;, +import android.os.Bundle;, +import android.view.View;, +import android.widget.TextView;, +import android.widget.Toast;, +import android.widget.ToggleButton;, +, +import rx.Observable;, +import rx.Observer;, +import rx.Subscription;, +import rx.observables.ConnectableObservable;, +, +import
[+++ b/classes/production/rxjava-core/rx/operators/README.txt, +This package "rx.operators" is for internal implementation details and can change at any time., +, +It is excluded from the public Javadocs (http://netflix.github.io/RxJava/javadoc/) and should not be relied upon by any code., +, +In short, changes to public signatures of these classes will not be accounted for in the versioning of RxJava., +++ b/classes/production/rxjava-core/rx/operators/README.txt, +This package "rx.operators" is for internal implementation details and can change at any time., +, +It is excluded from the public Javadocs (http://netflix.github.io/RxJava/javadoc/) and should not be relied upon by any code., +, +In short, changes to public signatures of these classes will
[+++ b/src/main/java/rx/Notification.java, +public class Notification<T> {, +++ b/src/main/java/rx/Notification.java, +public class Notification<T> {, +++ b/src/main/java/rx/Observable.java, + * @see <a href="https://github.com/ReactiveX/RxJava/wiki/Mathematical-and-Aggregate-Operators#count-and-countlong">RxJava wiki: count</a>, + * @see #countLong(), + * Returns an Observable that counts the total number of items emitted by the source Observable and emits, + * this count as a 64-bit Long., + * <p>, + * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/longCount.png" alt="">, + * <dl>, + * <dt><b>Backpressure Support:</b></dt>, + * <dd>This operator does not support backpressure because by intent it will receive all values and reduce, + * them to a single {@code onNext}.</dd>, + * <dt><b>Scheduler:</b></dt>, +
[+++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.internal.operators.single.*;, + * Maps the signal types of this Completable into a {@link Notification} of the same kind, + * and emits it as a single success value to downstream., + * <p>, + * <img width="640" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/materialize.png" alt="">, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code materialize} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + * @param <T> the intended target element type of the notification, + * @return the new Single instance, + * @since 2.2.4 - experimental, + * @see Single#dematerialize(Function), + */, + @Experimental, +
[+++ b/.gitignore, +.gradletasknamecache, +++ b/.gitignore, +.gradletasknamecache, +++ b/CHANGES.md, +### Version 0.17.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.17.2%22)) ###, +, +* [Pull 963](https://github.com/Netflix/RxJava/pull/963) A more robust JMH benchmarking set-up , +* [Pull 964](https://github.com/Netflix/RxJava/pull/964) SubjectSubscriptionManager fix., +* [Pull 970](https://github.com/Netflix/RxJava/pull/970) Notifications for the allocation averse., +* [Pull 973](https://github.com/Netflix/RxJava/pull/973) Merge - Handle Bad Observables, +* [Pull 974](https://github.com/Netflix/RxJava/pull/974) TestSubject, TestObserver and TestScheduler Improvements, +* [Pull 975](https://github.com/Netflix/RxJava/pull/975) GroupBy & Time Gap Fixes, +* [Pull 976](https://github.com/Netflix/RxJava/pull/976) parallel-merge unit test assertions, +* [Pull 977](https://github.com/Netflix/RxJava/pull/977) Dematerialize - handle non-materialized terminal events, +* [Pull 982](https://github.com/Netflix/RxJava/pull/982) Pivot Operator, +* [Pull 984](https://github.com/Netflix/RxJava/pull/984) Tests and Javadoc for Pivot, +* [Pull 966](https://github.com/Netflix/RxJava/pull/966) Reimplement the ElementAt operator and
[+++ b/src/main/java/io/reactivex/Completable.java, + * Hides the identity of this Completable and its Disposable., + * <p>Allows preventing certain identity-based, + * optimizations (fusion)., + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code hide} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + * @return the new Completable instance, + * @since 2.0.5 - experimental, + */, + @Experimental, + @CheckReturnValue, + @SchedulerSupport(SchedulerSupport.NONE), + public final Completable hide() {, + return RxJavaPlugins.onAssembly(new CompletableHide(this));, + }, +, + /**, +++ b/src/main/java/io/reactivex/Completable.java, + * Hides the identity of this Completable and its Disposable., + * <p>Allows preventing
[+++ b/CHANGES.md, +### Version 0.14.8 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.8%22)) ###, +, +* [Pull 460](https://github.com/Netflix/RxJava/pull/460) Operator: Amb, +* [Pull 466](https://github.com/Netflix/RxJava/pull/466) Refactor Unit Tests, +, +++ b/CHANGES.md, +### Version 0.14.8 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.8%22)) ###, +, +* [Pull 460](https://github.com/Netflix/RxJava/pull/460) Operator: Amb, +* [Pull 466](https://github.com/Netflix/RxJava/pull/466) Refactor Unit Tests, +, +++ b/gradle.properties, +version=0.14.9-SNAPSHOT, +++ b/CHANGES.md, +### Version 0.14.8 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.8%22)) ###, +, +* [Pull 460](https://github.com/Netflix/RxJava/pull/460) Operator: Amb, +* [Pull 466](https://github.com/Netflix/RxJava/pull/466) Refactor Unit Tests, +, +++ b/gradle.properties, +version=0.14.9-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, + * Returns either the observable sequence or an TimeoutException if timeout elapses., + * The timeout duration, + * The time unit of the timeout, + *
[+++ b/gradlew, +++ b/gradlew, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.observable, +import rx.lang.scala.concurrency.Schedulers, + i => println(s"${i}a (on thread #${Thread.currentThread().getId()})"), + i => println(s"${i}b (on thread #${Thread.currentThread().getId()})"), + o.observeOn(Schedulers.newThread).subscribe(, + i => println(s"${i}a (on thread #${Thread.currentThread().getId()})"), + o.observeOn(Schedulers.newThread).subscribe(, + i => println(s"${i}b (on thread #${Thread.currentThread().getId()})"), + println(s"$x*$x is being calculated on thread ${Thread.currentThread().getId()}"), + println(s"map() is being called on thread ${Thread.currentThread().getId()}"), + @Test def observableLikeFuture1() {, + implicit val scheduler = Schedulers.threadPoolForIO, + val o1 = observable {, + Thread.sleep(1000), + 5, + }, + val o2 = observable {, + Thread.sleep(500), + 4, + }, + Thread.sleep(500), + val t1 =
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/README.md, +++ b/CHANGES.md, +++ b/README.md, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/CHANGES.md, +++ b/README.md, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/rxjava-core/build.gradle, + compile 'com.google.code.findbugs:jsr305:2.0.0', +++ b/CHANGES.md, +++ b/README.md, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, +++ b/rxjava-core/build.gradle, + compile 'com.google.code.findbugs:jsr305:2.0.0', +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.*;, + private final boolean isTrusted;, + this(null, false);, + this(onSubscribe, false);, + }, +, + /**, + * @param onSubscribe, + * {@link Func1} to be executed when {@link #subscribe(Observer)} is called., + * @param isTrusted, + * boolean true if the <code>onSubscribe</code> function is guaranteed to conform to the correct contract and thus shortcuts can be taken., + */, +
[+++ b/gradle.properties, +version=0.14.9]
[+++ b/CHANGES.md, +### Version 0.14.3 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.3%22)) ###, +, +* [Pull 407](https://github.com/Netflix/RxJava/pull/407) Implemented RefCount Operator, +* [Pull 410](https://github.com/Netflix/RxJava/pull/410) Implemented the 'Contains' operator, +* [Pull 411](https://github.com/Netflix/RxJava/pull/411) Unit Test fix: update counter before triggering latch , +* [Pull 413](https://github.com/Netflix/RxJava/pull/413) Fixed the issues of takeLast(items, 0) and null values, +* [Pull 414](https://github.com/Netflix/RxJava/pull/414) Implemented the 'SkipLast' operator, +* [Pull 415](https://github.com/Netflix/RxJava/pull/415) Implemented the 'Empty' operator with scheduler, +* [Pull 416](https://github.com/Netflix/RxJava/pull/416) Implemented the 'Throw' operator with scheduler , +* [Pull 420](https://github.com/Netflix/RxJava/pull/420) Scala Adaptor Improvements, +* [Pull 422](https://github.com/Netflix/RxJava/pull/422) JRuby function wrapping support, +* [Pull 424](https://github.com/Netflix/RxJava/pull/424) Implemented the 'IgnoreElements' operator, +* [Pull 426](https://github.com/Netflix/RxJava/pull/426) PublishSubject ReSubscribe for publish().refCount()
[+++ b/.gitignore, +++ b/.gitignore, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscriptions.empty()!!, +++ b/.gitignore, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscriptions.empty()!!, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscriptions.empty()!!, +++ b/.gitignore, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscriptions.empty()!!, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscriptions.empty()!!, +++ b/rxjava-contrib/rxjava-android/build.gradle, + instruction 'Fragment-Host', 'com.netflix.rxjava.core', +++ b/.gitignore, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscriptions.empty()!!, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscriptions.empty()!!, +++ b/rxjava-contrib/rxjava-android/build.gradle, + instruction 'Fragment-Host', 'com.netflix.rxjava.core', +++ b/rxjava-contrib/rxjava-apache-http/build.gradle, + instruction 'Fragment-Host', 'com.netflix.rxjava.core', +++ b/.gitignore, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscriptions.empty()!!, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscriptions.empty()!!, +++ b/rxjava-contrib/rxjava-android/build.gradle, + instruction 'Fragment-Host', 'com.netflix.rxjava.core', +++ b/rxjava-contrib/rxjava-apache-http/build.gradle, + instruction 'Fragment-Host', 'com.netflix.rxjava.core', +++ b/rxjava-contrib/rxjava-async-util/build.gradle, + instruction 'Fragment-Host', 'com.netflix.rxjava.core', +++ b/.gitignore, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscriptions.empty()!!, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, +
[+++ b/src/main/java/io/reactivex/Observable.java, + return new ObservableFromSource<T>(this);, +++ b/src/main/java/io/reactivex/Observable.java, + return new ObservableFromSource<T>(this);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFromPublisher.java, + /** */, + private static final long serialVersionUID = -7306579371159152354L;, + , +++ b/src/main/java/io/reactivex/Observable.java, + return new ObservableFromSource<T>(this);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFromPublisher.java, + /** */, + private static final long serialVersionUID = -7306579371159152354L;, + , +++ b/src/main/java/io/reactivex/observers/single/SingleSerializedObserver.java, +public final class SingleSerializedObserver<T> implements SingleObserver<T> {, + final SingleObserver<? super T> actual;, + public SingleSerializedObserver(SingleObserver<? super T> actual) {, + public void onSuccess(T value) {]
[+++ b/gradle.properties, +version=2.0.0-DP0-SNAPSHOT]
[+++ b/.gitignore, +.m2, +target/, +build/, +bin/, +, +# Scala build, +*.cache, +++ b/.gitignore, +.m2, +target/, +build/, +bin/, +, +# Scala build, +*.cache, +++ b/CHANGES.md, +# RxJava Releases #, +, +### Version 0.6.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.6.1%22)) ###, +, +* [Pull 190](https://github.com/Netflix/RxJava/pull/190) Fix generics issue with materialize() that prevented chaining, +, +### Version 0.6.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.6.0%22)) ###, +, +* [Issue 154](https://github.com/Netflix/RxJava/issues/154) Add OSGi manifest headers, +* [Issue 173](https://github.com/Netflix/RxJava/issues/173) Subscription Utilities and Default Implementations, +* [Pull 184](https://github.com/Netflix/RxJava/pull/184) Convert 'last' from non-blocking to blocking to match Rx.Net (see [Issue 57](https://github.com/Netflix/RxJava/issues/57)), +, +*NOTE:* This is a version bump from 0.5 to 0.6 because [Issue 173](https://github.com/Netflix/RxJava/issues/173)
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC1-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC1-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, + // type mismatch; found : rx.Observable[java.lang.Boolean] required: rx.Observable[_ <: scala.Boolean], + // new Observable[Boolean](asJavaNotification.all(predicate)), + // it's more fun in Scala:, + this.map(predicate).foldLeft(true)(_ && _), +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC1-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, + // type mismatch; found : rx.Observable[java.lang.Boolean] required: rx.Observable[_ <: scala.Boolean], + // new Observable[Boolean](asJavaNotification.all(predicate)), + // it's more fun in Scala:, + this.map(predicate).foldLeft(true)(_ && _), +++ b/language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/ObservableTest.scala, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC1-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, + // type mismatch; found : rx.Observable[java.lang.Boolean] required: rx.Observable[_ <: scala.Boolean], + // new Observable[Boolean](asJavaNotification.all(predicate)), + //
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationFlatMap;, +import rx.operators.OperatorToObservableFuture;, + return create(OperatorToObservableFuture.toObservableFuture(future));, + return create(OperatorToObservableFuture.toObservableFuture(future, timeout, unit));, + return create(OperatorToObservableFuture.toObservableFuture(future)).subscribeOn(scheduler);, + return create(OperationFlatMap.flatMap(this, onNext, onError, onCompleted));, + return create(OperationFlatMap.flatMap(this, collectionSelector, resultSelector));, + return merge(map(OperationFlatMap.flatMapIterableFunc(collectionSelector)));, + return mergeMap(OperationFlatMap.flatMapIterableFunc(collectionSelector), resultSelector);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationFlatMap;, +import rx.operators.OperatorToObservableFuture;, + return create(OperatorToObservableFuture.toObservableFuture(future));, + return create(OperatorToObservableFuture.toObservableFuture(future, timeout, unit));, + return create(OperatorToObservableFuture.toObservableFuture(future)).subscribeOn(scheduler);, + return create(OperationFlatMap.flatMap(this, onNext, onError, onCompleted));, + return create(OperationFlatMap.flatMap(this, collectionSelector, resultSelector));, + return merge(map(OperationFlatMap.flatMapIterableFunc(collectionSelector)));, + return mergeMap(OperationFlatMap.flatMapIterableFunc(collectionSelector), resultSelector);, +++ b/rxjava-core/src/main/java/rx/operators/OperationFlatMap.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use
[+++ b/src/main/java/io/reactivex/Emitter.java, +/**, + * Copyright 2016 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the
[+++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableCreateTest.java, +import io.reactivex.functions.Cancellable;, + public void basicWithCancellable() {, + final Disposable d1 = Disposables.empty();, + final Disposable d2 = Disposables.empty();, +, + Completable.create(new CompletableOnSubscribe() {, + @Override, + public void subscribe(CompletableEmitter e) throws Exception {, + e.setDisposable(d1);, + e.setCancellable(new Cancellable() {, + @Override, + public void cancel() throws Exception {, + d2.dispose();, + }, + });, +, + e.onComplete();, + e.onError(new TestException());, + e.onComplete();, + }, + }), + .test(), + .assertResult();, +, + assertTrue(d1.isDisposed());, + assertTrue(d2.isDisposed());, + }, +, + @Test, +++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableCreateTest.java, +import io.reactivex.functions.Cancellable;, + public void basicWithCancellable() {, + final Disposable d1 = Disposables.empty();, +
[+++ b/gradle.properties, +version=0.14.0-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Observable.java, + if (count < 0) {, + throw new IllegalArgumentException("count >= required but it was " + count);, + } else, +++ b/src/main/java/io/reactivex/Observable.java, + if (count < 0) {, + throw new IllegalArgumentException("count >= required but it was " + count);, + } else, +++ b/src/main/java/io/reactivex/internal/operators/OperatorFlatMap.java, +++ b/src/main/java/io/reactivex/Observable.java, + if (count < 0) {, + throw new IllegalArgumentException("count >= required but it was " + count);, + } else, +++ b/src/main/java/io/reactivex/internal/operators/OperatorFlatMap.java, +++ b/src/main/java/io/reactivex/internal/operators/OperatorPublish.java, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + volatile Subscription s;, + static final AtomicReferenceFieldUpdater<PublishSubscriber, Subscription> S =, + AtomicReferenceFieldUpdater.newUpdater(PublishSubscriber.class, Subscription.class, "s");, + , + static final Subscription CANCELLED
[+++ b/.gitignore, +/.nb-gradle/profiles/private/, +.nb-gradle-properties, +/.nb-gradle/private/, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +.nb-gradle-properties, +/.nb-gradle/private/, +++ b/CHANGES.md, +### Version 0.17.4 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.17.4%22)) ###, +, +* [Pull 990] (https://github.com/Netflix/RxJava/pull/990) Quasar Lightweight Threads/Fibers Contrib Module, +* [Pull 1012] (https://github.com/Netflix/RxJava/pull/1012) SerializedObserver: Removed window between the two synchronized blocks, +, +, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +.nb-gradle-properties, +/.nb-gradle/private/, +++ b/CHANGES.md, +### Version 0.17.4 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.17.4%22)) ###, +, +* [Pull 990] (https://github.com/Netflix/RxJava/pull/990) Quasar Lightweight Threads/Fibers Contrib Module, +* [Pull 1012] (https://github.com/Netflix/RxJava/pull/1012) SerializedObserver: Removed window between the two synchronized blocks, +, +, +++ b/gradle.properties, +version=0.17.5-SNAPSHOT, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +.nb-gradle-properties, +/.nb-gradle/private/, +++ b/CHANGES.md, +### Version 0.17.4 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.17.4%22)) ###, +, +* [Pull 990]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRedo.java, +import io.reactivex.processors.*;, + FlowProcessor<Try<Optional<Object>>> subject = BehaviorProcessor.<Try<Optional<Object>>>create().toSerialized();, + final FlowProcessor<Try<Optional<Object>>> subject;, + public RedoSubscriber(Subscriber<? super T> actual, FlowProcessor<Try<Optional<Object>>> subject, Publisher<? extends T> source) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableRedo.java, +import io.reactivex.processors.*;, + FlowProcessor<Try<Optional<Object>>> subject = BehaviorProcessor.<Try<Optional<Object>>>create().toSerialized();, + final FlowProcessor<Try<Optional<Object>>> subject;, + public RedoSubscriber(Subscriber<? super T> actual, FlowProcessor<Try<Optional<Object>>> subject, Publisher<? extends T> source) {, +++ b/src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java, + , + if (decrementAndGet() != 0) {, + drainLoop();, + }, +, +, + if (decrementAndGet() != 0) {, + drainLoop();, + }, +, + long requestAmount = 0L;, + Subscription requestTarget = null;, + , + requestAmount = BackpressureHelper.addCap(requestAmount, r);, + requestTarget =
[+++ b/src/main/java/io/reactivex/Flowable.java, + return new FlowableDoOnLifecycle<T>(this, onSubscribe, onRequest, onCancel);, + return new FlowableSerialized<T>(this);, +++ b/src/main/java/io/reactivex/Flowable.java, + return new FlowableDoOnLifecycle<T>(this, onSubscribe, onRequest, onCancel);, + return new FlowableSerialized<T>(this);, +++ b/src/main/java/io/reactivex/Observable.java, + return new ObservableDoOnLifecycle<T>(this, onSubscribe, onCancel);, + return new ObservableSerialized<T>(this);, +++ b/src/main/java/io/reactivex/Flowable.java, + return new FlowableDoOnLifecycle<T>(this, onSubscribe, onRequest, onCancel);, + return new FlowableSerialized<T>(this);, +++ b/src/main/java/io/reactivex/Observable.java, + return new ObservableDoOnLifecycle<T>(this, onSubscribe, onCancel);, + return new ObservableSerialized<T>(this);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDoOnLifecycle.java, +/**, + * Copyright 2016 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License.
[+++ b/src/main/java/io/reactivex/Single.java, + * <p>, + * <img width="640" height="515" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.defer.png" alt="">, + * <p>, + * <img width="640" height="292" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.timer.png" alt="">, + * <p>, + * <img width="640" height="292" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.timer.s.png" alt="">, + * <img width="640" height="462" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.toFlowable.png" alt="">, + * <img width="640" height="467" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/Single.toFuture.png" alt="">, + * <img width="640" height="463" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.toMaybe.png" alt="">]
[+++ b/gradle.properties, +version=0.17.0-RC2-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/observers/DefaultObserver.java, + * .subscribe(new DefaultObserver&lt;Integer>() {]
[+++ b/src/main/java/io/reactivex/subjects/PublishSubject.java, + onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));, +++ b/src/main/java/io/reactivex/subjects/PublishSubject.java, + onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));, +++ b/src/test/java/io/reactivex/processors/AsyncProcessorTest.java, +, + @Test, + public void onNextNull() {, + final AsyncProcessor<Object> p = AsyncProcessor.create();, +, + p.onNext(null);, +, + p.test(), + .assertNoValues(), + .assertError(NullPointerException.class), + .assertErrorMessage("onNext called with null. Null values are generally not allowed in 2.x operators and sources.");, + }, +, + @Test, + public void onErrorNull() {, + final AsyncProcessor<Object> p = AsyncProcessor.create();, +, + p.onError(null);,
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC3-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC3-SNAPSHOT, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java, + *, + * @param <T1>, + * @param <T2>, + * @param <T3>, + * @param <T4>, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC3-SNAPSHOT, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java, + *, + * @param <T1>, + * @param <T2>, + * @param <T3>, + * @param <T4>, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyFunctionWrapper.java, + *, + * @param <T1>, + * @param <T2>, + * @param <T3>, + * @param <T4>, + * @param <T5>, + * @param <T6>, + * @param <T7>, + * @param <T8>, + * @param <T9>, + *
[+++ b/language-adaptors/rxjava-groovy/README.md, + Observable.from("one", "two", "three"), +++ b/language-adaptors/rxjava-groovy/README.md, + Observable.from("one", "two", "three"), +++ b/language-adaptors/rxjava-groovy/src/examples/groovy/rx/lang/groovy/examples/RxExamples.groovy, + Observable.from(names), + Observable<Integer> o = Observable.from(1, 2, 3, 4, 5, 6);, + Observable<String> o = Observable.from("a", "b", "c");, + Observable<Integer> o = Observable.from(list);, +++ b/language-adaptors/rxjava-groovy/README.md, + Observable.from("one", "two", "three"), +++ b/language-adaptors/rxjava-groovy/src/examples/groovy/rx/lang/groovy/examples/RxExamples.groovy, + Observable.from(names), + Observable<Integer> o = Observable.from(1, 2, 3, 4, 5, 6);, + Observable<String> o = Observable.from("a", "b", "c");, + Observable<Integer> o = Observable.from(list);, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, + Observable.filter(Observable.from(1, 2, 3), {it >= 2}).subscribe({ result -> a.received(result)});, + assertEquals("three", Observable.from("one", "two", "three").toBlockingObservable().last()), + assertEquals("two", Observable.from("one", "two", "three").toBlockingObservable().last({ x -> x.length() == 3})), + Observable.map(Observable.from(1,
[+++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java, + public String call(rx.functions.Func1 f) {, + public String call(rx.functions.Func2 f) {, + public String call(rx.functions.Action1 f) {, + public String call(rx.functions.Action2 f) {, +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java, + public String call(rx.functions.Func1 f) {, + public String call(rx.functions.Func2 f) {, + public String call(rx.functions.Action1 f) {, + public String call(rx.functions.Action2 f) {, +++ b/language-adaptors/rxjava-groovy/src/examples/groovy/rx/lang/groovy/examples/RxExamples.groovy, +import rx.functions.Action0, +import rx.functions.Func1;, +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java, + public String call(rx.functions.Func1 f) {, + public String call(rx.functions.Func2 f) {, + public String call(rx.functions.Action1 f) {, + public String call(rx.functions.Action2 f) {, +++ b/language-adaptors/rxjava-groovy/src/examples/groovy/rx/lang/groovy/examples/RxExamples.groovy, +import rx.functions.Action0, +import rx.functions.Func1;, +++ b/language-adaptors/rxjava-groovy/src/examples/groovy/rx/lang/groovy/examples/VideoExample.groovy, +import rx.functions.Func1;, +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java, + public String
[+++ b/gradle.properties, +version=0.11.0]
[+++ b/CHANGES.md, +### Version 0.20.0-RC5 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.20.0-RC5%22)) ###, +, +Version 0.20.0-RC5 updates `parallel`, `buffer(size)`, `switchOnNext`, `repeat`, and `retry` to support "reactive pull" backpressure. It adds a `groupBy` overload with an element selector, a new `compose` method as an alternative to `lift` for custom operators, fixes bugs and other general improvements., +, +There are still oustanding items being tracked for 0.20 that need to be completed for the final release., +, +* [Pull 1573] (https://github.com/Netflix/RxJava/pull/1573) Backpressure: parallel , +* [Pull 1572] (https://github.com/Netflix/RxJava/pull/1572) Remove Timeout in Blocking Iterator, +* [Pull 1570] (https://github.com/Netflix/RxJava/pull/1570) RxClojure: Fix for mapcat, +* [Pull 1568] (https://github.com/Netflix/RxJava/pull/1568) Compose/Transformer,
[+++ b/gradle/convention.gradle, + gradleVersion = '1.1', +++ b/gradle/convention.gradle, + gradleVersion = '1.1', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/convention.gradle, + gradleVersion = '1.1', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Aug 14 16:28:54 PDT 2012, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.1-bin.zip, +++ b/gradle/convention.gradle, + gradleVersion = '1.1', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Aug 14 16:28:54 PDT 2012, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.1-bin.zip, +++ b/gradlew, + warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT", + GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\"", +++ b/gradle/convention.gradle, + gradleVersion = '1.1', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Tue Aug 14 16:28:54 PDT 2012, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.1-bin.zip, +++ b/gradlew, + warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT", + GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\"", +++ b/gradlew.bat]
[+++ b/language-adaptors/rxjava-scala/README.md, +# Scala Adaptor for RxJava, +This adaptor allows to use RxJava in Scala with anonymous functions, e.g., +, +val o = Observable.interval(200 millis).take(5), +o.subscribe(n => println("n = " + n)), +Observable(1, 2, 3, 4).reduce(_ + _), +For-comprehensions are also supported:, +, +val first = Observable(10, 11, 12), +val second = Observable(10, 11, 12), +val booleans = for ((n1, n2) <- (first zip second)) yield (n1 == n2), +Further, this adaptor attempts to expose an API which is as Scala-idiomatic as possible. This means that certain methods have been renamed, their signature was changed, or static methods were
[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/schedulers/ComputationScheduler.scala, + def apply(): ComputationScheduler = {, + new ComputationScheduler(rx.schedulers.Schedulers.computation()), +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/schedulers/ComputationScheduler.scala, + def apply(): ComputationScheduler = {, + new ComputationScheduler(rx.schedulers.Schedulers.computation()), +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationRepeat;, + return this.repeat(Schedulers.currentThread());, + return create(OperationRepeat.repeat(this, scheduler));, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/schedulers/ComputationScheduler.scala, + def apply(): ComputationScheduler = {, + new ComputationScheduler(rx.schedulers.Schedulers.computation()), +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationRepeat;, + return this.repeat(Schedulers.currentThread());, + return create(OperationRepeat.repeat(this, scheduler));, +++ b/rxjava-core/src/main/java/rx/operators/OperationRepeat.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy
[+++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +RxScala Release Notes, +=====================, +, +This release of the RxScala bindings builds on the previous 0.15 release to make the Rx bindings for Scala, +include all Rx types. In particular this release focuses on the `Subject` and `Scheduler` types., +To makes these notes self-contained, we will start with the `Observer[T]` and `Observable[T]` traits, +that lay at the heart of Rx., +, +Observer, +--------, +, +In this release we have made the `asJavaObserver` property in `Observable[T]`as well the the factory method in the, + companion object
[+++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/build.gradle, +// Establish version and status, +ext.githubProjectName = rootProject.name // Change if github project name is not the same as the root project's name, + repositories {, + mavenLocal(), + maven { url 'http://jcenter.bintray.com' }, + }, + repositories { mavenRepo url: 'http://jcenter.bintray.com' }, +apply from: file('gradle/check.gradle'), + group =
[+++ b/src/main/java/io/reactivex/Completable.java, + * <img width="640" height="475" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delaySubscription.t.png" alt="">, + * <img width="640" height="420" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delaySubscription.ts.png" alt="">, +++ b/src/main/java/io/reactivex/Completable.java, + * <img width="640" height="475" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delaySubscription.t.png" alt="">, + * <img width="640" height="420" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.delaySubscription.ts.png" alt="">, +++ b/src/main/java/io/reactivex/internal/fuseable/ConditionalSubscriber.java, + * A Subscriber with an additional {@link #tryOnNext(Object)} method that, + * and the next value can be sent immediately]
[+++ b/gradle.properties, +version=0.18.0-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/exceptions/CompositeException.java, + *, + * @throws IllegalArgumentException if <code>exceptions</code> is empty., + this(exceptions == null ?, + Arrays.asList(new NullPointerException("exceptions was null")) : Arrays.asList(exceptions));, + *, + * @throws IllegalArgumentException if <code>errors</code> is empty., + deDupedExceptions.add(new NullPointerException("Throwable was null!"));, + deDupedExceptions.add(new NullPointerException("errors was null"));, + if (deDupedExceptions.isEmpty()) {, + throw new IllegalArgumentException("errors is empty");, + }, + if (root == null || root == ex) {, + Throwable cause = root.getCause();, + if (cause == null || cause == root) {, + root = cause;, + if (root == null || cause == root) {, + if (cause ==
[+++ b/src/main/java/io/reactivex/Observable.java, + return cacheWithInitialCapacity(16);, + ObjectHelper.verifyPositive(initialCapacity, "initialCapacity");, + return RxJavaPlugins.onAssembly(new ObservableCache<T>(this, initialCapacity));, +++ b/src/main/java/io/reactivex/Observable.java, + return cacheWithInitialCapacity(16);, + ObjectHelper.verifyPositive(initialCapacity, "initialCapacity");, + return RxJavaPlugins.onAssembly(new ObservableCache<T>(this, initialCapacity));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java, +import io.reactivex.internal.util.BackpressureHelper;, +public final class FlowableCache<T> extends AbstractFlowableWithUpstream<T, T>, +implements FlowableSubscriber<T> {, + /**, + * The subscription to the source should happen at most once., + */, + * The number of items per cached nodes., + final int capacityHint;, +, + /**, + * The current known array of subscriber state to notify., + */, + final AtomicReference<CacheSubscription<T>[]> subscribers;, +, + /**, + * A shared instance of an
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.1-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.1-SNAPSHOT, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.1-SNAPSHOT, +++ /dev/null, +++ b/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/ObservableHttp.java, + parentSubscription.add(Subscriptions.create(client.execute(requestProducer, new ResponseConsumerDelegate(observer, parentSubscription),, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.1-SNAPSHOT, +++ /dev/null, +++ b/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/ObservableHttp.java, + parentSubscription.add(Subscriptions.create(client.execute(requestProducer, new ResponseConsumerDelegate(observer, parentSubscription),, +++ b/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ResponseConsumerDelegate.java, + if (response.getFirstHeader("Content-Type").getValue().equals("text/event-stream")) {, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.1-SNAPSHOT, +++ /dev/null, +++ b/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/ObservableHttp.java, + parentSubscription.add(Subscriptions.create(client.execute(requestProducer, new ResponseConsumerDelegate(observer, parentSubscription),, +++ b/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ResponseConsumerDelegate.java, + if (response.getFirstHeader("Content-Type").getValue().equals("text/event-stream")) {, +++ b/rxjava-contrib/rxjava-apache-http/src/test/java/rx/apache/http/examples/ExampleObservableHttp.java, + for (int i = 0; i < 5; i++) {, + final int c = i + 1;, + ObservableHttp.createRequest(HttpAsyncMethods.createGet("http://ec2-54-211-91-164.compute-1.amazonaws.com:8077/eventbus.stream?topic=hystrix-metrics"), client), + System.out.println("Response [" + c + "]:
[+++ b/src/main/java/io/reactivex/Maybe.java, + * Returns a Single that emits the items emitted by the source Maybe or the item of an alternate, + * SingleSource if the current Maybe is empty., + * <p>, + * <img width="640" height="445" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchifempty.m.png" alt="">, + * <p/>, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code switchIfEmpty} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + *, + * @param other, + * the alternate SingleSource to subscribe to if the main does not emit any items, + * @return a Single that emits the items emitted
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCreate.java, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCreate.java, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDematerialize.java, + if (t.isOnError()) {, + RxJavaPlugins.onError(t.getError());, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCreate.java, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDematerialize.java, + if (t.isOnError()) {, + RxJavaPlugins.onError(t.getError());, + }, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFromFuture.java, +import io.reactivex.internal.functions.ObjectHelper;, +import io.reactivex.internal.observers.DeferredScalarDisposable;, + DeferredScalarDisposable<T> d = new DeferredScalarDisposable<T>(s);, + d.complete(v);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCreate.java, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableDematerialize.java, + if (t.isOnError()) {, + RxJavaPlugins.onError(t.getError());, + }, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFromFuture.java, +import io.reactivex.internal.functions.ObjectHelper;, +import io.reactivex.internal.observers.DeferredScalarDisposable;, + DeferredScalarDisposable<T> d = new DeferredScalarDisposable<T>(s);, + d.complete(v);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSkipLastTimed.java, + if (!cancelled) {, + s.dispose();, + for (;;) {, + if (cancelled) {, + queue.clear();, + if (d) {, + if (delayError) {, + if (empty) {, + Throwable e
[+++ b/src/main/java/io/reactivex/Observable.java, +import io.reactivex.observables.ConnectableObservable;, +import io.reactivex.schedulers.Schedulers;, + , + public final Observable<T> observeOn(Scheduler scheduler) {, + return observeOn(scheduler, false, bufferSize());, + }, + , + public final Observable<T> observeOn(Scheduler scheduler, boolean delayError) {, + return observeOn(scheduler, delayError, bufferSize());, + }, + , + public final Observable<T> observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {, + // TODO implement, + throw new UnsupportedOperationException();, + }, + , + public final Observable<T> subscribeOn(Scheduler scheduler) {, + // TODO implement, + throw new UnsupportedOperationException();, + }, + , + public final Observable<T> unsubscribeOn(Scheduler scheduler) {, + // TODO implement, + throw new UnsupportedOperationException();,
[+++ b/src/main/java/io/reactivex/Observable.java, + return lift(new OperatorAll<>(predicate));, + return all(v -> false);, +++ b/src/main/java/io/reactivex/Observable.java, + return lift(new OperatorAll<>(predicate));, + return all(v -> false);, +++ b/src/main/java/io/reactivex/internal/operators/OperatorAll.java, +import java.util.concurrent.atomic.AtomicInteger;, +import io.reactivex.internal.subscriptions.SubscriptionHelper;, + return new AllSubscriber<>(t, predicate);, + static final class AllSubscriber<T> extends AtomicInteger implements Subscriber<T>, Subscription {, + /** */, + private static final long serialVersionUID = -3521127104134758517L;, + static final int NO_REQUEST_NO_VALUE = 0;, + static final int NO_REQUEST_HAS_VALUE = 1;, + static final int HAS_REQUEST_NO_VALUE = 2;, + static final int HAS_REQUEST_HAS_VALUE = 3;, + , + public AllSubscriber(Subscriber<? super Boolean> actual, Predicate<? super T> predicate) {, + if (SubscriptionHelper.validateSubscription(this.s,
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableInterval.java, +import io.reactivex.Scheduler.Worker;, +import io.reactivex.internal.schedulers.TrampolineScheduler;, + Scheduler sch = scheduler;, + if (sch instanceof TrampolineScheduler) {, + Worker worker = sch.createWorker();, + is.setResource(worker);, + worker.schedulePeriodically(is, initialDelay, period, unit);, + } else {, + Disposable d = sch.schedulePeriodicallyDirect(is, initialDelay, period, unit);, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableInterval.java, +import io.reactivex.Scheduler.Worker;, +import io.reactivex.internal.schedulers.TrampolineScheduler;, + Scheduler sch = scheduler;, + if (sch instanceof TrampolineScheduler) {, + Worker worker = sch.createWorker();, + is.setResource(worker);, + worker.schedulePeriodically(is, initialDelay, period, unit);, + } else {, + Disposable d = sch.schedulePeriodicallyDirect(is, initialDelay, period, unit);, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableIntervalRange.java, +import io.reactivex.Scheduler.Worker;, +import io.reactivex.internal.schedulers.TrampolineScheduler;, + Scheduler sch = scheduler;, + if
[+++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.3-bin.zip, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.3-bin.zip, +++ b/rxjava-core/src/main/java/rx/observables/Notification.java, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.3-bin.zip, +++ b/rxjava-core/src/main/java/rx/observables/Notification.java, +++ /dev/null, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.3-bin.zip, +++ b/rxjava-core/src/main/java/rx/observables/Notification.java, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/util/AtomicObserverSingleThreaded.java, + private final Observer<T> Observer;, + this.Observer = Observer;, + Observer.onNext(arg);, + Observer.onError(e);, + Observer.onCompleted();]
[+++ b/.travis.yml, +# Code coverage, +after_success:, + - bash <(curl -s https://codecov.io/bash), +, +++ b/.travis.yml, +# Code coverage, +after_success:, + - bash <(curl -s https://codecov.io/bash), +, +++ b/README.md, +[![codecov.io](http://codecov.io/github/ReactiveX/RxJava/coverage.svg?branch=2.x)](http://codecov.io/github/ReactiveX/RxJava?branch=2.x), +++ b/.travis.yml, +# Code coverage, +after_success:, + - bash <(curl -s https://codecov.io/bash), +, +++ b/README.md, +[![codecov.io](http://codecov.io/github/ReactiveX/RxJava/coverage.svg?branch=2.x)](http://codecov.io/github/ReactiveX/RxJava?branch=2.x), +++ b/build.gradle, +apply plugin: 'jacoco', +, +jacoco {, + toolVersion = '0.7.7.201606060606' // See http://www.eclemma.org/jacoco/., +}, +, +jacocoTestReport {, + reports {, + xml.enabled = true, + html.enabled = true, + }, +}, +, +build.dependsOn jacocoTestReport]
[+++ b/gradle.properties, +version=0.17.0-RC1-SNAPSHOT, +++ b/gradle.properties, +version=0.17.0-RC1-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, + @Test def timeoutExample(): Unit = {, + val other = List(100L, 200L, 300L).toObservable, + val result = Observable.interval(100 millis).timeout(50 millis, other).toBlockingObservable.toList, + println(result), + }, +, + @Test def timeoutExample2(): Unit = {, + val firstTimeoutSelector = () => {, + Observable.timer(10 seconds, 10 seconds, ComputationScheduler()).take(1), + }, + val timeoutSelector = (t: Long) => {, + Observable.timer(, + (500 - t * 100) max 1 millis,, + (500 - t * 100) max 1 millis,, + ComputationScheduler()).take(1), + }, + val other = List(100L, 200L, 300L).toObservable, + val result
[+++ b/src/main/java/io/reactivex/Completable.java, + * <dt><b>Error handling:</b></dt>, + * <dt><b>Error handling:</b></dt>, + * <dt><b>Error handling:</b></dt>]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableUnsubscribeOn.java, +import io.reactivex.Scheduler;, +import io.reactivex.plugins.RxJavaPlugins;, + if (!get()) {, + }, + if (get()) {, + RxJavaPlugins.onError(t);, + return;, + }, + if (!get()) {, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableUnsubscribeOn.java, +import io.reactivex.Scheduler;, +import io.reactivex.plugins.RxJavaPlugins;, + if (!get()) {, + }, + if (get()) {, + RxJavaPlugins.onError(t);, + return;, + }, + if (!get()) {, + }, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableUnsubscribeOn.java, +import io.reactivex.plugins.RxJavaPlugins;, + if (!get()) {, + }, + if (get()) {, + RxJavaPlugins.onError(t);, + return;, + }, + if (!get()) {, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableUnsubscribeOn.java, +import io.reactivex.Scheduler;, +import io.reactivex.plugins.RxJavaPlugins;, + if (!get()) {, + }, + if (get()) {, +
[+++ b/gradle.properties, +version=0.19.1]
[+++ b/CHANGES.md, +### Version 0.16.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.16.1%22)) ###, +, +* [Pull 730](https://github.com/Netflix/RxJava/pull/730) Improve Error Handling and Stacktraces When Unsubscribe Fails, +* [Pull 720](https://github.com/Netflix/RxJava/pull/720) Added `Observable.timeout` wrappers to scala adapter, +* [Pull 731](https://github.com/Netflix/RxJava/pull/731) Fix non-deterministic unit test, +* [Pull 742](https://github.com/Netflix/RxJava/pull/742) Build with Gradle 1.10, +* [Pull 718](https://github.com/Netflix/RxJava/pull/718) Merge overloads, +* [Pull 733](https://github.com/Netflix/RxJava/pull/733) Buffer with Observable boundary, +* [Pull 734](https://github.com/Netflix/RxJava/pull/734) Delay with subscription and item delaying observables, +* [Pull 735](https://github.com/Netflix/RxJava/pull/735) Window with Observable boundary, +* [Pull 736](https://github.com/Netflix/RxJava/pull/736) MergeMap with Iterable and resultSelector overloads, +* [Pull 738](https://github.com/Netflix/RxJava/pull/738) Publish and PublishLast overloads, +* [Pull 739](https://github.com/Netflix/RxJava/pull/739) Debounce with selector, +* [Pull 740](https://github.com/Netflix/RxJava/pull/740) Timeout with
[+++ b/src/main/java/io/reactivex/exceptions/Exceptions.java, + if (t instanceof StackOverflowError) {, +++ b/src/main/java/io/reactivex/exceptions/Exceptions.java, + if (t instanceof StackOverflowError) {, +++ /dev/null, +++ b/src/main/java/io/reactivex/exceptions/Exceptions.java, + if (t instanceof StackOverflowError) {, +++ /dev/null, +++ /dev/null, +++ b/src/main/java/io/reactivex/exceptions/Exceptions.java, + if (t instanceof StackOverflowError) {, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/src/main/java/io/reactivex/exceptions/Exceptions.java, + if (t instanceof StackOverflowError) {, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/src/main/java/io/reactivex/exceptions/Exceptions.java, + if (t instanceof StackOverflowError) {, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/src/test/java/io/reactivex/exceptions/ExceptionsNullTest.java, + @Ignore("OnCompleteFailedException will likely not be ported"), +// Throwable t = new OnCompleteFailedException(null);, +//, +// Assert.assertTrue(t.getCause() instanceof NullPointerException);, + @Ignore("OnCompleteFailedException will
[+++ b/.travis.yml, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/.travis.yml, +++ b/CHANGES.md, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:1.12.+' }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/src/main/java/rx/Observable.java, + * For more information see the <a href="https://github.com/ReactiveX/RxJava/wiki/Observable">RxJava wiki</a>, + * @see <a href="https://github.com/ReactiveX/RxJava/wiki/Creating-Observables#create">RxJava wiki: create</a>, + *
[+++ b/gradle.properties, +version=0.11.0-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Observable.java, + public final Flowable<T> toFlowable(BackpressureStrategy strategy) {]
[+++ b/src/main/java/io/reactivex/Completable.java, + try {, + return wrap(transformer.apply(this));, + } catch (Throwable ex) {, + Exceptions.throwIfFatal(ex);, + throw ExceptionHelper.wrapOrThrow(ex);, + }, +++ b/src/main/java/io/reactivex/Completable.java, + try {, + return wrap(transformer.apply(this));, + } catch (Throwable ex) {, + Exceptions.throwIfFatal(ex);, + throw ExceptionHelper.wrapOrThrow(ex);, + }, +++ b/src/main/java/io/reactivex/CompletableTransformer.java, +public interface CompletableTransformer {, + CompletableSource apply(Completable completable) throws Exception;, +++ b/src/main/java/io/reactivex/Completable.java, + try {, + return wrap(transformer.apply(this));, + } catch (Throwable ex) {, + Exceptions.throwIfFatal(ex);, + throw ExceptionHelper.wrapOrThrow(ex);, + }, +++ b/src/main/java/io/reactivex/CompletableTransformer.java, +public interface CompletableTransformer {, + CompletableSource apply(Completable completable) throws Exception;, +++ b/src/main/java/io/reactivex/Flowable.java, + try {, + return fromPublisher(composer.apply(this));, + } catch (Throwable
[+++ b/build.gradle, +++ b/build.gradle, +++ b/gradle.properties, +version=0.18.4-SNAPSHOT, +++ b/build.gradle, +++ b/gradle.properties, +version=0.18.4-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorGroupBy.java, + public Subscriber<? super T> call(final Subscriber<? super GroupedObservable<K, T>> childObserver) {, + return new GroupBySubscriber<K, T>(keySelector, childObserver);, + final Subscriber<? super GroupedObservable<K, T>> childObserver;, + public GroupBySubscriber(Func1<? super T, ? extends K> keySelector, Subscriber<? super GroupedObservable<K, T>> childObserver) {, + this.childObserver = childObserver;, + childObserver.onCompleted();, + childObserver.onError(e);, + BufferUntilSubscriber<T> gps = groups.get(key);, + if (gps == null) {, + if (childObserver.isUnsubscribed()) {, + gps = BufferUntilSubscriber.create();, + final BufferUntilSubscriber<T> _gps = gps;, + _gps.unsafeSubscribe(new Subscriber<T>(o) {, + groups.put(key, gps);, + childObserver.onNext(go);, + gps.onNext(t);, +
[+++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java, + throw fail("Fewer values received than expected (" + i + ")");]
[+++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/TestParallel.groovy, +import rx.concurrency.Schedulers, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/TestParallel.groovy, +import rx.concurrency.Schedulers, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/TestParallel.groovy, +import rx.concurrency.Schedulers, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/TestParallel.groovy, +import rx.concurrency.Schedulers, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, + def mountainBikeMedals: Observable[Medal] = Observable(, + Observable(, + Observable(, + Observable(, + Observable(, + Observable(, + Observable(), +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/TestParallel.groovy, +import rx.concurrency.Schedulers, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, + def mountainBikeMedals: Observable[Medal] = Observable(, + Observable(, + Observable(, + Observable(, + Observable(, + Observable(, + Observable(), +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.concurrency._, + val first = Observable(10,
[+++ b/CHANGES.md, +### Version 0.20.0-RC1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.20.0-RC1%22)) ###, +, +, +Version 0.20.0-RC1 is a preview release that adds backpressure support to RxJava as per issue [#1000](https://github.com/Netflix/RxJava/issues/1000). It has been done in a way that is mostly additive and most existing code will not be affected by these additions. A section below on "Breaking Changes" will discuss use cases that do break and how to deal with them., +, +This release has been tested successfully in Netflix production canaries, but that does not exercise all use cases or operators, nor does it leverage the newly added backpressure functionality (though the
[+++ b/gradle.properties, +version=0.7.1-SNAPSHOT]
[+++ b/gradle.properties, +version=0.6.1]
[+++ b/src/main/java/io/reactivex/internal/disposables/ResettableConnectable.java, +/**, + * Copyright (c) 2016-present, RxJava Contributors., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorOnErrorReturn;, + return lift(new OperatorOnErrorReturn<T>(resumeFunction));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorOnErrorReturn;, + return lift(new OperatorOnErrorReturn<T>(resumeFunction));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorOnErrorReturn;, + return lift(new OperatorOnErrorReturn<T>(resumeFunction));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorOnErrorReturn.java, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not, + * use this file except in compliance with the License. You may obtain a copy of, + * the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under
[+++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.internal.operators.maybe.MaybeDelayWithCompletable;, + * Returns a {@link Maybe} which will subscribe to this Completable and once that is completed then, + * will subscribe to the {@code next} MaybeSource. An error event from this Completable will be, + * propagated to the downstream subscriber and will result in skipping the subscription of the, + * Maybe., + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code andThen} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + *, + * @param <T> the value type of the next MaybeSource, + * @param next the
[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.{Observer, Notification, Observable}, +import rx.lang.scala.subjects.BehaviorSubject, +import org.mockito.Mockito._, +import scala.Some, +import org.mockito.Matchers._, +import scala.Some, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.{Observer, Notification, Observable}, +import rx.lang.scala.subjects.BehaviorSubject, +import org.mockito.Mockito._, +import scala.Some, +import org.mockito.Matchers._, +import scala.Some, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/TestSchedulerExample.scala, +import org.junit.{Assert, Test}, +import rx.lang.scala.subjects.BehaviorSubject, +import org.mockito.Mockito._, +import org.mockito.Matchers._, +, +, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.{Observer, Notification, Observable}, +import rx.lang.scala.subjects.BehaviorSubject, +import org.mockito.Mockito._, +import scala.Some, +import org.mockito.Matchers._, +import scala.Some, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/TestSchedulerExample.scala, +import org.junit.{Assert, Test}, +import rx.lang.scala.subjects.BehaviorSubject, +import org.mockito.Mockito._, +import org.mockito.Matchers._, +, +, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Subscription.scala, + private [scala] val asJavaSubscription: rx.Subscription = new rx.Subscription {, + subscription match {, + }, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.{Observer, Notification, Observable}, +import
[+++ b/src/main/java/io/reactivex/Scheduler.java, +import io.reactivex.annotations.Experimental;, +import io.reactivex.functions.Function;, +import io.reactivex.internal.schedulers.SchedulerWhen;, + * Allows the use of operators for controlling the timing around when, + * actions scheduled on workers are actually done. This makes it possible to, + * layer additional behavior on this {@link Scheduler}. The only parameter, + * is a function that flattens an {@link Flowable} of {@link Flowable}, + * of {@link Completable}s into just one {@link Completable}. There must be, + * a chain of operators connecting the returned value to the source, + * {@link Flowable} otherwise any work scheduled on the returned, + *
[+++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java, + * Copyright 2013 Netflix, Inc., +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java, + * Copyright 2013 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyActionWrapper.java, + * Copyright 2013 Netflix, Inc., +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java, + * Copyright 2013 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyActionWrapper.java, + * Copyright 2013 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, + * Copyright 2013 Netflix, Inc., +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java, + * Copyright 2013 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyActionWrapper.java, + * Copyright 2013 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, + * Copyright 2013 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyFunctionWrapper.java, + * Copyright 2013 Netflix, Inc., +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/interop/DummyObservable.java, + * Copyright 2013 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyActionWrapper.java, + * Copyright 2013 Netflix, Inc., +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, +
[+++ b/gradle.properties, +version=0.5.5-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Single.java, + * <img width="640" height="457" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.filter.png" alt="">]
[+++ b/src/main/java/io/reactivex/Single.java, + * <p>, + * <img width="640" height="457" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.repeat.png" alt="">, + * <p>, + * <img width="640" height="457" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.repeat.n.png" alt="">, + * <p>, + * <img width="640" height="1478" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.repeatWhen.png" alt="">]
[+++ b/gradle.properties, +version=0.17.1]
[+++ b/src/main/java/io/reactivex/Completable.java, + private static Completable merge0(Publisher<? extends CompletableConsumable> sources, int maxConcurrency, boolean delayErrors) {, + private static NullPointerException toNpe(Throwable ex) {, + private Completable doOnLifecycle(, + private Completable timeout0(long timeout, TimeUnit unit, Scheduler scheduler, CompletableConsumable other) {]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-scala-java/README.md, +, +rxjava-scala-java, +-----------------, +, +Contains examples illustrating how RxScala code can be used from Java., +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-scala-java/README.md, +, +rxjava-scala-java, +-----------------, +, +Contains examples illustrating how RxScala code can be used from Java., +++ b/language-adaptors/rxjava-scala-java/build.gradle, +, +apply plugin: 'osgi', +, +, +project(':language-adaptors:rxjava-scala-java') {, + //sourceSets.test.java.srcDir 'src/examples/java', + sourceSets.main.java.srcDir
[+++ b/src/main/java/io/reactivex/Completable.java, + ObjectHelper.verifyPositive(prefetch, "prefetch");, + ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");, +++ b/src/main/java/io/reactivex/Completable.java, + ObjectHelper.verifyPositive(prefetch, "prefetch");, + ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");, +++ b/src/main/java/io/reactivex/Flowable.java, + ObjectHelper.verifyPositive(count, "count");, + ObjectHelper.verifyPositive(skip, "skip");, + ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");, + ObjectHelper.verifyPositive(prefetch, "prefetch");, + ObjectHelper.requireNonNull(mapper, "mapper is null");, + ObjectHelper.verifyPositive(bufferSize, "bufferSize");, +++ b/src/main/java/io/reactivex/Completable.java, + ObjectHelper.verifyPositive(prefetch, "prefetch");, + ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");, +++ b/src/main/java/io/reactivex/Flowable.java, + ObjectHelper.verifyPositive(count, "count");, + ObjectHelper.verifyPositive(skip, "skip");, + ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");, + ObjectHelper.verifyPositive(prefetch, "prefetch");, + ObjectHelper.requireNonNull(mapper, "mapper is null");, + ObjectHelper.verifyPositive(bufferSize, "bufferSize");, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAutoConnect.java, +import java.util.concurrent.atomic.AtomicInteger;, +, +++ b/src/main/java/io/reactivex/Completable.java, + ObjectHelper.verifyPositive(prefetch, "prefetch");, + ObjectHelper.verifyPositive(maxConcurrency, "maxConcurrency");, +++ b/src/main/java/io/reactivex/Flowable.java, + ObjectHelper.verifyPositive(count, "count");, + ObjectHelper.verifyPositive(skip, "skip");, + ObjectHelper.requireNonNull(bufferSupplier, "bufferSupplier is null");, +
[+++ b/CHANGES.md, +### Version 0.20.0-RC3 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.20.0-RC3%22)) ###, +, +Version 0.20.0-RC3 preview release fixes several bugs related to backpressure and adds `retryWhen`, `repeatWhen` for more advanced recursion use cases like retry with exponential backoff., +, +This version passed the Netflix API production canary process. Please test this against your code to help us find any issues before we release 0.20.0., +, +* [Pull 1493] (https://github.com/Netflix/RxJava/pull/1493) retryWhen/repeatWhen, +* [Pull 1494] (https://github.com/Netflix/RxJava/pull/1494) zipWith, +* [Pull 1501] (https://github.com/Netflix/RxJava/pull/1501) blocking synchronous next, +* [Pull 1498] (https://github.com/Netflix/RxJava/pull/1498) non-deterministic testUserSubscriberUsingRequestAsync, +* [Pull 1497] (https://github.com/Netflix/RxJava/pull/1497) spsc ring buffer concurrency test, +* [Pull 1496] (https://github.com/Netflix/RxJava/pull/1496) Change RxRingBuffer
[+++ b/gradle.properties, +version=0.20.0-RC2]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterable.java, + SubscriptionHelper.setOnce(this, s, batchSize);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterable.java, + SubscriptionHelper.setOnce(this, s, batchSize);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundary.java, + SubscriptionHelper.setOnce(this, s, Long.MAX_VALUE);, + SubscriptionHelper.setOnce(this, s, Long.MAX_VALUE);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterable.java, + SubscriptionHelper.setOnce(this, s, batchSize);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundary.java, + SubscriptionHelper.setOnce(this, s, Long.MAX_VALUE);, + SubscriptionHelper.setOnce(this, s, Long.MAX_VALUE);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java, + SubscriptionHelper.setOnce(connection, s, Long.MAX_VALUE);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterable.java, + SubscriptionHelper.setOnce(this, s, batchSize);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundary.java, + SubscriptionHelper.setOnce(this, s, Long.MAX_VALUE);, + SubscriptionHelper.setOnce(this, s, Long.MAX_VALUE);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java, + SubscriptionHelper.setOnce(connection, s, Long.MAX_VALUE);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java, + SubscriptionHelper.setOnce(this, s, prefetch);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableIterable.java, + SubscriptionHelper.setOnce(this, s, batchSize);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferBoundary.java, + SubscriptionHelper.setOnce(this, s, Long.MAX_VALUE);, + SubscriptionHelper.setOnce(this, s, Long.MAX_VALUE);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCache.java, + SubscriptionHelper.setOnce(connection, s, Long.MAX_VALUE);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCombineLatest.java, + SubscriptionHelper.setOnce(this, s,
[+++ b/language-adaptors/rxjava-clojure/src/examples/clojure/rx/lang/clojure/examples/http_examples.clj, +;, +; Copyright 2013 Netflix, Inc., +; , +; Licensed under the Apache License, Version 2.0 (the "License");, +; you may not use this file except in compliance with the License., +; You may obtain a copy of the License at, +;, +; http://www.apache.org/licenses/LICENSE-2.0, +; , +; Unless required by applicable law or agreed to in writing, software, +; distributed under the License is distributed on an "AS IS" BASIS,, +; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., +; See the License for the specific language governing permissions and, +; limitations under the
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/src/main/java/io/reactivex/processors/UnicastProcessor.java, + * @param onCancelled the non null callback, + * @param onTerminate the callback to run when the Processor is terminated or cancelled, null not allowed, + if (t == null) {, + onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));, + return;, + }, +, + if (t == null) {, + t = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");, + }, +, +++ b/src/main/java/io/reactivex/processors/UnicastProcessor.java, + * @param onCancelled the non null callback, + * @param onTerminate the
[+++ b/src/main/java/io/reactivex/BackpressureOverflow.java, +/**, + * Copyright 2016 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for
[+++ b/gradle.properties, +version=0.12.0-SNAPSHOT]
[+++ b/.gitignore, +.gradletasknamecache, +++ b/.gitignore, +.gradletasknamecache, +++ b/CHANGES.md, +### Version 0.17.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.17.2%22)) ###, +, +* [Pull 963](https://github.com/Netflix/RxJava/pull/963) A more robust JMH benchmarking set-up , +* [Pull 964](https://github.com/Netflix/RxJava/pull/964) SubjectSubscriptionManager fix., +* [Pull 970](https://github.com/Netflix/RxJava/pull/970) Notifications for the allocation averse., +* [Pull 973](https://github.com/Netflix/RxJava/pull/973) Merge - Handle Bad Observables, +* [Pull 974](https://github.com/Netflix/RxJava/pull/974) TestSubject, TestObserver and TestScheduler Improvements, +* [Pull 975](https://github.com/Netflix/RxJava/pull/975) GroupBy & Time Gap Fixes, +* [Pull 976](https://github.com/Netflix/RxJava/pull/976) parallel-merge unit test assertions, +* [Pull 977](https://github.com/Netflix/RxJava/pull/977) Dematerialize - handle non-materialized terminal events, +* [Pull 982](https://github.com/Netflix/RxJava/pull/982) Pivot Operator, +* [Pull 984](https://github.com/Netflix/RxJava/pull/984) Tests and Javadoc for Pivot, +* [Pull 966](https://github.com/Netflix/RxJava/pull/966) Reimplement the ElementAt operator and
[+++ b/gradle.properties, +version=0.17.0-RC2]
[+++ b/gradle.properties, +version=0.17.0-RC7-SNAPSHOT]
[+++ b/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/Async.java, + * Copyright 2013 Netflix, Inc., +import rx.util.async.operators.OperationDeferFuture;, +import rx.util.async.operators.OperationForEachFuture;, +import rx.util.async.operators.OperationFromFunctionals;, +import rx.util.async.operators.OperationStartFuture;, + return OperationStartFuture.startFuture(functionAsync);, + return OperationStartFuture.startFuture(functionAsync, scheduler);, + return OperationDeferFuture.deferFuture(observableFactoryAsync);, + return OperationDeferFuture.deferFuture(observableFactoryAsync, scheduler);, + * @see #forEachFuture(rx.functions.Action1, rx.Scheduler), + return OperationForEachFuture.forEachFuture(source, onNext);, + * @see #forEachFuture(rx.functions.Action1, rx.functions.Action1, rx.Scheduler), + return OperationForEachFuture.forEachFuture(source, onNext, onError);, + * @see #forEachFuture(rx.functions.Action1, rx.functions.Action1, rx.functions.Action0, rx.Scheduler), + return OperationForEachFuture.forEachFuture(source, onNext, onError, onCompleted);, + FutureTask<Void> task = OperationForEachFuture.forEachFuture(source, onNext);, + FutureTask<Void> task = OperationForEachFuture.forEachFuture(source, onNext, onError);, + FutureTask<Void> task = OperationForEachFuture.forEachFuture(source, onNext, onError, onCompleted);, + * Return an Observable that calls the given function and emits its, + *
[+++ b/src/test/java/io/reactivex/flowable/BackpressureTests.java, + @Ignore("The test is non-deterministic and can't be made deterministic"), +++ b/src/test/java/io/reactivex/flowable/BackpressureTests.java, + @Ignore("The test is non-deterministic and can't be made deterministic"), +++ b/src/test/java/io/reactivex/flowable/CombineLatestTests.java, + @Ignore("No longer allowed"), +++ b/src/test/java/io/reactivex/flowable/BackpressureTests.java, + @Ignore("The test is non-deterministic and can't be made deterministic"), +++ b/src/test/java/io/reactivex/flowable/CombineLatestTests.java, + @Ignore("No longer allowed"), +++ b/src/test/java/io/reactivex/flowable/ObservableTests.java, + @Ignore("Throwing is not allowed from the create?!"), + @Test // FIXME throwing is not allowed from the create?!, +++ b/src/test/java/io/reactivex/flowable/BackpressureTests.java, + @Ignore("The test is non-deterministic and can't be made deterministic"), +++ b/src/test/java/io/reactivex/flowable/CombineLatestTests.java, + @Ignore("No longer allowed"), +++ b/src/test/java/io/reactivex/flowable/ObservableTests.java, + @Ignore("Throwing is not allowed from the create?!"), + @Test
[+++ b/src/main/java/io/reactivex/flowables/BlockingFlowable.java, +import io.reactivex.subscribers.DefaultSubscriber;, + subscribe(new DefaultSubscriber<T>() {, +++ b/src/main/java/io/reactivex/flowables/BlockingFlowable.java, +import io.reactivex.subscribers.DefaultSubscriber;, + subscribe(new DefaultSubscriber<T>() {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableMostRecent.java, +import io.reactivex.subscribers.DefaultSubscriber;, + static final class MostRecentObserver<T> extends DefaultSubscriber<T> {, +++ b/src/main/java/io/reactivex/flowables/BlockingFlowable.java, +import io.reactivex.subscribers.DefaultSubscriber;, + subscribe(new DefaultSubscriber<T>() {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableMostRecent.java, +import io.reactivex.subscribers.DefaultSubscriber;, + static final class MostRecentObserver<T> extends DefaultSubscriber<T> {, +++ /dev/null, +++ b/src/main/java/io/reactivex/flowables/BlockingFlowable.java, +import io.reactivex.subscribers.DefaultSubscriber;, + subscribe(new DefaultSubscriber<T>() {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/BlockingFlowableMostRecent.java, +import io.reactivex.subscribers.DefaultSubscriber;, + static final class MostRecentObserver<T> extends DefaultSubscriber<T> {, +++ /dev/null, +++ b/src/main/java/io/reactivex/subscribers/DefaultSubscriber.java, +/**, + * Copyright 2016 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use
[+++ b/gradle.properties, +version=0.18.2-SNAPSHOT]
[+++ b/language-adaptors/rxjava-scala/build.gradle, + main { , + scala { , + srcDir 'src/main/scala', + }, + }, + srcDir 'src/test/scala', + srcDir 'src/examples/scala', + }, + }, + examples { , + scala { , + srcDir 'src/examples/scala', +tasks.compileExamplesScala { , + classpath = classpath + files(compileScala.destinationDir) + (configurations.compile + configurations.provided), +}, +, +++ b/language-adaptors/rxjava-scala/build.gradle, + main { , + scala { , + srcDir 'src/main/scala', + }, + }, + srcDir 'src/test/scala', + srcDir 'src/examples/scala', + }, + }, + examples { , + scala { , + srcDir 'src/examples/scala', +tasks.compileExamplesScala { , + classpath = classpath +
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC5-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC5-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/internal/operators/OnSubscribeCombineLatest.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import java.util.concurrent.atomic.AtomicLong;, +import java.util.concurrent.atomic.AtomicLongFieldUpdater;, +import rx.Producer;, +import rx.exceptions.MissingBackpressureException;, +import rx.internal.util.RxRingBuffer;, + * @param <T>, + * the common basetype of the source values, + * @param <R>, + * the result type of the combinator function, + if (sources.size() > 128) {, + // For design simplicity this is limited to 128. If more are really needed we'll need to adjust , + // the design of how RxRingBuffer is used in the implementation below., + throw new IllegalArgumentException("More than 128 sources to
[+++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/rxjava-core/src/main/java/rx/Observable.java, +++ b/rxjava-core/src/main/java/rx/operators/OperationZip.java, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentLinkedQueue;, +import java.util.concurrent.atomic.AtomicBoolean;, + /*, + * ThreadSafe, + */, + /* package accessible for unit tests */static class ZipObserver<R, T> implements Observer<T> {, + final Observable<? extends T> w;, + final Aggregator<R> a;, + private final SafeObservableSubscription subscription = new
[+++ b/src/main/java/io/reactivex/Completable.java, + * <p>, + * <img width="640" height="297" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromAction.png" alt="">, + * <p>, + * <img width="640" height="286" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromCallable.png" alt="">, + * <img width="640" height="628" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromFuture.png" alt="">, + * <p>, + * Returns a Completable instance that when subscribed to, subscribes to the {@code Maybe} instance and, + * emits a completion event if the maybe emits {@code onSuccess}/{@code onComplete} or forwards any, + * {@code onError} events., + * <p>, + * <img width="640" height="235" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.fromMaybe.png" alt="">, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code fromMaybe} does not operate by default on a particular {@link
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationTakeWhile;, +import rx.operators.OperatorOnExceptionResumeNextViaObservable;, + return lift(new OperatorOnExceptionResumeNextViaObservable<T>(resumeSequence));, + return create(OperationTakeWhile.takeWhile(this, predicate));, + return create(OperationTakeWhile.takeWhileWithIndex(this, predicate));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationTakeWhile;, +import rx.operators.OperatorOnExceptionResumeNextViaObservable;, + return lift(new OperatorOnExceptionResumeNextViaObservable<T>(resumeSequence));, + return create(OperationTakeWhile.takeWhile(this, predicate));, + return create(OperationTakeWhile.takeWhileWithIndex(this, predicate));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationTakeWhile;, +import rx.operators.OperatorOnExceptionResumeNextViaObservable;, + return lift(new OperatorOnExceptionResumeNextViaObservable<T>(resumeSequence));, + return create(OperationTakeWhile.takeWhile(this, predicate));, + return create(OperationTakeWhile.takeWhileWithIndex(this, predicate));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperationTakeWhile.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationOnExceptionResumeNextViaObservable;, +import rx.operators.OperatorParallelMerge;, + return OperatorParallelMerge.parallelMerge(source, parallelObservables);, + return OperatorParallelMerge.parallelMerge(source, parallelObservables, scheduler);, + return create(OperationOnExceptionResumeNextViaObservable.onExceptionResumeNextViaObservable(this, resumeSequence));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationOnExceptionResumeNextViaObservable;, +import rx.operators.OperatorParallelMerge;, + return OperatorParallelMerge.parallelMerge(source, parallelObservables);, + return OperatorParallelMerge.parallelMerge(source, parallelObservables, scheduler);, + return create(OperationOnExceptionResumeNextViaObservable.onExceptionResumeNextViaObservable(this, resumeSequence));, +++ b/rxjava-core/src/main/java/rx/operators/OperationOnExceptionResumeNextViaObservable.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required
[+++ b/src/main/java/io/reactivex/Observable.java, + * Returns a Maybe that emits the single item emitted by this Observable if this Observable, + * @return a {@link Maybe} that emits the single item emitted by the source ObservableSource]
[+++ b/.gitignore]
[+++ b/src/main/java/io/reactivex/Observable.java, + * Returns a Maybe that completes if this Observable is empty or emits the single item emitted by this Observable,, + * or signals an {@code IllegalArgumentException} if this Observable emits more than one item., + * <img width="640" height="217" src="https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/singleElement.o.png" alt="">, +++ b/src/main/java/io/reactivex/Observable.java, + * Returns a Maybe that completes if this Observable is empty or emits the single item emitted by this Observable,, + * or signals an {@code IllegalArgumentException} if this Observable emits more than one item., + * <img width="640" height="217" src="https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/singleElement.o.png" alt="">, +++ b/src/test/java/io/reactivex/internal/operators/observable/ObservableSingleTest.java, + inOrder.verify(observer, never()).onError(any(Throwable.class));]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, + return lift(new OperatorTakeLast<T>(count));, + return lift(new OperatorTakeLastTimed<T>(count, time, unit, scheduler));, + return lift(new OperatorTakeLastTimed<T>(time, unit, scheduler));, + return OperationTakeUntil.takeUntil(this, other);, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return lift(new OperatorTakeLast<T>(count));, + return lift(new OperatorTakeLastTimed<T>(count, time, unit, scheduler));, + return lift(new OperatorTakeLastTimed<T>(time, unit, scheduler));, + return OperationTakeUntil.takeUntil(this, other);, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return lift(new OperatorTakeLast<T>(count));, + return lift(new OperatorTakeLastTimed<T>(count, time, unit, scheduler));, + return lift(new OperatorTakeLastTimed<T>(time, unit, scheduler));, + return OperationTakeUntil.takeUntil(this, other);, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperationTakeUntil.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you
[+++ b/src/main/java/io/reactivex/Observable.java, + , +++ b/src/main/java/io/reactivex/Observable.java, + , +++ b/src/main/java/io/reactivex/internal/operators/PublisherRefCount.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorAmb;, + return create(OperatorAmb.amb(sources));, + return create(OperatorAmb.amb(o1, o2));, + return create(OperatorAmb.amb(o1, o2, o3));, + return create(OperatorAmb.amb(o1, o2, o3, o4));, + return create(OperatorAmb.amb(o1, o2, o3, o4, o5));, + return create(OperatorAmb.amb(o1, o2, o3, o4, o5, o6));, + return create(OperatorAmb.amb(o1, o2, o3, o4, o5, o6, o7));, + return create(OperatorAmb.amb(o1, o2, o3, o4, o5, o6, o7, o8));, + return create(OperatorAmb.amb(o1, o2, o3, o4, o5, o6, o7, o8, o9));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorAmb;, + return create(OperatorAmb.amb(sources));, + return create(OperatorAmb.amb(o1, o2));, + return create(OperatorAmb.amb(o1, o2, o3));, + return create(OperatorAmb.amb(o1, o2, o3, o4));, + return create(OperatorAmb.amb(o1, o2, o3, o4, o5));, + return create(OperatorAmb.amb(o1,
[+++ b/src/main/java/io/reactivex/observers/DefaultObserver.java, + * Abstract base implementation of an {@link io.reactivex.Observer Observer} with support for cancelling a, + * <p>All pre-implemented final methods are thread-safe., + *, + * <p>Use the protected {@link #cancel()} to dispose the sequence from within an, + * {@code onNext} implementation., + *, + * <p>Like all other consumers, {@code DefaultObserver} can be subscribed only once., + * Any subsequent attempt to subscribe it to a new source will yield an, + * {@link IllegalStateException} with message {@code "Disposable already set!"}., + *, + * <p>Implementation of {@link #onStart()}, {@link #onNext(Object)}, {@link #onError(Throwable)}, +
[+++ b/src/main/java/io/reactivex/Flowable.java, + public final <U, V> Flowable<V> flatMapIterable(final Function<? super T, ? extends Iterable<? extends U>> mapper, final BiFunction<? super T, ? super U, ? extends V> resultSelector, int prefetch) {, + Objects.requireNonNull(mapper, "mapper is null");, + Objects.requireNonNull(resultSelector, "resultSelector is null");, + return flatMap(new Function<T, Publisher<U>>() {, + @Override, + public Publisher<U> apply(T t) {, + return new FlowableFromIterable<U>(mapper.apply(t));, + }, + }, resultSelector, false, bufferSize(), prefetch);, + }, +, + @BackpressureSupport(BackpressureKind.FULL), + @SchedulerSupport(SchedulerSupport.NONE), + @BackpressureSupport(BackpressureKind.ERROR), + @SchedulerSupport(SchedulerSupport.NONE), + public final <TRight, TLeftEnd, TRightEnd, R> Flowable<R> groupJoin(, + Publisher<? extends TRight> other,, + Function<? super T, ? extends
[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/ImplicitFunctionConversions.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/ImplicitFunctionConversions.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, + * the [[rx.lang.scala.Scheduler]] on which Observers subscribe to the Observable, + * The [[rx.lang.scala.Scheduler]] to use when determining the end and start of a buffer., + * The [[rx.lang.scala.Scheduler]] to use when determining the end and start of a buffer., + * The [[rx.lang.scala.Scheduler]] to use when determining the end and start of a buffer., + * The [[rx.lang.scala.Scheduler]] to use when determining the end and start of a window., + * The [[rx.lang.scala.Scheduler]] to use when determining the end and start of a window., + * The [[rx.lang.scala.Scheduler]] to use when
[+++ b/src/main/java/io/reactivex/Flowable.java, + * @param prefetch hints about the number of expected values from each inner Publisher, must be positive, +++ b/src/main/java/io/reactivex/Flowable.java, + * @param prefetch hints about the number of expected values from each inner Publisher, must be positive, +++ b/src/main/java/io/reactivex/Observable.java, + * @param prefetch hints about the number of expected values from each inner ObservableSource, must be positive, +++ b/src/main/java/io/reactivex/Flowable.java, + * @param prefetch hints about the number of expected values from each inner Publisher, must be positive, +++ b/src/main/java/io/reactivex/Observable.java, + * @param prefetch hints about the number of expected values from each inner ObservableSource, must be
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAmb.java, +import io.reactivex.exceptions.Exceptions;, + try {, + if (p == null) {, + EmptySubscription.error(new NullPointerException("One of the sources is null"), s);, + return;, + }, + } catch (Throwable e) {, + Exceptions.throwIfFatal(e);, + EmptySubscription.error(e, s);, + return;, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAmb.java, +import io.reactivex.exceptions.Exceptions;, + try {, + if (p == null) {, + EmptySubscription.error(new NullPointerException("One of the sources is null"), s);, + return;, + }, + } catch (Throwable e) {, + Exceptions.throwIfFatal(e);, + EmptySubscription.error(e, s);, + return;, + }, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableAmb.java, +import io.reactivex.exceptions.Exceptions;, + try {, + if (p == null) {, + EmptyDisposable.error(new NullPointerException("One of
[+++ b/language-adaptors/rxjava-groovy/README.md, + Observable.from("one", "two", "three"), +++ b/language-adaptors/rxjava-groovy/README.md, + Observable.from("one", "two", "three"), +++ b/language-adaptors/rxjava-groovy/src/examples/groovy/rx/lang/groovy/examples/RxExamples.groovy, + Observable.from(names), + Observable<Integer> o = Observable.from(1, 2, 3, 4, 5, 6);, + Observable<String> o = Observable.from("a", "b", "c");, + Observable<Integer> o = Observable.from(list);, +++ b/language-adaptors/rxjava-groovy/README.md, + Observable.from("one", "two", "three"), +++ b/language-adaptors/rxjava-groovy/src/examples/groovy/rx/lang/groovy/examples/RxExamples.groovy, + Observable.from(names), + Observable<Integer> o = Observable.from(1, 2, 3, 4, 5, 6);, + Observable<String> o = Observable.from("a", "b", "c");, + Observable<Integer> o = Observable.from(list);, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, + Observable.filter(Observable.from(1, 2, 3), {it >= 2}).subscribe({ result -> a.received(result)});, + assertEquals("three", Observable.from("one", "two", "three").toBlockingObservable().last()), + assertEquals("two", Observable.from("one", "two", "three").toBlockingObservable().last({ x -> x.length() == 3})), + Observable.map(Observable.from(1,
[+++ b/src/main/java/rx/Observable.java, + if (this instanceof ScalarSynchronousObservable) {, + return ((ScalarSynchronousObservable<T>)this).scalarScheduleOn(scheduler);, + }, + if (this instanceof ScalarSynchronousObservable) {, + return ((ScalarSynchronousObservable<T>)this).scalarScheduleOn(scheduler);, + }, +++ b/src/main/java/rx/Observable.java, + if (this instanceof ScalarSynchronousObservable) {, + return ((ScalarSynchronousObservable<T>)this).scalarScheduleOn(scheduler);, + }, + if (this instanceof ScalarSynchronousObservable) {, + return ((ScalarSynchronousObservable<T>)this).scalarScheduleOn(scheduler);, + }, +++ b/src/main/java/rx/internal/schedulers/EventLoopsScheduler.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * ,
[+++ b/gradlew, +++ b/gradlew, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ b/gradlew, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/gradlew, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +import static rx.lang.scala.JavaConversions.toScalaObservable;, +++ b/gradlew, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +import static rx.lang.scala.JavaConversions.toScalaObservable;, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, + def mountainBikeMedals: Observable[Medal] = Observable(, + Observable(, + Observable(, + Observable(, + Observable(, + Observable(, + Observable(), +++ b/gradlew, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observer { …}, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/src/examples/java/rx/lang/scala/examples/MovieLibUsage.java, +import static rx.lang.scala.JavaConversions.toScalaObservable;, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, + def mountainBikeMedals: Observable[Medal] = Observable(, + Observable(, + Observable(, + Observable(,
[+++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.annotations.SchedulerSupport;, +import io.reactivex.internal.util.Exceptions;, + public static Completable defer(final Callable<? extends CompletableConsumable> completableSupplier) {, + public static Completable error(final Callable<? extends Throwable> errorSupplier) {, + public static <R> Completable using(Callable<R> resourceSupplier, , + final Callable<R> resourceSupplier, , + try {, + } catch (Throwable ex) {, + throw Exceptions.propagate(ex);, + }, + public final <T> Single<T> toSingle(final Callable<? extends T> completionValueSupplier) {, +++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.annotations.SchedulerSupport;, +import io.reactivex.internal.util.Exceptions;, + public static Completable defer(final Callable<? extends CompletableConsumable> completableSupplier) {, + public static Completable error(final Callable<? extends Throwable> errorSupplier) {, + public static <R> Completable using(Callable<R> resourceSupplier, , +
[+++ b/src/main/java/io/reactivex/Completable.java, + * If the Completable emits an error, it is wrapped into an, + * {@link io.reactivex.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}, + * and routed to the RxJavaPlugins.onError handler., + * <p>, +++ b/src/main/java/io/reactivex/Completable.java, + * If the Completable emits an error, it is wrapped into an, + * {@link io.reactivex.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}, + * and routed to the RxJavaPlugins.onError handler., + * <p>, +++ b/src/main/java/io/reactivex/Flowable.java, + * <p>, + * If the Flowable emits an error, it is wrapped into an, + * {@link io.reactivex.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}, + * and routed to the RxJavaPlugins.onError handler., + * <p>, + FlowableBlockingSubscribe.subscribe(this, onNext,
[+++ b/src/main/java/io/reactivex/flowables/ConnectableFlowable.java, +import java.util.concurrent.TimeUnit;, +, +import io.reactivex.*;, +import io.reactivex.annotations.*;, +import io.reactivex.internal.functions.*;, +import io.reactivex.schedulers.Schedulers;, + * <dl>, + * <dt><b>Backpressure:</b></dt>, + * <dd>The operator itself doesn't interfere with backpressure which is determined by the upstream, + * {@code ConnectableFlowable}'s backpressure behavior.</dd>, + * <dt><b>Scheduler:</b></dt>, + * <dd>This {@code refCount} overload does not operate on any particular {@link Scheduler}.</dd>, + * </dl>, + * @see #refCount(int), + * @see #refCount(long, TimeUnit), + * @see #refCount(int, long, TimeUnit), + @CheckReturnValue, + @SchedulerSupport(SchedulerSupport.NONE), + @BackpressureSupport(BackpressureKind.PASS_THROUGH), + * Connects to the upstream {@code ConnectableFlowable} if the number of subscribed, + * subscriber reaches the
[+++ b/rxjava-contrib/rxjava-async-util/build.gradle, +apply plugin: 'osgi', +, +sourceCompatibility = JavaVersion.VERSION_1_6, +targetCompatibility = JavaVersion.VERSION_1_6, +, +dependencies {, + compile project(':rxjava-core'), + testCompile project(":rxjava-core").sourceSets.test.output , + provided 'junit:junit-dep:4.10', + provided 'org.mockito:mockito-core:1.8.5', +}, +, +jar {, + manifest {, + name = 'rxjava-async-util', + instruction 'Bundle-Vendor', 'Netflix', + instruction 'Bundle-DocURL', 'https://github.com/Netflix/RxJava', + instruction 'Import-Package', '!org.junit,!junit.framework,!org.mockito.*,*', + }, +}, +++ b/rxjava-contrib/rxjava-async-util/build.gradle, +apply plugin: 'osgi', +, +sourceCompatibility = JavaVersion.VERSION_1_6, +targetCompatibility = JavaVersion.VERSION_1_6, +, +dependencies {, + compile project(':rxjava-core'), + testCompile project(":rxjava-core").sourceSets.test.output , + provided 'junit:junit-dep:4.10', + provided 'org.mockito:mockito-core:1.8.5', +}, +, +jar {, + manifest {, + name = 'rxjava-async-util', + instruction 'Bundle-Vendor', 'Netflix', + instruction
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Returns a Single that applies a specified accumulator function to the first item emitted by a source, +++ b/src/main/java/io/reactivex/Flowable.java, + * Returns a Single that applies a specified accumulator function to the first item emitted by a source, +++ b/src/main/java/io/reactivex/Observable.java, + * Returns a Single that applies a specified accumulator function to the first item emitted by a source]
[+++ b/gradle.properties, +version=0.5.6-SNAPSHOT]
[+++ b/gradle.properties, +version=0.19.4]
[+++ b/language-adaptors/rxjava-groovy/README.md, + Observable.toObservable("one", "two", "three"), +++ b/language-adaptors/rxjava-groovy/README.md, + Observable.toObservable("one", "two", "three"), +++ b/language-adaptors/rxjava-groovy/src/examples/groovy/rx/lang/groovy/examples/RxExamples.groovy, + Observable.toObservable(names), + Observable<Integer> o = Observable.toObservable(1, 2, 3, 4, 5, 6);, + Observable<String> o = Observable.toObservable("a", "b", "c");, + Observable<Integer> o = Observable.toObservable(list);, +++ b/language-adaptors/rxjava-groovy/README.md, + Observable.toObservable("one", "two", "three"), +++ b/language-adaptors/rxjava-groovy/src/examples/groovy/rx/lang/groovy/examples/RxExamples.groovy, + Observable.toObservable(names), + Observable<Integer> o = Observable.toObservable(1, 2, 3, 4, 5, 6);, + Observable<String> o = Observable.toObservable("a", "b", "c");, + Observable<Integer> o = Observable.toObservable(list);, +++ b/language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/ObservableTests.groovy, + Observable.filter(Observable.toObservable(1, 2, 3), {it >= 2}).subscribe({ result -> a.received(result)});, + assertEquals("three", Observable.toObservable("one", "two", "three").last()), + assertEquals("two", Observable.toObservable("one", "two", "three").last({ x -> x.length() == 3})), + Observable.map(Observable.toObservable(1,
[+++ b/gradle.properties, +version=0.19.2]
[+++ b/src/main/java/io/reactivex/internal/operators/single/SingleFlatMap.java, +import io.reactivex.internal.disposables.SequentialDisposable;, + protected void subscribeActual(SingleObserver<? super R> subscriber) {, + SingleFlatMapCallback<T, R> parent = new SingleFlatMapCallback<T, R>(subscriber, mapper);, + subscriber.onSubscribe(parent.sd);, + source.subscribe(parent);, + static final class SingleFlatMapCallback<T, R> implements SingleObserver<T> {, + final SequentialDisposable sd;, +, + this.sd = new SequentialDisposable();, + sd.replace(d);, + o = mapper.apply(value);, + if (o == null) {, + actual.onError(new NullPointerException("The single returned by the mapper is null"));, + return;, + }, +, + if (sd.isDisposed()) {, + return;, + }, +, + o.subscribe(new SingleObserver<R>() {, + @Override, + public void onSubscribe(Disposable d) {, + sd.replace(d);, + }, +, + @Override,
[+++ b/.gitignore, +.m2, +target/, +build/, +bin/, +, +# Scala build, +*.cache, +++ b/.gitignore, +.m2, +target/, +build/, +bin/, +, +# Scala build, +*.cache, +++ b/CHANGES.md, +# RxJava Releases #, +, +### Version 0.7.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.7.0%22)) ###, +, +This release adds the foundations of Rx Schedulers., +, +There are still open questions, portions not implemented and assuredly bugs and behavior we didn't understand and thus implemented wrong., +, +Please provide bug reports, pull requests or feedback to help us on the road to version 1.0 and get schedulers implemented correctly., +, +See https://github.com/Netflix/RxJava/issues/19#issuecomment-15979582 for some known open questions that we could
[+++ b/build.gradle, + perf {, + java {, + srcDir 'src/perf/java', + compileClasspath += main.output, + runtimeClasspath += main.output, + }, + }, + }, +, + dependencies {, + perfCompile 'org.openjdk.jmh:jmh-core:0.2', + plusConfigurations += configurations.perfCompile, + // TODO not sure what to add it to, + //scopes.PROVIDED.plus += configurations.perfCompile, +++ b/build.gradle, + perf {, + java {, + srcDir 'src/perf/java', + compileClasspath += main.output, + runtimeClasspath += main.output, + }, + }, + }, +, + dependencies {, + perfCompile 'org.openjdk.jmh:jmh-core:0.2', + plusConfigurations += configurations.perfCompile, + // TODO not sure what to add it to, + //scopes.PROVIDED.plus +=
[+++ b/src/main/java/io/reactivex/Completable.java, + * Implement this method to handle the incoming {@link CompletableObserver}s and, + * <p>There is no need to call any of the plugin hooks on the current {@code Completable} instance or, + * the {@code CompletableObserver}; all hooks and basic safeguards have been, + * applied by {@link #subscribe(CompletableObserver)} before this method gets called., +++ b/src/main/java/io/reactivex/Completable.java, + * Implement this method to handle the incoming {@link CompletableObserver}s and, + * <p>There is no need to call any of the plugin hooks on the current {@code Completable} instance or, + * the {@code CompletableObserver}; all hooks and
[+++ b/rxjava-core/src/main/java/rx/Observable.java, + return nest().lift(new OperatorRetry<T>());, + return nest().lift(new OperatorRetry<T>(retryCount));, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return nest().lift(new OperatorRetry<T>());, + return nest().lift(new OperatorRetry<T>(retryCount));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return nest().lift(new OperatorRetry<T>());, + return nest().lift(new OperatorRetry<T>(retryCount));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorRetry.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or
[+++ b/CHANGES.md, +### Version 0.19.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.19.2%22)) ###, +, +* [Pull 1388] (https://github.com/Netflix/RxJava/pull/1388) CompositeException stops mutating nested Exceptions, +* [Pull 1387] (https://github.com/Netflix/RxJava/pull/1387) Upgrade to JMH 0.9, +* [Pull 1297] (https://github.com/Netflix/RxJava/pull/1297) [RxScala] rxjava-scalaz: providing some type class instances, +* [Pull 1332] (https://github.com/Netflix/RxJava/pull/1332) IOSSchedulers for RoboVM, +* [Pull 1380] (https://github.com/Netflix/RxJava/pull/1380) Variety of Fixes, +* [Pull 1379] (https://github.com/Netflix/RxJava/pull/1379) Parallel Operator Rewrite, +* [Pull 1378] (https://github.com/Netflix/RxJava/pull/1378) BugFix: Pivot Concurrency, +* [Pull 1376] (https://github.com/Netflix/RxJava/pull/1376) Revision of JMH Tests, +* [Pull 1375] (https://github.com/Netflix/RxJava/pull/1375) RxScala: Add idiomatic toXXX methods, +* [Pull 1367] (https://github.com/Netflix/RxJava/pull/1367) Fix the bug that 'flatMap' swallows OnErrorNotImplementedException, +* [Pull 1374] (https://github.com/Netflix/RxJava/pull/1374) Fix head/tail
[+++ b/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java, + Scheduler scheduler = spy(OperatorTester.UnitTest.forwardingScheduler(Schedulers.immediate()));, +++ b/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java, + Scheduler scheduler = spy(OperatorTester.UnitTest.forwardingScheduler(Schedulers.immediate()));, +++ b/rxjava-core/src/main/java/rx/operators/OperationSubscribeOn.java, + Scheduler scheduler = spy(OperatorTester.UnitTest.forwardingScheduler(Schedulers.immediate()));, +++ b/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java, + Scheduler scheduler = spy(OperatorTester.UnitTest.forwardingScheduler(Schedulers.immediate()));, +++ b/rxjava-core/src/main/java/rx/operators/OperationSubscribeOn.java, + Scheduler scheduler = spy(OperatorTester.UnitTest.forwardingScheduler(Schedulers.immediate()));, +++ b/rxjava-core/src/main/java/rx/operators/OperationTake.java, +import static rx.operators.OperatorTester.UnitTest.*;, +++ b/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java, + Scheduler scheduler = spy(OperatorTester.UnitTest.forwardingScheduler(Schedulers.immediate()));, +++ b/rxjava-core/src/main/java/rx/operators/OperationSubscribeOn.java, + Scheduler scheduler = spy(OperatorTester.UnitTest.forwardingScheduler(Schedulers.immediate()));, +++ b/rxjava-core/src/main/java/rx/operators/OperationTake.java, +import static rx.operators.OperatorTester.UnitTest.*;, +++ b/rxjava-core/src/main/java/rx/operators/OperatorTester.java, +/**, + * Copyright 2013 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may
[+++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/build.gradle, +// Establish version and status, +ext.githubProjectName = rootProject.name // Change if github project name is not the same as the root project's name, + repositories {, + mavenLocal(), + mavenCentral() // maven { url 'http://jcenter.bintray.com' }, + }, + repositories { , + mavenCentral() // maven { url: 'http://jcenter.bintray.com'
[+++ b/gradle.properties, +version=0.14.12-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/subjects/CompletableSubject.java, +/**, + * Copyright 2016 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language governing
[+++ b/.travis.yml]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * <p>, + * If any of the sources never produces an item but only terminates (normally or with an error), the, + * resulting sequence terminates immediately (normally or with all the errors accumulated till that point)., + * If that input source is also synchronous, other sources after it will not be subscribed to., + * <p>, + * If any of the sources never produces an item but only terminates (normally or with an error), the, + * resulting sequence terminates immediately (normally or with all the errors accumulated till that point)., +
[+++ b/gradle.properties, +version=0.9.2-SNAPSHOT]
[+++ b/src/test/java/io/reactivex/tck/CompletableAndThenPublisherTckTest.java, +/**, + * Copyright (c) 2016-present, RxJava Contributors., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAt.java, + if (!done) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAt.java, + if (!done) {, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableElementAtTest.java, +import io.reactivex.*;, +import io.reactivex.exceptions.TestException;, +import io.reactivex.functions.Function;, +import io.reactivex.internal.subscriptions.BooleanSubscription;, +import io.reactivex.plugins.RxJavaPlugins;, +import java.util.List;, +import org.reactivestreams.*;, +, +, + @Test, + public void doubleOnSubscribe() {, + TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Publisher<Object>>() {, + @Override, + public Publisher<Object> apply(Flowable<Object> o) throws Exception {, + return o.elementAt(0).toFlowable();, + }, + });, + }, +, + @Test, + public void elementAtIndex1WithDefaultOnEmptySourceObservable() {, + Flowable.empty(), + .elementAt(1, 10), + .toFlowable(), + .test(), + .assertResult(10);, + }, +, + @Test, + public void errorFlowable() {, + Flowable.error(new TestException()), + .elementAt(1, 10), + .toFlowable(), +
[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/ScalaAdaptor.scala, +/**, + * Copyright 2013 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for
[+++ b/src/main/java/io/reactivex/internal/fuseable/SimplePlainQueue.java, +/**, + * Copyright 2016 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language governing
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationTakeTimed;, + Subscription s = f.onSubscribe(observer);, + if (s != null) {, + observer.add(s);, + }, + return create(new OperationTakeTimed.TakeTimed<T>(this, time, unit, scheduler));, + Boolean isInternal = (p != null && p.getName().startsWith("rx.operators"));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationTakeTimed;, + Subscription s = f.onSubscribe(observer);, + if (s != null) {, + observer.add(s);, + }, + return create(new OperationTakeTimed.TakeTimed<T>(this, time, unit, scheduler));, + Boolean isInternal = (p != null && p.getName().startsWith("rx.operators"));, +++ b/rxjava-core/src/main/java/rx/operators/OperationTakeTimed.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use
[+++ b/src/main/java/io/reactivex/Flowable.java, + * <dd>Backpressure is honored towards the downstream and the inner Publishers are, + * <em>Important note:</em> This Publisher is blocking on the thread it gets subscribed on; you cannot unsubscribe from it., + * return value of the {@link Future#get} method of that object, by passing the object into the {@code fromFuture}, + * <em>Important note:</em> This Publisher is blocking on the thread it gets subscribed on; you cannot unsubscribe from it., + * Flattens an array of Publishers into one Flowable, in a way that allows an Subscriber to receive all, + * @return a
[+++ b/src/main/java/io/reactivex/BackpressureStrategy.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the
[+++ b/src/main/java/io/reactivex/internal/operators/parallel/ParallelRunOn.java, +import io.reactivex.internal.schedulers.SchedulerMultiWorkerSupport;, +import io.reactivex.internal.schedulers.SchedulerMultiWorkerSupport.WorkerCallback;, + public void subscribe(final Subscriber<? super T>[] subscribers) {, + final Subscriber<T>[] parents = new Subscriber[n];, + if (scheduler instanceof SchedulerMultiWorkerSupport) {, + SchedulerMultiWorkerSupport multiworker = (SchedulerMultiWorkerSupport) scheduler;, + multiworker.createWorkers(n, new MultiWorkerCallback(subscribers, parents));, + for (int i = 0; i < n; i++) {, + createSubscriber(i, subscribers, parents, scheduler.createWorker());, + void createSubscriber(int i, Subscriber<? super T>[] subscribers,, + Subscriber<T>[] parents, Scheduler.Worker worker) {, +, + Subscriber<? super T> a = subscribers[i];, +, + SpscArrayQueue<T> q = new SpscArrayQueue<T>(prefetch);, +, + if (a instanceof ConditionalSubscriber) {, + parents[i] = new RunOnConditionalSubscriber<T>((ConditionalSubscriber<? super T>)a, prefetch,
[+++ b/gradle.properties, +version=0.19.2-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounce.java, +import io.reactivex.exceptions.*;, +import io.reactivex.internal.functions.ObjectHelper;, + actual.onError(new MissingBackpressureException("Could not deliver value due to lack of requests"));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounce.java, +import io.reactivex.exceptions.*;, +import io.reactivex.internal.functions.ObjectHelper;, + actual.onError(new MissingBackpressureException("Could not deliver value due to lack of requests"));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java, +import io.reactivex.exceptions.MissingBackpressureException;, +import io.reactivex.internal.disposables.DisposableHelper;, + actual.onError(new MissingBackpressureException("Could not deliver value due to lack of requests"));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounce.java, +import io.reactivex.exceptions.*;, +import io.reactivex.internal.functions.ObjectHelper;, + actual.onError(new MissingBackpressureException("Could not deliver value due to lack of requests"));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDebounceTimed.java, +import io.reactivex.exceptions.MissingBackpressureException;, +import io.reactivex.internal.disposables.DisposableHelper;, + actual.onError(new MissingBackpressureException("Could not deliver value due to lack of requests"));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableIntervalRange.java, +import io.reactivex.exceptions.MissingBackpressureException;, +import io.reactivex.internal.disposables.DisposableHelper;, + actual.onError(new MissingBackpressureException("Can't deliver value " + count
[+++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java, +import java.util.function.*;, +, + * Utility class to inject handlers to certain standard RxJava operations., +public final class RxJavaPlugins {, + static final Consumer<Throwable> DEFAULT_ERROR_HANDLER = error -> {, + };, + , + static volatile Consumer<Throwable> errorHandler = DEFAULT_ERROR_HANDLER;, + , + static volatile Function<Subscriber<Object>, Subscriber<Object>> onSubscribeHandler = e -> e;, + , + static volatile Function<Publisher<Object>, Publisher<Object>> onCreateHandler = e -> e;, +, + static volatile Function<Runnable, Runnable> onScheduleHandler = r -> r;, +, + static volatile Function<Scheduler, Scheduler> onInitComputationHandler = s -> s;, + , + static volatile Function<Scheduler, Scheduler> onInitSingleHandler = s ->
[+++ b/CHANGES.md, +### Version 0.20.0-RC3 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.20.0-RC3%22)) ###, +, +Version 0.20.0-RC3 preview release fixes several bugs related to backpressure and adds `retryWhen`, `repeatWhen` for more advanced recursion use cases like retry with exponential backoff., +, +This version passed the Netflix API production canary process. Please test this against your code to help us find any issues before we release 0.20.0., +, +* [Pull 1493] (https://github.com/Netflix/RxJava/pull/1493) retryWhen/repeatWhen, +* [Pull 1494] (https://github.com/Netflix/RxJava/pull/1494) zipWith, +* [Pull 1501] (https://github.com/Netflix/RxJava/pull/1501) blocking synchronous next, +* [Pull 1498] (https://github.com/Netflix/RxJava/pull/1498) non-deterministic testUserSubscriberUsingRequestAsync, +* [Pull 1497] (https://github.com/Netflix/RxJava/pull/1497) spsc ring buffer concurrency test, +* [Pull 1496] (https://github.com/Netflix/RxJava/pull/1496) Change RxRingBuffer
[+++ b/rxjava-contrib/rxjava-android/build.gradle, + provided 'com.pivotallabs:robolectric:1.2', +++ b/rxjava-contrib/rxjava-android/build.gradle, + provided 'com.pivotallabs:robolectric:1.2', +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/testsupport/AndroidTestRunner.java, +package rx.android.testsupport;, +, +import com.xtremelabs.robolectric.RobolectricConfig;, +import com.xtremelabs.robolectric.RobolectricTestRunner;, +import org.junit.runners.model.InitializationError;, +, +import java.io.File;, +, +public class AndroidTestRunner extends RobolectricTestRunner {, +, + public AndroidTestRunner(Class<?> testClass) throws InitializationError {, + super(testClass, new RobolectricConfig(new File("src/test/resources")));, + }, +}, +++ b/rxjava-contrib/rxjava-android/build.gradle, + provided 'com.pivotallabs:robolectric:1.2', +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/testsupport/AndroidTestRunner.java, +package rx.android.testsupport;, +, +import com.xtremelabs.robolectric.RobolectricConfig;, +import com.xtremelabs.robolectric.RobolectricTestRunner;, +import org.junit.runners.model.InitializationError;, +, +import java.io.File;, +, +public class AndroidTestRunner extends RobolectricTestRunner {, +, + public AndroidTestRunner(Class<?> testClass) throws InitializationError {, + super(testClass, new RobolectricConfig(new File("src/test/resources")));, + }, +}, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/testsupport/R.java, +package rx.android.testsupport;, +, +public class R {, +
[+++ b/src/main/java/io/reactivex/BackpressureOverflowStrategy.java, + * Copyright (c) 2016-present, RxJava Contributors., +++ b/src/main/java/io/reactivex/BackpressureOverflowStrategy.java, + * Copyright (c) 2016-present, RxJava Contributors., +++ b/src/main/java/io/reactivex/BackpressureStrategy.java, + * Copyright (c) 2016-present, RxJava Contributors., +++ b/src/main/java/io/reactivex/BackpressureOverflowStrategy.java, + * Copyright (c) 2016-present, RxJava Contributors., +++ b/src/main/java/io/reactivex/BackpressureStrategy.java, + * Copyright (c) 2016-present, RxJava Contributors., +++ b/src/main/java/io/reactivex/Completable.java, + * Copyright (c) 2016-present, RxJava Contributors., +++ b/src/main/java/io/reactivex/BackpressureOverflowStrategy.java, + * Copyright (c) 2016-present, RxJava Contributors., +++ b/src/main/java/io/reactivex/BackpressureStrategy.java, + * Copyright (c) 2016-present, RxJava Contributors., +++ b/src/main/java/io/reactivex/Completable.java, + * Copyright (c) 2016-present, RxJava Contributors., +++ b/src/main/java/io/reactivex/CompletableEmitter.java, + * Copyright (c) 2016-present, RxJava Contributors., +++ b/src/main/java/io/reactivex/BackpressureOverflowStrategy.java, + * Copyright (c) 2016-present, RxJava Contributors.,
[+++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, +import rx.Observable.OnSubscribe;, +import rx.Observer;, +public class GroovyCreateWrapper<T> implements OnSubscribe<T> {, + public void call(Observer<? super T> op) {, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, +import rx.Observable.OnSubscribe;, +import rx.Observer;, +public class GroovyCreateWrapper<T> implements OnSubscribe<T> {, + public void call(Observer<? super T> op) {, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, + Observable.empty[Medal], +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, +import rx.Observable.OnSubscribe;, +import rx.Observer;, +public class GroovyCreateWrapper<T> implements OnSubscribe<T> {, + public void call(Observer<? super T> op) {, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, + Observable.empty[Medal], +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, + val numbers = Observable.interval(250 millis) take 14, + val grouped = numbers.groupByUntil[Long, Long](, + {case x => x % 2},, + {case (key, obs) => obs filter {case
[+++ b/gradle.properties, +version=0.14.8]
[+++ b/src/main/java/io/reactivex/Maybe.java, +import java.util.NoSuchElementException;, + * Returns a {@link Single} based on applying a specified function to the item emitted by the, + * source {@link Maybe}, where that function returns a {@link Single}., + * When this Maybe completes a {@link NoSuchElementException} will be thrown., + * <p>, + * <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMapSingle.png" alt="">, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code flatMapSingle} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + *, + * @param mapper, + * a function that, when applied to the item emitted by the source
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Maps the upstream items into {@link MaybeSource}s and switches (subscribes) to the newer ones, + * while disposing the older ones (and ignoring their signals) and emits the latest success value of the current one if, + * available while failing immediately if this {@code Flowable} or any of the, + * active inner {@code MaybeSource}s fail., + * <p>, + * <img width="640" height="350" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMap.png" alt="">, + * <dl>, + * <dt><b>Backpressure:</b></dt>, + * <dd>The operator honors backpressure from downstream. The main {@code Flowable} is consumed in an, + * unbounded manner (i.e., without
[+++ b/src/main/java/io/reactivex/observers/DisposableCompletableObserver.java, +/**, + * Copyright 2016 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language governing
[+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableAmb.java, + c.subscribe(new Amb(once, set, observer));, +, + final AtomicBoolean once;, +, + final CompositeDisposable set;, +, + final CompletableObserver downstream;, +, + Disposable upstream;, + set.delete(upstream);, + set.delete(upstream);, + upstream = d;, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableAmb.java, + c.subscribe(new Amb(once, set, observer));, +, + final AtomicBoolean once;, +, + final CompositeDisposable set;, +, + final CompletableObserver downstream;, +, + Disposable upstream;, + set.delete(upstream);, + set.delete(upstream);, + upstream = d;, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeAmb.java, + CompositeDisposable set = new CompositeDisposable();, + observer.onSubscribe(set);, +, + AtomicBoolean winner = new AtomicBoolean();, + if (set.isDisposed()) {, + set.dispose();, + NullPointerException ex = new NullPointerException("One of the
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.19.2-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.19.2-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, + * {@code cache} with initial capacity., + *, + * @param capacity, + * initial cache size, + * @return an Observable that, when first subscribed to, caches all of its items and notifications for the, + * benefit of subsequent subscribers, + * @see <a href="https://github.com/Netflix/RxJava/wiki/Observable-Utility-Operators#cache">RxJava Wiki: cache()</a>, + */, + public final Observable<T> cache(int capacity) {, + return create(new OnSubscribeCache<T>(this, capacity));, + }, +, + /**, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.19.2-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, + * {@code cache} with initial capacity., + *,
[+++ b/src/main/java/io/reactivex/Observable.java, + public final <U> Observable<T> debounce(Function<? super T, ? extends Publisher<U>> debounceSelector) {, + return lift(new OperatorDebounce<>(debounceSelector));, + }, +, + public final Observable<T> debounce(long timeout, TimeUnit unit) {, + return debounce(timeout, unit, Schedulers.computation());, + }, +, + public final Observable<T> debounce(long timeout, TimeUnit unit, Scheduler scheduler) {, + return lift(new OperatorDebounceTimed<>(timeout, unit, scheduler));, + }, + , + public final Observable<T> throttleWithTimeout(long timeout, TimeUnit unit) {, + return debounce(timeout, unit);, + }, + , + public final Observable<T> throttleWithTimeout(long timeout, TimeUnit unit, Scheduler scheduler) {, + return debounce(timeout, unit, scheduler);, + }, +, +++ b/src/main/java/io/reactivex/Observable.java, +
[+++ b/README.md, +# RxJava: Reactive Programming on the JVM, +++ b/README.md, +# RxJava: Reactive Programming on the JVM, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, +++ b/README.md, +# RxJava: Reactive Programming on the JVM, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, +++ /dev/null, +++ b/README.md, +# RxJava: Reactive Programming on the JVM, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, +++ /dev/null, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/ListeningFragmentActivity.java, +import static rx.android.schedulers.AndroidSchedulers.mainThread;, + strings = SampleObservables.numberStrings(1, 50, 250).observeOn(mainThread()).publish();, + subscription = strings.subscribe(new Subscriber<String>() {, +++ b/README.md, +# RxJava: Reactive Programming on the JVM, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, +++ /dev/null, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/ListeningFragmentActivity.java, +import static rx.android.schedulers.AndroidSchedulers.mainThread;, + strings = SampleObservables.numberStrings(1, 50, 250).observeOn(mainThread()).publish();, + subscription = strings.subscribe(new Subscriber<String>() {, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/RetainedFragmentActivity.java, +import rx.android.schedulers.AndroidSchedulers;, + strings
[+++ b/gradle.properties, +version=0.11.4-SNAPSHOT]
[+++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, + implicit def scalaInnerToJavaInner(s: Inner): rx.Scheduler.Inner = s.asJavaInner, + implicit def javaInnerToScalaInner(s: rx.Scheduler.Inner): Inner = Inner(s), +, +, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, + implicit def scalaInnerToJavaInner(s: Inner): rx.Scheduler.Inner = s.asJavaInner, + implicit def javaInnerToScalaInner(s: rx.Scheduler.Inner): Inner = Inner(s), +, +, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Notification.scala, + Notification(rx.Notification.createOnNext[T](value)), + Notification(rx.Notification.createOnError[T](error)), + Notification(rx.Notification.createOnCompleted[T]()), +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, + implicit def scalaInnerToJavaInner(s: Inner): rx.Scheduler.Inner = s.asJavaInner, + implicit def javaInnerToScalaInner(s: rx.Scheduler.Inner):
[+++ b/src/main/java/io/reactivex/Single.java, + * <p>, + * <img width="640" height="458" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.hide.png" alt="">]
[+++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.exceptions.Exceptions;, +++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.exceptions.Exceptions;, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.exceptions.Exceptions;, +import io.reactivex.internal.util.ArrayListSupplier;, +++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.exceptions.Exceptions;, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.exceptions.Exceptions;, +import io.reactivex.internal.util.ArrayListSupplier;, +++ b/src/main/java/io/reactivex/Observable.java, +import io.reactivex.exceptions.Exceptions;, +import io.reactivex.internal.util.ArrayListSupplier;, +++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.exceptions.Exceptions;, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.exceptions.Exceptions;, +import io.reactivex.internal.util.ArrayListSupplier;, +++ b/src/main/java/io/reactivex/Observable.java, +import io.reactivex.exceptions.Exceptions;, +import io.reactivex.internal.util.ArrayListSupplier;, +++ b/src/main/java/io/reactivex/Scheduler.java, +import io.reactivex.exceptions.Exceptions;, +++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.exceptions.Exceptions;, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.exceptions.Exceptions;, +import io.reactivex.internal.util.ArrayListSupplier;, +++ b/src/main/java/io/reactivex/Observable.java, +import io.reactivex.exceptions.Exceptions;, +import io.reactivex.internal.util.ArrayListSupplier;, +++ b/src/main/java/io/reactivex/Scheduler.java, +import io.reactivex.exceptions.Exceptions;, +++ b/src/main/java/io/reactivex/Single.java, +import io.reactivex.exceptions.Exceptions;, +++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.exceptions.Exceptions;, +++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.exceptions.Exceptions;, +import io.reactivex.internal.util.ArrayListSupplier;, +++ b/src/main/java/io/reactivex/Observable.java, +import io.reactivex.exceptions.Exceptions;, +import io.reactivex.internal.util.ArrayListSupplier;, +++ b/src/main/java/io/reactivex/Scheduler.java, +import io.reactivex.exceptions.Exceptions;, +++ b/src/main/java/io/reactivex/Single.java, +import io.reactivex.exceptions.Exceptions;, +++
[+++ b/src/main/java/io/reactivex/Observable.java, + return new ObservableConcatMap(sources, Functions.identity(), bufferSize);, + return new ObservableFlatMap(sources, Functions.identity(), false, Integer.MAX_VALUE, bufferSize());, + return new ObservableFlatMap(sources, Functions.identity(), false, maxConcurrency, bufferSize());, + return new ObservableFlatMap(sources, Functions.identity(), true, Integer.MAX_VALUE, bufferSize());, + return new ObservableFlatMap(sources, Functions.identity(), true, maxConcurrency, bufferSize());, + return new ObservableSwitchMap(sources, Functions.identity(), bufferSize);, + return new ObservableToList(sources, 16), + return new ObservableCollect<T, U>(this, initialValueSupplier, collector);, + return new ObservableConcatMap<T, R>(this, mapper, prefetch);, + return new ObservableCount<T>(this);, + return new ObservableDebounce<T, U>(this, debounceSelector);, + return new ObservableDebounceTimed<T>(this, timeout, unit, scheduler);, + return new ObservableTake<U>(itemDelay.apply(v), 1).map(new Function<U, T>() {, + return new ObservableDelay<T>(this, delay, unit, scheduler, delayError);, +
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorDematerialize;, + @SuppressWarnings({"unchecked", "rawtypes"}), + return lift(new OperatorDematerialize());, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorDematerialize;, + @SuppressWarnings({"unchecked", "rawtypes"}), + return lift(new OperatorDematerialize());, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorDematerialize;, + @SuppressWarnings({"unchecked", "rawtypes"}), + return lift(new OperatorDematerialize());, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorDematerialize.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by
[+++ b/build.gradle, + classpath "me.champeau.gradle:jmh-gradle-plugin:0.4.5", + jvmArgs = ["-Djmh.ignoreLock=true"], +++ b/build.gradle, + classpath "me.champeau.gradle:jmh-gradle-plugin:0.4.5", + jvmArgs = ["-Djmh.ignoreLock=true"], +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, + classpath "me.champeau.gradle:jmh-gradle-plugin:0.4.5", + jvmArgs = ["-Djmh.ignoreLock=true"], +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.3.1-bin.zip, +++ b/build.gradle, + classpath "me.champeau.gradle:jmh-gradle-plugin:0.4.5", + jvmArgs = ["-Djmh.ignoreLock=true"], +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.3.1-bin.zip, +++ b/src/jmh/java/io/reactivex/TakeUntilPerf.java, +/**, + * Copyright (c) 2016-present, RxJava Contributors., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0,
[+++ b/language-adaptors/rxjava-scala/README.md, +Alternative Rx bindings for Scala, +=================================, +The current RxScala binding attempt to optimize for seamless interop between Scala and Java., +The intended interop is illustrated by the following example where in Scala a class is defined that takes, +an `Observable[Movie]` that is transformed using RxScala operators:, +class MovieLib(val moviesStream: Observable[Movie]) {, + val threshold = 1200, + def shortMovies: Observable[Movie] = ???, + def longMovies: Observable[Movie] = ???, +}, +which is then called in Java, passing a Java `Observable<Movie>` to the constructor, +```java, +public void test() {, + MovieLib lib = new MovieLib(Observable.from(...));, + lib.longMovies().subscribe(moviePrinter);, +}, +```,
[+++ b/gradle.properties, +version=0.17.5]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDoAfterNext.java, + if (done) {, + return;, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDoAfterNext.java, + if (done) {, + return;, + }, +++ b/src/test/java/io/reactivex/flowable/FlowableDoAfterNextTest.java, +/**, + * Copyright 2016 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS"
[+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java, +import rx.operators.OperatorObserveFromAndroidComponent;, + return OperatorObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, activity);, + return OperatorObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (android.support.v4.app.Fragment) fragment);, + return OperatorObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (Fragment) fragment);, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java, +import rx.operators.OperatorObserveFromAndroidComponent;, + return OperatorObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, activity);, + return OperatorObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (android.support.v4.app.Fragment) fragment);, + return OperatorObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (Fragment) fragment);, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/subscriptions/AndroidSubscriptions.java, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed
[+++ b/src/main/java/io/reactivex/disposables/CompositeDisposable.java, + @Override, + @Override, + @Override, +++ b/src/main/java/io/reactivex/disposables/CompositeDisposable.java, + @Override, + @Override, + @Override, +++ b/src/main/java/io/reactivex/disposables/Disposable.java, + * @return true if this resource has been disposed, +++ b/src/main/java/io/reactivex/disposables/CompositeDisposable.java, + @Override, + @Override, + @Override, +++ b/src/main/java/io/reactivex/disposables/Disposable.java, + * @return true if this resource has been disposed, +++ b/src/main/java/io/reactivex/internal/disposables/ListCompositeDisposable.java, + @Override, + @Override, + @Override, +++ b/src/main/java/io/reactivex/disposables/CompositeDisposable.java, + @Override, + @Override, + @Override, +++ b/src/main/java/io/reactivex/disposables/Disposable.java, + * @return true if this resource has been disposed, +++ b/src/main/java/io/reactivex/internal/disposables/ListCompositeDisposable.java, + @Override, + @Override, + @Override, +++ b/src/main/java/io/reactivex/internal/subscribers/flowable/BasicFuseableConditionalSubscriber.java, + @Override, + * Rethrows the throwable if it is a fatal exception
[+++ b/src/main/java/io/reactivex/Flowable.java, + * <p>, + * Note that calling this method will block the caller thread until the upstream terminates, + * normally or with an error. Therefore, calling this method from special threads such as the, + * Android Main Thread or the Swing Event Dispatch Thread is not recommended., + * @see #blockingSubscribe(Consumer), + * @see #blockingSubscribe(Consumer, Consumer), + * @see #blockingSubscribe(Consumer, Consumer, Action), + * Using the overloads {@link #blockingSubscribe(Consumer, Consumer)}, + * or {@link #blockingSubscribe(Consumer, Consumer, Action)} instead is recommended., + * <p>, + * Note that calling this method will block the caller
[+++ b/gradle.properties, +version=0.8.0]
[+++ b/gradle.properties, +version=0.5.1-SNAPSHOT]
[+++ b/build.gradle, +apply plugin: "eclipse", +def guavaVersion = "24.0-jre", + testImplementation "com.google.guava:guava:$guavaVersion", +++ b/build.gradle, +apply plugin: "eclipse", +def guavaVersion = "24.0-jre", + testImplementation "com.google.guava:guava:$guavaVersion", +++ b/src/main/java/io/reactivex/Flowable.java, + return RxJavaPlugins.onAssembly(new FlowableGroupBy<T, K, V>(this, keySelector, valueSelector, bufferSize, delayError, null));, + }, +, + /**, + * Groups the items emitted by a {@code Publisher} according to a specified criterion, and emits these, + * grouped items as {@link GroupedFlowable}s. The emitted {@code GroupedFlowable} allows only a single, + * {@link Subscriber} during its lifetime and if this {@code Subscriber} cancels before the, + * source terminates, the next emission by the
[+++ b/src/main/java/io/reactivex/Flowable.java, + * the type of item emitted by the resulting Iterable, + * the type of item emitted by the resulting Iterable, + * the type of item emitted by the resulting Iterable, +++ b/src/main/java/io/reactivex/Flowable.java, + * the type of item emitted by the resulting Iterable, + * the type of item emitted by the resulting Iterable, + * the type of item emitted by the resulting Iterable, +++ b/src/main/java/io/reactivex/Maybe.java, + * Returns a Flowable that merges each item emitted by the source Maybe with the values in an, + * Iterable corresponding to that item that
[+++ b/build.gradle, + apply plugin: 'shadow', + task perfJar(type: Jar, dependsOn: perfClasses) {, + from sourceSets.perf.output + sourceSets.main.output, + }, +, + artifacts {, + perfRuntime perfJar, + }, + , + /**, + * By default: Run without arguments this will execute all benchmarks that are found (can take a long time)., + *, + * Optionally pass arguments for custom execution. Example:, + *, + * ../gradlew benchmarks '-Pjmh=-f 1 -tu ns -bm avgt -wi 5 -i 5 -r 1 .*OperatorSerializePerf.*', + *, + * To see all options:, + *, + * ../gradlew benchmarks '-Pjmh=-h', +
[+++ /dev/null, +++ /dev/null, +++ b/src/main/java/io/reactivex/observers/Observers.java, + public static <T> ResourceObserver<T> emptyResource() {, + return new ResourceObserver<T>() {, + public static <T> ResourceObserver<T> createResource(Consumer<? super T> onNext) {, + return createResource(onNext, RxJavaPlugins.errorConsumer(), Functions.EMPTY_RUNNABLE, Functions.EMPTY_RUNNABLE);, + public static <T> ResourceObserver<T> createResource(Consumer<? super T> onNext,, + return createResource(onNext, onError, Functions.EMPTY_RUNNABLE, Functions.EMPTY_RUNNABLE);, + public static <T> ResourceObserver<T> createResource(Consumer<? super T> onNext,, + return createResource(onNext, onError, onComplete, Functions.EMPTY_RUNNABLE);, + public static <T> ResourceObserver<T> createResource(, + return new ResourceObserver<T>() {, +++ /dev/null, +++ b/src/main/java/io/reactivex/observers/Observers.java, + public static <T> ResourceObserver<T> emptyResource() {, + return new ResourceObserver<T>() {, + public static <T> ResourceObserver<T> createResource(Consumer<? super T>
[+++ b/gradle.properties, +version=0.20.0-RC1]
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC5-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC5-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, + public <R> Observable<R> compose(Transformer<T, R> transformer) {, + public static interface Transformer<T, R> extends Func1<Observable<T>, Observable<R>> {, + return concat(just(t1, t2));, + return concat(just(t1, t2, t3));, + return concat(just(t1, t2, t3, t4));, + return concat(just(t1, t2, t3, t4, t5));, + return concat(just(t1, t2, t3, t4, t5, t6));, + return concat(just(t1, t2, t3, t4, t5, t6, t7));, + return concat(just(t1, t2, t3, t4, t5, t6, t7, t8));, + return concat(just(t1, t2, t3, t4, t5, t6, t7, t8, t9));, + // TODO in a future revision
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorDebounceWithSelector;, +import rx.operators.OperatorDebounceWithTime;, + return lift(new OperatorDebounceWithSelector<T, U>(debounceSelector));, + return lift(new OperatorDebounceWithTime<T>(timeout, unit, Schedulers.computation()));, + return lift(new OperatorDebounceWithTime<T>(timeout, unit, scheduler));, + return debounce(timeout, unit);, + return debounce(timeout, unit, scheduler);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorDebounceWithSelector;, +import rx.operators.OperatorDebounceWithTime;, + return lift(new OperatorDebounceWithSelector<T, U>(debounceSelector));, + return lift(new OperatorDebounceWithTime<T>(timeout, unit, Schedulers.computation()));, + return lift(new OperatorDebounceWithTime<T>(timeout, unit, scheduler));, + return debounce(timeout, unit);, + return debounce(timeout, unit, scheduler);, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorDebounceWithSelector;, +import rx.operators.OperatorDebounceWithTime;, + return lift(new OperatorDebounceWithSelector<T, U>(debounceSelector));, + return lift(new OperatorDebounceWithTime<T>(timeout, unit, Schedulers.computation()));, + return lift(new OperatorDebounceWithTime<T>(timeout, unit, scheduler));, + return debounce(timeout, unit);, + return debounce(timeout, unit, scheduler);, +++
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/src/main/java/rx/Observable.java, + * termination if <code>disposeEagerly</code> is set to true and unsubscription does not occur before termination. Otherwise, + * resource disposal will occur on unsubscription. Eager disposal is particularly appropriate for a synchronous observable, + * that resuses resources. <code>disposeAction</code> will only be called once per subscription., + * if true then disposal will happen either on unsubscription or just before emission of , + * a terminal event (onComplete or onError)., + * Merges the specified observable sequence into this Observable sequence by using the resultSelector , + * function only when
[+++ b/.gitignore, +++ b/.gitignore, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscriptions.empty()!!, +++ b/.gitignore, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscriptions.empty()!!, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscriptions.empty()!!, +++ b/.gitignore, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscriptions.empty()!!, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscriptions.empty()!!, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, + @Test def combineLatestExample() {, + val first_counter = Observable.interval(250 millis), + val second_counter = Observable.interval(550 millis), + val combined_counter = first_counter.combineLatest(second_counter,, + (x: Long, y: Long) => List(x,y)) take 10, +, + combined_counter subscribe {x => println(s"Emitted group: $x")}, + }, +, +++ b/.gitignore, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscriptions.empty()!!, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscriptions.empty()!!, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, + @Test def combineLatestExample() {, + val first_counter = Observable.interval(250
[+++ b/gradle.properties, +version=0.19.4-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Completable.java, + ObjectHelper.requireNonNull(next, "next is null");, + return RxJavaPlugins.onAssembly(new CompletableAndThenCompletable(this, next));, + return RxJavaPlugins.onAssembly(new CompletableAndThenCompletable(this, other));, +++ b/src/main/java/io/reactivex/Completable.java, + ObjectHelper.requireNonNull(next, "next is null");, + return RxJavaPlugins.onAssembly(new CompletableAndThenCompletable(this, next));, + return RxJavaPlugins.onAssembly(new CompletableAndThenCompletable(this, other));, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableAndThenCompletable.java, +/**, + * Copyright (c) 2016-present, RxJava Contributors., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing,
[+++ b/src/main/java/io/reactivex/observers/TestObserver.java, +++ b/src/main/java/io/reactivex/observers/TestObserver.java, +++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableDoOnTest.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import static org.junit.Assert.*;, +import org.junit.*;, +import io.reactivex.functions.*;, +, + @Test, + public void doOnDisposeCalled() {, + final AtomicBoolean atomicBoolean = new AtomicBoolean();, +, + assertFalse(atomicBoolean.get());, +, + Completable.complete(), + .doOnDispose(new Action() {, + @Override, + public void run() throws Exception {, + atomicBoolean.set(true);, + }, + }), + .test(), + .assertResult(), + .dispose();, +, + assertTrue(atomicBoolean.get());, + }, +++ b/src/main/java/io/reactivex/observers/TestObserver.java, +++ b/src/test/java/io/reactivex/internal/operators/completable/CompletableDoOnTest.java, +import java.util.concurrent.atomic.AtomicBoolean;, +import static org.junit.Assert.*;, +import org.junit.*;, +import io.reactivex.functions.*;, +, + @Test, + public void doOnDisposeCalled() {, + final AtomicBoolean atomicBoolean = new AtomicBoolean();, +, + assertFalse(atomicBoolean.get());, +, +
[+++ b/gradle.properties, +version=0.17.3]
[+++ b/src/main/java/io/reactivex/schedulers/Schedulers.java, +++ b/src/main/java/io/reactivex/schedulers/Schedulers.java, +++ b/src/test/java/io/reactivex/completable/CompletableTest.java, + TestScheduler scheduler = new TestScheduler();, +++ b/src/main/java/io/reactivex/schedulers/Schedulers.java, +++ b/src/test/java/io/reactivex/completable/CompletableTest.java, + TestScheduler scheduler = new TestScheduler();, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java, + TestScheduler test = new TestScheduler();, +++ b/src/main/java/io/reactivex/schedulers/Schedulers.java, +++ b/src/test/java/io/reactivex/completable/CompletableTest.java, + TestScheduler scheduler = new TestScheduler();, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java, + TestScheduler test = new TestScheduler();, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableMergeTest.java, + TestScheduler scheduler1 = new TestScheduler();, + TestScheduler scheduler2 = new TestScheduler();, + TestScheduler scheduler1 = new TestScheduler();, + TestScheduler scheduler2 = new TestScheduler();, + TestScheduler scheduler = new TestScheduler();, +++ b/src/main/java/io/reactivex/schedulers/Schedulers.java, +++ b/src/test/java/io/reactivex/completable/CompletableTest.java, + TestScheduler scheduler = new TestScheduler();, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableDelayTest.java, + TestScheduler test = new TestScheduler();, +++
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorTakeWhile;, + return lift(new OperatorTakeWhile(predicate));, + return lift(new OperatorTakeWhile(predicate));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorTakeWhile;, + return lift(new OperatorTakeWhile(predicate));, + return lift(new OperatorTakeWhile(predicate));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorTakeWhile;, + return lift(new OperatorTakeWhile(predicate));, + return lift(new OperatorTakeWhile(predicate));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorTakeWhile.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + *
[+++ b/rxjava-contrib/rxjava-computation-expressions/src/main/java/rx/Statement.java, +import rx.operators.OperationConditionals;, +public class Statement {, +, + return Observable.create(OperationConditionals.switchCase(caseSelector, mapOfCases, defaultCase));, + public static <T> Observable<T> doWhile(Observable<T> source, Func0<Boolean> postCondition) {, + return Observable.create(OperationConditionals.doWhile(source, postCondition));, + public static <T> Observable<T> whileDo(Observable<T> source, Func0<Boolean> preCondition) {, + return Observable.create(OperationConditionals.whileDo(source, preCondition));, + return Observable.create(OperationConditionals.ifThen(condition, then, orElse));, +++ b/rxjava-contrib/rxjava-computation-expressions/src/main/java/rx/Statement.java, +import rx.operators.OperationConditionals;, +public class Statement {, +, + return Observable.create(OperationConditionals.switchCase(caseSelector, mapOfCases, defaultCase));, + public static <T> Observable<T> doWhile(Observable<T> source, Func0<Boolean> postCondition) {, + return Observable.create(OperationConditionals.doWhile(source, postCondition));, + public static <T> Observable<T> whileDo(Observable<T> source, Func0<Boolean> preCondition) {, + return Observable.create(OperationConditionals.whileDo(source, preCondition));, + return Observable.create(OperationConditionals.ifThen(condition, then, orElse));, +++ b/rxjava-contrib/rxjava-computation-expressions/src/main/java/rx/operators/OperationConditionals.java, +/**, + *
[+++ b/src/main/java/io/reactivex/observers/BaseTestConsumer.java, +/**, + * Copyright 2016 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language governing
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorOnExceptionResumeNextViaObservable;, + return lift(new OperatorOnExceptionResumeNextViaObservable<T>(resumeSequence));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorOnExceptionResumeNextViaObservable;, + return lift(new OperatorOnExceptionResumeNextViaObservable<T>(resumeSequence));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorOnExceptionResumeNextViaObservable;, + return lift(new OperatorOnExceptionResumeNextViaObservable<T>(resumeSequence));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorOnExceptionResumeNextViaObservable.java, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not, + * use this file except in compliance with the License. You may obtain a copy of, + * the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under
[+++ b/gradle.properties, +version=0.16.2-SNAPSHOT, +++ b/gradle.properties, +version=0.16.2-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, + * Perform work on the source {@code Observable<T>} in parallel by sharding it on a {@link Schedulers#computation()} {@link Scheduler}, and return the resulting {@code Observable<R>}., +++ b/gradle.properties, +version=0.16.2-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, + * Perform work on the source {@code Observable<T>} in parallel by sharding it on a {@link Schedulers#computation()} {@link Scheduler}, and return the resulting {@code Observable<R>}., +++ b/rxjava-core/src/main/java/rx/Scheduler.java, + * Copyright 2013 Netflix, Inc., + * Schedules an Action on a new Scheduler instance (typically another thread) for execution., +, + public abstract Subscription schedule(Action1<Scheduler.Inner> action);, + * Schedules an
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, + Subscription upstream;, + if (SubscriptionHelper.validate(this.upstream, s)) {, + this.upstream = s;, + upstream.cancel();, + upstream.request(scalarLimit);, + upstream.request(scalarLimit);, + upstream.cancel();, + if (!delayErrors) {, + upstream.cancel();, + }, + upstream.request(replenishMain);, + upstream.cancel();, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, + Subscription upstream;, + if (SubscriptionHelper.validate(this.upstream, s)) {, + this.upstream = s;, + upstream.cancel();, + upstream.request(scalarLimit);, + upstream.request(scalarLimit);, + upstream.cancel();, + if (!delayErrors) {, + upstream.cancel();, + }, + upstream.request(replenishMain);, + upstream.cancel();, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFlatMapTest.java, +, + @Test, + public void failingFusedInnerCancelsSource() {, + final AtomicInteger counter = new AtomicInteger();, + Flowable.range(1, 5), + .doOnNext(new Consumer<Integer>() {, + @Override, + public void accept(Integer v)
[+++ b/src/main/java/io/reactivex/subjects/UnicastSubject.java, + void doTerminate() {, + Runnable r = onTerminate.get();, + if (r != null && onTerminate.compareAndSet(r, null)) {, + r.run();, + }, + }, +, + onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));, + t = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");, +, + doTerminate();, +, +, + doTerminate();, +, +, + doTerminate();, +, +++ b/src/main/java/io/reactivex/subjects/UnicastSubject.java, + void doTerminate() {, + Runnable r = onTerminate.get();, + if (r != null && onTerminate.compareAndSet(r, null)) {, + r.run();, + },
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.0-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.0-SNAPSHOT, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.0-SNAPSHOT, +++ /dev/null, +++ b/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/ObservableHttp.java, + parentSubscription.add(Subscriptions.from(client.execute(requestProducer, new ResponseConsumerDelegate(observer, parentSubscription),, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.0-SNAPSHOT, +++ /dev/null, +++ b/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/ObservableHttp.java, + parentSubscription.add(Subscriptions.from(client.execute(requestProducer, new ResponseConsumerDelegate(observer, parentSubscription),, +++ b/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ResponseConsumerDelegate.java, + if (response.getFirstHeader("Content-Type").getValue().contains("text/event-stream")) {, + // use 'contains' instead of equals since Content-Type can contain additional information, + // such as charset ... see here: http://www.w3.org/International/O-HTTP-charset, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.14.0-SNAPSHOT, +++ /dev/null, +++ b/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/ObservableHttp.java, + parentSubscription.add(Subscriptions.from(client.execute(requestProducer, new ResponseConsumerDelegate(observer, parentSubscription),, +++ b/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/consumers/ResponseConsumerDelegate.java, + if (response.getFirstHeader("Content-Type").getValue().contains("text/event-stream")) {, + // use 'contains' instead of equals since Content-Type
[+++ b/rxjava-contrib/rxjava-android/build.gradle, +++ b/rxjava-contrib/rxjava-android/build.gradle, +++ b/rxjava-contrib/rxjava-apache-http/build.gradle, +++ b/rxjava-contrib/rxjava-android/build.gradle, +++ b/rxjava-contrib/rxjava-apache-http/build.gradle, +++ b/rxjava-contrib/rxjava-async-util/build.gradle, +++ b/rxjava-contrib/rxjava-android/build.gradle, +++ b/rxjava-contrib/rxjava-apache-http/build.gradle, +++ b/rxjava-contrib/rxjava-async-util/build.gradle, +++ b/rxjava-contrib/rxjava-computation-expressions/build.gradle, +++ b/rxjava-contrib/rxjava-android/build.gradle, +++ b/rxjava-contrib/rxjava-apache-http/build.gradle, +++ b/rxjava-contrib/rxjava-async-util/build.gradle, +++ b/rxjava-contrib/rxjava-computation-expressions/build.gradle, +++ b/rxjava-contrib/rxjava-string/build.gradle, +++ b/rxjava-contrib/rxjava-android/build.gradle, +++ b/rxjava-contrib/rxjava-apache-http/build.gradle, +++ b/rxjava-contrib/rxjava-async-util/build.gradle, +++ b/rxjava-contrib/rxjava-computation-expressions/build.gradle, +++ b/rxjava-contrib/rxjava-string/build.gradle, +++ b/rxjava-contrib/rxjava-swing/build.gradle, +++ b/rxjava-contrib/rxjava-android/build.gradle, +++ b/rxjava-contrib/rxjava-apache-http/build.gradle, +++ b/rxjava-contrib/rxjava-async-util/build.gradle, +++ b/rxjava-contrib/rxjava-computation-expressions/build.gradle, +++ b/rxjava-contrib/rxjava-string/build.gradle, +++ b/rxjava-contrib/rxjava-swing/build.gradle, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationFilter;, +import rx.operators.OnSubscribeFromIterable;, +import rx.operators.OperatorTimeout;, +import rx.operators.OperatorTimeoutWithSelector;, + return source.lift(new OperatorMerge(maxConcurrent)); // any idea how to get these generics working?!, + private final Observable<Observable<T>> nest() {, + if (count < 1) {, + throw new IllegalArgumentException("Count must be positive");, + return create(OperationFilter.filter(this,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.schedulers.TimeInterval;, +import rx.schedulers.Timestamped;, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.schedulers.TimeInterval;, +import rx.schedulers.Timestamped;, +++ b/rxjava-core/src/main/java/rx/operators/OperationReplay.java, +import rx.schedulers.Timestamped;, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.schedulers.TimeInterval;, +import rx.schedulers.Timestamped;, +++ b/rxjava-core/src/main/java/rx/operators/OperationReplay.java, +import rx.schedulers.Timestamped;, +++ b/rxjava-core/src/main/java/rx/operators/OperationSkipLast.java, +import rx.schedulers.Timestamped;, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.schedulers.TimeInterval;, +import rx.schedulers.Timestamped;, +++ b/rxjava-core/src/main/java/rx/operators/OperationReplay.java, +import rx.schedulers.Timestamped;, +++ b/rxjava-core/src/main/java/rx/operators/OperationSkipLast.java, +import rx.schedulers.Timestamped;, +++ b/rxjava-core/src/main/java/rx/operators/OperationTakeLast.java, +import rx.schedulers.Timestamped;, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.schedulers.TimeInterval;, +import rx.schedulers.Timestamped;, +++ b/rxjava-core/src/main/java/rx/operators/OperationReplay.java, +import rx.schedulers.Timestamped;, +++ b/rxjava-core/src/main/java/rx/operators/OperationSkipLast.java, +import rx.schedulers.Timestamped;, +++ b/rxjava-core/src/main/java/rx/operators/OperationTakeLast.java, +import rx.schedulers.Timestamped;, +++ b/rxjava-core/src/main/java/rx/operators/OperationTimeInterval.java, +import rx.schedulers.TimeInterval;, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.schedulers.TimeInterval;, +import rx.schedulers.Timestamped;, +++ b/rxjava-core/src/main/java/rx/operators/OperationReplay.java, +import rx.schedulers.Timestamped;, +++ b/rxjava-core/src/main/java/rx/operators/OperationSkipLast.java, +import rx.schedulers.Timestamped;, +++ b/rxjava-core/src/main/java/rx/operators/OperationTakeLast.java, +import rx.schedulers.Timestamped;, +++ b/rxjava-core/src/main/java/rx/operators/OperationTimeInterval.java, +import rx.schedulers.TimeInterval;, +++ b/rxjava-core/src/main/java/rx/operators/OperatorTimestamp.java, +import rx.schedulers.Timestamped;, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import
[+++ b/build.gradle, +task GCandMem(dependsOn: 'check') << {, + System.gc(), + Thread.sleep(200), + print("Memory usage: "), + println(java.lang.management.ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed() / 1024.0 / 1024.0), +}, +, +jacocoTestReport.dependsOn GCandMem, +, +++ b/build.gradle, +task GCandMem(dependsOn: 'check') << {, + System.gc(), + Thread.sleep(200), + print("Memory usage: "), + println(java.lang.management.ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed() / 1024.0 / 1024.0), +}, +, +jacocoTestReport.dependsOn GCandMem, +, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybe.java, + s.cancel();, + set.dispose();, +++ b/build.gradle, +task GCandMem(dependsOn: 'check') << {, + System.gc(), + Thread.sleep(200), + print("Memory usage: "), + println(java.lang.management.ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed() / 1024.0 / 1024.0), +}, +, +jacocoTestReport.dependsOn GCandMem, +, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapMaybe.java, + s.cancel();, + set.dispose();, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMapSingle.java, + s.cancel();, + set.dispose();, +++ b/build.gradle, +task
[+++ b/src/main/java/io/reactivex/internal/observers/DisposableLambdaObserver.java, + this.s = DisposableHelper.DISPOSED;, + if (s != DisposableHelper.DISPOSED) {, + } else {, + RxJavaPlugins.onError(t);, + }, + if (s != DisposableHelper.DISPOSED) {, + }, +++ b/src/main/java/io/reactivex/internal/observers/DisposableLambdaObserver.java, + this.s = DisposableHelper.DISPOSED;, + if (s != DisposableHelper.DISPOSED) {, + } else {, + RxJavaPlugins.onError(t);, + }, + if (s != DisposableHelper.DISPOSED) {, + }, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletablePeek.java, +import io.reactivex.disposables.Disposable;, +import io.reactivex.internal.disposables.*;, + source.subscribe(new CompletableObserverImplementation(s));, + final class CompletableObserverImplementation implements CompletableObserver, Disposable {, + final CompletableObserver actual;, +, + Disposable d;, +, + private CompletableObserverImplementation(CompletableObserver actual) {, + this.actual = actual;, + }, +, +, + @Override, + public
[+++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, +++ /dev/null, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, +++ /dev/null, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/ListeningFragmentActivity.java, +import static rx.android.schedulers.AndroidSchedulers.mainThread;, + strings = SampleObservables.numberStrings(1, 50, 250).observeOn(mainThread()).publish();, + subscription = strings.subscribe(new Subscriber<String>() {, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, +++ /dev/null, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/ListeningFragmentActivity.java, +import static rx.android.schedulers.AndroidSchedulers.mainThread;, + strings = SampleObservables.numberStrings(1, 50, 250).observeOn(mainThread()).publish();, + subscription = strings.subscribe(new Subscriber<String>() {, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/RetainedFragmentActivity.java, +import rx.android.schedulers.AndroidSchedulers;, + strings = SampleObservables.fakeApiCall(2000).map(PARSE_JSON), + .observeOn(AndroidSchedulers.mainThread()), + .cache();, + subscription = strings.subscribe(new Action1<String>() {, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/AndroidManifest.xml, +++ /dev/null, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/ListeningFragmentActivity.java, +import static rx.android.schedulers.AndroidSchedulers.mainThread;, + strings = SampleObservables.numberStrings(1, 50, 250).observeOn(mainThread()).publish();, + subscription = strings.subscribe(new Subscriber<String>() {, +++ b/rxjava-contrib/rxjava-android-samples/samples/src/main/java/com/netflix/rxjava/android/samples/RetainedFragmentActivity.java, +import rx.android.schedulers.AndroidSchedulers;, + strings = SampleObservables.fakeApiCall(2000).map(PARSE_JSON), + .observeOn(AndroidSchedulers.mainThread()), + .cache();,
[+++ b/src/main/java/io/reactivex/Flowable.java, + * <img width="640" height="237" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstElement.m.png" alt="">, + * <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/first.s.png" alt="">, + * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.f.png" alt="">, + * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.f.png" alt="">, + * <img width="640" height="410" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.f.r.png" alt="">, + * <img width="640" height="410" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.f.r.png" alt="">, +++ b/src/main/java/io/reactivex/Flowable.java, + * <img width="640" height="237" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstElement.m.png" alt="">, + * <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/first.s.png" alt="">, + * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.f.png" alt="">, + * <img width="640" height="310" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.f.png" alt="">, + * <img width="640" height="410" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.f.r.png" alt="">, + * <img width="640" height="410" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flatMapIterable.f.r.png" alt="">, +++ b/src/main/java/io/reactivex/Maybe.java, + * <img width="640" height="373" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/flattenAsFlowable.png" alt="">, + *
[+++ b/src/main/java/io/reactivex/Flowable.java, + * <dd>You specify which {@link Scheduler} this operator will use.</dd>, + * <dd>You specify which {@link Scheduler} this operator will use.</dd>, + * <dd>You specify which {@link Scheduler} this operator will use.</dd>, + * <dd>You specify which {@link Scheduler} this operator will use.</dd>, + * <dd>You specify which {@link Scheduler} this operator will use.</dd>, + * <dd>You specify which {@link Scheduler} this operator will use.</dd>, + * <dd>You specify which {@link Scheduler} this operator will use.</dd>, + * <dd>You specify which {@link Scheduler} this operator will use.</dd>, + * <dd>You specify which {@link Scheduler} this operator
[+++ b/gradle.properties, +version=0.11.0-SNAPSHOT]
[+++ b/CHANGES.md, +### Version 0.14.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.1%22)) ###, +, +* [Pull 402](https://github.com/Netflix/RxJava/pull/402) rxjava-apache-http improvements, +, +### Version 0.14.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.0%22)) ###, +, +Further progress to the Scala adaptor and a handful of new operators., +, +Bump to 0.14.0 due to small breaking change to `distinct` operator removing overloaded methods with `Comparator`. These methods were added in 0.13.2 and determined to be incorrect., +, +This release also includes a new contrib module, [rxjava-apache-http](https://github.com/Netflix/RxJava/tree/master/rxjava-contrib/rxjava-apache-http) that provides an Observable API to the Apache HttpAsyncClient., +, +* [Pull 396](https://github.com/Netflix/RxJava/pull/396) Add missing methods to Scala Adaptor, +* [Pull 390](https://github.com/Netflix/RxJava/pull/390) Operators: ElementAt and ElementAtOrDefault, +*
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCollect.java, +import io.reactivex.plugins.RxJavaPlugins;, + boolean done;, + , + if (done) {, + return;, + }, + onError(e);, + if (done) {, + RxJavaPlugins.onError(t);, + return;, + } , + done = true;, + if (done) {, + return;, + }, + done = true;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableCollect.java, +import io.reactivex.plugins.RxJavaPlugins;, + boolean done;, + , + if (done) {, + return;, + }, + onError(e);, + if (done) {, + RxJavaPlugins.onError(t);, + return;, + } , + done = true;, + if (done) {, + return;, + }, + done = true;, +++ b/src/test/java/io/reactivex/flowable/Burst.java, +/**, + * Copyright 2016
[+++ b/.travis.yml, +# running in container causes test failures and 2x-3x longer build, use standalone instances, +++ b/.travis.yml, +# running in container causes test failures and 2x-3x longer build, use standalone instances, +++ b/HEADER, +Copyright (c) 2016-present, RxJava Contributors., +, +Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, +compliance with the License. You may obtain a copy of the License at, +, +http://www.apache.org/licenses/LICENSE-2.0, +, +Unless required by applicable law or agreed to in writing, software distributed under the License is, +distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, + source.subscribe(subscribe(s, mapper, delayErrors, maxConcurrency, bufferSize));, + }, +, + public static <T, U> Subscriber<T> subscribe(Subscriber<? super U> s,, + Function<? super T, ? extends Publisher<? extends U>> mapper,, + boolean delayErrors, int maxConcurrency, int bufferSize) {, + return new MergeSubscriber<T, U>(s, mapper, delayErrors, maxConcurrency, bufferSize);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, + source.subscribe(subscribe(s, mapper, delayErrors, maxConcurrency, bufferSize));, + }, +, + public static <T, U> Subscriber<T> subscribe(Subscriber<? super U> s,, + Function<? super T, ? extends Publisher<? extends U>> mapper,, + boolean delayErrors, int maxConcurrency, int bufferSize) {, + return new MergeSubscriber<T, U>(s, mapper, delayErrors, maxConcurrency, bufferSize);, +++ b/src/main/java/io/reactivex/internal/operators/parallel/ParallelCollect.java, +import
[+++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/build.gradle, + apply plugin: 'eclipse', + apply plugin: 'idea', +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, + * Applies a timeout policy for each item emitted by the Observable, using, + * the specified scheduler to run timeout timers. If the next item isn't, + * observed within the specified timeout duration starting from its, + * predecessor, observers are
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.13.2-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.13.2-SNAPSHOT, +++ /dev/null, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.13.2-SNAPSHOT, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/TODO.md, +- [ ] ConnectableObservable: Implement adaptor. Note that it cannot extend Scala Observable, since value classes are final., +- [ ] more methods of BlockingObservable, +- [ ] multicast, publish, replay once we have ConnectableObservable, +- [ ] groupBy and GroupedObservable, +- [ ] mirror complete Java package structure in Scala, +- [ ] convert Java futures to Scala futures, +- [ ] Add methods present in Scala collections library, but not in RxJava, e.g. zipWithIndex,
[+++ b/CHANGES.md, +, +### Version 0.20.0-RC6 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.20.0-RC6%22)) ###, +, +Further fixes and enhancements bringing us close to completing 0.20.0 and almost ready for 1.0., +, +A more major change in this release is the deprecation of `Observable.from(T)`. The full discussion can be seen in [#1563](https://github.com/Netflix/RxJava/issues/1563)., +, +* [Pull 1575] (https://github.com/Netflix/RxJava/pull/1575) combineLatest with backpressure, +* [Pull 1569] (https://github.com/Netflix/RxJava/pull/1569) Compose/Transform Covariance, +* [Pull 1577] (https://github.com/Netflix/RxJava/pull/1577) Fix the compose covariance, +* [Pull 1581] (https://github.com/Netflix/RxJava/pull/1581) zip(Iterable) -> zipWith(Iterable), +* [Pull 1582] (https://github.com/Netflix/RxJava/pull/1582) Deprecate GroupedObservable.from, +* [Pull 1583] (https://github.com/Netflix/RxJava/pull/1583) Redo/Repeat Backpressure, +* [Pull 1576] (https://github.com/Netflix/RxJava/pull/1576) from(T) -> just(T), +* [Pull 1545] (https://github.com/Netflix/RxJava/pull/1545) Make
[+++ b/src/main/java/io/reactivex/Single.java, + * <img width="640" height="300" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMapObservable.png" alt="">]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, + if (ex != ExceptionHelper.TERMINATED) {, + }, + Throwable ex = errs.terminate();, + if (ex != ExceptionHelper.TERMINATED) {, + actual.onError(ex);, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, + if (ex != ExceptionHelper.TERMINATED) {, + }, + Throwable ex = errs.terminate();, + if (ex != ExceptionHelper.TERMINATED) {, + actual.onError(ex);, + }, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java, + Throwable ex = errors.terminate();, + if (ex != ExceptionHelper.TERMINATED) {, + child.onError(ex);, + }, + e = errors.terminate();, + if (e != ExceptionHelper.TERMINATED) {, + actual.onError(e);, + }, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFlatMap.java, + if (ex != ExceptionHelper.TERMINATED) {, + }, + Throwable ex = errs.terminate();, + if (ex
[+++ b/src/main/java/io/reactivex/Maybe.java, + * Mirrors the MaybeSource (current or provided) that first signals an event., + * <p>, + * <img width="640" height="385" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png" alt="">, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code amb} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + *, + * @param other, + * a MaybeSource competing to react first, + * @return a Maybe that emits the same sequence as whichever of the source MaybeSources first, + * signalled, + * @see <a href="http://reactivex.io/documentation/operators/amb.html">ReactiveX operators documentation: Amb</a>, + */, + @SuppressWarnings("unchecked"), + @SchedulerSupport(SchedulerSupport.NONE), + public final
[+++ b/src/main/java/io/reactivex/Observable.java, +, + public final Observable<T> skipLast(long time, TimeUnit unit) {, + return skipLast(time, unit, Schedulers.trampoline(), false, bufferSize());, + }, + , + public final Observable<T> skipLast(long time, TimeUnit unit, boolean delayError) {, + return skipLast(time, unit, Schedulers.trampoline(), delayError, bufferSize());, + }, + , + public final Observable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler) {, + return skipLast(time, unit, scheduler, false, bufferSize());, + }, + , + public final Observable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError) {, + return skipLast(time, unit, scheduler, delayError, bufferSize());, + }, + , + public final Observable<T> skipLast(long time, TimeUnit unit,
[+++ b/rxjava-core/src/test/java/rx/subjects/ReplaySubjectConcurrencyTest.java, +/**, + * Copyright 2013 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See
[+++ b/src/main/java/io/reactivex/Maybe.java, + * Instructs a Maybe to pass control to another {@link MaybeSource} rather than invoking, + * the next {@code MaybeSource} that will take over if the source Maybe encounters, + * If the current {@code Maybe} didn't signal an event before the {@code timeoutIndicator} {@link MaybeSource} signals, a, + * {@link TimeoutException} is signaled instead., + * @param timeoutIndicator the {@code MaybeSource} that indicates the timeout by signaling onSuccess, + * If the current {@code Maybe} didn't signal an event before the {@code timeoutIndicator} {@link MaybeSource} signals,, + * the current {@code Maybe} is cancelled and
[+++ b/gradle.properties, +version=0.17.0-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Observable.java, + , + public final Observable<Observable<T>> window(long count) {, + return window(count, count, bufferSize());, + }, +, + public final Observable<Observable<T>> window(long count, long skip) {, + return window(count, skip, bufferSize());, + }, + , + public final Observable<Observable<T>> window(long count, long skip, int bufferSize) {, + if (skip <= 0) {, + throw new IllegalArgumentException("skip > 0 required but it was " + skip);, + }, + if (count <= 0) {, + throw new IllegalArgumentException("count > 0 required but it was " + count);, + }, + validateBufferSize(bufferSize);, + return lift(new OperatorWindow<>(count, skip, bufferSize));, +
[+++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscription { }, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscription { }, +++ b/rxjava-contrib/rxjava-quasar/README.md, +# rxjava-quasar, +, +Integrates RxJava with [Quasar](https://github.com/puniverse/quasar)., +Includes a fiber (lightweight-thread) based scheduler, and an Observable API for Quasar channels., +, +Main Classes:, +, +- [NewFiberScheduler](https://github.com/Netflix/RxJava/blob/master/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/NewFiberScheduler.java), +- [ChannelObservable](https://github.com/Netflix/RxJava/blob/master/rxjava-contrib/rxjava-quasar/src/main/java/rx/quasar/ChannelObservable.java), +, +, +# Binaries, +, +Binaries and dependency information for Maven, Ivy, Gradle and others can be found at [http://search.maven.org](http://search.maven.org/#search%7Cga%7C1%7Ccom.netflix.rxjava)., +, +Example for [Maven](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22rxjava-apache-http%22):,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorTakeWhile;, +import rx.operators.OperationThrottleFirst;, + return lift(new OperatorTakeWhile(predicate));, + return lift(new OperatorTakeWhile(predicate));, + return create(OperationThrottleFirst.throttleFirst(this, windowDuration, unit));, + return create(OperationThrottleFirst.throttleFirst(this, skipDuration, unit, scheduler));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorTakeWhile;, +import rx.operators.OperationThrottleFirst;, + return lift(new OperatorTakeWhile(predicate));, + return lift(new OperatorTakeWhile(predicate));, + return create(OperationThrottleFirst.throttleFirst(this, windowDuration, unit));, + return create(OperationThrottleFirst.throttleFirst(this, skipDuration, unit, scheduler));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorTakeWhile;, +import rx.operators.OperationThrottleFirst;, + return lift(new OperatorTakeWhile(predicate));, + return lift(new OperatorTakeWhile(predicate));, + return create(OperationThrottleFirst.throttleFirst(this, windowDuration, unit));, + return create(OperationThrottleFirst.throttleFirst(this, skipDuration, unit, scheduler));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperationThrottleFirst.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version
[+++ b/rxjava-contrib/rxjava-android/build.gradle, + instruction 'Fragment-Host', 'com.netflix.rxjava.core', +++ b/rxjava-contrib/rxjava-android/build.gradle, + instruction 'Fragment-Host', 'com.netflix.rxjava.core', +++ b/rxjava-contrib/rxjava-apache-http/build.gradle, + instruction 'Fragment-Host', 'com.netflix.rxjava.core', +++ b/rxjava-contrib/rxjava-android/build.gradle, + instruction 'Fragment-Host', 'com.netflix.rxjava.core', +++ b/rxjava-contrib/rxjava-apache-http/build.gradle, + instruction 'Fragment-Host', 'com.netflix.rxjava.core', +++ b/rxjava-contrib/rxjava-async-util/build.gradle, + instruction 'Fragment-Host', 'com.netflix.rxjava.core', +++ b/rxjava-contrib/rxjava-android/build.gradle, + instruction 'Fragment-Host', 'com.netflix.rxjava.core', +++ b/rxjava-contrib/rxjava-apache-http/build.gradle, + instruction 'Fragment-Host', 'com.netflix.rxjava.core', +++ b/rxjava-contrib/rxjava-async-util/build.gradle, + instruction 'Fragment-Host', 'com.netflix.rxjava.core', +++ b/rxjava-contrib/rxjava-computation-expressions/build.gradle, + instruction 'Fragment-Host', 'com.netflix.rxjava.core', +++ b/rxjava-contrib/rxjava-android/build.gradle, + instruction 'Fragment-Host', 'com.netflix.rxjava.core', +++ b/rxjava-contrib/rxjava-apache-http/build.gradle, + instruction 'Fragment-Host', 'com.netflix.rxjava.core', +++ b/rxjava-contrib/rxjava-async-util/build.gradle, + instruction 'Fragment-Host', 'com.netflix.rxjava.core', +++ b/rxjava-contrib/rxjava-computation-expressions/build.gradle, + instruction 'Fragment-Host', 'com.netflix.rxjava.core', +++ b/rxjava-contrib/rxjava-string/build.gradle, + instruction 'Fragment-Host', 'com.netflix.rxjava.core', +++ b/rxjava-contrib/rxjava-android/build.gradle, + instruction 'Fragment-Host', 'com.netflix.rxjava.core', +++ b/rxjava-contrib/rxjava-apache-http/build.gradle, +
[+++ b/.gitignore, +++ b/.gitignore, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/gradle.properties, +version=0.15.2-SNAPSHOT]
[+++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/ImplicitFunctionConversions.scala, +import rx.lang.scala.concurrency.Scheduler, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/ImplicitFunctionConversions.scala, +import rx.lang.scala.concurrency.Scheduler, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +import rx.lang.scala.concurrency.Scheduler, + zip(that, (t: T, u: U) => (t, u)), + }, +, + /**, + * Returns an Observable formed from this Observable and another Observable by combining, + * corresponding elements using the selector function., + * The number of `onNext` invocations of the resulting `Observable[(T, U)]`, + * is the minumum of the number of `onNext` invocations of `this` and `that`., + */, + def zip[U, R](that: Observable[U], selector: (T,U) => R): Observable[R] = {, + Observable[R](rx.Observable.zip[T, U, R](this.asJavaObservable, that.asJavaObservable, selector)), + * The [[Scheduler]]
[+++ b/src/main/java/io/reactivex/Observable.java, + public final Observable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit) {, + return buffer(timespan, timeskip, unit, Schedulers.computation(), ArrayList::new);, + }, + , + public final Observable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit, Scheduler scheduler) {, + return buffer(timespan, timeskip, unit, scheduler, ArrayList::new);, + }, + , + public final <B> Observable<List<T>> buffer(Supplier<? extends Observable<B>> boundarySupplier) {, + Objects.requireNonNull(boundarySupplier);, + // TODO implement, + throw new UnsupportedOperationException();, + }, +, +++ b/src/main/java/io/reactivex/Observable.java, + public final Observable<List<T>> buffer(long timespan, long timeskip, TimeUnit unit) {, + return buffer(timespan, timeskip, unit, Schedulers.computation(), ArrayList::new);, + }, + , + public final Observable<List<T>>
[+++ b/CHANGES.md, +### Version 0.20.0-RC3 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.20.0-RC3%22)) ###, +, +Version 0.20.0-RC3 preview release fixes several bugs related to backpressure and adds `retryWhen`, `repeatWhen` for more advanced recursion use cases like retry with exponential backoff., +, +This version passed the Netflix API production canary process. Please test this against your code to help us find any issues before we release 0.20.0., +, +* [Pull 1493] (https://github.com/Netflix/RxJava/pull/1493) retryWhen/repeatWhen, +* [Pull 1494] (https://github.com/Netflix/RxJava/pull/1494) zipWith, +* [Pull 1501] (https://github.com/Netflix/RxJava/pull/1501) blocking synchronous next, +* [Pull 1498] (https://github.com/Netflix/RxJava/pull/1498) non-deterministic testUserSubscriberUsingRequestAsync, +* [Pull 1497] (https://github.com/Netflix/RxJava/pull/1497) spsc ring buffer concurrency test, +* [Pull 1496] (https://github.com/Netflix/RxJava/pull/1496) Change RxRingBuffer
[+++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscription { }, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscription { }, +++ b/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/ObservableHttp.java, + new FutureCallback<HttpResponse>() {, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscription { }, +++ b/rxjava-contrib/rxjava-apache-http/src/main/java/rx/apache/http/ObservableHttp.java, + new FutureCallback<HttpResponse>() {, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OnSubscribeFromIterable;, +import rx.operators.OperatorFilter;, +import rx.operators.OperationMergeMaxConcurrent;, + return Observable.create(OperationMergeMaxConcurrent.merge(source, maxConcurrent));, + public final Observable<Observable<T>> nest() {, + if (count < 0) {, + throw new IllegalArgumentException("Count can not be negative");, + return lift(new OperatorFilter<T>(predicate));, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription
[+++ b/src/main/java/io/reactivex/Scheduler.java, +import io.reactivex.internal.disposables.*;, + Disposable d = w.schedulePeriodically(periodicTask, initialDelay, period, unit);, + if (d == EmptyDisposable.INSTANCE) {, + return d;, + }, + Disposable d = schedule(new PeriodicTask(firstStartInNanoseconds, decoratedRun, firstNowNanoseconds, sd,, + periodInNanoseconds), initialDelay, unit);, +, + if (d == EmptyDisposable.INSTANCE) {, + return d;, + }, + first.replace(d);, +++ b/src/main/java/io/reactivex/Scheduler.java, +import io.reactivex.internal.disposables.*;, + Disposable d = w.schedulePeriodically(periodicTask, initialDelay, period, unit);, + if (d == EmptyDisposable.INSTANCE) {, + return d;, + }, + Disposable d = schedule(new PeriodicTask(firstStartInNanoseconds, decoratedRun, firstNowNanoseconds, sd,, + periodInNanoseconds), initialDelay, unit);, +, + if (d == EmptyDisposable.INSTANCE) {, + return d;, + }, +
[+++ b/rxjava-core/src/main/java/rx/Observable.java, + return lift(new OperatorSkipUntil<T, U>(other));, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return lift(new OperatorSkipUntil<T, U>(other));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return lift(new OperatorSkipUntil<T, U>(other));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorSkipUntil.java, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not, + * use this file except in compliance with the License. You may obtain a copy of, + * the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is
[+++ b/gradle.properties, +version=0.8.2, +++ b/gradle.properties, +version=0.8.2, +++ b/rxjava-contrib/rxjava-swing/src/main/java/rx/observables/SwingObservable.java, +import java.awt.Component;, +import java.awt.Dimension;, +import java.awt.event.ComponentEvent;, +import rx.swing.sources.ComponentEventSource;, + public static Observable<KeyEvent> fromKeyEvents(Component component) {, + public static Observable<KeyEvent> fromKeyEvents(Component component, final Set<Integer> keyCodes) {, + public static Observable<Set<Integer>> fromPressedKeys(Component component) {, + public static Observable<MouseEvent> fromMouseEvents(Component component) {, + public static Observable<MouseEvent> fromMouseMotionEvents(Component component) {, + , + /**, + * Creates an observable corresponding to raw component events., + * , + * @param component, + * The component to register the observable for., + * @return Observable of component events., + */, + public static Observable<ComponentEvent> fromComponentEvents(Component component)
[+++ b/src/main/java/io/reactivex/Completable.java, + * <dt><b>Error handling:</b></dt>, + * <dd> If the {@link Action} throws an exception, the respective {@link Throwable} is, + * delivered to the downstream via {@link CompletableObserver#onError(Throwable)},, + * except when the downstream has disposed this {@code Completable} source., + * In this latter case, the {@code Throwable} is delivered to the global error handler via, + * {@link RxJavaPlugins#onError(Throwable)} as an {@link io.reactivex.exceptions.UndeliverableException UndeliverableException}., + * </dd>, + * <dt><b>Error handling:</b></dt>, + * <dd> If the {@link Callable} throws an exception, the respective {@link Throwable} is, + * delivered to the downstream via {@link CompletableObserver#onError(Throwable)},,
[+++ b/rxjava-core/src/test/java/README.md, +This test folder only contains performance and functional/integration style tests., +, +The unit tests themselves are embedded as inner classes of the Java code (such as here: [rxjava-core/src/main/java/rx/operators](https://github.com/Netflix/RxJava/tree/master/rxjava-core/src/main/java/rx/operators))., +, +* For an explanation of this design choice see , +Ben J. Christensen's [JUnit Tests as Inner Classes](http://benjchristensen.com/2011/10/23/junit-tests-as-inner-classes/)., +, +Also, each of the language adaptors has a /src/test/ folder which further testing (see Groovy for an example: [language-adaptors/rxjava-groovy/src/test](https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-groovy/src/test))., +++ b/rxjava-core/src/test/java/README.md, +This test folder only contains performance and functional/integration style tests., +, +The unit tests themselves are embedded as inner classes of the Java code (such as here: [rxjava-core/src/main/java/rx/operators](https://github.com/Netflix/RxJava/tree/master/rxjava-core/src/main/java/rx/operators)).,
[+++ b/CHANGES.md, +### Version 0.20.0-RC5 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.20.0-RC5%22)) ###, +, +Version 0.20.0-RC5 updates `parallel`, `buffer(size)`, `switchOnNext`, `repeat`, and `retry` to support "reactive pull" backpressure. It adds a `groupBy` overload with an element selector, a new `compose` method as an alternative to `lift` for custom operators, fixes bugs and other general improvements., +, +There are still oustanding items being tracked for 0.20 that need to be completed for the final release., +, +* [Pull 1573] (https://github.com/Netflix/RxJava/pull/1573) Backpressure: parallel , +* [Pull 1572] (https://github.com/Netflix/RxJava/pull/1572) Remove Timeout in Blocking Iterator, +* [Pull 1570] (https://github.com/Netflix/RxJava/pull/1570) RxClojure: Fix for mapcat, +* [Pull 1568] (https://github.com/Netflix/RxJava/pull/1568) Compose/Transformer,
[+++ b/src/main/java/io/reactivex/Flowable.java, + * the source Publisher is disposed and resulting Publisher begins instead to mirror a fallback Publisher., + * starting from its predecessor, the source Publisher is disposed and resulting Publisher begins, + * instead to mirror a fallback Publisher., +++ b/src/main/java/io/reactivex/Flowable.java, + * the source Publisher is disposed and resulting Publisher begins instead to mirror a fallback Publisher., + * starting from its predecessor, the source Publisher is disposed and resulting Publisher begins, + * instead to mirror a fallback Publisher., +++ b/src/main/java/io/reactivex/Maybe.java, + * the source MaybeSource is disposed and resulting Maybe begins instead to
[+++ b/src/main/java/io/reactivex/Observable.java, + * Maps each element of the upstream Observable into CompletableSources, subscribes to them one at a time in, + * order and waits until the upstream and all CompletableSources complete., + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code concatMapCompletable} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + *, + * @param mapper, + * a function that, when applied to an item emitted by the source ObservableSource, returns a CompletableSource, + * @return a Completable that signals {@code onComplete} when the upstream and all CompletableSources complete, + * @since
[+++ b/src/main/java/io/reactivex/Completable.java, +, + if (cancelled) {, + ts.cancel();, + }]
[+++ b/src/main/java/io/reactivex/Completable.java, +public abstract class Completable {, + return new CompletableWrapper(onSubscribe);, + subscribeActual(s);, + protected abstract void subscribeActual(CompletableSubscriber s);, +, +++ b/src/main/java/io/reactivex/Completable.java, +public abstract class Completable {, + return new CompletableWrapper(onSubscribe);, + subscribeActual(s);, + protected abstract void subscribeActual(CompletableSubscriber s);, +, +++ b/src/main/java/io/reactivex/Flowable.java, +public abstract class Flowable<T> implements Publisher<T> {, + return fromPublisher(onSubscribe);, + return new FlowableWrapper<T>(publisher);, + return create(new PublisherLift<R, T>(this, lifter));, + subscribeActual(s);, + protected abstract void subscribeActual(Subscriber<? super T> s);, + , +++ b/src/main/java/io/reactivex/Completable.java, +public abstract class Completable {, + return new CompletableWrapper(onSubscribe);, + subscribeActual(s);, + protected abstract void subscribeActual(CompletableSubscriber s);, +, +++ b/src/main/java/io/reactivex/Flowable.java, +public abstract class
[+++ b/src/main/java/io/reactivex/CompletableOperator.java, + * @throws Exception on failure, +++ b/src/main/java/io/reactivex/CompletableOperator.java, + * @throws Exception on failure, +++ b/src/main/java/io/reactivex/Flowable.java, + * Returns a Single that emits a Boolean value that indicates whether two Publisher sequences are the, + public static <T> Single<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2) {, + * Returns a Single that emits a Boolean value that indicates whether two Publisher sequences are the, + * @return a Single that emits a Boolean value that indicates whether the two Publisher sequences, + public static <T> Single<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2,, +
[+++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeToObservable.java, +import io.reactivex.annotations.Experimental;, + source.subscribe(create(s));, + /**, + * Creates a {@link MaybeObserver} wrapper around a {@link Observer}., + * @param <T> the value type, + * @param downstream the downstream {@code Observer} to talk to, + * @return the new MaybeObserver instance, + * @since 2.1.11 - experimental, + */, + @Experimental, + public static <T> MaybeObserver<T> create(Observer<? super T> downstream) {, + return new MaybeToObservableObserver<T>(downstream);, + }, +, + static final class MaybeToObservableObserver<T> extends DeferredScalarDisposable<T>, + MaybeToObservableObserver(Observer<? super T> actual) {, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeToObservable.java, +import io.reactivex.annotations.Experimental;, + source.subscribe(create(s));, + /**, + * Creates a {@link MaybeObserver} wrapper
[+++ b/src/main/java/io/reactivex/Observable.java, + * <img width="640" height="344" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/fromPublisher.o.png" alt="">, + * <p>, + * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zipArray.o.png" alt="">, + * <img width="640" height="264" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/all.o.png" alt="">]
[+++ b/src/main/java/io/reactivex/BackpressureStrategy.java, + * OnNext events are written without any buffering or dropping., + * Downstream has to deal with any overflow., + * <p>Useful when one applies one of the custom-parameter onBackpressureXXX operators., + */, + NONE,, + /**, + * Signals a MissingBackpressureException in case the downstream can't keep up., + */, + ERROR,, + /**, + * Buffers <em>all</em> onNext values until the downstream consumes it., + * Drops the most recent onNext value if the downstream can't keep up., + * Keeps only the latest onNext value, overwriting any previous value if the, + *
[+++ b/src/main/java/io/reactivex/Single.java, + * <p>, + * <img width="640" height="244" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.never.png" alt="">]
[+++ b/src/main/java/io/reactivex/Completable.java, + ObjectHelper.requireNonNull(observer, "The RxJavaPlugins.onSubscribe hook returned a null CompletableObserver. Please check the handler provided to RxJavaPlugins.setOnCompletableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins");, +, +++ b/src/main/java/io/reactivex/Completable.java, + ObjectHelper.requireNonNull(observer, "The RxJavaPlugins.onSubscribe hook returned a null CompletableObserver. Please check the handler provided to RxJavaPlugins.setOnCompletableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins");, +, +++ b/src/main/java/io/reactivex/Flowable.java, + ObjectHelper.requireNonNull(z, "The RxJavaPlugins.onSubscribe hook returned a null FlowableSubscriber. Please check the handler provided to RxJavaPlugins.setOnFlowableSubscribe for invalid null returns. Further reading: https://github.com/ReactiveX/RxJava/wiki/Plugins");, +++ b/src/main/java/io/reactivex/Completable.java, + ObjectHelper.requireNonNull(observer, "The RxJavaPlugins.onSubscribe hook returned a null CompletableObserver. Please check the handler provided to RxJavaPlugins.setOnCompletableSubscribe for invalid null returns.
[+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java, +import rx.operators.OperatorObserveFromAndroidComponent;, + return OperatorObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, activity);, + return OperatorObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (android.support.v4.app.Fragment) fragment);, + return OperatorObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (Fragment) fragment);, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java, +import rx.operators.OperatorObserveFromAndroidComponent;, + return OperatorObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, activity);, + return OperatorObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (android.support.v4.app.Fragment) fragment);, + return OperatorObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (Fragment) fragment);, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/subscriptions/AndroidSubscriptions.java, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed
[+++ b/gradle.properties, +version=0.1-SNAPSHOT]
[+++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, +import rx.Operator;, +import rx.util.functions.Action1;, +public class GroovyCreateWrapper<T> implements Action1<Operator<? super T>> {, + public void call(Operator<? super T> op) {, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, +import rx.Operator;, +import rx.util.functions.Action1;, +public class GroovyCreateWrapper<T> implements Action1<Operator<? super T>> {, + public void call(Operator<? super T> op) {, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, + Observable.empty, +++ b/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/GroovyCreateWrapper.java, +import rx.Operator;, +import rx.util.functions.Action1;, +public class GroovyCreateWrapper<T> implements Action1<Operator<? super T>> {, + public void call(Operator<? super T> op) {, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, + Observable.empty, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, + val numbers = Observable.interval(250 millis).take(14), + val grouped = numbers.groupByUntil[Long](x => x % 2, {case (key, obs) => obs.filter(x => x ==
[+++ b/gradle.properties, +release.version=2.0.0-DP0-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/internal/subscribers/EmptySubscriber.java, + /** Empty instance that reports error to the plugins. */, + INSTANCE(true),, + /** Empty instance that doesn't report to the plugins to avoid flooding the test output. */, + INSTANCE_NOERROR(false);, + , + final boolean reportError;, + , + EmptySubscriber(boolean reportError) {, + this.reportError = reportError;, + }, + if (reportError) {, + }, +++ b/src/main/java/io/reactivex/internal/subscribers/EmptySubscriber.java, + /** Empty instance that reports error to the plugins. */, + INSTANCE(true),, + /** Empty instance that doesn't report to the plugins to avoid flooding the test output. */, + INSTANCE_NOERROR(false);, + , + final boolean reportError;, +
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Publisher completes, the resulting Publisher emits the current buffer and propagates the notification from the, + * source Publisher. Note that if the source Publisher issues an onError notification the event is passed on, + * immediately without first emitting the buffer it is in the process of assembling., + * Publisher completes, the resulting Publisher emits the current buffer and propagates the notification from the, + * source Publisher. Note that if the source Publisher issues an onError notification the event is passed on, + * immediately without first emitting the buffer it is
[+++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:2.+' }, +apply plugin: 'java', +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:2.+' }, +apply plugin: 'java', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, + dependencies { classpath 'com.netflix.nebula:gradle-rxjava-project-plugin:2.+' }, +apply plugin: 'java', +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Sat Dec 13 00:15:28 PST 2014, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-bin.zip]
[+++ b/src/main/java/io/reactivex/internal/schedulers/ComputationScheduler.java, + static final RxThreadFactory THREAD_FACTORY;, + /** The name of the system property for setting the thread priority for this Scheduler. */, + private static final String KEY_COMPUTATION_PRIORITY = "rx2.computation-priority";, +, + int priority = Math.max(Thread.MIN_PRIORITY, Math.min(Thread.MAX_PRIORITY,, + Integer.getInteger(KEY_COMPUTATION_PRIORITY, Thread.NORM_PRIORITY)));, +, + THREAD_FACTORY = new RxThreadFactory(THREAD_NAME_PREFIX, priority);, +++ b/src/main/java/io/reactivex/internal/schedulers/ComputationScheduler.java, + static final RxThreadFactory THREAD_FACTORY;, + /** The name of the system property for setting the thread priority for this Scheduler. */, + private static final String KEY_COMPUTATION_PRIORITY = "rx2.computation-priority";, +, + int priority = Math.max(Thread.MIN_PRIORITY, Math.min(Thread.MAX_PRIORITY,, + Integer.getInteger(KEY_COMPUTATION_PRIORITY, Thread.NORM_PRIORITY)));, +, + THREAD_FACTORY = new RxThreadFactory(THREAD_NAME_PREFIX, priority);, +++
[+++ b/gradle.properties, +version=0.5.4-SNAPSHOT]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationFinally;, +import rx.operators.OperatorMergeMapPair;, +import rx.operators.OperatorMergeMapTransform;, + return create(OperationFinally.finallyDo(this, action));, + return lift(new OperatorMergeMapTransform<T, R>(onNext, onError, onCompleted));, + return lift(new OperatorMergeMapPair<T, U, R>(collectionSelector, resultSelector));, + return merge(map(OperatorMergeMapPair.convertSelector(collectionSelector)));, + return mergeMap(OperatorMergeMapPair.convertSelector(collectionSelector), resultSelector);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationFinally;, +import rx.operators.OperatorMergeMapPair;, +import rx.operators.OperatorMergeMapTransform;, + return create(OperationFinally.finallyDo(this, action));, + return lift(new OperatorMergeMapTransform<T, R>(onNext, onError, onCompleted));, + return lift(new OperatorMergeMapPair<T, U, R>(collectionSelector, resultSelector));, + return merge(map(OperatorMergeMapPair.convertSelector(collectionSelector)));, + return mergeMap(OperatorMergeMapPair.convertSelector(collectionSelector), resultSelector);, +++ b/rxjava-core/src/main/java/rx/operators/OperationFinally.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in
[+++ b/CHANGES.md, +### Version 0.14.6 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.6%22)) ###, +, +* [Pull 441](https://github.com/Netflix/RxJava/pull/441) Fixed the issue that 'take' does not call 'onError', +* [Pull 443](https://github.com/Netflix/RxJava/pull/443) OperationSwitch notify onComplete() too early., +* [Pull 434](https://github.com/Netflix/RxJava/pull/434) Timeout operator and SerialSubscription, +* [Pull 447](https://github.com/Netflix/RxJava/pull/447) Caching the result of 'isInternalImplementation', +, +### Version 0.14.5 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.5%22)) ###, +, +* [Pull 438](https://github.com/Netflix/RxJava/pull/438) Kotlin Language Adaptor, +, +### Version 0.14.4 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.14.4%22)) ###, +, +* [Issue 428](https://github.com/Netflix/RxJava/issues/428) Fix: buffer() using TimeAndSizeBasedChunks incorrectly forces thread into interrupted state, +* [Pull 435](https://github.com/Netflix/RxJava/pull/435) rx-apache-http recognizes "Transfer-Encoding: chunked" as an HTTP stream, +* [Pull 437](https://github.com/Netflix/RxJava/pull/437) Fixes: Scheduler and Merge, +, +,
[+++ b/gradle.properties, +version=0.12.2]
[+++ b/src/main/java/io/reactivex/Maybe.java, + * <p>, + * <img width="640" height="300" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.hide.png" alt="">]
[+++ b/language-adaptors/rxjava-clojure/build.gradle, +apply plugin: 'clojure', + , + // clojure, + testCompile 'clj-http:clj-http:0.6.4' // https://clojars.org/clj-http, +}, +, +/*, + * Clojure, + */, +aotCompile = true, +warnOnReflection = true, +, +buildscript {, + repositories { maven { url "http://clojars.org/repo" } }, + dependencies { classpath "clojuresque:clojuresque:1.5.4" }, +}, +, +repositories {, + mavenCentral(), + clojarsRepo(), +}, +, +/*, + * Add Counterclockwise and include 'provided' dependencies, + */, +eclipse {, + project {, + natures "ccw.nature", + }, + classpath {, + plusConfigurations += configurations.provided, + downloadSources = true, + downloadJavadoc = true, + }, +}, +, +, +//
[+++ b/gradle.properties, +version=0.14.8-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/internal/disposables/EmptyDisposable.java, +import io.reactivex.annotations.Nullable;, + @Nullable, +++ b/src/main/java/io/reactivex/internal/disposables/EmptyDisposable.java, +import io.reactivex.annotations.Nullable;, + @Nullable, +++ b/src/main/java/io/reactivex/internal/fuseable/SimplePlainQueue.java, +import io.reactivex.annotations.Nullable;, +, + @Nullable, +++ b/src/main/java/io/reactivex/internal/disposables/EmptyDisposable.java, +import io.reactivex.annotations.Nullable;, + @Nullable, +++ b/src/main/java/io/reactivex/internal/fuseable/SimplePlainQueue.java, +import io.reactivex.annotations.Nullable;, +, + @Nullable, +++ b/src/main/java/io/reactivex/internal/fuseable/SimpleQueue.java, +import io.reactivex.annotations.Nullable;, +, + /**, + * @return null to indicate an empty queue, + */, + @Nullable, +++ b/src/main/java/io/reactivex/internal/disposables/EmptyDisposable.java, +import io.reactivex.annotations.Nullable;, + @Nullable, +++ b/src/main/java/io/reactivex/internal/fuseable/SimplePlainQueue.java, +import io.reactivex.annotations.Nullable;, +, + @Nullable, +++ b/src/main/java/io/reactivex/internal/fuseable/SimpleQueue.java, +import io.reactivex.annotations.Nullable;, +, + /**, + * @return null to indicate an empty queue, + */, + @Nullable, +++ b/src/main/java/io/reactivex/internal/observers/DeferredScalarDisposable.java, +import io.reactivex.annotations.Nullable;, + @Nullable, +++ b/src/main/java/io/reactivex/internal/disposables/EmptyDisposable.java, +import io.reactivex.annotations.Nullable;, + @Nullable, +++ b/src/main/java/io/reactivex/internal/fuseable/SimplePlainQueue.java,
[+++ b/src/main/java/io/reactivex/Scheduler.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtMaybe.java, + if (!done) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtMaybe.java, + if (!done) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtSingle.java, + if (!done) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtMaybe.java, + if (!done) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtSingle.java, + if (!done) {, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableElementAtMaybe.java, + if (!done) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtMaybe.java, + if (!done) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtSingle.java, + if (!done) {, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableElementAtMaybe.java, + if (!done) {, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableElementAtSingle.java, + if (!done) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtMaybe.java, + if (!done) {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableElementAtSingle.java, + if (!done) {, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableElementAtMaybe.java, + if (!done) {, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableElementAtSingle.java, + if (!done) {, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableElementAtTest.java, +, + @Test, + public void elementAtIndex0OnEmptySource() {, + Flowable.empty(), + .elementAt(0), +
[+++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java, +import rx.operators.OperatorObserveFromAndroidComponent;, + return OperatorObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, activity);, + return OperatorObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (android.support.v4.app.Fragment) fragment);, + return OperatorObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (Fragment) fragment);, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/observables/AndroidObservable.java, +import rx.operators.OperatorObserveFromAndroidComponent;, + return OperatorObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, activity);, + return OperatorObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (android.support.v4.app.Fragment) fragment);, + return OperatorObserveFromAndroidComponent.observeFromAndroidComponent(sourceObservable, (Fragment) fragment);, +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/subscriptions/AndroidSubscriptions.java, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed
[+++ b/gradle.properties, +version=0.13.4]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * <dd>{@code debounce} operates by default on the {@code computation} {@link Scheduler}.</dd>, + * the length of the window of time that must pass after the emission of an item from the source, + * Publisher in which that Publisher emits no items in order for the item to be emitted by the, + * resulting Publisher, + * the unit of time for the specified {@code timeout}, + * the unit of time for the specified {@code timeout}, + * Returns a Flowable that mirrors the source Publisher, except that it drops items emitted by
[+++ b/gradle.properties, +version=0.6.3-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableAmb.java, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableAmb.java, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableConcat.java, +import io.reactivex.exceptions.*;, +import io.reactivex.internal.disposables.DisposableHelper;, +import io.reactivex.internal.fuseable.*;, +import io.reactivex.internal.queue.*;, + sources.subscribe(new CompletableConcatSubscriber(s, prefetch));, + private static final long serialVersionUID = 9032184911934499404L;, + final CompletableObserver actual;, +, + final int prefetch;, +, + final int limit;, +, + final ConcatInnerObserver inner;, +, + final AtomicBoolean once;, +, + int sourceFused;, +, + int consumed;, +, + SimpleQueue<CompletableSource> queue;, + volatile boolean active;, + this.inner = new ConcatInnerObserver(this);, + this.once = new AtomicBoolean();, + this.limit = prefetch - (prefetch >> 2);, +, + long r = prefetch == Integer.MAX_VALUE ? Long.MAX_VALUE : prefetch;, +, + if
[+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java, + if (!done && errors.addThrowable(t)) {, + } else {, + RxJavaPlugins.onError(t);, + }, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java, + if (!done && errors.addThrowable(t)) {, + } else {, + RxJavaPlugins.onError(t);, + }, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableSwitchTest.java, +, + @Test, + public void innerCancelledOnMainError() {, + final PublishProcessor<Integer> main = PublishProcessor.create();, + final PublishProcessor<Integer> inner = PublishProcessor.create();, +, + TestSubscriber<Integer> to = main.switchMap(Functions.justFunction(inner)), + .test();, +, + assertTrue(main.hasSubscribers());, +, + main.onNext(1);, +, + assertTrue(inner.hasSubscribers());, +, + main.onError(new TestException());, +, + assertFalse(inner.hasSubscribers());, +, + to.assertFailure(TestException.class);, + }, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableSwitchMap.java, + if (!done && errors.addThrowable(t)) {, + } else {, + RxJavaPlugins.onError(t);, + },
[+++ b/src/main/java/io/reactivex/Observable.java, + * <img width="640" height="380" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/zipIterable.o.png" alt="">, + * <img width="640" height="385" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ambWith.o.png" alt="">, + * <img width="640" height="330" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingForEach.o.png" alt="">, + * <img width="640" height="315" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingIterable.o.png" alt="">, + * <img width="640" height="315" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingLast.o.png" alt="">, + * <img width="640" height="310" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingLastDefault.o.png" alt="">, + * <img width="640" height="426" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingMostRecent.o.png" alt="">, + * <img width="640" height="427" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingNext.o.png" alt="">, + * <img width="640" height="315" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingSingle.o.png" alt="">, + * <img width="640" height="315" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/blockingSingleDefault.o.png" alt="">, + * <img width="640" height="410" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/cacheWithInitialCapacity.o.png" alt="">]
[+++ b/src/main/java/io/reactivex/Completable.java, +public abstract class Completable implements CompletableSource {, + public static Completable wrap(CompletableSource source) {, + public static Completable amb(final CompletableSource... sources) {, + public static Completable amb(final Iterable<? extends CompletableSource> sources) {, + public static Completable concat(CompletableSource... sources) {, + public static Completable concat(Iterable<? extends CompletableSource> sources) {, + public static Completable concat(Publisher<? extends CompletableSource> sources) {, + public static Completable concat(Publisher<? extends CompletableSource> sources, int prefetch) {, + public static Completable create(CompletableSource onSubscribe) {, + public static Completable defer(final Callable<? extends CompletableSource> completableSupplier) {, + public static Completable merge(CompletableSource... sources) {, + public static Completable merge(Iterable<?
[+++ b/src/main/java/io/reactivex/Emitter.java, + * <p>, + * Note that the {@link Emitter#onNext}, {@link Emitter#onError} and, + * {@link Emitter#onComplete} methods provided to the function via the {@link Emitter} instance should be called synchronously,, + * never concurrently. Calling them from multiple threads is not supported and leads to an, + * undefined behavior., +++ b/src/main/java/io/reactivex/Emitter.java, + * <p>, + * Note that the {@link Emitter#onNext}, {@link Emitter#onError} and, + * {@link Emitter#onComplete} methods provided to the function via the {@link Emitter} instance should be called synchronously,, + * never concurrently. Calling them from multiple threads is not supported and
[+++ b/src/main/java/io/reactivex/disposables/RefCountDisposable.java, +import io.reactivex.internal.disposables.DisposableHelper;, + static final Disposable DISPOSED = DisposableHelper.DISPOSED;, + DisposableHelper.dispose(resource);, + DisposableHelper.dispose(resource);, +++ b/src/main/java/io/reactivex/disposables/RefCountDisposable.java, +import io.reactivex.internal.disposables.DisposableHelper;, + static final Disposable DISPOSED = DisposableHelper.DISPOSED;, + DisposableHelper.dispose(resource);, + DisposableHelper.dispose(resource);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAmb.java, + if (get() != SubscriptionHelper.CANCELLED) {, + if (s != null && s != SubscriptionHelper.CANCELLED) {, + SubscriptionHelper.dispose(this);, +++ b/src/main/java/io/reactivex/disposables/RefCountDisposable.java, +import io.reactivex.internal.disposables.DisposableHelper;, + static final Disposable DISPOSED = DisposableHelper.DISPOSED;, + DisposableHelper.dispose(resource);, + DisposableHelper.dispose(resource);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableAmb.java, + if (get() != SubscriptionHelper.CANCELLED) {, + if (s != null && s != SubscriptionHelper.CANCELLED) {, + SubscriptionHelper.dispose(this);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBufferTimed.java, +import io.reactivex.internal.disposables.DisposableHelper;, + DisposableHelper.dispose(timer);, + DisposableHelper.dispose(timer);, + DisposableHelper.dispose(timer);, + DisposableHelper.dispose(timer);, +++ b/src/main/java/io/reactivex/disposables/RefCountDisposable.java,
[+++ b/src/main/java/io/reactivex/Completable.java, + * <p>History: 2.1.17 - beta, + * @since 2.2, + * <p>History: 2.1.7 - experimental, + * @since 2.2, + * <p>History: 2.1.5 - experimental, + * @since 2.2, + * <p>History: 2.1.8 - experimental, + * @since 2.2, + * <p>History: 2.1.17 - experimental, + * @since 2.2, +++ b/src/main/java/io/reactivex/Completable.java, + * <p>History: 2.1.17 - beta, + * @since 2.2, + * <p>History: 2.1.7 - experimental, + * @since 2.2, + * <p>History: 2.1.5 - experimental, + * @since 2.2, + * <p>History: 2.1.8 - experimental, + * @since 2.2, + * <p>History: 2.1.17 -
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC3-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC3-SNAPSHOT, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java, + *, + * @param <T1>, + * @param <T2>, + * @param <T3>, + * @param <T4>, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.20.0-RC3-SNAPSHOT, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyActionWrapper.java, + *, + * @param <T1>, + * @param <T2>, + * @param <T3>, + * @param <T4>, +++ b/language-adaptors/rxjava-jruby/src/main/java/rx/lang/jruby/JRubyFunctionWrapper.java, + *, + * @param <T1>, + * @param <T2>, + * @param <T3>, + * @param <T4>, + * @param <T5>, + * @param <T6>, + * @param <T7>, + * @param <T8>, + * @param <T9>, + *
[+++ b/src/main/java/io/reactivex/disposables/Disposables.java, + * Returns a disposed Disposable instance., + * @return a disposed Disposable instance]
[+++ b/gradle.properties, +release.scope=patch]
[+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFromCallable.java, + return ObjectHelper.requireNonNull(callable.call(), "The callable returned a null value");, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableFromCallable.java, + return ObjectHelper.requireNonNull(callable.call(), "The callable returned a null value");, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableFromCallableTest.java, +import static org.junit.Assert.*;, +import io.reactivex.functions.Function;, +, + @Test, + public void fusedFlatMapExecution() {, + final int[] calls = { 0 };, +, + Flowable.just(1).flatMap(new Function<Integer, Publisher<? extends Object>>() {, + @Override, + public Publisher<? extends Object> apply(Integer v), + throws Exception {, + return Flowable.fromCallable(new Callable<Object>() {, + @Override, + public Object call() throws Exception {, + return ++calls[0];, + }, + });, + }, + }), + .test(), + .assertResult(1);, +, + assertEquals(1, calls[0]);,
[+++ b/gradle.properties, +version=0.9.3-SNAPSHOT]
[+++ b/.travis.yml, + , +sudo: false, +# as per http://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/, +++ b/.travis.yml, + , +sudo: false, +# as per http://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/, +++ b/CHANGES.md, +### Version 1.0.4 – December 29th 2014 ([Maven Central](http://search.maven.org/#artifactdetails%7Cio.reactivex%7Crxjava%7C1.0.4%7C)) ###, +, +* [Pull 2156] (https://github.com/ReactiveX/RxJava/pull/2156) Fix the issue that map may swallow fatal exceptions, +* [Pull 1967] (https://github.com/ReactiveX/RxJava/pull/1967) Fix the issue that GroupBy may not call 'unsubscribe', +* [Pull 2052] (https://github.com/ReactiveX/RxJava/pull/2052) OperatorDoOnRequest.ParentSubscriber should be static class, +* [Pull 2237] (https://github.com/ReactiveX/RxJava/pull/2237) Make Publish Operator Release RingBuffer, +* [Pull 2053] (https://github.com/ReactiveX/RxJava/pull/2053) Fixed wrong bounded ReplaySubject use in test, +, +++ b/.travis.yml, + , +sudo: false, +# as per http://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorGroupBy;, +import rx.operators.OperatorTakeUntil;, +import rx.operators.OperatorToIterator;, + return OperatorTakeUntil.takeUntil(source, other);, + return create(OperatorGroupBy.groupBy(source, keySelector, elementSelector));, + return create(OperatorGroupBy.groupBy(source, keySelector));, + return OperatorToIterator.toIterator(that);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorGroupBy;, +import rx.operators.OperatorTakeUntil;, +import rx.operators.OperatorToIterator;, + return OperatorTakeUntil.takeUntil(source, other);, + return create(OperatorGroupBy.groupBy(source, keySelector, elementSelector));, + return create(OperatorGroupBy.groupBy(source, keySelector));, + return OperatorToIterator.toIterator(that);, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorGroupBy;, +import rx.operators.OperatorTakeUntil;, +import rx.operators.OperatorToIterator;, + return OperatorTakeUntil.takeUntil(source, other);, + return create(OperatorGroupBy.groupBy(source, keySelector, elementSelector));, + return create(OperatorGroupBy.groupBy(source, keySelector));, + return OperatorToIterator.toIterator(that);, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperationObserveOn.java, +import org.mockito.InOrder;, +, + @Test, + @SuppressWarnings("unchecked"), + public void testOrdering() {, + Observable<String> obs = Observable.from("one", null, "two", "three", "four");,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationSequenceEqual;, +import rx.operators.OperatorSkipTimed;, + return OperationSequenceEqual.sequenceEqual(first, second, equality);, + return lift(new OperatorSkipTimed<T>(time, unit, scheduler));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationSequenceEqual;, +import rx.operators.OperatorSkipTimed;, + return OperationSequenceEqual.sequenceEqual(first, second, equality);, + return lift(new OperatorSkipTimed<T>(time, unit, scheduler));, +++ b/rxjava-core/src/main/java/rx/operators/OperationSequenceEqual.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or
[+++ b/.travis.yml, +- oraclejdk8]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-clojure/src/main/java/rx/lang/clojure/ClojureAdaptor.java, +/**, + * Copyright 2013 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
[+++ b/src/main/java/io/reactivex/Flowable.java, + return RxJavaPlugins.onAssembly(new FlowableSubscribeOn<T>(this, scheduler, this instanceof FlowableCreate));, +++ b/src/main/java/io/reactivex/Flowable.java, + return RxJavaPlugins.onAssembly(new FlowableSubscribeOn<T>(this, scheduler, this instanceof FlowableCreate));, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableSubscribeOn.java, +/**, + * Subscribes to the source Flowable on the specified Scheduler and makes, + * sure downstream requests are scheduled there as well., + *, + * @param <T> the value type emitted, + */, +, + final boolean nonScheduledRequests;, +, + public FlowableSubscribeOn(Publisher<T> source, Scheduler scheduler, boolean nonScheduledRequests) {, + this.nonScheduledRequests = nonScheduledRequests;, + final SubscribeOnSubscriber<T> sos = new SubscribeOnSubscriber<T>(s, w, source, nonScheduledRequests);, +, +, + final boolean nonScheduledRequests;, +, + SubscribeOnSubscriber(Subscriber<? super T> actual,
[+++ b/src/main/java/io/reactivex/Completable.java, + * Nulls out references to the upstream producer and downstream CompletableObserver if, + * the sequence is terminated or downstream calls dispose()., + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code onTerminateDetach} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + * @return a Completable which nulls out references to the upstream producer and downstream CompletableObserver if, + * the sequence is terminated or downstream calls dispose(), + * @since 2.1.5 - experimental, + */, + @Experimental, + @CheckReturnValue, + @SchedulerSupport(SchedulerSupport.NONE), + public final Completable onTerminateDetach() {, + return RxJavaPlugins.onAssembly(new CompletableDetach(this));,
[+++ b/src/main/java/io/reactivex/internal/operators/single/SingleFlatMap.java, +import io.reactivex.internal.disposables.DisposableHelper;, +import io.reactivex.internal.functions.ObjectHelper;, +import java.util.concurrent.atomic.AtomicReference;, + protected void subscribeActual(SingleObserver<? super R> actual) {, + source.subscribe(new SingleFlatMapCallback<T, R>(actual, mapper));, + static final class SingleFlatMapCallback<T, R>, + extends AtomicReference<Disposable>, + implements SingleObserver<T>, Disposable {, + }, +, + @Override, + public void dispose() {, + DisposableHelper.dispose(this);, + }, +, + @Override, + public boolean isDisposed() {, + return DisposableHelper.isDisposed(get());, + if (DisposableHelper.setOnce(this, d)) {, + actual.onSubscribe(this);, + }, + o = ObjectHelper.requireNonNull(mapper.apply(value), "The single returned by the mapper is null");, + o.subscribe(new FlatMapSingleObserver<R>(this, actual));, + public void onError(Throwable e) {, + actual.onError(e);, + }, +, + static final
[+++ b/src/main/java/io/reactivex/Maybe.java, + * through and turning an empty Maybe into a Single that emits the given, + * value through onSuccess.]
[+++ b/.gitignore, +++ b/.gitignore, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++
[+++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableCombineLatest.java, + Object[] latest;, + final SpscLinkedArrayQueue<Object[]> queue;, + this.latest = new Object[count];, + CombinerObserver<T, R>[] as = new CombinerObserver[count];, + for (int i = 0; i < count; i++) {, + as[i] = new CombinerObserver<T, R>(this, i);, + }, + this.observers = as;, + this.queue = new SpscLinkedArrayQueue<Object[]>(bufferSize);, + latest = null;, + final SpscLinkedArrayQueue<Object[]> q = queue;, + for (;;) {, + if (cancelled) {, + clear(q);, + if (!delayError && errors.get() != null) {, + cancelSources();, + clear(q);, + a.onError(errors.terminate());, + return;, + }, + Object[] s = q.poll();, + boolean empty = s ==
[+++ b/build.gradle, +, + testCompile 'org.reactivestreams:reactive-streams-tck:1.0.0', + testCompile group: 'org.testng', name: 'testng', version: '6.9.10', +task testng(type: Test) { , + useTestNG() , +} , +, +check.dependsOn testng , +, +++ b/build.gradle, +, + testCompile 'org.reactivestreams:reactive-streams-tck:1.0.0', + testCompile group: 'org.testng', name: 'testng', version: '6.9.10', +task testng(type: Test) { , + useTestNG() , +} , +, +check.dependsOn testng , +, +++ b/src/main/java/io/reactivex/internal/util/HalfSerializer.java, + /**, + * Emits the given value if possible and terminates if there was an onComplete or onError, + * while emitting, drops the value otherwise., + * @param <T> the value type, + * @param subscriber the
[+++ b/gradle.properties, +version=0.14.11]
[+++ b/language-adaptors/rxjava-scala-java/README.md, +, +rxjava-scala-java, +-----------------, +, +Contains examples illustrating how RxScala code can be used from Java., +++ b/language-adaptors/rxjava-scala-java/README.md, +, +rxjava-scala-java, +-----------------, +, +Contains examples illustrating how RxScala code can be used from Java., +++ b/language-adaptors/rxjava-scala-java/build.gradle, +, +apply plugin: 'osgi', +, +, +project(':language-adaptors:rxjava-scala-java') {, + //sourceSets.test.java.srcDir 'src/examples/java', + sourceSets.main.java.srcDir 'src/main/java', +}, +, +dependencies {, + compile 'org.scala-lang:scala-library:2.10.+', +, + compile project(':rxjava-core'), + , + compile project(':language-adaptors:rxjava-scala'), + , + provided 'junit:junit-dep:4.10', + provided 'org.mockito:mockito-core:1.8.5', + provided 'org.scalatest:scalatest_2.10:1.9.1', +}, +, +jar {, + manifest {, + name = 'rxjava-scala-java', + instruction 'Bundle-Vendor', 'Netflix', + instruction 'Bundle-DocURL', 'https://github.com/Netflix/RxJava', + instruction 'Import-Package',
[+++ b/src/main/java/io/reactivex/Single.java, + * If the {@code Iterable} of {@link SingleSource}s is empty a {@link NoSuchElementException} error is signalled after subscription., + * <p>, + * @param sources the Iterable sequence of SingleSource instances. An empty sequence will result in an, + * {@code onError} signal of {@link NoSuchElementException}., + * If the array of {@link SingleSource}s is empty a {@link NoSuchElementException} error is signalled immediately., + * <p>, + * @param sources the array of SingleSource instances. An empty sequence will result in an, + * {@code onError} signal of {@link NoSuchElementException}.]
[+++ b/src/main/java/io/reactivex/Completable.java, +import io.reactivex.annotations.*;, +import io.reactivex.internal.fuseable.*;, + * <dd>{@code ambArray} does not operate by default on a particular {@link Scheduler}.</dd>, + * <dd>{@code concatArray} does not operate by default on a particular {@link Scheduler}.</dd>, + @BackpressureSupport(BackpressureKind.FULL), + @BackpressureSupport(BackpressureKind.FULL), + @BackpressureSupport(BackpressureKind.UNBOUNDED_IN), + * <dd>{@code mergeArray} does not operate by default on a particular {@link Scheduler}.</dd>, + @BackpressureSupport(BackpressureKind.UNBOUNDED_IN), + @BackpressureSupport(BackpressureKind.FULL), + @BackpressureSupport(BackpressureKind.FULL), + * <dd>{@code mergeArrayDelayError} does not operate by default on a particular {@link Scheduler}.</dd>, + @BackpressureSupport(BackpressureKind.UNBOUNDED_IN), + @BackpressureSupport(BackpressureKind.FULL), + * <dd>{@code wrap} does not operate by default on a particular {@link Scheduler}.</dd>, + @BackpressureSupport(BackpressureKind.FULL), + * <dd>{@code blockingGet} does
[+++ b/src/main/java/io/reactivex/flowables/ConnectableFlowable.java, + * Returns a Flowable that automatically connects (at most once) to this ConnectableFlowable, + * <p>, + * <img width="640" height="392" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/autoConnect.f.png" alt="">, + * <p>, + * The connection happens after the first subscription and happens at most once, + * during the lifetime of the returned Flowable. If this ConnectableFlowable, + * terminates, the connection is never renewed, no matter how Subscribers come, + * and go. Use {@link #refCount()} to renew a connection or dispose an active, + * connection when all {@code Subscriber}s have cancelled their {@code Subscription}s., + * <p>, +
[+++ b/rxjava-contrib/rxjava-android-samples/build.gradle, + classpath 'com.android.tools.build:gradle:0.11.+', +++ b/rxjava-contrib/rxjava-android-samples/build.gradle, + classpath 'com.android.tools.build:gradle:0.11.+', +++ b/rxjava-contrib/rxjava-android-samples/gradle/wrapper/gradle-wrapper.properties, +#Sat Jun 07 16:12:40 CEST 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/rxjava-contrib/rxjava-android-samples/build.gradle, + classpath 'com.android.tools.build:gradle:0.11.+', +++ b/rxjava-contrib/rxjava-android-samples/gradle/wrapper/gradle-wrapper.properties, +#Sat Jun 07 16:12:40 CEST 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/rxjava-contrib/rxjava-android-samples/samples/build.gradle, + buildToolsVersion "19.1.0", +++ b/rxjava-contrib/rxjava-android-samples/build.gradle, + classpath 'com.android.tools.build:gradle:0.11.+', +++ b/rxjava-contrib/rxjava-android-samples/gradle/wrapper/gradle-wrapper.properties, +#Sat Jun 07 16:12:40 CEST 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/rxjava-contrib/rxjava-android-samples/samples/build.gradle, + buildToolsVersion "19.1.0", +++ b/rxjava-contrib/rxjava-android/src/main/java/rx/android/schedulers/HandlerThreadScheduler.java, +import rx.functions.Action1;, +import rx.subscriptions.BooleanSubscription;, + private BooleanSubscription innerSubscription = new BooleanSubscription();, + innerSubscription.unsubscribe();, + return innerSubscription.isUnsubscribed();, + final Runnable runnable = new Runnable() {, + @Override, + public void run() {, + if (isUnsubscribed()) {, + return;, + }, +
[+++ b/src/main/java/io/reactivex/Completable.java, + Exceptions.throwIfFatal(ex);, + Exceptions.throwIfFatal(ex);, + Exceptions.throwIfFatal(ex);, + Exceptions.throwIfFatal(ex);, +++ b/src/main/java/io/reactivex/Completable.java, + Exceptions.throwIfFatal(ex);, + Exceptions.throwIfFatal(ex);, + Exceptions.throwIfFatal(ex);, + Exceptions.throwIfFatal(ex);, +++ b/src/main/java/io/reactivex/CompletableObserver.java, + * Called once by the Completable to set a Disposable on this instance which, + * then can be used to cancel the subscription at any time., + * @param d the Disposable instance to call dispose on for cancellation, not null, + */, + void onSubscribe(Disposable d);, +, + /**, +++ b/src/main/java/io/reactivex/Completable.java, + Exceptions.throwIfFatal(ex);, + Exceptions.throwIfFatal(ex);, + Exceptions.throwIfFatal(ex);, + Exceptions.throwIfFatal(ex);, +++ b/src/main/java/io/reactivex/CompletableObserver.java, + * Called once by the Completable to set a Disposable on this
[+++ b/CHANGES.md, +### Version 0.20.0-RC3 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.20.0-RC3%22)) ###, +, +Version 0.20.0-RC3 preview release fixes several bugs related to backpressure and adds `retryWhen`, `repeatWhen` for more advanced recursion use cases like retry with exponential backoff., +, +This version passed the Netflix API production canary process. Please test this against your code to help us find any issues before we release 0.20.0., +, +* [Pull 1493] (https://github.com/Netflix/RxJava/pull/1493) retryWhen/repeatWhen, +* [Pull 1494] (https://github.com/Netflix/RxJava/pull/1494) zipWith, +* [Pull 1501] (https://github.com/Netflix/RxJava/pull/1501) blocking synchronous next, +* [Pull 1498] (https://github.com/Netflix/RxJava/pull/1498) non-deterministic testUserSubscriberUsingRequestAsync, +* [Pull 1497] (https://github.com/Netflix/RxJava/pull/1497) spsc ring buffer concurrency test, +* [Pull 1496] (https://github.com/Netflix/RxJava/pull/1496) Change RxRingBuffer
[+++ /dev/null, +++ /dev/null, +++ b/src/main/java/io/reactivex/disposables/Disposables.java, +import io.reactivex.internal.disposables.EmptyDisposable;, +import io.reactivex.internal.functions.Functions;, +import java.util.concurrent.Future;, +import org.reactivestreams.Subscription;, + return new RunnableDisposable(run);, + public static Disposable from(Subscription subscription) {, + return new SubscriptionDisposable(subscription);, + return from(Functions.emptyRunnable());, + private static final Consumer<Disposable> DISPOSER = new Consumer<Disposable>() {, +++ /dev/null, +++ b/src/main/java/io/reactivex/disposables/Disposables.java, +import io.reactivex.internal.disposables.EmptyDisposable;, +import io.reactivex.internal.functions.Functions;, +import java.util.concurrent.Future;, +import org.reactivestreams.Subscription;, + return new RunnableDisposable(run);, + public static Disposable from(Subscription subscription) {, + return new SubscriptionDisposable(subscription);, + return from(Functions.emptyRunnable());, + private static final Consumer<Disposable> DISPOSER = new Consumer<Disposable>() {, +++ b/src/main/java/io/reactivex/disposables/FutureDisposable.java, +/**, + * Copyright 2016 Netflix, Inc., + *, + * Licensed under the Apache
[+++ b/gradle.properties, +version=0.14.3-SNAPSHOT]
[+++ b/CHANGES.md, +### Version 0.19.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.19.0%22)) ###, +, +#### Performance and Object Allocation, +, +Fairly significant object allocation improvements are included in this release which reduce GC pressure and improve performance., +, +Two pull requests (amongst several) with details are:, +, +- https://github.com/Netflix/RxJava/pull/1281 Reduce Subscription Object Allocation, +- https://github.com/Netflix/RxJava/pull/1246 Moved to atomic field updaters, +, +With the following simple test code relative performance has increased as shown below:, +, +```java, +Observable<Integer> o = Observable.just(1);, +o.map(i -> {, + return String.valueOf(i);, +}).map(i -> {, + return Integer.parseInt(i);, +}).subscribe(observer);, +```, +, +, +###### Rx 0.19, +, +```, +Run: 10 -
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorThrottleFirst;, +import rx.operators.OperationTimeInterval;, + return lift(new OperatorThrottleFirst<T>(windowDuration, unit, Schedulers.computation()));, + return lift(new OperatorThrottleFirst<T>(skipDuration, unit, scheduler));, + return create(OperationTimeInterval.timeInterval(this));, + return create(OperationTimeInterval.timeInterval(this, scheduler));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorThrottleFirst;, +import rx.operators.OperationTimeInterval;, + return lift(new OperatorThrottleFirst<T>(windowDuration, unit, Schedulers.computation()));, + return lift(new OperatorThrottleFirst<T>(skipDuration, unit, scheduler));, + return create(OperationTimeInterval.timeInterval(this));, + return create(OperationTimeInterval.timeInterval(this, scheduler));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorThrottleFirst;, +import rx.operators.OperationTimeInterval;, + return lift(new OperatorThrottleFirst<T>(windowDuration, unit, Schedulers.computation()));, + return lift(new OperatorThrottleFirst<T>(skipDuration, unit, scheduler));, + return create(OperationTimeInterval.timeInterval(this));, + return create(OperationTimeInterval.timeInterval(this, scheduler));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperationTimeInterval.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version
[+++ b/src/main/java/io/reactivex/flowables/ConnectableFlowable.java, + * A {@code ConnectableFlowable} resembles an ordinary {@link Flowable}, except that it does not begin, + * can wait for all intended {@link Subscriber}s to {@link Flowable#subscribe} to the {@code Flowable}, + * before the {@code Flowable} begins emitting items., + * the type of items emitted by the {@code ConnectableFlowable}, + * Instructs the {@code ConnectableFlowable} to begin emitting the items from its underlying, + * Instructs the {@code ConnectableFlowable} to begin emitting the items from its underlying, + * Returns a {@code Flowable} that stays connected to this {@code ConnectableFlowable} as long as there,
[+++ b/rxjava-contrib/rxjava-computation-expressions/src/main/java/rx/Statement.java, +import rx.operators.OperatorIfThen;, +import rx.operators.OperatorSwitchCase;, +import rx.operators.OperatorWhileDoWhile;, +public final class Statement {, + private Statement() { throw new IllegalStateException("No instances!"); }, + return Observable.create(new OperatorSwitchCase<K, R>(caseSelector, mapOfCases, defaultCase));, + public static <T> Observable<T> doWhile(Observable<? extends T> source, Func0<Boolean> postCondition) {, + return Observable.create(new OperatorWhileDoWhile<T>(source, TRUE, postCondition));, + public static <T> Observable<T> whileDo(Observable<? extends T> source, Func0<Boolean> preCondition) {, + return Observable.create(new OperatorWhileDoWhile<T>(source, preCondition, preCondition));, + return Observable.create(new OperatorIfThen<R>(condition, then, orElse));, + }, + /** Returns always true. */, + private static final class Func0True implements Func0<Boolean> {, + @Override, + public Boolean call() {, + return true;, +
[+++ b/gradle.properties, +version=0.17.0-RC4-SNAPSHOT, +++ b/gradle.properties, +version=0.17.0-RC4-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, + duration(100 millis), // a short delay because medals are only awarded some time after the Games began, + val oneYear = 1000.millis, + //val neverUsedDummyMedal = Medal(3333, "?", "?", "?", "?", "?"), + /** runs an infinite loop, and returns Bottom type (Nothing) */, + def getNothing: Nothing = {, + println("You shouldn't have called this method ;-)"), + getNothing, + }, + , + /** returns an Observable which emits no elements and completes after a duration of d */, + def duration(d: Duration): Observable[Nothing] = Observable.interval(d).take(1).filter(_ => false).map(_
[+++ b/src/main/java/io/reactivex/Completable.java, + public static <T> Completable fromSingle(final SingleSource<T> single) {, +++ b/src/main/java/io/reactivex/Completable.java, + public static <T> Completable fromSingle(final SingleSource<T> single) {, +++ b/src/main/java/io/reactivex/Observable.java, + return Single.create(new SingleSource<T>() {, + public void subscribe(final SingleObserver<? super T> s) {, +++ b/src/main/java/io/reactivex/Completable.java, + public static <T> Completable fromSingle(final SingleSource<T> single) {, +++ b/src/main/java/io/reactivex/Observable.java, + return Single.create(new SingleSource<T>() {, + public void subscribe(final SingleObserver<? super T> s) {, +++ b/src/main/java/io/reactivex/Single.java, +public abstract class Single<T> implements SingleSource<T> {, + static <T> Single<T> wrap(SingleSource<T> source) {, + public static <T> Single<T> amb(final Iterable<? extends SingleSource<? extends T>> sources) {, + public static <T> Single<T>
[+++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/CompletableTransformer.java, + CompletableSource apply(Completable upstream);, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/CompletableTransformer.java, + CompletableSource apply(Completable upstream);, +++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/CompletableTransformer.java, + CompletableSource apply(Completable upstream);, +++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/FlowableTransformer.java, + Publisher<Downstream> apply(Flowable<Upstream> upstream);, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/CompletableTransformer.java, + CompletableSource apply(Completable upstream);, +++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/FlowableTransformer.java, + Publisher<Downstream> apply(Flowable<Upstream> upstream);, +++ b/src/main/java/io/reactivex/Maybe.java, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/CompletableTransformer.java, + CompletableSource apply(Completable upstream);, +++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/FlowableTransformer.java, + Publisher<Downstream> apply(Flowable<Upstream> upstream);, +++ b/src/main/java/io/reactivex/Maybe.java, +++ b/src/main/java/io/reactivex/MaybeTransformer.java, + MaybeSource<Downstream> apply(Maybe<Upstream> upstream);, +++ b/src/main/java/io/reactivex/Completable.java, +++ b/src/main/java/io/reactivex/CompletableTransformer.java, + CompletableSource apply(Completable upstream);, +++ b/src/main/java/io/reactivex/Flowable.java, +++ b/src/main/java/io/reactivex/FlowableTransformer.java, + Publisher<Downstream> apply(Flowable<Upstream> upstream);, +++ b/src/main/java/io/reactivex/Maybe.java, +++ b/src/main/java/io/reactivex/MaybeTransformer.java, +
[+++ b/src/main/java/io/reactivex/Completable.java, + * Returns a Completable which calls the given onEvent callback with the (throwable) for an onError, + * or (null) for an onComplete signal from this Completable before delivering said signal to the downstream., + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code doOnEvent} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + * @param onEvent the event callback, + * @return the new Completable instance, + * @throws NullPointerException if onEvent is null, + */, + @SchedulerSupport(SchedulerSupport.NONE), + public final Completable doOnEvent(final Consumer<? super Throwable> onEvent) {, + ObjectHelper.requireNonNull(onEvent, "onEvent
[+++ b/src/main/java/io/reactivex/internal/schedulers/ExecutorScheduler.java, + /* public: test support. */, + public static final class ExecutorWorker extends Scheduler.Worker implements Runnable {, + final SetCompositeResource<Disposable> tasks = new SetCompositeResource<>(Disposable::dispose);, + , + ScheduledRunnable sr = new ScheduledRunnable(() -> {, + mar.setResource(schedule(decoratedRun));, + }, tasks);, + tasks.add(sr);, + Future<?> f = ((ScheduledExecutorService)executor).schedule(sr, delay, unit);, + sr.setFuture(f);, + Disposable d = HELPER.scheduleDirect(sr, delay, unit);, + sr.setFuture(new Future<Object>() {, + @Override, + public boolean cancel(boolean mayInterruptIfRunning) {, + d.dispose();, + return false;, + @Override, + public boolean isCancelled() {, + return false;, + }, +, + @Override, + public boolean isDone() {, + return false;,
[+++ b/src/main/java/io/reactivex/Single.java, +import java.util.NoSuchElementException;, + ObjectHelper.requireNonNull(zipper, "zipper is null");, + return RxJavaPlugins.onAssembly(new SingleZipIterable<T, R>(sources, zipper));, + ObjectHelper.requireNonNull(zipper, "zipper is null");, + if (sources.length == 0) {, + return error(new NoSuchElementException());, + return RxJavaPlugins.onAssembly(new SingleZipArray<T, R>(sources, zipper));, +++ b/src/main/java/io/reactivex/Single.java, +import java.util.NoSuchElementException;, + ObjectHelper.requireNonNull(zipper, "zipper is null");, + return RxJavaPlugins.onAssembly(new SingleZipIterable<T, R>(sources, zipper));, + ObjectHelper.requireNonNull(zipper, "zipper is null");, + if (sources.length == 0) {, + return error(new NoSuchElementException());, + return RxJavaPlugins.onAssembly(new SingleZipArray<T, R>(sources, zipper));, +++ b/src/main/java/io/reactivex/internal/operators/maybe/MaybeZipArray.java, + MaybeSource<? extends T> source = sources[i];, +, + if (source == null) {, + parent.innerError(new NullPointerException("One of the sources is null"), i);, + return;,
[+++ b/gradle.properties, +version=0.12.1-SNAPSHOT]
[+++ b/gradle.properties, +version=0.17.7-SNAPSHOT]
[+++ b/rxjava-core/src/main/java/rx/Observable.java, + return lift(new OperatorTakeLast<T>(count));, + return lift(new OperatorTakeLastTimed<T>(count, time, unit, scheduler));, + return lift(new OperatorTakeLastTimed<T>(time, unit, scheduler));, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return lift(new OperatorTakeLast<T>(count));, + return lift(new OperatorTakeLastTimed<T>(count, time, unit, scheduler));, + return lift(new OperatorTakeLastTimed<T>(time, unit, scheduler));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, + return lift(new OperatorTakeLast<T>(count));, + return lift(new OperatorTakeLastTimed<T>(count, time, unit, scheduler));, + return lift(new OperatorTakeLastTimed<T>(time, unit, scheduler));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorTakeLast.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., +
[+++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/language-adaptors/rxjava-scala/Rationale.md, +object Observable { …}, +++ b/language-adaptors/rxjava-scala/ReleaseNotes.md, +RxScala Release Notes, +=====================, +, +This release of the RxScala bindings builds on the previous 0.15 release to make the Rx bindings for Scala, +include all Rx types. In particular this release focuses on fleshing out the bindings for the `Subject` and `Scheduler` types., +To makes these notes self-contained, we will start with the `Observer[T]` and `Observable[T]` traits, +that lay at the heart of Rx., +, +Observer, +--------, +, +In this release we have made the `asJavaObserver` property in `Observable[T]`as well the the factory method
[+++ b/rxjava-core/src/main/java/rx/Notification.java, + public void accept(Observer<? super T> observer) {, +++ b/rxjava-core/src/main/java/rx/Notification.java, + public void accept(Observer<? super T> observer) {, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.observers.SafeObserver;, +import rx.operators.OperationTakeTimed;, +import rx.operators.SafeObservableSubscription;, + * {@link OnSubscribeFunc} to be executed when {@link #subscribe(Observer)} is called, + * Returns an Observable that will execute the specified function when an {@link Observer} subscribes to it., + * invoke the Observer's {@link Observer#onNext onNext}, {@link Observer#onError onError}, and {@link Observer#onCompleted onCompleted} methods appropriately., + * @return an Observable that, when an {@link Observer} subscribes to it, will execute the, + * @see <a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables#wiki-create">RxJava Wiki: create()</a>, +
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.13.2-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.13.2-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/build.gradle, + instruction 'Import-Package', '!org.junit,!junit.framework,!org.mockito.*,*', +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.13.2-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/build.gradle, + instruction 'Import-Package', '!org.junit,!junit.framework,!org.mockito.*,*', +++ b/rxjava-core/src/main/java/rx/Observable.java, + * , + * <p>A typical implementation of {@code subscribe} does the following:, + * , + * <p>A typical implementation of {@code subscribe} does the following:, + * , + * Combines the given observables, emitting an event containing an aggregation of the latest values of each of the source observables, + * each time an event is received from one of the source observables, where
[+++ b/CHANGES.md, +### Version 0.20.0-RC3 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.20.0-RC3%22)) ###, +, +Version 0.20.0-RC3 preview release fixes several bugs related to backpressure and adds `retryWhen`, `repeatWhen` for more advanced recursion use cases like retry with exponential backoff., +, +This version passed the Netflix API production canary process. Please test this against your code to help us find any issues before we release 0.20.0., +, +* [Pull 1493] (https://github.com/Netflix/RxJava/pull/1493) retryWhen/repeatWhen, +* [Pull 1494] (https://github.com/Netflix/RxJava/pull/1494) zipWith, +* [Pull 1501] (https://github.com/Netflix/RxJava/pull/1501) blocking synchronous next, +* [Pull 1498] (https://github.com/Netflix/RxJava/pull/1498) non-deterministic testUserSubscriberUsingRequestAsync, +* [Pull 1497] (https://github.com/Netflix/RxJava/pull/1497) spsc ring buffer concurrency test, +* [Pull 1496] (https://github.com/Netflix/RxJava/pull/1496) Change RxRingBuffer
[+++ b/rxjava-contrib/rxjava-android-samples/gradle/wrapper/gradle-wrapper.properties, +#Sat Apr 05 11:18:06 CEST 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.11-all.zip]
[+++ b/src/main/java/io/reactivex/Maybe.java, + * receive all successfully emitted items from all of the source MaybeSources without being interrupted by, + * an error notification from one of them or even the main Publisher., + * This behaves like {@link #merge(Publisher)} except that if any of the merged MaybeSources notify of an, + * error notification until all of the merged MaybeSources and the main Publisher have finished emitting items., +, + /**, + * Flattens a Publisher that emits MaybeSources into one Publisher, in a way that allows a Subscriber to, + * receive all successfully emitted items from
[+++ b/rxjava-contrib/rxjava-android-samples/gradle/wrapper/gradle-wrapper.properties, +#Sat Apr 05 11:18:06 CEST 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.11-all.zip]
[+++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/internal/observers/LambdaObserver.java, + s.dispose();, + get().dispose();, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/internal/observers/LambdaObserver.java, + s.dispose();, + get().dispose();, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableInternalHelper.java, +++ b/src/main/java/io/reactivex/Observable.java, +++ b/src/main/java/io/reactivex/internal/observers/LambdaObserver.java, + s.dispose();, + get().dispose();, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableInternalHelper.java, +++ b/src/test/java/io/reactivex/internal/observers/LambdaObserverTest.java, +import io.reactivex.subjects.PublishSubject;, +, + @Test, + public void onNextThrowsCancelsUpstream() {, + PublishSubject<Integer> ps = PublishSubject.create();, +, + final List<Throwable> errors = new ArrayList<Throwable>();, +, + ps.subscribe(new Consumer<Integer>() {, + @Override, + public void accept(Integer v) throws Exception {, + throw new TestException();, + }, + }, new Consumer<Throwable>() {, + @Override, + public void accept(Throwable e) throws Exception {, + errors.add(e);, + }, + });, +, +
[+++ b/src/main/java/io/reactivex/disposables/Disposables.java, +import io.reactivex.internal.disposables.EmptyDisposable;, + return EmptyDisposable.INSTANCE;, +++ b/src/main/java/io/reactivex/disposables/Disposables.java, +import io.reactivex.internal.disposables.EmptyDisposable;, + return EmptyDisposable.INSTANCE;, +++ b/src/main/java/io/reactivex/internal/disposables/NbpFullArbiter.java, + this.s = EmptyDisposable.INSTANCE;]
[+++ b/src/main/java/io/reactivex/Single.java, +, + if (cancelled) {, + ts.cancel();, + }, +]
[+++ b/src/main/java/io/reactivex/Observable.java, + public final Observable<Observable<T>> window(long timespan, TimeUnit unit) {, + return window(timespan, unit, Schedulers.computation(), Long.MAX_VALUE, false);, + }, +, + public final Observable<Observable<T>> window(long timespan, TimeUnit unit, , + long count) {, + return window(timespan, unit, Schedulers.computation(), count, false);, + }, +, + public final Observable<Observable<T>> window(long timespan, TimeUnit unit, , + long count, boolean restart) {, + return window(timespan, unit, Schedulers.computation(), count, restart);, + }, +, + public final Observable<Observable<T>> window(long timespan, TimeUnit unit, , + Scheduler scheduler) {, + return window(timespan, unit, scheduler, Long.MAX_VALUE, false);, + }, +, + public final Observable<Observable<T>> window(long timespan, TimeUnit
[+++ b/src/main/java/io/reactivex/Observable.java, + return new ObservableHide<T>(this);, +++ b/src/main/java/io/reactivex/Observable.java, + return new ObservableHide<T>(this);, +++ b/src/main/java/io/reactivex/internal/operators/observable/ObservableHide.java, +/**, + * Copyright 2016 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +import rx.lang.scala.observable, +import rx.lang.scala.concurrency.Schedulers, + o.observeOn(Schedulers.newThread).subscribe(, + o.observeOn(Schedulers.newThread).subscribe(, + @Test def observableLikeFuture1() {, + implicit val scheduler = Schedulers.threadPoolForIO, + val o1 = observable {, + Thread.sleep(1000), + 5, + }, + val o2 = observable {, + Thread.sleep(500), + 4, + }, + Thread.sleep(500), + val t1 = System.currentTimeMillis, + println((o1 merge o2).first.toBlockingObservable.single), + println(System.currentTimeMillis - t1), + }, +, + @Test def observableLikeFuture2() {, + class Friend {}, + val session = new Object {, + def getFriends: List[Friend] = List(new Friend, new Friend), + }, +, + implicit val scheduler = Schedulers.threadPoolForIO, + val
[+++ b/src/main/java/io/reactivex/Observable.java, + public static <T, R> Observable<R> zip(Iterable<? extends Publisher<? extends T>> sources, Function<? super Object[], ? extends R> zipper) {, + Objects.requireNonNull(zipper);, + Objects.requireNonNull(sources);, + return create(new PublisherZip<>(null, sources, zipper, bufferSize(), false));, + }, +, + , +++ b/src/main/java/io/reactivex/Observable.java, + public static <T, R> Observable<R> zip(Iterable<? extends Publisher<? extends T>> sources, Function<? super Object[], ? extends R> zipper) {, + Objects.requireNonNull(zipper);, + Objects.requireNonNull(sources);, + return create(new PublisherZip<>(null, sources, zipper, bufferSize(), false));, + }, +, + , +++ b/src/main/java/io/reactivex/internal/operators/OperatorDebounceTimed.java, + , + DebounceEmitter<T> de = new DebounceEmitter<>(t, idx, this);, + if (!TIMER.compareAndSet(this, d, de)) {, + return;, +
[+++ b/.travis.yml]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * @throws NullPointerException, + * @throws NullPointerException, + * @throws NullPointerException, + * @throws NullPointerException, +++ b/src/main/java/io/reactivex/Flowable.java, + * @throws NullPointerException, + * @throws NullPointerException, + * @throws NullPointerException, + * @throws NullPointerException, +++ b/src/main/java/io/reactivex/Maybe.java, + * @throws NullPointerException, + * @throws NullPointerException, +++ b/src/main/java/io/reactivex/Flowable.java, + * @throws NullPointerException, + * @throws NullPointerException, + * @throws NullPointerException, + * @throws NullPointerException, +++ b/src/main/java/io/reactivex/Maybe.java, + * @throws NullPointerException, + * @throws NullPointerException, +++ b/src/main/java/io/reactivex/Observable.java, + * @throws NullPointerException, + * @throws NullPointerException, + * @throws NullPointerException, + * @throws NullPointerException, +++ b/src/main/java/io/reactivex/Flowable.java, + * @throws NullPointerException, +
[+++ b/build.gradle, + perfCompile 'org.openjdk.jmh:jmh-core:1.16', + perfCompile 'org.openjdk.jmh:jmh-generator-annprocess:1.16', +++ b/build.gradle, + perfCompile 'org.openjdk.jmh:jmh-core:1.16', + perfCompile 'org.openjdk.jmh:jmh-generator-annprocess:1.16', +++ b/src/main/java/io/reactivex/Flowable.java, + ObjectHelper.requireNonNull(seed, "seed is null");, + ObjectHelper.requireNonNull(reducer, "reducer is null");, + return RxJavaPlugins.onAssembly(new FlowableReduceSeedSingle<T, R>(this, seed, reducer));, + ObjectHelper.requireNonNull(seedSupplier, "seedSupplier is null");, + ObjectHelper.requireNonNull(reducer, "reducer is null");, + return RxJavaPlugins.onAssembly(new FlowableReduceWithSingle<T, R>(this, seedSupplier, reducer));, +++ b/build.gradle, + perfCompile 'org.openjdk.jmh:jmh-core:1.16', + perfCompile 'org.openjdk.jmh:jmh-generator-annprocess:1.16', +++ b/src/main/java/io/reactivex/Flowable.java, + ObjectHelper.requireNonNull(seed, "seed is null");, + ObjectHelper.requireNonNull(reducer, "reducer is null");, + return RxJavaPlugins.onAssembly(new FlowableReduceSeedSingle<T, R>(this, seed, reducer));, + ObjectHelper.requireNonNull(seedSupplier, "seedSupplier is null");, + ObjectHelper.requireNonNull(reducer, "reducer is null");, + return RxJavaPlugins.onAssembly(new FlowableReduceWithSingle<T, R>(this, seedSupplier, reducer));, +++ b/src/main/java/io/reactivex/Observable.java, +
[+++ b/CHANGES.md, +### Version 0.6.2 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.6.2%22)) ###, +, +* [Issue 101](https://github.com/Netflix/RxJava/issues/101) Operator: Where (alias to filter), +* [Pull 197](https://github.com/Netflix/RxJava/pull/197) TakeWhile observables do not properly complete, +* [Issue 21](https://github.com/Netflix/RxJava/issues/21) Operator: All, +* [Pull 206](https://github.com/Netflix/RxJava/pull/206) Observable.toList breaks with multiple subscribers, +* [Issue 29](https://github.com/Netflix/RxJava/issues/29) Operator: CombineLatest, +* [Issue 211](https://github.com/Netflix/RxJava/issues/211) Remove use of JSR 305 and dependency on com.google.code.findbugs, +* [Pull 212](https://github.com/Netflix/RxJava/pull/212) Operation take leaks errors, +* [Pull 220](https://github.com/Netflix/RxJava/pull/220) TakeWhile protect calls to predicate, +* [Pull 221](https://github.com/Netflix/RxJava/pull/221) Error Handling Improvements - User Provided Observers/Functions, +* [Pull 201](https://github.com/Netflix/RxJava/pull/201) Synchronize Observer on OperationMerge, +* [Issue 43](https://github.com/Netflix/RxJava/issues/43) Operator: Finally, +, +### Version 0.6.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.6.1%22))
[+++ b/gradle.properties, +version=0.20.0-RC6]
[+++ b/src/main/java/io/reactivex/disposables/Disposables.java, + return EmptyDisposable.INSTANCE;, +++ b/src/main/java/io/reactivex/disposables/Disposables.java, + return EmptyDisposable.INSTANCE;, +++ b/src/main/java/io/reactivex/internal/disposables/DisposableHelper.java, + /**, + * Marker instance compared by identity for indicating a previously referenced, + * {@link Disposable} was disposed. DO NOT USE this instance as an arbitrary, empty disposable!, + */]
[+++ b/src/main/java/io/reactivex/processors/AsyncProcessor.java, + @Nullable, + @Nullable, +++ b/src/main/java/io/reactivex/processors/AsyncProcessor.java, + @Nullable, + @Nullable, +++ b/src/main/java/io/reactivex/processors/BehaviorProcessor.java, + @Nullable, + @Nullable, +++ b/src/main/java/io/reactivex/processors/AsyncProcessor.java, + @Nullable, + @Nullable, +++ b/src/main/java/io/reactivex/processors/BehaviorProcessor.java, + @Nullable, + @Nullable, +++ b/src/main/java/io/reactivex/processors/PublishProcessor.java, + @Nullable, +++ b/src/main/java/io/reactivex/processors/AsyncProcessor.java, + @Nullable, + @Nullable, +++ b/src/main/java/io/reactivex/processors/BehaviorProcessor.java, + @Nullable, + @Nullable, +++ b/src/main/java/io/reactivex/processors/PublishProcessor.java, + @Nullable, +++ b/src/main/java/io/reactivex/processors/ReplayProcessor.java, + @Nullable, + @Nullable, + @Nullable, + @Nullable, +++ b/src/main/java/io/reactivex/processors/AsyncProcessor.java, + @Nullable, + @Nullable, +++ b/src/main/java/io/reactivex/processors/BehaviorProcessor.java, + @Nullable, + @Nullable, +++ b/src/main/java/io/reactivex/processors/PublishProcessor.java, + @Nullable, +++ b/src/main/java/io/reactivex/processors/ReplayProcessor.java, + @Nullable, + @Nullable, + @Nullable, + @Nullable, +++ b/src/main/java/io/reactivex/processors/SerializedProcessor.java, +import io.reactivex.annotations.Nullable;, + @Nullable, +++ b/src/main/java/io/reactivex/processors/AsyncProcessor.java, + @Nullable, + @Nullable, +++
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Ensures that the event flow between the upstream and downstream follow, + * the Reactive-Streams 1.0 specification by honoring the 3 additional rules, + * (which are omitted in standard operators due to performance reasons)., + * <ul>, + * <li>§1.3: onNext should not be called concurrently until onSubscribe returns</li>, + * <li>§2.3: onError or onComplete must not call cancel</li>, + * <li>§3.9: negative requests should emit an onError(IllegalArgumentException)</li>, + * </ul>, + * In addition, if rule §2.12 (onSubscribe must be called at most once) is violated,, + * the sequence is cancelled an
[+++ b/src/main/java/io/reactivex/internal/subscribers/EmptySubscriber.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the
[+++ b/src/main/java/io/reactivex/Observable.java, + public final Observable<List<T>> buffer(int count) {, + return buffer(count, count);, + }, +, + public final <U extends Collection<? super T>> Observable<U> buffer(int count, Supplier<U> bufferSupplier) {, + return buffer(count, count, bufferSupplier);, + }, +, + public final Observable<List<T>> buffer(int count, int skip) {, + return buffer(count, skip, ArrayList::new);, + }, +, + public final <U extends Collection<? super T>> Observable<U> buffer(int count, int skip, Supplier<U> bufferSupplier) {, + return lift(new OperatorBuffer<>(count, skip, bufferSupplier));, + }, + , + public final Observable<List<T>> buffer(long timespan, TimeUnit unit) {, + return buffer(timespan, unit, Integer.MAX_VALUE, Schedulers.computation());, + }, +,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationDebounce;, +import rx.operators.OperatorGroupByUntil;, + return create(OperationDebounce.debounceSelector(this, debounceSelector));, + return create(OperationDebounce.debounce(this, timeout, unit));, + return create(OperationDebounce.debounce(this, timeout, unit, scheduler));, + return lift(new OperatorGroupByUntil<T, TKey, TValue, TDuration>(keySelector, valueSelector, durationSelector));, + return create(OperationDebounce.debounce(this, timeout, unit));, + return create(OperationDebounce.debounce(this, timeout, unit, scheduler));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationDebounce;, +import rx.operators.OperatorGroupByUntil;, + return create(OperationDebounce.debounceSelector(this, debounceSelector));, + return create(OperationDebounce.debounce(this, timeout, unit));, + return create(OperationDebounce.debounce(this, timeout, unit, scheduler));, + return lift(new OperatorGroupByUntil<T, TKey, TValue, TDuration>(keySelector, valueSelector, durationSelector));, + return create(OperationDebounce.debounce(this, timeout, unit));, + return create(OperationDebounce.debounce(this, timeout, unit, scheduler));, +++ b/rxjava-core/src/main/java/rx/operators/OperationDebounce.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the
[+++ b/src/main/java/io/reactivex/Completable.java, + * <img width="640" height="442" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.create.png" alt="">, + * <p>, + * <p>, + * <img width="640" height="260" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.unsafeCreate.png" alt="">, + * <img width="640" height="313" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.lift.png" alt="">, + * <p>, + * <p>, + * <img width="640" height="373" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.repeat.png" alt="">, + * <p>, + * <img width="640" height="408" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.repeat.n.png" alt="">, + * <p>, + * <img width="640" height="381" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.repeatUntil.png" alt="">, + * <p>, + * <img width="640" height="586" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.repeatWhen.png" alt="">, + * <p>, + * <img width="640" height="368" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retry.png" alt="">, + * <p>, + * <img width="640" height="325" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.retry.ff.png" alt="">, + * <p>, + * <img width="640"
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorAll;, + return lift(new OperatorAll<T>(predicate));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorAll;, + return lift(new OperatorAll<T>(predicate));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorAll;, + return lift(new OperatorAll<T>(predicate));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorAll.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software, +
[+++ b/src/main/java/io/reactivex/Maybe.java, + * be subscribed to., +++ b/src/main/java/io/reactivex/Maybe.java, + * be subscribed to., +++ b/src/main/java/io/reactivex/Single.java, + * be subscribed to.]
[+++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscription { }, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscription { }, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscription { }, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { }, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/ExtensionTests.kt, + Subscription { }, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/rxjava-contrib/rxjava-android/build.gradle, +++ b/.gitignore, +/.nb-gradle/profiles/private/, +++ b/language-adaptors/rxjava-kotlin/src/test/kotlin/rx/lang/kotlin/BasicKotlinTests.kt, + return Subscription { },
[+++ b/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java, + private AtomicReferenceArray<Object> lvNextBufferAndUnlink(AtomicReferenceArray<Object> curr, int nextIndex) {, + int nextOffset = calcDirectOffset(nextIndex);, + AtomicReferenceArray<Object> nextBuffer = (AtomicReferenceArray<Object>)lvElement(curr, nextOffset);, + soElement(curr, nextOffset, null); // Avoid GC nepotism, + return nextBuffer;, + return newBufferPoll(lvNextBufferAndUnlink(buffer, mask + 1), index, mask);, + return newBufferPeek(lvNextBufferAndUnlink(buffer, mask + 1), index, mask);, +++ b/src/main/java/io/reactivex/internal/queue/SpscLinkedArrayQueue.java, + private AtomicReferenceArray<Object> lvNextBufferAndUnlink(AtomicReferenceArray<Object> curr, int nextIndex) {, + int nextOffset = calcDirectOffset(nextIndex);, + AtomicReferenceArray<Object> nextBuffer = (AtomicReferenceArray<Object>)lvElement(curr, nextOffset);, + soElement(curr, nextOffset, null); // Avoid GC nepotism, + return nextBuffer;, + return newBufferPoll(lvNextBufferAndUnlink(buffer, mask + 1), index, mask);, + return newBufferPeek(lvNextBufferAndUnlink(buffer, mask + 1), index, mask);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableRefCountTest.java, +
[+++ b/rxjava-contrib/rxjava-computation-expressions/build.gradle, +apply plugin: 'osgi', +, +sourceCompatibility = JavaVersion.VERSION_1_6, +targetCompatibility = JavaVersion.VERSION_1_6, +, +dependencies {, + compile project(':rxjava-core'), + testCompile project(":rxjava-core").sourceSets.test.output , + provided 'junit:junit-dep:4.10', + provided 'org.mockito:mockito-core:1.8.5', +}, +, +jar {, + manifest {, + name = 'rxjava-computation-expressions', + instruction 'Bundle-Vendor', 'Netflix', + instruction 'Bundle-DocURL', 'https://github.com/Netflix/RxJava', + instruction 'Import-Package', '!org.junit,!junit.framework,!org.mockito.*,*', + }, +}, +++ b/rxjava-contrib/rxjava-computation-expressions/build.gradle, +apply plugin: 'osgi', +, +sourceCompatibility = JavaVersion.VERSION_1_6, +targetCompatibility = JavaVersion.VERSION_1_6, +, +dependencies {, + compile project(':rxjava-core'), + testCompile project(":rxjava-core").sourceSets.test.output , + provided 'junit:junit-dep:4.10', + provided 'org.mockito:mockito-core:1.8.5', +}, +, +jar {, + manifest {, + name = 'rxjava-computation-expressions', + instruction 'Bundle-Vendor', 'Netflix', + instruction
[+++ b/src/main/java/io/reactivex/internal/schedulers/ComputationScheduler.java, +import java.util.concurrent.*;, +import java.util.concurrent.atomic.AtomicReference;, +, + static final FixedSchedulerPool NONE;, + final ThreadFactory threadFactory;, +, + NONE = new FixedSchedulerPool(0, THREAD_FACTORY);, + NONE.shutdown();, + FixedSchedulerPool(int maxThreads, ThreadFactory threadFactory) {, + this.eventLoops[i] = new PoolWorker(threadFactory);, + this(THREAD_FACTORY);, + }, +, + /**, + * Create a scheduler with pool size equal to the available processor, + * count and using least-recent worker selection policy., + *, + * @param threadFactory thread factory to use for creating worker threads. Note that this takes precedence over any, + * system properties for configuring new thread creation. Cannot be null., +
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationDistinctUntilChanged;, +import rx.operators.OperatorFinally;, + return create(OperationDistinctUntilChanged.distinctUntilChanged(this));, + return create(OperationDistinctUntilChanged.distinctUntilChanged(this, keySelector));, + return lift(new OperatorFinally<T>(action));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationDistinctUntilChanged;, +import rx.operators.OperatorFinally;, + return create(OperationDistinctUntilChanged.distinctUntilChanged(this));, + return create(OperationDistinctUntilChanged.distinctUntilChanged(this, keySelector));, + return lift(new OperatorFinally<T>(action));, +++ b/rxjava-core/src/main/java/rx/operators/OperationDistinctUntilChanged.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or
[+++ b/src/main/java/io/reactivex/Completable.java, + * Returns an Observable which first delivers the events, + * of the other Observable then runs this CompletableConsumable., + * @param other the other Observable to run first, + * @return the new Observable instance, + * Returns an Observable which when subscribed to subscribes to this Completable and, + * @return the new Observable created, +++ b/src/main/java/io/reactivex/Completable.java, + * Returns an Observable which first delivers the events, + * of the other Observable then runs this CompletableConsumable., + * @param other the other Observable to run first, + * @return the new Observable instance,
[+++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +/target, +*/target, +/build, +*/build, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/build.gradle, +// Establish version and status, +ext.githubProjectName = rootProject.name // Change if github project name is not the same as the root project's name, +apply from: file('gradle/check.gradle'), + group = "com.netflix.${githubProjectName}" // TEMPLATE: Set to organization of project, + dependencies {, + compile 'javax.ws.rs:jsr311-api:1.1.1', + compile 'com.sun.jersey:jersey-core:1.11', + testCompile 'org.testng:testng:6.1.1',
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/README.md, +# RxJava: Functional Reactive Programming on the JVM, +++ b/CHANGES.md, +++ b/README.md, +# RxJava: Functional Reactive Programming on the JVM, +++ b/build.gradle, + //perfCompile project, +++ b/CHANGES.md, +++ b/README.md, +# RxJava: Functional Reactive Programming on the JVM, +++ b/build.gradle, + //perfCompile project, +++ b/gradle.properties, +version=0.17.3-SNAPSHOT, +++ b/CHANGES.md, +++ b/README.md, +# RxJava: Functional Reactive Programming on the JVM, +++ b/build.gradle, + //perfCompile project, +++ b/gradle.properties, +version=0.17.3-SNAPSHOT, +++ b/gradle/buildscript.gradle, +++ b/CHANGES.md, +++ b/README.md, +# RxJava: Functional Reactive Programming on the JVM, +++ b/build.gradle, + //perfCompile project, +++ b/gradle.properties, +version=0.17.3-SNAPSHOT, +++ b/gradle/buildscript.gradle, +++ b/language-adaptors/rxjava-clojure/README.md, +Once the
[+++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeFromActionTest.java, + cdl2.await(5, TimeUnit.SECONDS);, +++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeFromActionTest.java, + cdl2.await(5, TimeUnit.SECONDS);, +++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeFromCallableTest.java, + cdl2.await(5, TimeUnit.SECONDS);, +++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeFromActionTest.java, + cdl2.await(5, TimeUnit.SECONDS);, +++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeFromCallableTest.java, + cdl2.await(5, TimeUnit.SECONDS);, +++ b/src/test/java/io/reactivex/internal/operators/maybe/MaybeFromRunnableTest.java, + cdl2.await(5, TimeUnit.SECONDS);]
[+++ b/src/main/java/io/reactivex/CompletableEmitter.java, + * All methods are safe to call from multiple threads, but note that there is no guarantee, + * whose terminal event will win and get delivered to the downstream., + * Calling {@link #onComplete()} multiple times has no effect., + * Calling {@link #onError(Throwable)} multiple times or after {@code onComplete} will route the, + * exception into the global error handler via {@link io.reactivex.plugins.RxJavaPlugins#onError(Throwable)}., + * <p>, + * The emitter allows the registration of a single resource, in the form of a {@link Disposable}, + * or {@link Cancellable} via {@link #setDisposable(Disposable)} or {@link
[+++ b/src/test/java/io/reactivex/XFlatMapTest.java, +import io.reactivex.observers.*;, + public Retry retry = new Retry(5, 1000, true);, + long before = System.currentTimeMillis();, + throw new IllegalStateException("Was not interrupted in time?! " + (System.currentTimeMillis() - before));, + void beforeCancelSleep(BaseTestConsumer<?, ?> ts) throws Exception {, + long before = System.currentTimeMillis();, + Thread.sleep(50);, + if (System.currentTimeMillis() - before > 100) {, + ts.dispose();, + throw new IllegalStateException("Overslept?" + (System.currentTimeMillis() - before));, + }, + }, +, + beforeCancelSleep(ts);, + beforeCancelSleep(ts);, + beforeCancelSleep(ts);, + beforeCancelSleep(ts);, + beforeCancelSleep(ts);, + beforeCancelSleep(ts);, + beforeCancelSleep(ts);, + beforeCancelSleep(ts);, + beforeCancelSleep(ts);, + beforeCancelSleep(ts);, + beforeCancelSleep(ts);, + beforeCancelSleep(ts);, + beforeCancelSleep(ts);, + beforeCancelSleep(ts);, + beforeCancelSleep(ts);,
[+++ b/src/main/java/io/reactivex/Flowable.java, + * <p>, + * If either the source {@code Publisher} or the boundary {@code Publisher} issues an {@code onError} notification the event is passed on, + * <dl>, + * <p>, + * If either the source {@code Publisher} or the boundary {@code Publisher} issues an {@code onError} notification the event is passed on, + * <dl>, +++ b/src/main/java/io/reactivex/Flowable.java, + * <p>, + * If either the source {@code Publisher} or the boundary {@code Publisher} issues an {@code onError} notification the event is passed on, + * <dl>, + * <p>, + * If either the
[+++ b/DESIGN.md, +++ b/DESIGN.md, +++ b/checkstyle.xml, +++ b/DESIGN.md, +++ b/checkstyle.xml, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, +++ b/DESIGN.md, +++ b/checkstyle.xml, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, +++ b/src/main/java/io/reactivex/FlowableEmitter.java, +++ b/DESIGN.md, +++ b/checkstyle.xml, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, +++ b/src/main/java/io/reactivex/FlowableEmitter.java, +++ b/src/main/java/io/reactivex/MaybeEmitter.java, +++ b/DESIGN.md, +++ b/checkstyle.xml, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, +++ b/src/main/java/io/reactivex/FlowableEmitter.java, +++ b/src/main/java/io/reactivex/MaybeEmitter.java, +++ b/src/main/java/io/reactivex/ObservableSource.java, +++ b/DESIGN.md, +++ b/checkstyle.xml, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, +++ b/src/main/java/io/reactivex/FlowableEmitter.java, +++ b/src/main/java/io/reactivex/MaybeEmitter.java, +++ b/src/main/java/io/reactivex/ObservableSource.java, +++ b/src/main/java/io/reactivex/Observer.java, +++ b/DESIGN.md, +++ b/checkstyle.xml, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, +++ b/src/main/java/io/reactivex/FlowableEmitter.java, +++ b/src/main/java/io/reactivex/MaybeEmitter.java, +++ b/src/main/java/io/reactivex/ObservableSource.java, +++ b/src/main/java/io/reactivex/Observer.java, +++ b/src/main/java/io/reactivex/SingleEmitter.java, +++ b/DESIGN.md, +++ b/checkstyle.xml, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, +++ b/src/main/java/io/reactivex/FlowableEmitter.java, +++ b/src/main/java/io/reactivex/MaybeEmitter.java, +++ b/src/main/java/io/reactivex/ObservableSource.java, +++ b/src/main/java/io/reactivex/Observer.java, +++ b/src/main/java/io/reactivex/SingleEmitter.java, +++ b/src/main/java/io/reactivex/annotations/package-info.java, +++ b/DESIGN.md, +++ b/checkstyle.xml, +++ b/src/main/java/io/reactivex/CompletableEmitter.java, +++ b/src/main/java/io/reactivex/FlowableEmitter.java, +++
[+++ b/gradle.properties, +version=0.8.4]
[+++ b/src/main/java/io/reactivex/Observable.java, +import io.reactivex.internal.operators.mixed.*;, + return RxJavaPlugins.onAssembly(new ObservableConcatMapCompletable<T>(this, mapper, ErrorMode.IMMEDIATE, capacityHint));, + }, +, + /**, + * Maps the upstream items into {@link CompletableSource}s and subscribes to them one after the, + * other terminates, delaying all errors till both this {@code Observable} and all, + * inner {@code CompletableSource}s terminate., + * <p>, + * <img width="640" height="305" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatMap.png" alt="">, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code concatMapCompletableDelayError} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + * @param mapper the function called with the upstream item and should return,
[+++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, + implicit def scalaInnerToJavaInner(s: Inner): rx.Scheduler.Inner = s.asJavaInner, + implicit def javaInnerToScalaInner(s: rx.Scheduler.Inner): Inner = Inner(s), +, +, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, + implicit def scalaInnerToJavaInner(s: Inner): rx.Scheduler.Inner = s.asJavaInner, + implicit def javaInnerToScalaInner(s: rx.Scheduler.Inner): Inner = Inner(s), +, +, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Notification.scala, + Notification(rx.Notification.createOnNext[T](value)), + Notification(rx.Notification.createOnError[T](error)), + Notification(rx.Notification.createOnCompleted[T]()), +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Feb 05 12:05:54 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/JavaConversions.scala, + implicit def scalaInnerToJavaInner(s: Inner): rx.Scheduler.Inner = s.asJavaInner, + implicit def javaInnerToScalaInner(s: rx.Scheduler.Inner):
[+++ b/src/main/java/io/reactivex/Observable.java, + * Converts an arbitrary Reactive-Streams Publisher into an Observable., + * <dd>{@code fromPublisher} does not operate by default on a particular {@link Scheduler}.</dd>, + * @param publisher the Publisher to convert, + public static <T> Observable<T> fromPublisher(Publisher<? extends T> publisher) {]
[+++ b/src/test/java/io/reactivex/TestHelper.java, +, + /**, + * Number of times to loop a {@link #race(Runnable, Runnable)} invocation, + * by default., + */, + public static final int RACE_DEFAULT_LOOPS = 2500;, +, + /**, + * Number of times to loop a {@link #race(Runnable, Runnable)} invocation, + * in tests with race conditions requiring more runs to check., + */, + public static final int RACE_LONG_LOOPS = 10000;, +, + * @see #RACE_DEFAULT_LOOPS, + * @see #RACE_LONG_LOOPS, + * @see #RACE_DEFAULT_LOOPS, + * @see #RACE_LONG_LOOPS, +++ b/src/test/java/io/reactivex/TestHelper.java, +, + /**, + * Number of times to loop a {@link
[+++ b/src/main/java/io/reactivex/Completable.java, + * Returns a Completable that delays the subscription to the source CompletableSource by a given amount of time., + * <p>, + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>This version of {@code delaySubscription} operates by default on the {@code computation} {@link Scheduler}.</dd>, + * </dl>, + *, + * @param delay the time to delay the subscription, + * @param unit the time unit of {@code delay}, + * @return a Completable that delays the subscription to the source CompletableSource by the given amount, + * @since 2.2.3 - experimental, + * @see <a href="http://reactivex.io/documentation/operators/delay.html">ReactiveX
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java, + long r = requested.get();, + long e = 0L;, + boolean continueNextSource = false;, +, + continueNextSource = true;, + break;, + continueNextSource = true;, + requested.addAndGet(-e);, + }, +, + if (continueNextSource) {, + continue;, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java, + long r = requested.get();, + long e = 0L;, + boolean continueNextSource = false;, +, + continueNextSource = true;, + break;, + continueNextSource = true;, + requested.addAndGet(-e);, + }, +, + if (continueNextSource) {, + continue;, +++ b/src/main/java/io/reactivex/internal/subscribers/InnerQueuedSubscriber.java, + QueueDrainHelper.request(s, prefetch);, + QueueDrainHelper.request(s, prefetch);, + if (fusionMode != QueueSubscription.SYNC) {, + }, + if (fusionMode != QueueSubscription.SYNC)
[+++ b/src/main/java/io/reactivex/CompletableObserver.java, + * Provides a mechanism for receiving push-based notification of a valueless completion or an error., + * <p>, + * When a {@code CompletableObserver} is subscribed to a {@link CompletableSource} through the {@link CompletableSource#subscribe(CompletableObserver)} method,, + * the {@code CompletableSource} calls {@link #onSubscribe(Disposable)} with a {@link Disposable} that allows, + * disposing the sequence at any time. A well-behaved, + * {@code CompletableSource} will call a {@code CompletableObserver}'s {@link #onError(Throwable)}, + * or {@link #onComplete()} method exactly once as they are considered mutually exclusive <strong>terminal signals</strong>., + * <p>, + * Calling the {@code CompletableObserver}'s method
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/README.md, +## Documentation, +, +You can build the documentation as follows: In the RxJava root directory, run, +, + ./gradlew :language-adaptors:rxjava-scala:scaladoc, +, +Then navigate to, +, + RxJava/language-adaptors/rxjava-scala/build/docs/scaladoc/index.html, +, +, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/language-adaptors/rxjava-scala/README.md, +## Documentation, +, +You can build the documentation as follows: In the RxJava root directory, run, +, + ./gradlew :language-adaptors:rxjava-scala:scaladoc, +, +Then navigate to, +, + RxJava/language-adaptors/rxjava-scala/build/docs/scaladoc/index.html, +, +, +++ b/language-adaptors/rxjava-scala/build.gradle, + main { , + test { , + scala {
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java, +public final class FlowableBuffer<T, C extends Collection<? super T>> extends FlowableWithUpstream<T, C> {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java, +public final class FlowableBuffer<T, C extends Collection<? super T>> extends FlowableWithUpstream<T, C> {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java, +public final class FlowableConcatMap<T, R> extends FlowableWithUpstream<T, R> {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java, +public final class FlowableBuffer<T, C extends Collection<? super T>> extends FlowableWithUpstream<T, C> {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java, +public final class FlowableConcatMap<T, R> extends FlowableWithUpstream<T, R> {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMapEager.java, +public class FlowableConcatMapEager<T, R> extends FlowableWithUpstream<T, R> {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableBuffer.java, +public final class FlowableBuffer<T, C extends Collection<? super T>> extends FlowableWithUpstream<T, C> {, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java, +public final class FlowableConcatMap<T, R>
[+++ b/rxjava-contrib/rxjava-android-samples/build.gradle, + classpath 'com.android.tools.build:gradle:0.11.+', +++ b/rxjava-contrib/rxjava-android-samples/build.gradle, + classpath 'com.android.tools.build:gradle:0.11.+', +++ b/rxjava-contrib/rxjava-android-samples/gradle/wrapper/gradle-wrapper.properties, +#Sat Jun 07 16:12:40 CEST 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/rxjava-contrib/rxjava-android-samples/build.gradle, + classpath 'com.android.tools.build:gradle:0.11.+', +++ b/rxjava-contrib/rxjava-android-samples/gradle/wrapper/gradle-wrapper.properties, +#Sat Jun 07 16:12:40 CEST 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/rxjava-contrib/rxjava-android-samples/samples/build.gradle, + buildToolsVersion "19.1.0"]
[+++ b/src/main/java/io/reactivex/observers/TestObserver.java, + public final TestObserver<T> assertFailure(Class<? extends Throwable> error, T... values) {]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * <p>, + * Note that the {@link GroupedFlowable}s should be subscribed to as soon as possible, otherwise,, + * the unconsumed groups may starve other groups due to the internal backpressure, + * coordination of the {@code groupBy} operator. Such hangs can be usually avoided by using, + * {@link #flatMap(Function, int)} or {@link #concatMapEager(Function, int, int)} and overriding the default maximum concurrency, + * value to be greater or equal to the expected number of groups, possibly using, + * {@code Integer.MAX_VALUE} if the number of expected groups is unknown., + *, + *
[+++ b/.gitignore, +.m2, +target/, +build/, +bin/, +, +# Scala build, +*.cache, +++ b/.gitignore, +.m2, +target/, +build/, +bin/, +, +# Scala build, +*.cache, +++ b/CHANGES.md, +# RxJava Releases #, +, +### Version 0.6.1 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.6.1%22)) ###, +, +* [Pull 190](https://github.com/Netflix/RxJava/pull/190) Fix generics issue with materialize() that prevented chaining, +, +### Version 0.6.0 ([Maven Central](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.netflix.rxjava%22%20AND%20v%3A%220.6.0%22)) ###, +, +* [Issue 154](https://github.com/Netflix/RxJava/issues/154) Add OSGi manifest headers, +* [Issue 173](https://github.com/Netflix/RxJava/issues/173) Subscription Utilities and Default Implementations, +* [Pull 184](https://github.com/Netflix/RxJava/pull/184) Convert 'last' from non-blocking to blocking to match Rx.Net (see [Issue 57](https://github.com/Netflix/RxJava/issues/57)), +, +*NOTE:* This is a version bump from 0.5 to 0.6 because [Issue 173](https://github.com/Netflix/RxJava/issues/173)
[+++ b/.travis.yml, +, + , +, +# secure environment variables for release to Bintray, + - secure: "HzRt91B6CLkBCxRXlo7V+F5L8SSHSW8dgkO8nAlTnOIK73k3QelDeBlcm1wnuNa3x+54YS9WBv6QrTNZr9lVi/8IPfKpd+jtjIbCWRvh6aNhqLIXWTL7oTvUd4E8DDUAKB6UMae6SiBSy2wsFELGHXeNwg7EiPfxsd5sKRiS7H4=", + - secure: "MSZLPasqNKAC+8qhKQD3xO+ZbuOy65HpUN+1+KnoOLMkHCu/f4x60W1tpTAzn1DFEVpokHR0n3I4z4HpWybURDQfDHD1bB4IsznjCUBYA9Uo9Sb0U4TS17dQr8s7SORIjHDLGNSWETJjrA9TfuUV6HTVhRO1ECx3H+wuTwCVDN0=", + - secure: Joj/k9B4q1BttgP7rY1DFR9flURcvT2b4PFnxYwxljQuu6NHwz/3yLM1b711Kv9oAXlo1D/ZTXsCzle8tLs5yC3GakDCpapqZP4Gmen4zGLuHB851gejH134dJj4bEWigrSM6NJMzjbl7qmlMAc8R+DlLi/J7AxNicOrhOT5MGw=, + - secure: jxpzSkzSBnTqlAAY6r8QmX4b/Gf36NTshQ7xWQ8UWkWHHjm4GTnCoR71nXCIqhtZRgXvteR2AKYbraXU3ROGkZZXR4KkEwjhkf2FVr16bmUWbiqQrVvIdBPljcV9m3OevNEzCqd3QPod/Jma5s8WIDvuOv2z/cnpN/HQiHaRFEM=, +++ b/.travis.yml, +, + , +, +# secure environment variables for release to Bintray, + - secure: "HzRt91B6CLkBCxRXlo7V+F5L8SSHSW8dgkO8nAlTnOIK73k3QelDeBlcm1wnuNa3x+54YS9WBv6QrTNZr9lVi/8IPfKpd+jtjIbCWRvh6aNhqLIXWTL7oTvUd4E8DDUAKB6UMae6SiBSy2wsFELGHXeNwg7EiPfxsd5sKRiS7H4=", + - secure: "MSZLPasqNKAC+8qhKQD3xO+ZbuOy65HpUN+1+KnoOLMkHCu/f4x60W1tpTAzn1DFEVpokHR0n3I4z4HpWybURDQfDHD1bB4IsznjCUBYA9Uo9Sb0U4TS17dQr8s7SORIjHDLGNSWETJjrA9TfuUV6HTVhRO1ECx3H+wuTwCVDN0=", + - secure: Joj/k9B4q1BttgP7rY1DFR9flURcvT2b4PFnxYwxljQuu6NHwz/3yLM1b711Kv9oAXlo1D/ZTXsCzle8tLs5yC3GakDCpapqZP4Gmen4zGLuHB851gejH134dJj4bEWigrSM6NJMzjbl7qmlMAc8R+DlLi/J7AxNicOrhOT5MGw=, + - secure: jxpzSkzSBnTqlAAY6r8QmX4b/Gf36NTshQ7xWQ8UWkWHHjm4GTnCoR71nXCIqhtZRgXvteR2AKYbraXU3ROGkZZXR4KkEwjhkf2FVr16bmUWbiqQrVvIdBPljcV9m3OevNEzCqd3QPod/Jma5s8WIDvuOv2z/cnpN/HQiHaRFEM=, +++ b/src/main/java/rx/internal/operators/OperatorConcat.java, + ConcatInnerSubscriber<T> actualSubscriber = currentSubscriber;, + if (actualSubscriber == null && wip > 0) {, + if (actualSubscriber != null) {, + actualSubscriber.requestMore(n);]
[+++ b/src/main/java/io/reactivex/Completable.java, + return CompletableEmpty.INSTANCE;, + return CompletableNever.INSTANCE;, +++ b/src/main/java/io/reactivex/Completable.java, + return CompletableEmpty.INSTANCE;, + return CompletableNever.INSTANCE;, +++ b/src/main/java/io/reactivex/Flowable.java, + @SuppressWarnings("unchecked"), + return (Flowable<T>) FlowableEmpty.INSTANCE;, + return (Flowable<T>) FlowableNever.INSTANCE;, +++ b/src/main/java/io/reactivex/Completable.java, + return CompletableEmpty.INSTANCE;, + return CompletableNever.INSTANCE;, +++ b/src/main/java/io/reactivex/Flowable.java, + @SuppressWarnings("unchecked"), + return (Flowable<T>) FlowableEmpty.INSTANCE;, + return (Flowable<T>) FlowableNever.INSTANCE;, +++ b/src/main/java/io/reactivex/Single.java, + return (Single<T>) SingleNever.INSTANCE;, +++ b/src/main/java/io/reactivex/Completable.java, + return CompletableEmpty.INSTANCE;, + return CompletableNever.INSTANCE;, +++ b/src/main/java/io/reactivex/Flowable.java, + @SuppressWarnings("unchecked"), + return (Flowable<T>) FlowableEmpty.INSTANCE;, + return (Flowable<T>) FlowableNever.INSTANCE;, +++ b/src/main/java/io/reactivex/Single.java, + return (Single<T>) SingleNever.INSTANCE;, +++ b/src/main/java/io/reactivex/internal/operators/completable/CompletableEmpty.java, + public static final Completable INSTANCE = new CompletableEmpty();, +, + private CompletableEmpty() {, + }, +,
[+++ b/src/main/java/io/reactivex/processors/MulticastProcessor.java, +/**, + * Copyright (c) 2016-present, RxJava Contributors., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the specific language
[+++ b/src/main/java/io/reactivex/Flowable.java, + FlowableBlockingSubscribe.subscribe(this, onNext, Functions.ERROR_CONSUMER, Functions.EMPTY_ACTION);, + return forEachWhile(onNext, Functions.ERROR_CONSUMER, Functions.EMPTY_ACTION);, + return subscribe(Functions.emptyConsumer(), Functions.ERROR_CONSUMER,, + return subscribe(onNext, Functions.ERROR_CONSUMER,, +++ b/src/main/java/io/reactivex/Flowable.java, + FlowableBlockingSubscribe.subscribe(this, onNext, Functions.ERROR_CONSUMER, Functions.EMPTY_ACTION);, + return forEachWhile(onNext, Functions.ERROR_CONSUMER, Functions.EMPTY_ACTION);, + return subscribe(Functions.emptyConsumer(), Functions.ERROR_CONSUMER,, + return subscribe(onNext, Functions.ERROR_CONSUMER,, +++ b/src/main/java/io/reactivex/Observable.java, + ObservableBlockingSubscribe.subscribe(this, onNext, Functions.ERROR_CONSUMER, Functions.EMPTY_ACTION);, + return forEachWhile(onNext, Functions.ERROR_CONSUMER, Functions.EMPTY_ACTION);, + return subscribe(Functions.emptyConsumer(), Functions.ERROR_CONSUMER, Functions.EMPTY_ACTION, Functions.emptyConsumer());, + return subscribe(onNext, Functions.ERROR_CONSUMER, Functions.EMPTY_ACTION, Functions.emptyConsumer());, +++ b/src/main/java/io/reactivex/Flowable.java, + FlowableBlockingSubscribe.subscribe(this, onNext, Functions.ERROR_CONSUMER, Functions.EMPTY_ACTION);, + return forEachWhile(onNext, Functions.ERROR_CONSUMER, Functions.EMPTY_ACTION);, + return subscribe(Functions.emptyConsumer(), Functions.ERROR_CONSUMER,, + return subscribe(onNext, Functions.ERROR_CONSUMER,, +++ b/src/main/java/io/reactivex/Observable.java, + ObservableBlockingSubscribe.subscribe(this, onNext, Functions.ERROR_CONSUMER, Functions.EMPTY_ACTION);, + return forEachWhile(onNext, Functions.ERROR_CONSUMER, Functions.EMPTY_ACTION);, + return subscribe(Functions.emptyConsumer(),
[+++ b/gradle.properties, +version=0.17.0-RC4-SNAPSHOT, +++ b/gradle.properties, +version=0.17.0-RC4-SNAPSHOT, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/Olympics.scala, + duration(100 millis), // a short delay because medals are only awarded some time after the Games began, + val oneYear = 1000.millis, + //val neverUsedDummyMedal = Medal(3333, "?", "?", "?", "?", "?"), + /** runs an infinite loop, and returns Bottom type (Nothing) */, + def getNothing: Nothing = {, + println("You shouldn't have called this method ;-)"), + getNothing, + }, + , + /** returns an Observable which emits no elements and completes after a duration of d */, + def duration(d: Duration): Observable[Nothing] = Observable.interval(d).take(1).filter(_ => false).map(_
[+++ b/src/main/java/io/reactivex/disposables/Disposable.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed under the License is, + * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See, + * the License for the
[+++ b/src/main/java/io/reactivex/disposables/RunnableDisposable.java, + , + @Override, + public String toString() {, + return "RunnableDisposable(disposed=" + isDisposed() + ", " + get() + ")";, + }, +++ b/src/main/java/io/reactivex/disposables/RunnableDisposable.java, + , + @Override, + public String toString() {, + return "RunnableDisposable(disposed=" + isDisposed() + ", " + get() + ")";, + }, +++ b/src/main/java/io/reactivex/disposables/SerialDisposable.java, +import io.reactivex.internal.disposables.*;, +++ b/src/main/java/io/reactivex/disposables/RunnableDisposable.java, + , + @Override, + public String toString() {, + return "RunnableDisposable(disposed=" + isDisposed() + ", " + get() + ")";, + }, +++ b/src/main/java/io/reactivex/disposables/SerialDisposable.java, +import io.reactivex.internal.disposables.*;, +++ b/src/main/java/io/reactivex/internal/disposables/DisposableHelper.java, +public enum DisposableHelper implements Disposable {, + * The singleton instance representing a terminal,
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableDoOnEach.java, +import io.reactivex.internal.util.ExceptionHelper;, + T v;, +, + try {, + v = qs.poll();, + } catch (Throwable ex) {, + Exceptions.throwIfFatal(ex);, + try {, + onError.accept(ex);, + } catch (Throwable exc) {, + throw new CompositeException(ex, exc);, + }, + throw ExceptionHelper.<Exception>throwIfThrowable(ex);, + }, + try {, + } catch (Throwable ex) {, + Exceptions.throwIfFatal(ex);, + try {, + onError.accept(ex);, + } catch (Throwable exc) {, + throw new CompositeException(ex, exc);, + }, + throw ExceptionHelper.<Exception>throwIfThrowable(ex);, + }, + T v;, +, + try {, + v = qs.poll();, + } catch (Throwable ex) {, + Exceptions.throwIfFatal(ex);,
[+++ b/src/main/java/io/reactivex/Notification.java, +import io.reactivex.annotations.*;, + @Nullable, + @Nullable, + @NonNull, + public static <T> Notification<T> createOnNext(@NonNull T value) {, + @NonNull, + public static <T> Notification<T> createOnError(@NonNull Throwable error) {, + @NonNull, +++ b/src/main/java/io/reactivex/Notification.java, +import io.reactivex.annotations.*;, + @Nullable, + @Nullable, + @NonNull, + public static <T> Notification<T> createOnNext(@NonNull T value) {, + @NonNull, + public static <T> Notification<T> createOnError(@NonNull Throwable error) {, + @NonNull, +++ b/src/main/java/io/reactivex/Observer.java, +import io.reactivex.annotations.NonNull;, + void onSubscribe(@NonNull Disposable d);, + void onNext(@NonNull T t);, + void onError(@NonNull Throwable e);, +++ b/src/main/java/io/reactivex/Notification.java, +import io.reactivex.annotations.*;, + @Nullable, + @Nullable, + @NonNull, + public static <T> Notification<T> createOnNext(@NonNull
[+++ b/build.gradle, +++ b/build.gradle, +++ b/src/main/java/io/reactivex/Observable.java, +public class Observable {, +++ b/build.gradle, +++ b/src/main/java/io/reactivex/Observable.java, +public class Observable {, +++ /dev/null, +++ b/build.gradle, +++ b/src/main/java/io/reactivex/Observable.java, +public class Observable {, +++ /dev/null, +++ b/src/main/java/io/reactivex/internal/queue/BaseArrayQueue.java, +/**, + * Copyright 2015 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, + * , + * Unless required by applicable law or agreed to in writing, software distributed
[+++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/rxjava-core/build.gradle, + instruction 'Eclipse-ExtensibleAPI', 'true', +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/rxjava-core/build.gradle, + instruction 'Eclipse-ExtensibleAPI', 'true', +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationAmb;, + return create(OperationAmb.amb(sources));, + return create(OperationAmb.amb(o1, o2));, + return create(OperationAmb.amb(o1, o2, o3));, + return create(OperationAmb.amb(o1, o2, o3, o4));, + return create(OperationAmb.amb(o1, o2, o3, o4, o5));, + return create(OperationAmb.amb(o1, o2, o3, o4, o5, o6));, + return create(OperationAmb.amb(o1, o2, o3, o4, o5, o6, o7));, + return create(OperationAmb.amb(o1, o2, o3, o4, o5, o6, o7, o8));, + return create(OperationAmb.amb(o1, o2, o3, o4, o5, o6, o7, o8, o9));, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, +++ b/language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/Observable.scala, +++ b/rxjava-core/build.gradle,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorGroupByUntil;, +import rx.operators.OperatorGroupJoin;, +import rx.operators.OperatorToMap;, +import rx.operators.OperatorUsing;, + return create(new OperatorGroupJoin<T, T2, D1, D2, R>(this, right, leftDuration, rightDuration, resultSelector));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorGroupByUntil;, +import rx.operators.OperatorGroupJoin;, +import rx.operators.OperatorToMap;, +import rx.operators.OperatorUsing;, + return create(new OperatorGroupJoin<T, T2, D1, D2, R>(this, right, leftDuration, rightDuration, resultSelector));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorGroupByUntil;, +import rx.operators.OperatorGroupJoin;, +import rx.operators.OperatorToMap;, +import rx.operators.OperatorUsing;, + return create(new OperatorGroupJoin<T, T2, D1, D2, R>(this, right, leftDuration, rightDuration, resultSelector));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorGroupJoin.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use
[+++ b/gradle.properties, +version=0.13.1]
[+++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-bin.zip, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.8-bin.zip, +++ b/rxjava-core/src/main/java/rx/Observable.java, + * @param <T> the type of the item emitted by the Observable, + private final static ConcurrentHashMap<Class, Boolean> internalClassMap = new ConcurrentHashMap<Class, Boolean>();, + /**, + * Function interface for work to be performed when an {@link Observable}, + * is subscribed to via {@link Observable#subscribe(Observer)}, + * , + * @param <T>, + */, + public static interface OnSubscribeFunc<T> extends Function {, +, + public Subscription onSubscribe(Observer<? super T> t1);, +, + }, + * @param onSubscribe {@link OnSubscribeFunc} to be executed when, + * {@link #subscribe(Observer)} is called,
[+++ b/build.gradle, + perfCompile 'org.openjdk.jmh:jmh-core:1.13', + perfCompile 'org.openjdk.jmh:jmh-generator-annprocess:1.13', + exclude "**/internal/**", +++ b/build.gradle, + perfCompile 'org.openjdk.jmh:jmh-core:1.13', + perfCompile 'org.openjdk.jmh:jmh-generator-annprocess:1.13', + exclude "**/internal/**", +++ b/src/main/java/io/reactivex/BackpressureStrategy.java, +/**, + * Represents the options for applying backpressure to a source sequence., + */, + /**, + * Buffer all values (unbounded) until there is a downstream demand for it., + */, + /**, + * Drop the value if there is no current demand for it from the downstream., + */, + /**, + * Have a latest value always available and overwrite it with more recent ones, + * if there is
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationAll;, +import rx.operators.OperatorAny;, + return create(OperationAll.all(this, predicate));, + return lift(new OperatorAny<T>(predicate, false));, + return lift(new OperatorAny<T>(Functions.alwaysTrue(), true)); // create(OperatorAny.isEmpty(this));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationAll;, +import rx.operators.OperatorAny;, + return create(OperationAll.all(this, predicate));, + return lift(new OperatorAny<T>(predicate, false));, + return lift(new OperatorAny<T>(Functions.alwaysTrue(), true)); // create(OperatorAny.isEmpty(this));, +++ b/rxjava-core/src/main/java/rx/operators/OperationAll.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + * , + * http://www.apache.org/licenses/LICENSE-2.0, +
[+++ b/rxjava-core/src/main/java/rx/operators/OperationTakeWhile.java, +import rx.subjects.PublishSubject;, + PublishSubject<Integer> s = PublishSubject.create();, +++ b/rxjava-core/src/main/java/rx/operators/OperationTakeWhile.java, +import rx.subjects.PublishSubject;, + PublishSubject<Integer> s = PublishSubject.create();, +++ b/rxjava-core/src/main/java/rx/operators/OperatorMulticast.java, +import rx.subjects.PublishSubject;, + PublishSubject.<String>create());, + PublishSubject.<String>create());, + PublishSubject.<String>create());, +++ b/rxjava-core/src/main/java/rx/operators/OperationTakeWhile.java, +import rx.subjects.PublishSubject;, + PublishSubject<Integer> s = PublishSubject.create();, +++ b/rxjava-core/src/main/java/rx/operators/OperatorMulticast.java, +import rx.subjects.PublishSubject;, + PublishSubject.<String>create());, + PublishSubject.<String>create());, + PublishSubject.<String>create());, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperationTakeWhile.java, +import rx.subjects.PublishSubject;, + PublishSubject<Integer> s = PublishSubject.create();, +++ b/rxjava-core/src/main/java/rx/operators/OperatorMulticast.java, +import rx.subjects.PublishSubject;, + PublishSubject.<String>create());, + PublishSubject.<String>create());, + PublishSubject.<String>create());, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/subjects/PublishSubject.java, +/**, + * Copyright 2013 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use
[+++ b/src/main/java/io/reactivex/Single.java, + * <p>, + * <img width="640" height="291" src="https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doFinally.png" alt="">, + * </p>, + * <p>, + * <img width="640" height="347" src="https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSubscribe.png" alt="">, + * </p>, + * <p>, + * <img width="640" height="347" src="https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSuccess.2.png" alt="">, + * </p>, + * <p>, + * <img width="640" height="349" src="https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnError.2.png" alt="">, + * </p>, + * <p>, + * <img width="640" height="332" src="https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnDispose.png" alt="">, + * </p>]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Returns a {@link Future} representing the only value emitted by this {@code Flowable}., + * <p>, + * <img width="640" height="324" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/Flowable.toFuture.png" alt="">, + * {@link java.lang.IndexOutOfBoundsException}. If the {@link Flowable} is empty, {@link java.util.concurrent.Future}, + * will receive a {@link java.util.NoSuchElementException}. The {@code Flowable} source has to terminate in order, + * for the returned {@code Future} to terminate as well., +++ b/src/main/java/io/reactivex/Flowable.java, + * Returns a {@link Future} representing the only value emitted by this {@code Flowable}., + * <p>, + * <img width="640" height="324" src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/Flowable.toFuture.png" alt="">, + * {@link java.lang.IndexOutOfBoundsException}. If the
[+++ b/gradle.properties, +version=0.13.5]
[+++ b/src/main/java/io/reactivex/Flowable.java, + * If the Flowable emits an error, it is wrapped into an, + * {@link io.reactivex.exceptions.OnErrorNotImplementedException OnErrorNotImplementedException}, + * and routed to the RxJavaPlugins.onError handler., + * Using the overloads {@link #blockingSubscribe(Consumer, Consumer)}, + * or {@link #blockingSubscribe(Consumer, Consumer, Action)} instead is recommended., + * <p>, + * Note that calling this method will block the caller thread until the upstream terminates, + * normally or with an error. Therefore, calling this method from special threads such as the, + * Android Main Thread or the Swing Event Dispatch Thread is not recommended., + * <dl>,
[+++ b/CHANGES.md, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.6.1-SNAPSHOT, +++ b/CHANGES.md, +++ b/gradle.properties, +version=0.6.1-SNAPSHOT, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationTake;, +import rx.operators.OperationTakeWhile;, +import rx.operators.OperationWhere;, + private final boolean isTrusted;, + this(null, false);, + this(onSubscribe, false);, + }, +, + /**, + * @param onSubscribe, + * {@link Func1} to be executed when {@link #subscribe(Observer)} is called., + * @param isTrusted, + * boolean true if the <code>onSubscribe</code> function is guaranteed to conform to the correct contract and thus shortcuts can be taken., + */, + private Observable(Func1<Observer<T>, Subscription> onSubscribe, boolean isTrusted) {, + this.isTrusted = isTrusted;, + if (onSubscribe == null) {, +
[+++ b/.gitignore, +.gradletasknamecache, +++ b/.gitignore, +.gradletasknamecache, +++ b/language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/RxScalaDemo.scala, + @Test def ambExample(): Unit = {, + val o1 = List(100L, 200L, 300L).toObservable.delay(4 seconds), + val o2 = List(1000L, 2000L, 3000L).toObservable.delay(2 seconds), + val result = o1.amb(o2).toBlockingObservable.toList, + println(result), + }, +, + @Test def delayExample(): Unit = {, + val o = List(100L, 200L, 300L).toObservable.delay(2 seconds), + val result = o.toBlockingObservable.toList, + println(result), + }, +, + @Test def delayExample2(): Unit = {, + val o = List(100L, 200L, 300L).toObservable.delay(2 seconds, IOScheduler()), + val result = o.toBlockingObservable.toList, + println(result), + }, +, + @Test def delaySubscriptionExample(): Unit = {,
[+++ b/src/main/java/io/reactivex/Observable.java, + public final Observable<T> retry(BiPredicate<? super Integer, ? super Throwable> predicate) {, + Objects.requireNonNull(predicate);, + , + return create(new PublisherRetryBiPredicate<>(this, predicate));, + }, + , + public final Observable<T> retryWhen(, + Function<? super Observable<? extends Throwable>, ? extends Publisher<?>> handler) {, + handler.apply(no.takeWhile(Try::hasError).map(t -> {, + return t.error();, + })), + , + NullPointerException npe = new NullPointerException("Actually not, but can't throw other exceptions due to RS");, + npe.initCause(e);, + throw npe;, +++ b/src/main/java/io/reactivex/Observable.java, + public final Observable<T> retry(BiPredicate<? super Integer, ? super Throwable> predicate) {, + Objects.requireNonNull(predicate);, + , + return create(new PublisherRetryBiPredicate<>(this, predicate));, + },
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationParallelMerge;, + return OperationParallelMerge.parallelMerge(source, parallelObservables);, + return OperationParallelMerge.parallelMerge(source, parallelObservables, scheduler);, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationParallelMerge;, + return OperationParallelMerge.parallelMerge(source, parallelObservables);, + return OperationParallelMerge.parallelMerge(source, parallelObservables, scheduler);, +++ b/rxjava-core/src/main/java/rx/observables/ConnectableObservable.java, +import rx.operators.OperatorRefCount;, + * @return the subscription representing the connection, + return create(new OperatorRefCount<T>(this));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperationParallelMerge;, + return OperationParallelMerge.parallelMerge(source, parallelObservables);, + return OperationParallelMerge.parallelMerge(source, parallelObservables, scheduler);, +++ b/rxjava-core/src/main/java/rx/observables/ConnectableObservable.java, +import rx.operators.OperatorRefCount;, + * @return the subscription representing the connection, + return create(new OperatorRefCount<T>(this));, +++ b/rxjava-core/src/main/java/rx/operators/OperationParallelMerge.java, +/**, + * Copyright 2014 Netflix, Inc., + * , + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not
[+++ b/src/main/java/io/reactivex/Flowable.java, +import io.reactivex.internal.fuseable.*;, + public static <T> Flowable<T> concat(Iterable<? extends Publisher<? extends T>> sources) {, + return fromIterable(sources).concatMap((Function)Functions.identity());, + public static <T> Flowable<T> concat(Iterable<? extends Publisher<? extends T>> sources, int prefetch) {, + return fromIterable(sources).concatMap((Function)Functions.identity(), prefetch);, + public static <T> Flowable<T> concatArrayEager(Publisher<? extends T>... sources) {, + return concatArrayEager(bufferSize(), bufferSize(), sources);, + }, +, + @SuppressWarnings({ "rawtypes", "unchecked" }), + public static <T> Flowable<T> concatArrayEager(int maxConcurrency, int prefetch, Publisher<? extends T>... sources) {, + return new FlowableConcatMapEager(new FlowableFromArray(sources), Functions.identity(), maxConcurrency, prefetch, ErrorMode.IMMEDIATE);, + }, +, + public static <T> Flowable<T> concatEager(Publisher<? extends Publisher<? extends T>> sources) {, +
[+++ b/gradle.properties, +version=0.6.4-SNAPSHOT]
[+++ b/src/main/java/io/reactivex/Single.java, + * <p>, + * <img width="640" height="283" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.error.c.png" alt="">, + * <img width="640" height="283" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.error.png" alt="">, + * <img width="640" height="451" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.onErrorReturn.png" alt="">, + * <p>, + * <img width="640" height="451" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.onErrorReturnItem.png" alt="">, + * <img width="640" height="451" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.onErrorResumeNext.png" alt="">, + * <img width="640" height="451" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.onErrorResumeNext.f.png" alt="">]
[+++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java, + int m = f.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java, + int m = f.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java, + final AtomicReference<Subscription> upstream = new AtomicReference<Subscription>();, + SubscriptionHelper.cancel(upstream);, + if (SubscriptionHelper.setOnce(this.upstream, s)) {, + int m = qs.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, + upstream.get().cancel();, + upstream.get().request(1);, + upstream.get().cancel();, + upstream.get().request(d);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableConcatMap.java, + int m = f.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java, + final AtomicReference<Subscription> upstream = new AtomicReference<Subscription>();, + SubscriptionHelper.cancel(upstream);, + if (SubscriptionHelper.setOnce(this.upstream, s)) {, + int m = qs.requestFusion(QueueSubscription.ANY | QueueSubscription.BOUNDARY);, + upstream.get().cancel();, + upstream.get().request(1);, + upstream.get().cancel();, + upstream.get().request(d);, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableConcatMapTest.java, +import java.util.concurrent.TimeUnit;, +import org.junit.Test;, +import org.reactivestreams.Publisher;, +, +import
[+++ b/src/main/java/io/reactivex/Single.java, + * <p>, + * <img width="640" height="457" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.delay.png" alt="">, + * <p>, + * <img width="640" height="457" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.delay.e.png" alt="">, + * <p>, + * <img width="640" height="457" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.delay.s.png" alt="">, + * <p>, + * <img width="640" height="457" src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.delay.se.png" alt="">]
[+++ b/src/main/java/io/reactivex/plugins/RxJavaPlugins.java, + /* test. */static void unlock() {]
[+++ b/src/main/java/io/reactivex/Observable.java, +import io.reactivex.internal.operators.flowable.FlowableFromObservable;, +import io.reactivex.internal.operators.single.SingleFromObservable;, + Flowable<T> o = new FlowableFromObservable<T>(this);, + return new SingleFromObservable<T>(this);, +++ b/src/main/java/io/reactivex/Observable.java, +import io.reactivex.internal.operators.flowable.FlowableFromObservable;, +import io.reactivex.internal.operators.single.SingleFromObservable;, + Flowable<T> o = new FlowableFromObservable<T>(this);, + return new SingleFromObservable<T>(this);, +++ b/src/main/java/io/reactivex/internal/operators/flowable/FlowableFromObservable.java, +/**, + * Copyright 2016 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in, + * compliance with the License. You may obtain a copy of the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software distributed under
[+++ b/rxjava-contrib/rxjava-async-util/src/main/java/rx/util/async/Async.java, + * Copyright 2014 Netflix, Inc., +import rx.util.async.operators.OperatorDeferFuture;, +import rx.util.async.operators.OperatorForEachFuture;, +import rx.util.async.operators.OperatorFromFunctionals;, +import rx.util.async.operators.OperatorStartFuture;, + return OperatorStartFuture.startFuture(functionAsync);, + return OperatorStartFuture.startFuture(functionAsync, scheduler);, + return OperatorDeferFuture.deferFuture(observableFactoryAsync);, + return OperatorDeferFuture.deferFuture(observableFactoryAsync, scheduler);, + * @see #forEachFuture(rx.Observable, rx.functions.Action1, rx.Scheduler), + return OperatorForEachFuture.forEachFuture(source, onNext);, + * @see #forEachFuture(rx.Observable, rx.functions.Action1, rx.functions.Action1, rx.Scheduler), + return OperatorForEachFuture.forEachFuture(source, onNext, onError);, + * @see #forEachFuture(rx.Observable, rx.functions.Action1, rx.functions.Action1, rx.functions.Action0, rx.Scheduler), + return OperatorForEachFuture.forEachFuture(source, onNext, onError, onCompleted);, + FutureTask<Void> task = OperatorForEachFuture.forEachFuture(source, onNext);, + FutureTask<Void> task = OperatorForEachFuture.forEachFuture(source, onNext, onError);, + FutureTask<Void> task = OperatorForEachFuture.forEachFuture(source, onNext, onError, onCompleted);, + return Observable.create(OperatorFromFunctionals.fromAction(action, result)).subscribeOn(scheduler);, + return Observable.create(OperatorFromFunctionals.fromCallable(callable)).subscribeOn(scheduler);, + return Observable.create(OperatorFromFunctionals.fromRunnable(run, result)).subscribeOn(scheduler);, +++
[+++ b/src/main/java/io/reactivex/CompletableOperator.java, + * Interface to map/wrap a downstream observer to an upstream observer., +public interface CompletableOperator {, + /**, + * Applies a function to the child CompletableObserver and returns a new parent CompletableObserver., + * @param observer the child CompletableObservable instance, + * @return the parent CompletableObserver instance, + */, + CompletableObserver apply(CompletableObserver observer) throws Exception;, +++ b/src/main/java/io/reactivex/CompletableOperator.java, + * Interface to map/wrap a downstream observer to an upstream observer., +public interface CompletableOperator {, + /**, + * Applies a function to the child CompletableObserver and returns a new parent CompletableObserver., + * @param observer the child
[+++ b/src/main/java/io/reactivex/Flowable.java, + @SuppressWarnings({ "unchecked", "cast" }), + return fromFuture((Future<T>)future, timeout, unit).subscribeOn(scheduler);, + @SuppressWarnings({ "cast", "unchecked" }), + return fromFuture((Future<T>)future).subscribeOn(scheduler);, + @SuppressWarnings({ "rawtypes", "unchecked", "cast" }), + return fromPublisher(sources).toList().flatMapPublisher((Function)FlowableInternalHelper.<T, R>zipIterable(zipper));, +++ b/src/main/java/io/reactivex/Flowable.java, + @SuppressWarnings({ "unchecked", "cast" }), + return fromFuture((Future<T>)future, timeout, unit).subscribeOn(scheduler);, + @SuppressWarnings({ "cast", "unchecked" }), + return fromFuture((Future<T>)future).subscribeOn(scheduler);, + @SuppressWarnings({ "rawtypes", "unchecked", "cast" }), + return fromPublisher(sources).toList().flatMapPublisher((Function)FlowableInternalHelper.<T, R>zipIterable(zipper));, +++ b/src/test/java/io/reactivex/internal/operators/flowable/FlowableGroupByTest.java, + .groupBy(Functions.<Integer>identity(), true), + .flatMap(new Function<GroupedFlowable<Integer, Integer>, Flowable<Integer>>() {, + public Flowable<Integer> apply(GroupedFlowable<Integer, Integer> g) throws Exception {, + .groupBy(Functions.<Integer>identity(), Functions.<Integer>identity(), true), + .flatMap(new Function<GroupedFlowable<Integer, Integer>, Flowable<Integer>>() {, + public Flowable<Integer> apply(GroupedFlowable<Integer, Integer> g) throws Exception {,
[+++ b/gradle.properties, +version=0.17.0-RC5, +++ b/gradle.properties, +version=0.17.0-RC5, +++ b/language-adaptors/rxjava-clojure/README.md, +# Clojure Adaptor for RxJava, +, +This adaptor provides functions and macros to ease Clojure/RxJava interop. In particular, there are functions and macros for turning Clojure functions and code into RxJava `Func*` and `Action*` interfaces without the tedium of manually reifying the interfaces., +, +# Basic Usage, +, +## Requiring the interop namespace, +The first thing to do is to require the namespace:, +, +```clojure, +(ns my.namespace, + (:require [rx.lang.clojure.interop :as rx]), + (:import [rx Observable])), +```, +, +or, at the REPL:, +, +```clojure, +(require '[rx.lang.clojure.interop :as rx]), +```, +, +##
[+++ b/src/main/java/io/reactivex/Observable.java, + validateBufferSize(bufferSize);, + validateBufferSize(bufferSize);, + validateBufferSize(bufferSize);, + validateBufferSize(bufferSize);, + validateBufferSize(bufferSize);, + Objects.requireNonNull(biFunction);, + validateBufferSize(bufferSize);, + validateBufferSize(bufferSize);, + validateBufferSize(bufferSize);, + // the internal buffer holds pairs of (timestamp, value) so double the default buffer size, + int s = bufferSize << 1; , + return lift(new OperatorSkipLastTimed<>(time, unit, scheduler, s, delayError));, + validateBufferSize(bufferSize);, + validateBufferSize(bufferSize);, + validateBufferSize(bufferSize);, + return create(new PublisherSequenceEqual<>(p1, p2, isEqual, bufferSize));, + }, +, + public static <T, R> Observable<R> combineLatest(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner) {, + return combineLatest(sources, combiner, false, bufferSize());, + }, +, + public static <T,
[+++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorOnErrorResumeNextViaObservable;, + return lift(new OperatorOnErrorResumeNextViaObservable<T>(resumeSequence));, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorOnErrorResumeNextViaObservable;, + return lift(new OperatorOnErrorResumeNextViaObservable<T>(resumeSequence));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/Observable.java, +import rx.operators.OperatorOnErrorResumeNextViaObservable;, + return lift(new OperatorOnErrorResumeNextViaObservable<T>(resumeSequence));, +++ /dev/null, +++ b/rxjava-core/src/main/java/rx/operators/OperatorOnErrorResumeNextViaObservable.java, +/**, + * Copyright 2014 Netflix, Inc., + *, + * Licensed under the Apache License, Version 2.0 (the "License"); you may not, + * use this file except in compliance with the License. You may obtain a copy of, + * the License at, + *, + * http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under
[+++ b/src/main/java/io/reactivex/internal/observers/ToNotificationObserver.java, +import java.util.concurrent.atomic.AtomicReference;, +, +public final class ToNotificationObserver<T>, +extends AtomicReference<Disposable>, +implements Observer<T>, Disposable {, + private static final long serialVersionUID = -7420197867343208289L;, + final Consumer<? super Notification<Object>> consumer;, + DisposableHelper.setOnce(this, s);, + get().dispose();, + get().dispose();, +, + @Override, + public void dispose() {, + DisposableHelper.dispose(this);, + }, +, + @Override, + public boolean isDisposed() {, + return DisposableHelper.isDisposed(get());, + }, +++ b/src/main/java/io/reactivex/internal/observers/ToNotificationObserver.java, +import java.util.concurrent.atomic.AtomicReference;, +, +public final class ToNotificationObserver<T>, +extends AtomicReference<Disposable>, +implements Observer<T>, Disposable {, + private static final long serialVersionUID = -7420197867343208289L;, + final Consumer<? super Notification<Object>> consumer;, + DisposableHelper.setOnce(this, s);, + get().dispose();, + get().dispose();, +, +
[+++ b/gradle.properties, +version=0.13.2]
[+++ b/src/main/java/io/reactivex/Maybe.java, + * Waits in a blocking fashion until the current Maybe signals a success value (which is returned),, + * null if completed or an exception (which is propagated)., + * <dl>, + * <dt><b>Scheduler:</b></dt>, + * <dd>{@code blockingGet} does not operate by default on a particular {@link Scheduler}.</dd>, + * </dl>, + * @return the success value, + */, + public T blockingGet() {, + return MaybeAwait.get(this, null);, + }, + , + /**, + * Waits in a blocking fashion until the current Maybe signals a success value (which is returned),, + * defaultValue if
[+++ b/src/main/java/io/reactivex/Flowable.java, + * Returns a Maybe that emits the single item at a specified index in a sequence of emissions from, + * this Flowable or completes if this Flowable sequence has fewer elements than index., + * Returns a Flowable that emits the item found at a specified index in a sequence of emissions from, + * this Flowable, or a default item if that index is out of range., + * Returns a Flowable that emits the item found at a specified index in a sequence of emissions from, + * this Flowable or signals a
[+++ b/src/main/java/io/reactivex/observers/TestObserver.java, +import io.reactivex.functions.Predicate;, + * overload to test against the class of an error instead of an instance of an error, + * or {@link #assertError(Predicate)} to test with different condition., + * @see #assertError(Predicate), + * Asserts that this TestObserver received exactly one onError event for which, + * the provided predicate returns true., + * @param errorPredicate, + * the predicate that receives the error Throwable, + * and should return true for expected errors., + * @return this, + */, + public final TestObserver<T> assertError(Predicate<Throwable> errorPredicate) {, + int s = errors.size();, + if (s
[+++ b/gradle.properties, +version=0.10.2]
[+++ b/rxjava-contrib/rxjava-android-samples/gradle/wrapper/gradle-wrapper.properties, +#Wed Mar 12 12:09:46 CET 2014, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.10-all.zip]
