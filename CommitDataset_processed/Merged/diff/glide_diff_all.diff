[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ChildModuleProcessor.java, +package com.bumptech.glide.annotation.compiler;, +, +import com.bumptech.glide.annotation.GlideModule;, +import com.squareup.javapoet.TypeSpec;, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Set;, +import javax.annotation.processing.RoundEnvironment;, +import javax.lang.model.element.TypeElement;, +, +/**, + * Generates {@link ModuleIndex} annotated classes for all, + * {@link com.bumptech.glide.module.ChildGlideModule} implementations., + */, +final class ChildModuleProcessor {, +  private static final String COMPILER_PACKAGE_NAME =, +      GlideAnnotationProcessor.class.getPackage().getName();, +, +  private ProcessorUtil processorUtil;, +, +  ChildModuleProcessor(ProcessorUtil processorUtil) {, +    this.processorUtil = processorUtil;, +  }, +, +  boolean processModules(Set<? extends TypeElement> set, RoundEnvironment env) {, +     // Order matters here, if we find an Indexer below, we return before writing the root module., +    // If we fail to add to rootModules before then, we might accidentally skip a valid RootModule., +    List<TypeElement> childGlideModules = new ArrayList<>();, +    for (TypeElement element : processorUtil.getElementsFor(GlideModule.class, env)) {, +      // Root elements are added separately and must be checked separately because they're sub, +      // classes of ChildGlideModules., +      if (processorUtil.isRootGlideModule(element)) {, +        continue;, +      } else if (!processorUtil.isChildGlideModule(element)) {, +        throw new IllegalStateException("@GlideModule can only be applied to ChildGlideModule", +            + " and RootGlideModule implementations, not: " + element);, +      }, +, +      childGlideModules.add(element);, +    }, +, +    processorUtil.debugLog("got child modules: " + childGlideModules);, +    if (childGlideModules.isEmpty()) {, +      return false;, +    }, +, +    TypeSpec indexer = GlideIndexerGenerator.generate(childGlideModules);, +    writeIndexer(indexer);, +    processorUtil.debugLog("Wrote an Indexer this round, skipping the root module to ensure all ", +        + "indexers are found");, +     // If I write an Indexer in a round in the target package, then try to find all classes in, +    // the target package, my newly written Indexer won't be found. Since we wrote a class with, +    // an Annotation handled by this processor, we know we will be called again in the next round, +    // and we can safely wait to write our RootModule until then., +    return true;, +  }, +, +  private void writeIndexer(TypeSpec indexer) {, +    processorUtil.writeClass(COMPILER_PACKAGE_NAME, indexer);, +  }, +, +  Set<String> getSupportedAnnotationTypes() {, +    return new HashSet<>(Arrays.asList(, +        ModuleIndex.class.getName(),, +        GlideModule.class.getName(), +    ));, +  }, +}, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ChildModuleProcessor.java, +package com.bumptech.glide.annotation.compiler;, +, +import com.bumptech.glide.annotation.GlideModule;, +import com.squareup.javapoet.TypeSpec;, +import java.util.ArrayList;, +import java.util.Arrays;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Set;, +import javax.annotation.processing.RoundEnvironment;, +import javax.lang.model.element.TypeElement;, +, +/**, + * Generates {@link ModuleIndex} annotated classes for all, + * {@link com.bumptech.glide.module.ChildGlideModule} implementations., + */, +final class ChildModuleProcessor {, +  private static final String COMPILER_PACKAGE_NAME =, +      GlideAnnotationProcessor.class.getPackage().getName();, +, +  private ProcessorUtil processorUtil;, +, +  ChildModuleProcessor(ProcessorUtil processorUtil) {, +    this.processorUtil = processorUtil;, +  }, +, +  boolean processModules(Set<? extends TypeElement> set, RoundEnvironment env) {, +     // Order matters here, if we find an Indexer below, we return before writing the root module.]
[+++ b/library/findbugs-exclude.xml, +    <!-- DecodeJob tasks are ordered, but equivalent ordering does not imply equality -->, +    <Match>, +        <Class name="com.bumptech.glide.load.engine.DecodeJob" />, +        <Bug pattern="EQ_COMPARETO_USE_OBJECT_EQUALS" />, +    </Match>, +, +++ b/library/findbugs-exclude.xml, +    <!-- DecodeJob tasks are ordered, but equivalent ordering does not imply equality -->, +    <Match>, +        <Class name="com.bumptech.glide.load.engine.DecodeJob" />, +        <Bug pattern="EQ_COMPARETO_USE_OBJECT_EQUALS" />, +    </Match>, +, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.engine.executor.GlideExecutor;, +      GlideExecutor executor = mock(GlideExecutor.class);, +      doAnswer(new Answer<Void>() {, +        public Void answer(InvocationOnMock invocation) throws Throwable {, +          return null;, +      }).when(executor).execute(any(Runnable.class));, +          .setResizeExecutor(executor).setDiskCacheExecutor(executor);, +++ b/library/findbugs-exclude.xml, +    <!-- DecodeJob tasks are ordered, but equivalent ordering does not imply equality -->, +    <Match>, +        <Class name="com.bumptech.glide.load.engine.DecodeJob" />, +        <Bug pattern="EQ_COMPARETO_USE_OBJECT_EQUALS" />, +    </Match>, +, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.engine.executor.GlideExecutor;, +      GlideExecutor executor = mock(GlideExecutor.class);, +      doAnswer(new Answer<Void>() {, +        public Void answer(InvocationOnMock invocation) throws Throwable {, +          return null;, +      }).when(executor).execute(any(Runnable.class));, +          .setResizeExecutor(executor).setDiskCacheExecutor(executor);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineJobTest.java, +import android.support.v4.util.Pools;, +import com.bumptech.glide.load.engine.executor.GlideExecutor;, +  public void testDoesNotNotifyCancelledIfCompletes() {, +    job.start(harness.decodeJob);, +  public void testCancelsDecodeJobOnCancel() {, +  public void testSubmitsDecodeJobToSourceServiceOnSubmitForSource() {, +    verify(harness.sourceService).execute(eq(harness.decodeJob));, +  public void testSubmitsDecodeJobToDiskCacheServiceOnStart() {, +    verify(harness.diskCacheService).execute(eq(harness.decodeJob));, +    GlideExecutor diskCacheService = mock(GlideExecutor.class);, +    GlideExecutor sourceService = mock(GlideExecutor.class);, +    Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);, +      job = new EngineJob(diskCacheService, sourceService, listener, pool, factory), +          .init(key, isCacheable);, +    GlideExecutor diskCacheService = mock(GlideExecutor.class);, +    GlideExecutor sourceService = mock(GlideExecutor.class);, +    Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);, +      EngineJob result = new EngineJob(diskCacheService, sourceService, listener, pool, factory), +          .init(key, isCacheable);, +++ b/library/findbugs-exclude.xml, +    <!-- DecodeJob tasks are ordered, but equivalent ordering does not imply equality -->, +    <Match>, +        <Class name="com.bumptech.glide.load.engine.DecodeJob" />, +        <Bug pattern="EQ_COMPARETO_USE_OBJECT_EQUALS" />, +    </Match>, +, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.engine.executor.GlideExecutor;, +      GlideExecutor executor = mock(GlideExecutor.class);, +      doAnswer(new Answer<Void>() {, +        public Void answer(InvocationOnMock invocation) throws Throwable {, +          return null;, +      }).when(executor).execute(any(Runnable.class));, +          .setResizeExecutor(executor).setDiskCacheExecutor(executor);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineJobTest.java, +import android.support.v4.util.Pools;, +import com.bumptech.glide.load.engine.executor.GlideExecutor;, +  public void testDoesNotNotifyCancelledIfCompletes() {, +    job.start(harness.decodeJob);, +  public void testCancelsDecodeJobOnCancel() {, +  public void testSubmitsDecodeJobToSourceServiceOnSubmitForSource() {, +    verify(harness.sourceService).execute(eq(harness.decodeJob));, +  public void testSubmitsDecodeJobToDiskCacheServiceOnStart() {, +    verify(harness.diskCacheService).execute(eq(harness.decodeJob));, +    GlideExecutor diskCacheService = mock(GlideExecutor.class);, +    GlideExecutor sourceService = mock(GlideExecutor.class);, +    Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);, +      job = new EngineJob(diskCacheService, sourceService, listener, pool, factory), +          .init(key, isCacheable);, +    GlideExecutor diskCacheService = mock(GlideExecutor.class);, +    GlideExecutor sourceService = mock(GlideExecutor.class);, +    Pools.Pool<EngineJob<?>> pool = new Pools.SimplePool<>(1);, +      EngineJob result = new EngineJob(diskCacheService, sourceService, listener, pool, factory), +          .init(key, isCacheable);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +import com.bumptech.glide.load.engine.executor.GlideExecutor;, +      engine = new Engine(cache, mock(DiskCache.Factory.class), mock(GlideExecutor.class),, +          mock(GlideExecutor.class), jobs, keyFactory, activeResources, engineJobFactory,, +++ b/library/findbugs-exclude.xml, +    <!-- DecodeJob tasks are ordered, but equivalent ordering does not imply equality -->, +    <Match>, +        <Class name="com.bumptech.glide.load.engine.DecodeJob" />]
[+++ b/library/src/com/bumptech/glide/loader/bitmap/BaseBitmapLoadFactory.java, +        if ((imageModelLoader == null || imageDecoder == null), +                && (videoModelLoader == null || videoDecoder == null)) {, +            throw new IllegalArgumentException("You must provide at least a video model loader and a video decoder or" +, +                    "an image model loader and an image decoder");, +        }, +        if (transformationLoader == null) {, +            throw new IllegalArgumentException("You must provide a non null transformation loader");, +        }, +++ b/library/src/com/bumptech/glide/loader/bitmap/BaseBitmapLoadFactory.java, +        if ((imageModelLoader == null || imageDecoder == null), +                && (videoModelLoader == null || videoDecoder == null)) {, +            throw new IllegalArgumentException("You must provide at least a video model loader and a video decoder or" +, +                    "an image model loader and an image decoder");, +        }, +        if (transformationLoader == null) {, +            throw new IllegalArgumentException("You must provide a non null transformation loader");, +        }, +++ b/library/src/com/bumptech/glide/resize/BaseBitmapLoadTask.java, +++ b/library/src/com/bumptech/glide/loader/bitmap/BaseBitmapLoadFactory.java, +        if ((imageModelLoader == null || imageDecoder == null), +                && (videoModelLoader == null || videoDecoder == null)) {, +            throw new IllegalArgumentException("You must provide at least a video model loader and a video decoder or" +, +                    "an image model loader and an image decoder");, +        }, +        if (transformationLoader == null) {, +            throw new IllegalArgumentException("You must provide a non null transformation loader");, +        }, +++ b/library/src/com/bumptech/glide/resize/BaseBitmapLoadTask.java, +++ b/library/tests/AndroidManifest.xml, +  <instrumentation android:name="com.bumptech.glide.MockitoInstrumentationTestRunner", +++ b/library/src/com/bumptech/glide/loader/bitmap/BaseBitmapLoadFactory.java, +        if ((imageModelLoader == null || imageDecoder == null), +                && (videoModelLoader == null || videoDecoder == null)) {, +            throw new IllegalArgumentException("You must provide at least a video model loader and a video decoder or" +, +                    "an image model loader and an image decoder");, +        }, +        if (transformationLoader == null) {, +            throw new IllegalArgumentException("You must provide a non null transformation loader");, +        }, +++ b/library/src/com/bumptech/glide/resize/BaseBitmapLoadTask.java, +++ b/library/tests/AndroidManifest.xml, +  <instrumentation android:name="com.bumptech.glide.MockitoInstrumentationTestRunner", +++ b/library/tests/libs/dexmaker-1.0.jar, +++ b/library/src/com/bumptech/glide/loader/bitmap/BaseBitmapLoadFactory.java, +        if ((imageModelLoader == null || imageDecoder == null), +                && (videoModelLoader == null || videoDecoder == null)) {, +            throw new IllegalArgumentException("You must provide at least a video model loader and a video decoder or" +, +                    "an image model loader and an image decoder");, +        }, +        if (transformationLoader == null) {, +            throw new IllegalArgumentException("You must provide a non null transformation loader");, +        }, +++ b/library/src/com/bumptech/glide/resize/BaseBitmapLoadTask.java, +++ b/library/tests/AndroidManifest.xml, +  <instrumentation android:name="com.bumptech.glide.MockitoInstrumentationTestRunner", +++ b/library/tests/libs/dexmaker-1.0.jar, +++ b/library/tests/libs/dexmaker-mockito-1.0.jar, +++ b/library/src/com/bumptech/glide/loader/bitmap/BaseBitmapLoadFactory.java, +        if ((imageModelLoader == null || imageDecoder == null), +                && (videoModelLoader == null || videoDecoder == null)) {, +            throw new IllegalArgumentException("You must provide at least a video model loader and a video decoder or" +, +                    "an image model loader and an image decoder");, +        }, +        if (transformationLoader == null) {, +            throw new IllegalArgumentException("You must provide a non null transformation loader");, +        }, +++ b/library/src/com/bumptech/glide/resize/BaseBitmapLoadTask.java, +++ b/library/tests/AndroidManifest.xml, +  <instrumentation android:name="com.bumptech.glide.MockitoInstrumentationTestRunner", +++ b/library/tests/libs/dexmaker-1.0.jar, +++ b/library/tests/libs/dexmaker-mockito-1.0.jar, +++ b/library/tests/libs/mockito-all-1.9.5.jar, +++ b/library/src/com/bumptech/glide/loader/bitmap/BaseBitmapLoadFactory.java, +        if ((imageModelLoader == null || imageDecoder == null), +                && (videoModelLoader == null || videoDecoder == null)) {, +            throw new IllegalArgumentException("You must provide at least a video model loader and a video decoder or" +, +                    "an image model loader and an image decoder");, +        }, +        if (transformationLoader == null) {, +            throw new IllegalArgumentException("You must provide a non null transformation loader");, +        }, +++ b/library/src/com/bumptech/glide/resize/BaseBitmapLoadTask.java, +++ b/library/tests/AndroidManifest.xml, +  <instrumentation android:name="com.bumptech.glide.MockitoInstrumentationTestRunner", +++ b/library/tests/libs/dexmaker-1.0.jar, +++ b/library/tests/libs/dexmaker-mockito-1.0.jar, +++ b/library/tests/libs/mockito-all-1.9.5.jar, +++ b/library/tests/src/com/bumptech/glide/MockitoInstrumentationTestRunner.java, +package com.bumptech.glide;, +, +import android.os.Bundle;, +import android.test.InstrumentationTestRunner;, +, +public class MockitoInstrumentationTestRunner extends InstrumentationTestRunner {, +    @Override, +    public void onCreate(Bundle arguments) {, +        // See https://code.google.com/p/dexmaker/issues/detail?id=2., +        System.setProperty("dexmaker.dexcache", getTargetContext().getCacheDir().getPath());, +        super.onCreate(arguments);]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +import com.bumptech.glide.load.MultiTransformation;, +   * Applies the given {@link Transformation}s in the given order for, +   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},, +   * {@link android.graphics.drawable.BitmapDrawable}, and, +   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}), +   * and throws an exception if asked to transform an unknown type., +   * <p>, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *, +   * @param transformations One or more {@link Transformation}s for {@link Bitmap}s., +   * @see #optionalTransform(Transformation), +   * @see #optionalTransform(Class, Transformation), +   */, +  public RequestOptions transforms(@NonNull Transformation<Bitmap>... transformations) {, +    if (isAutoCloneEnabled) {, +      return clone().transforms(transformations);, +    }, +, +    optionalTransform(new MultiTransformation<>(transformations));, +    isTransformationRequired = true;, +    fields |= TRANSFORMATION_REQUIRED;, +    return selfOrThrowIfLocked();, +  }, +, +  /**, +++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +import com.bumptech.glide.load.MultiTransformation;, +   * Applies the given {@link Transformation}s in the given order for, +   * {@link Bitmap Bitmaps} to the default types ({@link Bitmap},, +   * {@link android.graphics.drawable.BitmapDrawable}, and, +   * {@link com.bumptech.glide.load.resource.gif.GifDrawable}), +   * and throws an exception if asked to transform an unknown type., +   * <p>, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *, +   * @param transformations One or more {@link Transformation}s for {@link Bitmap}s., +   * @see #optionalTransform(Transformation), +   * @see #optionalTransform(Class, Transformation), +   */, +  public RequestOptions transforms(@NonNull Transformation<Bitmap>... transformations) {, +    if (isAutoCloneEnabled) {, +      return clone().transforms(transformations);, +    }, +, +    optionalTransform(new MultiTransformation<>(transformations));, +    isTransformationRequired = true;, +    fields |= TRANSFORMATION_REQUIRED;, +    return selfOrThrowIfLocked();, +  }, +, +  /**, +++ b/library/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java, +, +import com.bumptech.glide.load.MultiTransformation;, +import com.bumptech.glide.load.resource.bitmap.CenterCrop;, +import com.bumptech.glide.load.resource.bitmap.CircleCrop;, +, +, +  @Test, +  public void testApplyMultiTransform() {, +    options.transforms(new CircleCrop(), new CenterCrop());, +    assertThat(options.isTransformationRequired()).isTrue();, +    assertThat(options.getTransformations()).containsKey(Bitmap.class);, +    assertThat(options.getTransformations().get(Bitmap.class)), +      .isInstanceOf(MultiTransformation.class);, +  }]
[+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java, +import java.lang.Override;, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;, +import java.lang.Override;, +import java.lang.SuppressWarnings;, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java, +import java.lang.Class;]
[+++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java, +  private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%;$";, +++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java, +  private static final String ALLOWED_URI_CHARS = "@#&=*+-_.,:!?()/~'%;$";, +++ b/library/src/test/java/com/bumptech/glide/load/model/GlideUrlTest.java, +import static com.google.common.truth.Truth.assertThat;, +  public void issue_2583() throws MalformedURLException {, +    String original =, +        "http://api.met.no/weatherapi/weathericon/1.1/?symbol=9;content_type=image/png";, +, +    GlideUrl glideUrl = new GlideUrl(original);, +    assertThat(glideUrl.toURL().toString()).isEqualTo(original);, +    assertThat(glideUrl.toStringUrl()).isEqualTo(original);, +  }, +, +  @Test]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.transcode.DrawableBytesTranscoder;, +    BitmapBytesTranscoder bitmapBytesTranscoder = new BitmapBytesTranscoder();, +    GifDrawableBytesTranscoder gifDrawableBytesTranscoder = new GifDrawableBytesTranscoder();, +, +        .register(Bitmap.class, byte[].class, bitmapBytesTranscoder), +        .register(, +            Drawable.class,, +            byte[].class,, +            new DrawableBytesTranscoder(, +                bitmapPool, bitmapBytesTranscoder, gifDrawableBytesTranscoder)), +        .register(GifDrawable.class, byte[].class, gifDrawableBytesTranscoder);, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.transcode.DrawableBytesTranscoder;, +    BitmapBytesTranscoder bitmapBytesTranscoder = new BitmapBytesTranscoder();, +    GifDrawableBytesTranscoder gifDrawableBytesTranscoder = new GifDrawableBytesTranscoder();, +, +        .register(Bitmap.class, byte[].class, bitmapBytesTranscoder), +        .register(, +            Drawable.class,, +            byte[].class,, +            new DrawableBytesTranscoder(, +                bitmapPool, bitmapBytesTranscoder, gifDrawableBytesTranscoder)), +        .register(GifDrawable.class, byte[].class, gifDrawableBytesTranscoder);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/DrawableBytesTranscoder.java, +package com.bumptech.glide.load.resource.transcode;, +, +, +import android.graphics.Bitmap;, +import android.graphics.drawable.BitmapDrawable;, +import android.graphics.drawable.Drawable;, +import android.support.annotation.Nullable;, +import com.bumptech.glide.load.Options;, +import com.bumptech.glide.load.engine.Resource;, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import com.bumptech.glide.load.resource.bitmap.BitmapResource;, +import com.bumptech.glide.load.resource.gif.GifDrawable;, +, +/**, + * Obtains {@code byte[]} from {@link BitmapDrawable}s by delegating to a, + * {@link ResourceTranscoder} for {@link Bitmap}s to {@code byte[]}s., + */, +public final class DrawableBytesTranscoder, +    implements ResourceTranscoder<Drawable, byte[]> {, +, +  private final BitmapPool bitmapPool;, +  private final ResourceTranscoder<Bitmap, byte[]> bitmapBytesTranscoder;, +  private final ResourceTranscoder<GifDrawable, byte[]> gifDrawableBytesTranscoder;, +, +  public DrawableBytesTranscoder(, +      BitmapPool bitmapPool,, +      ResourceTranscoder<Bitmap, byte[]> bitmapBytesTranscoder,, +      ResourceTranscoder<GifDrawable, byte[]> gifDrawableBytesTranscoder) {, +    this.bitmapPool = bitmapPool;, +    this.bitmapBytesTranscoder = bitmapBytesTranscoder;, +    this.gifDrawableBytesTranscoder = gifDrawableBytesTranscoder;, +  }, +, +  @Nullable, +  @Override, +  public Resource<byte[]> transcode(Resource<Drawable> toTranscode, Options options) {, +    Drawable drawable = toTranscode.get();, +    if (drawable instanceof BitmapDrawable) {, +      return bitmapBytesTranscoder.transcode(, +          BitmapResource.obtain(((BitmapDrawable) drawable).getBitmap(), bitmapPool), options);, +    } else if (drawable instanceof GifDrawable) {, +      return gifDrawableBytesTranscoder.transcode(toGifDrawableResource(toTranscode), options);, +    }, +    return null;, +  }, +, +  @SuppressWarnings("unchecked"), +  private static Resource<GifDrawable> toGifDrawableResource(Resource<Drawable> resource) {, +    return (Resource<GifDrawable>) (Resource<?>) resource;, +  }, +}]
[+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java, +import com.bumptech.glide.module.AppGlideModule;, +public class SvgModule extends AppGlideModule {]
[+++ b/README.md, +Download, +--------, +You can download a jar from GitHub's [release page](https://github.com/bumptech/glide/releases) or to use the 3.0 alpha branch, use Gradle:, +, +```groovy, +repositories {, +  mavenCentral(), +  maven {, +      url "https://oss.sonatype.org/content/repositories/snapshots", +  }, +}, +, +dependencies {, +  compile group: 'com.github.bumptech.glide', name:'glide', version:'3.3.0-SNAPSHOT', changing: true, +}, +```, +, +Or Maven:, +, +In your parent pom:, +, +```xml, +<parent>, +  <groupId>org.sonatype.oss</groupId>, +  <artifactId>oss-parent</artifactId>, +  <version>7</version>, +</parent>, +```, +, +In your module:, +, +```xml, +<dependency>, +  <groupId>com.github.bumptech.glide</groupId>, +  <artifactId>glide</artifactId>, +  <version>3.3.0-SNAPSHOT</version>, +  <type>aar</type>, +</dependency>, +```, +, +Checkout the GitHub wiki for pages on a variety of topics and links to javadocs., +    Glide.with(this).load("http://goo.gl/h8qOq7").into(imageView);, +    Glide.with(myFragment), +        .load(url), +Glide was used at Bump for around a year in two of our Android apps at version 1.0. Version 2.0 was the first public release with a stable api. Version 3.0 is a work in progress and is in use in open source projects at Google including in the Android Camera app and in the 2014 Google IO app. Comments/bugs/questions/pull requests welcome!, +git submodule init && git submodule update, +Thanks to the Android project and Jake Wharton for the [disk cache implementation](https://github.com/JakeWharton/DiskLruCache) included with Glide. Thanks also to the Android team for [Volley](https://android.googlesource.com/platform/frameworks/volley/). Thanks to Dave Smith for his [GifDecoder gist](https://gist.github.com/devunwired/4479231) on which Glide's is based. Thanks also to everyone who has contributed code and reported issues!, +++ b/README.md, +Download, +--------, +You can download a jar from GitHub's [release page](https://github.com/bumptech/glide/releases) or to use the 3.0 alpha branch, use Gradle:, +, +```groovy, +repositories {, +  mavenCentral(), +  maven {, +      url "https://oss.sonatype.org/content/repositories/snapshots", +  }, +}, +, +dependencies {, +  compile group: 'com.github.bumptech.glide', name:'glide', version:'3.3.0-SNAPSHOT', changing: true, +}, +```, +, +Or Maven:, +, +In your parent pom:, +, +```xml, +<parent>, +  <groupId>org.sonatype.oss</groupId>, +  <artifactId>oss-parent</artifactId>, +  <version>7</version>, +</parent>, +```, +, +In your module:, +, +```xml, +<dependency>, +  <groupId>com.github.bumptech.glide</groupId>, +  <artifactId>glide</artifactId>, +  <version>3.3.0-SNAPSHOT</version>, +  <type>aar</type>, +</dependency>, +```, +, +Checkout the GitHub wiki for pages on a variety of topics and links to javadocs., +    Glide.with(this).load("http://goo.gl/h8qOq7").into(imageView);, +    Glide.with(myFragment), +        .load(url), +Glide was used at Bump for around a year in two of our Android apps at version 1.0. Version 2.0 was the first public release with a stable api. Version 3.0 is a work in progress and is in use in open source projects at Google including in the Android Camera app and in the 2014 Google IO app. Comments/bugs/questions/pull requests welcome!, +git submodule init && git submodule update, +Thanks to the Android project and Jake Wharton for the [disk cache implementation](https://github.com/JakeWharton/DiskLruCache) included with Glide. Thanks also to the Android team for [Volley](https://android.googlesource.com/platform/frameworks/volley/). Thanks to Dave Smith for his [GifDecoder gist](https://gist.github.com/devunwired/4479231) on which Glide's is based. Thanks also to everyone who has contributed code and reported issues!, +++ b/gradle.properties, +VERSION_NAME=3.3.0-SNAPSHOT, +VERSION_CODE=5, +GROUP=com.github.bumptech.glide]
[+++ b/gradle.properties, +MIN_SDK_VERSION=14, +++ b/gradle.properties, +MIN_SDK_VERSION=14, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/gradle.properties, +MIN_SDK_VERSION=14, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +++ b/gradle.properties, +MIN_SDK_VERSION=14, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    maybeSetPreMultiplied(bitmap);, +++ b/gradle.properties, +MIN_SDK_VERSION=14, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    maybeSetPreMultiplied(bitmap);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java, +    // Explicitly check with an if statement, on some devices both parts of boolean expressions, +    // can be evaluated even if we'd normally expect a short circuit., +      return false;, +++ b/gradle.properties, +MIN_SDK_VERSION=14, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    maybeSetPreMultiplied(bitmap);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java, +    // Explicitly check with an if statement, on some devices both parts of boolean expressions, +    // can be evaluated even if we'd normally expect a short circuit., +      return false;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +import android.support.annotation.Nullable;, +    return getBitmapString(options.inBitmap);, +  @Nullable, +      return null;, +    }, +, +    return  "[" + bitmap.getWidth() + "x" + bitmap.getHeight() + "] " + bitmap.getConfig(), +++ b/gradle.properties, +MIN_SDK_VERSION=14, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    maybeSetPreMultiplied(bitmap);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java, +    // Explicitly check with an if statement, on some devices both parts of boolean expressions, +    // can be evaluated even if we'd normally expect a short circuit., +      return false;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +import android.support.annotation.Nullable;, +    return getBitmapString(options.inBitmap);, +  @Nullable, +      return null;, +    }, +, +    return  "[" + bitmap.getWidth() + "x" + bitmap.getHeight() + "] " + bitmap.getConfig(), +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java, +    outBitmap.setHasAlpha(inBitmap.hasAlpha());, +    result.setHasAlpha(true);, +    result.setHasAlpha(true);, +++ b/gradle.properties, +MIN_SDK_VERSION=14, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    maybeSetPreMultiplied(bitmap);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java, +    // Explicitly check with an if statement, on some devices both parts of boolean expressions, +    // can be evaluated even if we'd normally expect a short circuit., +      return false;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +import android.support.annotation.Nullable;, +    return getBitmapString(options.inBitmap);, +  @Nullable, +      return null;, +    }, +, +    return  "[" + bitmap.getWidth() + "x" + bitmap.getHeight() + "] " + bitmap.getConfig(), +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java, +    outBitmap.setHasAlpha(inBitmap.hasAlpha());, +    result.setHasAlpha(true);, +    result.setHasAlpha(true);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +    if (getCallback() == null) {, +++ b/gradle.properties, +MIN_SDK_VERSION=14, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    maybeSetPreMultiplied(bitmap);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java, +    // Explicitly check with an if statement, on some devices both parts of boolean expressions, +    // can be evaluated even if we'd normally expect a short circuit., +      return false;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/README.md, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/README.md, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }, +    }, +}, +, +subprojects {, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = 1.7, +        targetCompatibility = 1.7, +    }, +}, +, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java, +  // The version of this transformation, incremented to correct an error in a previous version., +  // See #455., +  private static final int VERSION = 1;, +  private static final String ID = "com.bumptech.glide.load.resource.bitmap.CircleCrop." + VERSION;]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java, +  private final Map<String, WriteLock> locks = new HashMap<>();, +  void acquire(String safeKey) {, +      writeLock = locks.get(safeKey);, +        locks.put(safeKey, writeLock);, +  void release(String safeKey) {, +      writeLock = Preconditions.checkNotNull(locks.get(safeKey));, +            + ", safeKey: " + safeKey, +        WriteLock removed = locks.remove(safeKey);, +              + ", safeKey: " + safeKey);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java, +  private final Map<String, WriteLock> locks = new HashMap<>();, +  void acquire(String safeKey) {, +      writeLock = locks.get(safeKey);, +        locks.put(safeKey, writeLock);, +  void release(String safeKey) {, +      writeLock = Preconditions.checkNotNull(locks.get(safeKey));, +            + ", safeKey: " + safeKey, +        WriteLock removed = locks.remove(safeKey);, +              + ", safeKey: " + safeKey);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java, +    writeLocker.acquire(safeKey);, +    try {, +      writeLocker.release(safeKey);]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +package com.bumptech.glide;, +, +import static org.mockito.ArgumentMatchers.any;, +import static org.mockito.ArgumentMatchers.anyBoolean;, +import static org.mockito.ArgumentMatchers.eq;, +import static org.mockito.Mockito.verify;, +, +import android.content.Context;, +import android.graphics.Bitmap;, +import android.graphics.drawable.Drawable;, +import android.os.Handler;, +import android.os.Looper;, +import android.support.test.InstrumentationRegistry;, +import android.support.test.runner.AndroidJUnit4;, +import com.bumptech.glide.load.DataSource;, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +import com.bumptech.glide.load.engine.cache.LruResourceCache;, +import com.bumptech.glide.request.FutureTarget;, +import com.bumptech.glide.request.RequestListener;, +import com.bumptech.glide.request.target.Target;, +import com.bumptech.glide.test.BitmapSubject;, +import com.bumptech.glide.test.GlideApp;, +import com.bumptech.glide.test.ResourceIds;, +import com.bumptech.glide.test.TearDownGlide;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.TimeoutException;, +import org.junit.Before;, +import org.junit.Rule;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +, +/**, + * Tests various aspects of memory and disk caching to verify resources can be retrieved as we, + * expect., + */, +@RunWith(AndroidJUnit4.class), +public class CachingTest {, +  private static final int IMAGE_SIZE_PIXELS = 500;, +  private static final long TIMEOUT_MS = 500;, +  // Store at least 10 500x500 pixel Bitmaps with the ARGB_8888 config to be safe., +  private static final long CACHE_SIZE_BYTES =, +      IMAGE_SIZE_PIXELS * IMAGE_SIZE_PIXELS * 4 * 10;, +, +  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();, +  @Mock private RequestListener<Drawable> requestListener;, +, +  private Context context;, +, +  @Before, +  public void setUp() throws InterruptedException {, +    MockitoAnnotations.initMocks(this);, +    context = InstrumentationRegistry.getTargetContext();, +, +    Glide.init(, +        context, new GlideBuilder().setMemoryCache(new LruResourceCache(CACHE_SIZE_BYTES)));, +  }, +, +  @Test, +  public void submit_withPreviousRequestClearedFromMemory_completesFromDataDiskCache(), +      throws InterruptedException, ExecutionException, TimeoutException {, +    FutureTarget<Drawable> future = GlideApp.with(context), +        .load(ResourceIds.raw.canonical), +        .diskCacheStrategy(DiskCacheStrategy.DATA), +        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);, +    future.get();, +    GlideApp.with(context).clear(future);, +, +    clearMemoryCacheOnMainThread();, +, +    GlideApp.with(context), +        .load(ResourceIds.raw.canonical), +        .diskCacheStrategy(DiskCacheStrategy.DATA), +        .listener(requestListener), +        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS), +        .get();, +, +    verify(requestListener), +        .onResourceReady(, +            any(Drawable.class),, +            any(),, +            anyTarget(),, +            eq(DataSource.DATA_DISK_CACHE),, +            anyBoolean());, +  }, +, +  @Test, +  public void submit_withPreviousButNoLongerReferencedIdenticalRequest_completesFromMemoryCache(), +      throws InterruptedException, TimeoutException, ExecutionException {, +    // We can't allow any mocks (RequestListner, Target etc) to reference this request or the test, +    // will fail due to the transient strong reference to the request., +    GlideApp.with(context), +        .load(ResourceIds.raw.canonical), +        .diskCacheStrategy(DiskCacheStrategy.RESOURCE), +        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS), +        .get(TIMEOUT_MS, TimeUnit.MILLISECONDS);]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +   * Disables the use of {@link android.graphics.Bitmap.Config#HARDWARE} in {@link Downsampler} to, +   * avoid errors caused by inspecting Bitmap pixels, drawing with hardware support disabled,, +   * drawing to {@link android.graphics.Canvas}s backed by {@link Bitmap}s etc., +   *, +   * <p>It's almost never safe to set {@link Downsampler#ALLOW_HARDWARE_CONFIG} to {@code true} so, +   * we only provide a way to disable hardware configs entirely. If no option is set for, +   * {@link Downsampler#ALLOW_HARDWARE_CONFIG}, Glide will set the value per request based on, +   * whether or not a {@link Transformation} is applied and if one is, the type of, +   * {@link Transformation} applied. Built in transformations like {@link FitCenter} and, +   * {@link com.bumptech.glide.load.resource.bitmap.DownsampleStrategy.CenterOutside} can safely use, +   * {@link android.graphics.Bitmap.Config#HARDWARE} because they can be entirely replaced by, +   * scaling within {@link Downsampler}. {@link Transformation}s like {@link #circleCrop()} that, +   * can't be replicated by {@link Downsampler} cannot use {@link Bitmap.Config#HARDWARE} because, +   * {@link android.graphics.Bitmap.Config#HARDWARE} cannot be drawn to, +   * {@link android.graphics.Canvas}s, which is required by most {@link Transformation}s., +   */, +  public RequestOptions disallowHardwareConfig() {, +    return set(Downsampler.ALLOW_HARDWARE_CONFIG, false);, +  }, +, +  /**]
[+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +   * @see #optionalCenterCrop()]
[+++ b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java, +  private final String notificationTag;, +    this(context, viewId, remoteViews, notification, notificationId, null);, +   * Constructor using a Notification object, a notificationId, and a notificationTag to get a, +   * handle on the Notification in order to update it that uses {@link #SIZE_ORIGINAL} as the, +   * target width and height., +   *, +   * @param context         Context to use in the AppWidgetManager initialization., +   * @param viewId          The id of the ImageView view that will load the image., +   * @param remoteViews     RemoteViews object which contains the ImageView that will load the, +   *                        bitmap., +   * @param notification    The Notification object that we want to update., +   * @param notificationId  The notificationId of the Notification that we want to load the Bitmap., +   * @param notificationTag The notificationTag of the Notification that we want to load the Bitmap., +   *                        May be {@code null}., +   */, +  public NotificationTarget(Context context, int viewId, RemoteViews remoteViews,, +      Notification notification, int notificationId, String notificationTag) {, +    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, notification, notificationId,, +      notificationTag);, +  }, +, +  /**, +   * Constructor using a Notification object, a notificationId, and a notificationTag to get a, +   * handle on the Notification in order to update it., +   * @param notificationTag The notificationTag of the Notification that we want to load the, +   *                        Bitmap. May be {@code null}., +  public NotificationTarget(Context context, int width, int height, int viewId,, +      RemoteViews remoteViews, Notification notification, int notificationId,, +      String notificationTag) {, +    this.notificationTag = notificationTag;, +    manager.notify(this.notificationTag, this.notificationId, this.notification);, +++ b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java, +  private final String notificationTag;, +    this(context, viewId, remoteViews, notification, notificationId, null);, +   * Constructor using a Notification object, a notificationId, and a notificationTag to get a, +   * handle on the Notification in order to update it that uses {@link #SIZE_ORIGINAL} as the, +   * target width and height., +   *, +   * @param context         Context to use in the AppWidgetManager initialization., +   * @param viewId          The id of the ImageView view that will load the image., +   * @param remoteViews     RemoteViews object which contains the ImageView that will load the, +   *                        bitmap., +   * @param notification    The Notification object that we want to update., +   * @param notificationId  The notificationId of the Notification that we want to load the Bitmap., +   * @param notificationTag The notificationTag of the Notification that we want to load the Bitmap., +   *                        May be {@code null}., +   */, +  public NotificationTarget(Context context, int viewId, RemoteViews remoteViews,, +      Notification notification, int notificationId, String notificationTag) {, +    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, notification, notificationId,, +      notificationTag);, +  }, +, +  /**, +   * Constructor using a Notification object, a notificationId, and a notificationTag to get a, +   * handle on the Notification in order to update it., +   * @param notificationTag The notificationTag of the Notification that we want to load the, +   *                        Bitmap. May be {@code null}., +  public NotificationTarget(Context context, int width, int height, int viewId,, +      RemoteViews remoteViews, Notification notification, int notificationId,, +      String notificationTag) {, +    this.notificationTag = notificationTag;, +    manager.notify(this.notificationTag, this.notificationId, this.notification);, +++ b/library/src/test/java/com/bumptech/glide/request/target/NotificationTargetTest.java, +  private String notificationTag;, +    notificationTag = "tag";, +            viewId, remoteViews, notification, notificationId, notificationTag);, +    assertEquals(notificationTag, shadowManager.updatedNotificationTag);, +        123 /*viewId*/, mock(RemoteViews.class), mock(Notification.class), 456 /*notificationId*/,, +        "tag" /*notificationTag*/);, +        123 /*viewId*/, mock(RemoteViews.class), null /*notification*/, 456 /*notificationId*/,, +        "tag" /*notificationTag*/);, +        123 /*viewId*/, null /*remoteViews*/, mock(Notification.class), 456 /*notificationId*/,, +        "tag" /*notificationTag*/);, +    String updatedNotificationTag;, +    public void notify(String notificationTag, int notificationId, Notification notification) {, +      updatedNotificationTag = notificationTag;]
[+++ b/.idea/codeStyleSettings.xml, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MAJOR=3, +VERSION_MINOR=6, +SUPPORT_V4_VERSION=19.1.0, +SUPPORT_V7_VERSION=19.1.0, +# TODO: Upgrade to latest version of Volley when we compile with Java 7., +VOLLEY_VERSION=1.0.8, +ANDROID_GRADLE_VERSION=1.0.0, +ROBOLECTRIC_GRADLE_VERSION=0.14.0, +ROBOLECTRIC_VERSION=2.4, +MOCKWEBSERVER_VERSION=1.6.0, +COMPILE_SDK_VERSION=19, +BUILD_TOOLS_VERSION=19.1.0, +TARGET_SDK_VERSION=19, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +        long contentLength = responseBody.contentLength();, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +        long contentLength = responseBody.contentLength();, +++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java, +import android.util.Log;, +    private static final String TAG = "HttpUrlFetcher";, +    private static final String ENCODING_HEADER = "Accept-Encoding";, +    private static final String DEFAULT_ENCODING = "identity";, +        // Do our best to avoid gzip since it's both inefficient for images and also makes it more, +        // difficult for us to detect and prevent partial content rendering. See #440., +        if (TextUtils.isEmpty(urlConnection.getRequestProperty(ENCODING_HEADER))) {, +            urlConnection.setRequestProperty(ENCODING_HEADER, DEFAULT_ENCODING);, +        }, +            return getStreamForSuccessfulRequest(urlConnection);, +    private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection), +            throws IOException {, +        if (TextUtils.isEmpty(urlConnection.getContentEncoding())) {, +            int contentLength = urlConnection.getContentLength();, +            stream = ContentLengthInputStream.obtain(urlConnection.getInputStream(), contentLength);, +        } else {, +            if (Log.isLoggable(TAG, Log.DEBUG)) {, +                Log.d(TAG, "Got non empty content encoding: " + urlConnection.getContentEncoding());, +            }, +            stream = urlConnection.getInputStream();, +        }, +        return stream;, +    }, +, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +        long contentLength = responseBody.contentLength();, +++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java, +import android.util.Log;, +    private static final String TAG = "HttpUrlFetcher";, +    private static final String ENCODING_HEADER = "Accept-Encoding";, +    private static final String DEFAULT_ENCODING = "identity";, +        // Do our best to avoid gzip since it's both inefficient for images and also makes it more, +        // difficult for us to detect and prevent partial content rendering. See #440., +        if (TextUtils.isEmpty(urlConnection.getRequestProperty(ENCODING_HEADER))) {, +            urlConnection.setRequestProperty(ENCODING_HEADER, DEFAULT_ENCODING);, +        }, +            return getStreamForSuccessfulRequest(urlConnection);, +    private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection), +            throws IOException {, +        if (TextUtils.isEmpty(urlConnection.getContentEncoding())) {, +            int contentLength = urlConnection.getContentLength();, +            stream = ContentLengthInputStream.obtain(urlConnection.getInputStream(), contentLength);, +        } else {, +            if (Log.isLoggable(TAG, Log.DEBUG)) {, +                Log.d(TAG, "Got non empty content encoding: " + urlConnection.getContentEncoding());, +            }, +            stream = urlConnection.getInputStream();, +        }, +        return stream;, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java, +  private final long contentLength;, +    return obtain(other, parseContentLength(contentLengthHeader));, +  }, +, +  public static InputStream obtain(InputStream other, long contentLength) {, +    return new ContentLengthInputStream(other, contentLength);, +  ContentLengthInputStream(InputStream in, long contentLength) {, +    return (int) Math.max(contentLength - readSoFar, in.available());]
[+++ b/build.gradle, +    gradleVersion = '4.1', +    distributionType = Wrapper.DistributionType.ALL, +, +++ b/build.gradle, +    gradleVersion = '4.1', +    distributionType = Wrapper.DistributionType.ALL, +, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, +    gradleVersion = '4.1', +    distributionType = Wrapper.DistributionType.ALL, +, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip, +++ b/build.gradle, +    gradleVersion = '4.1', +    distributionType = Wrapper.DistributionType.ALL, +, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip, +++ b/gradlew, +#!/usr/bin/env sh, +# Attempt to set APP_HOME, +# Resolve links: $0 may be a link, +PRG="$0", +# Need this for relative symlinks., +while [ -h "$PRG" ] ; do, +    ls=`ls -ld "$PRG"`, +    link=`expr "$ls" : '.*-> \(.*\)$'`, +    if expr "$link" : '/.*' > /dev/null; then, +        PRG="$link", +    else, +        PRG=`dirname "$PRG"`"/$link", +    fi, +done, +SAVED="`pwd`", +cd "`dirname \"$PRG\"`/" >/dev/null, +APP_HOME="`pwd -P`", +cd "$SAVED" >/dev/null, +# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script., +DEFAULT_JVM_OPTS="", +, +nonstop=false, +  NONSTOP* ), +    nonstop=true, +    ;;, +if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then, +# Escape application args, +save () {, +    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done, +    echo " ", +APP_ARGS=$(save "$@"), +# Collect all arguments for the java command, following the shell quoting and substitution rules, +eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS", +, +# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong, +if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then, +  cd "$(dirname "$0")", +fi, +, +exec "$JAVACMD" "$@", +++ b/build.gradle, +    gradleVersion = '4.1', +    distributionType = Wrapper.DistributionType.ALL, +, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip, +++ b/gradlew, +#!/usr/bin/env sh, +# Attempt to set APP_HOME, +# Resolve links: $0 may be a link, +PRG="$0", +# Need this for relative symlinks., +while [ -h "$PRG" ] ; do, +    ls=`ls -ld "$PRG"`, +    link=`expr "$ls" : '.*-> \(.*\)$'`, +    if expr "$link" : '/.*' > /dev/null; then, +        PRG="$link", +    else, +        PRG=`dirname "$PRG"`"/$link", +    fi, +done, +SAVED="`pwd`", +cd "`dirname \"$PRG\"`/" >/dev/null, +APP_HOME="`pwd -P`", +cd "$SAVED" >/dev/null, +# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script., +DEFAULT_JVM_OPTS="", +, +nonstop=false, +  NONSTOP* ), +    nonstop=true, +    ;;, +if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then, +# Escape application args, +save () {]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +        /*parentCoordinator=*/ null,]
[+++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="module" module-name="library" />, +++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="module" module-name="library" />, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +  public InputStream loadData(Priority priority) throws IOException {, +++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="module" module-name="library" />, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +  public InputStream loadData(Priority priority) throws IOException {, +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows =, +    VolleyStreamFetcherServerTest.FakeSystemClock.class), +  public void testReturnsNullIfRedirectLocationIsEmpty() throws Exception {, +    assertThat(getFetcher().loadData(Priority.NORMAL)).isNull();, +  public void testReturnsNullIfStatusCodeIsNegativeOne() throws Exception {, +    assertThat(getFetcher().loadData(Priority.LOW)).isNull();, +  public void testReturnsNullAfterTooManyRedirects() throws Exception {, +    assertThat(getFetcher().loadData(Priority.NORMAL)).isNull();, +  public void testReturnsNullIfStatusCodeIs500() throws Exception {, +    assertThat(getFetcher().loadData(Priority.NORMAL)).isNull();, +  public void testReturnsNullIfStatusCodeIs400() throws Exception {, +    assertThat(getFetcher().loadData(Priority.LOW)).isNull();, +++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="module" module-name="library" />, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +  public InputStream loadData(Priority priority) throws IOException {, +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows =, +    VolleyStreamFetcherServerTest.FakeSystemClock.class), +  public void testReturnsNullIfRedirectLocationIsEmpty() throws Exception {, +    assertThat(getFetcher().loadData(Priority.NORMAL)).isNull();, +  public void testReturnsNullIfStatusCodeIsNegativeOne() throws Exception {, +    assertThat(getFetcher().loadData(Priority.LOW)).isNull();, +  public void testReturnsNullAfterTooManyRedirects() throws Exception {, +    assertThat(getFetcher().loadData(Priority.NORMAL)).isNull();, +  public void testReturnsNullIfStatusCodeIs500() throws Exception {, +    assertThat(getFetcher().loadData(Priority.NORMAL)).isNull();, +  public void testReturnsNullIfStatusCodeIs400() throws Exception {, +    assertThat(getFetcher().loadData(Priority.LOW)).isNull();, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +import android.util.Log;, +, +import com.bumptech.glide.Logs;, +import java.io.IOException;, +import java.util.concurrent.ExecutionException;, +  public InputStream loadData(Priority priority) throws IOException {, +    try {, +    } catch (InterruptedException e) {, +      if (Logs.isEnabled(Log.VERBOSE)) {, +        Logs.log(Log.VERBOSE, "Interrupted waiting for Volley response", e);, +      }, +    } catch (ExecutionException e) {, +      if (Logs.isEnabled(Log.VERBOSE)) {, +        Logs.log(Log.VERBOSE, "ExecutionException waiting for Volley response", e);, +      }, +    }, +    return null;, +++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="module" module-name="library" />, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +  public InputStream loadData(Priority priority) throws IOException {, +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows =, +    VolleyStreamFetcherServerTest.FakeSystemClock.class), +  public void testReturnsNullIfRedirectLocationIsEmpty() throws Exception {, +    assertThat(getFetcher().loadData(Priority.NORMAL)).isNull();, +  public void testReturnsNullIfStatusCodeIsNegativeOne() throws Exception {, +    assertThat(getFetcher().loadData(Priority.LOW)).isNull();, +  public void testReturnsNullAfterTooManyRedirects() throws Exception {, +    assertThat(getFetcher().loadData(Priority.NORMAL)).isNull();, +  public void testReturnsNullIfStatusCodeIs500() throws Exception {, +    assertThat(getFetcher().loadData(Priority.NORMAL)).isNull();, +  public void testReturnsNullIfStatusCodeIs400() throws Exception {, +    assertThat(getFetcher().loadData(Priority.LOW)).isNull();, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +import android.util.Log;, +, +import com.bumptech.glide.Logs;, +import java.io.IOException;, +import java.util.concurrent.ExecutionException;, +  public InputStream loadData(Priority priority) throws IOException {, +    try {, +    } catch (InterruptedException e) {, +      if (Logs.isEnabled(Log.VERBOSE)) {, +        Logs.log(Log.VERBOSE, "Interrupted waiting for Volley response", e);, +      }, +    } catch (ExecutionException e) {, +      if (Logs.isEnabled(Log.VERBOSE)) {, +        Logs.log(Log.VERBOSE, "ExecutionException waiting for Volley response", e);, +      }, +    }, +    return null;, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +      public boolean onLoadFailed(Object model, Target target,, +    verify(target).onLoadFailed(eq(drawable));, +    verify(target).onLoadFailed(eq(error));, +++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="module" module-name="library" />, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }, +    }, +}, +, +subprojects {, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = 1.7, +        targetCompatibility = 1.7, +    }, +}, +, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java, +    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java, +    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java, +    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java, +    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java, +    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java, +    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {, +++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java, +import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;, +  public void testTrimMemoryUiHiddenOrLessRemovesHalfOfArrays() {, +    testTrimMemory(MAX_SIZE, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);, +  public void testTrimMemoryUiHiddenOrLessRemovesNoArraysIfPoolLessThanHalfFull() {, +    testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);, +  public void testTrimMemoryBackgroundOrGreaterRemovesAllArrays() {, +    for (int trimLevel : new int[] {TRIM_MEMORY_BACKGROUND, TRIM_MEMORY_COMPLETE}) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java, +    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java, +    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {, +++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java, +import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;, +  public void testTrimMemoryUiHiddenOrLessRemovesHalfOfArrays() {, +    testTrimMemory(MAX_SIZE, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);, +  public void testTrimMemoryUiHiddenOrLessRemovesNoArraysIfPoolLessThanHalfFull() {, +    testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);, +  public void testTrimMemoryBackgroundOrGreaterRemovesAllArrays() {, +    for (int trimLevel : new int[] {TRIM_MEMORY_BACKGROUND, TRIM_MEMORY_COMPLETE}) {, +++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;, +  public void testTrimMemoryUiHiddenOrLessRemovesHalfOfBitmaps() {, +    testTrimMemory(MAX_SIZE, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);, +  public void testTrimMemoryUiHiddenOrLessRemovesNoBitmapsIfPoolLessThanHalfFull() {, +    testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_UI_HIDDEN, 0);, +  public void testTrimMemoryBackgroundOrGreaterRemovesAllBitmaps() {, +    for (int trimLevel : new int[] { TRIM_MEMORY_BACKGROUND, TRIM_MEMORY_COMPLETE }) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java, +    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java, +    if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN) {, +++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java, +import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;, +  public void testTrimMemoryUiHiddenOrLessRemovesHalfOfArrays() {, +    testTrimMemory(MAX_SIZE, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);, +  public void testTrimMemoryUiHiddenOrLessRemovesNoArraysIfPoolLessThanHalfFull() {, +    testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);, +  public void testTrimMemoryBackgroundOrGreaterRemovesAllArrays() {, +    for (int trimLevel : new int[] {TRIM_MEMORY_BACKGROUND, TRIM_MEMORY_COMPLETE}) {, +++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;, +  public void testTrimMemoryUiHiddenOrLessRemovesHalfOfBitmaps() {, +    testTrimMemory(MAX_SIZE, TRIM_MEMORY_UI_HIDDEN, MAX_SIZE / 2);, +  public void testTrimMemoryUiHiddenOrLessRemovesNoBitmapsIfPoolLessThanHalfFull() {, +    testTrimMemory(MAX_SIZE / 2, TRIM_MEMORY_UI_HIDDEN, 0);, +  public void testTrimMemoryBackgroundOrGreaterRemovesAllBitmaps() {, +    for (int trimLevel : new int[] { TRIM_MEMORY_BACKGROUND, TRIM_MEMORY_COMPLETE }) {, +++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java, +  public void testTrimMemoryBackground() {, +    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);, +  public void testTrimMemoryModerate() {, +    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_MODERATE);, +  public void testTrimMemoryUiHidden() {, +    harness.resourceCache.trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);]
[+++ b/src/com/bumptech/photos/imagemanager/loader/Approximate.java, +public class Approximate<T> extends ImageManagerLoader<T> {, +++ b/src/com/bumptech/photos/imagemanager/loader/Approximate.java, +public class Approximate<T> extends ImageManagerLoader<T> {, +++ b/src/com/bumptech/photos/imagemanager/loader/AsIs.java, +public class AsIs<T> extends ImageManagerLoader<T> {, +++ b/src/com/bumptech/photos/imagemanager/loader/Approximate.java, +public class Approximate<T> extends ImageManagerLoader<T> {, +++ b/src/com/bumptech/photos/imagemanager/loader/AsIs.java, +public class AsIs<T> extends ImageManagerLoader<T> {, +++ b/src/com/bumptech/photos/imagemanager/loader/CenterCrop.java, +public class CenterCrop<T> extends ImageManagerLoader<T> {, +++ b/src/com/bumptech/photos/imagemanager/loader/Approximate.java, +public class Approximate<T> extends ImageManagerLoader<T> {, +++ b/src/com/bumptech/photos/imagemanager/loader/AsIs.java, +public class AsIs<T> extends ImageManagerLoader<T> {, +++ b/src/com/bumptech/photos/imagemanager/loader/CenterCrop.java, +public class CenterCrop<T> extends ImageManagerLoader<T> {, +++ b/src/com/bumptech/photos/imagemanager/loader/Exact.java, +public class Exact<T> extends ImageManagerLoader<T> {, +++ b/src/com/bumptech/photos/imagemanager/loader/Approximate.java, +public class Approximate<T> extends ImageManagerLoader<T> {, +++ b/src/com/bumptech/photos/imagemanager/loader/AsIs.java, +public class AsIs<T> extends ImageManagerLoader<T> {, +++ b/src/com/bumptech/photos/imagemanager/loader/CenterCrop.java, +public class CenterCrop<T> extends ImageManagerLoader<T> {, +++ b/src/com/bumptech/photos/imagemanager/loader/Exact.java, +public class Exact<T> extends ImageManagerLoader<T> {, +++ b/src/com/bumptech/photos/imagemanager/loader/FitCenter.java, +public class FitCenter<T> extends ImageManagerLoader<T> {, +++ b/src/com/bumptech/photos/imagemanager/loader/Approximate.java, +public class Approximate<T> extends ImageManagerLoader<T> {, +++ b/src/com/bumptech/photos/imagemanager/loader/AsIs.java, +public class AsIs<T> extends ImageManagerLoader<T> {, +++ b/src/com/bumptech/photos/imagemanager/loader/CenterCrop.java, +public class CenterCrop<T> extends ImageManagerLoader<T> {, +++ b/src/com/bumptech/photos/imagemanager/loader/Exact.java, +public class Exact<T> extends ImageManagerLoader<T> {, +++ b/src/com/bumptech/photos/imagemanager/loader/FitCenter.java, +public class FitCenter<T> extends ImageManagerLoader<T> {, +++ b/src/com/bumptech/photos/imagemanager/loader/ImageManagerLoader.java, +package com.bumptech.photos.imagemanager.loader;, +, +import android.graphics.Bitmap;, +import com.bumptech.photos.imagemanager.ImageManager;, +import com.bumptech.photos.loader.image.BaseImageLoader;, +, +/**, + * Created with IntelliJ IDEA., + * User: sam, + * Date: 1/1/13, + * Time: 2:51 PM, + * To change this template use File | Settings | File Templates., + */, +public abstract class ImageManagerLoader<T> extends BaseImageLoader<T> {, +, +    protected final ImageManager imageManager;, +    private Bitmap acquired;, +    private Object loadToken;, +, +    public ImageManagerLoader(ImageManager imageManager) {, +        this.imageManager = imageManager;, +    }, +    @Override, +    protected final void doFetchImage(String path, T model, int width, int height, ImageReadyCallback cb) {, +        releaseAcquired();, +        loadToken = doFetchImage(path, width, height, cb);, +    }, +, +    protected abstract Object doFetchImage(String path, int width, int height, ImageReadyCallback cb);, +, +    @Override, +    protected void onImageReady(Bitmap image, boolean isUsed) {, +        if (isUsed) {, +            releaseAcquired();, +            imageManager.acquireBitmap(image);, +            acquired = image;, +        } else {, +            imageManager.rejectBitmap(image);, +        }, +    }, +, +    @Override, +    public void clear() {, +        releaseAcquired();, +    }, +, +    private void releaseAcquired() {, +        if (acquired != null) {, +            imageManager.releaseBitmap(acquired);, +            acquired = null;, +        }, +    }, +, +}, +++ b/src/com/bumptech/photos/imagemanager/loader/Approximate.java, +public class Approximate<T> extends ImageManagerLoader<T> {, +++ b/src/com/bumptech/photos/imagemanager/loader/AsIs.java, +public class AsIs<T> extends ImageManagerLoader<T> {, +++ b/src/com/bumptech/photos/imagemanager/loader/CenterCrop.java]
[+++ b/.idea/codeStyleSettings.xml, +    <option name="PREFERRED_PROJECT_CODE_STYLE" value="GoogleStyle" />, +++ b/.idea/codeStyleSettings.xml, +    <option name="PREFERRED_PROJECT_CODE_STYLE" value="GoogleStyle" />, +++ b/annotation/.gitignore, +/build, +++ b/.idea/codeStyleSettings.xml, +    <option name="PREFERRED_PROJECT_CODE_STYLE" value="GoogleStyle" />, +++ b/annotation/.gitignore, +/build, +++ b/annotation/build.gradle, +apply plugin: 'java', +, +apply from: "${rootProject.projectDir}/scripts/upload.gradle", +++ b/.idea/codeStyleSettings.xml, +    <option name="PREFERRED_PROJECT_CODE_STYLE" value="GoogleStyle" />, +++ b/annotation/.gitignore, +/build, +++ b/annotation/build.gradle, +apply plugin: 'java', +, +apply from: "${rootProject.projectDir}/scripts/upload.gradle", +++ b/annotation/compiler/.gitignore, +/build, +++ b/.idea/codeStyleSettings.xml, +    <option name="PREFERRED_PROJECT_CODE_STYLE" value="GoogleStyle" />, +++ b/annotation/.gitignore, +/build, +++ b/annotation/build.gradle, +apply plugin: 'java', +, +apply from: "${rootProject.projectDir}/scripts/upload.gradle", +++ b/annotation/compiler/.gitignore, +/build, +++ b/annotation/compiler/build.gradle, +import org.gradle.internal.jvm.Jvm, +, +apply plugin: 'java', +, +dependencies {, +    compile 'com.squareup:javapoet:1.8.0', +    compile 'com.google.auto.service:auto-service:1.0-rc3', +    compile project(':annotation'), +    // This is to support com.sun.tootls.javac.util.List, currently used in RootModuleGenerator., +    compile files(Jvm.current().getToolsJar()), +, +    testCompile "junit:junit:${JUNIT_VERSION}", +    testCompile 'com.google.testing.compile:compile-testing:0.10', +}, +, +apply from: "${rootProject.projectDir}/scripts/upload.gradle", +++ b/.idea/codeStyleSettings.xml, +    <option name="PREFERRED_PROJECT_CODE_STYLE" value="GoogleStyle" />, +++ b/annotation/.gitignore, +/build, +++ b/annotation/build.gradle, +apply plugin: 'java', +, +apply from: "${rootProject.projectDir}/scripts/upload.gradle", +++ b/annotation/compiler/.gitignore, +/build, +++ b/annotation/compiler/build.gradle, +import org.gradle.internal.jvm.Jvm, +, +apply plugin: 'java', +, +dependencies {, +    compile 'com.squareup:javapoet:1.8.0', +    compile 'com.google.auto.service:auto-service:1.0-rc3', +    compile project(':annotation'), +    // This is to support com.sun.tootls.javac.util.List, currently used in RootModuleGenerator., +    compile files(Jvm.current().getToolsJar()), +, +    testCompile "junit:junit:${JUNIT_VERSION}", +    testCompile 'com.google.testing.compile:compile-testing:0.10', +}, +, +apply from: "${rootProject.projectDir}/scripts/upload.gradle", +++ b/annotation/compiler/gradle.properties, +POM_NAME=Glide Annotation processor, +POM_ARTIFACT_ID=compiler, +POM_PACKAGING=jar, +, +VERSION_NAME=1.0.0-SNAPSHOT, +VERSION_MAJOR=1, +VERSION_MINOR=0, +VERSION_PATCH=0, +, +POM_DESCRIPTION=Glide's anntation processor. Should be included in all Applications and in all libraries that use Glide's modules for configuration., +++ b/.idea/codeStyleSettings.xml, +    <option name="PREFERRED_PROJECT_CODE_STYLE" value="GoogleStyle" />, +++ b/annotation/.gitignore, +/build, +++ b/annotation/build.gradle, +apply plugin: 'java', +, +apply from: "${rootProject.projectDir}/scripts/upload.gradle", +++ b/annotation/compiler/.gitignore, +/build, +++ b/annotation/compiler/build.gradle]
[+++ b/library/build.gradle, +, +        consumerProguardFiles 'proguard-rules.txt', +++ b/library/build.gradle, +, +        consumerProguardFiles 'proguard-rules.txt', +++ b/library/proguard-rules.txt, +-keep public class * implements com.bumptech.glide.module.GlideModule, +-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {, +    **[] $VALUES;, +    public *;, +}]
[+++ b/.travis.yml, +      # TODO(#2738): Re-enable these when we find a fix., +      #    - COMPONENT=instrumentation ANDROID_TARGET=16, +      #    - COMPONENT=instrumentation ANDROID_TARGET=17, +      #    - COMPONENT=instrumentation ANDROID_TARGET=18]
[+++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MINOR=6, +VERSION_PATCH=0, +VERSION_CODE=12, +++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MINOR=6, +VERSION_PATCH=0, +VERSION_CODE=12, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.3.0-SNAPSHOT, +AERSION_MINOR=3, +VERSION_PATCH=0, +VERSION_CODE=8, +++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MINOR=6, +VERSION_PATCH=0, +VERSION_CODE=12, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.3.0-SNAPSHOT, +AERSION_MINOR=3, +VERSION_PATCH=0, +VERSION_CODE=8, +++ b/integration/volley/gradle.properties, +VERSION_NAME=1.3.0-SNAPSHOT, +VERSION_MINOR=3, +VERSION_PATCH=0, +VERSION_CODE=8]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java, +        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build()), +        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build()), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java, +        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build()), +        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build()), +++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java, +  @CheckResult, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java, +        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build()), +        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build()), +++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java, +  @CheckResult, +++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideRequests.java, +  @CheckResult]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +     * Returns a {@link android.graphics.Bitmap} of exactly the given width, height, and configuration, and containing, +     * only transparent pixels or null if no such {@link android.graphics.Bitmap} could be obtained from the pool., +     *, +     * <p>, +     *     Because this method erases all pixels in the {@link Bitmap}, this method is slightly slower than, +     *     {@link #getDirty(int, int, android.graphics.Bitmap.Config)}. If the {@link android.graphics.Bitmap} is being, +     *     obtained to be used in {@link android.graphics.BitmapFactory} or in any other case where every pixel in the, +     *     {@link android.graphics.Bitmap} will always be overwritten or cleared,, +     *     {@link #getDirty(int, int, android.graphics.Bitmap.Config)} will be faster. When in doubt, use this method, +     *     to ensure correctness., +     * </p>, +     *, +     * <pre>, +     *     Implementations can should clear out every returned Bitmap using the following:, +     *, +     * {@code, +     * bitmap.eraseColor(Color.TRANSPARENT);, +     * }, +     * </pre>, +     *, +     * @see #getDirty(int, int, android.graphics.Bitmap.Config), +     * Identical to {@link #get(int, int, android.graphics.Bitmap.Config)} except that any returned non-null, +     * {@link android.graphics.Bitmap} may <em>not</em> have been erased and may contain random data., +     *, +     * <p>, +     *     Although this method is slightly more efficient than {@link #get(int, int, android.graphics.Bitmap.Config)}, +     *     it should be used with caution and only when the caller is sure that they are going to erase the, +     *     {@link android.graphics.Bitmap} entirely before writing new data to it., +     * </p>, +     *, +     * @see #get(int, int, android.graphics.Bitmap.Config), +     *, +     * @param width The width of the desired {@link android.graphics.Bitmap}., +     * @param height The height of the desired {@link android.graphics.Bitmap}., +     * @param config The {@link android.graphics.Bitmap.Config} of the desired {@link android.graphics.Bitmap}., +     * @return A {@link android.graphics.Bitmap} with exactly the given width, height, and config potentially containing, +     * random image data or null if no such {@link android.graphics.Bitmap} could be obtained from the pool., +     */, +    public Bitmap getDirty(int width, int height, Bitmap.Config config);, +, +    /**, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +     * Returns a {@link android.graphics.Bitmap} of exactly the given width, height, and configuration, and containing, +     * only transparent pixels or null if no such {@link android.graphics.Bitmap} could be obtained from the pool., +     *, +     * <p>, +     *     Because this method erases all pixels in the {@link Bitmap}, this method is slightly slower than, +     *     {@link #getDirty(int, int, android.graphics.Bitmap.Config)}. If the {@link android.graphics.Bitmap} is being, +     *     obtained to be used in {@link android.graphics.BitmapFactory} or in any other case where every pixel in the, +     *     {@link android.graphics.Bitmap} will always be overwritten or cleared,, +     *     {@link #getDirty(int, int, android.graphics.Bitmap.Config)} will be faster. When in doubt, use this method, +     *     to ensure correctness., +     * </p>, +     *, +     * <pre>, +     *     Implementations can should clear out every returned Bitmap using the following:, +     *, +     * {@code, +     * bitmap.eraseColor(Color.TRANSPARENT);, +     * }, +     * </pre>, +     *, +     * @see #getDirty(int, int, android.graphics.Bitmap.Config), +     * Identical to {@link #get(int, int, android.graphics.Bitmap.Config)} except that any returned non-null, +     * {@link android.graphics.Bitmap} may <em>not</em> have been erased and may contain random data., +     *, +     * <p>, +     *     Although this method is slightly more efficient than {@link #get(int, int, android.graphics.Bitmap.Config)}, +     *     it should be used with caution and only when the caller is sure that they are going to erase the, +     *     {@link android.graphics.Bitmap} entirely before writing new data to it., +     * </p>, +     *, +     * @see #get(int, int, android.graphics.Bitmap.Config), +     *, +     * @param width The width of the desired {@link android.graphics.Bitmap}., +     * @param height The height of the desired {@link android.graphics.Bitmap}., +     * @param config The {@link android.graphics.Bitmap.Config} of the desired {@link android.graphics.Bitmap}., +     * @return A {@link android.graphics.Bitmap} with exactly the given width, height, and config potentially containing, +     * random image data or null if no such {@link android.graphics.Bitmap} could be obtained from the pool., +     */, +    public Bitmap getDirty(int width, int height, Bitmap.Config config);, +, +    /**, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java, +    public Bitmap getDirty(int width, int height, Bitmap.Config config) {, +        return null;, +    }, +, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +     * Returns a {@link android.graphics.Bitmap} of exactly the given width, height, and configuration, and containing, +     * only transparent pixels or null if no such {@link android.graphics.Bitmap} could be obtained from the pool., +     *, +     * <p>, +     *     Because this method erases all pixels in the {@link Bitmap}, this method is slightly slower than, +     *     {@link #getDirty(int, int, android.graphics.Bitmap.Config)}. If the {@link android.graphics.Bitmap} is being, +     *     obtained to be used in {@link android.graphics.BitmapFactory} or in any other case where every pixel in the, +     *     {@link android.graphics.Bitmap} will always be overwritten or cleared,, +     *     {@link #getDirty(int, int, android.graphics.Bitmap.Config)} will be faster. When in doubt, use this method]
[+++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java, +  /**, +   * @deprecated Use {@link #waitForLayout()} instead., +   */, +  @SuppressWarnings({"unused", "deprecation"}), +  @Deprecated, +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java, +  /**, +   * @deprecated Use {@link #waitForLayout()} instead., +   */, +  @SuppressWarnings({"unused", "deprecation"}), +  @Deprecated, +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java, +  /**, +   * @deprecated Use {@link #waitForLayout()} instead., +   */, +  @SuppressWarnings("deprecation"), +  @Deprecated, +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java, +  /**, +   * @deprecated Use {@link #waitForLayout()} instead., +   */, +  @SuppressWarnings({"unused", "deprecation"}), +  @Deprecated, +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java, +  /**, +   * @deprecated Use {@link #waitForLayout()} instead., +   */, +  @SuppressWarnings("deprecation"), +  @Deprecated, +++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java, +  /**, +   * @deprecated Use {@link #waitForLayout()} instead., +   */, +  @SuppressWarnings({"unused", "deprecation"}), +  @Deprecated, +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java, +  /**, +   * @deprecated Use {@link #waitForLayout()} instead., +   */, +  @SuppressWarnings({"unused", "deprecation"}), +  @Deprecated, +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java, +  /**, +   * @deprecated Use {@link #waitForLayout()} instead., +   */, +  @SuppressWarnings("deprecation"), +  @Deprecated, +++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java, +  /**, +   * @deprecated Use {@link #waitForLayout()} instead., +   */, +  @SuppressWarnings({"unused", "deprecation"}), +  @Deprecated, +++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java, +  /**, +   * @deprecated Use {@link #waitForLayout()} instead., +   */, +  @Deprecated, +  @SuppressWarnings("deprecation"), +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java, +  /**, +   * @deprecated Use {@link #waitForLayout()} instead., +   */, +  @SuppressWarnings({"unused", "deprecation"}), +  @Deprecated, +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java, +  /**, +   * @deprecated Use {@link #waitForLayout()} instead., +   */, +  @SuppressWarnings("deprecation"), +  @Deprecated, +++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java, +  /**, +   * @deprecated Use {@link #waitForLayout()} instead., +   */, +  @SuppressWarnings({"unused", "deprecation"}), +  @Deprecated, +++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java, +  /**, +   * @deprecated Use {@link #waitForLayout()} instead., +   */, +  @Deprecated, +  @SuppressWarnings("deprecation"), +++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java, +  /**, +   * @deprecated Use {@link #waitForLayout()} instead., +   */, +  @SuppressWarnings({"deprecation"}), +  @Deprecated, +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java, +  /**, +   * @deprecated Use {@link #waitForLayout()} instead., +   */, +  @SuppressWarnings({"unused", "deprecation"}), +  @Deprecated, +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java, +  /**, +   * @deprecated Use {@link #waitForLayout()} instead., +   */]
[+++ b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java, +   * @param viewId      The id of the ImageView view that will load the image., +   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap., +  public AppWidgetTarget(Context context, int width, int height,, +      int viewId, RemoteViews remoteViews, int... widgetIds) {, +   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap., +  public AppWidgetTarget(Context context,, +      int viewId, RemoteViews remoteViews, int... widgetIds) {, +    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, widgetIds);, +   * @param viewId        The id of the ImageView view that will load the image., +   * @param remoteViews   RemoteViews object which contains the ImageView that will load the, +   *                      bitmap., +  public AppWidgetTarget(Context context, int width, int height,, +      int viewId, RemoteViews remoteViews, ComponentName componentName) {, +   * @param viewId        The id of the ImageView view that will load the image., +  public AppWidgetTarget(Context context,, +      int viewId, RemoteViews remoteViews, ComponentName componentName) {, +    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, componentName);, +++ b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java, +   * @param viewId      The id of the ImageView view that will load the image., +   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap., +  public AppWidgetTarget(Context context, int width, int height,, +      int viewId, RemoteViews remoteViews, int... widgetIds) {, +   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap., +  public AppWidgetTarget(Context context,, +      int viewId, RemoteViews remoteViews, int... widgetIds) {, +    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, widgetIds);, +   * @param viewId        The id of the ImageView view that will load the image., +   * @param remoteViews   RemoteViews object which contains the ImageView that will load the, +   *                      bitmap., +  public AppWidgetTarget(Context context, int width, int height,, +      int viewId, RemoteViews remoteViews, ComponentName componentName) {, +   * @param viewId        The id of the ImageView view that will load the image., +  public AppWidgetTarget(Context context,, +      int viewId, RemoteViews remoteViews, ComponentName componentName) {, +    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, componentName);, +++ b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java, +   * @param viewId         The id of the ImageView view that will load the image., +  public NotificationTarget(Context context,, +      int viewId, RemoteViews remoteViews, Notification notification, int notificationId) {, +    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, notification, notificationId);, +   * @param viewId         The id of the ImageView view that will load the image., +   * @param remoteViews    RemoteViews object which contains the ImageView that will load the, +   *                       bitmap., +  public NotificationTarget(Context context, int width, int height,, +      int viewId, RemoteViews remoteViews, Notification notification, int notificationId) {, +++ b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java, +   * @param viewId      The id of the ImageView view that will load the image., +   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap., +  public AppWidgetTarget(Context context, int width, int height,, +      int viewId, RemoteViews remoteViews, int... widgetIds) {, +   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap., +  public AppWidgetTarget(Context context,, +      int viewId, RemoteViews remoteViews, int... widgetIds) {, +    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, widgetIds);, +   * @param viewId        The id of the ImageView view that will load the image., +   * @param remoteViews   RemoteViews object which contains the ImageView that will load the, +   *                      bitmap., +  public AppWidgetTarget(Context context, int width, int height,, +      int viewId, RemoteViews remoteViews, ComponentName componentName) {, +   * @param viewId        The id of the ImageView view that will load the image., +  public AppWidgetTarget(Context context,, +      int viewId, RemoteViews remoteViews, ComponentName componentName) {, +    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, componentName);, +++ b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java, +   * @param viewId         The id of the ImageView view that will load the image., +  public NotificationTarget(Context context,, +      int viewId, RemoteViews remoteViews, Notification notification, int notificationId) {, +    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, notification, notificationId);, +   * @param viewId         The id of the ImageView view that will load the image., +   * @param remoteViews    RemoteViews object which contains the ImageView that will load the, +   *                       bitmap., +  public NotificationTarget(Context context, int width, int height,, +      int viewId, RemoteViews remoteViews, Notification notification, int notificationId) {, +++ b/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java, +        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, componentName);, +        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, componentName);, +        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, widgetIds);, +        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, widgetIds);, +    new AppWidgetTarget(null /*context*/, 1234 /*viewId*/, views, 1 /*widgetIds*/);, +    new AppWidgetTarget(null /*context*/, 1234 /*viewId*/, views, mock(ComponentName.class));, +    new AppWidgetTarget(RuntimeEnvironment.application,, +        viewId, null /*remoteViews*/, 1 /*widgetIds*/);, +    new AppWidgetTarget(RuntimeEnvironment.application,, +        viewId, null /*remoteViews*/, mock(ComponentName.class));, +    new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, (int[]) null /*widgetIds*/);, +    new AppWidgetTarget(RuntimeEnvironment.application, viewId, views);, +    new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, (ComponentName) null);, +++ b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java, +   * @param viewId      The id of the ImageView view that will load the image., +   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap., +  public AppWidgetTarget(Context context, int width, int height,, +      int viewId, RemoteViews remoteViews, int... widgetIds) {, +   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap., +  public AppWidgetTarget(Context context,, +      int viewId, RemoteViews remoteViews, int... widgetIds) {, +    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, widgetIds);, +   * @param viewId        The id of the ImageView view that will load the image., +   * @param remoteViews   RemoteViews object which contains the ImageView that will load the, +   *                      bitmap.]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java]
[+++ b/README.md, +You can download a jar from GitHub's [release page](https://github.com/bumptech/glide/releases)., +    compile 'com.github.bumptech.glide:glide:3.3.+', +  <version>3.3.1</version>, +Checkout the [GitHub wiki](https://github.com/bumptech/glide/wiki) for pages on a variety of topics, and see the [javadocs](http://bumptech.github.io/glide/javadocs/latest/index.html)., +Volley is now an optional dependency that can be included via a utility library. To use Volley to fetch media over http/https:, +    compile 'com.github.bumptech.glide:volley-integration:1.0.+', +    <version>1.0.1</version>, +In addition to Volley, Glide also includes support for fetching media using OkHttp. To use OkHttp to fetch media over http/https:, +    compile 'com.github.bumptech.glide:okhttp-integration:1.0.+', +    <version>1.0.1</version>, +Version 3.x is a stable public release used in multiple open source projects at Google including in the Android Camera app and in the 2014 Google IO app. Comments/bugs/questions/pull requests welcome!, +Note: Make sure your Android SDK has the Android Support Repository installed, and that your `$ANDROID_HOME` environment variable is pointing at the SDK or add a `local.properties` file in the root project with a `sdk.dir=...` line., +Follow the steps in the 'Build' section to setup the project and then edit the files however you wish. Intellij's [IDEA 14 early access build](http://confluence.jetbrains.com/display/IDEADEV/IDEA+14+EAP) cleanly imports both Glide's source and tests and is the recommended way to work with Glide. Earlier versions of intellij do not import the gradle project cleanly. Although Android Studio imports the source cleanly, it is not possible to run or debug the tests without manually modifying the tests' classpath., +4. Select settings.gradle., +To report a specific problem or feature request, [open a new issue on Github](https://github.com/bumptech/glide/issues/new). For questions, suggestions, or anything else, join or email [Glide's discussion group](https://groups.google.com/forum/#!forum/glidelibrary), +Before submitting pull requests, contributors must sign Google's [individual contribution license agreement](https://developers.google.com/open-source/cla/individual)., +* The Android team and Jake Wharton for the [disk cache implementation](https://github.com/JakeWharton/DiskLruCache) Glide's disk cache is based on., +* Dave Smith for the [gif decoder gist](https://gist.github.com/devunwired/4479231) Glide's gif decoder is based on., +* Chris Banes for his [gradle-mvn-push](https://github.com/chrisbanes/gradle-mvn-push) script., +* Corey Hall for Glide's [amazing logo](static/glide_logo.png)., +++ b/README.md, +You can download a jar from GitHub's [release page](https://github.com/bumptech/glide/releases)., +    compile 'com.github.bumptech.glide:glide:3.3.+', +  <version>3.3.1</version>, +Checkout the [GitHub wiki](https://github.com/bumptech/glide/wiki) for pages on a variety of topics, and see the [javadocs](http://bumptech.github.io/glide/javadocs/latest/index.html)., +Volley is now an optional dependency that can be included via a utility library. To use Volley to fetch media over http/https:, +    compile 'com.github.bumptech.glide:volley-integration:1.0.+', +    <version>1.0.1</version>, +In addition to Volley, Glide also includes support for fetching media using OkHttp. To use OkHttp to fetch media over http/https:, +    compile 'com.github.bumptech.glide:okhttp-integration:1.0.+', +    <version>1.0.1</version>, +Version 3.x is a stable public release used in multiple open source projects at Google including in the Android Camera app and in the 2014 Google IO app. Comments/bugs/questions/pull requests welcome!, +Note: Make sure your Android SDK has the Android Support Repository installed, and that your `$ANDROID_HOME` environment variable is pointing at the SDK or add a `local.properties` file in the root project with a `sdk.dir=...` line., +Follow the steps in the 'Build' section to setup the project and then edit the files however you wish. Intellij's [IDEA 14 early access build](http://confluence.jetbrains.com/display/IDEADEV/IDEA+14+EAP) cleanly imports both Glide's source and tests and is the recommended way to work with Glide. Earlier versions of intellij do not import the gradle project cleanly. Although Android Studio imports the source cleanly, it is not possible to run or debug the tests without manually modifying the tests' classpath., +4. Select settings.gradle., +To report a specific problem or feature request, [open a new issue on Github](https://github.com/bumptech/glide/issues/new). For questions, suggestions, or anything else, join or email [Glide's discussion group](https://groups.google.com/forum/#!forum/glidelibrary), +Before submitting pull requests, contributors must sign Google's [individual contribution license agreement](https://developers.google.com/open-source/cla/individual)., +* The Android team and Jake Wharton for the [disk cache implementation](https://github.com/JakeWharton/DiskLruCache) Glide's disk cache is based on., +* Dave Smith for the [gif decoder gist](https://gist.github.com/devunwired/4479231) Glide's gif decoder is based on., +* Chris Banes for his [gradle-mvn-push](https://github.com/chrisbanes/gradle-mvn-push) script., +* Corey Hall for Glide's [amazing logo](static/glide_logo.png)., +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import static org.mockito.Mockito.atLeastOnce;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +import com.bumptech.glide.request.target.SizeReadyCallback;, +import com.bumptech.glide.request.target.Target;, +, +import org.junit.Before;, +import org.mockito.ArgumentCaptor;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +import org.mockito.verification.VerificationMode;, +import java.util.Arrays;, +    @Mock, +    private BitmapRequestBuilder request;, +, +    @Before, +    public void setUp() throws Exception {, +        MockitoAnnotations.initMocks(this);, +    }, +, +        final AtomicInteger calledCount = new AtomicInteger();, +, +            public List<Object> getPreloadItems(int position) {, +                final int count = calledCount.getAndIncrement();, +                assertEquals(11 + count, position);, +                return super.getPreloadItems(position);, +        assertEquals(10, calledCount.get());, +            objects.add(new Integer(i));, +            public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {, +            public List<Object> getPreloadItems(int position) {, +                return objects.subList(position - 11, position + 1 - 11);, +        preloader.onScroll(null, 1, 10, 20);, +        final AtomicInteger calledCount = new AtomicInteger();, +            public List<Object> getPreloadItems(int position) {, +                if (position >= 40) {, +                final int count = calledCount.getAndIncrement();, +                assertEquals(28 - count, position);, +                return super.getPreloadItems(position);, +            public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {, +            public List<Object> getPreloadItems(int position) {, +                if (position == 40) {, +                    return null;, +                return objects.subList(position, position + 1);, +        preloader.onScroll(null, 30, 10, 10);, +        preloader.onScroll(null, 29, 10, 10);, +        final AtomicInteger calledCount = new AtomicInteger();, +            public List<Object> getPreloadItems(int position) {, +                final int count = calledCount.getAndIncrement();, +                assertEquals(26 + count, position);, +                return super.getPreloadItems(position);, +        final AtomicInteger calledCount = new AtomicInteger();, +            public List<Object> getPreloadItems(int position) {, +                if (position >= 17) {, +                final int count = calledCount.getAndIncrement();, +                assertEquals(5 - count, position);, +                return super.getPreloadItems(position);, +            public List<Object> getPreloadItems(int position) {]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import static org.mockito.AdditionalMatchers.not;, +import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;, +import com.bumptech.glide.test.ResourceIds.raw;, +  public void submit_withDisabledMemoryCache_andResourceInActiveResources_loadsFromMemory() {, +    Glide.init(, +        context, new GlideBuilder().setMemoryCache(new MemoryCacheAdapter()));, +, +    FutureTarget<Drawable> first =, +        GlideApp.with(context), +            .load(raw.canonical), +            .submit();, +    concurrency.get(first);, +, +    concurrency.get(, +        GlideApp.with(context), +            .load(ResourceIds.raw.canonical), +            .listener(requestListener), +            .submit());, +, +    verify(requestListener), +        .onResourceReady(, +            any(Drawable.class),, +            any(),, +            anyTarget(),, +            eq(DataSource.MEMORY_CACHE),, +            anyBoolean());, +  }, +, +  @Test, +  public void submit_withRequestClearedFromMemory_doesNotLoadFromMemory() {, +    Glide.init(, +        context, new GlideBuilder().setMemoryCache(new MemoryCacheAdapter()));, +, +    FutureTarget<Drawable> first =, +        GlideApp.with(context), +            .load(raw.canonical), +            .submit();, +    concurrency.get(first);, +, +    // Allow first to be GCed and removed from active resources., +    //noinspection UnusedAssignment, +    first = null;, +    // De-flake by allowing multiple tries, +    for (int j = 0; j < 10; j++) {, +      Runtime.getRuntime().gc();, +      concurrency.pokeMainThread();, +      try {, +        // Loading again here won't shuffle our resource around because it only changes our, +        // reference count from 1 to 2 and back. The reference we're waiting for will only be, +        // decremented when the target is GCed., +        FutureTarget<Drawable> target =, +            concurrency.wait(, +                GlideApp.with(context), +                    .load(ResourceIds.raw.canonical), +                    .onlyRetrieveFromCache(true), +                    .diskCacheStrategy(DiskCacheStrategy.NONE), +                    .submit());, +        GlideApp.with(context).clear(target);, +      } catch (RuntimeException e) {, +        // The item has been cleared from active resources., +        break;, +      }, +    }, +, +    concurrency.get(, +        GlideApp.with(context), +            .load(ResourceIds.raw.canonical), +            .listener(requestListener), +            .submit());, +, +    verify(requestListener), +        .onResourceReady(, +            any(Drawable.class),, +            any(),, +            anyTarget(),, +            not(eq(DataSource.MEMORY_CACHE)),, +            anyBoolean());, +  }, +, +  @Test, +, +    concurrency.pokeMainThread();, +, +, +    concurrency.pokeMainThread();, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import static org.mockito.AdditionalMatchers.not;, +import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;, +import com.bumptech.glide.test.ResourceIds.raw;, +  public void submit_withDisabledMemoryCache_andResourceInActiveResources_loadsFromMemory() {, +    Glide.init(, +        context, new GlideBuilder().setMemoryCache(new MemoryCacheAdapter()));, +, +    FutureTarget<Drawable> first =, +        GlideApp.with(context), +            .load(raw.canonical), +            .submit();, +    concurrency.get(first);, +]
[+++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +        Resource<T> previous = resource;, +                Resource<T> transformed = transformation.transform(previous, outWidth, outHeight);, +                if (transformed != previous && previous != resource && previous != null) {, +                    previous.recycle();, +                }, +                previous = transformed;, +                 Resource<T> transformed = transformation.transform(previous, outWidth, outHeight);, +                if (transformed != previous && previous != resource && previous != null) {, +                    previous.recycle();, +                }, +                previous = transformed;, +        return previous;, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +        Resource<T> previous = resource;, +                Resource<T> transformed = transformation.transform(previous, outWidth, outHeight);, +                if (transformed != previous && previous != resource && previous != null) {, +                    previous.recycle();, +                }, +                previous = transformed;, +                 Resource<T> transformed = transformation.transform(previous, outWidth, outHeight);, +                if (transformed != previous && previous != resource && previous != null) {, +                    previous.recycle();, +                }, +                previous = transformed;, +        return previous;, +++ b/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java, +package com.bumptech.glide.load;, +, +import com.bumptech.glide.Resource;, +import org.junit.Test;, +, +import static junit.framework.Assert.assertEquals;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.never;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, +public class MultiTransformationTest {, +    @Test, +    public void testReturnsConcatenatedTransformationIds() {, +        String firstId = "firstId";, +        Transformation first = mock(Transformation.class);, +        when(first.getId()).thenReturn(firstId);, +        String secondId = "secondId";, +        Transformation second = mock(Transformation.class);, +        when(second.getId()).thenReturn(secondId);, +        String thirdId = "thirdId";, +        Transformation third = mock(Transformation.class);, +        when(third.getId()).thenReturn(thirdId);, +, +        MultiTransformation transformation = new MultiTransformation(first, second, third);, +, +        assertEquals(firstId + secondId + thirdId, transformation.getId());, +    }, +, +    @Test, +    public void testAppliesTransformationsInOrder() {, +        final int width = 584;, +        final int height = 768;, +, +        Resource initial = mock(Resource.class);, +, +        Resource firstTransformed = mock(Resource.class);, +        Transformation first = mock(Transformation.class);, +        when(first.transform(eq(initial), eq(width), eq(height))).thenReturn(firstTransformed);, +, +        Resource secondTransformed = mock(Resource.class);, +        Transformation second = mock(Transformation.class);, +        when(second.transform(eq(firstTransformed), eq(width), eq(height))).thenReturn(secondTransformed);, +, +        MultiTransformation transformation = new MultiTransformation(first, second);, +, +        assertEquals(secondTransformed, transformation.transform(initial, width, height));, +    }, +, +    @Test, +    public void testInitialResourceIsNotRecycled() {, +        Resource initial = mock(Resource.class);, +, +        Resource transformed = mock(Resource.class);, +        Transformation first = mock(Transformation.class);, +        when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(transformed);, +, +        MultiTransformation transformation = new MultiTransformation(first);, +, +        transformation.transform(initial, 123, 456);, +, +        verify(initial, never()).recycle();, +    }, +, +    @Test, +    public void testInitialResourceIsNotRecycledEvenIfReturnedByMultipleTransformations() {, +        Resource initial = mock(Resource.class);, +        Transformation first = mock(Transformation.class);, +        when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(initial);, +        Transformation second = mock(Transformation.class);]
[+++ b/annotation/compiler/gradle.properties, +++ b/annotation/compiler/gradle.properties, +++ b/annotation/gradle.properties, +++ b/annotation/compiler/gradle.properties, +++ b/annotation/gradle.properties, +++ b/integration/gifencoder/gradle.properties, +++ b/annotation/compiler/gradle.properties, +++ b/annotation/gradle.properties, +++ b/integration/gifencoder/gradle.properties, +++ b/integration/okhttp/gradle.properties, +++ b/annotation/compiler/gradle.properties, +++ b/annotation/gradle.properties, +++ b/integration/gifencoder/gradle.properties, +++ b/integration/okhttp/gradle.properties, +++ b/integration/okhttp3/gradle.properties, +++ b/annotation/compiler/gradle.properties, +++ b/annotation/gradle.properties, +++ b/integration/gifencoder/gradle.properties, +++ b/integration/okhttp/gradle.properties, +++ b/integration/okhttp3/gradle.properties, +++ b/integration/recyclerview/gradle.properties, +++ b/annotation/compiler/gradle.properties, +++ b/annotation/gradle.properties, +++ b/integration/gifencoder/gradle.properties, +++ b/integration/okhttp/gradle.properties, +++ b/integration/okhttp3/gradle.properties, +++ b/integration/recyclerview/gradle.properties, +++ b/integration/volley/gradle.properties, +++ b/annotation/compiler/gradle.properties, +++ b/annotation/gradle.properties, +++ b/integration/gifencoder/gradle.properties, +++ b/integration/okhttp/gradle.properties, +++ b/integration/okhttp3/gradle.properties, +++ b/integration/recyclerview/gradle.properties, +++ b/integration/volley/gradle.properties, +++ b/third_party/disklrucache, +Subproject commit 273f119c607eb55da0627ebb4a0c1b0d1a15b2dc, +++ b/annotation/compiler/gradle.properties, +++ b/annotation/gradle.properties, +++ b/integration/gifencoder/gradle.properties, +++ b/integration/okhttp/gradle.properties, +++ b/integration/okhttp3/gradle.properties, +++ b/integration/recyclerview/gradle.properties, +++ b/integration/volley/gradle.properties, +++ b/third_party/disklrucache, +Subproject commit 273f119c607eb55da0627ebb4a0c1b0d1a15b2dc, +++ b/third_party/gif_decoder/gradle.properties]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java, +++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java, +  private DrawableCrossFadeTransition resourceTransition;, +  protected DrawableCrossFadeFactory(int duration, boolean isCrossFadeEnabled) {, +    return dataSource == DataSource.MEMORY_CACHE, +        ? NoTransition.<Drawable>get() : getResourceTransition();, +  private Transition<Drawable> getResourceTransition() {, +      if (resourceTransition == null) {, +        resourceTransition = new DrawableCrossFadeTransition(duration, isCrossFadeEnabled);, +      return resourceTransition;, +     * @param durationMillis The duration of the cross fade animation in milliseconds., +      return new DrawableCrossFadeFactory(durationMillis, isCrossFadeEnabled);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java, +++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java, +  private DrawableCrossFadeTransition resourceTransition;, +  protected DrawableCrossFadeFactory(int duration, boolean isCrossFadeEnabled) {, +    return dataSource == DataSource.MEMORY_CACHE, +        ? NoTransition.<Drawable>get() : getResourceTransition();, +  private Transition<Drawable> getResourceTransition() {, +      if (resourceTransition == null) {, +        resourceTransition = new DrawableCrossFadeTransition(duration, isCrossFadeEnabled);, +      return resourceTransition;, +     * @param durationMillis The duration of the cross fade animation in milliseconds., +      return new DrawableCrossFadeFactory(durationMillis, isCrossFadeEnabled);, +++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java, +import android.graphics.Color;, +import android.graphics.drawable.ColorDrawable;, +  public DrawableCrossFadeTransition(int duration,, +    if (previous == null) {, +      previous = new ColorDrawable(Color.TRANSPARENT);, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java, +++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java, +  private DrawableCrossFadeTransition resourceTransition;, +  protected DrawableCrossFadeFactory(int duration, boolean isCrossFadeEnabled) {, +    return dataSource == DataSource.MEMORY_CACHE, +        ? NoTransition.<Drawable>get() : getResourceTransition();, +  private Transition<Drawable> getResourceTransition() {, +      if (resourceTransition == null) {, +        resourceTransition = new DrawableCrossFadeTransition(duration, isCrossFadeEnabled);, +      return resourceTransition;, +     * @param durationMillis The duration of the cross fade animation in milliseconds., +      return new DrawableCrossFadeFactory(durationMillis, isCrossFadeEnabled);, +++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java, +import android.graphics.Color;, +import android.graphics.drawable.ColorDrawable;, +  public DrawableCrossFadeTransition(int duration,, +    if (previous == null) {, +      previous = new ColorDrawable(Color.TRANSPARENT);, +    }, +++ b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java, +    factory = new DrawableCrossFadeFactory(100 /*duration*/, false /*isCrossFadeEnabled*/);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java, +++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java, +  private DrawableCrossFadeTransition resourceTransition;, +  protected DrawableCrossFadeFactory(int duration, boolean isCrossFadeEnabled) {, +    return dataSource == DataSource.MEMORY_CACHE, +        ? NoTransition.<Drawable>get() : getResourceTransition();, +  private Transition<Drawable> getResourceTransition() {, +      if (resourceTransition == null) {, +        resourceTransition = new DrawableCrossFadeTransition(duration, isCrossFadeEnabled);, +      return resourceTransition;, +     * @param durationMillis The duration of the cross fade animation in milliseconds., +      return new DrawableCrossFadeFactory(durationMillis, isCrossFadeEnabled);, +++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeTransition.java, +import android.graphics.Color;, +import android.graphics.drawable.ColorDrawable;, +  public DrawableCrossFadeTransition(int duration,, +    if (previous == null) {, +      previous = new ColorDrawable(Color.TRANSPARENT);, +    }, +++ b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactoryTest.java, +    factory = new DrawableCrossFadeFactory(100 /*duration*/, false /*isCrossFadeEnabled*/);, +++ b/library/src/test/java/com/bumptech/glide/request/transition/DrawableCrossFadeViewAnimationTest.java, +  public void transition_withNonNullPreviousDrawable_setsTransitionDrawable() {, +  public void transition_withNullPreviousDrawable_setsTransitionDrawable() {, +    harness.animation.transition(harness.current, harness.adapter);, +, +    verify(harness.adapter).setDrawable(any(TransitionDrawable.class));, +  }, +, +  @Test, +  public void transition_withNoCurrentDrawable_returnsTrue() {, +    assertTrue(harness.animation.transition(harness.current, harness.adapter));, +  }, +, +  @Test, +  public void transition_withCurrentDrawable_returnsTrue() {, +        new DrawableCrossFadeTransition(duration, true /*isCrossFadeEnabled*/);]
[+++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888_DISALLOW_HARDWARE;, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888_DISALLOW_HARDWARE;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888_DISALLOW_HARDWARE;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +      return path.load(rewinder, options, width, height,, +          new DecodeCallback<ResourceType>(dataSource));, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888_DISALLOW_HARDWARE;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +      return path.load(rewinder, options, width, height,, +          new DecodeCallback<ResourceType>(dataSource));, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888_DISALLOW_HARDWARE;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +      return path.load(rewinder, options, width, height,, +          new DecodeCallback<ResourceType>(dataSource));, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +          downsampleStrategy, decodeFormat, requestedWidth, requestedHeight,, +          fixBitmapToRequestedDimensions, callbacks);, +      DecodeFormat decodeFormat, int requestedWidth, int requestedHeight,, +      boolean fixBitmapToRequestedDimensions, DecodeCallbacks callbacks) throws IOException {, +, +    calculateConfig(is, decodeFormat, options, targetWidth, targetHeight);, +        targetWidth, targetHeight, optionsWithScaling, format)) {, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888_DISALLOW_HARDWARE;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +      return path.load(rewinder, options, width, height,, +          new DecodeCallback<ResourceType>(dataSource));, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +          downsampleStrategy, decodeFormat, requestedWidth, requestedHeight,, +          fixBitmapToRequestedDimensions, callbacks);, +      DecodeFormat decodeFormat, int requestedWidth, int requestedHeight,, +      boolean fixBitmapToRequestedDimensions, DecodeCallbacks callbacks) throws IOException {, +, +    calculateConfig(is, decodeFormat, options, targetWidth, targetHeight);, +        targetWidth, targetHeight, optionsWithScaling, format)) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java, +  /**, +   * The minimum size that will trigger downsampling in {@link BitmapFactory}., +   *, +   * <p>From {@link android.graphics.BitmapFactory.Options#inSampleSize}., +   */, +  private static final int MINIMUM_SAMPLE_SIZE = 2;, +, +      DecodeFormat decodeFormat) {, +    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O, +    boolean result = !optionsWithScaling.inScaled, +        && optionsWithScaling.inSampleSize < MINIMUM_SAMPLE_SIZE, +        && targetWidth >= MIN_HARDWARE_DIMENSION, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888_DISALLOW_HARDWARE;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +      return path.load(rewinder, options, width, height,, +          new DecodeCallback<ResourceType>(dataSource));, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +          downsampleStrategy, decodeFormat, requestedWidth, requestedHeight,, +          fixBitmapToRequestedDimensions, callbacks);, +      DecodeFormat decodeFormat, int requestedWidth, int requestedHeight,, +      boolean fixBitmapToRequestedDimensions, DecodeCallbacks callbacks) throws IOException {, +, +    calculateConfig(is, decodeFormat, options, targetWidth, targetHeight);, +        targetWidth, targetHeight, optionsWithScaling, format)) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java, +  /**, +   * The minimum size that will trigger downsampling in {@link BitmapFactory}., +   *, +   * <p>From {@link android.graphics.BitmapFactory.Options#inSampleSize}., +   */, +  private static final int MINIMUM_SAMPLE_SIZE = 2;, +, +      DecodeFormat decodeFormat) {, +    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O, +    boolean result = !optionsWithScaling.inScaled, +        && optionsWithScaling.inSampleSize < MINIMUM_SAMPLE_SIZE, +        && targetWidth >= MIN_HARDWARE_DIMENSION, +++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +   * Applies {@link com.bumptech.glide.load.resource.bitmap.FitCenter} to all default types, and, +   * ignores unknown types., +   * <p>This will override previous calls to {@link #dontTransform()}., +    return optionalTransform(DownsampleStrategy.FIT_CENTER, new FitCenter());, +   * Applies {@link FitCenter} to all default types and, +   * throws an exception if asked to transform an unknown type., +   * <p>This will override previous calls to {@link #dontTransform()}., +    return transform(DownsampleStrategy.FIT_CENTER, new FitCenter());, +   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types, and, +   * ignores unknown types.]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +import static com.bumptech.glide.gifdecoder.GifDecoder.TOTAL_ITERATION_COUNT_FOREVER;, +, +      int intrinsicCount = state.frameLoader.getLoopCount();, +      maxLoopCount =, +          (intrinsicCount == TOTAL_ITERATION_COUNT_FOREVER) ? LOOP_FOREVER : intrinsicCount;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +import static com.bumptech.glide.gifdecoder.GifDecoder.TOTAL_ITERATION_COUNT_FOREVER;, +, +      int intrinsicCount = state.frameLoader.getLoopCount();, +      maxLoopCount =, +          (intrinsicCount == TOTAL_ITERATION_COUNT_FOREVER) ? LOOP_FOREVER : intrinsicCount;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java, +    return gifDecoder.getTotalIterationCount();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +import static com.bumptech.glide.gifdecoder.GifDecoder.TOTAL_ITERATION_COUNT_FOREVER;, +, +      int intrinsicCount = state.frameLoader.getLoopCount();, +      maxLoopCount =, +          (intrinsicCount == TOTAL_ITERATION_COUNT_FOREVER) ? LOOP_FOREVER : intrinsicCount;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java, +    return gifDecoder.getTotalIterationCount();, +++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertTrue("drawable should be still running", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +  public void testUsesDecoderTotalLoopCountIfLoopCountIsLoopIntrinsic() {, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +  public void testLoopsForeverIfLoopCountIsLoopIntrinsicAndTotalIterationCountIsForever() {, +    final int frameCount = 3;, +    final int loopCount = 40;, +    when(frameLoader.getLoopCount()).thenReturn(GifDecoder.TOTAL_ITERATION_COUNT_FOREVER);, +    when(frameLoader.getFrameCount()).thenReturn(frameCount);, +    drawable.setLoopCount(GifDrawable.LOOP_INTRINSIC);, +    drawable.setVisible(true, true);, +    drawable.start();, +, +    runLoops(loopCount, frameCount);, +, +    verifyRanLoops(loopCount, frameCount);, +    assertTrue("drawable should be still running", drawable.isRunning());, +  }, +, +, +  @Test, +        assertTrue("drawable should be started before calling drawable.onFrameReady()",, +            drawable.isRunning());, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +import static com.bumptech.glide.gifdecoder.GifDecoder.TOTAL_ITERATION_COUNT_FOREVER;, +, +      int intrinsicCount = state.frameLoader.getLoopCount();, +      maxLoopCount =, +          (intrinsicCount == TOTAL_ITERATION_COUNT_FOREVER) ? LOOP_FOREVER : intrinsicCount;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java, +    return gifDecoder.getTotalIterationCount();, +++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertTrue("drawable should be still running", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +  public void testUsesDecoderTotalLoopCountIfLoopCountIsLoopIntrinsic() {, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +  public void testLoopsForeverIfLoopCountIsLoopIntrinsicAndTotalIterationCountIsForever() {, +    final int frameCount = 3;, +    final int loopCount = 40;, +    when(frameLoader.getLoopCount()).thenReturn(GifDecoder.TOTAL_ITERATION_COUNT_FOREVER);, +    when(frameLoader.getFrameCount()).thenReturn(frameCount);, +    drawable.setLoopCount(GifDrawable.LOOP_INTRINSIC);, +    drawable.setVisible(true, true);, +    drawable.start();, +, +    runLoops(loopCount, frameCount);, +, +    verifyRanLoops(loopCount, frameCount);, +    assertTrue("drawable should be still running", drawable.isRunning());, +  }, +, +, +  @Test, +        assertTrue("drawable should be started before calling drawable.onFrameReady()",, +            drawable.isRunning());, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, +  /** The total iteration count which means repeat forever. */, +  int TOTAL_ITERATION_COUNT_FOREVER = 0;, +   * Gets the "Netscape" loop count, if any. A count of 0 means repeat indefinitely., +   * @deprecated Use {@link #getNetscapeLoopCount()} instead., +   *             This method cannot distinguish whether the loop count is 1 or doesn't exist., +   * @return loop count if one was specified, else 1., +  @Deprecated, +   * Gets the "Netscape" loop count, if any., +   * A count of 0 ({@link GifHeader#NETSCAPE_LOOP_COUNT_FOREVER}) means repeat indefinitely.]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.data.DataRewinderRegistry;, +import com.bumptech.glide.load.data.InputStreamRewinder;, +    private final DataRewinderRegistry dataRewinderRegistry;, +        dataRewinderRegistry = new DataRewinderRegistry();, +        dataRewinderRegistry.register(new InputStreamRewinder.Factory());, +, +        return new RequestContext(loaderRegistry, encoderRegistry, decoderRegistry, resourceEncoderRegistry,, +                dataRewinderRegistry);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.data.DataRewinderRegistry;, +import com.bumptech.glide.load.data.InputStreamRewinder;, +    private final DataRewinderRegistry dataRewinderRegistry;, +        dataRewinderRegistry = new DataRewinderRegistry();, +        dataRewinderRegistry.register(new InputStreamRewinder.Factory());, +, +        return new RequestContext(loaderRegistry, encoderRegistry, decoderRegistry, resourceEncoderRegistry,, +                dataRewinderRegistry);, +++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java, +     * Synchronously fetch data from which a resource can be decoded. This will always be called on, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.data.DataRewinderRegistry;, +import com.bumptech.glide.load.data.InputStreamRewinder;, +    private final DataRewinderRegistry dataRewinderRegistry;, +        dataRewinderRegistry = new DataRewinderRegistry();, +        dataRewinderRegistry.register(new InputStreamRewinder.Factory());, +, +        return new RequestContext(loaderRegistry, encoderRegistry, decoderRegistry, resourceEncoderRegistry,, +                dataRewinderRegistry);, +++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java, +     * Synchronously fetch data from which a resource can be decoded. This will always be called on, +++ b/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java, +package com.bumptech.glide.load.data;, +, +import java.io.IOException;, +, +public interface DataRewinder<T> {, +, +    interface Factory<T> {, +        DataRewinder<T> build(T data);, +        Class getDataClass();, +    }, +, +    T rewindAndGet() throws IOException;, +, +    void cleanup();, +}, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.data.DataRewinderRegistry;, +import com.bumptech.glide.load.data.InputStreamRewinder;, +    private final DataRewinderRegistry dataRewinderRegistry;, +        dataRewinderRegistry = new DataRewinderRegistry();, +        dataRewinderRegistry.register(new InputStreamRewinder.Factory());, +, +        return new RequestContext(loaderRegistry, encoderRegistry, decoderRegistry, resourceEncoderRegistry,, +                dataRewinderRegistry);, +++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java, +     * Synchronously fetch data from which a resource can be decoded. This will always be called on, +++ b/library/src/main/java/com/bumptech/glide/load/data/DataRewinder.java, +package com.bumptech.glide.load.data;, +, +import java.io.IOException;, +, +public interface DataRewinder<T> {, +, +    interface Factory<T> {, +        DataRewinder<T> build(T data);, +        Class getDataClass();, +    }, +, +    T rewindAndGet() throws IOException;, +, +    void cleanup();, +}, +++ b/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java, +package com.bumptech.glide.load.data;, +, +import java.util.HashMap;, +import java.util.Map;, +, +public class DataRewinderRegistry {, +    private final Map<Class, DataRewinder.Factory> rewinders = new HashMap<Class, DataRewinder.Factory>();, +    private static final DataRewinder.Factory DEFAULT_FACTORY = new DataRewinder.Factory<Object>() {, +        @Override, +        public DataRewinder<Object> build(Object data) {, +            return new DefaultRewinder(data);, +        }, +, +        @Override, +        public Class getDataClass() {, +            throw new UnsupportedOperationException("Not implemented");, +        }, +    };, +, +    public synchronized void register(DataRewinder.Factory factory) {, +        rewinders.put(factory.getDataClass(), factory);, +    }, +, +    @SuppressWarnings("unchecked"), +    public synchronized <T> DataRewinder<T> build(T data) {]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.model.DataUrlLoader;, +        .append(String.class, InputStream.class, new DataUrlLoader.StreamFactory()), +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.model.DataUrlLoader;, +        .append(String.class, InputStream.class, new DataUrlLoader.StreamFactory()), +++ b/library/src/main/java/com/bumptech/glide/load/model/DataUrlLoader.java, +package com.bumptech.glide.load.model;, +, +import android.content.Context;, +import android.util.Base64;, +, +import com.bumptech.glide.Priority;, +import com.bumptech.glide.load.DataSource;, +import com.bumptech.glide.load.Options;, +import com.bumptech.glide.load.data.DataFetcher;, +import com.bumptech.glide.signature.ObjectKey;, +, +import java.io.ByteArrayInputStream;, +import java.io.IOException;, +import java.io.InputStream;, +, +/**, + * A simple model loader for loading data from a Data URL String., + *, + * Data URIs use the "data" scheme., + *, + * <p>See http://www.ietf.org/rfc/rfc2397.txt  for a complete description of the 'data' URL scheme., + *, + * <p>Briefly, a 'data' URL has the form: <pre>data:[mediatype][;base64],somedata"</pre>, + */, +public final class DataUrlLoader<Data> implements ModelLoader<String, Data> {, +, +  private static final String DATA_SCHEME_IMAGE = "data:image";, +  private static final String BASE64_TAG = ";base64";, +  private final DataDecoder<Data> dataDecoder;, +, +  public DataUrlLoader(DataDecoder<Data> dataDecoder) {, +    this.dataDecoder = dataDecoder;, +  }, +, +  @Override, +  public LoadData<Data> buildLoadData(String model, int width, int height, Options options) {, +    return new LoadData<>(new ObjectKey(model), new DataUriFetcher<Data>(model, dataDecoder));, +  }, +, +  @Override, +  public boolean handles(String url) {, +    return url.startsWith(DATA_SCHEME_IMAGE);, +  }, +, +  /**, +   * Allows decoding a specific type of data from a Data URL String., +   *, +   * @param <Data> The type of data that can be opened., +   */, +  public interface DataDecoder<Data> {, +, +    Data decode(String uri) throws IllegalArgumentException;, +, +    void close(Data data) throws IOException;, +, +    Class<Data> getDataClass();, +  }, +, +  private static final class DataUriFetcher<Data> implements DataFetcher<Data> {, +, +    private final String dataUri;, +    private final DataDecoder<Data> reader;, +    private Data data;, +, +    public DataUriFetcher(String dataUri, DataDecoder<Data> reader) {, +      this.dataUri = dataUri;, +      this.reader = reader;, +    }, +, +    @Override, +    public void loadData(Priority priority, DataCallback<? super Data> callback) {, +      try {, +        data = reader.decode(dataUri);, +        callback.onDataReady(data);, +      } catch (IllegalArgumentException e) {, +        callback.onLoadFailed(e);, +      }, +    }, +, +    @Override, +    public void cleanup() {, +      try {, +        reader.close(data);, +      } catch (IOException e) {, +        // Ignored., +      }, +    }, +, +    @Override, +    public void cancel() {, +      // Do nothing., +    }, +]
[+++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java, +import java.nio.charset.Charset;, +import java.security.MessageDigest;, + * <p>Using the fully qualified class name as a static final {@link String} (not, + * {@link Class#getName()} to avoid proguard obfuscation) is an easy way to implement, + * {@link #updateDiskCacheKey(java.security.MessageDigest)}} correctly. If additional arguments are, + * required they can be passed in to the constructor of the {@code Transformation} and then used to, + * update the {@link java.security.MessageDigest} passed in to, + * {@link #updateDiskCacheKey(MessageDigest)}. If arguments are primitive types, they can typically, + * easily be serialized using {@link java.nio.ByteBuffer}. {@link String} types can be serialized, + * with {@link String#getBytes(Charset)} using the constant {@link #CHARSET}., + * <p>Implementations <em>must</em> implement {@link #equals(Object)} and {@link #hashCode()} for, + * memory caching to work correctly., +++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java, +import java.nio.charset.Charset;, +import java.security.MessageDigest;, + * <p>Using the fully qualified class name as a static final {@link String} (not, + * {@link Class#getName()} to avoid proguard obfuscation) is an easy way to implement, + * {@link #updateDiskCacheKey(java.security.MessageDigest)}} correctly. If additional arguments are, + * required they can be passed in to the constructor of the {@code Transformation} and then used to, + * update the {@link java.security.MessageDigest} passed in to, + * {@link #updateDiskCacheKey(MessageDigest)}. If arguments are primitive types, they can typically, + * easily be serialized using {@link java.nio.ByteBuffer}. {@link String} types can be serialized, + * with {@link String#getBytes(Charset)} using the constant {@link #CHARSET}., + * <p>Implementations <em>must</em> implement {@link #equals(Object)} and {@link #hashCode()} for, + * memory caching to work correctly., +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java, +import java.nio.charset.Charset;, +import java.security.MessageDigest;, + * public class FillSpace extends BitmapTransformation {, + *, + * <p>Using the fully qualified class name as a static final {@link String} (not, + * {@link Class#getName()} to avoid proguard obfuscation) is an easy way to implement, + * {@link #updateDiskCacheKey(java.security.MessageDigest)}} correctly. If additional arguments are, + * required they can be passed in to the constructor of the {@code Transformation} and then used to, + * update the {@link java.security.MessageDigest} passed in to, + * {@link #updateDiskCacheKey(MessageDigest)}. If arguments are primitive types, they can typically, + * easily be serialized using {@link java.nio.ByteBuffer}. {@link String} types can be serialized, + * with {@link String#getBytes(Charset)} using the constant {@link #CHARSET}., + *, + * <p>As with all {@link Transformation}s, all subclasses <em>must</em> implement, + * {@link #equals(Object)} and {@link #hashCode()} for memory caching to work correctly.]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java, +import android.widget.ImageView;, + * <p>All methods in this interface will be called from a background thread if the, + * {@code RequestListener} is added to a request that is started with, + * {@link RequestBuilder#submit()}, {@link RequestBuilder#submit(int, int)}, or, + * {@link RequestBuilder#into(int, int)}. Those methods no longer post results back to the main, + * thread to avoid the unnecessary thread interactions and corresponding latency. As a side affect, + * though, listeners added to those requests are no longer called on the main thread., + * {@code RequestListeners} added to requests started with {@link RequestBuilder#into(Target)} or, + * {@link RequestBuilder#into(ImageView)} will continue to be called back on the main thread., + *, +   * <p>For threading guarantees, see the class comment., +   *, +   *, +   * <p>For threading guarantees, see the class comment., +   *]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private void notifyComplete(Resource<R> resource, DataSource dataSource) {, +    callback.onResourceReady(resource, dataSource);, +      notifyEncodeAndRelease(resource, currentDataSource);, +  private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource) {, +    notifyComplete(result, dataSource);, +    void onResourceReady(Resource<R> resource, DataSource dataSource);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private void notifyComplete(Resource<R> resource, DataSource dataSource) {, +    callback.onResourceReady(resource, dataSource);, +      notifyEncodeAndRelease(resource, currentDataSource);, +  private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource) {, +    notifyComplete(result, dataSource);, +    void onResourceReady(Resource<R> resource, DataSource dataSource);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +import com.bumptech.glide.load.DataSource;, +      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);, +      cb.onResourceReady(active, DataSource.MEMORY_CACHE);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private void notifyComplete(Resource<R> resource, DataSource dataSource) {, +    callback.onResourceReady(resource, dataSource);, +      notifyEncodeAndRelease(resource, currentDataSource);, +  private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource) {, +    notifyComplete(result, dataSource);, +    void onResourceReady(Resource<R> resource, DataSource dataSource);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +import com.bumptech.glide.load.DataSource;, +      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);, +      cb.onResourceReady(active, DataSource.MEMORY_CACHE);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +import com.bumptech.glide.load.DataSource;, +  private DataSource dataSource;, +      cb.onResourceReady(engineResource, dataSource);, +        cb.onResourceReady(engineResource, dataSource);, +    dataSource = null;, +  public void onResourceReady(Resource<R> resource, DataSource dataSource) {, +    this.dataSource = dataSource;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private void notifyComplete(Resource<R> resource, DataSource dataSource) {, +    callback.onResourceReady(resource, dataSource);, +      notifyEncodeAndRelease(resource, currentDataSource);, +  private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource) {, +    notifyComplete(result, dataSource);, +    void onResourceReady(Resource<R> resource, DataSource dataSource);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +import com.bumptech.glide.load.DataSource;, +      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);, +      cb.onResourceReady(active, DataSource.MEMORY_CACHE);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +import com.bumptech.glide.load.DataSource;, +  private DataSource dataSource;, +      cb.onResourceReady(engineResource, dataSource);, +        cb.onResourceReady(engineResource, dataSource);, +    dataSource = null;, +  public void onResourceReady(Resource<R> resource, DataSource dataSource) {, +    this.dataSource = dataSource;, +++ b/library/src/main/java/com/bumptech/glide/request/ResourceCallback.java, +import com.bumptech.glide.load.DataSource;, +  void onResourceReady(Resource<?> resource, DataSource dataSource);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private void notifyComplete(Resource<R> resource, DataSource dataSource) {, +    callback.onResourceReady(resource, dataSource);, +      notifyEncodeAndRelease(resource, currentDataSource);, +  private void notifyEncodeAndRelease(Resource<R> resource, DataSource dataSource) {, +    notifyComplete(result, dataSource);, +    void onResourceReady(Resource<R> resource, DataSource dataSource);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +import com.bumptech.glide.load.DataSource;, +      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);, +      cb.onResourceReady(active, DataSource.MEMORY_CACHE);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +import com.bumptech.glide.load.DataSource;, +  private DataSource dataSource;, +      cb.onResourceReady(engineResource, dataSource);, +        cb.onResourceReady(engineResource, dataSource);, +    dataSource = null;, +  public void onResourceReady(Resource<R> resource, DataSource dataSource) {, +    this.dataSource = dataSource;, +++ b/library/src/main/java/com/bumptech/glide/request/ResourceCallback.java, +import com.bumptech.glide.load.DataSource;, +  void onResourceReady(Resource<?> resource, DataSource dataSource);, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +import com.bumptech.glide.load.DataSource;, +  private int width;, +  private int height;, +    width = -1;, +    height = -1;, +    this.width = Math.round(sizeMultiplier * width);, +    this.height = Math.round(sizeMultiplier * height);, +        this.width,, +        this.height,, +  public void onResourceReady(Resource<?> resource, DataSource dataSource) {, +    onResourceReady((Resource<R>) resource, (R) received, dataSource);, +   * Internal {@link #onResourceReady(Resource, DataSource)} where arguments are known to be safe., +  private void onResourceReady(Resource<R> resource, R result, DataSource dataSource) {, +    if (Log.isLoggable(TAG, Log.VERBOSE)) {, +      Log.v(TAG, "Finished loading " + result.getClass().getSimpleName() + " from " + dataSource, +          + " for " + model + " with size [" + width + "x" + height + "] in ", +          + LogTime.getElapsedMillis(startTime) + " ms");, +    }]
[+++ b/integration/gifencoder/build.gradle, +    androidTestCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}", +++ b/integration/gifencoder/build.gradle, +    androidTestCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}", +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/integration/gifencoder/build.gradle, +    androidTestCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}", +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestBuilderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/integration/gifencoder/build.gradle, +    androidTestCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}", +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestBuilderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java, +import org.robolectric.RobolectricTestRunner;, +  @Rule public ExpectedException exception = ExpectedException.none();, +++ b/integration/gifencoder/build.gradle, +    androidTestCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}", +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestBuilderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java, +import org.robolectric.RobolectricTestRunner;, +  @Rule public ExpectedException exception = ExpectedException.none();, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/integration/gifencoder/build.gradle, +    androidTestCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}", +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestBuilderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java, +import org.robolectric.RobolectricTestRunner;, +  @Rule public ExpectedException exception = ExpectedException.none();, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/request/RequestFutureTargetTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/integration/gifencoder/build.gradle, +    androidTestCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}", +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestBuilderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java, +import org.robolectric.RobolectricTestRunner;, +  @Rule public ExpectedException exception = ExpectedException.none();, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/request/RequestFutureTargetTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/request/target/PreloadTargetTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/integration/gifencoder/build.gradle, +    androidTestCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}", +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestBuilderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java, +import org.robolectric.RobolectricTestRunner;, +  @Rule public ExpectedException exception = ExpectedException.none();, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/request/RequestFutureTargetTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/request/target/PreloadTargetTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +    File cacheFile = null;, +++ b/integration/gifencoder/build.gradle, +    androidTestCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}", +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestBuilderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java, +import org.robolectric.RobolectricTestRunner;, +  @Rule public ExpectedException exception = ExpectedException.none();, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/request/RequestFutureTargetTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/request/target/PreloadTargetTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +    File cacheFile = null;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java, +    File cacheFile = null;, +++ b/integration/gifencoder/build.gradle, +    androidTestCompile "com.android.support:support-v4:${SUPPORT_V4_VERSION}", +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import org.robolectric.RobolectricTestRunner;]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java, +        public BitmapSubject createSubject(, +            @NonNull FailureMetadata metadata, @NonNull Bitmap actual) {]
[+++ b/samples/svg/src/main/res/layout/activity_main.xml, +    <TextView, +        android:id="@+id/description", +        android:layout_width="wrap_content", +        android:layout_height="wrap_content", +        android:layout_marginBottom="@dimen/activity_vertical_margin", +        android:onClick="clearCache", +        android:clickable="true", +        android:text="@string/hello_world", +    />, +, +    <Button, +        android:id="@+id/button", +        android:layout_width="wrap_content", +        android:layout_height="wrap_content", +        android:layout_alignParentBottom="true", +        android:layout_centerHorizontal="true", +        android:layout_marginTop="@dimen/activity_vertical_margin", +        android:onClick="cycleScaleType", +        android:text="@string/scaleType", +    />, +, +        android:layout_below="@id/description", +        android:layout_above="@id/button", +        android:layout_below="@id/description", +        android:layout_above="@id/button"]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java, +package com.bumptech.glide;, +, +, +import static com.google.common.truth.Truth.assertThat;, +import static org.junit.Assert.fail;, +, +import android.content.Context;, +import android.support.test.InstrumentationRegistry;, +import android.support.test.runner.AndroidJUnit4;, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +import com.bumptech.glide.test.ConcurrencyHelper;, +import com.bumptech.glide.test.GlideApp;, +import com.bumptech.glide.test.MockModelLoader;, +import com.bumptech.glide.test.ResourceIds;, +import com.bumptech.glide.test.TearDownGlide;, +import java.io.ByteArrayInputStream;, +import java.io.ByteArrayOutputStream;, +import java.io.File;, +import java.io.IOException;, +import java.io.InputStream;, +import org.junit.Rule;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +, +@RunWith(AndroidJUnit4.class), +public class AsFileTest {, +  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();, +  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();, +  private final Context context = InstrumentationRegistry.getTargetContext();, +, +  @Test, +  public void asFile_withUrl_succeeds() {, +    String url = "https://www.w3schools.com/howto/img_fjords.jpg";, +, +    MockModelLoader.mock(url, getData());, +, +    File file =, +        concurrency.get(, +            GlideApp.with(context), +                .asFile(), +                .load("https://www.w3schools.com/howto/img_fjords.jpg"), +                .submit());, +    assertThat(file).isNotNull();, +  }, +, +  @Test, +  public void asFile_withUrlAndDiskCacheStrategyData_succeeds() {, +    String url = "https://www.w3schools.com/howto/img_fjords.jpg";, +, +    MockModelLoader.mock(url, getData());, +, +    File file =, +        concurrency.get(, +            GlideApp.with(context), +                .asFile(), +                .diskCacheStrategy(DiskCacheStrategy.DATA), +                .load("https://www.w3schools.com/howto/img_fjords.jpg"), +                .submit());, +    assertThat(file).isNotNull();, +  }, +, +  @Test, +  public void asFile_withUrlAndDiskCacheStrategyResource_fails() {, +    String url = "https://www.w3schools.com/howto/img_fjords.jpg";, +, +    MockModelLoader.mock(url, getData());, +, +    try {, +      concurrency.get(, +          GlideApp.with(context), +              .asFile(), +              .diskCacheStrategy(DiskCacheStrategy.RESOURCE), +              .load("https://www.w3schools.com/howto/img_fjords.jpg"), +              .submit());, +      fail();, +    } catch (RuntimeException e) {, +      // expected., +    }, +  }, +, +  @Test, +  public void asFile_withUrlAndDiskCacheStrategyAll_fails() {, +    String url = "https://www.w3schools.com/howto/img_fjords.jpg";, +, +    MockModelLoader.mock(url, getData());, +, +    try {, +      concurrency.get(, +          GlideApp.with(context), +              .asFile(), +              .diskCacheStrategy(DiskCacheStrategy.ALL), +              .load("https://www.w3schools.com/howto/img_fjords.jpg"), +              .submit());, +      fail();, +    } catch (RuntimeException e) {, +      // Expected., +    }, +  }, +]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java, +import org.mockito.ArgumentMatchers;, +  @Test, +  public void loadFromBuilder_withDataDiskCacheStrategy_returnsFromSource() throws IOException {, +    byte[] data = getCanonicalBytes();, +, +    concurrency.wait(, +        GlideApp.with(context), +            .asDrawable(), +            .diskCacheStrategy(DiskCacheStrategy.DATA), +            .load(data), +            .submit());, +, +    concurrency.wait(, +        GlideApp.with(context), +            .asDrawable(), +            .diskCacheStrategy(DiskCacheStrategy.DATA), +            .skipMemoryCache(true), +            .load(data), +            .listener(requestListener), +            .submit());, +, +    verify(requestListener).onResourceReady(, +        anyDrawable(),, +        ArgumentMatchers.any(),, +        anyDrawableTarget(),, +        eq(DataSource.DATA_DISK_CACHE),, +        anyBoolean());, +  }, +]
[+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java, +import com.bumptech.glide.request.RequestListener;, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +    return (GlideRequests) super.addDefaultRequestListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java, +import com.bumptech.glide.request.RequestListener;, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +    return (GlideRequests) super.addDefaultRequestListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java, +import com.bumptech.glide.request.RequestListener;, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +    return (GlideRequests) super.addDefaultRequestListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java, +import com.bumptech.glide.request.RequestListener;, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +    return (GlideRequests) super.addDefaultRequestListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java, +import com.bumptech.glide.request.RequestListener;, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +    return (GlideRequests) super.addDefaultRequestListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideRequests.java, +import com.bumptech.glide.request.RequestListener;, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +    return (GlideRequests) super.addDefaultRequestListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java, +import com.bumptech.glide.request.RequestListener;, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +    return (GlideRequests) super.addDefaultRequestListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java, +import com.bumptech.glide.request.RequestListener;, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +    return (GlideRequests) super.addDefaultRequestListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideRequests.java, +import com.bumptech.glide.request.RequestListener;, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +    return (GlideRequests) super.addDefaultRequestListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +  // We only override the method to change the return type, not the functionality., +  @SuppressWarnings("PMD.ConstructorCallsOverridableMethod"), +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java, +import com.bumptech.glide.request.RequestListener;, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +    return (GlideRequests) super.addDefaultRequestListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java, +import com.bumptech.glide.request.RequestListener;, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +    return (GlideRequests) super.addDefaultRequestListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/GlideRequests.java, +import com.bumptech.glide.request.RequestListener;, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +    return (GlideRequests) super.addDefaultRequestListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java]
[+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java, +  // Maximum size is 256, see GifHeaderParser.readColorTable, +  // Private color table that can be modified if needed, +  private final int[] pct = new int[256];, +    act = currentFrame.lct != null ? currentFrame.lct : header.gct;, +      // Prepare local copy of color table ("pct = act"), see #1068, +      System.arraycopy(act, 0, pct, 0, act.length);, +      // Forget about act reference from shared header object, use copied version, +      act = pct;, +      // Set transparent color if specified., +      act[currentFrame.transIndex] = 0;, +    // Transfer pixel data to image., +    return setPixels(currentFrame, previousFrame);, +          if (currentFrame.lct != null && header.bgIndex == currentFrame.transIndex) {, +            c = 0;, +          }]
[+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +   * <p>Note #{@link #resumeRequests()} must be called for any requests made before or while the, +   * manager is paused to complete. RequestManagers attached to Fragments and Activities, +   * automatically resume onStart()., +   *, +   * Cancels any in progress loads and clears resources of completed loads., +   *, +   * <p>Note #{@link #resumeRequests()} must be called for any requests made before or while the, +   * manager is paused to complete. RequestManagers attached to Fragments and Activities, +   * automatically resume onStart()., +   *, +   * <p>This will release the memory used by completed bitmaps but leaves them in any configured, +   * caches. When an #{@link android.app.Activity} receives #{@link, +   * android.app.Activity#onTrimMemory(int)} at a level of #{@link, +   * android.content.ComponentCallbacks2#TRIM_MEMORY_BACKGROUND} this is desirable in order to keep, +   * your process alive longer., +   *, +   * @see #isPaused(), +   * @see #resumeRequests(), +   */, +  public void pauseAllRequests() {, +    Util.assertMainThread();, +    requestTracker.pauseAllRequests();, +  }, +, +  /**, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +   * <p>Note #{@link #resumeRequests()} must be called for any requests made before or while the, +   * manager is paused to complete. RequestManagers attached to Fragments and Activities, +   * automatically resume onStart()., +   *, +   * Cancels any in progress loads and clears resources of completed loads., +   *, +   * <p>Note #{@link #resumeRequests()} must be called for any requests made before or while the, +   * manager is paused to complete. RequestManagers attached to Fragments and Activities, +   * automatically resume onStart()., +   *, +   * <p>This will release the memory used by completed bitmaps but leaves them in any configured, +   * caches. When an #{@link android.app.Activity} receives #{@link, +   * android.app.Activity#onTrimMemory(int)} at a level of #{@link, +   * android.content.ComponentCallbacks2#TRIM_MEMORY_BACKGROUND} this is desirable in order to keep, +   * your process alive longer., +   *, +   * @see #isPaused(), +   * @see #resumeRequests(), +   */, +  public void pauseAllRequests() {, +    Util.assertMainThread();, +    requestTracker.pauseAllRequests();, +  }, +, +  /**, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java, +  /** Stops any in progress requests and releases bitmaps associated with completed requests. */, +  public void pauseAllRequests() {, +    isPaused = true;, +    for (Request request : Util.getSnapshot(requests)) {, +      if (request.isRunning() || request.isComplete()) {, +        request.pause();, +        pendingRequests.add(request);, +      }, +    }, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +   * <p>Note #{@link #resumeRequests()} must be called for any requests made before or while the, +   * manager is paused to complete. RequestManagers attached to Fragments and Activities, +   * automatically resume onStart()., +   *, +   * Cancels any in progress loads and clears resources of completed loads., +   *, +   * <p>Note #{@link #resumeRequests()} must be called for any requests made before or while the, +   * manager is paused to complete. RequestManagers attached to Fragments and Activities, +   * automatically resume onStart()., +   *, +   * <p>This will release the memory used by completed bitmaps but leaves them in any configured, +   * caches. When an #{@link android.app.Activity} receives #{@link, +   * android.app.Activity#onTrimMemory(int)} at a level of #{@link, +   * android.content.ComponentCallbacks2#TRIM_MEMORY_BACKGROUND} this is desirable in order to keep, +   * your process alive longer., +   *, +   * @see #isPaused(), +   * @see #resumeRequests(), +   */, +  public void pauseAllRequests() {, +    Util.assertMainThread();, +    requestTracker.pauseAllRequests();, +  }, +, +  /**, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java, +  /** Stops any in progress requests and releases bitmaps associated with completed requests. */, +  public void pauseAllRequests() {, +    isPaused = true;, +    for (Request request : Util.getSnapshot(requests)) {, +      if (request.isRunning() || request.isComplete()) {, +        request.pause();, +        pendingRequests.add(request);, +      }, +    }]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }, +    }, +}, +, +subprojects {, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = 1.7, +        targetCompatibility = 1.7, +    }, +}, +, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    // When request was failed or cancelled, be sure to use the updated model as it can contains, +    // unexposed data that could help the request to succeed on restart., +    // See https://github.com/bumptech/glide/issues/2270, +    if (request.isEquivalentTo(previous), +      && (Preconditions.checkNotNull(previous).isComplete(), +         || Preconditions.checkNotNull(previous).isRunning())) {, +      // triggering RequestListeners and Targets. If the request is already]
[+++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoWrapperEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoWrapperEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoWrapperEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoWrapperEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoWrapperEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullResourceEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoWrapperEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullResourceEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoWrapperEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullResourceEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoWrapperEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullResourceEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoWrapperEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullResourceEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoWrapperEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullResourceEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoWrapperEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullResourceEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawableEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoWrapperEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullResourceEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FileDescriptorBitmapDecoder.java]
[+++ b/library/src/com/bumptech/glide/Glide.java, +import android.graphics.Bitmap;, +import com.bumptech.glide.loader.bitmap.BaseBitmapLoadFactory;, +import com.bumptech.glide.loader.bitmap.model.BaseUrlLoader;, +import com.bumptech.glide.loader.bitmap.model.ResourceLoader;, +import com.bumptech.glide.loader.bitmap.model.FileLoader;, +import com.bumptech.glide.loader.bitmap.model.GenericLoaderFactory;, +import com.bumptech.glide.loader.bitmap.model.ModelLoader;, +import com.bumptech.glide.loader.bitmap.model.ModelLoaderFactory;, +import com.bumptech.glide.loader.bitmap.model.StringLoader;, +import com.bumptech.glide.loader.bitmap.model.UriLoader;, +import com.bumptech.glide.loader.bitmap.resource.ResourceFetcher;, +import com.bumptech.glide.loader.bitmap.transformation.CenterCrop;, +import com.bumptech.glide.loader.bitmap.transformation.FitCenter;, +import com.bumptech.glide.loader.bitmap.transformation.MultiTransformationLoader;, +import com.bumptech.glide.loader.bitmap.transformation.None;, +import com.bumptech.glide.loader.bitmap.transformation.TransformationLoader;, +import com.bumptech.glide.resize.load.BitmapDecoder;, +import java.io.InputStream;, +        loaderFactory.register(File.class, InputStream.class, new FileLoader.Factory());, +        loaderFactory.register(Integer.class, InputStream.class, new ResourceLoader.Factory());, +        loaderFactory.register(String.class, InputStream.class, new StringLoader.Factory());, +        loaderFactory.register(Uri.class, InputStream.class, new UriLoader.Factory());, +            loaderFactory.register(URL.class, InputStream.class, new VolleyUrlLoader.Factory());, +            loaderFactory.register(URL.class, InputStream.class, new ModelLoaderFactory<URL, InputStream>() {, +                ModelLoader<URL, InputStream> errorUrlLoader = new ModelLoader<URL, InputStream>() {, +, +                    public ResourceFetcher<InputStream> getResourceFetcher(URL model, int width, int height) {, +                public ModelLoader<URL, InputStream> build(Context context, GenericLoaderFactory factories) {, +                public Class<? extends ModelLoader<URL, InputStream>> loaderClass() {, +                    return (Class<ModelLoader<URL, InputStream>>) errorUrlLoader.getClass();, +     * models. Typically the {@link Glide#using(ModelLoader)} syntax is preferred, +     *     used for any other model class, {@link ModelLoaderFactory#teardown()}, +    public <T> void register(Class<T> clazz, ModelLoaderFactory<T, InputStream> factory) {, +        ModelLoaderFactory<T, InputStream> removed = loaderFactory.register(clazz, InputStream.class, factory);, +     * @param modelClass The class to get a {@link ModelLoader} for, +    public static <T, Y> ModelLoader<T, Y> buildModelLoader(Class<T> modelClass, Class<Y> resourceClass, Context context) {, +        return GLIDE.loaderFactory.buildModelLoader(modelClass, resourceClass, context);, +    private <T, Y> ModelLoaderFactory<T, Y> getFactory(T model, Class<Y> resourceClass) {, +        return loaderFactory.getFactory((Class<T>) model.getClass(), resourceClass);, +     *     {@link #register(Class, ModelLoaderFactory)}., +     *     of {@link BaseUrlLoader}, +    public static <T, Y> ModelRequest<T, Y> using(ModelLoaderFactory<T, Y> factory) {, +        return new ModelRequest<T, Y>(factory);, +     * @see #using(ModelLoaderFactory), +     * @param <Y> the type of resource the model loader can translate from a given model., +    public static <T, Y> ModelRequest<T, Y> usingGeneric(final ModelLoader<T, Y> modelLoader) {, +        return new ModelRequest<T, Y>(new ModelLoaderFactory<T, Y>() {, +, +            public ModelLoader<T, Y> build(Context context, GenericLoaderFactory factories) {, +            @SuppressWarnings("unchecked"), +            @Override, +            public Class<? extends ModelLoader<T, Y>> loaderClass() {, +                return (Class<ModelLoader<T, Y>>) modelLoader.getClass();, +     * Set the {@link ModelLoader} to use for for a new load where the model loader translates from a model to an, +     * {@link InputStream} resource., +     *, +     * @param modelLoader The model loader to use., +     * @param <T> The type of the model., +     * @return A new {@link StreamModelRequest}., +     */, +    public static <T> StreamModelRequest<T> using(final ModelLoader<T, InputStream> modelLoader) {, +        return new StreamModelRequest<T>(new ModelLoaderFactory<T, InputStream>() {, +            @Override, +            public ModelLoader<T, InputStream> build(Context context, GenericLoaderFactory factories) {, +                return modelLoader;, +            }, +, +            @SuppressWarnings("unchecked"), +            @Override, +            public Class<? extends ModelLoader<T, InputStream>> loaderClass() {, +                return (Class<ModelLoader<T, InputStream>>) modelLoader.getClass();, +            }, +, +            @Override, +            public void teardown() { }, +        });, +, +    }, +, +    /**, +    public static StreamRequest<String> load(String string) {, +        return new StreamRequest<String>(string);, +    public static StreamRequest<Uri> load(Uri uri) {, +        return new StreamRequest<Uri>(uri);, +    public static StreamRequest<URL> load(URL url) {, +        return new StreamRequest<URL>(url);, +    public static StreamRequest<File> load(File file) {, +        return new StreamRequest<File>(file);, +    public static StreamRequest<Integer> load(Integer resourceId) {, +        return new StreamRequest<Integer>(resourceId);, +    public static <T> StreamRequest<T> load(T model) {, +        return new StreamRequest<T>(model);, +     * A helper class for building requests with custom {@link ModelLoader}s that translate models to, +     * {@link InputStream} resources., +     *, +     * @param <T> The type of the model., +     */, +    public static class StreamModelRequest<T> {, +        private final ModelLoaderFactory<T, InputStream> factory;]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifOptions.java, +      "com.bumptech.glide.load.resource.gif.GifOptions.DecodeFormat", DecodeFormat.DEFAULT);, +      "com.bumptech.glide.load.resource.gif.GifOptions.DisableAnimation", false);]
[+++ b/library/AndroidManifest.xml, +          android:versionCode="5", +          android:versionName="2.0.3" >]
[+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java, +      int newPosition = Math.min(rawData.position() + blockSize, rawData.limit());, +      rawData.position(newPosition);]
[+++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +   *, +   * @deprecated If you must disable hardware bitmaps, set, +   * {@link com.bumptech.glide.load.resource.bitmap.Downsampler#ALLOW_HARDWARE_CONFIG} to false, +   * instead., +  @Deprecated, +  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888;, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +   *, +   * @deprecated If you must disable hardware bitmaps, set, +   * {@link com.bumptech.glide.load.resource.bitmap.Downsampler#ALLOW_HARDWARE_CONFIG} to false, +   * instead., +  @Deprecated, +  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +import android.graphics.Bitmap;, +  boolean isBitmapTransformationSet() {, +    return transformations.get(Bitmap.class) != null;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +   *, +   * @deprecated If you must disable hardware bitmaps, set, +   * {@link com.bumptech.glide.load.resource.bitmap.Downsampler#ALLOW_HARDWARE_CONFIG} to false, +   * instead., +  @Deprecated, +  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +import android.graphics.Bitmap;, +  boolean isBitmapTransformationSet() {, +    return transformations.get(Bitmap.class) != null;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +import android.os.Build;, +import com.bumptech.glide.load.resource.bitmap.Downsampler;, +  private Options getOptionsWithHardwareConfig(DataSource dataSource) {, +    Options options = this.options;, +    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {, +      return options;, +    }, +, +    if (options.get(Downsampler.ALLOW_HARDWARE_CONFIG) != null) {, +      return options;, +    }, +, +    if (dataSource == DataSource.RESOURCE_DISK_CACHE, +        || !decodeHelper.isBitmapTransformationSet()) {, +      options = new Options();, +      options.putAll(this.options);, +      options.set(Downsampler.ALLOW_HARDWARE_CONFIG, true);, +    }, +    return options;, +  }, +, +    Options options = getOptionsWithHardwareConfig(dataSource);, +      return path.load(rewinder, options, width, height, new DecodeCallback<>(dataSource));, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +   *, +   * @deprecated If you must disable hardware bitmaps, set, +   * {@link com.bumptech.glide.load.resource.bitmap.Downsampler#ALLOW_HARDWARE_CONFIG} to false, +   * instead., +  @Deprecated, +  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +import android.graphics.Bitmap;, +  boolean isBitmapTransformationSet() {, +    return transformations.get(Bitmap.class) != null;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +import android.os.Build;, +import com.bumptech.glide.load.resource.bitmap.Downsampler;, +  private Options getOptionsWithHardwareConfig(DataSource dataSource) {, +    Options options = this.options;, +    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {, +      return options;, +    }, +, +    if (options.get(Downsampler.ALLOW_HARDWARE_CONFIG) != null) {, +      return options;, +    }, +, +    if (dataSource == DataSource.RESOURCE_DISK_CACHE, +        || !decodeHelper.isBitmapTransformationSet()) {, +      options = new Options();, +      options.putAll(this.options);, +      options.set(Downsampler.ALLOW_HARDWARE_CONFIG, true);, +    }, +    return options;, +  }, +, +    Options options = getOptionsWithHardwareConfig(dataSource);, +      return path.load(rewinder, options, width, height, new DecodeCallback<>(dataSource));, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    // Avoid short circuiting on sdk int since it breaks on some versions of Android., +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {, +      if (config == Bitmap.Config.HARDWARE) {, +        throw new IllegalArgumentException("Cannot create a mutable Bitmap with config: " + config, +            + ". Consider setting Downsampler#ALLOW_HARDWARE_CONFIG to false in your RequestOptions"]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java, +import com.bumptech.glide.util.Util;, +    return TransformationUtils.roundedCorners(pool, toTransform, roundingRadius);, +    if (o instanceof RoundedCorners) {, +      RoundedCorners other = (RoundedCorners) o;, +      return roundingRadius == other.roundingRadius;, +    }, +    return false;, +    return Util.hashCode(ID.hashCode(),, +        Util.hashCode(roundingRadius));, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java, +import com.bumptech.glide.util.Util;, +    return TransformationUtils.roundedCorners(pool, toTransform, roundingRadius);, +    if (o instanceof RoundedCorners) {, +      RoundedCorners other = (RoundedCorners) o;, +      return roundingRadius == other.roundingRadius;, +    }, +    return false;, +    return Util.hashCode(ID.hashCode(),, +        Util.hashCode(roundingRadius));, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java, +import com.bumptech.glide.load.Transformation;, +   *, +   * @deprecated Width and height are unused and ignored. Use, +   * {@link #roundedCorners(BitmapPool, Bitmap, int)} instead., +  @Deprecated, +  public static Bitmap roundedCorners(, +      @NonNull BitmapPool pool,, +      @NonNull Bitmap inBitmap,, +      @SuppressWarnings("unused") int width,, +      @SuppressWarnings("unused") int height,, +      int roundingRadius) {, +    return roundedCorners(pool, inBitmap, roundingRadius);, +  }, +, +  /**, +   * Creates a bitmap from a source bitmap and rounds the corners., +   *, +   * <p>This method does <em>NOT</em> resize the given {@link Bitmap}, it only rounds it's corners., +   * To both resize and round the corners of an image, consider, +   * {@link com.bumptech.glide.request.RequestOptions#transforms(Transformation[])} and/or, +   * {@link com.bumptech.glide.load.MultiTransformation}., +   *, +   * @param inBitmap the source bitmap to use as a basis for the created bitmap., +   * @param roundingRadius the corner radius to be applied (in device-specific pixels)., +   * @return a {@link Bitmap} similar to inBitmap but with rounded corners., +   * @throws IllegalArgumentException if roundingRadius, width or height is 0 or less., +   */, +  public static Bitmap roundedCorners(, +      @NonNull BitmapPool pool, @NonNull Bitmap inBitmap, int roundingRadius) {, +    Bitmap result =, +        pool.get(toTransform.getWidth(), toTransform.getHeight(), Bitmap.Config.ARGB_8888);]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import java.util.Map;, +      RequestOptions defaultRequestOptions,, +      Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions) {, +            context, registry, imageViewTargetFactory, defaultRequestOptions,, +            defaultTransitionOptions, engine, logLevel);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import java.util.Map;, +      RequestOptions defaultRequestOptions,, +      Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions) {, +            context, registry, imageViewTargetFactory, defaultRequestOptions,, +            defaultTransitionOptions, engine, logLevel);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import android.support.annotation.NonNull;, +import android.support.v4.util.ArrayMap;, +import java.util.Map;, +  private final Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions = new ArrayMap<>();, +   * Sets the default {@link TransitionOptions} to use when starting a request that will load a, +   * resource with the given {@link Class}., +   *, +   * <p>It's preferable but not required for the requested resource class to match the resource, +   * class applied here as long as the resource class applied here is assignable from the requested, +   * resource class. For example you can set a default transition for, +   * {@link android.graphics.drawable.Drawable} and that default transition will be used if you, +   * subsequently start requests for specific {@link android.graphics.drawable.Drawable} types like, +   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} or, +   * {@link android.graphics.drawable.BitmapDrawable}. Specific types are always preferred so if you, +   * register a default transition for both {@link android.graphics.drawable.Drawable} and, +   * {@link android.graphics.drawable.BitmapDrawable} and then start a request for, +   * {@link android.graphics.drawable.BitmapDrawable}s, the transition you registered for, +   * {@link android.graphics.drawable.BitmapDrawable}s will be used., +   */, +  public <T> GlideBuilder setDefaultTransitionOptions(, +      @NonNull Class<T> clazz, @Nullable TransitionOptions<?, T> options) {, +    defaultTransitionOptions.put(clazz, options);, +    return this;, +  }, +, +  /**, +        defaultRequestOptions.lock(),, +        defaultTransitionOptions);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import java.util.Map;, +      RequestOptions defaultRequestOptions,, +      Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions) {, +            context, registry, imageViewTargetFactory, defaultRequestOptions,, +            defaultTransitionOptions, engine, logLevel);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import android.support.annotation.NonNull;, +import android.support.v4.util.ArrayMap;, +import java.util.Map;, +  private final Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions = new ArrayMap<>();, +   * Sets the default {@link TransitionOptions} to use when starting a request that will load a, +   * resource with the given {@link Class}., +   *, +   * <p>It's preferable but not required for the requested resource class to match the resource, +   * class applied here as long as the resource class applied here is assignable from the requested, +   * resource class. For example you can set a default transition for, +   * {@link android.graphics.drawable.Drawable} and that default transition will be used if you, +   * subsequently start requests for specific {@link android.graphics.drawable.Drawable} types like, +   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} or, +   * {@link android.graphics.drawable.BitmapDrawable}. Specific types are always preferred so if you, +   * register a default transition for both {@link android.graphics.drawable.Drawable} and, +   * {@link android.graphics.drawable.BitmapDrawable} and then start a request for, +   * {@link android.graphics.drawable.BitmapDrawable}s, the transition you registered for, +   * {@link android.graphics.drawable.BitmapDrawable}s will be used., +   */, +  public <T> GlideBuilder setDefaultTransitionOptions(, +      @NonNull Class<T> clazz, @Nullable TransitionOptions<?, T> options) {, +    defaultTransitionOptions.put(clazz, options);, +    return this;, +  }, +, +  /**, +        defaultRequestOptions.lock(),, +        defaultTransitionOptions);, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +import android.support.annotation.NonNull;, +import android.support.annotation.VisibleForTesting;, +import java.util.Map;, +import java.util.Map.Entry;, +  @VisibleForTesting, +  static final TransitionOptions<?, ?> DEFAULT_TRANSITION_OPTIONS =, +      new GenericTransitionOptions<Object>();, +  private final Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions;, +      Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions, Engine engine,, +      int logLevel) {, +    this.defaultTransitionOptions = defaultTransitionOptions;, +  @SuppressWarnings("unchecked"), +  @NonNull, +  public <T> TransitionOptions<?, T> getDefaultTransitionOptions(Class<T> transcodeClass) {, +    TransitionOptions<?, ?> result = defaultTransitionOptions.get(transcodeClass);, +    if (result == null) {, +      for (Entry<Class<?>, TransitionOptions<?, ?>> value : defaultTransitionOptions.entrySet()) {, +        if (value.getKey().isAssignableFrom(transcodeClass)) {, +          result = value.getValue();, +        }, +      }, +    }, +    if (result == null) {]
[+++ b/library/src/androidTest/java/com/bumptech/glide/util/TransformationUtilsTest.java, +import org.robolectric.annotation.Config;, +import org.robolectric.annotation.Implementation;, +import org.robolectric.annotation.Implements;, +import org.robolectric.shadows.ShadowBitmap;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertTrue;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.when;, +@Config(shadows = { TransformationUtilsTest.AlphaShadowBitmap.class }), +    @Test, +    public void testCenterCropSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmapIsReused() {, +        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +, +        Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);, +, +        toReuse.setHasAlpha(false);, +        toTransform.setHasAlpha(true);, +, +        Bitmap result = TransformationUtils.centerCrop(toReuse, toTransform, toReuse.getWidth(), toReuse.getHeight());, +, +        assertEquals(toReuse, result);, +        assertTrue(result.hasAlpha());, +    }, +, +    @Test, +    public void testCenterCropSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlphaAndOutBitmapIsReused() {, +        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +, +        Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);, +, +        toReuse.setHasAlpha(true);, +        toTransform.setHasAlpha(false);, +, +        Bitmap result = TransformationUtils.centerCrop(toReuse, toTransform, toReuse.getWidth(), toReuse.getHeight());, +, +        assertEquals(toReuse, result);, +        assertFalse(result.hasAlpha());, +    }, +, +    @Test, +    public void testCenterCropSetsOutBitmapToHaveAlphaIfInBitmapHasAlpha() {, +        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +        BitmapPool pool = mock(BitmapPool.class);, +, +        toTransform.setHasAlpha(true);, +, +        Bitmap result = TransformationUtils.centerCrop(null, toTransform, toTransform.getWidth() / 2,, +                toTransform.getHeight() / 2);, +, +        assertTrue(result.hasAlpha());, +    }, +, +    @Test, +    public void testSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlpha() {, +        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +, +        toTransform.setHasAlpha(false);, +, +        Bitmap result = TransformationUtils.centerCrop(null, toTransform, toTransform.getWidth() / 2,, +                toTransform.getHeight() / 2);, +, +        assertFalse(result.hasAlpha());, +    }, +, +    @Test, +    public void testFitCenterSetsOutBitmapToHaveAlphaIfInBitmapHasAlphaAndOutBitmapIsReused() {, +        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +, +        Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);, +        BitmapPool bitmapPool = mock(BitmapPool.class);, +        when(bitmapPool.get(eq(toReuse.getWidth()), eq(toReuse.getHeight()), eq(toReuse.getConfig()))), +                .thenReturn(toReuse);, +, +        toReuse.setHasAlpha(false);, +        toTransform.setHasAlpha(true);, +, +        Bitmap result = TransformationUtils.fitCenter(toTransform, bitmapPool, toReuse.getWidth(), toReuse.getHeight());, +, +        assertEquals(toReuse, result);, +        assertTrue(result.hasAlpha());, +    }, +, +    @Test, +    public void testFitCenterSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlphaAndOutBitmapIsReused() {, +        Bitmap toTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +, +        Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);, +        BitmapPool bitmapPool = mock(BitmapPool.class);, +        when(bitmapPool.get(eq(toReuse.getWidth()), eq(toReuse.getHeight()), eq(toReuse.getConfig()))), +                .thenReturn(toReuse);, +, +        toReuse.setHasAlpha(true);, +        toTransform.setHasAlpha(false);, +, +        Bitmap result = TransformationUtils.fitCenter(toTransform, bitmapPool, toReuse.getWidth(), toReuse.getHeight());, +, +        assertEquals(toReuse, result);, +        assertFalse(result.hasAlpha());]
[+++ b/library/src/main/java/com/bumptech/glide/OriginalEngineKey.java, +package com.bumptech.glide;, +, +import com.bumptech.glide.load.Key;, +, +import java.io.UnsupportedEncodingException;, +import java.security.MessageDigest;, +, +public class OriginalEngineKey implements Key {, +    private String id;, +, +    public OriginalEngineKey(String id) {, +        this.id = id;, +    }, +, +    @Override, +    public boolean equals(Object o) {, +        if (this == o) {, +            return true;, +        }, +        if (!(o instanceof OriginalEngineKey)) {, +            return false;, +        }, +, +        OriginalEngineKey that = (OriginalEngineKey) o;, +, +        if (!id.equals(that.id)) {, +            return false;, +        }, +, +        return true;, +    }, +, +    @Override, +    public int hashCode() {, +        return id.hashCode();, +    }, +, +    @Override, +    public void updateDiskCacheKey(MessageDigest messageDigest) throws UnsupportedEncodingException {, +        messageDigest.update(id.getBytes("UTF-8"));, +    }, +}, +++ b/library/src/main/java/com/bumptech/glide/OriginalEngineKey.java, +package com.bumptech.glide;, +, +import com.bumptech.glide.load.Key;, +, +import java.io.UnsupportedEncodingException;, +import java.security.MessageDigest;, +, +public class OriginalEngineKey implements Key {, +    private String id;, +, +    public OriginalEngineKey(String id) {, +        this.id = id;, +    }, +, +    @Override, +    public boolean equals(Object o) {, +        if (this == o) {, +            return true;, +        }, +        if (!(o instanceof OriginalEngineKey)) {, +            return false;, +        }, +, +        OriginalEngineKey that = (OriginalEngineKey) o;, +, +        if (!id.equals(that.id)) {, +            return false;, +        }, +, +        return true;, +    }, +, +    @Override, +    public int hashCode() {, +        return id.hashCode();, +    }, +, +    @Override, +    public void updateDiskCacheKey(MessageDigest messageDigest) throws UnsupportedEncodingException {, +        messageDigest.update(id.getBytes("UTF-8"));, +    }, +}, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DefaultResourceRunnerFactory.java, +    public <T, Z, R> ResourceRunner<Z, R> build(EngineKey key, int width, int height,, +        SourceResourceRunner<T, Z, R> sourceRunner = new SourceResourceRunner<T, Z, R>(key, width, height, cacheLoader,, +                cacheDecoder, fetcher, decoder, transformation, encoder, transcoder, diskCache, priority, engineJob);, +++ b/library/src/main/java/com/bumptech/glide/OriginalEngineKey.java, +package com.bumptech.glide;, +, +import com.bumptech.glide.load.Key;, +, +import java.io.UnsupportedEncodingException;, +import java.security.MessageDigest;, +, +public class OriginalEngineKey implements Key {, +    private String id;]
[+++ b/.idea/codeStyleSettings.xml]
[+++ b/build.gradle, +                << "-Xlint:-classfile" \, +                /*, +                 * Disable deprecation warnings for ViewTarget/BaseTarget for now., +                 */ \, +                << "-Xlint:-deprecation", +, +            if (project.plugins.hasPlugin('net.ltgt.errorprone')) {, +                // It's often useful to track individual objects when debugging object pooling., +                options.compilerArgs << "-Xep:ObjectToString:OFF", +            }, +++ b/build.gradle, +                << "-Xlint:-classfile" \, +                /*, +                 * Disable deprecation warnings for ViewTarget/BaseTarget for now., +                 */ \, +                << "-Xlint:-deprecation", +, +            if (project.plugins.hasPlugin('net.ltgt.errorprone')) {, +                // It's often useful to track individual objects when debugging object pooling., +                options.compilerArgs << "-Xep:ObjectToString:OFF", +            }, +++ b/gradle.properties, +ERROR_PRONE_VERSION=2.3.1, +++ b/build.gradle, +                << "-Xlint:-classfile" \, +                /*, +                 * Disable deprecation warnings for ViewTarget/BaseTarget for now., +                 */ \, +                << "-Xlint:-deprecation", +, +            if (project.plugins.hasPlugin('net.ltgt.errorprone')) {, +                // It's often useful to track individual objects when debugging object pooling., +                options.compilerArgs << "-Xep:ObjectToString:OFF", +            }, +++ b/gradle.properties, +ERROR_PRONE_VERSION=2.3.1, +++ b/library/build.gradle, +, +    testImplementation "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}", +    testImplementation project(':testutil'), +    testImplementation 'com.google.guava:guava-testlib:18.0', +    testImplementation "com.google.truth:truth:${TRUTH_VERSION}", +    testImplementation "junit:junit:${JUNIT_VERSION}", +    testImplementation "org.mockito:mockito-core:${MOCKITO_VERSION}", +    testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}", +    testImplementation "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}", +    testImplementation "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}", +++ b/build.gradle, +                << "-Xlint:-classfile" \, +                /*, +                 * Disable deprecation warnings for ViewTarget/BaseTarget for now., +                 */ \, +                << "-Xlint:-deprecation", +, +            if (project.plugins.hasPlugin('net.ltgt.errorprone')) {, +                // It's often useful to track individual objects when debugging object pooling., +                options.compilerArgs << "-Xep:ObjectToString:OFF", +            }, +++ b/gradle.properties, +ERROR_PRONE_VERSION=2.3.1, +++ b/library/build.gradle, +, +    testImplementation "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}", +    testImplementation project(':testutil'), +    testImplementation 'com.google.guava:guava-testlib:18.0', +    testImplementation "com.google.truth:truth:${TRUTH_VERSION}", +    testImplementation "junit:junit:${JUNIT_VERSION}", +    testImplementation "org.mockito:mockito-core:${MOCKITO_VERSION}", +    testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}", +    testImplementation "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}", +    testImplementation "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}", +++ b/library/src/main/AndroidManifest.xml, +<manifest package="com.bumptech.glide">, +++ b/build.gradle, +                << "-Xlint:-classfile" \, +                /*, +                 * Disable deprecation warnings for ViewTarget/BaseTarget for now., +                 */ \, +                << "-Xlint:-deprecation", +, +            if (project.plugins.hasPlugin('net.ltgt.errorprone')) {, +                // It's often useful to track individual objects when debugging object pooling., +                options.compilerArgs << "-Xep:ObjectToString:OFF", +            }, +++ b/gradle.properties, +ERROR_PRONE_VERSION=2.3.1, +++ b/library/build.gradle, +, +    testImplementation "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}", +    testImplementation project(':testutil'), +    testImplementation 'com.google.guava:guava-testlib:18.0', +    testImplementation "com.google.truth:truth:${TRUTH_VERSION}", +    testImplementation "junit:junit:${JUNIT_VERSION}", +    testImplementation "org.mockito:mockito-core:${MOCKITO_VERSION}", +    testImplementation "org.robolectric:robolectric:${ROBOLECTRIC_VERSION}", +    testImplementation "com.squareup.okhttp3:mockwebserver:${MOCKWEBSERVER_VERSION}", +    testImplementation "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}", +++ b/library/src/main/AndroidManifest.xml, +<manifest package="com.bumptech.glide">]
[+++ b/checkstyle.xml, +        <module name="MethodName" >, +            <property name="format" value="^[a-z][a-zA-Z0-9]*(_[a-zA-Z0-9]+)*$"/>, +        </module>]
[+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java, +import android.support.annotation.NonNull;, +  public static File getPhotoCacheDir(Context arg0) {, +    return Glide.getPhotoCacheDir(arg0);, +  public static File getPhotoCacheDir(Context arg0, String arg1) {, +    return Glide.getPhotoCacheDir(arg0, arg1);, +  @NonNull, +  public static Glide get(Context arg0) {, +    return Glide.get(arg0);, +  public static void init(Context arg0, GlideBuilder arg1) {, +    Glide.init(arg0, arg1);, +  public static GlideRequests with(Context arg0) {, +    return (GlideRequests) Glide.with(arg0);, +  public static GlideRequests with(Activity arg0) {, +    return (GlideRequests) Glide.with(arg0);, +  public static GlideRequests with(FragmentActivity arg0) {, +    return (GlideRequests) Glide.with(arg0);, +  public static GlideRequests with(Fragment arg0) {, +    return (GlideRequests) Glide.with(arg0);, +  public static GlideRequests with(android.support.v4.app.Fragment arg0) {, +    return (GlideRequests) Glide.with(arg0);, +  public static GlideRequests with(View arg0) {, +    return (GlideRequests) Glide.with(arg0);, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java, +import android.support.annotation.NonNull;, +  public static File getPhotoCacheDir(Context arg0) {, +    return Glide.getPhotoCacheDir(arg0);, +  public static File getPhotoCacheDir(Context arg0, String arg1) {, +    return Glide.getPhotoCacheDir(arg0, arg1);, +  @NonNull, +  public static Glide get(Context arg0) {, +    return Glide.get(arg0);, +  public static void init(Context arg0, GlideBuilder arg1) {, +    Glide.init(arg0, arg1);, +  public static GlideRequests with(Context arg0) {, +    return (GlideRequests) Glide.with(arg0);, +  public static GlideRequests with(Activity arg0) {, +    return (GlideRequests) Glide.with(arg0);, +  public static GlideRequests with(FragmentActivity arg0) {, +    return (GlideRequests) Glide.with(arg0);, +  public static GlideRequests with(Fragment arg0) {, +    return (GlideRequests) Glide.with(arg0);, +  public static GlideRequests with(android.support.v4.app.Fragment arg0) {, +    return (GlideRequests) Glide.with(arg0);, +  public static GlideRequests with(View arg0) {, +    return (GlideRequests) Glide.with(arg0);, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java, +import android.support.annotation.NonNull;, +  public static File getPhotoCacheDir(Context arg0) {, +    return Glide.getPhotoCacheDir(arg0);, +  public static File getPhotoCacheDir(Context arg0, String arg1) {, +    return Glide.getPhotoCacheDir(arg0, arg1);, +  @NonNull, +  public static Glide get(Context arg0) {, +    return Glide.get(arg0);, +  public static void init(Context arg0, GlideBuilder arg1) {, +    Glide.init(arg0, arg1);, +  public static GlideRequests with(Context arg0) {, +    return (GlideRequests) Glide.with(arg0);, +  public static GlideRequests with(Activity arg0) {, +    return (GlideRequests) Glide.with(arg0);, +  public static GlideRequests with(FragmentActivity arg0) {, +    return (GlideRequests) Glide.with(arg0);, +  public static GlideRequests with(Fragment arg0) {, +    return (GlideRequests) Glide.with(arg0);, +  public static GlideRequests with(android.support.v4.app.Fragment arg0) {, +    return (GlideRequests) Glide.with(arg0);, +  public static GlideRequests with(View arg0) {, +    return (GlideRequests) Glide.with(arg0);, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null]
[+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java, +    super.onLoadStarted(placeholder);, +    super.onLoadFailed(errorDrawable);, +    super.onLoadCleared(placeholder);, +++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java, +    super.onLoadStarted(placeholder);, +    super.onLoadFailed(errorDrawable);, +    super.onLoadCleared(placeholder);, +++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java, +import android.graphics.drawable.Drawable;, + * <p> Subclasses must call super in {@link #onLoadCleared(Drawable)} </p>, + *, +  @Override, +  public void onLoadCleared(Drawable placeholder) {, +    super.onLoadCleared(placeholder);, +    sizeDeterminer.clearCallbacksAndListener();, +  }, +, +      clearCallbacksAndListener();, +    void getSize(SizeReadyCallback cb) {, +    void clearCallbacksAndListener() {, +      // Keep a reference to the layout listener and remove it here, +      // rather than having the observer remove itself because the observer, +      // we add the listener to will be almost immediately merged into, +      // another observer and will therefore never be alive. If we instead, +      // keep a reference to the listener and remove it here, we get the, +      // current view tree observer and should succeed., +      ViewTreeObserver observer = view.getViewTreeObserver();, +      if (observer.isAlive()) {, +        observer.removeOnPreDrawListener(layoutListener);, +      }, +      layoutListener = null;, +      cbs.clear();, +    }, +]
[+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +    Drawable error = null;, +    if (model == null) {, +      error = getFallbackDrawable();, +    }, +    // Either the model isn't null, or there was no fallback drawable set. Either way we should show, +    // the error Drawable., +      error = getErrorDrawable();, +    if (requestListener == null, +        || !requestListener.onLoadFailed(e, model, target, isFirstReadyResource())) {, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +    Drawable error = null;, +    if (model == null) {, +      error = getFallbackDrawable();, +    }, +    // Either the model isn't null, or there was no fallback drawable set. Either way we should show, +    // the error Drawable., +      error = getErrorDrawable();, +    if (requestListener == null, +        || !requestListener.onLoadFailed(e, model, target, isFirstReadyResource())) {, +++ b/library/src/test/java/com/bumptech/glide/GlideTest.java, +import static com.bumptech.glide.request.RequestOptions.errorOf;, +        .apply(errorOf(drawable)), +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +    Drawable error = null;, +    if (model == null) {, +      error = getFallbackDrawable();, +    }, +    // Either the model isn't null, or there was no fallback drawable set. Either way we should show, +    // the error Drawable., +      error = getErrorDrawable();, +    if (requestListener == null, +        || !requestListener.onLoadFailed(e, model, target, isFirstReadyResource())) {, +++ b/library/src/test/java/com/bumptech/glide/GlideTest.java, +import static com.bumptech.glide.request.RequestOptions.errorOf;, +        .apply(errorOf(drawable)), +++ b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java, +    harness.errorDrawable = placeholder;]
[+++ b/integration/volley/src/main/java/com/bumptech/glide/volley/VolleyDiskCacheWrapper.java, +, +import com.bumptech.glide.load.engine.cache.StringKey;, +import java.io.File;, +import java.io.FileInputStream;, +import java.io.FileNotFoundException;, +import java.io.FileOutputStream;, +        File file = diskCache.get(new StringKey(key));, +        if (file == null) {, +        InputStream is = null;, +            is = new FileInputStream(file);, +            CacheHeader header = readHeader(is);, +            byte[] data = streamToBytes(is);, +            if (is != null) {, +                    is.close();, +                } catch (IOException e) {, +                    // Do nothing., +                }, +            }, +            public boolean write(File file) {, +                OutputStream os = null;, +                boolean success = false;, +                    os = new FileOutputStream(file);, +                    CacheHeader header = new CacheHeader(key, entry);, +                    success = header.writeHeader(os);, +                    if (success) {, +                    }, +                } catch (FileNotFoundException e) {, +                    e.printStackTrace();, +                } catch (IOException e) {, +                    e.printStackTrace();, +                    success = false;, +++ b/integration/volley/src/main/java/com/bumptech/glide/volley/VolleyDiskCacheWrapper.java, +, +import com.bumptech.glide.load.engine.cache.StringKey;, +import java.io.File;, +import java.io.FileInputStream;, +import java.io.FileNotFoundException;, +import java.io.FileOutputStream;, +        File file = diskCache.get(new StringKey(key));, +        if (file == null) {, +        InputStream is = null;, +            is = new FileInputStream(file);, +            CacheHeader header = readHeader(is);, +            byte[] data = streamToBytes(is);, +            if (is != null) {, +                    is.close();, +                } catch (IOException e) {, +                    // Do nothing., +                }, +            }, +            public boolean write(File file) {, +                OutputStream os = null;, +                boolean success = false;, +                    os = new FileOutputStream(file);, +                    CacheHeader header = new CacheHeader(key, entry);, +                    success = header.writeHeader(os);, +                    if (success) {, +                    }, +                } catch (FileNotFoundException e) {, +                    e.printStackTrace();, +                } catch (IOException e) {, +                    e.printStackTrace();, +                    success = false;, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +, +import java.io.File;, +            ResourceDecoder<File, Bitmap> cacheDecoder) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/volley/VolleyDiskCacheWrapper.java, +, +import com.bumptech.glide.load.engine.cache.StringKey;, +import java.io.File;, +import java.io.FileInputStream;, +import java.io.FileNotFoundException;, +import java.io.FileOutputStream;, +        File file = diskCache.get(new StringKey(key));, +        if (file == null) {, +        InputStream is = null;, +            is = new FileInputStream(file);, +            CacheHeader header = readHeader(is);, +            byte[] data = streamToBytes(is);, +            if (is != null) {, +                    is.close();, +                } catch (IOException e) {, +                    // Do nothing., +                }, +            }, +            public boolean write(File file) {, +                OutputStream os = null;, +                boolean success = false;, +                    os = new FileOutputStream(file);, +                    CacheHeader header = new CacheHeader(key, entry);, +                    success = header.writeHeader(os);, +                    if (success) {, +                    }, +                } catch (FileNotFoundException e) {, +                    e.printStackTrace();, +                } catch (IOException e) {, +                    e.printStackTrace();, +                    success = false;]
[+++ b/.travis.yml, +    - COMPONENT=instrumentation ANDROID_TARGET=16, +    - COMPONENT=instrumentation ANDROID_TARGET=17, +    - COMPONENT=instrumentation ANDROID_TARGET=18, +++ b/.travis.yml, +    - COMPONENT=instrumentation ANDROID_TARGET=16, +    - COMPONENT=instrumentation ANDROID_TARGET=17, +    - COMPONENT=instrumentation ANDROID_TARGET=18, +++ b/scripts/travis_create_emulator.sh, +avdmanager create avd --force -n test -k $target --device "Nexus 4" -c 2048M]
[+++ b/integration/gifencoder/gifencoder.iml, +++ b/integration/gifencoder/gifencoder.iml, +++ b/integration/okhttp/okhttp.iml, +++ b/integration/gifencoder/gifencoder.iml, +++ b/integration/okhttp/okhttp.iml, +++ b/integration/volley/volley.iml, +++ b/integration/gifencoder/gifencoder.iml, +++ b/integration/okhttp/okhttp.iml, +++ b/integration/volley/volley.iml, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +++ b/integration/gifencoder/gifencoder.iml, +++ b/integration/okhttp/okhttp.iml, +++ b/integration/volley/volley.iml, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java, +    /** decodeFromCachedResource **/, +            assertEquals("diskCacheStrategy: " + strategy, harness.resource,, +                    harness.getJob().decodeFromCachedResource());, +            harness.getJob().decodeFromCachedResource();, +            assertNull(harness.getJob().decodeFromCachedResource());, +        assertEquals(transcoded, harness.getJob().decodeFromCachedResource());, +        harness.getJob().decodeFromCachedResource();, +        assertNull(harness.getJob().decodeFromCachedResource());, +        assertNull(harness.getJob().decodeFromCachedResource());, +            harness.getJob().decodeFromCachedResource();, +        assertNull(harness.getJob().decodeFromCachedResource());, +        harness.getJob().decodeFromCachedResource();, +        assertNull(harness.getJob().decodeFromCachedResource());, +        assertNull(harness.getJob().decodeFromCachedResource());, +    /** decodeFromCachedData **/, +            assertNull(harness.getJob().decodeFromCachedData());, +            assertEquals(harness.resource, harness.getJob().decodeFromCachedData());, +            harness.getJob().decodeFromCachedData();, +            assertEquals(transcoded, harness.getJob().decodeFromCachedData());, +            harness.getJob().decodeFromCachedData();, +            harness.getJob().decodeFromCachedData();, +        harness.getJob().decodeFromCachedData();, +        harness.getJob().decodeFromCachedData();, +        assertNull(harness.getJob().decodeFromCachedData());, +            harness.getJob().decodeFromCachedData();, +        assertNull(harness.getJob().decodeFromCachedData());, +        harness.getJob().decodeFromCachedData();, +        assertNull(harness.getJob().decodeFromCachedData());, +        harness.getJob().decodeFromCachedData();, +        assertNull(harness.getJob().decodeFromCachedData());, +        harness.getJob().decodeFromCachedData();, +++ b/integration/gifencoder/gifencoder.iml, +++ b/integration/okhttp/okhttp.iml, +++ b/integration/volley/volley.iml, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java, +    /** decodeFromCachedResource **/, +            assertEquals("diskCacheStrategy: " + strategy, harness.resource,, +                    harness.getJob().decodeFromCachedResource());, +            harness.getJob().decodeFromCachedResource();, +            assertNull(harness.getJob().decodeFromCachedResource());, +        assertEquals(transcoded, harness.getJob().decodeFromCachedResource());, +        harness.getJob().decodeFromCachedResource();, +        assertNull(harness.getJob().decodeFromCachedResource());, +        assertNull(harness.getJob().decodeFromCachedResource());, +            harness.getJob().decodeFromCachedResource();, +        assertNull(harness.getJob().decodeFromCachedResource());, +        harness.getJob().decodeFromCachedResource();, +        assertNull(harness.getJob().decodeFromCachedResource());, +        assertNull(harness.getJob().decodeFromCachedResource());, +    /** decodeFromCachedData **/, +            assertNull(harness.getJob().decodeFromCachedData());, +            assertEquals(harness.resource, harness.getJob().decodeFromCachedData());, +            harness.getJob().decodeFromCachedData();, +            assertEquals(transcoded, harness.getJob().decodeFromCachedData());, +            harness.getJob().decodeFromCachedData();, +            harness.getJob().decodeFromCachedData();, +        harness.getJob().decodeFromCachedData();, +        harness.getJob().decodeFromCachedData();, +        assertNull(harness.getJob().decodeFromCachedData());, +            harness.getJob().decodeFromCachedData();, +        assertNull(harness.getJob().decodeFromCachedData());, +        harness.getJob().decodeFromCachedData();, +        assertNull(harness.getJob().decodeFromCachedData());, +        harness.getJob().decodeFromCachedData();, +        assertNull(harness.getJob().decodeFromCachedData());, +        harness.getJob().decodeFromCachedData();, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineRunnableTest.java, +        when(job.decodeFromCachedResource()).thenReturn(expected);, +        when(job.decodeFromCachedResource()).thenReturn(null);, +        when(job.decodeFromCachedResource()).thenThrow(new RuntimeException("test"));, +        when(job.decodeFromCachedData()).thenReturn(expected);, +        when(job.decodeFromCachedResource()).thenThrow(new RuntimeException("test"));]
[+++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java, + * <p>Implementations <em>must</em> implement {@link #equals(Object)} and {@link #hashCode()}., + *, +, +  /**, +   * For caching to work correctly, implementations <em>must</em> implement this method and, +   * {@link #hashCode()}., +   */, +  @Override, +  boolean equals(Object o);, +, +  /**, +   * For caching to work correctly, implementations <em>must</em> implement this method and, +   * {@link #equals(Object)}., +   */, +  @Override, +  int hashCode();]
[+++ b/.gitignore, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +samples/flickr/target, +++ b/.gitignore, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +samples/flickr/target, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +++ b/.gitignore, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +samples/flickr/target, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +++ b/Makefile, +	cd third_party/gif_decoder && ant clean && ant jar, +	cp third_party/gif_decoder/bin/gifdecoder*.jar library/libs, +++ b/.gitignore, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +samples/flickr/target, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +++ b/Makefile, +	cd third_party/gif_decoder && ant clean && ant jar, +	cp third_party/gif_decoder/bin/gifdecoder*.jar library/libs, +++ b/library/.gitignore, +libs/gifdecoder*.jar, +++ b/.gitignore, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +samples/flickr/target, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +++ b/Makefile, +	cd third_party/gif_decoder && ant clean && ant jar, +	cp third_party/gif_decoder/bin/gifdecoder*.jar library/libs, +++ b/library/.gitignore, +libs/gifdecoder*.jar, +++ b/library/AndroidManifest.xml, +          android:versionCode="5", +          android:versionName="3.2.0a" >, +  <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="19" />, +++ b/.gitignore, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +samples/flickr/target, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +++ b/Makefile, +	cd third_party/gif_decoder && ant clean && ant jar, +	cp third_party/gif_decoder/bin/gifdecoder*.jar library/libs, +++ b/library/.gitignore, +libs/gifdecoder*.jar, +++ b/library/AndroidManifest.xml, +          android:versionCode="5", +          android:versionName="3.2.0a" >, +  <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="19" />, +++ b/library/custom_rules.xml, +            <zipgroupfileset dir="libs" includes="disklrucache*.jar,volley.jar" />, +++ b/.gitignore, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +samples/flickr/target, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +++ b/Makefile, +	cd third_party/gif_decoder && ant clean && ant jar, +	cp third_party/gif_decoder/bin/gifdecoder*.jar library/libs, +++ b/library/.gitignore, +libs/gifdecoder*.jar, +++ b/library/AndroidManifest.xml, +          android:versionCode="5", +          android:versionName="3.2.0a" >, +  <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="19" />, +++ b/library/custom_rules.xml, +            <zipgroupfileset dir="libs" includes="disklrucache*.jar,volley.jar" />, +++ b/library/install_dependencies/install-android-deps.sh, +#!/bin/sh, +# This script installs the necessary Android dependencies to compile Glide and run, +# the test suite., +# , +# Pre-requisites: , +# Using the android sdk tool, under Android 4.4.2 (API 19), install:, +#   SDK Platform, +#   Glass Development Kit Preview, +#      , +, +git clone https://github.com/mosabua/maven-android-sdk-deployer.git, +cd maven-android-sdk-deployer , +mvn clean install -N && cd platforms && mvn clean install -N && cd android-19 && mvn clean install || { , +  echo 'Failed to install 4.4 SDK, install relevant packages in android SDK first'; ]
[+++ b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java, +@SuppressWarnings("PMD.UseUtilityClass"), +, +  public static <TranscodeType> GenericTransitionOptions<TranscodeType> withNoTransition() {, +    return new GenericTransitionOptions<TranscodeType>().dontTransition();, +  }, +++ b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java, +@SuppressWarnings("PMD.UseUtilityClass"), +, +  public static <TranscodeType> GenericTransitionOptions<TranscodeType> withNoTransition() {, +    return new GenericTransitionOptions<TranscodeType>().dontTransition();, +  }, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +  private final RequestManager requestManager;, +++ b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java, +@SuppressWarnings("PMD.UseUtilityClass"), +, +  public static <TranscodeType> GenericTransitionOptions<TranscodeType> withNoTransition() {, +    return new GenericTransitionOptions<TranscodeType>().dontTransition();, +  }, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +  private final RequestManager requestManager;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java, +public final class DrawableTransitionOptions extends, +    TransitionOptions<DrawableTransitionOptions, Drawable> {, +++ b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java, +@SuppressWarnings("PMD.UseUtilityClass"), +, +  public static <TranscodeType> GenericTransitionOptions<TranscodeType> withNoTransition() {, +    return new GenericTransitionOptions<TranscodeType>().dontTransition();, +  }, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +  private final RequestManager requestManager;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java, +public final class DrawableTransitionOptions extends, +    TransitionOptions<DrawableTransitionOptions, Drawable> {, +++ b/samples/flickr/build.gradle, +    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}", +++ b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java, +@SuppressWarnings("PMD.UseUtilityClass"), +, +  public static <TranscodeType> GenericTransitionOptions<TranscodeType> withNoTransition() {, +    return new GenericTransitionOptions<TranscodeType>().dontTransition();, +  }, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +  private final RequestManager requestManager;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java, +public final class DrawableTransitionOptions extends, +    TransitionOptions<DrawableTransitionOptions, Drawable> {, +++ b/samples/flickr/build.gradle, +    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}", +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java, +import static com.bumptech.glide.GenericTransitionOptions.withNoTransition;, +import android.graphics.Rect;, +import android.support.v7.widget.GridLayoutManager;, +import android.support.v7.widget.RecyclerView;, +import android.util.Log;, +import java.util.Collections;, +  private RecyclerView grid;, +  private GridLayoutManager layoutManager;, +        .transition(withNoTransition()), +        .transition(withNoTransition()), +    final int gridMargin = getResources().getDimensionPixelOffset(R.dimen.grid_margin);, +    int spanCount = getResources().getDisplayMetrics().widthPixels / (photoSize + (2 * gridMargin));, +    grid = (RecyclerView) result.findViewById(R.id.flickr_photo_grid);, +    layoutManager = new GridLayoutManager(getActivity(), spanCount);, +    grid.setLayoutManager(layoutManager);, +, +    grid.addItemDecoration(new RecyclerView.ItemDecoration() {, +      @Override, +      public void getItemOffsets(Rect outRect, View view, RecyclerView parent,, +          RecyclerView.State state) {, +        outRect.set(gridMargin, gridMargin, gridMargin, gridMargin);, +      }, +    });, +    grid.setRecyclerListener(new RecyclerView.RecyclerListener() {, +      @Override, +      public void onViewRecycled(RecyclerView.ViewHolder holder) {, +        PhotoViewHolder photoViewHolder = (PhotoViewHolder) holder;, +        Glide.with(FlickrPhotoGrid.this).clear(photoViewHolder.imageView);, +      }, +    });, +, +    int heightCount = getResources().getDisplayMetrics().heightPixels / photoSize;, +    grid.getRecycledViewPool().setMaxRecycledViews(0, spanCount * heightCount * 2);, +    grid.setItemViewCacheSize(0);, +        new FixedPreloadSizeProvider<>(photoSize, photoSize);, +    final ListPreloader<Photo> preloader = new ListPreloader<>(Glide.with(this), adapter,, +    grid.addOnScrollListener(new RecyclerToListViewScrollListener(preloader));, +      grid.scrollToPosition(index);, +      int index = layoutManager.findFirstVisibleItemPosition();, +  private class PhotoAdapter extends RecyclerView.Adapter<PhotoViewHolder> implements, +    private List<Photo> photos = Collections.emptyList();, +    public int getItemViewType(int position) {, +    public PhotoViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {, +      View view = inflater.inflate(R.layout.flickr_photo_grid_item, parent, false);, +      ViewGroup.LayoutParams params = view.getLayoutParams();, +      return new PhotoViewHolder(view);, +    @Override, +    public void onBindViewHolder(PhotoViewHolder holder, int position) {]
[+++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java, + * {@link @}GlideExtension, + *   {@literal @}GlideOption, + * {@literal @}GlideExtension, + *   {@literal @}GlideOption, +++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java, + * {@link @}GlideExtension, + *   {@literal @}GlideOption, + * {@literal @}GlideExtension, + *   {@literal @}GlideOption, +++ b/glide/build.gradle, +        doFirst {, +            it.classpath =, +                    project.files(, +                            getAndroidLibraryVariantsForJar(variantName).collect {, +                                LibraryVariant lib -> lib.getJavaCompiler().classpath.files, +                            getAndroidLibraryVariantsForJavadoc(variantName).collect {, +                                LibraryVariant lib -> lib.getJavaCompiler().classpath.files, +                            // Finds dependencies of Android packages that would otherwise be, +                            // ignored (Volley in particular), +        }, +++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java, + * {@link @}GlideExtension, + *   {@literal @}GlideOption, + * {@literal @}GlideExtension, + *   {@literal @}GlideOption, +++ b/glide/build.gradle, +        doFirst {, +            it.classpath =, +                    project.files(, +                            getAndroidLibraryVariantsForJar(variantName).collect {, +                                LibraryVariant lib -> lib.getJavaCompiler().classpath.files, +                            getAndroidLibraryVariantsForJavadoc(variantName).collect {, +                                LibraryVariant lib -> lib.getJavaCompiler().classpath.files, +                            // Finds dependencies of Android packages that would otherwise be, +                            // ignored (Volley in particular), +        }, +++ b/library/build.gradle, +        doFirst {, +            it.classpath +=, +                    files(project.android.libraryVariants.collect {, +                        it.javaCompile.classpath.files, +                    }), +        }, +, +++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java, + * {@link @}GlideExtension, + *   {@literal @}GlideOption, + * {@literal @}GlideExtension, + *   {@literal @}GlideOption, +++ b/glide/build.gradle, +        doFirst {, +            it.classpath =, +                    project.files(, +                            getAndroidLibraryVariantsForJar(variantName).collect {, +                                LibraryVariant lib -> lib.getJavaCompiler().classpath.files, +                            getAndroidLibraryVariantsForJavadoc(variantName).collect {, +                                LibraryVariant lib -> lib.getJavaCompiler().classpath.files, +                            // Finds dependencies of Android packages that would otherwise be, +                            // ignored (Volley in particular), +        }, +++ b/library/build.gradle, +        doFirst {, +            it.classpath +=, +                    files(project.android.libraryVariants.collect {, +                        it.javaCompile.classpath.files, +                    }), +        }, +, +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java, +   * See {@code getDrawable(Context, int, Theme)}., +++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java, + * {@link @}GlideExtension, + *   {@literal @}GlideOption, + * {@literal @}GlideExtension, + *   {@literal @}GlideOption, +++ b/glide/build.gradle, +        doFirst {, +            it.classpath =, +                    project.files(, +                            getAndroidLibraryVariantsForJar(variantName).collect {, +                                LibraryVariant lib -> lib.getJavaCompiler().classpath.files, +                            getAndroidLibraryVariantsForJavadoc(variantName).collect {, +                                LibraryVariant lib -> lib.getJavaCompiler().classpath.files, +                            // Finds dependencies of Android packages that would otherwise be, +                            // ignored (Volley in particular), +        }, +++ b/library/build.gradle, +        doFirst {, +            it.classpath +=, +                    files(project.android.libraryVariants.collect {, +                        it.javaCompile.classpath.files, +                    }), +        }, +, +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java, +   * See {@code getDrawable(Context, int, Theme)}., +++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java, +    Glide.init(context, new GlideBuilder().setBitmapPool(bitmapPool));, +++ b/annotation/src/main/java/com/bumptech/glide/annotation/GlideOption.java]
[+++ b/build.gradle, +        // gifencoder is a legacy project that has a ton of warnings and is basically never, +        // modified, so we're not going to worry about cleaning it up., +          options.compilerArgs \, +                << "-Xlint:all" << "-Werror" \, +                /*, +                 * Java expects every annotation to have a processor, but we use, +                 * javax.annotation.Nullable, which doesn't have one., +                 */ \, +                << "-Xlint:-processing" \, +                /*, +                 * See https://github.com/google/dagger/issues/945, +                 * and https://bugs.openjdk.java.net/browse/JDK-8190452, +                 */ \, +                << "-Xlint:-classfile", +, +    project.afterEvaluate {, +        if (project.hasProperty("android")) {, +            android {, +                lintOptions {, +                    warningsAsErrors true, +                    quiet true, +                }, +            }, +        }, +    }, +++ b/build.gradle, +        // gifencoder is a legacy project that has a ton of warnings and is basically never, +        // modified, so we're not going to worry about cleaning it up., +          options.compilerArgs \, +                << "-Xlint:all" << "-Werror" \, +                /*, +                 * Java expects every annotation to have a processor, but we use, +                 * javax.annotation.Nullable, which doesn't have one., +                 */ \, +                << "-Xlint:-processing" \, +                /*, +                 * See https://github.com/google/dagger/issues/945, +                 * and https://bugs.openjdk.java.net/browse/JDK-8190452, +                 */ \, +                << "-Xlint:-classfile", +, +    project.afterEvaluate {, +        if (project.hasProperty("android")) {, +            android {, +                lintOptions {, +                    warningsAsErrors true, +                    quiet true, +                }, +            }, +        }, +    }, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java, +      implements ModelLoaderFactory<WaitModel<Model>, Data> {, +      @SuppressWarnings("unchecked") ModelLoaderFactory<WaitModel<T>, InputStream> streamFactory =, +    public ModelLoader<WaitModel<Model>, Data> build(, +      return new WaitModelLoader<>(multiFactory.build(modelClass, dataClass));, +++ b/build.gradle, +        // gifencoder is a legacy project that has a ton of warnings and is basically never, +        // modified, so we're not going to worry about cleaning it up., +          options.compilerArgs \, +                << "-Xlint:all" << "-Werror" \, +                /*, +                 * Java expects every annotation to have a processor, but we use, +                 * javax.annotation.Nullable, which doesn't have one., +                 */ \, +                << "-Xlint:-processing" \, +                /*, +                 * See https://github.com/google/dagger/issues/945, +                 * and https://bugs.openjdk.java.net/browse/JDK-8190452, +                 */ \, +                << "-Xlint:-classfile", +, +    project.afterEvaluate {, +        if (project.hasProperty("android")) {, +            android {, +                lintOptions {, +                    warningsAsErrors true, +                    quiet true, +                }, +            }, +        }, +    }, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java, +      implements ModelLoaderFactory<WaitModel<Model>, Data> {, +      @SuppressWarnings("unchecked") ModelLoaderFactory<WaitModel<T>, InputStream> streamFactory =, +    public ModelLoader<WaitModel<Model>, Data> build(, +      return new WaitModelLoader<>(multiFactory.build(modelClass, dataClass));, +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +  public <Model, Data> Registry replace(, +      Class<Model> modelClass,, +      Class<Data> dataClass,, +      ModelLoaderFactory<? extends Model, ? extends Data> factory) {, +++ b/build.gradle, +        // gifencoder is a legacy project that has a ton of warnings and is basically never, +        // modified, so we're not going to worry about cleaning it up., +          options.compilerArgs \, +                << "-Xlint:all" << "-Werror" \, +                /*, +                 * Java expects every annotation to have a processor, but we use]
[+++ b/CONTRIBUTING.md, + * **wontfix**: working as intended, or won't be fixed due to compatibility or other reasons, +++ b/CONTRIBUTING.md, + * **wontfix**: working as intended, or won't be fixed due to compatibility or other reasons, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +   * Default {@link com.android.volley.Request} implementation for Glide that receives errors and, +++ b/CONTRIBUTING.md, + * **wontfix**: working as intended, or won't be fixed due to compatibility or other reasons, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +   * Default {@link com.android.volley.Request} implementation for Glide that receives errors and, +++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java, +   * the concrete data type returned by the AssetManager., +++ b/CONTRIBUTING.md, + * **wontfix**: working as intended, or won't be fixed due to compatibility or other reasons, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +   * Default {@link com.android.volley.Request} implementation for Glide that receives errors and, +++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java, +   * the concrete data type returned by the AssetManager., +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java, +     * @param dataSource The data source we were loading from., +++ b/CONTRIBUTING.md, + * **wontfix**: working as intended, or won't be fixed due to compatibility or other reasons, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +   * Default {@link com.android.volley.Request} implementation for Glide that receives errors and, +++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java, +   * the concrete data type returned by the AssetManager., +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java, +     * @param dataSource The data source we were loading from., +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +    // We just need the encoder and resource type to match, which this will enforce., +++ b/CONTRIBUTING.md, + * **wontfix**: working as intended, or won't be fixed due to compatibility or other reasons, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +   * Default {@link com.android.volley.Request} implementation for Glide that receives errors and, +++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java, +   * the concrete data type returned by the AssetManager., +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java, +     * @param dataSource The data source we were loading from., +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +    // We just need the encoder and resource type to match, which this will enforce., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java, +   * The maximum number of times larger an int array may be to be than a requested size to eligible, +++ b/CONTRIBUTING.md, + * **wontfix**: working as intended, or won't be fixed due to compatibility or other reasons, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +   * Default {@link com.android.volley.Request} implementation for Glide that receives errors and, +++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java, +   * the concrete data type returned by the AssetManager., +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java, +     * @param dataSource The data source we were loading from., +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +    // We just need the encoder and resource type to match, which this will enforce., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java, +   * The maximum number of times larger an int array may be to be than a requested size to eligible, +++ b/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java, +   * returning {@code true} if the listener was removed successfully, and {@code false} otherwise., +++ b/CONTRIBUTING.md, + * **wontfix**: working as intended, or won't be fixed due to compatibility or other reasons, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +   * Default {@link com.android.volley.Request} implementation for Glide that receives errors and, +++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java, +   * the concrete data type returned by the AssetManager., +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java, +     * @param dataSource The data source we were loading from., +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +    // We just need the encoder and resource type to match, which this will enforce., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java, +   * The maximum number of times larger an int array may be to be than a requested size to eligible, +++ b/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java, +   * returning {@code true} if the listener was removed successfully, and {@code false} otherwise., +++ b/library/src/main/java/com/bumptech/glide/module/GlideModule.java, + *                              builder.setDecodeFormat(DecodeFormat.ALWAYS_ARGB_8888);, +++ b/CONTRIBUTING.md, + * **wontfix**: working as intended, or won't be fixed due to compatibility or other reasons, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +   * Default {@link com.android.volley.Request} implementation for Glide that receives errors and, +++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java, +   * the concrete data type returned by the AssetManager., +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java, +     * @param dataSource The data source we were loading from., +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +    // We just need the encoder and resource type to match, which this will enforce., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java, +   * The maximum number of times larger an int array may be to be than a requested size to eligible, +++ b/library/src/main/java/com/bumptech/glide/manager/Lifecycle.java, +   * returning {@code true} if the listener was removed successfully, and {@code false} otherwise., +++ b/library/src/main/java/com/bumptech/glide/module/GlideModule.java, + *                              builder.setDecodeFormat(DecodeFormat.ALWAYS_ARGB_8888);, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +  private Drawable loadDrawable(int resourceId) {, +    return ResourcesCompat.getDrawable(resources, resourceId, requestOptions.getTheme());, +++ b/CONTRIBUTING.md, + * **wontfix**: working as intended, or won't be fixed due to compatibility or other reasons, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +   * Default {@link com.android.volley.Request} implementation for Glide that receives errors and, +++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java, +   * the concrete data type returned by the AssetManager., +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java, +     * @param dataSource The data source we were loading from., +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import static com.google.common.truth.Truth.assertThat;, +import android.os.Handler;, +import android.os.Looper;, +import com.bumptech.glide.test.WaitModelLoader;, +import com.bumptech.glide.test.WaitModelLoader.WaitModel;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +  // Tests #2428., +  @Test, +  public void onlyRetrieveFromCache_withPreviousRequestLoadingFromSource_doesNotBlock() {, +    final WaitModel<Integer> waitModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);, +, +    GlideApp.with(context), +        .load(waitModel), +        .submit();, +, +    FutureTarget<Drawable> onlyFromCacheFuture = GlideApp.with(context), +        .load(waitModel), +        .onlyRetrieveFromCache(true), +        .submit();, +    try {, +      onlyFromCacheFuture.get(1000, TimeUnit.MILLISECONDS);, +      throw new IllegalStateException();, +    } catch (InterruptedException | TimeoutException e) {, +      throw new RuntimeException(e);, +    } catch (ExecutionException e) {, +      // Expected., +    }, +    waitModel.countDown();, +  }, +, +  // Tests #2428., +  @Test, +  public void submit_withRequestLoadingWithOnlyRetrieveFromCache_andNotInCache_doesNotFail() {, +    // Block the main thread so that we know that both requests will be queued but not started at, +    // the same time., +    final CountDownLatch blockMainThread = new CountDownLatch(1);, +    new Handler(Looper.getMainLooper()).post(new Runnable() {, +      @Override, +      public void run() {, +         try {, +          blockMainThread.await();, +        } catch (InterruptedException e) {, +          throw new RuntimeException(e);, +        }, +      }, +    });, +, +    // Queue the retrieve from cache request first., +    GlideApp.with(context), +        .load(ResourceIds.raw.canonical), +        .onlyRetrieveFromCache(true), +        .submit();, +, +    // Then queue the normal request., +    FutureTarget<Drawable> expectedFuture =, +        GlideApp.with(context).load(ResourceIds.raw.canonical).submit();, +, +    // Run the requests., +    blockMainThread.countDown();, +, +    // Verify that the request that didn't have retrieve from cache succeeds, +    assertThat(concurrency.get(expectedFuture)).isNotNull();, +  }, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import static com.google.common.truth.Truth.assertThat;, +import android.os.Handler;, +import android.os.Looper;, +import com.bumptech.glide.test.WaitModelLoader;, +import com.bumptech.glide.test.WaitModelLoader.WaitModel;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +  // Tests #2428., +  @Test, +  public void onlyRetrieveFromCache_withPreviousRequestLoadingFromSource_doesNotBlock() {, +    final WaitModel<Integer> waitModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);, +, +    GlideApp.with(context), +        .load(waitModel), +        .submit();, +, +    FutureTarget<Drawable> onlyFromCacheFuture = GlideApp.with(context), +        .load(waitModel), +        .onlyRetrieveFromCache(true), +        .submit();, +    try {, +      onlyFromCacheFuture.get(1000, TimeUnit.MILLISECONDS);, +      throw new IllegalStateException();, +    } catch (InterruptedException | TimeoutException e) {, +      throw new RuntimeException(e);, +    } catch (ExecutionException e) {, +      // Expected., +    }, +    waitModel.countDown();, +  }, +, +  // Tests #2428., +  @Test, +  public void submit_withRequestLoadingWithOnlyRetrieveFromCache_andNotInCache_doesNotFail() {]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java, +public abstract class DownsampleStrategy {, +  public static final DownsampleStrategy AT_LEAST = new DownsampleStrategy() {, +   * Downsamples, maintaining the original aspect ratio, so that one of the image's dimensions is, +   * exactly equal to the requested size and the other dimension is less than or equal to the, +   * requested size., +   */, +  public static final DownsampleStrategy FIT_CENTER = new DownsampleStrategy() {, +    @Override, +    public int getSampleSize(int sourceWidth, int sourceHeight, int requestedWidth,, +        int requestedHeight) {, +      return AT_LEAST.getSampleSize(sourceWidth, sourceHeight, requestedWidth, requestedHeight);, +    }, +, +    @Override, +    public int getDensity(int sourceWidth, int sourceHeight, int requestedWidth,, +        int requestedHeight) {, +      float widthPercentage = requestedWidth / (float) sourceWidth;, +      float heightPercentage = requestedHeight / (float) sourceHeight;, +      return widthPercentage < heightPercentage ? sourceWidth : sourceHeight;, +    }, +, +    @Override, +    public int getTargetDensity(int sourceWidth, int sourceHeight, int requestedWidth,, +        int requestedHeight, int sampleSize) {, +      float widthPercentage = requestedWidth / (float) sourceWidth;, +      float heightPercentage = requestedHeight / (float) sourceHeight;, +      int targetDimen = widthPercentage < heightPercentage ? requestedWidth : requestedHeight;, +      return targetDimen * sampleSize;, +    }, +  };, +, +  /**, +  public static final DownsampleStrategy AT_MOST = new DownsampleStrategy() {, +, +    @Override, +    public int getDensity(int sourceWidth, int sourceHeight, int requestedWidth,, +        int requestedHeight) {, +      return 0;, +    }, +, +    @Override, +    public int getTargetDensity(int sourceWidth, int sourceHeight, int requestedWidth,, +        int requestedHeight, int sampleSize) {, +      return 0;, +    }, +  public static final DownsampleStrategy NONE = new DownsampleStrategy() {, +, +    @Override, +    public int getDensity(int sourceWidth, int sourceHeight, int requestedWidth,, +        int requestedHeight) {, +      return 0;, +    }, +, +    @Override, +    public int getTargetDensity(int sourceWidth, int sourceHeight, int requestedWidth,, +        int requestedHeight, int sampleSize) {, +      return 0;, +    }, +  public static final DownsampleStrategy DEFAULT = AT_LEAST;, +   * to be downsampled and the dimensions of the view/target the image will be displayed in., +   * @param sourceHeight  The height in pixels of the image to be downsampled., +   * @param requestedHeight The height in pixels of the view/target the image will be displayed in., +  public abstract int getSampleSize(int sourceWidth, int sourceHeight, int requestedWidth,, +      int requestedHeight);, +, +  /**, +   * Returns an integer value for {@link android.graphics.BitmapFactory.Options#inDensity} that can, +   * be used, along with {@link #getTargetDensity(int, int, int, int, int)} to scale the image, +   * natively, or {@code 0} to additional avoid scaling., +   *, +   * @param sourceWidth   The width in pixels of the image to be downsampled., +   * @param sourceHeight  The height in pixels of the image to be downsampled., +   * @param requestedWidth  The width in pixels of the view/target the image will be displayed in., +   * @param requestedHeight The height in pixels of the view/target the image will be displayed in., +   */, +  public int getDensity(int sourceWidth, int sourceHeight, int requestedWidth,, +      int requestedHeight) {, +    return 0;, +  }, +, +  /**, +   * Returns an integer value for {@link android.graphics.BitmapFactory.Options#inTargetDensity}, +   * that can be used, along with {@link #getDensity(int, int, int, int)}} to scale the image, +   * natively, or {@code 0} to additional avoid scaling., +   *, +   * <p> The additional scaling will be applied by multiplying the result of, +   * inTargetDensity/inDensity to to downsampled image (sourceWidth/Height divided by sampleSize), +   * </p>, +   *, +   * <p> Images can only be downscaled, scale factors from densities greater than 1 will be ignored., +   * </p>, +   *, +   * @param sourceWidth   The width in pixels of the image to be downsampled., +   * @param sourceHeight  The height in pixels of the image to be downsampled., +   * @param requestedWidth  The width in pixels of the view/target the image will be displayed in., +   * @param requestedHeight The height in pixels of the view/target the image will be displayed in., +   * @param sampleSize The sample size that will be used to downsample the image before any, +   *                   additional density related scaling is applied., +   */]
[+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +      @NonNull List<RequestListener<Object>> defaultRequestListeners,, +      boolean isLoggingRequestOriginsEnabled) {, +            isLoggingRequestOriginsEnabled,, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +      @NonNull List<RequestListener<Object>> defaultRequestListeners,, +      boolean isLoggingRequestOriginsEnabled) {, +            isLoggingRequestOriginsEnabled,, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +  private boolean isLoggingRequestOriginsEnabled;, +  /**, +   * Set to {@code true} to make Glide populate, +   * {@link com.bumptech.glide.load.engine.GlideException#setOrigin(Exception)} for failed requests., +   *, +   * <p>The exception set by this method is not printed by {@link GlideException} and can only be, +   * viewed via a {@link RequestListener} that reads the field via, +   * {@link GlideException#getOrigin()}., +   *, +   * <p>This is an experimental API that may be removed in the future., +   */, +  public GlideBuilder setLogRequestOrigins(boolean isEnabled) {, +    isLoggingRequestOriginsEnabled = isEnabled;, +    return this;, +  }, +, +        defaultRequestListeners,, +        isLoggingRequestOriginsEnabled);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +      @NonNull List<RequestListener<Object>> defaultRequestListeners,, +      boolean isLoggingRequestOriginsEnabled) {, +            isLoggingRequestOriginsEnabled,, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +  private boolean isLoggingRequestOriginsEnabled;, +  /**, +   * Set to {@code true} to make Glide populate, +   * {@link com.bumptech.glide.load.engine.GlideException#setOrigin(Exception)} for failed requests., +   *, +   * <p>The exception set by this method is not printed by {@link GlideException} and can only be, +   * viewed via a {@link RequestListener} that reads the field via, +   * {@link GlideException#getOrigin()}., +   *, +   * <p>This is an experimental API that may be removed in the future., +   */, +  public GlideBuilder setLogRequestOrigins(boolean isEnabled) {, +    isLoggingRequestOriginsEnabled = isEnabled;, +    return this;, +  }, +, +        defaultRequestListeners,, +        isLoggingRequestOriginsEnabled);, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +  private boolean isLoggingRequestOriginsEnabled;, +      boolean isLoggingRequestOriginsEnabled,, +    this.isLoggingRequestOriginsEnabled = isLoggingRequestOriginsEnabled;, +, +  /**, +   * Returns {@code true} if Glide should populate, +   * {@link com.bumptech.glide.load.engine.GlideException#setOrigin(Exception)} for failed requests., +   *, +   * <p>This is an experimental API that may be removed in the future., +   */, +  public boolean isLoggingRequestOriginsEnabled() {, +    return isLoggingRequestOriginsEnabled;, +  }, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +      @NonNull List<RequestListener<Object>> defaultRequestListeners,, +      boolean isLoggingRequestOriginsEnabled) {, +            isLoggingRequestOriginsEnabled,, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +  private boolean isLoggingRequestOriginsEnabled;, +  /**, +   * Set to {@code true} to make Glide populate, +   * {@link com.bumptech.glide.load.engine.GlideException#setOrigin(Exception)} for failed requests., +   *, +   * <p>The exception set by this method is not printed by {@link GlideException} and can only be, +   * viewed via a {@link RequestListener} that reads the field via, +   * {@link GlideException#getOrigin()}., +   *, +   * <p>This is an experimental API that may be removed in the future., +   */, +  public GlideBuilder setLogRequestOrigins(boolean isEnabled) {, +    isLoggingRequestOriginsEnabled = isEnabled;, +    return this;, +  }, +, +        defaultRequestListeners,, +        isLoggingRequestOriginsEnabled);, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +  private boolean isLoggingRequestOriginsEnabled;, +      boolean isLoggingRequestOriginsEnabled,, +    this.isLoggingRequestOriginsEnabled = isLoggingRequestOriginsEnabled;, +, +  /**, +   * Returns {@code true} if Glide should populate, +   * {@link com.bumptech.glide.load.engine.GlideException#setOrigin(Exception)} for failed requests., +   *, +   * <p>This is an experimental API that may be removed in the future., +   */, +  public boolean isLoggingRequestOriginsEnabled() {, +    return isLoggingRequestOriginsEnabled;]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +import android.support.annotation.DrawableRes;, +import android.support.annotation.FloatRange;, +import android.support.annotation.IntRange;, +  public static RequestOptions sizeMultiplierOf(, +      @FloatRange(from = 0, to = 1) float sizeMultiplier) {, +  public static RequestOptions placeholderOf(@DrawableRes int placeholderId) {, +  public static RequestOptions errorOf(@DrawableRes int errorId) {, +  public static RequestOptions overrideOf(, +      @IntRange(from = 0) int width,, +      @IntRange(from = 0) int height) {, +  public static RequestOptions overrideOf(@IntRange(from = 0) int size) {, +  public static RequestOptions frameOf(@IntRange(from = 0) long frameTimeMicros) {, +  public static RequestOptions timeoutOf(@IntRange(from = 0) int timeout) {, +  public static RequestOptions encodeQualityOf(@IntRange(from = 0, to = 100) int quality) {, +  public RequestOptions sizeMultiplier(@FloatRange(from = 0, to = 1) float sizeMultiplier) {, +  public RequestOptions placeholder(@DrawableRes int resourceId) {, +  public RequestOptions fallback(@Nullable Drawable drawable) {, +  public RequestOptions fallback(@DrawableRes int resourceId) {, +  public RequestOptions error(@DrawableRes int resourceId) {, +  public RequestOptions theme(@Nullable Resources.Theme theme) {, +  public RequestOptions override(, +      @IntRange(from = 0) int width,, +      @IntRange(from = 0) int height) {, +  public RequestOptions override(@IntRange(from = 0) int size) {, +  public RequestOptions encodeQuality(@IntRange(from = 0, to = 100) int quality) {, +  public RequestOptions frame(@IntRange(from = 0) long frameTimeMicros) {, +  public RequestOptions timeout(@IntRange(from = 0) int timeoutMs) {, +  public RequestOptions optionalTransform(@NonNull Transformation<Bitmap> transformation) {, +  public <T> RequestOptions optionalTransform(, +      @NonNull Class<T> resourceClass, @NonNull Transformation<T> transformation) {, +      @NonNull Class<T> resourceClass, @NonNull Transformation<T> transformation) {, +  public RequestOptions apply(@NonNull RequestOptions other) {]
[+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java, +  @CheckResult, +  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {, +    return (GlideRequest<TranscodeType>) super.addListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java, +  @CheckResult, +  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {, +    return (GlideRequest<TranscodeType>) super.addListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java, +  @CheckResult, +  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {, +    return (GlideRequest<TranscodeType>) super.addListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java, +  @CheckResult, +  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {, +    return (GlideRequest<TranscodeType>) super.addListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java, +  @CheckResult, +  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {, +    return (GlideRequest<TranscodeType>) super.addListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java, +  @CheckResult, +  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {, +    return (GlideRequest<TranscodeType>) super.addListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java, +  @CheckResult, +  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {, +    return (GlideRequest<TranscodeType>) super.addListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java, +  @CheckResult, +  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {, +    return (GlideRequest<TranscodeType>) super.addListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java, +  @CheckResult, +  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {, +    return (GlideRequest<TranscodeType>) super.addListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideRequest.java, +  @CheckResult, +  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {, +    return (GlideRequest<TranscodeType>) super.addListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java, +  @CheckResult, +  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {, +    return (GlideRequest<TranscodeType>) super.addListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideRequest.java, +  @CheckResult, +  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {, +    return (GlideRequest<TranscodeType>) super.addListener(listener);, +  }, +, +  @Override, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideRequest.java, +  @CheckResult, +  public GlideRequest<TranscodeType> addListener(@Nullable RequestListener<TranscodeType> listener) {, +    return (GlideRequest<TranscodeType>) super.addListener(listener);]
[+++ b/.gitmodules, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ b/.gitmodules, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ /dev/null, +++ b/.gitmodules, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ /dev/null, +++ /dev/null, +++ b/.gitmodules, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitmodules, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitmodules, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitmodules, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitmodules, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitmodules, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitmodules, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitmodules, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitmodules, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitmodules, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, +import java.util.ArrayList;, +import java.util.Collection;, +import java.util.List;, +    List<String> excludedGlideModuleClassNames =, +    List<String> orderedLibraryGlideModuleClassNames =, +        new ArrayList<>(libraryGlideModuleClassNames);, +    Collections.sort(orderedLibraryGlideModuleClassNames);, +, +            appGlideModuleClassName,, +            orderedLibraryGlideModuleClassNames,, +            excludedGlideModuleClassNames);, +        generateRegisterComponents(, +            orderedLibraryGlideModuleClassNames, excludedGlideModuleClassNames);, +  private MethodSpec generateGetExcludedModuleClasses(Collection<String> excludedClassNames) {, +  private MethodSpec generateRegisterComponents(, +      Collection<String> libraryGlideModuleClassNames,, +      Collection<String> excludedGlideModuleClassNames) {, +      Collection<String> libraryGlideModuleClassNames,, +      Collection<String> excludedGlideModuleClassNames) {, +  private List<String> getExcludedGlideModuleClassNames(TypeElement appGlideModule) {, +    Set<String> names = processorUtil.findClassValuesFromAnnotationOnClassAsNames(, +    List<String> result = new ArrayList<>(names);, +    Collections.sort(result);, +    return result;]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java, +import static com.google.common.truth.Truth.assertThat;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, +import org.robolectric.RobolectricTestRunner;, +import android.graphics.drawable.BitmapDrawable;, +import com.bumptech.glide.load.engine.Resource;, +import org.mockito.ArgumentCaptor;, +import org.mockito.invocation.InvocationOnMock;, +import org.mockito.stubbing.Answer;, +  @Mock Resource<BitmapDrawable> drawableResourceToTransform;, +  @Mock BitmapDrawable drawableToTransform;, +, +  private Bitmap bitmapToTransform;, +    bitmapToTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    when(drawableResourceToTransform.get()).thenReturn(drawableToTransform);, +    when(drawableToTransform.getBitmap()).thenReturn(bitmapToTransform);, +  public void testReturnsOriginalResourceIfTransformationDoesNotTransform() {, +    int outWidth = 123;, +    int outHeight = 456;, +    when(wrapped.transform(any(Resource.class), eq(outWidth), eq(outHeight))), +        .thenAnswer(new Answer<Object>() {, +          @Override, +          public Object answer(InvocationOnMock invocation) throws Throwable {, +            return invocation.getArguments()[0];, +          }, +        });, +, +    Resource<BitmapDrawable> transformed = transformation.transform(drawableResourceToTransform,, +        outWidth, outHeight);, +, +    assertThat(transformed).isEqualTo(drawableResourceToTransform);, +  }, +, +  @Test, +  public void testReturnsNewResourceIfTransformationDoesTransform() {, +    int outWidth = 999;, +    int outHeight = 555;, +, +    Bitmap transformedBitmap = Bitmap.createBitmap(outWidth, outHeight, Bitmap.Config.RGB_565);, +    Resource<Bitmap> transformedBitmapResource = mock(Resource.class);, +    when(transformedBitmapResource.get()).thenReturn(transformedBitmap);, +    when(wrapped.transform(any(Resource.class), eq(outWidth), eq(outHeight))), +        .thenReturn(transformedBitmapResource);, +, +    Resource<BitmapDrawable> transformed =, +        transformation.transform(drawableResourceToTransform, outWidth, outHeight);, +, +    assertThat(transformed.get().getBitmap()).isEqualTo(transformedBitmap);, +  }, +, +  @Test, +  public void testProvidesBitmapFromGivenResourceToWrappedTransformation() {, +    int outWidth = 332;, +    int outHeight = 111;, +    Resource<Bitmap> transformed = mock(Resource.class);, +    when(transformed.get()), +        .thenReturn(Bitmap.createBitmap(outWidth, outHeight, Bitmap.Config.ARGB_8888));, +    when(wrapped.transform(any(Resource.class), anyInt(), anyInt())), +        .thenReturn(transformed);, +, +    transformation.transform(drawableResourceToTransform, outWidth, outHeight);, +    ArgumentCaptor<Resource> captor = ArgumentCaptor.forClass(Resource.class);, +, +    verify(wrapped).transform(captor.capture(), eq(outWidth), eq(outHeight));, +, +    assertThat(captor.getValue().get()).isEqualTo(bitmapToTransform);, +  }, +, +  @Test, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformationTest.java, +import static com.google.common.truth.Truth.assertThat;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, +import org.robolectric.RobolectricTestRunner;, +import android.graphics.drawable.BitmapDrawable;, +import com.bumptech.glide.load.engine.Resource;, +import org.mockito.ArgumentCaptor;, +import org.mockito.invocation.InvocationOnMock;, +import org.mockito.stubbing.Answer;, +  @Mock Resource<BitmapDrawable> drawableResourceToTransform;, +  @Mock BitmapDrawable drawableToTransform;, +, +  private Bitmap bitmapToTransform;, +    bitmapToTransform = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    when(drawableResourceToTransform.get()).thenReturn(drawableToTransform);, +    when(drawableToTransform.getBitmap()).thenReturn(bitmapToTransform);, +  public void testReturnsOriginalResourceIfTransformationDoesNotTransform() {, +    int outWidth = 123;, +    int outHeight = 456;, +    when(wrapped.transform(any(Resource.class), eq(outWidth), eq(outHeight)))]
[+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java, +import com.bumptech.glide.GlideBuilder;, +import java.lang.Deprecated;, +  @Deprecated, +   * @see Glide#init(Context, GlideBuilder), +   */, +  @VisibleForTesting, +  @SuppressLint("VisibleForTests"), +  public static void init(Context context, GlideBuilder builder) {, +    Glide.init(context, builder);, +  }, +, +  /**, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java, +import com.bumptech.glide.GlideBuilder;, +import java.lang.Deprecated;, +  @Deprecated, +   * @see Glide#init(Context, GlideBuilder), +   */, +  @VisibleForTesting, +  @SuppressLint("VisibleForTests"), +  public static void init(Context context, GlideBuilder builder) {, +    Glide.init(context, builder);, +  }, +, +  /**, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +  /**, +   * @deprecated Use {@link #init(Context, GlideBuilder)} to get a singleton compatible with, +   * Glide's generated API., +   *, +   * <p>This method will be removed in a future version of Glide., +   */, +  @Deprecated, +  public static synchronized void init(Context context, GlideBuilder builder) {, +    initializeGlide(context, builder);, +  }, +, +  @VisibleForTesting, +    initializeGlide(context, new GlideBuilder());, +  }, +  @SuppressWarnings("deprecation"), +  private static void initializeGlide(Context context, GlideBuilder builder) {, +    Context applicationContext = context.getApplicationContext();, +    builder.setRequestManagerFactory(factory);, +    applicationContext.registerComponentCallbacks(glide);]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +      target.setRequest(null);, +    target.setRequest(null);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +      target.setRequest(null);, +    target.setRequest(null);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +      cleanup();, +  private void cleanup() {, +    currentData = null;, +    currentDataSource = null;, +    currentFetcher = null;, +    currentSourceKey = null;, +    currentThread = null;, +  }, +]
[+++ b/.gitmodules, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ b/.gitmodules, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ b/library/tests/assets/exif-orientation-examples, +Subproject commit e87146ce6f4171130c6e0d325ae3fbf2a108f136, +++ b/.gitmodules, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ b/library/tests/assets/exif-orientation-examples, +Subproject commit e87146ce6f4171130c6e0d325ae3fbf2a108f136, +++ b/library/tests/src/com/bumptech/glide/ExifTest.java, +package com.bumptech.glide;, +, +import android.content.res.AssetManager;, +import android.test.InstrumentationTestCase;, +import com.bumptech.glide.resize.load.ExifOrientationParser;, +, +import java.io.IOException;, +import java.io.InputStream;, +, +/**, + * Created with IntelliJ IDEA., + * User: sam, + * Date: 8/14/13, + * Time: 9:18 AM, + * To change this template use File | Settings | File Templates., + */, +public class ExifTest extends InstrumentationTestCase {, +    private AssetManager assets;, +, +    @Override, +    protected void setUp() throws Exception {, +        super.setUp();, +, +        assets = getInstrumentation().getContext().getResources().getAssets();, +    }, +, +    private InputStream open(String imageName) throws IOException {, +        return assets.open("exif-orientation-examples/" + imageName);, +    }, +, +    private void assertOrientation(String filePrefix, int expectedOrientation) {, +        InputStream is = null;, +        try {, +            is = open(filePrefix + "_" + expectedOrientation + ".jpg");, +            assertEquals(new ExifOrientationParser(is).getOrientation(), expectedOrientation);, +        } catch (IOException e) {, +            e.printStackTrace();, +            assertNull(e);, +        } finally {, +            if (is != null) {, +                try {, +                    is.close();, +                } catch (IOException e) { }, +            }, +        }, +    }, +, +    public void testLandscape() throws IOException {, +        for (int i = 1; i <= 8; i++) {, +            assertOrientation("Landscape", i);, +        }, +    }, +, +    public void testPortrait() throws IOException {, +        for (int i = 1; i <= 8; i++) {, +            assertOrientation("Portrait", i);, +        }, +    }, +}]
[+++ b/README.md, +++ b/README.md, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    // Engine asserts this anyway when removing resources, fail faster and consistently, +    Util.assertMainThread();, +    // memory cache needs to be cleared before bitmap pool to clear re-pooled Bitmaps too. See #687., +    bitmapPool.clearMemory();, +    // Engine asserts this anyway when removing resources, fail faster and consistently, +    Util.assertMainThread();, +    // memory cache needs to be trimmed before bitmap pool to trim re-pooled Bitmaps too. See #687., +    bitmapPool.trimMemory(level);, +    // Engine asserts this anyway when removing resources, fail faster and consistently, +    Util.assertMainThread();, +    // memory cache needs to be trimmed before bitmap pool to trim re-pooled Bitmaps too. See #687.]
[+++ b/.idea/codeStyleSettings.xml, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +  <component name="NewModuleRootManager" inherit-compiler-output="false">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +  <component name="NewModuleRootManager" inherit-compiler-output="false">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +  <component name="NewModuleRootManager" inherit-compiler-output="false">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" isTestSource="false" />, +      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" isTestSource="true" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +  <component name="NewModuleRootManager" inherit-compiler-output="false">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" isTestSource="false" />, +      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" isTestSource="true" />, +++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MAJOR=3, +VERSION_MINOR=6, +SUPPORT_V4_VERSION=19.1.0, +SUPPORT_V7_VERSION=19.1.0, +# TODO: Upgrade to latest version of Volley when we compile with Java 7., +VOLLEY_VERSION=1.0.8, +ANDROID_GRADLE_VERSION=1.0.0, +ROBOLECTRIC_GRADLE_VERSION=0.14.0, +ROBOLECTRIC_VERSION=2.4, +MOCKWEBSERVER_VERSION=1.6.0, +COMPILE_SDK_VERSION=19, +BUILD_TOOLS_VERSION=19.1.0, +TARGET_SDK_VERSION=19, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml]
[+++ b/src/com/bumptech/photos/PhotoManager.java, +import com.bumptech.photos.resize.ResizeJobGenerator;, +    private ResizeJobGenerator resizer;, +        this.resizer = new ResizeJobGenerator(mainHandler, CAN_RECYCLE ? bitmapCache : null);, +++ b/src/com/bumptech/photos/PhotoManager.java, +import com.bumptech.photos.resize.ResizeJobGenerator;, +    private ResizeJobGenerator resizer;, +        this.resizer = new ResizeJobGenerator(mainHandler, CAN_RECYCLE ? bitmapCache : null);, +++ /dev/null, +++ b/src/com/bumptech/photos/PhotoManager.java, +import com.bumptech.photos.resize.ResizeJobGenerator;, +    private ResizeJobGenerator resizer;, +        this.resizer = new ResizeJobGenerator(mainHandler, CAN_RECYCLE ? bitmapCache : null);, +++ /dev/null, +++ b/src/com/bumptech/photos/resize/ResizeJobGenerator.java, +/*, + * Copyright (c) 2012 Bump Technologies Inc. All rights reserved., + */, +package com.bumptech.photos.resize;, +, +import android.graphics.Bitmap;, +import android.os.Handler;, +import com.bumptech.photos.LoadedCallback;, +import com.bumptech.photos.cache.SizedBitmapCache;, +, +import java.io.IOException;, +import java.io.InputStream;, +, +/**, + * @author sam, + *, + */, +public class ResizeJobGenerator {, +, +    private Handler mainHandler;, +    private final SizedBitmapCache bitmapCache;, +, +    public ResizeJobGenerator(Handler mainHandler) {, +        this(mainHandler, null);, +    }, +, +    public ResizeJobGenerator(Handler mainHandler, SizedBitmapCache bitmapCache){, +        this.mainHandler = mainHandler;, +        this.bitmapCache = bitmapCache;, +    }, +, +    public Runnable resizeCenterCrop(final String path, final int width, final int height, LoadedCallback callback){, +        return new SimpleStreamResizeRunnable(callback) {, +, +            @Override, +            public Bitmap resize(Bitmap recycled) {, +                Bitmap streamed = Utils.streamIn(path, width, height);, +, +                if (streamed.getWidth() == width && streamed.getHeight() == height) {, +                    return streamed;, +                } else {, +                    return Utils.centerCrop(streamed, width, height);, +                }, +            }, +        };, +    }, +, +    public Runnable fitInSpace(final String path, final int width, final int height, LoadedCallback callback){, +        return new SimpleStreamResizeRunnable(callback) {, +, +            @Override, +            public Bitmap resize(Bitmap recycled) {, +                final Bitmap streamed = Utils.streamIn(path, width > height ? 1 : width, height > width ? 1 : height);, +                return Utils.fitInSpace(streamed, width, height);, +            }, +        };, +    }, +, +    public Runnable loadApproximate(final String path, final int width, final int height, LoadedCallback callback){, +        return new SimpleStreamResizeRunnable(callback) {, +, +            @Override, +            public Bitmap resize(Bitmap recycled) {, +                return Utils.streamIn(path, width, height);, +            }, +        };, +    }, +, +    public Runnable loadAsIs(final InputStream is1, final InputStream is2, final LoadedCallback callback) {, +        return new StreamResizeRunnable(callback) {, +, +            @Override, +            public Bitmap getRecycledBitmap() {, +                int[] dimens = new int[] {-1, -1};, +                try {, +                    dimens = Utils.getDimension(is1);, +                } finally {, +                    try {, +                        is1.close();, +                    } catch (IOException e) {, +                        e.printStackTrace();, +                    }, +                }, +                return bitmapCache.get(dimens[0], dimens[1]);, +            }]
[+++ b/gradle.properties, +OK_HTTP_VERSION=3.0.0-RC1, +MOCKWEBSERVER_VERSION=3.0.0-RC1, +++ b/gradle.properties, +OK_HTTP_VERSION=3.0.0-RC1, +MOCKWEBSERVER_VERSION=3.0.0-RC1, +++ b/integration/okhttp/build.gradle, +    compile "com.squareup.okhttp:okhttp:2.7.1", +++ b/gradle.properties, +OK_HTTP_VERSION=3.0.0-RC1, +MOCKWEBSERVER_VERSION=3.0.0-RC1, +++ b/integration/okhttp/build.gradle, +    compile "com.squareup.okhttp:okhttp:2.7.1", +++ b/integration/okhttp/gradle.properties, +POM_DESCRIPTION=An integration library to use OkHttp 2.x to fetch data over http/https in Glide, +++ b/gradle.properties, +OK_HTTP_VERSION=3.0.0-RC1, +MOCKWEBSERVER_VERSION=3.0.0-RC1, +++ b/integration/okhttp/build.gradle, +    compile "com.squareup.okhttp:okhttp:2.7.1", +++ b/integration/okhttp/gradle.properties, +POM_DESCRIPTION=An integration library to use OkHttp 2.x to fetch data over http/https in Glide, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, + *, + * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpGlideModule., +@Deprecated, +++ b/gradle.properties, +OK_HTTP_VERSION=3.0.0-RC1, +MOCKWEBSERVER_VERSION=3.0.0-RC1, +++ b/integration/okhttp/build.gradle, +    compile "com.squareup.okhttp:okhttp:2.7.1", +++ b/integration/okhttp/gradle.properties, +POM_DESCRIPTION=An integration library to use OkHttp 2.x to fetch data over http/https in Glide, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, + *, + * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpGlideModule., +@Deprecated, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, + *, + * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpStreamFetcher., +@Deprecated, +++ b/gradle.properties, +OK_HTTP_VERSION=3.0.0-RC1, +MOCKWEBSERVER_VERSION=3.0.0-RC1, +++ b/integration/okhttp/build.gradle, +    compile "com.squareup.okhttp:okhttp:2.7.1", +++ b/integration/okhttp/gradle.properties, +POM_DESCRIPTION=An integration library to use OkHttp 2.x to fetch data over http/https in Glide, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, + *, + * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpGlideModule., +@Deprecated, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, + *, + * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpStreamFetcher., +@Deprecated, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, + *, + * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpUrlLoader., +@Deprecated, +++ b/gradle.properties, +OK_HTTP_VERSION=3.0.0-RC1, +MOCKWEBSERVER_VERSION=3.0.0-RC1, +++ b/integration/okhttp/build.gradle, +    compile "com.squareup.okhttp:okhttp:2.7.1", +++ b/integration/okhttp/gradle.properties, +POM_DESCRIPTION=An integration library to use OkHttp 2.x to fetch data over http/https in Glide, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, + *, + * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpGlideModule., +@Deprecated, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, + *, + * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpStreamFetcher., +@Deprecated, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, + *, + * @deprecated replaced with com.bumptech.glide.integration.okhttp3.OkHttpUrlLoader., +@Deprecated, +++ b/integration/okhttp3/build.gradle, +apply plugin: 'com.android.library', +, +repositories {, +    mavenCentral(), +}, +, +dependencies {, +    compile project(':glide'), +, +    compile "com.squareup.okhttp3:okhttp:${OK_HTTP_VERSION}", +}, +, +android {, +    compileSdkVersion COMPILE_SDK_VERSION as int, +    buildToolsVersion BUILD_TOOLS_VERSION as String, +, +    defaultConfig {, +        minSdkVersion MIN_SDK_VERSION as int, +        targetSdkVersion TARGET_SDK_VERSION as int, +]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java, +    return transcoder.transcode(transformed, options);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java, +    return transcoder.transcode(transformed, options);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java, +import com.bumptech.glide.load.Options;, +  public Resource<byte[]> transcode(Resource<Bitmap> toTranscode, Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java, +    return transcoder.transcode(transformed, options);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java, +import com.bumptech.glide.load.Options;, +  public Resource<byte[]> transcode(Resource<Bitmap> toTranscode, Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java, +import com.bumptech.glide.load.Options;, +  public Resource<BitmapDrawable> transcode(Resource<Bitmap> toTranscode, Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java, +    return transcoder.transcode(transformed, options);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java, +import com.bumptech.glide.load.Options;, +  public Resource<byte[]> transcode(Resource<Bitmap> toTranscode, Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java, +import com.bumptech.glide.load.Options;, +  public Resource<BitmapDrawable> transcode(Resource<Bitmap> toTranscode, Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java, +import com.bumptech.glide.load.Options;, +  public Resource<byte[]> transcode(Resource<GifDrawable> toTranscode, Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java, +    return transcoder.transcode(transformed, options);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java, +import com.bumptech.glide.load.Options;, +  public Resource<byte[]> transcode(Resource<Bitmap> toTranscode, Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java, +import com.bumptech.glide.load.Options;, +  public Resource<BitmapDrawable> transcode(Resource<Bitmap> toTranscode, Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java, +import com.bumptech.glide.load.Options;, +  public Resource<byte[]> transcode(Resource<GifDrawable> toTranscode, Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java, +import com.bumptech.glide.load.Options;, +  Resource<R> transcode(Resource<Z> toTranscode, Options options);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java, +    return transcoder.transcode(transformed, options);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java, +import com.bumptech.glide.load.Options;, +  public Resource<byte[]> transcode(Resource<Bitmap> toTranscode, Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java, +import com.bumptech.glide.load.Options;, +  public Resource<BitmapDrawable> transcode(Resource<Bitmap> toTranscode, Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java, +import com.bumptech.glide.load.Options;, +  public Resource<byte[]> transcode(Resource<GifDrawable> toTranscode, Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java, +import com.bumptech.glide.load.Options;, +  Resource<R> transcode(Resource<Z> toTranscode, Options options);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java, +import com.bumptech.glide.load.Options;, +  public Resource<Z> transcode(Resource<Z> toTranscode, Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java, +    return transcoder.transcode(transformed, options);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java, +import com.bumptech.glide.load.Options;, +  public Resource<byte[]> transcode(Resource<Bitmap> toTranscode, Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java, +import com.bumptech.glide.load.Options;, +  public Resource<BitmapDrawable> transcode(Resource<Bitmap> toTranscode, Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java, +import com.bumptech.glide.load.Options;, +  public Resource<byte[]> transcode(Resource<GifDrawable> toTranscode, Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java, +import com.bumptech.glide.load.Options;, +  Resource<R> transcode(Resource<Z> toTranscode, Options options);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java, +import com.bumptech.glide.load.Options;, +  public Resource<Z> transcode(Resource<Z> toTranscode, Options options) {, +++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java, +import com.bumptech.glide.load.Options;, +    Options options = new Options();, +      Resource<byte[]> bytesResource = transcoder.transcode(bitmapResource, options);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java, +    return transcoder.transcode(transformed, options);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java, +import com.bumptech.glide.load.Options;, +  public Resource<byte[]> transcode(Resource<Bitmap> toTranscode, Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java, +import com.bumptech.glide.load.Options;, +  public Resource<BitmapDrawable> transcode(Resource<Bitmap> toTranscode, Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/GifDrawableBytesTranscoder.java, +import com.bumptech.glide.load.Options;, +  public Resource<byte[]> transcode(Resource<GifDrawable> toTranscode, Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java, +import com.bumptech.glide.load.Options;, +  Resource<R> transcode(Resource<Z> toTranscode, Options options);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java, +import com.bumptech.glide.load.Options;, +  public Resource<Z> transcode(Resource<Z> toTranscode, Options options) {, +++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoderTest.java, +import com.bumptech.glide.load.Options;, +    Options options = new Options();, +      Resource<byte[]> bytesResource = transcoder.transcode(bitmapResource, options);, +++ b/library/src/test/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java]
[+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java, +     * Returns a Volley request for the given image url. The given future should be put as a, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java, +     * Returns a Volley request for the given image url. The given future should be put as a, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java, +      public Class<TestDrawable> getResourceClass() {, +        return TestDrawable.class;, +      }, +, +      @Override, +      public Class<TestDrawable> getResourceClass() {, +        return TestDrawable.class;, +      }, +, +      @Override, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java, +     * Returns a Volley request for the given image url. The given future should be put as a, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java, +      public Class<TestDrawable> getResourceClass() {, +        return TestDrawable.class;, +      }, +, +      @Override, +      public Class<TestDrawable> getResourceClass() {, +        return TestDrawable.class;, +      }, +, +      @Override, +++ b/library/src/androidTest/java/com/bumptech/glide/request/SingleRequestTest.java, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java, +     * Returns a Volley request for the given image url. The given future should be put as a, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java, +      public Class<TestDrawable> getResourceClass() {, +        return TestDrawable.class;, +      }, +, +      @Override, +      public Class<TestDrawable> getResourceClass() {, +        return TestDrawable.class;, +      }, +, +      @Override, +++ b/library/src/androidTest/java/com/bumptech/glide/request/SingleRequestTest.java, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        .register(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, new BitmapEncoder())), +        .prepend(InputStream.class, GifDrawable.class, new GifResourceDecoder(context, bitmapPool)), +   * Use {@link GlideBuilder#setMemoryCache(MemoryCache)} to put a permanent memory size if you want, +   * @throws IllegalArgumentException if an object other than Glide's metadata is put as the view's, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java, +     * Returns a Volley request for the given image url. The given future should be put as a, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java, +      public Class<TestDrawable> getResourceClass() {, +        return TestDrawable.class;, +      }, +, +      @Override, +      public Class<TestDrawable> getResourceClass() {, +        return TestDrawable.class;, +      }, +, +      @Override, +++ b/library/src/androidTest/java/com/bumptech/glide/request/SingleRequestTest.java, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        .register(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, new BitmapEncoder())), +        .prepend(InputStream.class, GifDrawable.class, new GifResourceDecoder(context, bitmapPool)), +   * Use {@link GlideBuilder#setMemoryCache(MemoryCache)} to put a permanent memory size if you want, +   * @throws IllegalArgumentException if an object other than Glide's metadata is put as the view's, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +  public Registry getRegistry() {, +    return registry;, +  }, +, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java, +     * Returns a Volley request for the given image url. The given future should be put as a, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java, +      public Class<TestDrawable> getResourceClass() {, +        return TestDrawable.class;, +      }, +, +      @Override, +      public Class<TestDrawable> getResourceClass() {, +        return TestDrawable.class;, +      }, +, +      @Override, +++ b/library/src/androidTest/java/com/bumptech/glide/request/SingleRequestTest.java, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        .register(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, new BitmapEncoder())), +        .prepend(InputStream.class, GifDrawable.class, new GifResourceDecoder(context, bitmapPool)), +   * Use {@link GlideBuilder#setMemoryCache(MemoryCache)} to put a permanent memory size if you want, +   * @throws IllegalArgumentException if an object other than Glide's metadata is put as the view's, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +  public Registry getRegistry() {, +    return registry;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, + * <p> Must be put using, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java, +     * Returns a Volley request for the given image url. The given future should be put as a]
[+++ b/project.properties, +target=android-16]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java, +            buffer.position(0);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java, +            buffer.position(0);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java, +    buffer.position(0);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java, +            buffer.position(0);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java, +    buffer.position(0);, +++ b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java, +      toCopy.position(0);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java, +            buffer.position(0);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java, +    buffer.position(0);, +++ b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java, +      toCopy.position(0);, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, +    rawData.position(0);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java, +            buffer.position(0);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bytes/ByteBufferRewinder.java, +    buffer.position(0);, +++ b/library/src/main/java/com/bumptech/glide/util/ByteBufferUtil.java, +      toCopy.position(0);, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, +    rawData.position(0);, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java, +    rawData.position(0);]
[+++ b/samples/flickr/src/main/AndroidManifest.xml, +    <activity android:name=".FullscreenActivity" />, +, +++ b/samples/flickr/src/main/AndroidManifest.xml, +    <activity android:name=".FullscreenActivity" />, +, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java, +import android.content.Intent;, +            imageView.setOnClickListener(new View.OnClickListener() {, +                @Override, +                public void onClick(View view) {, +                    Intent intent = FullscreenActivity.getIntent(getActivity(), current);, +                    startActivity(intent);, +                }, +            });, +, +++ b/samples/flickr/src/main/AndroidManifest.xml, +    <activity android:name=".FullscreenActivity" />, +, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java, +import android.content.Intent;, +            imageView.setOnClickListener(new View.OnClickListener() {, +                @Override, +                public void onClick(View view) {, +                    Intent intent = FullscreenActivity.getIntent(getActivity(), current);, +                    startActivity(intent);, +                }, +            });, +, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java, +import android.content.Intent;, +            viewHolder.imageView.setOnClickListener(new View.OnClickListener() {, +                @Override, +               public void onClick(View view) {, +                    Intent intent = FullscreenActivity.getIntent(getActivity(), current);, +                    startActivity(intent);, +                }, +            });, +, +++ b/samples/flickr/src/main/AndroidManifest.xml, +    <activity android:name=".FullscreenActivity" />, +, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java, +import android.content.Intent;, +            imageView.setOnClickListener(new View.OnClickListener() {, +                @Override, +                public void onClick(View view) {, +                    Intent intent = FullscreenActivity.getIntent(getActivity(), current);, +                    startActivity(intent);, +                }, +            });, +, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java, +import android.content.Intent;, +            viewHolder.imageView.setOnClickListener(new View.OnClickListener() {, +                @Override, +               public void onClick(View view) {, +                    Intent intent = FullscreenActivity.getIntent(getActivity(), current);, +                    startActivity(intent);, +                }, +            });, +, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java, +package com.bumptech.glide.samples.flickr;, +, +import android.content.Context;, +import android.content.Intent;, +import android.os.Bundle;, +import android.support.v4.app.FragmentActivity;, +import android.widget.ImageView;, +import com.bumptech.glide.Glide;, +import com.bumptech.glide.samples.flickr.api.Photo;, +, +/**, + * A simple activity for viewing a single photo., + */, +public class FullscreenActivity extends FragmentActivity {, +    private static final String ARG_PHOTO = "photo";, +, +    public static Intent getIntent(Context context, Photo photo) {, +        Intent intent = new Intent(context, FullscreenActivity.class);, +        intent.putExtra(ARG_PHOTO, photo);, +        return intent;, +    }, +, +    @Override, +    protected void onCreate(Bundle savedInstanceState) {, +        super.onCreate(savedInstanceState);, +        setContentView(R.layout.fullscreen_activity);, +        ImageView fullscreenView = (ImageView) findViewById(R.id.fullscreen_view);, +        Photo photo = getIntent().getParcelableExtra(ARG_PHOTO);, +        Glide.with(this), +                .load(photo), +                .fitCenter(), +                .into(fullscreenView);, +    }, +}, +++ b/samples/flickr/src/main/AndroidManifest.xml, +    <activity android:name=".FullscreenActivity" />, +]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import com.bumptech.glide.test.ConcurrencyHelper;, +  private ConcurrencyHelper concurrency = new ConcurrencyHelper();, +    concurrency.get(future);, +    concurrency.get(, +            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));, +    concurrency.get(, +            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));, +    concurrency.get(, +            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));, +    Bitmap bitmap =, +        concurrency.get(, +            GlideApp.with(context), +                .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));, +    concurrency.get(future);, +    concurrency.get(future);, +    concurrency.get(future);, +    concurrency.get(, +            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));, +    concurrency.runOnMainThread(new Runnable() {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import com.bumptech.glide.test.ConcurrencyHelper;, +  private ConcurrencyHelper concurrency = new ConcurrencyHelper();, +    concurrency.get(future);, +    concurrency.get(, +            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));, +    concurrency.get(, +            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));, +    concurrency.get(, +            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));, +    Bitmap bitmap =, +        concurrency.get(, +            GlideApp.with(context), +                .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));, +    concurrency.get(future);, +    concurrency.get(future);, +    concurrency.get(future);, +    concurrency.get(, +            .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS));, +    concurrency.runOnMainThread(new Runnable() {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java, +package com.bumptech.glide.test;, +, +, +import android.os.Handler;, +import android.os.Looper;, +import java.util.concurrent.Callable;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.Future;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.TimeoutException;, +import java.util.concurrent.atomic.AtomicReference;, +, +/**, + * Helper for running sections of code on the main thread in emulator tests., + */, +public class ConcurrencyHelper {, +  private final Handler handler = new Handler(Looper.getMainLooper());, +  private static final long TIMEOUT_MS = 5000;, +  private static final TimeUnit TIMEOUT_UNIT = TimeUnit.MILLISECONDS;, +, +  public <T> T get(Future<T> future) {, +    try {, +      return future.get(TIMEOUT_MS, TIMEOUT_UNIT);, +    } catch (InterruptedException | ExecutionException | TimeoutException e) {, +      throw new RuntimeException(e);, +    }, +  }, +, +  public void runOnMainThread(final Runnable runnable) {, +    callOnMainThread(new Callable<Void>() {, +      @Override, +      public Void call() throws Exception {, +        runnable.run();, +        return null;, +      }, +    });, +  }, +, +  public <T> T callOnMainThread(final Callable<T> callable) {, +    final AtomicReference<T> reference = new AtomicReference<>();, +    final CountDownLatch latch = new CountDownLatch(1);, +    handler.post(new Runnable() {, +      @Override, +      public void run() {, +        try {, +          T result = callable.call();, +          reference.set(result);, +        } catch (Exception e) {, +          throw new RuntimeException(e);, +        }, +        latch.countDown();, +      }, +    });, +    try {, +      latch.await(TIMEOUT_MS, TIMEOUT_UNIT);, +    } catch (InterruptedException e) {, +      throw new RuntimeException(e);, +    }]
[+++ b/.gitignore, +.gradle, +build, +*.iws, +doc/**, +bin/**, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +*.swo, +samples/flickr/target, +integration/volley/target/**, +**/local.properties, +**/out/**, +**/gen-external-apklibs/**, +++ b/.gitignore, +.gradle, +build, +*.iws, +doc/**, +bin/**, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +*.swo, +samples/flickr/target, +integration/volley/target/**, +**/local.properties, +**/out/**, +**/gen-external-apklibs/**, +++ b/.gitmodules, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +[submodule "third_party/disklrucache"], +	path = third_party/disklrucache, +	url = https://github.com/sjudd/DiskLruCache.git, +[submodule "library/src/androidTest/resources/exif-orientation-examples"], +	path = library/src/androidTest/resources/exif-orientation-examples, +++ b/.gitignore, +.gradle, +build, +*.iws, +doc/**, +bin/**, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +*.swo, +samples/flickr/target, +integration/volley/target/**, +**/local.properties, +**/out/**, +**/gen-external-apklibs/**, +++ b/.gitmodules, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +[submodule "third_party/disklrucache"], +	path = third_party/disklrucache, +	url = https://github.com/sjudd/DiskLruCache.git, +[submodule "library/src/androidTest/resources/exif-orientation-examples"], +	path = library/src/androidTest/resources/exif-orientation-examples, +++ b/.travis.yml, +language: android, +android:, +  components:, +  - build-tools-19.1.0, +  licenses: , +  - 'android-sdk-license.*', +, +script: 'travis_retry ./gradlew build', +, +after_success:, +- ./gradlew uploadGlideArchives -PNEXUS_USERNAME="${NEXUS_USERNAME}" -PNEXUS_PASSWORD="${NEXUS_PASSWORD}", +, +env:, +  global:, +  - secure: m/sb1iqIHzL/xCANDf0PHBRtX4ihiccFFWsMWby5PiGDh5ncItjI+kU+Yrgdy/PwmSwwTfB5nXzCdcJe8nLADSLF5PPccuKKO63mGH/Vsai0SJt94+wr+JnBS+T1LmTrlvtlRFEcKjFhOQsnAeJL30iNtQWsoqNSgVrYqUaBdAM=, +  - secure: dMBw5H/o1VsmFX9vama8KWpS3ZbwSgVeNdwByfBgZz82ad1AkYPFN2QNt02qZsopeHCs3w91J1+2ULkEcGpi/eCjRNV449uQyx1DXB0pGkiGq9OAgeZhO/HiRAPqqzJRC4gxgOHBvfxaKm6ZD8THfExWJKTQfXrwFrh+9R4cL3g=, +++ b/.gitignore, +.gradle, +build, +*.iws, +doc/**, +bin/**, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +*.swo, +samples/flickr/target, +integration/volley/target/**, +**/local.properties, +**/out/**, +**/gen-external-apklibs/**, +++ b/.gitmodules, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +[submodule "third_party/disklrucache"], +	path = third_party/disklrucache, +	url = https://github.com/sjudd/DiskLruCache.git, +[submodule "library/src/androidTest/resources/exif-orientation-examples"], +	path = library/src/androidTest/resources/exif-orientation-examples, +++ b/.travis.yml, +language: android, +android:]
[+++ b/build.gradle, +, +++ b/build.gradle, +, +++ b/glide/build.gradle, +apply plugin: 'java', +, +evaluationDependsOn(":third_party:gif_decoder"), +evaluationDependsOn(":third_party:disklrucache"), +evaluationDependsOn(":library"), +, +def getAndroidSdkDirectory() {, +  project(":library").android.sdkDirectory, +}, +, +def getAndroidCompileSdkVersion() {, +  project(":library").android.compileSdkVersion, +}, +, +def getInternalAndroidProjects() {, +    [':third_party:gif_decoder', ':library'].collect { project(it) }, +}, +def getInternalJavaProjects() {, +    [':third_party:disklrucache'].collect { project(it) }, +}, +, +def getAllInternalProjects() {, +    getInternalAndroidProjects() + getInternalJavaProjects(), +}, +, +def getReleaseVariantAndroidProjects() {, +    getAndroidLibraryVariants("release"), +}, +, +def getAndroidLibraryVariants(variantName) {, +    getInternalAndroidProjects().collect { project ->, +        project.android.libraryVariants.findAll { type ->, +            type.buildType.name.equalsIgnoreCase(variantName), +        }, +    }.sum(), +}, +, +def getSourceFilesForVariant(variantName) {, +    getAndroidLibraryVariants(variantName).collect { it.javaCompile.source } +, +            getInternalJavaProjects().collect { it.sourceSets.main.allJava }, +}, +, +def getAndroidJar() {, +    "${getAndroidSdkDirectory()}/platforms/${getAndroidCompileSdkVersion()}/android.jar", +}, +, +// Generate javadocs and sources containing batched documentation and sources for all internal projects., +["release", "debug"].each { variantName ->, +, +    task("${variantName}SourceJar", type: Jar) {, +      classifier = 'sources', +      from getSourceFilesForVariant(variantName), +    }, +, +    def javadocTask = task("${variantName}Javadoc", type: Javadoc) {, +        classifier = 'javadoc', +, +        source = getSourceFilesForVariant(variantName), +, +        classpath = files(getAndroidLibraryVariants(variantName).collect {, +            files(it.javaCompile.classpath.files, getAndroidJar()), +        }), +        classpath += getInternalJavaProjects().collect { files(it.configurations.compile) }, +, +        options {, +            links("http://docs.oracle.com/javase/7/docs/api/"), +            linksOffline("http://d.android.com/reference", "${getAndroidSdkDirectory()}/docs/reference"), +        }, +, +        exclude '**/BuildConfig.java', +        exclude '**/R.java', +    }, +, +    def cleanJavadocTask = task("clean${variantName.capitalize()}Javadoc", type: Delete) {, +        delete javadocTask.destinationDir, +    }, +    clean.dependsOn(cleanJavadocTask), +, +    def javadocJarTask = task("${variantName}JavadocJar", type: Jar) {, +      classifier = 'javadoc', +      from javadocTask.destinationDir, +    }, +    javadocJarTask.dependsOn(javadocTask), +}, +, +jar {, +    from files(, +            getReleaseVariantAndroidProjects().collect { variant ->, +                variant.javaCompile.destinationDir, +            }, +    ), +    exclude "**/R.class", +    exclude "**/BuildConfig.class", +    from files(getInternalJavaProjects().collect { it.sourceSets.main.output }), +}]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java]
[+++ b/samples/giphy/src/main/AndroidManifest.xml, +        android:largeHeap="true", +        <activity android:name=".FullscreenActivity" />, +++ b/samples/giphy/src/main/AndroidManifest.xml, +        android:largeHeap="true", +        <activity android:name=".FullscreenActivity" />, +++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java, +    private static volatile Api api = null;, +++ b/samples/giphy/src/main/AndroidManifest.xml, +        android:largeHeap="true", +        <activity android:name=".FullscreenActivity" />, +++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java, +    private static volatile Api api = null;, +++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java, +package com.bumptech.glide.samples.giphy;, +, +import android.app.Activity;, +import android.content.ClipData;, +import android.content.ClipboardManager;, +import android.content.Context;, +import android.content.Intent;, +import android.os.Bundle;, +import android.view.View;, +import android.widget.ImageView;, +import com.bumptech.glide.Glide;, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +import com.bumptech.glide.load.resource.drawable.GlideDrawable;, +import com.bumptech.glide.load.resource.transcode.BitmapToGlideDrawableTranscoder;, +import com.google.gson.Gson;, +, +/**, + * An {@link android.app.Activity} for displaying full size original GIFs., + */, +public class FullscreenActivity extends Activity {, +    private static final String EXTRA_RESULT_JSON = "result_json";, +, +    public static Intent getIntent(Context context, Api.GifResult result) {, +        Intent intent = new Intent(context, FullscreenActivity.class);, +        intent.putExtra(EXTRA_RESULT_JSON, new Gson().toJson(result));, +        return intent;, +    }, +, +    @Override, +    protected void onCreate(Bundle savedInstanceState) {, +        super.onCreate(savedInstanceState);, +        setContentView(R.layout.fullscreen_activity);, +, +        String resultJson = getIntent().getStringExtra(EXTRA_RESULT_JSON);, +        final Api.GifResult result = new Gson().fromJson(resultJson, Api.GifResult.class);, +, +        ImageView gifView = (ImageView) findViewById(R.id.fullscreen_gif);, +, +        gifView.setOnClickListener(new View.OnClickListener() {, +            @Override, +            public void onClick(View view) {, +                ClipboardManager clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);, +                ClipData clip = ClipData.newPlainText("giphy_url", result.images.original.url);, +                clipboard.setPrimaryClip(clip);, +            }, +        });, +, +        Glide.with(this), +                .load(result.images.original.url), +                .diskCacheStrategy(DiskCacheStrategy.SOURCE), +                .thumbnail(Glide.with(this), +                        .load(result), +                        .asBitmap(), +                        .transcode(new BitmapToGlideDrawableTranscoder(this), GlideDrawable.class), +                        .diskCacheStrategy(DiskCacheStrategy.SOURCE), +                ), +                .into(gifView);, +    }, +}, +++ b/samples/giphy/src/main/AndroidManifest.xml, +        android:largeHeap="true", +        <activity android:name=".FullscreenActivity" />, +++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java, +    private static volatile Api api = null;, +++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java, +package com.bumptech.glide.samples.giphy;, +, +import android.app.Activity;, +import android.content.ClipData;, +import android.content.ClipboardManager;, +import android.content.Context;, +import android.content.Intent;, +import android.os.Bundle;, +import android.view.View;, +import android.widget.ImageView;, +import com.bumptech.glide.Glide;, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +import com.bumptech.glide.load.resource.drawable.GlideDrawable;, +import com.bumptech.glide.load.resource.transcode.BitmapToGlideDrawableTranscoder;, +import com.google.gson.Gson;, +, +/**, + * An {@link android.app.Activity} for displaying full size original GIFs., + */, +public class FullscreenActivity extends Activity {, +    private static final String EXTRA_RESULT_JSON = "result_json";]
[+++ b/.gitignore, +library/build/*, +++ b/.gitignore, +library/build/*, +++ b/.gitmodules, +[submodule "samples/flickr/ActionBarSherlock"], +	path = samples/flickr/ActionBarSherlock, +	url = https://github.com/JakeWharton/ActionBarSherlock.git, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ b/.gitignore, +library/build/*, +++ b/.gitmodules, +[submodule "samples/flickr/ActionBarSherlock"], +	path = samples/flickr/ActionBarSherlock, +	url = https://github.com/JakeWharton/ActionBarSherlock.git, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ /dev/null, +++ b/.gitignore, +library/build/*, +++ b/.gitmodules, +[submodule "samples/flickr/ActionBarSherlock"], +	path = samples/flickr/ActionBarSherlock, +	url = https://github.com/JakeWharton/ActionBarSherlock.git, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ /dev/null, +++ b/LICENSE, +Copyright 2013 Bump Technologies, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY BUMP TECHNOLOGIES, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BUMP TECHNOLOGIES, INC. OR, +or implied, of Bump Technologies, Inc., +++ b/.gitignore, +library/build/*, +++ b/.gitmodules, +[submodule "samples/flickr/ActionBarSherlock"], +	path = samples/flickr/ActionBarSherlock, +	url = https://github.com/JakeWharton/ActionBarSherlock.git, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ /dev/null, +++ b/LICENSE, +Copyright 2013 Bump Technologies, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY BUMP TECHNOLOGIES, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BUMP TECHNOLOGIES, INC. OR, +or implied, of Bump Technologies, Inc., +++ b/Makefile, +	cd library/volley && ant clean && ant jar, +	cp library/volley/bin/volley.jar library/libs, +, +glide-minus-volley:, +	cd library && ant clean && ant glide-minus-volley, +, +++ b/.gitignore, +library/build/*, +++ b/.gitmodules, +[submodule "samples/flickr/ActionBarSherlock"], +	path = samples/flickr/ActionBarSherlock, +	url = https://github.com/JakeWharton/ActionBarSherlock.git, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ /dev/null, +++ b/LICENSE, +Copyright 2013 Bump Technologies, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY BUMP TECHNOLOGIES, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BUMP TECHNOLOGIES, INC. OR, +or implied, of Bump Technologies, Inc., +++ b/Makefile, +	cd library/volley && ant clean && ant jar, +	cp library/volley/bin/volley.jar library/libs, +, +glide-minus-volley:, +	cd library && ant clean && ant glide-minus-volley, +, +++ b/README.md, +Glide is fast and efficient image loading library for Android that wraps image downloading, resizing, memory and disk caching, and bitmap recycling into one simple and easy to use interface. By default, Glide includes an implementation for fetching images over http based on Google's Volley project for fast, parallelized network operations on Android., +Glide's primary focus is on making scrolling any kind of a list of images as smooth and fast as possible, but Glide is also effective for almost any case where you need to fetch, resize, and display a remote image., +You can download a .jar from GitHub's release page for the Glide project. The wiki also has pages on a variety of topics and the javadocs for version 2.0+ will also be available via a link there as well., +    Glide.load("http://goo.gl/h8qOq7").into(imageView);, +    Glide.load(url), +Glide has been in use at Bump for about six months in two of our Android apps at version 1.0. Version 2.0 is the first public release with a stable api. Comments/bugs/questions/pull requests welcome!, +Thanks to the Android project and Jake Wharton for the [disk cache implementation](https://github.com/JakeWharton/DiskLruCache) included with Glide. Thanks also to the Android team for [Volley](https://android.googlesource.com/platform/frameworks/volley/)., +++ b/.gitignore, +library/build/*]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +   *, +   * @deprecated Use {@link #submit(int, int)} instead., +  @Deprecated, +    return submit(width, height);, +  }, +, +  /**, +   * Returns a future that can be used to do a blocking get on a background thread., +   *, +   * <p>This method defaults to {@link Target#SIZE_ORIGINAL} for the width and the height. However,, +   * since the width and height will be overriden by values passed to {@link, +   * RequestOptions#override(int, int)}, this method can be used whenever {@link RequestOptions}, +   * with override values are applied, or whenever you want to retrieve the image in its original, +   * size., +   *, +   * @see #submit(int, int), +   * @see #into(Target), +   */, +  public FutureTarget<TranscodeType> submit() {, +    return submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);, +  }, +, +  /**, +   * Returns a future that can be used to do a blocking get on a background thread., +   *, +   * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be, +   *               overridden by, +   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)} if, +   *               previously called., +   * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be, +   *               overridden by, +   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)}} if, +   *               previously called)., +   */, +  public FutureTarget<TranscodeType> submit(int width, int height) {, +    if (Util.isOnBackgroundThread()) {, +    } else {, +      into(target);, +    }, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +   *, +   * @deprecated Use {@link #submit(int, int)} instead., +  @Deprecated, +    return submit(width, height);, +  }, +, +  /**, +   * Returns a future that can be used to do a blocking get on a background thread., +   *, +   * <p>This method defaults to {@link Target#SIZE_ORIGINAL} for the width and the height. However,, +   * since the width and height will be overriden by values passed to {@link, +   * RequestOptions#override(int, int)}, this method can be used whenever {@link RequestOptions}, +   * with override values are applied, or whenever you want to retrieve the image in its original, +   * size., +   *, +   * @see #submit(int, int), +   * @see #into(Target), +   */, +  public FutureTarget<TranscodeType> submit() {, +    return submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);, +  }, +, +  /**, +   * Returns a future that can be used to do a blocking get on a background thread., +   *, +   * @param width  The desired width in pixels, or {@link Target#SIZE_ORIGINAL}. This will be, +   *               overridden by, +   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)} if, +   *               previously called., +   * @param height The desired height in pixels, or {@link Target#SIZE_ORIGINAL}. This will be, +   *               overridden by, +   *               {@link com.bumptech.glide.request.BaseRequestOptions#override(int, int)}} if, +   *               previously called)., +   */, +  public FutureTarget<TranscodeType> submit(int width, int height) {, +    if (Util.isOnBackgroundThread()) {, +    } else {, +      into(target);, +    }, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +   * A helper method equivalent to calling {@link #asDrawable()} and then {@link, +   * RequestBuilder#load(Object)} with the given model., +   *, +   * @return A new request builder for loading a {@link Drawable} using the given model., +   */, +  public RequestBuilder<Drawable> load(@Nullable Object model) {, +    return asDrawable().load(model);, +  }, +, +  /**, +   * A helper method equivalent to calling {@link #downloadOnly()} ()} and then {@link, +   * RequestBuilder#load(Object)} with the given model., +   *, +   * @return A new request builder for loading a {@link Drawable} using the given model., +   */, +  public RequestBuilder<File> download(@Nullable Object model) {, +    return downloadOnly().load(model);, +  }, +]
[+++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;, +    public BitmapRequestBuilder<ModelType, TranscodeType> cacheDecoder(ResourceDecoder<File, Bitmap> cacheDecoder) {, +     * Transform images using the given {@link com.bumptech.glide.load.resource.bitmap.BitmapTransformation}s., +     *, +     * @see #centerCrop(), +     * @see #fitCenter(), +     * @see #transform(com.bumptech.glide.load.Transformation[]), +     *, +     * @param transformations The transformations to apply in order., +     * @return This request builder., +     */, +    public BitmapRequestBuilder<ModelType, TranscodeType> transform(BitmapTransformation... transformations) {, +        super.transform(transformations);, +        return this;, +    }, +, +    /**, +     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...), +     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...), +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;, +    public BitmapRequestBuilder<ModelType, TranscodeType> cacheDecoder(ResourceDecoder<File, Bitmap> cacheDecoder) {, +     * Transform images using the given {@link com.bumptech.glide.load.resource.bitmap.BitmapTransformation}s., +     *, +     * @see #centerCrop(), +     * @see #fitCenter(), +     * @see #transform(com.bumptech.glide.load.Transformation[]), +     *, +     * @param transformations The transformations to apply in order., +     * @return This request builder., +     */, +    public BitmapRequestBuilder<ModelType, TranscodeType> transform(BitmapTransformation... transformations) {, +        super.transform(transformations);, +        return this;, +    }, +, +    /**, +     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...), +     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...), +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;, +    public DrawableRequestBuilder<ModelType> sizeMultiplier(float sizeMultiplier) {, +    public DrawableRequestBuilder<ModelType> decoder(ResourceDecoder<ImageVideoWrapper, GifBitmapWrapper> decoder) {, +    public DrawableRequestBuilder<ModelType> cacheDecoder(ResourceDecoder<File, GifBitmapWrapper> cacheDecoder) {, +    public DrawableRequestBuilder<ModelType> encoder(ResourceEncoder<GifBitmapWrapper> encoder) {, +     * Transform {@link android.graphics.drawable.Drawable}s using the given, +     * {@link com.bumptech.glide.load.resource.bitmap.BitmapTransformation}s., +     *, +     * <p>, +     *     Note - Bitmap transformations will apply individually to each frame of animated GIF images and also to, +     *     individual {@link Bitmap}s., +     * </p>, +     *, +     * @see #centerCrop(), +     * @see #fitCenter(), +     * @see #bitmapTransform(com.bumptech.glide.load.Transformation[]), +     * @see #transform(com.bumptech.glide.load.Transformation[]), +     *, +     * @param transformations The transformations to apply in order., +     * @return This request builder., +     */, +    public DrawableRequestBuilder<ModelType> transform(BitmapTransformation... transformations) {, +        return bitmapTransform(transformations);, +    }, +, +    /**, +     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...), +     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...), +     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...), +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;, +    public BitmapRequestBuilder<ModelType, TranscodeType> cacheDecoder(ResourceDecoder<File, Bitmap> cacheDecoder) {, +     * Transform images using the given {@link com.bumptech.glide.load.resource.bitmap.BitmapTransformation}s., +     *, +     * @see #centerCrop(), +     * @see #fitCenter(), +     * @see #transform(com.bumptech.glide.load.Transformation[]), +     *, +     * @param transformations The transformations to apply in order., +     * @return This request builder., +     */, +    public BitmapRequestBuilder<ModelType, TranscodeType> transform(BitmapTransformation... transformations) {, +        super.transform(transformations);, +        return this;, +    }, +, +    /**, +     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...), +     * @see #transform(com.bumptech.glide.load.resource.bitmap.BitmapTransformation...), +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;, +    public DrawableRequestBuilder<ModelType> sizeMultiplier(float sizeMultiplier) {, +    public DrawableRequestBuilder<ModelType> decoder(ResourceDecoder<ImageVideoWrapper, GifBitmapWrapper> decoder) {, +    public DrawableRequestBuilder<ModelType> cacheDecoder(ResourceDecoder<File, GifBitmapWrapper> cacheDecoder) {, +    public DrawableRequestBuilder<ModelType> encoder(ResourceEncoder<GifBitmapWrapper> encoder) {, +     * Transform {@link android.graphics.drawable.Drawable}s using the given, +     * {@link com.bumptech.glide.load.resource.bitmap.BitmapTransformation}s., +     *, +     * <p>]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java, +import com.bumptech.glide.load.DecodeFormat;, +        decoder = new GifResourceDecoder(Robolectric.application, bitmapPool, DecodeFormat.PREFER_RGB_565,, +                parserPool, decoderPool);, +, +    @Test, +    public void testSetsPreferredConfigOnDecoderBeforeDecoding() {, +        when(gifHeader.getNumFrames()).thenReturn(1);, +        when(gifHeader.getStatus()).thenReturn(GifDecoder.STATUS_OK);, +        when(gifDecoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));, +, +        decoder = new GifResourceDecoder(Robolectric.application, mock(BitmapPool.class), DecodeFormat.ALWAYS_ARGB_8888,, +                parserPool, decoderPool);, +, +        decoder.decode(new ByteArrayInputStream(new byte[0]), 100, 100);, +, +        InOrder order = inOrder(gifDecoder);, +        order.verify(gifDecoder).setPreferredConfig(eq(Bitmap.Config.ARGB_8888));, +        order.verify(gifDecoder).getNextFrame();, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java, +import com.bumptech.glide.load.DecodeFormat;, +        decoder = new GifResourceDecoder(Robolectric.application, bitmapPool, DecodeFormat.PREFER_RGB_565,, +                parserPool, decoderPool);, +, +    @Test, +    public void testSetsPreferredConfigOnDecoderBeforeDecoding() {, +        when(gifHeader.getNumFrames()).thenReturn(1);, +        when(gifHeader.getStatus()).thenReturn(GifDecoder.STATUS_OK);, +        when(gifDecoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));, +, +        decoder = new GifResourceDecoder(Robolectric.application, mock(BitmapPool.class), DecodeFormat.ALWAYS_ARGB_8888,, +                parserPool, decoderPool);, +, +        decoder.decode(new ByteArrayInputStream(new byte[0]), 100, 100);, +, +        InOrder order = inOrder(gifDecoder);, +        order.verify(gifDecoder).setPreferredConfig(eq(Bitmap.Config.ARGB_8888));, +        order.verify(gifDecoder).getNextFrame();, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +    private DecodeFormat decodeFormat;, +        this.decodeFormat =  other.glide.getDecodeFormat();, +        imageDecoder = new StreamBitmapDecoder(bitmapPool, decodeFormat);, +        videoDecoder = new FileDescriptorBitmapDecoder(bitmapPool, decodeFormat);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java, +import com.bumptech.glide.load.DecodeFormat;, +        decoder = new GifResourceDecoder(Robolectric.application, bitmapPool, DecodeFormat.PREFER_RGB_565,, +                parserPool, decoderPool);, +, +    @Test, +    public void testSetsPreferredConfigOnDecoderBeforeDecoding() {, +        when(gifHeader.getNumFrames()).thenReturn(1);, +        when(gifHeader.getStatus()).thenReturn(GifDecoder.STATUS_OK);, +        when(gifDecoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));, +, +        decoder = new GifResourceDecoder(Robolectric.application, mock(BitmapPool.class), DecodeFormat.ALWAYS_ARGB_8888,, +                parserPool, decoderPool);, +, +        decoder.decode(new ByteArrayInputStream(new byte[0]), 100, 100);, +, +        InOrder order = inOrder(gifDecoder);, +        order.verify(gifDecoder).setPreferredConfig(eq(Bitmap.Config.ARGB_8888));, +        order.verify(gifDecoder).getNextFrame();, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +    private DecodeFormat decodeFormat;, +        this.decodeFormat =  other.glide.getDecodeFormat();, +        imageDecoder = new StreamBitmapDecoder(bitmapPool, decodeFormat);, +        videoDecoder = new FileDescriptorBitmapDecoder(bitmapPool, decodeFormat);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.DecodeFormat;, +    private final DecodeFormat decodeFormat;, +    Glide(Engine engine, MemoryCache memoryCache, BitmapPool bitmapPool, Context context, DecodeFormat decodeFormat) {, +        this.decodeFormat = decodeFormat;, +        StreamBitmapDataLoadProvider streamBitmapLoadProvider =, +                new StreamBitmapDataLoadProvider(bitmapPool, decodeFormat);, +        dataLoadProviderRegistry.register(InputStream.class, Bitmap.class, streamBitmapLoadProvider);, +        FileDescriptorBitmapDataLoadProvider fileDescriptorLoadProvider =, +                new FileDescriptorBitmapDataLoadProvider(bitmapPool, decodeFormat);, +        dataLoadProviderRegistry.register(ParcelFileDescriptor.class, Bitmap.class, fileDescriptorLoadProvider);, +, +        ImageVideoDataLoadProvider imageVideoDataLoadProvider =, +                new ImageVideoDataLoadProvider(streamBitmapLoadProvider, fileDescriptorLoadProvider);, +        GifDrawableLoadProvider gifDrawableLoadProvider =, +                new GifDrawableLoadProvider(context, bitmapPool, decodeFormat);, +    DecodeFormat getDecodeFormat() {, +        return decodeFormat;, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java, +import com.bumptech.glide.load.DecodeFormat;, +        decoder = new GifResourceDecoder(Robolectric.application, bitmapPool, DecodeFormat.PREFER_RGB_565,, +                parserPool, decoderPool);, +, +    @Test, +    public void testSetsPreferredConfigOnDecoderBeforeDecoding() {]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java, +import android.graphics.Bitmap;, +, +    Bitmap firstFrame = drawable.getFirstFrame();, +   return drawable.getBuffer().limit() + Util.getBitmapByteSize(firstFrame.getWidth(),, +       firstFrame.getHeight(), firstFrame.getConfig());, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableResource.java, +import android.graphics.Bitmap;, +, +    Bitmap firstFrame = drawable.getFirstFrame();, +   return drawable.getBuffer().limit() + Util.getBitmapByteSize(firstFrame.getWidth(),, +       firstFrame.getHeight(), firstFrame.getConfig());, +++ b/library/src/main/java/com/bumptech/glide/util/LruCache.java, +  protected synchronized void trimToSize(int size) {]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;, +    registry = new Registry();, +    registry.register(new DefaultImageHeaderParser());, +, +    Downsampler downsampler = new Downsampler(registry.getImageHeaderParsers(),, +        resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);, +, +    registry.register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;, +    registry = new Registry();, +    registry.register(new DefaultImageHeaderParser());, +, +    Downsampler downsampler = new Downsampler(registry.getImageHeaderParsers(),, +        resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);, +, +    registry.register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +import com.bumptech.glide.load.ImageHeaderParser;, +import com.bumptech.glide.provider.ImageHeaderParserRegistry;, +  private final ImageHeaderParserRegistry imageHeaderParserRegistry;, +    this.imageHeaderParserRegistry = new ImageHeaderParserRegistry();, +  public Registry register(ImageHeaderParser parser) {, +    imageHeaderParserRegistry.add(parser);, +    return this;, +  }, +, +  public List<ImageHeaderParser> getImageHeaderParsers() {, +    List<ImageHeaderParser> result = imageHeaderParserRegistry.getParsers();, +    if (result.isEmpty()) {, +      throw new NoImageHeaderParserException();, +    }, +    return result;, +  }, +, +, +  /**, +   * Thrown when no {@link ImageHeaderParser} is registered., +   */, +  public static final class NoImageHeaderParserException extends MissingComponentException {, +    public NoImageHeaderParserException() {, +      super("Failed to find image header parser.");, +    }, +  }, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;, +    registry = new Registry();, +    registry.register(new DefaultImageHeaderParser());, +, +    Downsampler downsampler = new Downsampler(registry.getImageHeaderParsers(),, +        resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);, +, +    registry.register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +import com.bumptech.glide.load.ImageHeaderParser;, +import com.bumptech.glide.provider.ImageHeaderParserRegistry;, +  private final ImageHeaderParserRegistry imageHeaderParserRegistry;, +    this.imageHeaderParserRegistry = new ImageHeaderParserRegistry();, +  public Registry register(ImageHeaderParser parser) {, +    imageHeaderParserRegistry.add(parser);, +    return this;, +  }, +, +  public List<ImageHeaderParser> getImageHeaderParsers() {, +    List<ImageHeaderParser> result = imageHeaderParserRegistry.getParsers();, +    if (result.isEmpty()) {, +      throw new NoImageHeaderParserException();, +    }, +    return result;, +  }, +, +, +  /**, +   * Thrown when no {@link ImageHeaderParser} is registered., +   */, +  public static final class NoImageHeaderParserException extends MissingComponentException {, +    public NoImageHeaderParserException() {, +      super("Failed to find image header parser.");, +    }, +  }, +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java, +package com.bumptech.glide.load;, +, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +import java.io.IOException;, +import java.io.InputStream;, +import java.nio.ByteBuffer;, +, +/**, + * Interface for the ImageHeaderParser., + */, +public interface ImageHeaderParser {, +  /**]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ExternallyClearedDiskCacheTest.java, +package com.bumptech.glide.test;, +, +import static com.google.common.truth.Truth.assertThat;, +import static org.mockito.Mockito.mock;, +, +import android.content.Context;, +import android.graphics.drawable.Drawable;, +import android.support.test.InstrumentationRegistry;, +import android.support.test.runner.AndroidJUnit4;, +import com.bumptech.glide.Glide;, +import com.bumptech.glide.GlideBuilder;, +import com.bumptech.glide.load.Key;, +import com.bumptech.glide.load.engine.cache.DiskCache;, +import com.bumptech.glide.load.engine.cache.DiskCache.Factory;, +import com.bumptech.glide.load.engine.cache.DiskLruCacheWrapper;, +import com.bumptech.glide.test.ResourceIds.raw;, +import java.io.File;, +import org.junit.After;, +import org.junit.Before;, +import org.junit.Rule;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +, +// Tests #2465., +@RunWith(AndroidJUnit4.class), +public class ExternallyClearedDiskCacheTest {, +  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();, +  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();, +  private Context context;, +  private File cacheDir;, +, +  @Before, +  public void setUp() {, +    context = InstrumentationRegistry.getTargetContext();, +    cacheDir = context.getCacheDir();, +  }, +, +  @After, +  public void tearDown() {, +    // Force us to wait until Glide's threads shut down., +    Glide.tearDown();, +    deleteRecursively(cacheDir);, +  }, +, +  @Test, +  public void clearDiskCache_afterOpeningDiskCache_andDeleteDirectoryOutsideGlide_doesNotThrow() {, +    DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);, +    cache.get(mock(Key.class));, +    deleteRecursively(cacheDir);, +    cache.clear();, +  }, +, +  @Test, +  public void get_afterDeleteDirectoryOutsideGlideAndClose_doesNotThrow() {, +    DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);, +    cache.get(mock(Key.class));, +    deleteRecursively(cacheDir);, +    cache.clear();, +, +    cache.get(mock(Key.class));, +  }, +, +  @Test, +  public void loadFromCache_afterDiskCacheDeletedAndCleared_doesNotFail() {, +    final DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);, +    cache.get(mock(Key.class));, +    deleteRecursively(cacheDir);, +    cache.clear();, +, +    Glide.init(, +        context,, +        new GlideBuilder(), +            .setDiskCache(new Factory() {, +              @Override, +              public DiskCache build() {, +                return cache;, +              }, +            }));, +, +    Drawable drawable =, +        concurrency.get(, +            Glide.with(context), +                .load(ResourceIds.raw.canonical), +                .submit());, +    assertThat(drawable).isNotNull();, +  }, +, +  @Test, +  public void loadFromCache_afterDiskCacheDeleted_doesNotFail() {, +    final DiskCache cache = DiskLruCacheWrapper.create(cacheDir, 1024 * 1024);, +    cache.get(mock(Key.class));, +    deleteRecursively(cacheDir);, +, +    Glide.init(, +        context,, +        new GlideBuilder(), +            .setDiskCache(new Factory() {, +              @Override, +              public DiskCache build() {]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java]
[+++ b/integration/volley/build.gradle, +    androidTestCompile project(":testutil"), +++ b/integration/volley/build.gradle, +    androidTestCompile project(":testutil"), +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import com.bumptech.glide.testutil.TestUtil;, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +++ b/integration/volley/build.gradle, +    androidTestCompile project(":testutil"), +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import com.bumptech.glide.testutil.TestUtil;, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +++ b/library/build.gradle, +    androidTestCompile project(':testutil'), +++ b/integration/volley/build.gradle, +    androidTestCompile project(":testutil"), +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import com.bumptech.glide.testutil.TestUtil;, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +++ b/library/build.gradle, +    androidTestCompile project(':testutil'), +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.testutil.TestResourceUtil;, +        return TestResourceUtil.openResource(getClass(), imageName);, +++ b/integration/volley/build.gradle, +    androidTestCompile project(":testutil"), +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import com.bumptech.glide.testutil.TestUtil;, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +++ b/library/build.gradle, +    androidTestCompile project(':testutil'), +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.testutil.TestResourceUtil;, +        return TestResourceUtil.openResource(getClass(), imageName);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java, +import com.bumptech.glide.testutil.TestUtil;, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +++ b/integration/volley/build.gradle, +    androidTestCompile project(":testutil"), +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import com.bumptech.glide.testutil.TestUtil;, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +++ b/library/build.gradle, +    androidTestCompile project(':testutil'), +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.testutil.TestResourceUtil;, +        return TestResourceUtil.openResource(getClass(), imageName);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java, +import com.bumptech.glide.testutil.TestUtil;, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +++ b/library/src/androidTest/java/com/bumptech/glide/resize/load/ExifTest.java, +import com.bumptech.glide.testutil.TestResourceUtil;, +        return TestResourceUtil.openResource(getClass(), "exif-orientation-examples/" + imageName);, +++ b/integration/volley/build.gradle, +    androidTestCompile project(":testutil"), +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import com.bumptech.glide.testutil.TestUtil;, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +++ b/library/build.gradle, +    androidTestCompile project(':testutil'), +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.testutil.TestResourceUtil;, +        return TestResourceUtil.openResource(getClass(), imageName);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java, +import com.bumptech.glide.testutil.TestUtil;, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +        assertEquals(expected, TestUtil.isToString(is));, +++ b/library/src/androidTest/java/com/bumptech/glide/resize/load/ExifTest.java, +import com.bumptech.glide.testutil.TestResourceUtil;, +        return TestResourceUtil.openResource(getClass(), "exif-orientation-examples/" + imageName);, +++ b/settings.gradle]
[+++ b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java, +     * @param quality int greater than 0.]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.model.MediaStoreFileLoader;, +        .append(Uri.class, File.class, new MediaStoreFileLoader.Factory()), +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.model.MediaStoreFileLoader;, +        .append(Uri.class, File.class, new MediaStoreFileLoader.Factory()), +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java, +  public static boolean isMediaStoreUri(Uri uri) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.model.MediaStoreFileLoader;, +        .append(Uri.class, File.class, new MediaStoreFileLoader.Factory()), +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java, +  public static boolean isMediaStoreUri(Uri uri) {, +++ b/library/src/main/java/com/bumptech/glide/load/model/MediaStoreFileLoader.java, +package com.bumptech.glide.load.model;, +, +import android.content.Context;, +import android.database.Cursor;, +import android.net.Uri;, +import android.provider.MediaStore;, +import android.text.TextUtils;, +, +import com.bumptech.glide.Priority;, +import com.bumptech.glide.load.DataSource;, +import com.bumptech.glide.load.Options;, +import com.bumptech.glide.load.data.DataFetcher;, +import com.bumptech.glide.load.data.mediastore.MediaStoreUtil;, +import com.bumptech.glide.signature.ObjectKey;, +, +import java.io.File;, +, +/**, + * Loads the file path for {@link MediaStore} owned {@link Uri uris}., + */, +public final class MediaStoreFileLoader implements ModelLoader<Uri, File>  {, +, +  private final Context context;, +, +  MediaStoreFileLoader(Context context) {, +    this.context = context;, +  }, +, +  @Override, +  public LoadData<File> buildLoadData(Uri uri, int width, int height, Options options) {, +    return new LoadData<>(new ObjectKey(uri), new FilePathFetcher(context, uri));, +  }, +, +  @Override, +  public boolean handles(Uri uri) {, +    return MediaStoreUtil.isMediaStoreUri(uri);, +  }, +, +  private static class FilePathFetcher implements DataFetcher<File> {, +    private static final String[] PROJECTION = new String[] {, +        MediaStore.MediaColumns.DATA,, +    };, +, +    private final Context context;, +    private final Uri uri;, +, +    FilePathFetcher(Context context, Uri uri) {, +      this.context = context;, +      this.uri = uri;, +    }, +, +    @Override, +    public void loadData(Priority priority, DataCallback<? super File> callback) {, +      Cursor cursor = context.getContentResolver().query(uri, PROJECTION, null /*selection*/,, +          null /*selectionArgs*/, null /*sortOrder*/);, +, +      String filePath = null;, +      if (cursor != null) {, +        try {, +          if (cursor.moveToFirst()) {, +            filePath = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.MediaColumns.DATA));, +          }, +        } finally {, +          cursor.close();, +        }, +      }, +, +      if (TextUtils.isEmpty(filePath)) {, +        callback.onDataReady(null);, +      } else {, +        callback.onDataReady(new File(filePath));, +      }, +    }, +, +    @Override, +    public void cleanup() {, +      // Do nothing., +    }, +, +    @Override, +    public void cancel() {, +      // Do nothing., +    }, +, +    @Override, +    public Class<File> getDataClass() {]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java, +package com.bumptech.glide;, +, +import static com.google.common.truth.Truth.assertThat;, +, +import android.content.Context;, +import android.graphics.Bitmap;, +import android.graphics.Bitmap.CompressFormat;, +import android.graphics.drawable.BitmapDrawable;, +import android.graphics.drawable.Drawable;, +import android.net.Uri;, +import android.support.test.InstrumentationRegistry;, +import android.support.test.runner.AndroidJUnit4;, +import android.util.Base64;, +import com.bumptech.glide.test.ConcurrencyHelper;, +import com.bumptech.glide.test.ResourceIds;, +import com.bumptech.glide.test.TearDownGlide;, +import java.io.ByteArrayOutputStream;, +import org.junit.Rule;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +, +@RunWith(AndroidJUnit4.class), +public class DataUriTest {, +  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();, +  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();, +  private final Context context = InstrumentationRegistry.getTargetContext();, +, +  @Test, +  public void load_withJpegAsDataUriString_returnsBitmap() {, +    Bitmap bitmap =, +        concurrency.get(, +            Glide.with(context), +                .asBitmap(), +                .load(getDataUriString(CompressFormat.JPEG)), +                .submit());, +    assertThat(bitmap).isNotNull();, +  }, +, +  @Test, +  public void load_withPngDataUriString_returnsBitmap() {, +    Bitmap bitmap =, +        concurrency.get(, +            Glide.with(context), +                .asBitmap(), +                .load(getDataUriString(CompressFormat.PNG)), +                .submit());, +    assertThat(bitmap).isNotNull();, +  }, +, +  @Test, +  public void load_withJpegAsDataUri_returnsBitmap() {, +    Bitmap bitmap =, +        concurrency.get(, +            Glide.with(context), +                .asBitmap(), +                .load(getDataUri(CompressFormat.JPEG)), +                .submit());, +    assertThat(bitmap).isNotNull();, +  }, +, +  @Test, +  public void load_withPngAsDataUri_returnsBitmap() {, +    Bitmap bitmap =, +        concurrency.get(, +            Glide.with(context), +                .asBitmap(), +                .load(getDataUri(CompressFormat.PNG)), +                .submit());, +    assertThat(bitmap).isNotNull();, +  }, +, +  private Uri getDataUri(CompressFormat format) {, +    return Uri.parse(getDataUriString(format));, +  }, +, +  private String getDataUriString(CompressFormat format) {, +    String bytes = getBase64BitmapBytes(format);, +    String imageType;, +    switch (format) {, +      case PNG:, +        imageType = "png";, +        break;, +      case JPEG:, +        imageType = "jpeg";, +        break;, +      case WEBP:, +        imageType = "webp";, +        break;, +      default:, +        throw new IllegalArgumentException("Unrecognized format: " + format);, +    }, +, +    String mimeType = "image/" + imageType;, +    return "data:" + mimeType + ";base64," + bytes;, +  }, +, +  private String getBase64BitmapBytes(CompressFormat format) {, +    ByteArrayOutputStream bos = new ByteArrayOutputStream();, +    Drawable drawable = context.getResources().getDrawable(ResourceIds.raw.canonical);]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java, +  @Test, +  public void loadWideGamutImage_withArgb888OfSufficientSizeInPool_usesArgb8888Bitmap() {, +    Bitmap wideGamut = Bitmap.createBitmap(100, 50, Bitmap.Config.RGBA_F16);, +    byte[] data = asPng(wideGamut);, +, +    Bitmap argb8888 = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Glide.init(context, new GlideBuilder(), +        .setBitmapPool(new LruBitmapPool(wideGamut.getAllocationByteCount() * 5)));, +    Glide.get(context).getBitmapPool().put(argb8888);, +, +    Bitmap result =, +        concurrency.get(, +            Glide.with(context), +                .asBitmap(), +                .load(data), +                .submit());, +, +    assertThat(result).isSameAs(argb8888);, +  }, +, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java, +  @Test, +  public void loadWideGamutImage_withArgb888OfSufficientSizeInPool_usesArgb8888Bitmap() {, +    Bitmap wideGamut = Bitmap.createBitmap(100, 50, Bitmap.Config.RGBA_F16);, +    byte[] data = asPng(wideGamut);, +, +    Bitmap argb8888 = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Glide.init(context, new GlideBuilder(), +        .setBitmapPool(new LruBitmapPool(wideGamut.getAllocationByteCount() * 5)));, +    Glide.get(context).getBitmapPool().put(argb8888);, +, +    Bitmap result =, +        concurrency.get(, +            Glide.with(context), +                .asBitmap(), +                .load(data), +                .submit());, +, +    assertThat(result).isSameAs(argb8888);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java, +import android.graphics.Bitmap.Config;, +import java.util.Arrays;, +  private static final Bitmap.Config[] ARGB_8888_IN_CONFIGS;, +    Bitmap.Config[] result =, +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {, +      result = Arrays.copyOf(result, result.length + 1);, +      result[result.length - 1] = Config.RGBA_F16;, +    }, +    ARGB_8888_IN_CONFIGS = result;, +  }, +  private static final Bitmap.Config[] RGBA_F16_IN_CONFIGS = ARGB_8888_IN_CONFIGS;, +]
[+++ b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +        Log.v(TAG, message + " in " + LogTime.getElapsedMillis(startTime) + ", key: " + resultKey);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +        Log.v(TAG, message + " in " + LogTime.getElapsedMillis(startTime) + ", key: " + resultKey);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java, +    private static final String EMPTY_LOG_STRING = "";, +                .append("EngineKey{"), +                .append('+'), +                .append("+["), +                .append('x'), +                .append("]+"), +                .append('\''), +                .append(cacheDecoder   != null ? cacheDecoder  .getId() : EMPTY_LOG_STRING), +                .append('\''), +                .append('+'), +                .append('\''), +                .append(decoder        != null ? decoder       .getId() : EMPTY_LOG_STRING), +                .append('\''), +                .append('+'), +                .append('\''), +                .append(transformation != null ? transformation.getId() : EMPTY_LOG_STRING), +                .append('\''), +                .append('+'), +                .append('\''), +                .append(encoder        != null ? encoder       .getId() : EMPTY_LOG_STRING), +                .append('\''), +                .append('+'), +                .append('\''), +                .append(transcoder     != null ? transcoder    .getId() : EMPTY_LOG_STRING), +                .append('\''), +                .append('+'), +                .append('\''), +                .append(sourceEncoder  != null ? sourceEncoder .getId() : EMPTY_LOG_STRING), +                .append('\''), +                .append('}')]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Rotate.java, +package com.bumptech.glide.load.resource.bitmap;, +, +import android.graphics.Bitmap;, +import android.support.annotation.NonNull;, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import com.bumptech.glide.util.Util;, +import java.nio.ByteBuffer;, +import java.security.MessageDigest;, +, +/**, + * A {@link BitmapTransformation} which rotates the bitmap., + */, +public class Rotate extends BitmapTransformation {, +  private static final String ID = "com.bumptech.glide.load.resource.bitmap.Rotate";, +  private static final byte[] ID_BYTES = ID.getBytes(CHARSET);, +, +  private final int degreesToRotate;, +, +  /**, +    * @param degreesToRotate number of degrees to rotate the image by. If zero the original image is, +    *                        not modified., +   */, +  public Rotate(int degreesToRotate) {, +    this.degreesToRotate = degreesToRotate;, +  }, +, +  @Override, +  protected Bitmap transform(, +      @NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth, int outHeight) {, +    return TransformationUtils.rotateImage(toTransform, degreesToRotate);, +  }, +, +  @Override, +  public boolean equals(Object o) {, +    if (o instanceof Rotate) {, +      Rotate other = (Rotate) o;, +      return degreesToRotate == other.degreesToRotate;, +    }, +    return false;, +  }, +, +  @Override, +  public int hashCode() {, +    return Util.hashCode(ID.hashCode(),, +            Util.hashCode(degreesToRotate));, +  }, +, +  @Override, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +    messageDigest.update(ID_BYTES);, +, +    byte[] degreesData = ByteBuffer.allocate(4).putInt(degreesToRotate).array();, +    messageDigest.update(degreesData);, +  }, +}]
[+++ b/.gitmodules, +[submodule "DiskLruCache"], +	path = DiskLruCache, +	url = https://github.com/JakeWharton/DiskLruCache.git, +++ b/.gitmodules, +[submodule "DiskLruCache"], +	path = DiskLruCache, +	url = https://github.com/JakeWharton/DiskLruCache.git, +++ b/DiskLruCache, +Subproject commit 204d41abb60f981a3f8521b7b5cb41deb43281bc, +++ b/.gitmodules, +[submodule "DiskLruCache"], +	path = DiskLruCache, +	url = https://github.com/JakeWharton/DiskLruCache.git, +++ b/DiskLruCache, +Subproject commit 204d41abb60f981a3f8521b7b5cb41deb43281bc, +++ b/libs/android-support-v4.jar, +++ b/.gitmodules, +[submodule "DiskLruCache"], +	path = DiskLruCache, +	url = https://github.com/JakeWharton/DiskLruCache.git, +++ b/DiskLruCache, +Subproject commit 204d41abb60f981a3f8521b7b5cb41deb43281bc, +++ b/libs/android-support-v4.jar, +++ b/src/com/bumptech/photos/LoadedCallback.java, +/*, + * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved., + */, +, +package com.bumptech.photos;, +, +import android.graphics.Bitmap;, +, +/**, + * Created by IntelliJ IDEA., + * User: sam, + * Date: 2/9/12, + * Time: 7:04 PM, + * To change this template use File | Settings | File Templates., + */, +public interface LoadedCallback {, +    public void loadCompleted(Bitmap loaded);, +    public void onLoadFailed(Exception e);, +}, +++ b/.gitmodules, +[submodule "DiskLruCache"], +	path = DiskLruCache, +	url = https://github.com/JakeWharton/DiskLruCache.git, +++ b/DiskLruCache, +Subproject commit 204d41abb60f981a3f8521b7b5cb41deb43281bc, +++ b/libs/android-support-v4.jar, +++ b/src/com/bumptech/photos/LoadedCallback.java, +/*, + * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved., + */, +, +package com.bumptech.photos;, +, +import android.graphics.Bitmap;, +, +/**, + * Created by IntelliJ IDEA., + * User: sam, + * Date: 2/9/12, + * Time: 7:04 PM, + * To change this template use File | Settings | File Templates., + */, +public interface LoadedCallback {, +    public void loadCompleted(Bitmap loaded);, +    public void onLoadFailed(Exception e);, +}, +++ b/src/com/bumptech/photos/PhotoManager.java, +/*, + * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved., + */, +, +package com.bumptech.photos;, +, +import android.graphics.Bitmap;, +import android.os.Build;, +import android.os.Handler;, +import com.bumptech.photos.cache.LruPhotoCache;, +import com.bumptech.photos.cache.PhotoDiskCache;, +import com.bumptech.photos.resize.PhotoStreamResizer;, +, +import java.io.File;, +import java.io.InputStream;, +import java.math.BigInteger;, +import java.security.MessageDigest;, +import java.security.NoSuchAlgorithmException;, +import java.util.HashMap;, +import java.util.Map;, +import java.util.concurrent.Future;, +, +/**, + * Created by IntelliJ IDEA., + * User: sam, + * Date: 2/9/12, + * Time: 5:02 PM, + * To change this template use File | Settings | File Templates.]
[+++ b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java, +++ b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java, +++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +  /**, +   * Keeps track of the set of Bitmaps drawn to the canvas., +   */, +++ b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java, +++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +  /**, +   * Keeps track of the set of Bitmaps drawn to the canvas., +   */, +++ b/library/src/test/java/javax/microedition/khronos/opengles/GL.java, +/**, + * TODO: Figure out why this is necessary and remove it., + * See: https://github.com/robolectric/robolectric-gradle-plugin/issues/145, + */, +++ b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java, +++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +  /**, +   * Keeps track of the set of Bitmaps drawn to the canvas., +   */, +++ b/library/src/test/java/javax/microedition/khronos/opengles/GL.java, +/**, + * TODO: Figure out why this is necessary and remove it., + * See: https://github.com/robolectric/robolectric-gradle-plugin/issues/145, + */, +++ b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/LZWEncoder.java]
[+++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +     *     The {@code source} is managed by the caller, there's no need to close it., +     *     The returned {@link Resource} will be {@link Resource#recycle() released} when the engine sees fit., +     * </p>, +     * <p>, +     *     Note - The {@code width} and {@code height} arguments are hints only,, +     *     there is no requirement that the decoded resource exactly match the given dimensions., +     *     A typical use case would be to use the target dimensions to determine, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +     *     The {@code source} is managed by the caller, there's no need to close it., +     *     The returned {@link Resource} will be {@link Resource#recycle() released} when the engine sees fit., +     * </p>, +     * <p>, +     *     Note - The {@code width} and {@code height} arguments are hints only,, +     *     there is no requirement that the decoded resource exactly match the given dimensions., +     *     A typical use case would be to use the target dimensions to determine, +++ b/library/src/main/java/com/bumptech/glide/load/data/ByteArrayFetcher.java, +        // Do nothing. It's safe to leave a ByteArrayInputStream open., +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +     *     The {@code source} is managed by the caller, there's no need to close it., +     *     The returned {@link Resource} will be {@link Resource#recycle() released} when the engine sees fit., +     * </p>, +     * <p>, +     *     Note - The {@code width} and {@code height} arguments are hints only,, +     *     there is no requirement that the decoded resource exactly match the given dimensions., +     *     A typical use case would be to use the target dimensions to determine, +++ b/library/src/main/java/com/bumptech/glide/load/data/ByteArrayFetcher.java, +        // Do nothing. It's safe to leave a ByteArrayInputStream open., +++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java, +     * @see #cleanup() where the data retuned will be cleaned up, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +     *     The {@code source} is managed by the caller, there's no need to close it., +     *     The returned {@link Resource} will be {@link Resource#recycle() released} when the engine sees fit., +     * </p>, +     * <p>, +     *     Note - The {@code width} and {@code height} arguments are hints only,, +     *     there is no requirement that the decoded resource exactly match the given dimensions., +     *     A typical use case would be to use the target dimensions to determine, +++ b/library/src/main/java/com/bumptech/glide/load/data/ByteArrayFetcher.java, +        // Do nothing. It's safe to leave a ByteArrayInputStream open., +++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java, +     * @see #cleanup() where the data retuned will be cleaned up, +++ b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoModelLoader.java, +, +        @SuppressWarnings("resource"), +        // @see ModelLoader.loadData, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +     *     The {@code source} is managed by the caller, there's no need to close it., +     *     The returned {@link Resource} will be {@link Resource#recycle() released} when the engine sees fit., +     * </p>, +     * <p>, +     *     Note - The {@code width} and {@code height} arguments are hints only,, +     *     there is no requirement that the decoded resource exactly match the given dimensions., +     *     A typical use case would be to use the target dimensions to determine, +++ b/library/src/main/java/com/bumptech/glide/load/data/ByteArrayFetcher.java, +        // Do nothing. It's safe to leave a ByteArrayInputStream open., +++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java, +     * @see #cleanup() where the data retuned will be cleaned up, +++ b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoModelLoader.java, +, +        @SuppressWarnings("resource"), +        // @see ModelLoader.loadData, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDecoder.java, +     * @param resource The resource to decode, managed by the caller, no need to clean it up., +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +     *     The {@code source} is managed by the caller, there's no need to close it., +     *     The returned {@link Resource} will be {@link Resource#recycle() released} when the engine sees fit., +     * </p>, +     * <p>, +     *     Note - The {@code width} and {@code height} arguments are hints only,, +     *     there is no requirement that the decoded resource exactly match the given dimensions., +     *     A typical use case would be to use the target dimensions to determine, +++ b/library/src/main/java/com/bumptech/glide/load/data/ByteArrayFetcher.java, +        // Do nothing. It's safe to leave a ByteArrayInputStream open., +++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java, +     * @see #cleanup() where the data retuned will be cleaned up, +++ b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoModelLoader.java, +, +        @SuppressWarnings("resource"), +        // @see ModelLoader.loadData, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDecoder.java, +     * @param resource The resource to decode, managed by the caller, no need to clean it up., +++ b/library/src/main/java/com/bumptech/glide/load/resource/file/FileToStreamDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +     *     The {@code source} is managed by the caller, there's no need to close it., +     *     The returned {@link Resource} will be {@link Resource#recycle() released} when the engine sees fit., +     * </p>, +     * <p>, +     *     Note - The {@code width} and {@code height} arguments are hints only,, +     *     there is no requirement that the decoded resource exactly match the given dimensions., +     *     A typical use case would be to use the target dimensions to determine, +++ b/library/src/main/java/com/bumptech/glide/load/data/ByteArrayFetcher.java, +        // Do nothing. It's safe to leave a ByteArrayInputStream open., +++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java, +     * @see #cleanup() where the data retuned will be cleaned up, +++ b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoModelLoader.java, +, +        @SuppressWarnings("resource"), +        // @see ModelLoader.loadData, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDecoder.java]
[+++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.request.RequestListener;, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.request.RequestListener;, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.request.RequestListener;, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.request.RequestListener;, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.request.RequestListener;, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +import com.bumptech.glide.request.GenericRequest;, +import com.bumptech.glide.request.RequestListener;, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.request.RequestListener;, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.request.RequestListener;, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +import com.bumptech.glide.request.GenericRequest;, +import com.bumptech.glide.request.RequestListener;, +++ b/library/src/main/java/com/bumptech/glide/request/GenericRequest.java, +package com.bumptech.glide.request;, +, +import android.content.Context;, +import android.graphics.drawable.Drawable;, +import android.util.Log;, +import android.view.animation.Animation;, +import android.view.animation.AnimationUtils;, +import com.bumptech.glide.Priority;, +import com.bumptech.glide.Resource;, +import com.bumptech.glide.load.ResourceDecoder;, +import com.bumptech.glide.load.ResourceEncoder;, +import com.bumptech.glide.load.Transformation;, +import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;, +import com.bumptech.glide.load.engine.Engine;, +import com.bumptech.glide.load.model.ModelLoader;, +import com.bumptech.glide.load.data.DataFetcher;, +import com.bumptech.glide.provider.LoadProvider;, +import com.bumptech.glide.request.target.Target;, +, +import java.io.InputStream;, +, +/**, + * A {@link Request} that loads a {@link Resource} into a given {@link Target}., + *, + * @param <A> The type of the model that the resource will be loaded from., + * @param <T> The type of the data that the resource will be loaded from., + * @param <Z> The type of the resource that will be loaded., + */, +public class GenericRequest<A, T, Z, R> implements Request, Target.SizeReadyCallback, ResourceCallback {, +    private static final String TAG = "Request";, +, +    private final int placeholderResourceId;, +    private final int errorResourceId;, +    private final Context context;, +    private final Transformation<Z> transformation;, +    private final LoadProvider<A, T, Z, R> loadProvider;, +    private final int animationId;, +    private final RequestCoordinator requestCoordinator;, +    private final A model;, +    private Class<R> transcodeClass;, +    private boolean isMemoryCacheable;, +    private Priority priority;, +    private final Target<R> target;, +    private final RequestListener<A> requestListener;, +    private final float sizeMultiplier;, +    private final Engine engine;, +    private Animation animation;, +    private Drawable placeholderDrawable;, +    private Drawable errorDrawable;, +    private boolean isCancelled;, +    private boolean isError;, +    private boolean loadedFromMemoryCache;, +    private Resource resource;, +    private Engine.LoadStatus loadStatus;, +, +    public GenericRequest(LoadProvider<A, T, Z, R> loadProvider, A model, Context context, Priority priority,, +            Target<R> target, float sizeMultiplier, Drawable placeholderDrawable, int placeholderResourceId,, +            Drawable errorDrawable, int errorResourceId, RequestListener<A> requestListener, int animationId,, +            Animation animation, RequestCoordinator requestCoordinator, Engine engine,, +            Transformation<Z> transformation, Class<R> transcodeClass, boolean isMemoryCacheable) {, +        this.loadProvider = loadProvider;, +        this.model = model;, +        this.context = context;, +        this.priority = priority;, +        this.target = target;, +        this.sizeMultiplier = sizeMultiplier;, +        this.placeholderDrawable = placeholderDrawable;, +        this.placeholderResourceId = placeholderResourceId;, +        this.errorDrawable = errorDrawable;, +        this.errorResourceId = errorResourceId;, +        this.requestListener = requestListener;, +        this.animationId = animationId;, +        this.animation = animation;, +        this.requestCoordinator = requestCoordinator;, +        this.engine = engine;, +        this.transformation = transformation;, +        this.transcodeClass = transcodeClass;, +        this.isMemoryCacheable = isMemoryCacheable;, +]
[+++ b/library/src/main/java/com/bumptech/glide/manager/TargetTracker.java, +    return Util.getSnapshot(targets);]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java, +    when(byteArrayPool.get(anyInt())), +        .thenReturn(new byte[ByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java, +    when(byteArrayPool.get(anyInt())), +        .thenReturn(new byte[ByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +    stream = new RecyclableBufferedInputStream(wrapped, byteArrayPool, BUFFER_SIZE);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java, +    when(byteArrayPool.get(anyInt())), +        .thenReturn(new byte[ByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +    stream = new RecyclableBufferedInputStream(wrapped, byteArrayPool, BUFFER_SIZE);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +  /**, +   * Sets the {@link ByteArrayPool} implementation to allow variable sized byte arrays to be stored, +   * and retrieved as needed., +   *, +   * @param byteArrayPool The pool to use., +   * @return This builder., +   */, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java, +    when(byteArrayPool.get(anyInt())), +        .thenReturn(new byte[ByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +    stream = new RecyclableBufferedInputStream(wrapped, byteArrayPool, BUFFER_SIZE);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +  /**, +   * Sets the {@link ByteArrayPool} implementation to allow variable sized byte arrays to be stored, +   * and retrieved as needed., +   *, +   * @param byteArrayPool The pool to use., +   * @return This builder., +   */, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +  // PMD is wrong here, this File must be an instance variable because it may be used across, +  // multiple calls to startNext., +  @SuppressWarnings("PMD.SingularField"), +  private File cacheFile;, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java, +    when(byteArrayPool.get(anyInt())), +        .thenReturn(new byte[ByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +    stream = new RecyclableBufferedInputStream(wrapped, byteArrayPool, BUFFER_SIZE);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +  /**, +   * Sets the {@link ByteArrayPool} implementation to allow variable sized byte arrays to be stored, +   * and retrieved as needed., +   *, +   * @param byteArrayPool The pool to use., +   * @return This builder., +   */, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +  // PMD is wrong here, this File must be an instance variable because it may be used across, +  // multiple calls to startNext., +  @SuppressWarnings("PMD.SingularField"), +  private File cacheFile;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java, +  // PMD is wrong here, this File must be an instance variable because it may be used across, +  // multiple calls to startNext., +  @SuppressWarnings("PMD.SingularField"), +  private File cacheFile;, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java, +    when(byteArrayPool.get(anyInt())), +        .thenReturn(new byte[ByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +    stream = new RecyclableBufferedInputStream(wrapped, byteArrayPool, BUFFER_SIZE);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +  /**, +   * Sets the {@link ByteArrayPool} implementation to allow variable sized byte arrays to be stored, +   * and retrieved as needed., +   *, +   * @param byteArrayPool The pool to use., +   * @return This builder., +   */, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +  // PMD is wrong here, this File must be an instance variable because it may be used across, +  // multiple calls to startNext., +  @SuppressWarnings("PMD.SingularField"), +  private File cacheFile;]
[+++ b/.travis.yml, +script: 'travis_retry ./gradlew build --parallel']
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +    this.context = context.getApplicationContext();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +    this.context = context.getApplicationContext();, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +    this.context = context.getApplicationContext();, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java, +  private static final int BYTES_PER_INTEGER = Integer.SIZE / 8;, +  // Maximum size is 256, see GifHeaderParser.readColorTable, +  // Private color table that can be modified if needed, +  private final int[] pct = new int[256];, +    act = currentFrame.lct != null ? currentFrame.lct : header.gct;, +      // Prepare local copy of color table ("pct = act"), see #1068, +      System.arraycopy(act, 0, pct, 0, act.length);, +      // Forget about act reference from shared header object, use copied version, +      act = pct;, +      // Set transparent color if specified., +      act[currentFrame.transIndex] = 0;, +    // Transfer pixel data to image., +    return setPixels(currentFrame, previousFrame);, +    downsampledWidth = header.width / sampleSize;, +    downsampledHeight = header.height / sampleSize;, +    mainScratch = bitmapProvider.obtainIntArray(downsampledWidth * downsampledHeight);, +          if (currentFrame.lct != null && header.bgIndex == currentFrame.transIndex) {, +            c = 0;, +          }, +        // The area used by the graphic must be restored to the background color., +        int downsampledIH = previousFrame.ih / sampleSize;, +        int downsampledIY = previousFrame.iy / sampleSize;, +        int downsampledIW = previousFrame.iw / sampleSize;, +        int downsampledIX = previousFrame.ix / sampleSize;, +        int topLeft = downsampledIY * downsampledWidth + downsampledIX;, +        int bottomLeft = topLeft + downsampledIH * downsampledWidth;, +        for (int left = topLeft; left < bottomLeft; left += downsampledWidth) {, +          int right = left + downsampledIW;, +          for (int pointer = left; pointer < right; pointer++) {, +            dest[pointer] = c;, +          }, +        }]
[+++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import static com.bumptech.glide.load.engine.DecodeOptions.through;, +import android.content.pm.ApplicationInfo;, +import android.os.Bundle;, +import com.bumptech.glide.module.GlideModule;, +import org.robolectric.res.builder.RobolectricPackageManager;, +, +        RobolectricPackageManager pm = (RobolectricPackageManager) Robolectric.application.getPackageManager();, +        ApplicationInfo info = pm.getApplicationInfo(Robolectric.application.getPackageName(), 0);, +        info.metaData = new Bundle();, +        info.metaData.putString(SetupModule.class.getName(), "GlideModule");, +, +//        ShadowPackageManager spm = Robolectric.shadowOf_(Robolectric.application.getPackageManager());, +//        spm.addGlideModule(SetupModule.class);, +        requestManager, +                .as(byte[].class), +                .decode(through(Robolectric.application, Bitmap.class)), +                .load(uri), +                .into(target);, +                .as(byte[].class), +                .decode(through(Robolectric.application, GifDrawable.class)), +                .as(byte[].class), +                .decode(through(Robolectric.application, Bitmap.class)), +        when(failFetcher.getDataClass()).thenReturn(failResource);, +        when(failLoader.handles(any(failModel))).thenReturn(true);, +        when(fetcher.getDataClass()).thenReturn(InputStream.class);, +        when(modelLoader.handles(any(modelClass))).thenReturn(true);, +    public static class SetupModule implements GlideModule {, +, +        @Override, +        public void applyOptions(Context context, GlideBuilder builder) {, +            // Run all tasks on the main thread so they complete synchronously., +            ExecutorService service = mock(ExecutorService.class);, +            when(service.submit(any(Runnable.class))).thenAnswer(new Answer<Future<?>>() {, +                @Override, +                public Future<?> answer(InvocationOnMock invocation) throws Throwable {, +                    Runnable runnable = (Runnable) invocation.getArguments()[0];, +                    runnable.run();, +                    return mock(Future.class);, +                }, +            });, +            builder, +                .setMemoryCache(mock(MemoryCache.class)), +                .setDiskCache(mock(DiskCache.class)), +                .setResizeService(service), +                .setDiskCacheService(service);, +        }, +, +        @Override, +        public void registerComponents(Context context, Glide glide) {, +            DataFetcher<InputStream> mockStreamFetcher = mock(DataFetcher.class);, +            when(mockStreamFetcher.getId()).thenReturn("fakeId");, +            when(mockStreamFetcher.getDataClass()).thenReturn(InputStream.class);, +            try {, +                when(mockStreamFetcher.loadData(any(Priority.class))).thenReturn(new ByteArrayInputStream(new byte[0]));, +            } catch (Exception e) {, +                throw new RuntimeException(e);, +            }, +            ModelLoader<GlideUrl, InputStream> mockUrlLoader = mock(ModelLoader.class);, +            when(mockUrlLoader.getDataFetcher(any(GlideUrl.class), anyInt(), anyInt())).thenReturn(mockStreamFetcher);, +            when(mockUrlLoader.handles(any(GlideUrl.class))).thenReturn(true);, +            ModelLoaderFactory<GlideUrl, InputStream> mockUrlLoaderFactory = mock(ModelLoaderFactory.class);, +            when(mockUrlLoaderFactory.build(any(Context.class), any(MultiModelLoaderFactory.class))), +                    .thenReturn(mockUrlLoader);, +, +            glide.prepend(GlideUrl.class, InputStream.class, mockUrlLoaderFactory);, +        }, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import static com.bumptech.glide.load.engine.DecodeOptions.through;, +import android.content.pm.ApplicationInfo;, +import android.os.Bundle;, +import com.bumptech.glide.module.GlideModule;, +import org.robolectric.res.builder.RobolectricPackageManager;, +, +        RobolectricPackageManager pm = (RobolectricPackageManager) Robolectric.application.getPackageManager();, +        ApplicationInfo info = pm.getApplicationInfo(Robolectric.application.getPackageName(), 0);, +        info.metaData = new Bundle();, +        info.metaData.putString(SetupModule.class.getName(), "GlideModule");, +, +//        ShadowPackageManager spm = Robolectric.shadowOf_(Robolectric.application.getPackageManager());, +//        spm.addGlideModule(SetupModule.class);, +        requestManager, +                .as(byte[].class), +                .decode(through(Robolectric.application, Bitmap.class)), +                .load(uri), +                .into(target);, +                .as(byte[].class), +                .decode(through(Robolectric.application, GifDrawable.class)), +                .as(byte[].class), +                .decode(through(Robolectric.application, Bitmap.class)), +        when(failFetcher.getDataClass()).thenReturn(failResource);, +        when(failLoader.handles(any(failModel))).thenReturn(true);, +        when(fetcher.getDataClass()).thenReturn(InputStream.class);, +        when(modelLoader.handles(any(modelClass))).thenReturn(true);, +    public static class SetupModule implements GlideModule {, +, +        @Override, +        public void applyOptions(Context context, GlideBuilder builder) {]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/src/com/bumptech/photos/photomanager/LoadedCallback.java, +/*, + * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved., + */, +, +package com.bumptech.photos.photomanager;, +, +import android.graphics.Bitmap;, +, +/**, + * Created by IntelliJ IDEA., + * User: sam, + * Date: 2/9/12, + * Time: 7:04 PM, + * To change this template use File | Settings | File Templates., + */, +public interface LoadedCallback {, +    public void onLoadCompleted(Bitmap loaded);, +    public void onLoadFailed(Exception e);, +}, +++ /dev/null, +++ /dev/null, +++ b/src/com/bumptech/photos/photomanager/LoadedCallback.java, +/*, + * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved., + */, +, +package com.bumptech.photos.photomanager;, +, +import android.graphics.Bitmap;, +, +/**, + * Created by IntelliJ IDEA., + * User: sam, + * Date: 2/9/12, + * Time: 7:04 PM, + * To change this template use File | Settings | File Templates., + */, +public interface LoadedCallback {, +    public void onLoadCompleted(Bitmap loaded);, +    public void onLoadFailed(Exception e);, +}, +++ b/src/com/bumptech/photos/photomanager/PhotoManager.java, +/*, + * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved., + */, +, +package com.bumptech.photos.photomanager;, +, +import android.graphics.Bitmap;, +import android.os.Build;, +import android.os.Handler;, +import android.os.SystemClock;, +import com.bumptech.photos.cache.LruPhotoCache;, +import com.bumptech.photos.cache.PhotoDiskCache;, +import com.bumptech.photos.cache.SizedBitmapCache;, +import com.bumptech.photos.resize.ResizeJobGenerator;, +, +import java.io.File;, +import java.io.InputStream;, +import java.util.HashMap;, +import java.util.Map;, +, +/**, + * Created by IntelliJ IDEA., + * User: sam, + * Date: 2/9/12, + * Time: 5:02 PM, + * To change this template use File | Settings | File Templates., + */, +public class PhotoManager {, +    public static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;, +, +    private PhotoDiskCache diskCache;, +    private LruPhotoCache memoryCache;, +    private ResizeJobGenerator resizer;, +    private Handler backgroundHandler;, +    private Map<Integer, Integer> bitmapReferenceCounter = new HashMap<Integer, Integer>();, +    private SizedBitmapCache bitmapCache = new SizedBitmapCache();, +, +    private enum ResizeType {, +        CENTER_CROP,, +        FIT_CENTER,, +        APPROXIMATE,, +        AS_IS, +    }, +, +    public PhotoManager(int maxMemCacheSize, long maxDiskCacheSize, File diskCacheDir, Handler mainHandler, Handler backgroundHandler) {, +        this.backgroundHandler = backgroundHandler;, +        this.memoryCache = new LruPhotoCache(maxMemCacheSize);, +        memoryCache.setPhotoRemovedListener(new LruPhotoCache.PhotoRemovedListener() {, +            @Override, +            public void onPhotoRemoved(String key, Bitmap bitmap) {, +                releaseBitmap(bitmap);, +            }]
[+++ b/CONTRIBUTING.md, +Similarly if you support a particular feature request, feel free to let us know by commenting on the issue., +[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20%28if%20any%29**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details/Repro%20steps/Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60, +[5]: /bumptech/glide, +++ b/CONTRIBUTING.md, +Similarly if you support a particular feature request, feel free to let us know by commenting on the issue., +[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20%28if%20any%29**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details/Repro%20steps/Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60, +[5]: /bumptech/glide, +++ b/README.md, +    mavenCentral(), +    compile 'com.github.bumptech.glide:glide:3.6.1', +    <version>3.6.1</version>, +@Override, +public void onCreate(Bundle savedInstanceState) {, +@Override, +public View getView(int position, View recycled, ViewGroup container) {, +    Glide.with(myFragment), +OkHttp and Volley, +-----------------, +Support for OkHttp and Volley is provided by integration libraries you can optionally include as dependencies., +The integration libraries are available via Maven or the [releases page][1]., +, +For instructions on including either the OkHttp or the Volley integration libraries, see the [Integration Libraries][12] wiki page., +, +Android SDK Version, +-------------------, +Glide requires a minimum SDK version of 10., +, +License, +-------, +BSD, part MIT and Apache 2.0. See the [LICENSE][16] file for details., +, +[*Version 3*][14] is a stable public release used in multiple open source projects at Google including in the Android Camera, +Comments/bugs/questions/pull requests welcome!, +To open the project in Intellij 14:, +Sam Judd - @samajudd, +[5]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20%28if%20any%29**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details/Repro%20steps/Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60, +++ b/CONTRIBUTING.md, +Similarly if you support a particular feature request, feel free to let us know by commenting on the issue., +[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20%28if%20any%29**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details/Repro%20steps/Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60, +[5]: /bumptech/glide, +++ b/README.md, +    mavenCentral(), +    compile 'com.github.bumptech.glide:glide:3.6.1', +    <version>3.6.1</version>, +@Override, +public void onCreate(Bundle savedInstanceState) {, +@Override, +public View getView(int position, View recycled, ViewGroup container) {, +    Glide.with(myFragment), +OkHttp and Volley, +-----------------, +Support for OkHttp and Volley is provided by integration libraries you can optionally include as dependencies., +The integration libraries are available via Maven or the [releases page][1]., +, +For instructions on including either the OkHttp or the Volley integration libraries, see the [Integration Libraries][12] wiki page., +, +Android SDK Version, +-------------------, +Glide requires a minimum SDK version of 10., +, +License, +-------, +BSD, part MIT and Apache 2.0. See the [LICENSE][16] file for details., +, +[*Version 3*][14] is a stable public release used in multiple open source projects at Google including in the Android Camera, +Comments/bugs/questions/pull requests welcome!, +To open the project in Intellij 14:, +Sam Judd - @samajudd, +[5]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20%28if%20any%29**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details/Repro%20steps/Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +   * Default {@link com.android.volley.Request} implementation for Glide that recives errors and, +++ b/CONTRIBUTING.md, +Similarly if you support a particular feature request, feel free to let us know by commenting on the issue., +[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20%28if%20any%29**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details/Repro%20steps/Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60, +[5]: /bumptech/glide, +++ b/README.md, +    mavenCentral(), +    compile 'com.github.bumptech.glide:glide:3.6.1', +    <version>3.6.1</version>, +@Override, +public void onCreate(Bundle savedInstanceState) {, +@Override, +public View getView(int position, View recycled, ViewGroup container) {, +    Glide.with(myFragment), +OkHttp and Volley, +-----------------, +Support for OkHttp and Volley is provided by integration libraries you can optionally include as dependencies., +The integration libraries are available via Maven or the [releases page][1]., +, +For instructions on including either the OkHttp or the Volley integration libraries, see the [Integration Libraries][12] wiki page., +, +Android SDK Version, +-------------------, +Glide requires a minimum SDK version of 10., +, +License, +-------, +BSD, part MIT and Apache 2.0. See the [LICENSE][16] file for details., +]
[+++ b/.travis.yml]
[+++ b/annotation/compiler/test/build.gradle, +    testImplementation "junit:junit:${JUNIT_VERSION}", +++ b/annotation/compiler/test/build.gradle, +    testImplementation "junit:junit:${JUNIT_VERSION}", +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidAppGlideModuleWithExcludesTest.java, +import static org.junit.Assert.assertThrows;, +import org.junit.function.ThrowingRunnable;, +// Ignore warnings since most methods use assertThrows, +    assertThrows(, +        RuntimeException.class,, +        new ThrowingRunnable() {, +          @Override, +          public void run() throws Throwable {, +        });, +  }, +++ b/annotation/compiler/test/build.gradle, +    testImplementation "junit:junit:${JUNIT_VERSION}", +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidAppGlideModuleWithExcludesTest.java, +import static org.junit.Assert.assertThrows;, +import org.junit.function.ThrowingRunnable;, +// Ignore warnings since most methods use assertThrows, +    assertThrows(, +        RuntimeException.class,, +        new ThrowingRunnable() {, +          @Override, +          public void run() throws Throwable {, +        });, +  }, +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java, +// Avoid warnings when asserting on exceptions., +++ b/annotation/compiler/test/build.gradle, +    testImplementation "junit:junit:${JUNIT_VERSION}", +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidAppGlideModuleWithExcludesTest.java, +import static org.junit.Assert.assertThrows;, +import org.junit.function.ThrowingRunnable;, +// Ignore warnings since most methods use assertThrows, +    assertThrows(, +        RuntimeException.class,, +        new ThrowingRunnable() {, +          @Override, +          public void run() throws Throwable {, +        });, +  }, +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java, +// Avoid warnings when asserting on exceptions., +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java, +import static org.junit.Assert.assertThrows;, +import org.junit.function.ThrowingRunnable;, +// Ignore warnings since most methods use assertThrows., +    assertThrows(, +        RuntimeException.class,, +        new ThrowingRunnable() {, +          @Override, +          public void run() throws Throwable {, +        });, +  }, +    assertThrows(, +        RuntimeException.class,, +        new ThrowingRunnable() {, +          @Override, +          public void run() throws Throwable {, +, +          }, +        });, +    assertThrows(, +        RuntimeException.class,, +        new ThrowingRunnable() {, +          @Override, +          public void run() throws Throwable {, +        });, +  }, +    assertThrows(, +        RuntimeException.class,, +        new ThrowingRunnable() {, +          @Override, +          public void run() throws Throwable {, +        });, +  }, +++ b/annotation/compiler/test/build.gradle, +    testImplementation "junit:junit:${JUNIT_VERSION}", +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidAppGlideModuleWithExcludesTest.java, +import static org.junit.Assert.assertThrows;, +import org.junit.function.ThrowingRunnable;, +// Ignore warnings since most methods use assertThrows, +    assertThrows(, +        RuntimeException.class,, +        new ThrowingRunnable() {, +          @Override, +          public void run() throws Throwable {, +        });, +  }, +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java, +// Avoid warnings when asserting on exceptions., +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java, +import static org.junit.Assert.assertThrows;, +import org.junit.function.ThrowingRunnable;, +// Ignore warnings since most methods use assertThrows., +    assertThrows(, +        RuntimeException.class,, +        new ThrowingRunnable() {]
[+++ b/gradle.properties, +VOLLEY_VERSION=1.0.16, +ROBOLECTRIC_VERSION=3.1, +++ b/gradle.properties, +VOLLEY_VERSION=1.0.16, +ROBOLECTRIC_VERSION=3.1, +++ b/integration/volley/build.gradle, +    compile "com.mcxiaoke.volley:library:${VOLLEY_VERSION}"]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java, +        bitmapPool = mock(BitmapPool.class);, +        Resource<Bitmap> resource = mock(Resource.class);, +        when(resource.get()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444));, +        final Bitmap toTransform = Bitmap.createBitmap(1, 2, Bitmap.Config.RGB_565);, +        Resource<Bitmap> resource = mock(Resource.class);, +        when(resource.get()).thenReturn(toTransform);, +, +        final Bitmap expected = Bitmap.createBitmap(223, 4123, Bitmap.Config.RGB_565);, +                assertEquals(expected, toTransform);, +                return expected;, +        Resource<Bitmap> resource = mock(Resource.class);, +        when(resource.get()).thenReturn(expected);, +        when(resource.get()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565));, +        assertNull(transform.transform(resource, 100, 100));, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java, +        bitmapPool = mock(BitmapPool.class);, +        Resource<Bitmap> resource = mock(Resource.class);, +        when(resource.get()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444));, +        final Bitmap toTransform = Bitmap.createBitmap(1, 2, Bitmap.Config.RGB_565);, +        Resource<Bitmap> resource = mock(Resource.class);, +        when(resource.get()).thenReturn(toTransform);, +, +        final Bitmap expected = Bitmap.createBitmap(223, 4123, Bitmap.Config.RGB_565);, +                assertEquals(expected, toTransform);, +                return expected;, +        Resource<Bitmap> resource = mock(Resource.class);, +        when(resource.get()).thenReturn(expected);, +        when(resource.get()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565));, +        assertNull(transform.transform(resource, 100, 100));, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java, +    public void testSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlpha() {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java, +        bitmapPool = mock(BitmapPool.class);, +        Resource<Bitmap> resource = mock(Resource.class);, +        when(resource.get()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444));, +        final Bitmap toTransform = Bitmap.createBitmap(1, 2, Bitmap.Config.RGB_565);, +        Resource<Bitmap> resource = mock(Resource.class);, +        when(resource.get()).thenReturn(toTransform);, +, +        final Bitmap expected = Bitmap.createBitmap(223, 4123, Bitmap.Config.RGB_565);, +                assertEquals(expected, toTransform);, +                return expected;, +        Resource<Bitmap> resource = mock(Resource.class);, +        when(resource.get()).thenReturn(expected);, +        when(resource.get()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565));, +        assertNull(transform.transform(resource, 100, 100));, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java, +    public void testSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlpha() {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java, +import static org.junit.Assert.assertNotEquals;, +    public void testDoesNotReturnOriginalDrawableOnGet() {, +        when(drawable.getConstantState()).thenReturn(mock(Drawable.ConstantState.class));, +        assertNotEquals(drawable, resource.get());, +    public void testReturnsNewDrawableOnGet() {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java, +        bitmapPool = mock(BitmapPool.class);, +        Resource<Bitmap> resource = mock(Resource.class);, +        when(resource.get()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444));, +        final Bitmap toTransform = Bitmap.createBitmap(1, 2, Bitmap.Config.RGB_565);, +        Resource<Bitmap> resource = mock(Resource.class);, +        when(resource.get()).thenReturn(toTransform);, +, +        final Bitmap expected = Bitmap.createBitmap(223, 4123, Bitmap.Config.RGB_565);, +                assertEquals(expected, toTransform);, +                return expected;, +        Resource<Bitmap> resource = mock(Resource.class);, +        when(resource.get()).thenReturn(expected);, +        when(resource.get()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565));, +        assertNull(transform.transform(resource, 100, 100));, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java, +    public void testSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlpha() {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java, +import static org.junit.Assert.assertNotEquals;, +    public void testDoesNotReturnOriginalDrawableOnGet() {, +        when(drawable.getConstantState()).thenReturn(mock(Drawable.ConstantState.class));, +        assertNotEquals(drawable, resource.get());, +    public void testReturnsNewDrawableOnGet() {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java, +        bitmapPool = mock(BitmapPool.class);, +        Resource<Bitmap> resource = mock(Resource.class);, +        when(resource.get()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444));, +        final Bitmap toTransform = Bitmap.createBitmap(1, 2, Bitmap.Config.RGB_565);, +        Resource<Bitmap> resource = mock(Resource.class);, +        when(resource.get()).thenReturn(toTransform);, +, +        final Bitmap expected = Bitmap.createBitmap(223, 4123, Bitmap.Config.RGB_565);, +                assertEquals(expected, toTransform);, +                return expected;, +        Resource<Bitmap> resource = mock(Resource.class);, +        when(resource.get()).thenReturn(expected);, +        when(resource.get()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565));, +        assertNull(transform.transform(resource, 100, 100));, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java, +    public void testSetsOutBitmapToNotHaveAlphaIfInBitmapDoesNotHaveAlpha() {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java, +import static org.junit.Assert.assertNotEquals;, +    public void testDoesNotReturnOriginalDrawableOnGet() {, +        when(drawable.getConstantState()).thenReturn(mock(Drawable.ConstantState.class));]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    private final GenericLoaderFactory loaderFactory;, +        loaderFactory = new GenericLoaderFactory(context);, +        return Glide.get(context).getLoaderFactory().buildModelLoader(modelClass, resourceClass);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    private final GenericLoaderFactory loaderFactory;, +        loaderFactory = new GenericLoaderFactory(context);, +        return Glide.get(context).getLoaderFactory().buildModelLoader(modelClass, resourceClass);, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +        this.context = context.getApplicationContext();, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    private final GenericLoaderFactory loaderFactory;, +        loaderFactory = new GenericLoaderFactory(context);, +        return Glide.get(context).getLoaderFactory().buildModelLoader(modelClass, resourceClass);, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +        this.context = context.getApplicationContext();, +++ b/library/src/main/java/com/bumptech/glide/load/model/GenericLoaderFactory.java, +    private final Context context;, +, +    public GenericLoaderFactory(Context context) {, +       this.context = context.getApplicationContext();, +    }, +, +     * @deprecated Use {@link #buildModelLoader(Class, Class)} instead., +     * @param modelClass The model class., +     * @param resourceClass The resource class., +     * @param context Unused, +     * @param <T> The type of the model., +     * @param <Y> The type of the resource., +     */, +    @Deprecated, +    public synchronized <T, Y> ModelLoader<T, Y> buildModelLoader(Class<T> modelClass, Class<Y> resourceClass,, +            Context context) {, +        return buildModelLoader(modelClass, resourceClass);, +    }, +, +    /**, +     * Returns a {@link ModelLoader} for the given model and resource classes by either returning a cached, +     * {@link ModelLoader} or building a new a new {@link ModelLoader} using registered {@link ModelLoaderFactory}s., +     * Returns null if no {@link ModelLoaderFactory} is registered for the given classes., +     *, +    public synchronized <T, Y> ModelLoader<T, Y> buildModelLoader(Class<T> modelClass, Class<Y> resourceClass) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    private final GenericLoaderFactory loaderFactory;, +        loaderFactory = new GenericLoaderFactory(context);, +        return Glide.get(context).getLoaderFactory().buildModelLoader(modelClass, resourceClass);, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +        this.context = context.getApplicationContext();, +++ b/library/src/main/java/com/bumptech/glide/load/model/GenericLoaderFactory.java, +    private final Context context;, +, +    public GenericLoaderFactory(Context context) {, +       this.context = context.getApplicationContext();, +    }, +, +     * @deprecated Use {@link #buildModelLoader(Class, Class)} instead., +     * @param modelClass The model class., +     * @param resourceClass The resource class., +     * @param context Unused, +     * @param <T> The type of the model., +     * @param <Y> The type of the resource., +     */, +    @Deprecated, +    public synchronized <T, Y> ModelLoader<T, Y> buildModelLoader(Class<T> modelClass, Class<Y> resourceClass,, +            Context context) {, +        return buildModelLoader(modelClass, resourceClass);, +    }, +, +    /**, +     * Returns a {@link ModelLoader} for the given model and resource classes by either returning a cached, +     * {@link ModelLoader} or building a new a new {@link ModelLoader} using registered {@link ModelLoaderFactory}s., +     * Returns null if no {@link ModelLoaderFactory} is registered for the given classes., +     *, +    public synchronized <T, Y> ModelLoader<T, Y> buildModelLoader(Class<T> modelClass, Class<Y> resourceClass) {, +++ b/library/src/main/java/com/bumptech/glide/load/model/file_descriptor/FileDescriptorFileLoader.java, +            return new FileDescriptorFileLoader(factories.buildModelLoader(Uri.class, ParcelFileDescriptor.class));, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    private final GenericLoaderFactory loaderFactory;, +        loaderFactory = new GenericLoaderFactory(context);, +        return Glide.get(context).getLoaderFactory().buildModelLoader(modelClass, resourceClass);, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +        this.context = context.getApplicationContext();, +++ b/library/src/main/java/com/bumptech/glide/load/model/GenericLoaderFactory.java, +    private final Context context;, +, +    public GenericLoaderFactory(Context context) {, +       this.context = context.getApplicationContext();, +    }, +, +     * @deprecated Use {@link #buildModelLoader(Class, Class)} instead., +     * @param modelClass The model class., +     * @param resourceClass The resource class., +     * @param context Unused, +     * @param <T> The type of the model., +     * @param <Y> The type of the resource., +     */, +    @Deprecated, +    public synchronized <T, Y> ModelLoader<T, Y> buildModelLoader(Class<T> modelClass, Class<Y> resourceClass,, +            Context context) {, +        return buildModelLoader(modelClass, resourceClass);]
[+++ b/annotation/compiler/test/build.gradle, +, +test.maxParallelForks = 2, +, +++ b/annotation/compiler/test/build.gradle, +, +test.maxParallelForks = 2, +, +++ b/build.gradle, +        options.fork = true, +++ b/annotation/compiler/test/build.gradle, +, +test.maxParallelForks = 2, +, +++ b/build.gradle, +        options.fork = true, +++ b/gradle.properties, +org.gradle.jvmargs=-Xmx4096M, +TEST_JVM_MEMORY_SIZE=4096M, +++ b/annotation/compiler/test/build.gradle, +, +test.maxParallelForks = 2, +, +++ b/build.gradle, +        options.fork = true, +++ b/gradle.properties, +org.gradle.jvmargs=-Xmx4096M, +TEST_JVM_MEMORY_SIZE=4096M, +++ b/library/build.gradle, +, +    // Initializing Robolectric is expensive, two threads seem to be around the only level where any, +    // improvement is seen., +    testTask.maxParallelForks = 2]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +  @Deprecated]
[+++ b/.travis.yml, +++ b/.travis.yml, +++ b/scripts/travis-sonatype-publish.sh, +if [ "$SONATYPE_PUBLISH" == "true" ] && [ "$TRAVIS_PULL_REQUEST" == "false" ] && [ "$TRAVIS_BRANCH" == "$SONATYPE_PUBLISH_BRANCH" ]; then]
[+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.load.engine.executor.FifoPriorityThreadPoolExecutor;, +import java.util.concurrent.ExecutorService;, +    private ExecutorService resizeService;, +    private ExecutorService diskCacheService;, +    public GlideBuilder setResizeService(ExecutorService service) {, +        this.resizeService = service;, +        return this;, +    }, +, +    public GlideBuilder setDiskCacheService(ExecutorService service) {, +        this.diskCacheService = service;, +        return this;, +    }, +, +        if (resizeService == null) {, +            final int cores = Math.max(1, Runtime.getRuntime().availableProcessors());, +            resizeService = new FifoPriorityThreadPoolExecutor(cores);, +        }, +        if (diskCacheService == null) {, +            diskCacheService = new FifoPriorityThreadPoolExecutor(1);, +        }, +, +            engine = new Engine(memoryCache, diskCache, resizeService, diskCacheService);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.load.engine.executor.FifoPriorityThreadPoolExecutor;, +import java.util.concurrent.ExecutorService;, +    private ExecutorService resizeService;, +    private ExecutorService diskCacheService;, +    public GlideBuilder setResizeService(ExecutorService service) {, +        this.resizeService = service;, +        return this;, +    }, +, +    public GlideBuilder setDiskCacheService(ExecutorService service) {, +        this.diskCacheService = service;, +        return this;, +    }, +, +        if (resizeService == null) {, +            final int cores = Math.max(1, Runtime.getRuntime().availableProcessors());, +            resizeService = new FifoPriorityThreadPoolExecutor(cores);, +        }, +        if (diskCacheService == null) {, +            diskCacheService = new FifoPriorityThreadPoolExecutor(1);, +        }, +, +            engine = new Engine(memoryCache, diskCache, resizeService, diskCacheService);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +import android.os.Handler;, +import android.os.Looper;, +import com.bumptech.glide.load.engine.cache.DiskCache;, +import java.util.concurrent.ExecutorService;, +    public Engine(MemoryCache memoryCache, DiskCache diskCache, ExecutorService resizeService,, +            ExecutorService diskCacheService) {, +        this(null, memoryCache, diskCache, resizeService, diskCacheService, null, null);, +    Engine(ResourceRunnerFactory factory, MemoryCache cache, DiskCache diskCache, ExecutorService resizeService,, +            ExecutorService diskCacheService, Map<Key, ResourceRunner> runners, KeyFactory keyFactory) {, +, +        if (keyFactory == null) {, +            keyFactory = new EngineKeyFactory();, +        }, +        if (runners == null) {, +            runners = new HashMap<Key, ResourceRunner>();, +        }, +        this.runners = runners;, +        if (factory == null) {, +            factory = new DefaultResourceRunnerFactory(cache, diskCache, new Handler(Looper.getMainLooper()),, +                    diskCacheService, resizeService);, +        }, +        this.factory = factory;, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.load.engine.executor.FifoPriorityThreadPoolExecutor;, +import java.util.concurrent.ExecutorService;, +    private ExecutorService resizeService;, +    private ExecutorService diskCacheService;, +    public GlideBuilder setResizeService(ExecutorService service) {, +        this.resizeService = service;, +        return this;, +    }, +, +    public GlideBuilder setDiskCacheService(ExecutorService service) {, +        this.diskCacheService = service;, +        return this;, +    }, +, +        if (resizeService == null) {, +            final int cores = Math.max(1, Runtime.getRuntime().availableProcessors());, +            resizeService = new FifoPriorityThreadPoolExecutor(cores);, +        }, +        if (diskCacheService == null) {, +            diskCacheService = new FifoPriorityThreadPoolExecutor(1);, +        }, +, +            engine = new Engine(memoryCache, diskCache, resizeService, diskCacheService);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +import android.os.Handler;, +import android.os.Looper;, +import com.bumptech.glide.load.engine.cache.DiskCache;, +import java.util.concurrent.ExecutorService;]
[+++ b/instrumentation/src/androidTest/AndroidManifest.xml, +  <application android:label="GlideTest">, +    <uses-library android:name="android.test.runner" />, +, +  <instrumentation android:targetPackage="com.bumptech.glide.instrumentation", +                   android:name="com.google.android.apps.common.testing.testrunner.Google3InstrumentationTestRunner", +                   android:label="Glide Emulator Tests" />, +++ b/instrumentation/src/androidTest/AndroidManifest.xml, +  <application android:label="GlideTest">, +    <uses-library android:name="android.test.runner" />, +, +  <instrumentation android:targetPackage="com.bumptech.glide.instrumentation", +                   android:name="com.google.android.apps.common.testing.testrunner.Google3InstrumentationTestRunner", +                   android:label="Glide Emulator Tests" />, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java, +++ b/instrumentation/src/androidTest/AndroidManifest.xml, +  <application android:label="GlideTest">, +    <uses-library android:name="android.test.runner" />, +, +  <instrumentation android:targetPackage="com.bumptech.glide.instrumentation", +                   android:name="com.google.android.apps.common.testing.testrunner.Google3InstrumentationTestRunner", +                   android:label="Glide Emulator Tests" />, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java, +    return DiskLruCacheWrapper.create(cacheDir, diskCacheSize);, +++ b/instrumentation/src/androidTest/AndroidManifest.xml, +  <application android:label="GlideTest">, +    <uses-library android:name="android.test.runner" />, +, +  <instrumentation android:targetPackage="com.bumptech.glide.instrumentation", +                   android:name="com.google.android.apps.common.testing.testrunner.Google3InstrumentationTestRunner", +                   android:label="Glide Emulator Tests" />, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java, +    return DiskLruCacheWrapper.create(cacheDir, diskCacheSize);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java, +   *, +   * @deprecated Use {@link #create(File, long)} to create a new cache with the specified arguments., +  @Deprecated, +  /**, +   * Create a new DiskCache in the given directory with a specified max size., +   *, +   * @param directory The directory for the disk cache, +   * @param maxSize   The max size for the disk cache, +   * @return The new disk cache with the given arguments, +   */, +  public static DiskCache create(File directory, long maxSize) {, +    return new DiskLruCacheWrapper(directory, maxSize);, +  }, +, +++ b/instrumentation/src/androidTest/AndroidManifest.xml, +  <application android:label="GlideTest">, +    <uses-library android:name="android.test.runner" />, +, +  <instrumentation android:targetPackage="com.bumptech.glide.instrumentation", +                   android:name="com.google.android.apps.common.testing.testrunner.Google3InstrumentationTestRunner", +                   android:label="Glide Emulator Tests" />, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java, +    return DiskLruCacheWrapper.create(cacheDir, diskCacheSize);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java, +   *, +   * @deprecated Use {@link #create(File, long)} to create a new cache with the specified arguments., +  @Deprecated, +  /**, +   * Create a new DiskCache in the given directory with a specified max size., +   *, +   * @param directory The directory for the disk cache, +   * @param maxSize   The max size for the disk cache, +   * @return The new disk cache with the given arguments, +   */, +  public static DiskCache create(File directory, long maxSize) {, +    return new DiskLruCacheWrapper(directory, maxSize);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/util/LruCache.java]
[+++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.presenter.Presenter;, +import com.bumptech.glide.presenter.ThumbImagePresenter;, +import com.bumptech.glide.resize.Metadata;, +import com.bumptech.glide.resize.Priority;, +        Presenter presenter = target.getPresenter();, +        if (presenter != null) {, +            presenter.clear();, +        public Request<ModelType> thumbnail(float sizeMultiplier) {, +            super.thumbnail(sizeMultiplier);, +            return this;, +        }, +, +        private Float thumbSizeMultiplier;, +        public GenericRequest thumbnail(float sizeMultiplier) {, +            if (sizeMultiplier < 0f || sizeMultiplier > 1f) {, +                throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");, +            }, +            this.thumbSizeMultiplier = sizeMultiplier;, +            return this;, +        }, +, +            Presenter<ModelType> presenter = buildImagePresenter(target);, +            presenter.setModel(model);, +            return target;, +        private <Y extends Target> ImagePresenter.Builder<ModelType, Y> buildImagePresenter(, +                ModelLoader<ModelType, ImageResourceType> imageModelLoader,, +                ModelLoader<ModelType, VideoResourceType> videoModelLoader, final Y target) {, +            return builder;, +        }, +, +, +        private <Y extends Target> Presenter<ModelType> buildImagePresenter(final Y target) {, +, +            ModelLoader<ModelType, ImageResourceType> imageModelLoader = null;, +            if (imageModelLoaderFactory != null) {, +                imageModelLoader = imageModelLoaderFactory.build(context, Glide.get(context).loaderFactory);, +            }, +            ModelLoader<ModelType, VideoResourceType> videoModelLoader = null;, +            if (videoModelLoaderFactory != null) {, +                videoModelLoader = videoModelLoaderFactory.build(context, Glide.get(context).loaderFactory);, +            }, +, +            ImagePresenter.Builder<ModelType, Y> fullBuilder, +                    = buildImagePresenter(imageModelLoader, videoModelLoader, target);, +, +            final Presenter<ModelType> result;, +            if (thumbSizeMultiplier != null) {, +                ImagePresenter.Builder<ModelType, Y> thumbBuilder = buildImagePresenter(imageModelLoader,, +                        videoModelLoader, target);, +                result = new ThumbImagePresenter.Builder<ModelType, Y>(), +                        .setFullPresenterBuilder(fullBuilder), +                        .setThumbPresenterBuilder(thumbBuilder, +                                .setSizeMultiplier(thumbSizeMultiplier), +                                .setMetadata(new Metadata(Priority.HIGH))), +                        .setTarget(target, context), +                        .build();, +            } else {, +                result = fullBuilder.build();, +            }, +            return result;, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.presenter.Presenter;, +import com.bumptech.glide.presenter.ThumbImagePresenter;, +import com.bumptech.glide.resize.Metadata;, +import com.bumptech.glide.resize.Priority;, +        Presenter presenter = target.getPresenter();, +        if (presenter != null) {, +            presenter.clear();, +        public Request<ModelType> thumbnail(float sizeMultiplier) {, +            super.thumbnail(sizeMultiplier);, +            return this;, +        }, +, +        private Float thumbSizeMultiplier;, +        public GenericRequest thumbnail(float sizeMultiplier) {, +            if (sizeMultiplier < 0f || sizeMultiplier > 1f) {, +                throw new IllegalArgumentException("sizeMultiplier must be between 0 and 1");, +            }, +            this.thumbSizeMultiplier = sizeMultiplier;, +            return this;, +        }, +, +            Presenter<ModelType> presenter = buildImagePresenter(target);, +            presenter.setModel(model);, +            return target;, +        private <Y extends Target> ImagePresenter.Builder<ModelType, Y> buildImagePresenter(, +                ModelLoader<ModelType, ImageResourceType> imageModelLoader,, +                ModelLoader<ModelType, VideoResourceType> videoModelLoader, final Y target) {, +            return builder;, +        }, +, +, +        private <Y extends Target> Presenter<ModelType> buildImagePresenter(final Y target) {, +, +            ModelLoader<ModelType, ImageResourceType> imageModelLoader = null;, +            if (imageModelLoaderFactory != null) {, +                imageModelLoader = imageModelLoaderFactory.build(context, Glide.get(context).loaderFactory);, +            }, +            ModelLoader<ModelType, VideoResourceType> videoModelLoader = null;]
[+++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java, +import java.util.Map;, +    private final Headers headers;, +    private final String stringUrl;, +    private String safeStringUrl;, +        this(url, Headers.NONE);, +        this(url, Headers.NONE);, +    }, +, +    public GlideUrl(URL url, Headers headers) {, +        if (url == null) {, +            throw new IllegalArgumentException("URL must not be null!");, +        }, +        if (headers == null) {, +            throw new IllegalArgumentException("Headers must not be null");, +        }, +        this.url = url;, +        stringUrl = null;, +        this.headers = headers;, +    }, +, +    public GlideUrl(String url, Headers headers) {, +        if (headers == null) {, +            throw new IllegalArgumentException("Headers must not be null");, +        }, +        this.headers = headers;, +        if (safeUrl == null) {, +            safeUrl = new URL(getSafeStringUrl());, +        }, +    public String toStringUrl() {, +        return getSafeStringUrl();, +    }, +, +    private String getSafeStringUrl() {, +        if (TextUtils.isEmpty(safeStringUrl)) {, +            String unsafeStringUrl = stringUrl;, +            if (TextUtils.isEmpty(unsafeStringUrl)) {, +                unsafeStringUrl = url.toString();, +            }, +            safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);, +        }, +        return safeStringUrl;, +    }, +, +    public Map<String, String> getHeaders() {, +        return headers.getHeaders();, +        String urlString = getSafeStringUrl();, +        StringBuilder stringBuilder = new StringBuilder(urlString);, +        Map<String, String> headerMap = headers.getHeaders();, +        for (Map.Entry<String, String> entry : headerMap.entrySet()) {, +            stringBuilder.append('\n'), +                .append(entry.getKey()), +                .append(": "), +                .append(entry.getValue());, +        return stringBuilder.toString();, +        if (o instanceof GlideUrl) {, +          GlideUrl other = (GlideUrl) o;, +          return getSafeStringUrl().equals(other.getSafeStringUrl()), +              && headers.equals(other.headers);, +        int hashCode = getSafeStringUrl().hashCode();, +        hashCode = 31 * hashCode + headers.hashCode();, +        return hashCode;, +++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java, +import java.util.Map;, +    private final Headers headers;, +    private final String stringUrl;, +    private String safeStringUrl;, +        this(url, Headers.NONE);, +        this(url, Headers.NONE);, +    }, +, +    public GlideUrl(URL url, Headers headers) {, +        if (url == null) {, +            throw new IllegalArgumentException("URL must not be null!");, +        }, +        if (headers == null) {, +            throw new IllegalArgumentException("Headers must not be null");, +        }, +        this.url = url;, +        stringUrl = null;, +        this.headers = headers;, +    }, +, +    public GlideUrl(String url, Headers headers) {, +        if (headers == null) {, +            throw new IllegalArgumentException("Headers must not be null");, +        }, +        this.headers = headers;, +        if (safeUrl == null) {, +            safeUrl = new URL(getSafeStringUrl());, +        }, +    public String toStringUrl() {, +        return getSafeStringUrl();, +    }, +, +    private String getSafeStringUrl() {, +        if (TextUtils.isEmpty(safeStringUrl)) {, +            String unsafeStringUrl = stringUrl;, +            if (TextUtils.isEmpty(unsafeStringUrl)) {, +                unsafeStringUrl = url.toString();]
[+++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.model.UnitModelLoader;, +        modelLoaderRegistry.append(GifDecoder.class, GifDecoder.class, new UnitModelLoader.Factory<GifDecoder>());, +        modelLoaderRegistry.append(File.class, File.class, new UnitModelLoader.Factory<File>());, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.model.UnitModelLoader;, +        modelLoaderRegistry.append(GifDecoder.class, GifDecoder.class, new UnitModelLoader.Factory<GifDecoder>());, +        modelLoaderRegistry.append(File.class, File.class, new UnitModelLoader.Factory<File>());, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +        return getDownloadOnlyRequest().into(target);, +        return getDownloadOnlyRequest().into(width, height);, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.model.UnitModelLoader;, +        modelLoaderRegistry.append(GifDecoder.class, GifDecoder.class, new UnitModelLoader.Factory<GifDecoder>());, +        modelLoaderRegistry.append(File.class, File.class, new UnitModelLoader.Factory<File>());, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +        return getDownloadOnlyRequest().into(target);, +        return getDownloadOnlyRequest().into(width, height);, +++ b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java, +package com.bumptech.glide.load.model;, +, +import android.content.Context;, +, +import com.bumptech.glide.Priority;, +import com.bumptech.glide.load.data.DataFetcher;, +, +public class UnitModelLoader<ResourceType> implements ModelLoader<ResourceType, ResourceType> {, +, +    @Override, +    public DataFetcher<ResourceType> getDataFetcher(ResourceType model, int width, int height) {, +        return new UnitFetcher<ResourceType>(model);, +    }, +, +    @Override, +    public boolean handles(ResourceType model) {, +        return true;, +    }, +, +    private static class UnitFetcher<ResourceType> implements DataFetcher<ResourceType> {, +, +        private ResourceType resource;, +, +        public UnitFetcher(ResourceType resource) {, +            this.resource = resource;, +        }, +, +        @Override, +        public ResourceType loadData(Priority priority) throws Exception {, +            return resource;, +        }, +, +        @Override, +        public void cleanup() {, +            // Do nothing., +        }, +, +        @Override, +        public String getId() {, +            return resource.toString();, +        }, +, +        @Override, +        public void cancel() {, +            // Do nothing., +        }, +    }, +, +    public static class Factory<ResourceType> implements ModelLoaderFactory<ResourceType, ResourceType> {, +, +        @Override, +        public ModelLoader<ResourceType, ResourceType> build(Context context, MultiModelLoaderFactory multiFactory) {, +            return new UnitModelLoader<ResourceType>();, +        }, +, +        @Override, +        public void teardown() {, +            // Do nothing., +        }, +    }, +}, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.model.UnitModelLoader;, +        modelLoaderRegistry.append(GifDecoder.class, GifDecoder.class, new UnitModelLoader.Factory<GifDecoder>());, +        modelLoaderRegistry.append(File.class, File.class, new UnitModelLoader.Factory<File>());, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +        return getDownloadOnlyRequest().into(target);, +        return getDownloadOnlyRequest().into(width, height);, +++ b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java, +package com.bumptech.glide.load.model;, +, +import android.content.Context;, +, +import com.bumptech.glide.Priority;, +import com.bumptech.glide.load.data.DataFetcher;, +]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java, +import com.bumptech.glide.util.MultiClassKey;, +, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java, +import com.bumptech.glide.util.MultiClassKey;, +, +++ b/library/src/main/java/com/bumptech/glide/provider/DataLoadProviderRegistry.java, +import com.bumptech.glide.util.MultiClassKey;, +, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/TranscoderRegistry.java, +import com.bumptech.glide.util.MultiClassKey;, +, +++ b/library/src/main/java/com/bumptech/glide/provider/DataLoadProviderRegistry.java, +import com.bumptech.glide.util.MultiClassKey;, +, +++ b/library/src/main/java/com/bumptech/glide/util/MultiClassKey.java, +package com.bumptech.glide.util;, +, +/**, + * A key of two {@link Class}es to be used in hashed collections., + */, +public class MultiClassKey {, +    private Class<?> first;, +    private Class<?> second;, +, +    public MultiClassKey() {, +        // leave them null, +    }, +, +    public MultiClassKey(Class<?> first, Class<?> second) {, +        set(first, second);, +    }, +, +    public void set(Class<?> first, Class<?> second) {, +        this.first = first;, +        this.second = second;, +    }, +, +    @Override, +    public String toString() {, +        return "MultiClassKey{", +                + "first=" + first, +                + ", second=" + second, +                + '}';, +    }, +, +    @Override, +    public boolean equals(Object o) {, +        if (this == o) {, +            return true;, +        }, +        if (o == null || getClass() != o.getClass()) {, +            return false;, +        }, +, +        MultiClassKey that = (MultiClassKey) o;, +, +        if (!first.equals(that.first)) {, +            return false;, +        }, +        if (!second.equals(that.second)) {, +            return false;, +        }, +, +        return true;, +    }, +, +    @Override, +    public int hashCode() {, +        int result = first.hashCode();, +        result = 31 * result + second.hashCode();, +        return result;, +    }, +}]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java, +     *   The provided Bitmap, toTransform, should not be recycled or returned to the pool. Glide will automatically, +     *   recycle and/or reuse toTransform if the transformation returns a different Bitmap. Similarly implementations, +     *   should never recycle or return Bitmaps that are returned as the result of this method. Recycling or returning, +     *   the provided and/or the returned Bitmap to the pool will lead to a variety of runtime exceptions and drawing, +     *   errors. See #408 for an example. If the implementation obtains and discards intermediate Bitmaps, they may, +     *   safely be returned to the BitmapPool and/or recycled., +     * </p>, +     *, +     * <p>]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java, +public abstract class DiskCacheStrategy {, +  public static final DiskCacheStrategy ALL = new DiskCacheStrategy() {, +, +    @Override, +    public boolean decodeCachedResource() {, +      return true;, +    }, +, +    @Override, +    public boolean decodeCachedData() {, +      return true;, +    }, +  };, +, +  public static final DiskCacheStrategy NONE = new DiskCacheStrategy() {, +, +    @Override, +    public boolean decodeCachedResource() {, +      return false;, +    }, +, +    @Override, +    public boolean decodeCachedData() {, +      return false;, +    }, +  };, +, +  public static final DiskCacheStrategy DATA = new DiskCacheStrategy() {, +, +    @Override, +    public boolean decodeCachedResource() {, +      return false;, +    }, +, +    @Override, +    public boolean decodeCachedData() {, +      return true;, +    }, +  };, +, +  public static final DiskCacheStrategy RESOURCE = new DiskCacheStrategy() {, +      return true;, +, +    @Override, +    public boolean decodeCachedResource() {, +      return true;, +    }, +, +    @Override, +    public boolean decodeCachedData() {, +      return false;, +    }, +  };, +, +  public static final DiskCacheStrategy AUTOMATIC = new DiskCacheStrategy() {, +    @Override, +    public boolean decodeCachedResource() {, +      return true;, +    @Override, +    public boolean decodeCachedData() {, +      return true;, +    }, +  };, +, +   *, +   * @param dataSource Indicates where the data was originally retrieved., +   *, +   * @param isFromAlternateCacheKey {@code true} if the resource we've decoded was loaded using an, +   *                                alternative, rather than the primary, cache key., +   * @param dataSource Indicates where the data used to decode the resource was originally, +   *                   retrieved., +   * @param encodeStrategy The {@link EncodeStrategy} the {@link, +   * com.bumptech.glide.load.ResourceEncoder} will use to encode the resource., +  public abstract boolean decodeCachedResource();, +  public abstract boolean decodeCachedData();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java, +public abstract class DiskCacheStrategy {, +  public static final DiskCacheStrategy ALL = new DiskCacheStrategy() {, +, +    @Override, +    public boolean decodeCachedResource() {, +      return true;, +    }, +, +    @Override, +    public boolean decodeCachedData() {, +      return true;, +    }, +  };, +, +  public static final DiskCacheStrategy NONE = new DiskCacheStrategy() {, +, +    @Override, +    public boolean decodeCachedResource() {, +      return false;, +    }, +, +    @Override, +    public boolean decodeCachedData() {]
[+++ b/library/src/androidTest/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java, +import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;, +    private RecyclableBufferedInputStream wrapped;, +        wrapped = mock(RecyclableBufferedInputStream.class);, +, +    @Test, +    public void testFixMarkLimitCallsFixMarkLimitOnWrappedStream() {, +        is.fixMarkLimit();, +        verify(wrapped).fixMarkLimit();, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java, +import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;, +    private RecyclableBufferedInputStream wrapped;, +        wrapped = mock(RecyclableBufferedInputStream.class);, +, +    @Test, +    public void testFixMarkLimitCallsFixMarkLimitOnWrappedStream() {, +        is.fixMarkLimit();, +        verify(wrapped).fixMarkLimit();, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +            if (Log.isLoggable(TAG, Log.VERBOSE)) {, +                Log.v(TAG, "Reject bitmap from pool=" + strategy.logBitmap(bitmap) + " is mutable=", +                        + bitmap.isMutable());, +            }, +++ b/library/src/androidTest/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java, +import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;, +    private RecyclableBufferedInputStream wrapped;, +        wrapped = mock(RecyclableBufferedInputStream.class);, +, +    @Test, +    public void testFixMarkLimitCallsFixMarkLimitOnWrappedStream() {, +        is.fixMarkLimit();, +        verify(wrapped).fixMarkLimit();, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +            if (Log.isLoggable(TAG, Log.VERBOSE)) {, +                Log.v(TAG, "Reject bitmap from pool=" + strategy.logBitmap(bitmap) + " is mutable=", +                        + bitmap.isMutable());, +            }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +, +                    downsampleWithSize(stream, options, pool, inWidth, inHeight, sampleSize,, +                            decodeFormat);, +            // BitmapFactory swallows exceptions during decodes and in some cases when inBitmap is non null, may catch, +    private Bitmap downsampleWithSize(ExceptionCatchingInputStream is, BitmapFactory.Options options, BitmapPool pool,, +            int inWidth, int inHeight, int sampleSize, DecodeFormat decodeFormat) {, +    public int[] getDimensions(ExceptionCatchingInputStream is, BitmapFactory.Options options) {, +    private static Bitmap decodeStream(ExceptionCatchingInputStream is, BitmapFactory.Options options) {, +         } else {, +             // Once we've read the image header, we no longer need to allow the buffer to expand in size. To avoid, +             // unnecessary allocations reading image data, we fix the mark limit so that it is no larger than our, +             // current buffer size here. See issue #225., +             is.fixMarkLimit();, +++ b/library/src/androidTest/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java, +import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;, +    private RecyclableBufferedInputStream wrapped;, +        wrapped = mock(RecyclableBufferedInputStream.class);, +, +    @Test, +    public void testFixMarkLimitCallsFixMarkLimitOnWrappedStream() {, +        is.fixMarkLimit();, +        verify(wrapped).fixMarkLimit();, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +            if (Log.isLoggable(TAG, Log.VERBOSE)) {, +                Log.v(TAG, "Reject bitmap from pool=" + strategy.logBitmap(bitmap) + " is mutable=", +                        + bitmap.isMutable());, +            }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +, +                    downsampleWithSize(stream, options, pool, inWidth, inHeight, sampleSize,, +                            decodeFormat);, +            // BitmapFactory swallows exceptions during decodes and in some cases when inBitmap is non null, may catch, +    private Bitmap downsampleWithSize(ExceptionCatchingInputStream is, BitmapFactory.Options options, BitmapPool pool,, +            int inWidth, int inHeight, int sampleSize, DecodeFormat decodeFormat) {, +    public int[] getDimensions(ExceptionCatchingInputStream is, BitmapFactory.Options options) {, +    private static Bitmap decodeStream(ExceptionCatchingInputStream is, BitmapFactory.Options options) {, +         } else {, +             // Once we've read the image header, we no longer need to allow the buffer to expand in size. To avoid, +             // unnecessary allocations reading image data, we fix the mark limit so that it is no larger than our, +             // current buffer size here. See issue #225., +             is.fixMarkLimit();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java, +import android.util.Log;, +, +    private static final String TAG = "BufferedIs";, +    private volatile byte[] buf;, +    private int count;, +    private int marklimit;, +    private int markpos = -1;, +    private int pos;, +     * Reduces the mark limit to match the current buffer length to prevent the buffer from, +     * continuing to increase in size., +     *, +     * <p>Subsequent calls to {@link #mark(int)} will be obeyed and may cause the buffer size]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import com.bumptech.glide.load.Transformation;, +   * {@link android.graphics.drawable.VectorDrawable}s. Although Glide makes a best effort to apply, +   * {@link com.bumptech.glide.load.Transformation}s to these {@link Drawable}s by either extracting, +   * the underlying {@link Bitmap} or by converting the {@link Drawable} to a {@link Bitmap}, Glide, +   * is still not able to transform all types of resources. Animated {@link Drawable}s cannot be, +   * transformed (other than {@link com.bumptech.glide.load.resource.gif.GifDrawable}). To avoid, +   * load failures if a {@link Drawable} can't be transformed, use the optional transformation, +   * methods like {@link RequestOptions#optionalTransform(Class, Transformation)}., +   *, +   * <p>In some cases converting {@link Drawable}s to {@link Bitmap}s may be inefficient. Use this, +   * method, especially in conjunction with {@link com.bumptech.glide.load.Transformation}s with, +   * caution for non-{@link Bitmap} {@link Drawable}s.]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerAllocationTest.java, +    private static final int DEFAULT_BITMAP_SIZE = Util.getBitmapByteSize(DEFAULT_BITMAP);, +            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +            int currentSize = Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerAllocationTest.java, +    private static final int DEFAULT_BITMAP_SIZE = Util.getBitmapByteSize(DEFAULT_BITMAP);, +            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +            int currentSize = Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/PreFillerHandlerTest.java, +        when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap));, +        when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap) / 2);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerAllocationTest.java, +    private static final int DEFAULT_BITMAP_SIZE = Util.getBitmapByteSize(DEFAULT_BITMAP);, +            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +            int currentSize = Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/PreFillerHandlerTest.java, +        when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap));, +        when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap) / 2);, +++ b/library/src/androidTest/java/com/bumptech/glide/util/UtilTest.java, +        int initialSize = Util.getBitmapByteSize(width, height, config);, +        int sizeOne = Util.getBitmapByteSize(width * 2, height, config);, +        int sizeTwo = Util.getBitmapByteSize(width, height * 2, config);, +        int size = Util.getBitmapByteSize(width, height, Bitmap.Config.ALPHA_8);, +        int size = Util.getBitmapByteSize(width, height, Bitmap.Config.RGB_565);, +        int size = Util.getBitmapByteSize(width, height, Bitmap.Config.ARGB_4444);, +        int size = Util.getBitmapByteSize(width, height, Bitmap.Config.ARGB_8888);, +        int size = Util.getBitmapByteSize(width, height, null);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerAllocationTest.java, +    private static final int DEFAULT_BITMAP_SIZE = Util.getBitmapByteSize(DEFAULT_BITMAP);, +            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +            int currentSize = Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/PreFillerHandlerTest.java, +        when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap));, +        when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap) / 2);, +++ b/library/src/androidTest/java/com/bumptech/glide/util/UtilTest.java, +        int initialSize = Util.getBitmapByteSize(width, height, config);, +        int sizeOne = Util.getBitmapByteSize(width * 2, height, config);, +        int sizeTwo = Util.getBitmapByteSize(width, height * 2, config);, +        int size = Util.getBitmapByteSize(width, height, Bitmap.Config.ALPHA_8);, +        int size = Util.getBitmapByteSize(width, height, Bitmap.Config.RGB_565);, +        int size = Util.getBitmapByteSize(width, height, Bitmap.Config.ARGB_4444);, +        int size = Util.getBitmapByteSize(width, height, Bitmap.Config.ARGB_8888);, +        int size = Util.getBitmapByteSize(width, height, null);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java, +        return Util.getBitmapByteSize(bitmap);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerAllocationTest.java, +    private static final int DEFAULT_BITMAP_SIZE = Util.getBitmapByteSize(DEFAULT_BITMAP);, +            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +            int currentSize = Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/PreFillerHandlerTest.java, +        when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap));, +        when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap) / 2);, +++ b/library/src/androidTest/java/com/bumptech/glide/util/UtilTest.java, +        int initialSize = Util.getBitmapByteSize(width, height, config);, +        int sizeOne = Util.getBitmapByteSize(width * 2, height, config);, +        int sizeTwo = Util.getBitmapByteSize(width, height * 2, config);, +        int size = Util.getBitmapByteSize(width, height, Bitmap.Config.ALPHA_8);, +        int size = Util.getBitmapByteSize(width, height, Bitmap.Config.RGB_565);, +        int size = Util.getBitmapByteSize(width, height, Bitmap.Config.ARGB_4444);, +        int size = Util.getBitmapByteSize(width, height, Bitmap.Config.ARGB_8888);, +        int size = Util.getBitmapByteSize(width, height, null);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java, +        return Util.getBitmapByteSize(bitmap);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java, +        int size = Util.getBitmapByteSize(bitmap);, +        final int size = Util.getBitmapByteSize(width, height, config);, +            final int removedSize = Util.getBitmapByteSize(removed);, +        int size = Util.getBitmapByteSize(width, height, config);, +        return Util.getBitmapByteSize(bitmap);, +        int size = Util.getBitmapByteSize(bitmap);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerAllocationTest.java, +    private static final int DEFAULT_BITMAP_SIZE = Util.getBitmapByteSize(DEFAULT_BITMAP);, +            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +            int currentSize = Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +            byteSize += Util.getBitmapByteSize(current.getWidth(), current.getHeight(), current.getConfig());, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/PreFillerHandlerTest.java, +        when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap));, +        when(cache.getMaxSize()).thenReturn(Util.getBitmapByteSize(bitmap) / 2);, +++ b/library/src/androidTest/java/com/bumptech/glide/util/UtilTest.java, +        int initialSize = Util.getBitmapByteSize(width, height, config);, +        int sizeOne = Util.getBitmapByteSize(width * 2, height, config);, +        int sizeTwo = Util.getBitmapByteSize(width, height * 2, config);, +        int size = Util.getBitmapByteSize(width, height, Bitmap.Config.ALPHA_8);, +        int size = Util.getBitmapByteSize(width, height, Bitmap.Config.RGB_565);, +        int size = Util.getBitmapByteSize(width, height, Bitmap.Config.ARGB_4444);, +        int size = Util.getBitmapByteSize(width, height, Bitmap.Config.ARGB_8888);, +        int size = Util.getBitmapByteSize(width, height, null);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategy.java, +        return Util.getBitmapByteSize(bitmap);]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +   * <p> Callers must <em>not</em> continue to use the Bitmap after calling this method. </p>]
[+++ b/.gitmodules, +[submodule "third_party/disklrucache/disklrucache"], +	path = third_party/disklrucache/disklrucache, +	url = https://github.com/sjudd/DiskLruCache.git, +++ b/.gitmodules, +[submodule "third_party/disklrucache/disklrucache"], +	path = third_party/disklrucache/disklrucache, +	url = https://github.com/sjudd/DiskLruCache.git, +++ b/library/build.gradle, +    compile project(':third_party:disklrucache:disklrucache'), +++ b/.gitmodules, +[submodule "third_party/disklrucache/disklrucache"], +	path = third_party/disklrucache/disklrucache, +	url = https://github.com/sjudd/DiskLruCache.git, +++ b/library/build.gradle, +    compile project(':third_party:disklrucache:disklrucache'), +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java, +import java.io.FileInputStream;, +import java.io.FileOutputStream;, +            final DiskLruCache.Value value = getDiskCache().get(safeKey);, +            if (value != null) {, +                result = new FileInputStream(value.getFile(0));, +                    File file = editor.getFile(0);, +                    os = new FileOutputStream(file);, +++ b/.gitmodules, +[submodule "third_party/disklrucache/disklrucache"], +	path = third_party/disklrucache/disklrucache, +	url = https://github.com/sjudd/DiskLruCache.git, +++ b/library/build.gradle, +    compile project(':third_party:disklrucache:disklrucache'), +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java, +import java.io.FileInputStream;, +import java.io.FileOutputStream;, +            final DiskLruCache.Value value = getDiskCache().get(safeKey);, +            if (value != null) {, +                result = new FileInputStream(value.getFile(0));, +                    File file = editor.getFile(0);, +                    os = new FileOutputStream(file);, +++ b/settings.gradle, +include ':third_party:disklrucache:disklrucache', +++ b/.gitmodules, +[submodule "third_party/disklrucache/disklrucache"], +	path = third_party/disklrucache/disklrucache, +	url = https://github.com/sjudd/DiskLruCache.git, +++ b/library/build.gradle, +    compile project(':third_party:disklrucache:disklrucache'), +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java, +import java.io.FileInputStream;, +import java.io.FileOutputStream;, +            final DiskLruCache.Value value = getDiskCache().get(safeKey);, +            if (value != null) {, +                result = new FileInputStream(value.getFile(0));, +                    File file = editor.getFile(0);, +                    os = new FileOutputStream(file);, +++ b/settings.gradle, +include ':third_party:disklrucache:disklrucache', +++ b/third_party/disklrucache/disklrucache, +Subproject commit 065a663f4d66f699b430a7b322c1a0d5ff6275e1, +++ b/.gitmodules, +[submodule "third_party/disklrucache/disklrucache"], +	path = third_party/disklrucache/disklrucache, +	url = https://github.com/sjudd/DiskLruCache.git, +++ b/library/build.gradle, +    compile project(':third_party:disklrucache:disklrucache'), +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java, +import java.io.FileInputStream;, +import java.io.FileOutputStream;, +            final DiskLruCache.Value value = getDiskCache().get(safeKey);, +            if (value != null) {, +                result = new FileInputStream(value.getFile(0));, +                    File file = editor.getFile(0);, +                    os = new FileOutputStream(file);, +++ b/settings.gradle, +include ':third_party:disklrucache:disklrucache', +++ b/third_party/disklrucache/disklrucache, +Subproject commit 065a663f4d66f699b430a7b322c1a0d5ff6275e1, +++ /dev/null]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +import android.util.Log;, +import com.bumptech.glide.load.engine.cache.MemoryCache;, +import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;, +import com.bumptech.glide.util.LogTime;, +    private static final String TAG = "Engine";, +        long startTime = LogTime.getLogTime();, +            if (Log.isLoggable(TAG, Log.VERBOSE)) {, +                Log.v(TAG, "loaded resource from cache in " + LogTime.getElapsedMillis(startTime));, +            }, +            if (Log.isLoggable(TAG, Log.VERBOSE)) {, +                Log.v(TAG, "added to existing load in " + LogTime.getElapsedMillis(startTime));, +            }, +        long start = LogTime.getLogTime();, +        if (Log.isLoggable(TAG, Log.VERBOSE)) {, +            Log.v(TAG, "queued new load in " + LogTime.getElapsedMillis(start));, +            Log.v(TAG, "finished load in engine in " + LogTime.getElapsedMillis(startTime));, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +import android.util.Log;, +import com.bumptech.glide.load.engine.cache.MemoryCache;, +import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;, +import com.bumptech.glide.util.LogTime;, +    private static final String TAG = "Engine";, +        long startTime = LogTime.getLogTime();, +            if (Log.isLoggable(TAG, Log.VERBOSE)) {, +                Log.v(TAG, "loaded resource from cache in " + LogTime.getElapsedMillis(startTime));, +            }, +            if (Log.isLoggable(TAG, Log.VERBOSE)) {, +                Log.v(TAG, "added to existing load in " + LogTime.getElapsedMillis(startTime));, +            }, +        long start = LogTime.getLogTime();, +        if (Log.isLoggable(TAG, Log.VERBOSE)) {, +            Log.v(TAG, "queued new load in " + LogTime.getElapsedMillis(start));, +            Log.v(TAG, "finished load in engine in " + LogTime.getElapsedMillis(startTime));, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +import android.util.Log;, +import com.bumptech.glide.util.LogTime;, +    private static final String TAG = "EngineJob";, +        final long start = LogTime.getLogTime();, +                if (Log.isLoggable(TAG, Log.VERBOSE)) {, +                    Log.v(TAG, "Posted to main thread in onResourceReady in " + LogTime.getElapsedMillis(start), +                            + " cancelled: " + isCancelled);, +                }, +                if (Log.isLoggable(TAG, Log.VERBOSE)) {, +                    Log.v(TAG, "Finished resource ready in " + LogTime.getElapsedMillis(start));, +                }, +        final long start = LogTime.getLogTime();, +                if (Log.isLoggable(TAG, Log.VERBOSE)) {, +                    Log.v(TAG, "posted to main thread in onException in " + LogTime.getElapsedMillis(start), +                            + " cancelled: " + isCancelled);, +                }, +                if (Log.isLoggable(TAG, Log.VERBOSE)) {, +                    Log.v(TAG, "finished onException in " + LogTime.getElapsedMillis(start));, +                }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +import android.util.Log;, +import com.bumptech.glide.load.engine.cache.MemoryCache;, +import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;, +import com.bumptech.glide.util.LogTime;, +    private static final String TAG = "Engine";, +        long startTime = LogTime.getLogTime();, +            if (Log.isLoggable(TAG, Log.VERBOSE)) {, +                Log.v(TAG, "loaded resource from cache in " + LogTime.getElapsedMillis(startTime));, +            }, +            if (Log.isLoggable(TAG, Log.VERBOSE)) {, +                Log.v(TAG, "added to existing load in " + LogTime.getElapsedMillis(startTime));, +            }, +        long start = LogTime.getLogTime();, +        if (Log.isLoggable(TAG, Log.VERBOSE)) {, +            Log.v(TAG, "queued new load in " + LogTime.getElapsedMillis(start));, +            Log.v(TAG, "finished load in engine in " + LogTime.getElapsedMillis(startTime));, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +import android.util.Log;, +import com.bumptech.glide.util.LogTime;, +    private static final String TAG = "EngineJob";, +        final long start = LogTime.getLogTime();, +                if (Log.isLoggable(TAG, Log.VERBOSE)) {, +                    Log.v(TAG, "Posted to main thread in onResourceReady in " + LogTime.getElapsedMillis(start), +                            + " cancelled: " + isCancelled);, +                }, +                if (Log.isLoggable(TAG, Log.VERBOSE)) {, +                    Log.v(TAG, "Finished resource ready in " + LogTime.getElapsedMillis(start));, +                }, +        final long start = LogTime.getLogTime();, +                if (Log.isLoggable(TAG, Log.VERBOSE)) {, +                    Log.v(TAG, "posted to main thread in onException in " + LogTime.getElapsedMillis(start), +                            + " cancelled: " + isCancelled);, +                }, +                if (Log.isLoggable(TAG, Log.VERBOSE)) {, +                    Log.v(TAG, "finished onException in " + LogTime.getElapsedMillis(start));, +                }, +++ b/library/src/main/java/com/bumptech/glide/request/GenericRequest.java, +import com.bumptech.glide.util.LogTime;, +    private long startTime;, +        startTime = LogTime.getLogTime();, +        if (Log.isLoggable(TAG, Log.VERBOSE)) {, +            logV("finished run method in " + LogTime.getElapsedMillis(startTime));]
[+++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +            transformations[i] = new GifBitmapWrapperTransformation(glide.getBitmapPool(), bitmapTransformations[i]);, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +            transformations[i] = new GifBitmapWrapperTransformation(glide.getBitmapPool(), bitmapTransformations[i]);, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +            transformations[i] = new GifBitmapWrapperTransformation(glide.getBitmapPool(), bitmapTransformations[i]);, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/GifRequestBuilder.java, +import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;, +public class GifRequestBuilder<ModelType>, +        extends GenericRequestBuilder<ModelType, InputStream, GifDrawable, GifDrawable>, +            LoadProvider<ModelType, InputStream, GifDrawable, GifDrawable> loadProvider, Glide glide,, +            RequestTracker requestTracker, Lifecycle lifecycle) {, +            GenericRequestBuilder<ModelType, InputStream, GifDrawable, GifDrawable> thumbnailRequest) {, +            ResourceDecoder<InputStream, GifDrawable> decoder) {, +            ResourceDecoder<File, GifDrawable> cacheDecoder) {, +            ResourceEncoder<GifDrawable> encoder) {, +    private GifDrawableTransformation[] toGifTransformations(Transformation<Bitmap>[] bitmapTransformations) {, +        GifDrawableTransformation[] transformations = new GifDrawableTransformation[bitmapTransformations.length];, +            transformations[i] = new GifDrawableTransformation(bitmapTransformations[i], glide.getBitmapPool());, +    public GifRequestBuilder<ModelType> transform(Transformation<GifDrawable>... transformations) {, +    public GifRequestBuilder<ModelType> transcoder(ResourceTranscoder<GifDrawable, GifDrawable> transcoder) {, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +            transformations[i] = new GifBitmapWrapperTransformation(glide.getBitmapPool(), bitmapTransformations[i]);, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/GifRequestBuilder.java, +import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;, +public class GifRequestBuilder<ModelType>, +        extends GenericRequestBuilder<ModelType, InputStream, GifDrawable, GifDrawable>, +            LoadProvider<ModelType, InputStream, GifDrawable, GifDrawable> loadProvider, Glide glide,, +            RequestTracker requestTracker, Lifecycle lifecycle) {, +            GenericRequestBuilder<ModelType, InputStream, GifDrawable, GifDrawable> thumbnailRequest) {, +            ResourceDecoder<InputStream, GifDrawable> decoder) {, +            ResourceDecoder<File, GifDrawable> cacheDecoder) {, +            ResourceEncoder<GifDrawable> encoder) {, +    private GifDrawableTransformation[] toGifTransformations(Transformation<Bitmap>[] bitmapTransformations) {, +        GifDrawableTransformation[] transformations = new GifDrawableTransformation[bitmapTransformations.length];, +            transformations[i] = new GifDrawableTransformation(bitmapTransformations[i], glide.getBitmapPool());, +    public GifRequestBuilder<ModelType> transform(Transformation<GifDrawable>... transformations) {, +    public GifRequestBuilder<ModelType> transcoder(ResourceTranscoder<GifDrawable, GifDrawable> transcoder) {, +++ b/library/src/main/java/com/bumptech/glide/GifTypeRequest.java, +import com.bumptech.glide.load.resource.transcode.GifDrawableBytesTranscoder;, + * {@link com.bumptech.glide.load.resource.gif.GifDrawable} into another resource type., +    private static <A, R> FixedLoadProvider<A, InputStream, GifDrawable, R> buildProvider(Glide glide,, +            ResourceTranscoder<GifDrawable, R> transcoder) {, +            transcoder = glide.buildTranscoder(GifDrawable.class, transcodeClass);, +        DataLoadProvider<InputStream, GifDrawable> dataLoadProvider = glide.buildDataProvider(InputStream.class,, +                GifDrawable.class);, +        return new FixedLoadProvider<A, InputStream, GifDrawable, R>(streamModelLoader, transcoder, dataLoadProvider);, +     * Sets a transcoder to transcode the decoded {@link com.bumptech.glide.load.resource.gif.GifDrawable} into another, +     * {@link com.bumptech.glide.load.resource.gif.GifDrawable} will be transcoded to., +     * @param <R> The type of the resource the {@link com.bumptech.glide.load.resource.gif.GifDrawable} will be, +    public <R> GenericRequestBuilder<ModelType, InputStream, GifDrawable, R> transcode(, +            ResourceTranscoder<GifDrawable, R> transcoder, Class<R> transcodeClass) {, +        FixedLoadProvider<ModelType, InputStream, GifDrawable, R> provider = buildProvider(glide, streamModelLoader,, +                transcodeClass, transcoder);, +        return optionsApplier.apply(model, new GenericRequestBuilder<ModelType, InputStream, GifDrawable, R>(context,, +                model, provider, transcodeClass, glide, requestTracker, lifecycle));, +    public GenericRequestBuilder<ModelType, InputStream, GifDrawable, byte[]> toBytes() {, +        return transcode(new GifDrawableBytesTranscoder(), byte[].class);, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +            transformations[i] = new GifBitmapWrapperTransformation(glide.getBitmapPool(), bitmapTransformations[i]);, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/GifRequestBuilder.java, +import com.bumptech.glide.load.resource.gif.GifDrawableTransformation;, +public class GifRequestBuilder<ModelType>, +        extends GenericRequestBuilder<ModelType, InputStream, GifDrawable, GifDrawable>, +            LoadProvider<ModelType, InputStream, GifDrawable, GifDrawable> loadProvider, Glide glide,, +            RequestTracker requestTracker, Lifecycle lifecycle) {, +            GenericRequestBuilder<ModelType, InputStream, GifDrawable, GifDrawable> thumbnailRequest) {, +            ResourceDecoder<InputStream, GifDrawable> decoder) {, +            ResourceDecoder<File, GifDrawable> cacheDecoder) {, +            ResourceEncoder<GifDrawable> encoder) {, +    private GifDrawableTransformation[] toGifTransformations(Transformation<Bitmap>[] bitmapTransformations) {, +        GifDrawableTransformation[] transformations = new GifDrawableTransformation[bitmapTransformations.length];, +            transformations[i] = new GifDrawableTransformation(bitmapTransformations[i], glide.getBitmapPool());, +    public GifRequestBuilder<ModelType> transform(Transformation<GifDrawable>... transformations) {, +    public GifRequestBuilder<ModelType> transcoder(ResourceTranscoder<GifDrawable, GifDrawable> transcoder) {, +++ b/library/src/main/java/com/bumptech/glide/GifTypeRequest.java, +import com.bumptech.glide.load.resource.transcode.GifDrawableBytesTranscoder;, + * {@link com.bumptech.glide.load.resource.gif.GifDrawable} into another resource type., +    private static <A, R> FixedLoadProvider<A, InputStream, GifDrawable, R> buildProvider(Glide glide,, +            ResourceTranscoder<GifDrawable, R> transcoder) {, +            transcoder = glide.buildTranscoder(GifDrawable.class, transcodeClass);, +        DataLoadProvider<InputStream, GifDrawable> dataLoadProvider = glide.buildDataProvider(InputStream.class,, +                GifDrawable.class);, +        return new FixedLoadProvider<A, InputStream, GifDrawable, R>(streamModelLoader, transcoder, dataLoadProvider);, +     * Sets a transcoder to transcode the decoded {@link com.bumptech.glide.load.resource.gif.GifDrawable} into another, +     * {@link com.bumptech.glide.load.resource.gif.GifDrawable} will be transcoded to., +     * @param <R> The type of the resource the {@link com.bumptech.glide.load.resource.gif.GifDrawable} will be, +    public <R> GenericRequestBuilder<ModelType, InputStream, GifDrawable, R> transcode(, +            ResourceTranscoder<GifDrawable, R> transcoder, Class<R> transcodeClass) {, +        FixedLoadProvider<ModelType, InputStream, GifDrawable, R> provider = buildProvider(glide, streamModelLoader,, +                transcodeClass, transcoder);, +        return optionsApplier.apply(model, new GenericRequestBuilder<ModelType, InputStream, GifDrawable, R>(context,, +                model, provider, transcodeClass, glide, requestTracker, lifecycle));, +    public GenericRequestBuilder<ModelType, InputStream, GifDrawable, byte[]> toBytes() {, +        return transcode(new GifDrawableBytesTranscoder(), byte[].class);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ /dev/null, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ /dev/null, +++ b/README.md, +Before submitting pull requests, contributors must sign Google's [individual contribution license agreement][7]., +[5]: https://github.com/bumptech/glide/issues/new, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ /dev/null, +++ b/README.md, +Before submitting pull requests, contributors must sign Google's [individual contribution license agreement][7]., +[5]: https://github.com/bumptech/glide/issues/new, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +  /**, +   * Ensure that the size of the bitmap is fixed to the requested width and height of the, +   * resource from the caller.  The final resource dimensions may differ from the requested, +   * width and height, and thus setting this to true may result in the bitmap size differing, +   * from the resource dimensions., +   *, +   * This can be used as a performance optimization for KitKat and above by fixing the size of the, +   * bitmap for a collection of requested resources so that the bitmap pool will not need to, +   * allocate new bitmaps for images of different sizes., +   */, +  public static final Option<Boolean> FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS =, +      Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.FixBitmapSize", false);, +, +    boolean fixBitmapToRequestedDimensions = options.get(FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS);, +          downsampleStrategy, decodeFormat, requestedWidth, requestedHeight,, +          fixBitmapToRequestedDimensions, callbacks);, +      boolean fixBitmapToRequestedDimensions, DecodeCallbacks callbacks) throws IOException {, +    int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth;, +    int targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;, +, +    calculateScaling(downsampleStrategy, degreesToRotate, sourceWidth, sourceHeight, targetWidth,, +        targetHeight, options);, +, +    boolean isKitKatOrGreater = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;, +    // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding., +    if ((options.inSampleSize == 1 || isKitKatOrGreater), +        && shouldUsePool(is)) {, +      int expectedWidth;, +      int expectedHeight;, +      if (fixBitmapToRequestedDimensions && isKitKatOrGreater) {, +        expectedWidth = targetWidth;, +        expectedHeight = targetHeight;, +      } else {, +        float densityMultiplier = isScaling(options), +            ? (float) options.inTargetDensity / options.inDensity : 1f;, +        int sampleSize = options.inSampleSize;, +        int downsampledWidth = (int) Math.ceil(sourceWidth / (float) sampleSize);, +        int downsampledHeight = (int) Math.ceil(sourceHeight / (float) sampleSize);, +        expectedWidth = Math.round(downsampledWidth * densityMultiplier);, +        expectedHeight = Math.round(downsampledHeight * densityMultiplier);, +, +        if (Log.isLoggable(TAG, Log.VERBOSE)) {, +          Log.v(TAG, "Calculated target [" + expectedWidth + "x" + expectedHeight + "] for source", +              + " [" + sourceWidth + "x" + sourceHeight + "]", +              + ", sampleSize: " + sampleSize, +              + ", targetDensity: " + options.inTargetDensity, +              + ", density: " + options.inDensity, +              + ", density multiplier: " + densityMultiplier);, +        }, +      }, +      // If this isn't an image, or BitmapFactory was unable to parse the size, width and height, +      // will be -1 here., +      if (expectedWidth > 0 && expectedHeight > 0) {, +        setInBitmap(options, bitmapPool, expectedWidth, expectedHeight);, +      }, +    }, +    Bitmap downsampled = decodeStream(is, options, callbacks);, +      int sourceWidth, int sourceHeight, int targetWidth, int targetHeight,, +      int height) {, +      options.inBitmap = bitmapPool.getDirty(width, height, options.inPreferredConfig);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +  /**, +   * Ensure that the size of the bitmap is fixed to the requested width and height of the, +   * resource from the caller.  The final resource dimensions may differ from the requested, +   * width and height, and thus setting this to true may result in the bitmap size differing, +   * from the resource dimensions., +   *, +   * This can be used as a performance optimization for KitKat and above by fixing the size of the, +   * bitmap for a collection of requested resources so that the bitmap pool will not need to, +   * allocate new bitmaps for images of different sizes., +   */, +  public static final Option<Boolean> FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS =, +      Option.memory("com.bumptech.glide.load.resource.bitmap.Downsampler.FixBitmapSize", false);, +, +    boolean fixBitmapToRequestedDimensions = options.get(FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS);, +          downsampleStrategy, decodeFormat, requestedWidth, requestedHeight,, +          fixBitmapToRequestedDimensions, callbacks);, +      boolean fixBitmapToRequestedDimensions, DecodeCallbacks callbacks) throws IOException {, +    int targetWidth = requestedWidth == Target.SIZE_ORIGINAL ? sourceWidth : requestedWidth;, +    int targetHeight = requestedHeight == Target.SIZE_ORIGINAL ? sourceHeight : requestedHeight;, +, +    calculateScaling(downsampleStrategy, degreesToRotate, sourceWidth, sourceHeight, targetWidth,, +        targetHeight, options);, +, +    boolean isKitKatOrGreater = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;, +    // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding., +    if ((options.inSampleSize == 1 || isKitKatOrGreater), +        && shouldUsePool(is)) {, +      int expectedWidth;, +      int expectedHeight;, +      if (fixBitmapToRequestedDimensions && isKitKatOrGreater) {, +        expectedWidth = targetWidth;, +        expectedHeight = targetHeight;, +      } else {, +        float densityMultiplier = isScaling(options), +            ? (float) options.inTargetDensity / options.inDensity : 1f;, +        int sampleSize = options.inSampleSize;, +        int downsampledWidth = (int) Math.ceil(sourceWidth / (float) sampleSize);, +        int downsampledHeight = (int) Math.ceil(sourceHeight / (float) sampleSize);]
[+++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use, +   * {@link android.graphics.Bitmap.Config#HARDWARE}., +   *, +   * this setting is a preference, not a promise., +   * Identical to {@link #PREFER_ARGB_8888} but prevents Glide from using {@link, +   * android.graphics.Bitmap.Config#HARDWARE} on Android O+, +   */, +  PREFER_ARGB_8888_DISALLOW_HARDWARE,, +, +  /**, +   *, +   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use, +   * {@link android.graphics.Bitmap.Config#HARDWARE}., +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use, +   * {@link android.graphics.Bitmap.Config#HARDWARE}., +   *, +   * this setting is a preference, not a promise., +   * Identical to {@link #PREFER_ARGB_8888} but prevents Glide from using {@link, +   * android.graphics.Bitmap.Config#HARDWARE} on Android O+, +   */, +  PREFER_ARGB_8888_DISALLOW_HARDWARE,, +, +  /**, +   *, +   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use, +   * {@link android.graphics.Bitmap.Config#HARDWARE}., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {, +      // GIFs, among other types, end up with a native Bitmap config that doesn't map to a java, +      // config and is treated as null in java code. On KitKat+ these Bitmaps can be reconfigured, +      // and are suitable for re-use., +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {, +      configs.remove(Bitmap.Config.HARDWARE);, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use, +   * {@link android.graphics.Bitmap.Config#HARDWARE}., +   *, +   * this setting is a preference, not a promise., +   * Identical to {@link #PREFER_ARGB_8888} but prevents Glide from using {@link, +   * android.graphics.Bitmap.Config#HARDWARE} on Android O+, +   */, +  PREFER_ARGB_8888_DISALLOW_HARDWARE,, +, +  /**, +   *, +   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use, +   * {@link android.graphics.Bitmap.Config#HARDWARE}., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {, +      // GIFs, among other types, end up with a native Bitmap config that doesn't map to a java, +      // config and is treated as null in java code. On KitKat+ these Bitmaps can be reconfigured, +      // and are suitable for re-use., +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {, +      configs.remove(Bitmap.Config.HARDWARE);, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +import android.graphics.Bitmap.Config;, +  static final String TAG = "Downsampler";, +  private final HardwareConfigState hardwareConfigState = HardwareConfigState.getInstance();, +    calculateConfig(is, decodeFormat, options, targetWidth, targetHeight);, +  private void calculateConfig(, +      InputStream is,, +      DecodeFormat format,, +      BitmapFactory.Options optionsWithScaling,, +      int targetWidth,, +      int targetHeight), +      throws IOException {, +, +    if (hardwareConfigState.setHardwareConfigIfAllowed(, +        targetWidth, targetHeight, optionsWithScaling, format)) {, +      return;, +    }, +, +      optionsWithScaling.inPreferredConfig = Bitmap.Config.ARGB_8888;, +      return;, +    optionsWithScaling.inPreferredConfig =, +        hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;, +    if (optionsWithScaling.inPreferredConfig == Config.RGB_565, +        || optionsWithScaling.inPreferredConfig == Config.ARGB_4444, +        || optionsWithScaling.inPreferredConfig == Config.ALPHA_8) {, +      optionsWithScaling.inDither = true;, +    }, +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O, +        && options.inPreferredConfig == Config.HARDWARE) {, +      return;, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +   * <p>On Android O+, this format will will use ARGB_8888 only when it's not possible to use, +   * {@link android.graphics.Bitmap.Config#HARDWARE}., +   *, +   * this setting is a preference, not a promise., +   * Identical to {@link #PREFER_ARGB_8888} but prevents Glide from using {@link, +   * android.graphics.Bitmap.Config#HARDWARE} on Android O+, +   */, +  PREFER_ARGB_8888_DISALLOW_HARDWARE,, +, +  /**]
[+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java, +import android.os.Looper;, +    Looper looper = harness.mainHandler.getLooper();, +    Shadows.shadowOf(looper).pause();, +    Shadows.shadowOf(looper).runOneTask();, +++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java, +import android.os.Looper;, +    Looper looper = harness.mainHandler.getLooper();, +    Shadows.shadowOf(looper).pause();, +    Shadows.shadowOf(looper).runOneTask();, +++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap first = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);, +    Bitmap second = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap third = Bitmap.createBitmap(120, 120, Bitmap.Config.RGB_565);, +    final Bitmap leastRecentlyUsed = Bitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);, +    final Bitmap other = Bitmap.createBitmap(1000, 1000, Bitmap.Config.RGB_565);, +    final Bitmap mostRecentlyUsed = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java, +import android.os.Looper;, +    Looper looper = harness.mainHandler.getLooper();, +    Shadows.shadowOf(looper).pause();, +    Shadows.shadowOf(looper).runOneTask();, +++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap first = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);, +    Bitmap second = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap third = Bitmap.createBitmap(120, 120, Bitmap.Config.RGB_565);, +    final Bitmap leastRecentlyUsed = Bitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);, +    final Bitmap other = Bitmap.createBitmap(1000, 1000, Bitmap.Config.RGB_565);, +    final Bitmap mostRecentlyUsed = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, config);, +++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java, +import android.os.Looper;, +    Looper looper = harness.mainHandler.getLooper();, +    Shadows.shadowOf(looper).pause();, +    Shadows.shadowOf(looper).runOneTask();, +++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap first = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);, +    Bitmap second = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap third = Bitmap.createBitmap(120, 120, Bitmap.Config.RGB_565);, +    final Bitmap leastRecentlyUsed = Bitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);, +    final Bitmap other = Bitmap.createBitmap(1000, 1000, Bitmap.Config.RGB_565);, +    final Bitmap mostRecentlyUsed = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, config);, +++ b/library/test/src/test/java/com/bumptech/glide/request/target/CustomViewTargetTest.java, +import android.view.Display;, +    Display display = Preconditions.checkNotNull(windowManager).getDefaultDisplay();, +      Shadows.shadowOf(display).setWidth(width);, +      Shadows.shadowOf(display).setHeight(height);, +++ b/library/test/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java, +import android.os.Looper;, +    Looper looper = harness.mainHandler.getLooper();, +    Shadows.shadowOf(looper).pause();, +    Shadows.shadowOf(looper).runOneTask();, +++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/AttributeStrategyTest.java, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_4444);, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap first = Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565);, +    Bitmap second = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    Bitmap third = Bitmap.createBitmap(120, 120, Bitmap.Config.RGB_565);, +    final Bitmap leastRecentlyUsed = Bitmap.createBitmap(100, 100, Bitmap.Config.ALPHA_8);, +    final Bitmap other = Bitmap.createBitmap(1000, 1000, Bitmap.Config.RGB_565);, +    final Bitmap mostRecentlyUsed = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, config);, +++ b/library/test/src/test/java/com/bumptech/glide/request/target/CustomViewTargetTest.java, +import android.view.Display;, +    Display display = Preconditions.checkNotNull(windowManager).getDefaultDisplay();, +      Shadows.shadowOf(display).setWidth(width);, +      Shadows.shadowOf(display).setHeight(height);, +++ b/library/test/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java, +import android.view.Display;, +    Display display = Preconditions.checkNotNull(windowManager).getDefaultDisplay();, +      Shadows.shadowOf(display).setWidth(width);, +      Shadows.shadowOf(display).setHeight(height);]
[+++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="module" module-name="library" />, +++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="module" module-name="library" />, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import com.bumptech.glide.load.DataSource;, +, +    @Override, +    public DataSource getDataSource() {, +        return DataSource.REMOTE;, +    }, +++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="module" module-name="library" />, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import com.bumptech.glide.load.DataSource;, +, +    @Override, +    public DataSource getDataSource() {, +        return DataSource.REMOTE;, +    }, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +import com.bumptech.glide.load.DataSource;, +    @Override, +    public DataSource getDataSource() {, +        return DataSource.REMOTE;, +    }, +, +++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="module" module-name="library" />, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import com.bumptech.glide.load.DataSource;, +, +    @Override, +    public DataSource getDataSource() {, +        return DataSource.REMOTE;, +    }, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +import com.bumptech.glide.load.DataSource;, +    @Override, +    public DataSource getDataSource() {, +        return DataSource.REMOTE;, +    }, +, +++ b/integration/volley/volley.iml, +    <orderEntry type="module" module-name="library" />, +++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="module" module-name="library" />, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import com.bumptech.glide.load.DataSource;, +, +    @Override, +    public DataSource getDataSource() {, +        return DataSource.REMOTE;, +    }, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +import com.bumptech.glide.load.DataSource;, +    @Override, +    public DataSource getDataSource() {, +        return DataSource.REMOTE;, +    }, +, +++ b/integration/volley/volley.iml, +    <orderEntry type="module" module-name="library" />, +++ b/library/src/main/java/com/bumptech/glide/load/DataSource.java, +package com.bumptech.glide.load;, +, +/**, + * Indicates the origin of some retrieved data., + */, +public enum DataSource {, +    /**, +     * Indicates this data was probably retrieved locally from the device, although it may have been obtained, +     * through a content provider that may have obtained the data from a remote source., +     */, +    LOCAL,, +    /**, +     * Indicates this data was retrieved from a remote source other than the device., +     */, +    REMOTE,, +}, +++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="module" module-name="library" />, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import com.bumptech.glide.load.DataSource;, +, +    @Override, +    public DataSource getDataSource() {, +        return DataSource.REMOTE;, +    }, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +import com.bumptech.glide.load.DataSource;, +    @Override, +    public DataSource getDataSource() {, +        return DataSource.REMOTE;, +    }, +, +++ b/integration/volley/volley.iml, +    <orderEntry type="module" module-name="library" />, +++ b/library/src/main/java/com/bumptech/glide/load/DataSource.java, +package com.bumptech.glide.load;]
[+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +      // Only log at more verbose log levels if the user has set a fallback drawable, because, +      // fallback Drawables indicate the user expects null models occasionally., +      int logLevel = getFallbackDrawable() == null ? Log.WARN : Log.DEBUG;, +      onLoadFailed(new GlideException("Received null model"), logLevel);, +    onLoadFailed(e, Log.WARN);, +  }, +, +  private void onLoadFailed(GlideException e, int maxLogLevel) {, +    if (logLevel <= maxLogLevel) {]
[+++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" />, +++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" />, +++ b/library/src/com/bumptech/glide/Glide.java, +import android.view.ViewGroup;, +import com.bumptech.glide.loader.model.FileLoader;, +import com.bumptech.glide.loader.model.GenericLoaderFactory;, +import com.bumptech.glide.loader.model.ModelLoader;, +import com.bumptech.glide.loader.model.ModelLoaderFactory;, +import com.bumptech.glide.loader.model.ResourceLoader;, +import com.bumptech.glide.loader.model.StringLoader;, +import com.bumptech.glide.loader.model.UriLoader;, +import com.bumptech.glide.loader.stream.StreamLoader;, +import com.bumptech.glide.loader.transformation.CenterCrop;, +import com.bumptech.glide.loader.transformation.FitCenter;, +import com.bumptech.glide.loader.transformation.MultiTransformationLoader;, +import com.bumptech.glide.loader.transformation.None;, +import com.bumptech.glide.loader.transformation.TransformationLoader;, +import com.bumptech.glide.presenter.target.Target;, +, +import java.util.Map;, +import java.util.WeakHashMap;, + * A singleton to present a simple static interface for Glide {@link Glide.Request} and to create and manage an, +    private final Map<Target, Metadata> metadataTracker = new WeakHashMap<Target, Metadata>();, +         *     public void onException(Exception e, T model, Target target) {, +        loaderFactory.register(File.class, new FileLoader.Factory());, +        loaderFactory.register(Integer.class, new ResourceLoader.Factory());, +        loaderFactory.register(String.class, new StringLoader.Factory());, +        loaderFactory.register(Uri.class, new UriLoader.Factory());, +            loaderFactory.register(URL.class, new VolleyUrlLoader.Factory());, +            loaderFactory.register(URL.class, new ModelLoaderFactory<URL>() {, +                ModelLoader<URL> errorUrlLoader = new ModelLoader<URL>() {, +                    @Override, +                    public StreamLoader getStreamLoader(URL model, int width, int height) {, +                        throw new IllegalArgumentException("No ModelLoaderFactory for urls registered with Glide");, +                    }, +, +                    @Override, +                    public String getId(URL model) {, +                        throw new IllegalArgumentException("No ModelLoaderFactory for urls registered with Glide");, +                    }, +                };, +, +                @Override, +                public ModelLoader<URL> build(Context context, GenericLoaderFactory factories) {, +                    return errorUrlLoader;, +                }, +, +                @Override @SuppressWarnings("unchecked"), +                public Class<? extends ModelLoader<URL>> loaderClass() {, +                    return (Class<ModelLoader<URL>>) errorUrlLoader.getClass();, +                }, +, +                @Override, +                public void teardown() {, +                }, +            });, +     * {@link ImageManager} with custom options for use with {@link com.bumptech.glide.Glide.Request} and/or as an, +     * Set the {@link ImageManager} to use with {@link Glide.Request}., +     * Set the {@link ImageManager} to use with {@link Glide.Request} Replaces the current, +     * models. Typically the {@link Glide#using(com.bumptech.glide.loader.model.ModelLoader)} syntax is preferred, +     * because it directly links the model with the ModelLoader being used to load it., +     *     used for any other model class, {@link com.bumptech.glide.loader.model.ModelLoaderFactory#teardown()}, +     * @param clazz The class, +     * @param factory The factory to use, +     * @param <T> The type of the model, +    public <T> void register(Class<T> clazz, ModelLoaderFactory<T> factory) {, +        ModelLoaderFactory<T> removed = loaderFactory.register(clazz, factory);, +     * @param clazz The class to get a {@link ModelLoader} for, +    public static <T> ModelLoader<T> buildModelLoader(Class<T> clazz, Context context) {, +        return GLIDE.loaderFactory.buildModelLoader(clazz, context);, +    }, +, +    @SuppressWarnings("unchecked"), +    private <T> ModelLoaderFactory<T> getFactory(T model) {, +        return loaderFactory.getFactory((Class<T>) model.getClass());, +    }, +, +    private ImageViewTarget getImageViewTarget(ImageView imageView) {, +        Object tag = imageView.getTag();, +        ImageViewTarget result = null;, +        if (tag instanceof ImageViewTarget) {, +            result = (ImageViewTarget) tag;, +        } else if (tag != null) {, +            throw new IllegalArgumentException("You cannot set a tag on an image view Glide is loading an image into");, +        }, +, +        return result;, +    }, +, +    private ImageViewTarget getImageViewTargetOrSet(ImageView imageView) {, +        ImageViewTarget result = getImageViewTarget(imageView);, +        if (result == null) {, +            result = new ImageViewTarget(imageView);, +            imageView.setTag(result);, +        }, +        return result;, +     * Set the {@link ModelLoaderFactory} and therefore the model type to use for a new load., +     *     Note - You can use this method to set a {@link ModelLoaderFactory} for models that don't have a default]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java, +import com.bumptech.glide.test.BitmapSubject;, +import com.bumptech.glide.test.GlideApp;, +, +  @Test, +  public void load_withBitmapDrawable_andDoNothingTransformation_doesNotRecycleBitmap(), +      throws ExecutionException, InterruptedException {, +    Bitmap bitmap = Bitmap.createBitmap(100, 200, Config.ARGB_8888);, +    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);, +, +    Drawable result = GlideApp.with(context), +        .load(drawable), +        .fitCenter(), +        .override(bitmap.getWidth(), bitmap.getHeight()), +        .submit(), +        .get();, +, +    BitmapSubject.assertThat(result).isNotRecycled();, +  }, +, +  @Test, +  public void load_withBitmapDrawable_andFunctionalTransformation_doesNotRecycleBitmap(), +      throws ExecutionException, InterruptedException {, +      Bitmap bitmap = Bitmap.createBitmap(100, 200, Config.ARGB_8888);, +    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);, +, +    Drawable result = GlideApp.with(context), +        .load(drawable), +        .fitCenter(), +        .override(bitmap.getWidth() / 2, bitmap.getHeight() / 2), +        .submit(), +        .get();, +, +    BitmapSubject.assertThat(result).isNotRecycled();, +  }, +, +  @Test, +  public void load_withColorDrawable_fixedSize_unitBitmapTransform_recyclesIntermediates(), +      throws ExecutionException, InterruptedException {, +    Drawable colorDrawable = new ColorDrawable(Color.RED);, +, +    int width = 100;, +    int height = 200;, +, +    GlideApp.with(context), +        .load(colorDrawable), +        .fitCenter(), +        .override(width, height), +        .submit(), +        .get();, +, +    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();, +    // Make sure we didn't put the same Bitmap twice., +    Bitmap first = bitmapPool.get(width, height, Config.ARGB_8888);, +    Bitmap second = bitmapPool.get(width, height, Config.ARGB_8888);, +, +    assertThat(first).isNotSameAs(second);, +  }, +   @Test, +  public void load_withColorDrawable_fixedSize_functionalBitmapTransform_doesNotRecycleOutput(), +      throws ExecutionException, InterruptedException {, +    Drawable colorDrawable = new ColorDrawable(Color.RED);, +, +    int width = 100;, +    int height = 200;, +, +    Drawable result = GlideApp.with(context), +        .load(colorDrawable), +        .circleCrop(), +        .override(width, height), +        .submit(), +        .get();, +, +     BitmapSubject.assertThat(result).isNotRecycled();, +, +    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();, +    // Make sure we didn't put the same Bitmap twice., +    Bitmap first = bitmapPool.get(width, height, Config.ARGB_8888);, +    Bitmap second = bitmapPool.get(width, height, Config.ARGB_8888);, +, +    assertThat(first).isNotSameAs(second);, +  }, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java, +import com.bumptech.glide.test.BitmapSubject;, +import com.bumptech.glide.test.GlideApp;, +, +  @Test, +  public void load_withBitmapDrawable_andDoNothingTransformation_doesNotRecycleBitmap(), +      throws ExecutionException, InterruptedException {, +    Bitmap bitmap = Bitmap.createBitmap(100, 200, Config.ARGB_8888);, +    BitmapDrawable drawable = new BitmapDrawable(context.getResources(), bitmap);, +, +    Drawable result = GlideApp.with(context), +        .load(drawable), +        .fitCenter(), +        .override(bitmap.getWidth(), bitmap.getHeight()), +        .submit(), +        .get();, +, +    BitmapSubject.assertThat(result).isNotRecycled();]
[+++ b/library/src/androidTest/java/com/bumptech/glide/manager/Issue117Activity.java, +package com.bumptech.glide.manager;, +, +import android.content.Context;, +import android.os.Bundle;, +import android.support.v4.app.Fragment;, +import android.support.v4.app.FragmentActivity;, +import android.support.v4.app.FragmentManager;, +import android.support.v4.app.FragmentPagerAdapter;, +import android.support.v4.view.ViewPager;, +import android.view.LayoutInflater;, +import android.view.View;, +import android.view.ViewGroup;, +import android.widget.ImageView;, +import com.bumptech.glide.Glide;, +, +/**, + * A test activity to reproduce Issue #117: https://github.com/bumptech/glide/issues/117., + */, +public class Issue117Activity extends FragmentActivity {, +    @Override, +    protected void onCreate(Bundle savedInstanceState) {, +        super.onCreate(savedInstanceState);, +        ViewPager viewPager = new ViewPager(this);, +        int id = View.generateViewId();, +        viewPager.setId(id);, +        setContentView(viewPager,, +                new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));, +        viewPager.setAdapter(new Issue117Adapter(getSupportFragmentManager()));, +    }, +, +    private static class Issue117Adapter extends FragmentPagerAdapter {, +, +        public Issue117Adapter(FragmentManager fm) {, +            super(fm);, +        }, +, +        @Override, +        public Fragment getItem(int position) {, +            return new Issue117Fragment();, +        }, +, +        @Override, +        public int getCount() {, +            return 1;, +        }, +    }, +, +    public static class Issue117Fragment extends Fragment {, +        @Override, +        public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {, +            return new Issue117ImageView(getActivity());, +        }, +    }, +, +    public static class Issue117ImageView extends ImageView {, +        public Issue117ImageView(Context context) {, +            super(context);, +        }, +, +        @Override, +        protected void onAttachedToWindow() {, +            super.onAttachedToWindow();, +            Glide.with(getContext()).load(android.R.drawable.ic_menu_rotate).into(this);, +        }, +    }, +}, +, +++ b/library/src/androidTest/java/com/bumptech/glide/manager/Issue117Activity.java, +package com.bumptech.glide.manager;, +, +import android.content.Context;, +import android.os.Bundle;, +import android.support.v4.app.Fragment;, +import android.support.v4.app.FragmentActivity;, +import android.support.v4.app.FragmentManager;, +import android.support.v4.app.FragmentPagerAdapter;, +import android.support.v4.view.ViewPager;, +import android.view.LayoutInflater;, +import android.view.View;, +import android.view.ViewGroup;, +import android.widget.ImageView;, +import com.bumptech.glide.Glide;, +, +/**, + * A test activity to reproduce Issue #117: https://github.com/bumptech/glide/issues/117., + */, +public class Issue117Activity extends FragmentActivity {, +    @Override, +    protected void onCreate(Bundle savedInstanceState) {, +        super.onCreate(savedInstanceState);, +        ViewPager viewPager = new ViewPager(this);, +        int id = View.generateViewId();, +        viewPager.setId(id);, +        setContentView(viewPager,, +                new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));, +        viewPager.setAdapter(new Issue117Adapter(getSupportFragmentManager()));, +    }, +, +    private static class Issue117Adapter extends FragmentPagerAdapter {]
[+++ b/checkstyle.xml, +        <!-- Prevent importing Mockito matchers directly -->, +        <module name="IllegalImport">, +            <property name="illegalPkgs" value="org.mockito.internal" />, +            <message key="import.illegal" value="Import from illegal package - {0}. Use org.mockito.Matchers to instantiate argument matchers; or org.hamcrest.Matchers for assertThat." />, +        </module>, +++ b/checkstyle.xml, +        <!-- Prevent importing Mockito matchers directly -->, +        <module name="IllegalImport">, +            <property name="illegalPkgs" value="org.mockito.internal" />, +            <message key="import.illegal" value="Import from illegal package - {0}. Use org.mockito.Matchers to instantiate argument matchers; or org.hamcrest.Matchers for assertThat." />, +        </module>, +++ b/library/build.gradle, +    androidTestCompile 'org.hamcrest:hamcrest-library:1.3', +++ b/checkstyle.xml, +        <!-- Prevent importing Mockito matchers directly -->, +        <module name="IllegalImport">, +            <property name="illegalPkgs" value="org.mockito.internal" />, +            <message key="import.illegal" value="Import from illegal package - {0}. Use org.mockito.Matchers to instantiate argument matchers; or org.hamcrest.Matchers for assertThat." />, +        </module>, +++ b/library/build.gradle, +    androidTestCompile 'org.hamcrest:hamcrest-library:1.3', +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import static org.hamcrest.Matchers.hasItem;, +                    return Collections.emptyList();, +                    return  Collections.emptyList();, +                    return Collections.emptyList();, +                    return Collections.emptyList();, +++ b/checkstyle.xml, +        <!-- Prevent importing Mockito matchers directly -->, +        <module name="IllegalImport">, +            <property name="illegalPkgs" value="org.mockito.internal" />, +            <message key="import.illegal" value="Import from illegal package - {0}. Use org.mockito.Matchers to instantiate argument matchers; or org.hamcrest.Matchers for assertThat." />, +        </module>, +++ b/library/build.gradle, +    androidTestCompile 'org.hamcrest:hamcrest-library:1.3', +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import static org.hamcrest.Matchers.hasItem;, +                    return Collections.emptyList();, +                    return  Collections.emptyList();, +                    return Collections.emptyList();, +                    return Collections.emptyList();, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/MediaStoreThumbFetcherTest.java, +import static org.hamcrest.Matchers.containsString;, +++ b/checkstyle.xml, +        <!-- Prevent importing Mockito matchers directly -->, +        <module name="IllegalImport">, +            <property name="illegalPkgs" value="org.mockito.internal" />, +            <message key="import.illegal" value="Import from illegal package - {0}. Use org.mockito.Matchers to instantiate argument matchers; or org.hamcrest.Matchers for assertThat." />, +        </module>, +++ b/library/build.gradle, +    androidTestCompile 'org.hamcrest:hamcrest-library:1.3', +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import static org.hamcrest.Matchers.hasItem;, +                    return Collections.emptyList();, +                    return  Collections.emptyList();, +                    return Collections.emptyList();, +                    return Collections.emptyList();, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/MediaStoreThumbFetcherTest.java, +import static org.hamcrest.Matchers.containsString;, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java, +import static org.hamcrest.Matchers.equalTo;, +import static org.hamcrest.Matchers.not;, +++ b/checkstyle.xml, +        <!-- Prevent importing Mockito matchers directly -->, +        <module name="IllegalImport">, +            <property name="illegalPkgs" value="org.mockito.internal" />, +            <message key="import.illegal" value="Import from illegal package - {0}. Use org.mockito.Matchers to instantiate argument matchers; or org.hamcrest.Matchers for assertThat." />, +        </module>, +++ b/library/build.gradle, +    androidTestCompile 'org.hamcrest:hamcrest-library:1.3', +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import static org.hamcrest.Matchers.hasItem;, +                    return Collections.emptyList();, +                    return  Collections.emptyList();, +                    return Collections.emptyList();, +                    return Collections.emptyList();, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/MediaStoreThumbFetcherTest.java, +import static org.hamcrest.Matchers.containsString;, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java, +import static org.hamcrest.Matchers.equalTo;, +import static org.hamcrest.Matchers.not;, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +import static org.hamcrest.Matchers.equalTo;, +import static org.hamcrest.Matchers.hasEntry;, +import static org.hamcrest.Matchers.hasKey;, +import static org.hamcrest.Matchers.not;, +import static org.hamcrest.Matchers.notNullValue;, +        assertThat(harness.runners, hasKey((Key) harness.cacheKey));, +        verify(harness.cb, never()).onResourceReady(isNull(Resource.class));, +        assertThat(harness.activeResources, not(hasKey((Key) harness.cacheKey)));, +        assertThat(harness.runners, not(hasKey((Key) harness.cacheKey)));, +        assertThat(harness.activeResources, not(hasKey((Key) harness.cacheKey)));, +        assertThat(harness.runners, not(hasKey((Key) harness.cacheKey)));, +        assertThat(harness.activeResources, not(hasKey((Key) harness.cacheKey)));, +        assertThat(harness.runners, hasEntry(equalTo((Key) harness.cacheKey), notNullValue(ResourceRunner.class)));, +++ b/checkstyle.xml, +        <!-- Prevent importing Mockito matchers directly -->, +        <module name="IllegalImport">, +            <property name="illegalPkgs" value="org.mockito.internal" />]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +    this.provider = new GifBitmapProvider(bitmapPool, byteArrayPool);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +    this.provider = new GifBitmapProvider(bitmapPool, byteArrayPool);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java, +import android.support.annotation.Nullable;, +import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;, +  @Nullable private final ByteArrayPool byteArrayPool;, +  /**, +   * Constructs an instance without a shared byte array pool. Byte arrays will be always constructed, +   * when requested., +   */, +    this(bitmapPool, null /*byteArrayPool*/);, +  }, +, +  /**, +   * Constructs an instance with a shared byte array pool. Byte arrays will be reused where, +   * possible., +   */, +  public GifBitmapProvider(BitmapPool bitmapPool, @Nullable ByteArrayPool byteArrayPool) {, +    this.byteArrayPool = byteArrayPool;, +, +  @Override, +  public byte[] obtainByteArray(int size) {, +    if (byteArrayPool == null) {, +      return new byte[size];, +    }, +    return byteArrayPool.get(size);, +  }, +, +  @Override, +  public void release(byte[] bytes) {, +    if (byteArrayPool == null) {, +      return;, +    }, +    byteArrayPool.put(bytes);, +  }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +    this.provider = new GifBitmapProvider(bitmapPool, byteArrayPool);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java, +import android.support.annotation.Nullable;, +import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;, +  @Nullable private final ByteArrayPool byteArrayPool;, +  /**, +   * Constructs an instance without a shared byte array pool. Byte arrays will be always constructed, +   * when requested., +   */, +    this(bitmapPool, null /*byteArrayPool*/);, +  }, +, +  /**, +   * Constructs an instance with a shared byte array pool. Byte arrays will be reused where, +   * possible., +   */, +  public GifBitmapProvider(BitmapPool bitmapPool, @Nullable ByteArrayPool byteArrayPool) {, +    this.byteArrayPool = byteArrayPool;, +, +  @Override, +  public byte[] obtainByteArray(int size) {, +    if (byteArrayPool == null) {, +      return new byte[size];, +    }, +    return byteArrayPool.get(size);, +  }, +, +  @Override, +  public void release(byte[] bytes) {, +    if (byteArrayPool == null) {, +      return;, +    }, +    byteArrayPool.put(bytes);, +  }, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, +  private byte[] block;, +, +    /**, +     * Returns a byte array used for decoding and generating the frame bitmap., +     *, +     * @param size the size of the byte array to obtain, +     */, +    byte[] obtainByteArray(int size);, +, +    /**, +     * Releases the given byte array back to the pool., +     */, +    void release(byte[] bytes);, +, +    if (block != null) {, +      bitmapProvider.release(block);, +    }, +        if (block == null) {, +          block = bitmapProvider.obtainByteArray(255);, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +    this.provider = new GifBitmapProvider(bitmapPool, byteArrayPool);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java, +import android.support.annotation.Nullable;, +import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;, +  @Nullable private final ByteArrayPool byteArrayPool;, +  /**]
[+++ b/annotation/compiler/build.gradle, +    compile 'com.squareup:javapoet:1.9.0', +++ b/annotation/compiler/build.gradle, +    compile 'com.squareup:javapoet:1.9.0', +++ b/checkstyle.xml, +        <!-- Allow common trailing comments used to describe suppressions -->, +        <module name="TrailingComment">, +          <property name="legalComment" value="Public API" />, +        </module>, +++ b/annotation/compiler/build.gradle, +    compile 'com.squareup:javapoet:1.9.0', +++ b/checkstyle.xml, +        <!-- Allow common trailing comments used to describe suppressions -->, +        <module name="TrailingComment">, +          <property name="legalComment" value="Public API" />, +        </module>, +++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +  @Nullable, +  @Nullable, +  @Nullable, +  @Nullable, +  @Nullable, +  @Nullable, +  @Nullable, +  @Nullable, +  @NonNull, +  @NonNull, +  @Nullable, +  @Nullable, +  @NonNull, +  @Nullable, +  @NonNull, +  @NonNull, +  @NonNull, +  @Nullable, +  @SuppressWarnings("WeakerAccess") // Public API, +  @SuppressWarnings("WeakerAccess") // Public API, +  @SuppressWarnings("WeakerAccess") // Public API, +  @SuppressWarnings("WeakerAccess") // Public API, +  @SuppressWarnings("WeakerAccess") // Public API, +  @SuppressWarnings("WeakerAccess") // Public API, +  @SuppressWarnings("WeakerAccess") // Public API, +  @SuppressWarnings("WeakerAccess") // Public API, +  @SuppressWarnings("WeakerAccess"), +  @SuppressWarnings("WeakerAccess") // Public API, +  @SuppressWarnings("WeakerAccess") // Public API, +  @SuppressWarnings("WeakerAccess") // Public API, +  @SuppressWarnings("WeakerAccess") // Public API, +  @SuppressWarnings("WeakerAccess") // Public API, +  @SuppressWarnings("WeakerAccess") // Public API, +      return result;, +  @SuppressWarnings("unchecked"), +   * @param transformation Any {@link Transformation} for {@link Bitmap}s., +    return this;, +    return this;, +  @NonNull, +  @SuppressWarnings("WeakerAccess"), +  @NonNull, +  @NonNull, +  @NonNull, +  @Nullable, +  @SuppressWarnings("WeakerAccess"), +  @SuppressWarnings("WeakerAccess"), +  @SuppressWarnings("WeakerAccess"), +  @Nullable, +  @SuppressWarnings("WeakerAccess"), +  @SuppressWarnings("WeakerAccess"), +  @Nullable, +  @SuppressWarnings("WeakerAccess"), +  @Nullable, +  @SuppressWarnings("WeakerAccess"), +  @NonNull, +  @NonNull]
[+++ b/library/src/main/java/com/bumptech/glide/load/DataSource.java, +++ b/library/src/main/java/com/bumptech/glide/load/DataSource.java, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +          animationFactory.build(dataSource, isFirstResource);, +++ b/library/src/main/java/com/bumptech/glide/load/DataSource.java, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +          animationFactory.build(dataSource, isFirstResource);, +++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java, +import com.bumptech.glide.load.DataSource;, +, +  public Transition<Drawable> build(DataSource dataSource, boolean isFirstResource) {, +    if (dataSource == DataSource.MEMORY_CACHE) {, +      return getFirstResourceTransition(dataSource);, +      return getSecondResourceTransition(dataSource);, +  private Transition<Drawable> getFirstResourceTransition(DataSource dataSource) {, +              viewAnimationFactory.build(dataSource, true /*isFirstResource*/);, +  private Transition<Drawable> getSecondResourceTransition(DataSource dataSource) {, +              viewAnimationFactory.build(dataSource, false /*isFirstResource*/);, +++ b/library/src/main/java/com/bumptech/glide/load/DataSource.java, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +          animationFactory.build(dataSource, isFirstResource);, +++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java, +import com.bumptech.glide.load.DataSource;, +, +  public Transition<Drawable> build(DataSource dataSource, boolean isFirstResource) {, +    if (dataSource == DataSource.MEMORY_CACHE) {, +      return getFirstResourceTransition(dataSource);, +      return getSecondResourceTransition(dataSource);, +  private Transition<Drawable> getFirstResourceTransition(DataSource dataSource) {, +              viewAnimationFactory.build(dataSource, true /*isFirstResource*/);, +  private Transition<Drawable> getSecondResourceTransition(DataSource dataSource) {, +              viewAnimationFactory.build(dataSource, false /*isFirstResource*/);, +++ b/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java, +import com.bumptech.glide.load.DataSource;, +, +    public Transition<R> build(DataSource dataSource, boolean isFirstResource) {, +++ b/library/src/main/java/com/bumptech/glide/load/DataSource.java, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +          animationFactory.build(dataSource, isFirstResource);, +++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java, +import com.bumptech.glide.load.DataSource;, +, +  public Transition<Drawable> build(DataSource dataSource, boolean isFirstResource) {, +    if (dataSource == DataSource.MEMORY_CACHE) {, +      return getFirstResourceTransition(dataSource);, +      return getSecondResourceTransition(dataSource);, +  private Transition<Drawable> getFirstResourceTransition(DataSource dataSource) {, +              viewAnimationFactory.build(dataSource, true /*isFirstResource*/);, +  private Transition<Drawable> getSecondResourceTransition(DataSource dataSource) {, +              viewAnimationFactory.build(dataSource, false /*isFirstResource*/);, +++ b/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java, +import com.bumptech.glide.load.DataSource;, +, +    public Transition<R> build(DataSource dataSource, boolean isFirstResource) {, +++ b/library/src/main/java/com/bumptech/glide/request/transition/TransitionFactory.java, +import com.bumptech.glide.load.DataSource;, +, +   * @param dataSource      The {@link com.bumptech.glide.load.DataSource} the resource was loaded, +   *                        from., +  Transition<R> build(DataSource dataSource, boolean isFirstResource);, +++ b/library/src/main/java/com/bumptech/glide/load/DataSource.java, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +          animationFactory.build(dataSource, isFirstResource);, +++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java, +import com.bumptech.glide.load.DataSource;, +, +  public Transition<Drawable> build(DataSource dataSource, boolean isFirstResource) {, +    if (dataSource == DataSource.MEMORY_CACHE) {, +      return getFirstResourceTransition(dataSource);, +      return getSecondResourceTransition(dataSource);, +  private Transition<Drawable> getFirstResourceTransition(DataSource dataSource) {, +              viewAnimationFactory.build(dataSource, true /*isFirstResource*/);, +  private Transition<Drawable> getSecondResourceTransition(DataSource dataSource) {, +              viewAnimationFactory.build(dataSource, false /*isFirstResource*/);, +++ b/library/src/main/java/com/bumptech/glide/request/transition/NoTransition.java, +import com.bumptech.glide.load.DataSource;, +, +    public Transition<R> build(DataSource dataSource, boolean isFirstResource) {, +++ b/library/src/main/java/com/bumptech/glide/request/transition/TransitionFactory.java, +import com.bumptech.glide.load.DataSource;, +, +   * @param dataSource      The {@link com.bumptech.glide.load.DataSource} the resource was loaded, +   *                        from., +  Transition<R> build(DataSource dataSource, boolean isFirstResource);, +++ b/library/src/main/java/com/bumptech/glide/request/transition/ViewAnimationFactory.java, +import com.bumptech.glide.load.DataSource;, +, +   * @param dataSource {@inheritDoc}, +  public Transition<R> build(DataSource dataSource, boolean isFirstResource) {, +    if (dataSource == DataSource.MEMORY_CACHE || !isFirstResource) {, +++ b/library/src/main/java/com/bumptech/glide/load/DataSource.java, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +          animationFactory.build(dataSource, isFirstResource);, +++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java, +import com.bumptech.glide.load.DataSource;, +, +  public Transition<Drawable> build(DataSource dataSource, boolean isFirstResource) {, +    if (dataSource == DataSource.MEMORY_CACHE) {, +      return getFirstResourceTransition(dataSource);, +      return getSecondResourceTransition(dataSource);]
[+++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java, +  // before they start running or while they are paused. See #346., +    if (request == null) {, +      return false;, +    }, +    boolean isOwnedByUs = requests.remove(request);, +    // Avoid short circuiting., +    isOwnedByUs = pendingRequests.remove(request) || isOwnedByUs;]
[+++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        ModelLoader<Float, InputStream> mockLoader = mockStreamModelLoader(Float.class);, +        ModelLoader<T, InputStream> modelLoader = mockStreamModelLoader(modelClass);, +    private <T> ModelLoader<T, InputStream> mockStreamModelLoader(final Class<T> modelClass) {, +        ModelLoader<T, InputStream> modelLoader = mock(ModelLoader.class);, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        ModelLoader<Float, InputStream> mockLoader = mockStreamModelLoader(Float.class);, +        ModelLoader<T, InputStream> modelLoader = mockStreamModelLoader(modelClass);, +    private <T> ModelLoader<T, InputStream> mockStreamModelLoader(final Class<T> modelClass) {, +        ModelLoader<T, InputStream> modelLoader = mock(ModelLoader.class);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/ResourceLoaderTest.java, +package com.bumptech.glide.load.model;, +, +import android.net.Uri;, +import com.bumptech.glide.load.data.DataFetcher;, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +import org.robolectric.Robolectric;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertTrue;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.when;, +, +/**, + * Tests for the {@link com.bumptech.glide.load.model.ResourceLoader} class., + */, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +public class ResourceLoaderTest {, +, +    @Mock ModelLoader<Uri, Object> uriLoader;, +    @Mock DataFetcher<Object> fetcher;, +, +    private ResourceLoader<Object> loader;, +, +    @Before, +    public void setUp() {, +        MockitoAnnotations.initMocks(this);, +, +        loader = new ResourceLoader<Object>(Robolectric.application, uriLoader);, +    }, +, +    @Test, +    public void testCanHandleId() {, +        int id = android.R.drawable.star_off;, +        Uri contentUri = Uri.parse("android.resource://android/drawable/star_off");, +        when(uriLoader.getDataFetcher(eq(contentUri), anyInt(), anyInt())).thenReturn(fetcher);, +, +        assertTrue(loader.handles(id));, +        assertEquals(fetcher, loader.getDataFetcher(id, 100, 100));, +    }, +}, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        ModelLoader<Float, InputStream> mockLoader = mockStreamModelLoader(Float.class);, +        ModelLoader<T, InputStream> modelLoader = mockStreamModelLoader(modelClass);, +    private <T> ModelLoader<T, InputStream> mockStreamModelLoader(final Class<T> modelClass) {, +        ModelLoader<T, InputStream> modelLoader = mock(ModelLoader.class);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/ResourceLoaderTest.java, +package com.bumptech.glide.load.model;, +, +import android.net.Uri;, +import com.bumptech.glide.load.data.DataFetcher;, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +import org.robolectric.Robolectric;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertTrue;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.when;, +, +/**, + * Tests for the {@link com.bumptech.glide.load.model.ResourceLoader} class., + */, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +public class ResourceLoaderTest {, +, +    @Mock ModelLoader<Uri, Object> uriLoader;, +    @Mock DataFetcher<Object> fetcher;, +, +    private ResourceLoader<Object> loader;, +, +    @Before, +    public void setUp() {, +        MockitoAnnotations.initMocks(this);, +]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java, +    public void testDoesNotCloseNullData() throws IOException {, +, +        @Override, +        protected void close(Closeable data) throws IOException {, +            data.close();, +        }, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java, +    public void testDoesNotCloseNullData() throws IOException {, +, +        @Override, +        protected void close(Closeable data) throws IOException {, +            data.close();, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java, +import java.io.IOException;, +, +    @Override, +    protected void close(ParcelFileDescriptor data) throws IOException {, +        data.close();, +    }, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java, +    public void testDoesNotCloseNullData() throws IOException {, +, +        @Override, +        protected void close(Closeable data) throws IOException {, +            data.close();, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java, +import java.io.IOException;, +, +    @Override, +    protected void close(ParcelFileDescriptor data) throws IOException {, +        data.close();, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java, +public abstract class LocalUriFetcher<T> implements DataFetcher<T> {, +                close(data);, +, +    /**, +     * Returns a concrete data type from the given {@link android.net.Uri} using the given, +     * {@link android.content.ContentResolver}., +     *, +     * @throws FileNotFoundException, +     */, +, +    /**, +     * Closes the concrete data type if necessary., +     *, +     * <p>, +     *     Note - We can't rely on the closeable interface because it was added after our min API level. See issue #157., +     * </p>, +     *, +     * @param data The data to close., +     * @throws IOException, +     */, +    protected abstract void close(T data) throws IOException;, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java, +    public void testDoesNotCloseNullData() throws IOException {, +, +        @Override, +        protected void close(Closeable data) throws IOException {, +            data.close();, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java, +import java.io.IOException;, +, +    @Override, +    protected void close(ParcelFileDescriptor data) throws IOException {, +        data.close();, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java, +public abstract class LocalUriFetcher<T> implements DataFetcher<T> {, +                close(data);, +, +    /**, +     * Returns a concrete data type from the given {@link android.net.Uri} using the given, +     * {@link android.content.ContentResolver}., +     *, +     * @throws FileNotFoundException, +     */, +, +    /**, +     * Closes the concrete data type if necessary., +     *, +     * <p>, +     *     Note - We can't rely on the closeable interface because it was added after our min API level. See issue #157., +     * </p>, +     *, +     * @param data The data to close., +     * @throws IOException, +     */, +    protected abstract void close(T data) throws IOException;, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +import java.io.IOException;, +, +    @Override, +    protected void close(InputStream data) throws IOException {, +        data.close();, +    }]
[+++ b/.gitignore, +library/bin/*, +library/gen/*, +library/local.properties, +*.DS_Store, +*.swp, +++ b/.gitignore, +library/bin/*, +library/gen/*, +library/local.properties, +*.DS_Store, +*.swp, +++ /dev/null, +++ b/.gitignore, +library/bin/*, +library/gen/*, +library/local.properties, +*.DS_Store, +*.swp, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +library/bin/*, +library/gen/*, +library/local.properties, +*.DS_Store, +*.swp, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +library/bin/*, +library/gen/*, +library/local.properties, +*.DS_Store, +*.swp, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/AndroidManifest.xml, +<?xml version="1.0" encoding="utf-8"?>, +<manifest xmlns:android="http://schemas.android.com/apk/res/android", +          package="com.bumptech.photos", +          android:versionCode="1", +          android:versionName="1.0">, +  <application android:label="@string/app_name">, +    <activity android:name="ACTIVITY_ENTRY_NAME", +              android:label="@string/app_name">, +      <intent-filter>, +        <action android:name="android.intent.action.MAIN"/>, +        <category android:name="android.intent.category.LAUNCHER"/>, +      </intent-filter>, +    </activity>, +  </application>, +</manifest>, +++ b/.gitignore, +library/bin/*, +library/gen/*, +library/local.properties, +*.DS_Store, +*.swp, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/AndroidManifest.xml, +<?xml version="1.0" encoding="utf-8"?>, +<manifest xmlns:android="http://schemas.android.com/apk/res/android", +          package="com.bumptech.photos", +          android:versionCode="1", +          android:versionName="1.0">, +  <application android:label="@string/app_name">, +    <activity android:name="ACTIVITY_ENTRY_NAME", +              android:label="@string/app_name">, +      <intent-filter>, +        <action android:name="android.intent.action.MAIN"/>, +        <category android:name="android.intent.category.LAUNCHER"/>, +      </intent-filter>, +    </activity>, +  </application>, +</manifest>, +++ b/library/ant.properties, +# This file is used to override default values used by the Ant build system., +#, +# This file must be checked into Version Control Systems, as it is, +# integral to the build system of your project., +, +# This file is only used by the Ant script., +, +# You can use this to override default values such as, +#  'source.dir' for the location of your java source folder and, +#  'out.dir' for the location of your output folder., +, +# You can also use it define how the release builds are signed by declaring, +# the following properties:, +#  'key.store' for the location of your keystore and, +#  'key.alias' for the name of the key to use., +# The password will be asked during the build when you use the 'release' target., +, +++ b/.gitignore, +library/bin/*]
[+++ b/.travis.yml]
[+++ b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java, +     * See page 11 of http://giflib.sourceforge.net/gif89.txt for the position of the frame, +     *, +     *          Column number, in pixels, of the left edge of the image, with respect to the left edge of the Logical Screen., +     *          Row number, in pixels, of the top edge of the image with respect to the top edge of the Logical Screen., +        if (started) {, +        }, +        if (fixedWidth < 1) {, +        }, +        if (fixedHeight < 1) {, +        }]
[+++ b/library/library.iml, +        <option name="RES_FOLDERS_RELATIVE_PATH" value="file://$MODULE_DIR$/src/main/res" />, +++ b/library/library.iml, +        <option name="RES_FOLDERS_RELATIVE_PATH" value="file://$MODULE_DIR$/src/main/res" />, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java, +    public void testDefaultBitmapPoolSize() {, +//        assertThat(bitmapPoolSize).isIn(Range.open());, +        float totalScreenBytes = harness.getScreenSize() * (harness.bitmapPoolScreens + harness.memoryCacheScreens);, +        float totalScreenMb = totalScreenBytes / (1024 * 1024);, +        float memoryClassMb = totalScreenMb / harness.sizeMultiplier;, +        return (int) Math.ceil(memoryClassMb);, +            return new MemorySizeCalculator(Robolectric.application, activityManager, screenDimensions);, +++ b/library/library.iml, +        <option name="RES_FOLDERS_RELATIVE_PATH" value="file://$MODULE_DIR$/src/main/res" />, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java, +    public void testDefaultBitmapPoolSize() {, +//        assertThat(bitmapPoolSize).isIn(Range.open());, +        float totalScreenBytes = harness.getScreenSize() * (harness.bitmapPoolScreens + harness.memoryCacheScreens);, +        float totalScreenMb = totalScreenBytes / (1024 * 1024);, +        float memoryClassMb = totalScreenMb / harness.sizeMultiplier;, +        return (int) Math.ceil(memoryClassMb);, +            return new MemorySizeCalculator(Robolectric.application, activityManager, screenDimensions);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import android.util.Log;, +    private static final String TAG = "Glide";, +     * <p>, +     *     Calls to this method are ignored on KitKat and Lollipop. See #301., +     * </p>, +     *, +        if (DecodeFormat.REQUIRE_ARGB_8888 && decodeFormat != DecodeFormat.ALWAYS_ARGB_8888) {, +            this.decodeFormat = DecodeFormat.ALWAYS_ARGB_8888;, +            if (Log.isLoggable(TAG, Log.WARN)) {, +                Log.w(TAG, "Unsafe to use RGB_565 on KitKat or Lollipop, ignoring setDecodeFormat");, +            }, +        } else {, +        }, +++ b/library/library.iml, +        <option name="RES_FOLDERS_RELATIVE_PATH" value="file://$MODULE_DIR$/src/main/res" />, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java, +    public void testDefaultBitmapPoolSize() {, +//        assertThat(bitmapPoolSize).isIn(Range.open());, +        float totalScreenBytes = harness.getScreenSize() * (harness.bitmapPoolScreens + harness.memoryCacheScreens);, +        float totalScreenMb = totalScreenBytes / (1024 * 1024);, +        float memoryClassMb = totalScreenMb / harness.sizeMultiplier;, +        return (int) Math.ceil(memoryClassMb);, +            return new MemorySizeCalculator(Robolectric.application, activityManager, screenDimensions);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import android.util.Log;, +    private static final String TAG = "Glide";, +     * <p>, +     *     Calls to this method are ignored on KitKat and Lollipop. See #301., +     * </p>, +     *, +        if (DecodeFormat.REQUIRE_ARGB_8888 && decodeFormat != DecodeFormat.ALWAYS_ARGB_8888) {, +            this.decodeFormat = DecodeFormat.ALWAYS_ARGB_8888;, +            if (Log.isLoggable(TAG, Log.WARN)) {, +                Log.w(TAG, "Unsafe to use RGB_565 on KitKat or Lollipop, ignoring setDecodeFormat");, +            }, +        } else {, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +, +    /** There is a rendering issue in KitKat and L (or at least L MR1) when reusing mixed format bitmaps. See #301. */, +    public static final boolean REQUIRE_ARGB_8888 = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;, +, +    public static final DecodeFormat DEFAULT = REQUIRE_ARGB_8888 ? ALWAYS_ARGB_8888 : PREFER_RGB_565;, +++ b/library/library.iml, +        <option name="RES_FOLDERS_RELATIVE_PATH" value="file://$MODULE_DIR$/src/main/res" />, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java, +    public void testDefaultBitmapPoolSize() {, +//        assertThat(bitmapPoolSize).isIn(Range.open());, +        float totalScreenBytes = harness.getScreenSize() * (harness.bitmapPoolScreens + harness.memoryCacheScreens);, +        float totalScreenMb = totalScreenBytes / (1024 * 1024);, +        float memoryClassMb = totalScreenMb / harness.sizeMultiplier;, +        return (int) Math.ceil(memoryClassMb);, +            return new MemorySizeCalculator(Robolectric.application, activityManager, screenDimensions);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import android.util.Log;, +    private static final String TAG = "Glide";, +     * <p>, +     *     Calls to this method are ignored on KitKat and Lollipop. See #301., +     * </p>, +     *, +        if (DecodeFormat.REQUIRE_ARGB_8888 && decodeFormat != DecodeFormat.ALWAYS_ARGB_8888) {, +            this.decodeFormat = DecodeFormat.ALWAYS_ARGB_8888;, +            if (Log.isLoggable(TAG, Log.WARN)) {, +                Log.w(TAG, "Unsafe to use RGB_565 on KitKat or Lollipop, ignoring setDecodeFormat");, +            }, +        } else {, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +, +    /** There is a rendering issue in KitKat and L (or at least L MR1) when reusing mixed format bitmaps. See #301. */, +    public static final boolean REQUIRE_ARGB_8888 = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;, +, +    public static final DecodeFormat DEFAULT = REQUIRE_ARGB_8888 ? ALWAYS_ARGB_8888 : PREFER_RGB_565;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java, +import android.text.format.Formatter;, +    // Visible for testing., +    static final int BITMAP_POOL_TARGET_SCREENS = 4;]
[+++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +        final AtomicInteger calledCount = new AtomicInteger();, +            public Object getPreloadItem(int position) {, +                final int count = calledCount.getAndIncrement();, +                assertEquals(11 + count, position);, +                return super.getPreloadItem(position);, +        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);, +        assertEquals(10, calledCount.get());, +            public int[] getPreloadSize(Object item, int pos) {, +            public Object getPreloadItem(int position) {, +                return objects.get(position - 10);, +                assertEquals(objects.get(pos - 10), item);, +        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter,, +                                                                    toPreload);, +        preloader.onScroll(null, 1, 10, 20);, +        final AtomicInteger calledCount = new AtomicInteger();, +            public Object getPreloadItem(int position) {, +                if (position >= 40) {, +                final int count = calledCount.getAndIncrement();, +                assertEquals(28 - count, position);, +                return super.getPreloadItem(position);, +        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);, +            public int[] getPreloadSize(Object item, int pos) {, +            public Object getPreloadItem(int position) {, +                if (position == 40) {, +                    return null;, +                return objects.get(position);, +        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter,, +                                                                    toPreload);, +        preloader.onScroll(null, 30, 10, 10);, +        preloader.onScroll(null, 29, 10, 10);, +        final AtomicInteger calledCount = new AtomicInteger();, +            public Object getPreloadItem(int position) {, +                final int count = calledCount.getAndIncrement();, +                assertEquals(26 + count, position);, +                return super.getPreloadItem(position);, +        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);, +        final AtomicInteger calledCount = new AtomicInteger();, +            public Object getPreloadItem(int position) {, +                if (position >= 17) {, +                final int count = calledCount.getAndIncrement();, +                assertEquals(5 - count, position);, +                return super.getPreloadItem(position);, +        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);, +            public Object getPreloadItem(int position) {, +                assertEquals(11 + current, position);, +                return super.getPreloadItem(position);, +        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);, +        assertEquals(13, called.get());, +            public Object getPreloadItem(int position) {, +                if (position >= 20) {, +                assertEquals(19 - current, position);, +                return super.getPreloadItem(position);, +        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);, +        assertEquals(13, called.get());, +            public Object getPreloadItem(int position) {, +                return objects.get(position - 11);, +        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);, +        preloader.onScroll(null, 1, 10, 13);, +    private static class ListPreloaderAdapter implements ListPreloader.PreloadModelProvider<Object>,, +            ListPreloader.PreloadSizeProvider<Object> {, +        public Object getPreloadItem(int position) {, +            return new Object();, +        public int[] getPreloadSize(Object item, int position) {, +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +        final AtomicInteger calledCount = new AtomicInteger();, +            public Object getPreloadItem(int position) {, +                final int count = calledCount.getAndIncrement();, +                assertEquals(11 + count, position);, +                return super.getPreloadItem(position);, +        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);, +        assertEquals(10, calledCount.get());, +            public int[] getPreloadSize(Object item, int pos) {, +            public Object getPreloadItem(int position) {, +                return objects.get(position - 10);, +                assertEquals(objects.get(pos - 10), item);, +        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter,, +                                                                    toPreload);, +        preloader.onScroll(null, 1, 10, 20);, +        final AtomicInteger calledCount = new AtomicInteger();, +            public Object getPreloadItem(int position) {, +                if (position >= 40) {, +                final int count = calledCount.getAndIncrement();, +                assertEquals(28 - count, position);, +                return super.getPreloadItem(position);, +        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, 10);, +            public int[] getPreloadSize(Object item, int pos) {, +            public Object getPreloadItem(int position) {, +                if (position == 40) {, +                    return null;, +                return objects.get(position);, +        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter,, +                                                                    toPreload);, +        preloader.onScroll(null, 30, 10, 10);, +        preloader.onScroll(null, 29, 10, 10);, +        final AtomicInteger calledCount = new AtomicInteger();, +            public Object getPreloadItem(int position) {, +                final int count = calledCount.getAndIncrement();, +                assertEquals(26 + count, position);, +                return super.getPreloadItem(position);]
[+++ b/library/build.gradle, +++ b/library/build.gradle, +++ /dev/null, +++ b/library/build.gradle, +++ /dev/null, +++ b/scripts/upload.gradle, +            : 'https://oss.sonatype.org/service/local/staging/deploy/maven2/', +            : 'https://oss.sonatype.org/content/repositories/snapshots/', +    return hasProperty('USERNAME') ? USERNAME : (hasProperty('NEXUS_USERNAME') ? NEXUS_USERNAME : ''), +    return hasProperty('PASSWORD') ? PASSWORD : (hasProperty('NEXUS_PASSWORD') ? NEXUS_PASSWORD : ''), +                            name = 'Simplified BSD License', +                            url = 'http://www.opensource.org/licenses/bsd-license', +                            distribution = 'repo', +                            name = 'The Apache Software License, Version 2.0', +                            url = 'http://www.apache.org/licenses/LICENSE-2.0.txt', +                            distribution = 'repo', +        required { isReleaseBuild() && gradle.taskGraph.hasTask('uploadArchives') }, +    def isAndroidProject = project.plugins.hasPlugin('com.android.application') || project.plugins.hasPlugin('com.android.library'), +, +    if (isAndroidProject) {, +        def releaseVariants = project.android.libraryVariants.findAll {, +            it.buildType.name.equalsIgnoreCase('release'), +                links('http://docs.oracle.com/javase/7/docs/api/'), +                linksOffline('http://d.android.com/reference', '${androidSdkDirectory}/docs/reference'), +            classifier = 'javadoc', +            classifier = 'sources', +            archives androidSourcesJar, +            archives androidJavadocsJar]
[+++ b/library/src/main/java/com/bumptech/glide/Registry.java, +        for (Class<?> registeredResourceClass : registeredResourceClasses) {, +          if (!result.contains(registeredResourceClass)) {, +            result.add(registeredResourceClass);, +          }, +        }, +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +        for (Class<?> registeredResourceClass : registeredResourceClasses) {, +          if (!result.contains(registeredResourceClass)) {, +            result.add(registeredResourceClass);, +          }, +        }, +++ b/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java, +    } else {, +      key.set(modelClass, resourceClass);]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java, +import com.bumptech.glide.tests.Util;, +import java.util.Collections;, +    Transformation<Object> transformation = mock(Transformation.class);, +, +    public Harness() {, +      doAnswer(new Util.WriteDigest("transformation")).when(transformation), +          .updateDiskCacheKey(any(MessageDigest.class));, +    }, +      return new EngineKey(id, signature, width, height,, +          Collections.<Class<?>, Transformation<?>>singletonMap(Object.class, transformation),, +          resourceClass, transcodeClass);, +  public void testDiffersIfTransformationsDiffer() throws NoSuchAlgorithmException {, +    EngineKey first = harness.build();, +    Transformation<Object> other = mock(Transformation.class);, +    doAnswer(new Util.WriteDigest("other")).when(other), +        .updateDiskCacheKey(any(MessageDigest.class));, +    harness.transformation = other;, +    EngineKey second = harness.build();, +    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java, +import com.bumptech.glide.tests.Util;, +import java.util.Collections;, +    Transformation<Object> transformation = mock(Transformation.class);, +, +    public Harness() {, +      doAnswer(new Util.WriteDigest("transformation")).when(transformation), +          .updateDiskCacheKey(any(MessageDigest.class));, +    }, +      return new EngineKey(id, signature, width, height,, +          Collections.<Class<?>, Transformation<?>>singletonMap(Object.class, transformation),, +          resourceClass, transcodeClass);, +  public void testDiffersIfTransformationsDiffer() throws NoSuchAlgorithmException {, +    EngineKey first = harness.build();, +    Transformation<Object> other = mock(Transformation.class);, +    doAnswer(new Util.WriteDigest("other")).when(other), +        .updateDiskCacheKey(any(MessageDigest.class));, +    harness.transformation = other;, +    EngineKey second = harness.build();, +    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java, +import com.bumptech.glide.load.Transformation;, +import java.util.Map;, +  private final Map<Class<?>, Transformation<?>> transformations;, +  public EngineKey(Object model, Key signature, int width, int height,, +      Map<Class<?>, Transformation<?>> transformations, Class<?> resourceClass,, +    this.transformations = Preconditions.checkNotNull(transformations);, +          && transformations.equals(other.transformations), +      hashCode = 31 * hashCode + transformations.hashCode();, +        + ", transformations=" + transformations, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java, +import com.bumptech.glide.tests.Util;, +import java.util.Collections;, +    Transformation<Object> transformation = mock(Transformation.class);, +, +    public Harness() {, +      doAnswer(new Util.WriteDigest("transformation")).when(transformation), +          .updateDiskCacheKey(any(MessageDigest.class));, +    }, +      return new EngineKey(id, signature, width, height,, +          Collections.<Class<?>, Transformation<?>>singletonMap(Object.class, transformation),, +          resourceClass, transcodeClass);, +  public void testDiffersIfTransformationsDiffer() throws NoSuchAlgorithmException {, +    EngineKey first = harness.build();, +    Transformation<Object> other = mock(Transformation.class);, +    doAnswer(new Util.WriteDigest("other")).when(other), +        .updateDiskCacheKey(any(MessageDigest.class));, +    harness.transformation = other;, +    EngineKey second = harness.build();, +    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java, +import com.bumptech.glide.load.Transformation;, +import java.util.Map;, +  private final Map<Class<?>, Transformation<?>> transformations;, +  public EngineKey(Object model, Key signature, int width, int height,, +      Map<Class<?>, Transformation<?>> transformations, Class<?> resourceClass,, +    this.transformations = Preconditions.checkNotNull(transformations);, +          && transformations.equals(other.transformations), +      hashCode = 31 * hashCode + transformations.hashCode();, +        + ", transformations=" + transformations, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKeyFactory.java, +        requestContext.getTransformations(), requestContext.getResourceClass(),, +        requestContext.getTranscodeClass());, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java, +import com.bumptech.glide.tests.Util;, +import java.util.Collections;, +    Transformation<Object> transformation = mock(Transformation.class);, +, +    public Harness() {, +      doAnswer(new Util.WriteDigest("transformation")).when(transformation), +          .updateDiskCacheKey(any(MessageDigest.class));, +    }, +      return new EngineKey(id, signature, width, height,, +          Collections.<Class<?>, Transformation<?>>singletonMap(Object.class, transformation),, +          resourceClass, transcodeClass);, +  public void testDiffersIfTransformationsDiffer() throws NoSuchAlgorithmException {, +    EngineKey first = harness.build();, +    Transformation<Object> other = mock(Transformation.class);, +    doAnswer(new Util.WriteDigest("other")).when(other), +        .updateDiskCacheKey(any(MessageDigest.class));]
[+++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=3.0-SNAPSHOT, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=3.0-SNAPSHOT, +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import org.robolectric.RuntimeEnvironment;, +import org.robolectric.shadows.ShadowLooper;, +        requestQueue = Volley.newRequestQueue(RuntimeEnvironment.application);, +                    ShadowLooper.runUiThreadTasks();, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=3.0-SNAPSHOT, +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import org.robolectric.RuntimeEnvironment;, +import org.robolectric.shadows.ShadowLooper;, +        requestQueue = Volley.newRequestQueue(RuntimeEnvironment.application);, +                    ShadowLooper.runUiThreadTasks();, +++ b/integration/volley/volley.iml, +    <orderEntry type="library" exported="" scope="TEST" name="robolectric-annotations-3.0-SNAPSHOT" level="project" />, +    <orderEntry type="library" exported="" name="library-1.0.10" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="truth-0.24" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="robolectric-3.0-SNAPSHOT" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="ant-1.8.0" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="bcprov-jdk15on-1.50" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="mockwebserver-2.2.0" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="sqlite4java-0.282" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="maven-ant-tasks-2.1.3" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="commons-codec-1.3" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="robolectric-utils-3.0-SNAPSHOT" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="robolectric-resources-3.0-SNAPSHOT" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="shadows-core-3.0-SNAPSHOT-21" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="icu4j-53.1" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="ant-launcher-1.8.0" level="project" />, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=3.0-SNAPSHOT, +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import org.robolectric.RuntimeEnvironment;, +import org.robolectric.shadows.ShadowLooper;, +        requestQueue = Volley.newRequestQueue(RuntimeEnvironment.application);, +                    ShadowLooper.runUiThreadTasks();, +++ b/integration/volley/volley.iml, +    <orderEntry type="library" exported="" scope="TEST" name="robolectric-annotations-3.0-SNAPSHOT" level="project" />, +    <orderEntry type="library" exported="" name="library-1.0.10" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="truth-0.24" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="robolectric-3.0-SNAPSHOT" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="ant-1.8.0" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="bcprov-jdk15on-1.50" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="mockwebserver-2.2.0" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="sqlite4java-0.282" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="maven-ant-tasks-2.1.3" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="commons-codec-1.3" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="robolectric-utils-3.0-SNAPSHOT" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="robolectric-resources-3.0-SNAPSHOT" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="shadows-core-3.0-SNAPSHOT-21" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="icu4j-53.1" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="ant-launcher-1.8.0" level="project" />, +++ b/library/library.iml, +    <orderEntry type="library" exported="" scope="TEST" name="robolectric-annotations-3.0-SNAPSHOT" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="robolectric-3.0-SNAPSHOT" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="robolectric-utils-3.0-SNAPSHOT" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="vtd-xml-2.11" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="asm-tree-5.0.1" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="robolectric-resources-3.0-SNAPSHOT" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="icu4j-53.1" level="project" />, +    <orderEntry type="library" exported="" scope="TEST" name="shadows-core-3.0-SNAPSHOT-21" level="project" />, +++ b/build.gradle]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java, +import com.squareup.javapoet.MethodSpec.Builder;, +            .addParameters(ProcessorUtil.getParameters(methodToOverride));, +    addReturnAnnotations(builder, methodToOverride);, +  private Builder addReturnAnnotations(Builder builder, ExecutableElement methodToOverride) {, +    String visibleForTestingTypeQualifiedName =, +        processingEnv, +            .getElementUtils(), +            .getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME), +            .toString();, +, +    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {, +      builder.addAnnotation(AnnotationSpec.get(mirror));, +, +      // Suppress a lint warning if we're overriding a VisibleForTesting method., +      // See #1977., +      String annotationQualifiedName = mirror.getAnnotationType().toString();, +      if (annotationQualifiedName.equals(visibleForTestingTypeQualifiedName)) {, +        builder.addAnnotation(, +            AnnotationSpec.builder(, +                ClassName.get(SUPPRESS_LINT_PACKAGE_NAME, SUPPRESS_LINT_CLASS_NAME)), +                .addMember("value", "$S", "VisibleForTests"), +                .build());, +      }, +    }, +, +    return builder;, +  }, +, +, +    Builder builder = MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString()), +        .addParameters(ProcessorUtil.getParameters(methodToOverride)), +            parameter.getSimpleName());, +, +    return addReturnAnnotations(builder, methodToOverride).build();, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java, +import com.squareup.javapoet.MethodSpec.Builder;, +            .addParameters(ProcessorUtil.getParameters(methodToOverride));, +    addReturnAnnotations(builder, methodToOverride);, +  private Builder addReturnAnnotations(Builder builder, ExecutableElement methodToOverride) {, +    String visibleForTestingTypeQualifiedName =, +        processingEnv, +            .getElementUtils(), +            .getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME), +            .toString();, +, +    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {, +      builder.addAnnotation(AnnotationSpec.get(mirror));, +, +      // Suppress a lint warning if we're overriding a VisibleForTesting method., +      // See #1977., +      String annotationQualifiedName = mirror.getAnnotationType().toString();, +      if (annotationQualifiedName.equals(visibleForTestingTypeQualifiedName)) {, +        builder.addAnnotation(, +            AnnotationSpec.builder(, +                ClassName.get(SUPPRESS_LINT_PACKAGE_NAME, SUPPRESS_LINT_CLASS_NAME)), +                .addMember("value", "$S", "VisibleForTests"), +                .build());, +      }, +    }, +, +    return builder;, +  }, +, +, +    Builder builder = MethodSpec.methodBuilder(methodToOverride.getSimpleName().toString()), +        .addParameters(ProcessorUtil.getParameters(methodToOverride)), +            parameter.getSimpleName());, +, +    return addReturnAnnotations(builder, methodToOverride).build();, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java, +import com.squareup.javapoet.MethodSpec.Builder;, +            .addParameters(ProcessorUtil.getParameters(methodToOverride));, +    addReturnAnnotations(builder, methodToOverride);, +  private Builder addReturnAnnotations(Builder builder, ExecutableElement methodToOverride) {, +    String visibleForTestingTypeQualifiedName =, +        processingEnv, +            .getElementUtils(), +            .getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME), +            .toString();, +, +    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {, +      builder.addAnnotation(AnnotationSpec.get(mirror));, +, +      // Suppress a lint warning if we're overriding a VisibleForTesting method., +      // See #1977., +      String annotationQualifiedName = mirror.getAnnotationType().toString();, +      if (annotationQualifiedName.equals(visibleForTestingTypeQualifiedName)) {, +        builder.addAnnotation(, +            AnnotationSpec.builder(, +                ClassName.get(SUPPRESS_LINT_PACKAGE_NAME, SUPPRESS_LINT_CLASS_NAME)), +                .addMember("value", "$S", "VisibleForTests"), +                .build());, +      }, +    }, +, +    return builder;, +  }, +]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +import java.util.Map;, +  public LoadData<InputStream> buildLoadData(GlideUrl model, int width, int height,, +      Map<String, Object> options) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +import java.util.Map;, +  public LoadData<InputStream> buildLoadData(GlideUrl model, int width, int height,, +      Map<String, Object> options) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java, +import java.util.Map;, +  public LoadData<InputStream> buildLoadData(GlideUrl url, int width, int height,, +      Map<String, Object> options) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +import java.util.Map;, +  public LoadData<InputStream> buildLoadData(GlideUrl model, int width, int height,, +      Map<String, Object> options) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java, +import java.util.Map;, +  public LoadData<InputStream> buildLoadData(GlideUrl url, int width, int height,, +      Map<String, Object> options) {, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import static org.mockito.Matchers.anyMapOf;, +    when(failLoader.buildLoadData(any(failModel), anyInt(), anyInt(),, +        anyMapOf(String.class, Object.class))), +    when(modelLoader.buildLoadData(any(modelClass), anyInt(), anyInt(),, +        anyMapOf(String.class, Object.class))), +      when(mockUrlLoader.buildLoadData(any(modelClass), anyInt(), anyInt(),, +          anyMapOf(String.class, Object.class))), +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +import java.util.Map;, +  public LoadData<InputStream> buildLoadData(GlideUrl model, int width, int height,, +      Map<String, Object> options) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java, +import java.util.Map;, +  public LoadData<InputStream> buildLoadData(GlideUrl url, int width, int height,, +      Map<String, Object> options) {, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import static org.mockito.Matchers.anyMapOf;, +    when(failLoader.buildLoadData(any(failModel), anyInt(), anyInt(),, +        anyMapOf(String.class, Object.class))), +    when(modelLoader.buildLoadData(any(modelClass), anyInt(), anyInt(),, +        anyMapOf(String.class, Object.class))), +      when(mockUrlLoader.buildLoadData(any(modelClass), anyInt(), anyInt(),, +          anyMapOf(String.class, Object.class))), +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java, +import java.util.HashMap;, +, +    assertEquals(fetcher, loader.buildLoadData(assetUri, IMAGE_SIDE, IMAGE_SIDE,, +        new HashMap<String, Object>()).fetcher);, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +import java.util.Map;, +  public LoadData<InputStream> buildLoadData(GlideUrl model, int width, int height,, +      Map<String, Object> options) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java, +import java.util.Map;, +  public LoadData<InputStream> buildLoadData(GlideUrl url, int width, int height,, +      Map<String, Object> options) {, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import static org.mockito.Matchers.anyMapOf;, +    when(failLoader.buildLoadData(any(failModel), anyInt(), anyInt(),, +        anyMapOf(String.class, Object.class))), +    when(modelLoader.buildLoadData(any(modelClass), anyInt(), anyInt(),, +        anyMapOf(String.class, Object.class))), +      when(mockUrlLoader.buildLoadData(any(modelClass), anyInt(), anyInt(),, +          anyMapOf(String.class, Object.class))), +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java, +import java.util.HashMap;, +, +    assertEquals(fetcher, loader.buildLoadData(assetUri, IMAGE_SIDE, IMAGE_SIDE,, +        new HashMap<String, Object>()).fetcher);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/ByteArrayLoaderTest.java, +import java.util.HashMap;, +import java.util.Map;, +  Map<String, Object> options;, +    options = new HashMap<>();, +    DataFetcher<Object> fetcher = loader.buildLoadData(data, -1, -1, options).fetcher;, +    loader.buildLoadData(data, 10, 10, options).fetcher.loadData(Priority.HIGH, callback);, +    assertEquals(Object.class,, +        loader.buildLoadData(new byte[10], 10, 10, options).fetcher.getDataClass());, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +import java.util.Map;, +  public LoadData<InputStream> buildLoadData(GlideUrl model, int width, int height,, +      Map<String, Object> options) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java, +import java.util.Map;, +  public LoadData<InputStream> buildLoadData(GlideUrl url, int width, int height,, +      Map<String, Object> options) {, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import static org.mockito.Matchers.anyMapOf;, +    when(failLoader.buildLoadData(any(failModel), anyInt(), anyInt(),, +        anyMapOf(String.class, Object.class))), +    when(modelLoader.buildLoadData(any(modelClass), anyInt(), anyInt(),, +        anyMapOf(String.class, Object.class))), +      when(mockUrlLoader.buildLoadData(any(modelClass), anyInt(), anyInt(),, +          anyMapOf(String.class, Object.class))), +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/AssetUriLoaderTest.java, +import java.util.HashMap;, +, +    assertEquals(fetcher, loader.buildLoadData(assetUri, IMAGE_SIDE, IMAGE_SIDE,, +        new HashMap<String, Object>()).fetcher);]
[+++ b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java, +import android.util.Log;, +    private static final String TAG = "AnimatedGifEncoder";, +, +    // The minimum % of an images pixels that must be transparent for us to set a transparent index automatically., +    private static final double MIN_TRANSPARENT_PERCENTAGE = 4d;, +        int totalTransparentPixels = 0;, +                totalTransparentPixels++;, +, +        double transparentPercentage = 100 * totalTransparentPixels / (double) pixelsInt.length;, +        // Assume images with greater where more than n% of the pixels are transparent actually have transparency., +        // See issue #214., +        hasTransparentPixels = transparentPercentage > MIN_TRANSPARENT_PERCENTAGE;, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +            Log.d(TAG, "got pixels for frame with " + transparentPercentage + "% transparent pixels");, +        }]
[+++ b/build.gradle, +buildscript {, +    repositories {, +        mavenCentral(), +    }, +    dependencies {, +        classpath 'com.android.tools.build:gradle:0.11.+', +    }, +}, +++ b/build.gradle, +buildscript {, +    repositories {, +        mavenCentral(), +    }, +    dependencies {, +        classpath 'com.android.tools.build:gradle:0.11.+', +    }, +}, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, +buildscript {, +    repositories {, +        mavenCentral(), +    }, +    dependencies {, +        classpath 'com.android.tools.build:gradle:0.11.+', +    }, +}, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Sun Jun 22 01:25:24 PDT 2014, +distributionBase=GRADLE_USER_HOME, +distributionPath=wrapper/dists, +zipStoreBase=GRADLE_USER_HOME, +zipStorePath=wrapper/dists, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/build.gradle, +buildscript {, +    repositories {, +        mavenCentral(), +    }, +    dependencies {, +        classpath 'com.android.tools.build:gradle:0.11.+', +    }, +}, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Sun Jun 22 01:25:24 PDT 2014, +distributionBase=GRADLE_USER_HOME, +distributionPath=wrapper/dists, +zipStoreBase=GRADLE_USER_HOME, +zipStorePath=wrapper/dists, +distributionUrl=http\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/gradlew, +#!/usr/bin/env bash, +, +##############################################################################, +##, +##  Gradle start up script for UN*X, +##, +##############################################################################, +, +# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script., +DEFAULT_JVM_OPTS="", +, +APP_NAME="Gradle", +APP_BASE_NAME=`basename "$0"`, +, +# Use the maximum available, or set MAX_FD != -1 to use that value., +MAX_FD="maximum", +, +warn ( ) {, +    echo "$*", +}, +, +die ( ) {, +    echo, +    echo "$*", +    echo, +    exit 1, +}, +, +# OS specific support (must be 'true' or 'false')., +cygwin=false, +msys=false, +darwin=false, +case "`uname`" in, +  CYGWIN* ), +    cygwin=true, +    ;;, +  Darwin* ), +    darwin=true, +    ;;, +  MINGW* ), +    msys=true, +    ;;, +esac, +, +# For Cygwin, ensure paths are in UNIX format before anything is touched., +if $cygwin ; then]
[+++ b/README.md, +  <version>3.3.1</version>, +    <version>1.0.1</version>, +    <version>1.0.1</version>, +++ b/README.md, +  <version>3.3.1</version>, +    <version>1.0.1</version>, +    <version>1.0.1</version>, +++ b/gradle.properties, +VERSION_NAME=3.3.1, +VERSION_MINOR=3, +VERSION_PATCH=1, +++ b/README.md, +  <version>3.3.1</version>, +    <version>1.0.1</version>, +    <version>1.0.1</version>, +++ b/gradle.properties, +VERSION_NAME=3.3.1, +VERSION_MINOR=3, +VERSION_PATCH=1, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.0.1, +VERSION_MINOR=0, +VERSION_PATCH=1, +++ b/README.md, +  <version>3.3.1</version>, +    <version>1.0.1</version>, +    <version>1.0.1</version>, +++ b/gradle.properties, +VERSION_NAME=3.3.1, +VERSION_MINOR=3, +VERSION_PATCH=1, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.0.1, +VERSION_MINOR=0, +VERSION_PATCH=1, +++ b/integration/volley/gradle.properties, +VERSION_NAME=1.0.1, +VERSION_MINOR=0, +VERSION_PATCH=1]
[+++ b/library/src/main/java/com/bumptech/glide/DrawableOptions.java, +++ b/library/src/main/java/com/bumptech/glide/DrawableOptions.java, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +     * impractical to return that size from {@link Target#getSize(com.bumptech.glide.request.target.SizeReadyCallback)}., +++ b/library/src/main/java/com/bumptech/glide/DrawableOptions.java, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +     * impractical to return that size from {@link Target#getSize(com.bumptech.glide.request.target.SizeReadyCallback)}., +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        public void onLoadStarted(Drawable placeholder) {, +, +        }, +, +        @Override, +        public void onLoadFailed(Exception e, Drawable errorDrawable) {, +, +        }, +, +        @Override, +        public void onLoadCleared(Drawable placeholder) {, +, +        }, +++ b/library/src/main/java/com/bumptech/glide/DrawableOptions.java, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +     * impractical to return that size from {@link Target#getSize(com.bumptech.glide.request.target.SizeReadyCallback)}., +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        public void onLoadStarted(Drawable placeholder) {, +, +        }, +, +        @Override, +        public void onLoadFailed(Exception e, Drawable errorDrawable) {, +, +        }, +, +        @Override, +        public void onLoadCleared(Drawable placeholder) {, +, +        }, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +, +import com.bumptech.glide.request.target.SizeReadyCallback;, +++ b/library/src/main/java/com/bumptech/glide/DrawableOptions.java, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +     * impractical to return that size from {@link Target#getSize(com.bumptech.glide.request.target.SizeReadyCallback)}., +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        public void onLoadStarted(Drawable placeholder) {, +, +        }, +, +        @Override, +        public void onLoadFailed(Exception e, Drawable errorDrawable) {, +, +        }, +, +        @Override, +        public void onLoadCleared(Drawable placeholder) {, +, +        }, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +, +import com.bumptech.glide.request.target.SizeReadyCallback;, +++ b/library/src/main/java/com/bumptech/glide/request/GenericRequest.java, +import com.bumptech.glide.request.target.SizeReadyCallback;, +public final class GenericRequest<A, T, Z, R> implements Request, SizeReadyCallback,, +            if (canNotifyStatusChanged()) {, +                target.onLoadStarted(getPlaceholderDrawable());, +            }, +        // Resource must be released before canNotifyStatusChanged is called., +        if (canNotifyStatusChanged()) {, +            target.onLoadCleared(getPlaceholderDrawable());, +        }, +    private void setErrorPlaceholder(Exception e) {, +        if (!canNotifyStatusChanged()) {, +        if (error == null) {, +            error = getPlaceholderDrawable();, +        target.onLoadFailed(e, error);, +    private boolean canSetResource() {, +    private boolean canNotifyStatusChanged() {, +        return requestCoordinator == null || requestCoordinator.canNotifyStatusChanged(this);, +    private boolean isFirstReadyResource() {, +        if (!canSetResource()) {, +                isFirstReadyResource())) {, +            GlideAnimation<R> animation = animationFactory.build(loadedFromMemoryCache, isFirstReadyResource());, +        if (requestListener == null || !requestListener.onException(e, model, target, isFirstReadyResource())) {, +            setErrorPlaceholder(e);, +++ b/library/src/main/java/com/bumptech/glide/DrawableOptions.java, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +     * impractical to return that size from {@link Target#getSize(com.bumptech.glide.request.target.SizeReadyCallback)}., +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        public void onLoadStarted(Drawable placeholder) {, +, +        }, +, +        @Override, +        public void onLoadFailed(Exception e, Drawable errorDrawable) {, +, +        }, +, +        @Override, +        public void onLoadCleared(Drawable placeholder) {]
[+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java, +import javax.lang.model.element.AnnotationMirror;, +  private static final ClassName CHECK_RESULT_CLASS_NAME =, +      ClassName.get("android.support.annotation", "CheckResult");, +        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build()), +    MethodSpec.Builder builder = MethodSpec.overriding(methodToOverride), +            .build());, +, +    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {, +      builder.addAnnotation(AnnotationSpec.get(mirror));, +    }, +    return builder.build();, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java, +import javax.lang.model.element.AnnotationMirror;, +  private static final ClassName CHECK_RESULT_CLASS_NAME =, +      ClassName.get("android.support.annotation", "CheckResult");, +        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build()), +    MethodSpec.Builder builder = MethodSpec.overriding(methodToOverride), +            .build());, +, +    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {, +      builder.addAnnotation(AnnotationSpec.get(mirror));, +    }, +    return builder.build();, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +import android.support.annotation.CheckResult;, +  @CheckResult, +  @CheckResult, +  @CheckResult, +  @CheckResult, +  @CheckResult, +  @CheckResult, +  @CheckResult, +  @CheckResult]
[+++ b/library/src/androidTest/java/com/bumptech/glide/request/target/SimpleTargetTest.java, +import static org.mockito.Mockito.mock;, +, +    public void testThrowsOnGetSizeIfGivenWidthIsLessThanZero() {, +        getTarget(-1, 1).getSize(mock(SizeReadyCallback.class));, +    }, +    @Test(expected = IllegalArgumentException.class), +    public void testThrowsOnGetSizeIfGivenWidthIsEqualToZero() {, +        getTarget(0, 1).getSize(mock(SizeReadyCallback.class));, +    }, +, +    @Test(expected = IllegalArgumentException.class), +    public void testThrowsOnGetSizeIfGivenHeightIsLessThanZero() {, +        getTarget(1, -1).getSize(mock(SizeReadyCallback.class));, +    }, +, +    @Test(expected = IllegalArgumentException.class), +    public void testThrowsOnGetSizeIfGivenHeightIsEqualToZero() {, +        getTarget(1, 0).getSize(mock(SizeReadyCallback.class));, +    }, +, +    @Test, +    public void testCanBeConstructedWithoutDimensions() {, +        getTarget();, +    }, +, +    @Test(expected = IllegalArgumentException.class), +    public void testThrowsOnGetSizeIfConstructedWithoutDimensions() {, +        getTarget().getSize(mock(SizeReadyCallback.class));, +    }, +, +    private SimpleTarget<Object> getTarget() {, +        return new SimpleTarget<Object>() {, +            public void onResourceReady(Object resource, GlideAnimation<? super Object> glideAnimation) {, +                // Do nothing., +    private SimpleTarget<Object> getTarget(int width, int height) {, +        return new SimpleTarget<Object>(width, height) {, +            public void onResourceReady(Object resource, GlideAnimation<? super Object> glideAnimation) {, +                // Do nothing., +++ b/library/src/androidTest/java/com/bumptech/glide/request/target/SimpleTargetTest.java, +import static org.mockito.Mockito.mock;, +, +    public void testThrowsOnGetSizeIfGivenWidthIsLessThanZero() {, +        getTarget(-1, 1).getSize(mock(SizeReadyCallback.class));, +    }, +    @Test(expected = IllegalArgumentException.class), +    public void testThrowsOnGetSizeIfGivenWidthIsEqualToZero() {, +        getTarget(0, 1).getSize(mock(SizeReadyCallback.class));, +    }, +, +    @Test(expected = IllegalArgumentException.class), +    public void testThrowsOnGetSizeIfGivenHeightIsLessThanZero() {, +        getTarget(1, -1).getSize(mock(SizeReadyCallback.class));, +    }, +, +    @Test(expected = IllegalArgumentException.class), +    public void testThrowsOnGetSizeIfGivenHeightIsEqualToZero() {, +        getTarget(1, 0).getSize(mock(SizeReadyCallback.class));, +    }, +, +    @Test, +    public void testCanBeConstructedWithoutDimensions() {, +        getTarget();, +    }, +, +    @Test(expected = IllegalArgumentException.class), +    public void testThrowsOnGetSizeIfConstructedWithoutDimensions() {, +        getTarget().getSize(mock(SizeReadyCallback.class));, +    }, +, +    private SimpleTarget<Object> getTarget() {, +        return new SimpleTarget<Object>() {, +            public void onResourceReady(Object resource, GlideAnimation<? super Object> glideAnimation) {, +                // Do nothing., +    private SimpleTarget<Object> getTarget(int width, int height) {, +        return new SimpleTarget<Object>(width, height) {, +            public void onResourceReady(Object resource, GlideAnimation<? super Object> glideAnimation) {, +                // Do nothing., +++ b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java, +     * Constructor for the target that assumes you will have called, +     * {@link com.bumptech.glide.GenericRequestBuilder#override(int, int)} on the request builder this target is given, +     * to., +     *, +     * <p>, +     *     Requests that load into this target will throw an {@link java.lang.IllegalArgumentException} if, +     *     {@link com.bumptech.glide.GenericRequestBuilder#override(int, int)} was not called on the request builder., +     * </p>, +     */, +    public SimpleTarget() {, +        this(-1, -1);, +    }, +, +    /**, +        if (width <= 0 || height <= 0) {, +            throw new IllegalArgumentException("Width and height must both be > 0, but given width: " + width + " and", +                    + " height: " + height + ", either provide dimensions in the constructor or call override()");, +        }]
[+++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +        public void update(String key, Boolean value, MessageDigest messageDigest) {, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +        public void update(String key, Boolean value, MessageDigest messageDigest) {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/OptionsTest.java, +package com.bumptech.glide.load;, +, +import com.google.common.testing.EqualsTester;, +, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +public class OptionsTest {, +, +  @Test, +  public void testEquals() {, +    Option<Object> firstOption = Option.memory("firstKey");, +    Object firstValue = new Object();, +    Option<Object> secondOption = Option.memory("secondKey");, +    Object secondValue = new Object();, +    new EqualsTester(), +        .addEqualityGroup(new Options(), new Options()), +        .addEqualityGroup(, +            new Options().set(firstOption, firstValue),, +            new Options().set(firstOption, firstValue), +        ), +        .addEqualityGroup(, +            new Options().set(secondOption, secondValue),, +            new Options().set(secondOption, secondValue), +        ), +        .addEqualityGroup(, +            new Options().set(firstOption, firstValue).set(secondOption, secondValue),, +            new Options().set(firstOption, firstValue).set(secondOption, secondValue), +        ).testEquals();, +  }, +, +}, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +        public void update(String key, Boolean value, MessageDigest messageDigest) {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/OptionsTest.java, +package com.bumptech.glide.load;, +, +import com.google.common.testing.EqualsTester;, +, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +public class OptionsTest {, +, +  @Test, +  public void testEquals() {, +    Option<Object> firstOption = Option.memory("firstKey");, +    Object firstValue = new Object();, +    Option<Object> secondOption = Option.memory("secondKey");, +    Object secondValue = new Object();, +    new EqualsTester(), +        .addEqualityGroup(new Options(), new Options()), +        .addEqualityGroup(, +            new Options().set(firstOption, firstValue),, +            new Options().set(firstOption, firstValue), +        ), +        .addEqualityGroup(, +            new Options().set(secondOption, secondValue),, +            new Options().set(secondOption, secondValue), +        ), +        .addEqualityGroup(, +            new Options().set(firstOption, firstValue).set(secondOption, secondValue),, +            new Options().set(firstOption, firstValue).set(secondOption, secondValue), +        ).testEquals();, +  }, +, +}, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java, +import com.bumptech.glide.load.Option;, +import com.bumptech.glide.load.Options;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +    Options options = new Options();, +          resourceClass, transcodeClass, options);, +, +  @Test, +  public void testDiffersIfOptionsDiffer() throws NoSuchAlgorithmException {, +    EngineKey first = harness.build();, +    harness.options = new Options();, +    harness.options.set(Option.memory("fakeKey"), "someValue");, +    EngineKey second = harness.build();, +    KeyAssertions.assertDifferent(first, second, false /*checkDiskCacheKey*/);, +  }, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +        public void update(String key, Boolean value, MessageDigest messageDigest) {]
[+++ b/.travis.yml, +  - android-16, +  - sys-img-armeabi-v7a-android-16, +    - COMPONENT=instrumentation ANDROID_TARGET=16, +    - COMPONENT=instrumentation ANDROID_TARGET=22, +++ b/.travis.yml, +  - android-16, +  - sys-img-armeabi-v7a-android-16, +    - COMPONENT=instrumentation ANDROID_TARGET=16, +    - COMPONENT=instrumentation ANDROID_TARGET=22, +++ b/scripts/travis_create_emulator.sh, +echo no | android create avd --force -n test -t android-$ANDROID_TARGET --abi armeabi-v7a]
[+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java, +, +      if (currentFrame.dispose == DISPOSAL_BACKGROUND && framePointer == 0) {, +        // TODO: We should check and see if all individual pixels are replaced. If they are, the, +        // first frame isn't actually transparent. For now, it's simpler and safer to assume, +        // drawing a transparent background means the GIF contains transparency., +        isFirstFrameTransparent = true;, +      }, +        (isFirstFrameTransparent != null && isFirstFrameTransparent), +            || (isFirstFrameTransparent == null && isFirstFrame && transparentColorIndex != -1);]
[+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java, +import android.support.v4.app.Fragment;, +  @Deprecated, +  public static GlideRequests with(@NonNull android.app.Fragment arg0) {, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java, +import android.support.v4.app.Fragment;, +  @Deprecated, +  public static GlideRequests with(@NonNull android.app.Fragment arg0) {, +++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java, +import android.support.v4.app.Fragment;, +   * Helper constructor that accepts an {@link android.app.Fragment}., +  @Deprecated, +  public RecyclerViewPreloader(@NonNull android.app.Fragment fragment,, +   * Helper constructor that accepts an {@link Fragment}., +  public RecyclerViewPreloader(@NonNull Fragment fragment,, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java, +import android.support.v4.app.Fragment;, +  @Deprecated, +  public static GlideRequests with(@NonNull android.app.Fragment arg0) {, +++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java, +import android.support.v4.app.Fragment;, +   * Helper constructor that accepts an {@link android.app.Fragment}., +  @Deprecated, +  public RecyclerViewPreloader(@NonNull android.app.Fragment fragment,, +   * Helper constructor that accepts an {@link Fragment}., +  public RecyclerViewPreloader(@NonNull Fragment fragment,, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +   * Begin a load with Glide that will be tied to the given {@link android.app.Fragment}'s lifecycle, +   * and that uses the given {@link android.app.Fragment}'s default options., +   *, +   * @param fragment The fragment to use., +   * @return A RequestManager for the given Fragment that can be used to start a load., +   */, +  @Deprecated, +  @NonNull, +  public static RequestManager with(@NonNull android.app.Fragment fragment) {, +    return getRetriever(fragment.getActivity()).get(fragment);, +  }, +, +  /**, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java, +import android.support.v4.app.Fragment;, +  @Deprecated, +  public static GlideRequests with(@NonNull android.app.Fragment arg0) {, +++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java, +import android.support.v4.app.Fragment;, +   * Helper constructor that accepts an {@link android.app.Fragment}., +  @Deprecated, +  public RecyclerViewPreloader(@NonNull android.app.Fragment fragment,, +   * Helper constructor that accepts an {@link Fragment}., +  public RecyclerViewPreloader(@NonNull Fragment fragment,, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +   * Begin a load with Glide that will be tied to the given {@link android.app.Fragment}'s lifecycle, +   * and that uses the given {@link android.app.Fragment}'s default options., +   *, +   * @param fragment The fragment to use., +   * @return A RequestManager for the given Fragment that can be used to start a load., +   */, +  @Deprecated, +  @NonNull, +  public static RequestManager with(@NonNull android.app.Fragment fragment) {, +    return getRetriever(fragment.getActivity()).get(fragment);, +  }, +, +  /**, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java, +@Deprecated, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java, +import android.support.v4.app.Fragment;, +  @Deprecated, +  public static GlideRequests with(@NonNull android.app.Fragment arg0) {, +++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java, +import android.support.v4.app.Fragment;, +   * Helper constructor that accepts an {@link android.app.Fragment}., +  @Deprecated, +  public RecyclerViewPreloader(@NonNull android.app.Fragment fragment,, +   * Helper constructor that accepts an {@link Fragment}., +  public RecyclerViewPreloader(@NonNull Fragment fragment,, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +   * Begin a load with Glide that will be tied to the given {@link android.app.Fragment}'s lifecycle, +   * and that uses the given {@link android.app.Fragment}'s default options., +   *, +   * @param fragment The fragment to use., +   * @return A RequestManager for the given Fragment that can be used to start a load., +   */, +  @Deprecated, +  @NonNull, +  public static RequestManager with(@NonNull android.app.Fragment fragment) {, +    return getRetriever(fragment.getActivity()).get(fragment);, +  }, +, +  /**, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java, +@Deprecated, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java, +  @Deprecated, +  @Deprecated, +  @Deprecated, +  @Deprecated, +  @Deprecated]
[+++ b/Makefile, +++ b/Makefile, +++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="19" />, +++ b/Makefile, +++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="19" />, +++ b/library/custom_rules.xml, +++ b/Makefile, +++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="19" />, +++ b/library/custom_rules.xml, +++ b/library/src/com/bumptech/glide/Glide.java, +import android.graphics.Bitmap;, +import android.graphics.drawable.Drawable;, +import android.os.ParcelFileDescriptor;, +import android.view.View;, +import com.android.volley.RequestQueue;, +import com.bumptech.glide.loader.bitmap.ImageVideoBitmapLoadFactory;, +import com.bumptech.glide.loader.bitmap.ResourceBitmapLoadFactory;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorFileLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorModelLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorResourceLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorStringLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorUriLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamByteArrayLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamResourceLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamFileLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamModelLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamStringLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamUriLoader;, +import com.bumptech.glide.loader.bitmap.model.GenericLoaderFactory;, +import com.bumptech.glide.loader.bitmap.model.ModelLoader;, +import com.bumptech.glide.loader.bitmap.model.ModelLoaderFactory;, +import com.bumptech.glide.loader.bitmap.transformation.CenterCrop;, +import com.bumptech.glide.loader.bitmap.transformation.FitCenter;, +import com.bumptech.glide.loader.bitmap.transformation.MultiTransformationLoader;, +import com.bumptech.glide.loader.bitmap.transformation.None;, +import com.bumptech.glide.loader.bitmap.transformation.TransformationLoader;, +import com.bumptech.glide.presenter.target.ImageViewTarget;, +import com.bumptech.glide.presenter.target.ViewTarget;, +import com.bumptech.glide.resize.load.BitmapDecoder;, +import com.bumptech.glide.resize.load.VideoBitmapDecoder;, +import java.io.InputStream;, +import java.util.UUID;, + * A singleton to present a simple static interface for Glide {@link Request} and to create and manage an, +    private static Glide GLIDE;, +    private final RequestQueue requestQueue;, +         *     public void onException(Exception e, ModelType model, Target target) {, +    public static Glide get(Context context) {, +        if (GLIDE == null) {, +            GLIDE = new GlideBuilder(context).createGlide();, +        }, +, +    public static boolean isSetup() {, +        return GLIDE != null;, +    public static void setup(GlideBuilder builder) {, +        if (GLIDE != null) {, +            throw new IllegalArgumentException("Glide is already setup, check with isSetup() first");, +        GLIDE = builder.createGlide();, +    Glide(ImageManager imageManager, RequestQueue requestQueue) {, +        this.imageManager = imageManager;, +        this.requestQueue = requestQueue;, +        register(File.class, ParcelFileDescriptor.class, new FileDescriptorFileLoader.Factory());, +        register(File.class, InputStream.class, new StreamFileLoader.Factory());, +        register(Integer.class, ParcelFileDescriptor.class, new FileDescriptorResourceLoader.Factory());, +        register(Integer.class, InputStream.class, new StreamResourceLoader.Factory());, +        register(String.class, ParcelFileDescriptor.class, new FileDescriptorStringLoader.Factory());, +        register(String.class, InputStream.class, new StreamStringLoader.Factory());, +        register(Uri.class, ParcelFileDescriptor.class, new FileDescriptorUriLoader.Factory());, +        register(Uri.class, InputStream.class, new StreamUriLoader.Factory());, +        register(URL.class, InputStream.class, new VolleyUrlLoader.Factory(requestQueue));, +     * Returns the {@link ImageManager} Glide is using to load images., +    public ImageManager getImageManager() {, +     * Returns the {@link RequestQueue} Glide is using to fetch images over http/https., +    public RequestQueue getRequestQueue() {, +        return requestQueue;, +     * models. Typically the {@link ModelRequest#using(StreamModelLoader)} or, +     * {@link ModelRequest#using(FileDescriptorModelLoader)} syntax is preferred because it directly links the model, +     * with the ModelLoader being used to load it., +     *     used for any other model class, {@link ModelLoaderFactory#teardown()}, +     * @see ModelRequest#using(FileDescriptorModelLoader), +     * @see ModelRequest#using(StreamModelLoader), +     *, +     * @param modelClass The model class., +     * @param resourceClass The resource class the model loader will translate the model type into., +     * @param factory The factory to use., +     * @param <T> The type of the model., +     * @param <Y> the type of the resource., +    public <T, Y> void register(Class<T> modelClass, Class<Y> resourceClass, ModelLoaderFactory<T, Y> factory) {, +        ModelLoaderFactory<T, Y> removed = loaderFactory.register(modelClass, resourceClass, factory);, +    @SuppressWarnings("unchecked"), +    private <T, Y> ModelLoaderFactory<T, Y> getFactory(T model, Class<Y> resourceClass) {, +        return loaderFactory.getFactory((Class<T>) model.getClass(), resourceClass);, +    }, +, +     * @param modelClass The class to get a {@link ModelLoader} for, +    public static <T, Y> ModelLoader<T, Y> buildModelLoader(Class<T> modelClass, Class<Y> resourceClass, Context context) {, +        return Glide.get(context).loaderFactory.buildModelLoader(modelClass, resourceClass, context);, +     * A convenience method to build a {@link ModelLoader} for the given model that produces {@link InputStream}s using]
[+++ b/instrumentation/build.gradle, +    annotationProcessor project(":annotation:compiler"), +    compile project(":library"), +, +++ b/instrumentation/build.gradle, +    annotationProcessor project(":annotation:compiler"), +    compile project(":library"), +, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java, +package com.bumptech.glide;, +, +import static com.google.common.truth.Truth.assertThat;, +, +import android.content.Context;, +import android.graphics.Bitmap;, +import android.support.test.InstrumentationRegistry;, +import android.support.test.runner.AndroidJUnit4;, +import com.bumptech.glide.test.BitmapRegressionTester;, +import com.bumptech.glide.test.CanonicalBitmap;, +import com.bumptech.glide.test.GlideApp;, +import com.bumptech.glide.test.RegressionTest;, +import com.bumptech.glide.test.SplitByCpu;, +import com.bumptech.glide.test.SplitBySdk;, +import com.bumptech.glide.test.TearDownGlide;, +import java.util.concurrent.ExecutionException;, +import org.junit.Before;, +import org.junit.Rule;, +import org.junit.Test;, +import org.junit.rules.TestName;, +import org.junit.runner.RunWith;, +, +@RunWith(AndroidJUnit4.class), +@RegressionTest, +@SplitByCpu, +@SplitBySdk({24, 21, 16}), +public class CenterCropRegressionTest {, +  @Rule public TestName testName = new TestName();, +  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();, +  private BitmapRegressionTester bitmapRegressionTester;, +  private Context context;, +  private CanonicalBitmap canonical;, +, +  @Before, +  public void setUp() {, +    context = InstrumentationRegistry.getTargetContext();, +    bitmapRegressionTester = new BitmapRegressionTester(getClass(), testName);, +    canonical = new CanonicalBitmap();, +  }, +, +  @Test, +  public void centerCrop_withSquareSmallerThanImage_returnsSquareImage(), +      throws ExecutionException, InterruptedException {, +    Bitmap result =, +        bitmapRegressionTester.test(, +            GlideApp.with(context), +                .asBitmap(), +                .load(canonical.getBitmap()), +                .centerCrop(), +                .override(50));, +    assertThat(result.getWidth()).isEqualTo(50);, +    assertThat(result.getHeight()).isEqualTo(50);, +  }, +, +  @Test, +  public void centerCrop_withRectangleSmallerThanImage_returnsRectangularImage(), +      throws ExecutionException, InterruptedException {, +     Bitmap result =, +        bitmapRegressionTester.test(, +            GlideApp.with(context), +                .asBitmap(), +                .load(canonical.getBitmap()), +                .centerCrop(), +                .override(60, 70));, +    assertThat(result.getWidth()).isEqualTo(60);, +    assertThat(result.getHeight()).isEqualTo(70);, +  }, +, +  @Test, +  public void centerCrop_withSquareLargerThanImage_returnsUpscaledRectangularImage(), +      throws ExecutionException, InterruptedException {, +    Bitmap result =, +          bitmapRegressionTester.test(, +            GlideApp.with(context), +                .asBitmap(), +                .load(canonical.getBitmap()), +                .centerCrop(), +                .override(canonical.getWidth() * 2));, +    assertThat(result.getWidth()).isEqualTo(canonical.getWidth() * 2);, +    assertThat(result.getHeight()).isEqualTo(canonical.getWidth() * 2);, +  }, +, +  @Test, +  public void centerCrop_withRectangleLargerThanImage_returnsUpscaledRectangularImage(), +      throws ExecutionException, InterruptedException {, +    Bitmap result =, +        bitmapRegressionTester.test(, +            GlideApp.with(context), +                .asBitmap(), +                .load(canonical.getBitmap()), +                .centerCrop()]
[+++ b/build.gradle, +        toolVersion = '6.12.1', +        configFile = rootProject.file('checkstyle.xml'), +    gradleVersion = '2.9', +    distributionUrl = "https://services.gradle.org/distributions/gradle-${gradleVersion}-all.zip", +++ b/build.gradle, +        toolVersion = '6.12.1', +        configFile = rootProject.file('checkstyle.xml'), +    gradleVersion = '2.9', +    distributionUrl = "https://services.gradle.org/distributions/gradle-${gradleVersion}-all.zip", +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, +        toolVersion = '6.12.1', +        configFile = rootProject.file('checkstyle.xml'), +    gradleVersion = '2.9', +    distributionUrl = "https://services.gradle.org/distributions/gradle-${gradleVersion}-all.zip", +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Nov 25 12:48:39 CET 2015, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.9-all.zip, +++ b/build.gradle, +        toolVersion = '6.12.1', +        configFile = rootProject.file('checkstyle.xml'), +    gradleVersion = '2.9', +    distributionUrl = "https://services.gradle.org/distributions/gradle-${gradleVersion}-all.zip", +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Nov 25 12:48:39 CET 2015, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.9-all.zip, +++ b/gradlew, +cd "`dirname \"$PRG\"`/" >/dev/null, +cd "$SAVED" >/dev/null, +    JAVACMD=`cygpath --unix "$JAVACMD"`, +++ b/build.gradle, +        toolVersion = '6.12.1', +        configFile = rootProject.file('checkstyle.xml'), +    gradleVersion = '2.9', +    distributionUrl = "https://services.gradle.org/distributions/gradle-${gradleVersion}-all.zip", +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Nov 25 12:48:39 CET 2015, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.9-all.zip, +++ b/gradlew, +cd "`dirname \"$PRG\"`/" >/dev/null, +cd "$SAVED" >/dev/null, +    JAVACMD=`cygpath --unix "$JAVACMD"`, +++ b/library/build.gradle, +    pmd {, +        toolVersion '5.4.0', +    }, +, +++ b/build.gradle, +        toolVersion = '6.12.1', +        configFile = rootProject.file('checkstyle.xml'), +    gradleVersion = '2.9', +    distributionUrl = "https://services.gradle.org/distributions/gradle-${gradleVersion}-all.zip", +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Nov 25 12:48:39 CET 2015, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.9-all.zip, +++ b/gradlew, +cd "`dirname \"$PRG\"`/" >/dev/null, +cd "$SAVED" >/dev/null, +    JAVACMD=`cygpath --unix "$JAVACMD"`, +++ b/library/build.gradle, +    pmd {, +        toolVersion '5.4.0', +    }, +, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +    if (transformationList.isEmpty()) {, +++ b/build.gradle, +        toolVersion = '6.12.1', +        configFile = rootProject.file('checkstyle.xml'), +    gradleVersion = '2.9', +    distributionUrl = "https://services.gradle.org/distributions/gradle-${gradleVersion}-all.zip", +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Wed Nov 25 12:48:39 CET 2015, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.9-all.zip, +++ b/gradlew, +cd "`dirname \"$PRG\"`/" >/dev/null, +cd "$SAVED" >/dev/null, +    JAVACMD=`cygpath --unix "$JAVACMD"`, +++ b/library/build.gradle, +    pmd {, +        toolVersion '5.4.0', +    }, +, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +    if (transformationList.isEmpty()) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java, +import com.bumptech.glide.util.Util;, +          && Util.bothNullOrEqual(transformation, other.transformation), +          && sourceKey.equals(other.sourceKey), +          && signature.equals(other.signature), +++ b/build.gradle, +        toolVersion = '6.12.1', +        configFile = rootProject.file('checkstyle.xml'), +    gradleVersion = '2.9']
[+++ b/glide/build.gradle, +    } as Javadoc, +    } as Task, +    } as Task, +    jar.dependsOn(project.tasks.build), +++ b/glide/build.gradle, +    } as Javadoc, +    } as Task, +    } as Task, +    jar.dependsOn(project.tasks.build), +++ b/gradle.properties, +# TODO: increase this to 2.0.+ when we compile with Java 7., +++ b/glide/build.gradle, +    } as Javadoc, +    } as Task, +    } as Task, +    jar.dependsOn(project.tasks.build), +++ b/gradle.properties, +# TODO: increase this to 2.0.+ when we compile with Java 7., +++ b/integration/build.gradle, +import com.android.build.gradle.api.BaseVariant, +    android.libraryVariants.all { BaseVariant variant ->, +++ b/glide/build.gradle, +    } as Javadoc, +    } as Task, +    } as Task, +    jar.dependsOn(project.tasks.build), +++ b/gradle.properties, +# TODO: increase this to 2.0.+ when we compile with Java 7., +++ b/integration/build.gradle, +import com.android.build.gradle.api.BaseVariant, +    android.libraryVariants.all { BaseVariant variant ->, +++ b/integration/okhttp/build.gradle, +    buildToolsVersion BUILD_TOOLS_VERSION as String, +        versionCode VERSION_CODE as int, +        versionName VERSION_NAME as String, +++ b/glide/build.gradle, +    } as Javadoc, +    } as Task, +    } as Task, +    jar.dependsOn(project.tasks.build), +++ b/gradle.properties, +# TODO: increase this to 2.0.+ when we compile with Java 7., +++ b/integration/build.gradle, +import com.android.build.gradle.api.BaseVariant, +    android.libraryVariants.all { BaseVariant variant ->, +++ b/integration/okhttp/build.gradle, +    buildToolsVersion BUILD_TOOLS_VERSION as String, +        versionCode VERSION_CODE as int, +        versionName VERSION_NAME as String, +++ b/integration/volley/build.gradle, +    buildToolsVersion BUILD_TOOLS_VERSION as String, +        versionCode VERSION_CODE as int, +        versionName VERSION_NAME as String, +++ b/glide/build.gradle, +    } as Javadoc, +    } as Task, +    } as Task, +    jar.dependsOn(project.tasks.build), +++ b/gradle.properties, +# TODO: increase this to 2.0.+ when we compile with Java 7., +++ b/integration/build.gradle, +import com.android.build.gradle.api.BaseVariant, +    android.libraryVariants.all { BaseVariant variant ->, +++ b/integration/okhttp/build.gradle, +    buildToolsVersion BUILD_TOOLS_VERSION as String, +        versionCode VERSION_CODE as int, +        versionName VERSION_NAME as String, +++ b/integration/volley/build.gradle, +    buildToolsVersion BUILD_TOOLS_VERSION as String, +        versionCode VERSION_CODE as int, +        versionName VERSION_NAME as String, +++ b/library/build.gradle, +    buildToolsVersion BUILD_TOOLS_VERSION as String, +        versionCode VERSION_CODE as int, +        versionName VERSION_NAME as String, +        classpath = files(project.configurations.compile.asPath), +++ b/glide/build.gradle, +    } as Javadoc, +    } as Task, +    } as Task, +    jar.dependsOn(project.tasks.build), +++ b/gradle.properties, +# TODO: increase this to 2.0.+ when we compile with Java 7., +++ b/integration/build.gradle, +import com.android.build.gradle.api.BaseVariant, +    android.libraryVariants.all { BaseVariant variant ->, +++ b/integration/okhttp/build.gradle, +    buildToolsVersion BUILD_TOOLS_VERSION as String, +        versionCode VERSION_CODE as int, +        versionName VERSION_NAME as String, +++ b/integration/volley/build.gradle, +    buildToolsVersion BUILD_TOOLS_VERSION as String, +        versionCode VERSION_CODE as int, +        versionName VERSION_NAME as String, +++ b/library/build.gradle, +    buildToolsVersion BUILD_TOOLS_VERSION as String, +        versionCode VERSION_CODE as int, +        versionName VERSION_NAME as String, +        classpath = files(project.configurations.compile.asPath)]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java, +import static org.mockito.Matchers.anyLong;, +import static org.mockito.Mockito.never;, +, +    @Test(expected = IllegalArgumentException.class), +    public void testThrowsExceptionIfInitializedWithNegativeFrame() {, +        new VideoBitmapDecoder(-1);, +    }, +, +    @Test, +    public void testSpecifiesThumbnailFrameIfInitializedWithFrameNumber() throws IOException {, +        int frame = 5;, +        decoder = new VideoBitmapDecoder(new VideoBitmapDecoder.MediaMetadataRetrieverFactory()  {, +          @Override, +          public MediaMetadataRetriever build() {, +            return factory.build();, +          }, +        }, frame);, +, +        decoder.decode(resource, bitmapPool, 100, 100, decodeFormat);, +, +        verify(retriever).getFrameAtTime(5);, +        verify(retriever, never()).getFrameAtTime();, +    }, +, +    @Test, +    public void testDoesNotSpecifyThumbnailFrameIfInitializedWithoutFrameNumber(), +        throws IOException {, +      decoder = new VideoBitmapDecoder(new VideoBitmapDecoder.MediaMetadataRetrieverFactory()  {, +        @Override, +        public MediaMetadataRetriever build() {, +          return factory.build();, +        }, +      });, +, +      decoder.decode(resource, bitmapPool, 100, 100, decodeFormat);, +, +      verify(retriever).getFrameAtTime();, +      verify(retriever, never()).getFrameAtTime(anyLong());, +    }, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoderTest.java, +import static org.mockito.Matchers.anyLong;, +import static org.mockito.Mockito.never;, +, +    @Test(expected = IllegalArgumentException.class), +    public void testThrowsExceptionIfInitializedWithNegativeFrame() {, +        new VideoBitmapDecoder(-1);, +    }, +, +    @Test, +    public void testSpecifiesThumbnailFrameIfInitializedWithFrameNumber() throws IOException {, +        int frame = 5;, +        decoder = new VideoBitmapDecoder(new VideoBitmapDecoder.MediaMetadataRetrieverFactory()  {, +          @Override, +          public MediaMetadataRetriever build() {, +            return factory.build();, +          }, +        }, frame);, +, +        decoder.decode(resource, bitmapPool, 100, 100, decodeFormat);, +, +        verify(retriever).getFrameAtTime(5);, +        verify(retriever, never()).getFrameAtTime();, +    }, +, +    @Test, +    public void testDoesNotSpecifyThumbnailFrameIfInitializedWithoutFrameNumber(), +        throws IOException {, +      decoder = new VideoBitmapDecoder(new VideoBitmapDecoder.MediaMetadataRetrieverFactory()  {, +        @Override, +        public MediaMetadataRetriever build() {, +          return factory.build();, +        }, +      });, +, +      decoder.decode(resource, bitmapPool, 100, 100, decodeFormat);, +, +      verify(retriever).getFrameAtTime();, +      verify(retriever, never()).getFrameAtTime(anyLong());, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java, +    private static final int NO_FRAME = -1;, +    private int frame;, +        this(DEFAULT_FACTORY, NO_FRAME);, +    }, +, +    public VideoBitmapDecoder(int frame) {, +      this(DEFAULT_FACTORY, checkValidFrame(frame));, +      this(factory, NO_FRAME);, +    }, +, +    VideoBitmapDecoder(MediaMetadataRetrieverFactory factory, int frame) {, +        this.frame = frame;, +        Bitmap result;, +        if (frame >= 0) {, +          result = mediaMetadataRetriever.getFrameAtTime(frame);, +        } else {, +          result = mediaMetadataRetriever.getFrameAtTime();, +        }, +]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java, +   * and height. To avoid upscaling, use {@link #AT_LEAST} or {@link #AT_MOST}., +  public static final DownsampleStrategy CENTER_INSIDE = new CenterInside();, +   * and height. To avoid upscaling, use {@link #AT_LEAST} or {@link #AT_MOST}., +  private static class CenterInside extends DownsampleStrategy {, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java, +   * and height. To avoid upscaling, use {@link #AT_LEAST} or {@link #AT_MOST}., +  public static final DownsampleStrategy CENTER_INSIDE = new CenterInside();, +   * and height. To avoid upscaling, use {@link #AT_LEAST} or {@link #AT_MOST}., +  private static class CenterInside extends DownsampleStrategy {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java, +   * and height. To avoid upscaling, use {@link #AT_LEAST} or {@link #AT_MOST}., +  public static final DownsampleStrategy CENTER_INSIDE = new CenterInside();, +   * and height. To avoid upscaling, use {@link #AT_LEAST} or {@link #AT_MOST}., +  private static class CenterInside extends DownsampleStrategy {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java, +    Canvas canvas = new Canvas(result);, +    canvas.drawBitmap(inBitmap, m, DEFAULT_PAINT);, +    clear(canvas);, +    Canvas canvas = new Canvas(toReuse);, +    canvas.drawBitmap(inBitmap, matrix, DEFAULT_PAINT);, +    clear(canvas);, +    final Canvas canvas = new Canvas(result);, +    canvas.drawBitmap(inBitmap, matrix, DEFAULT_PAINT);, +    clear(canvas);, +, +, +, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java, +   * and height. To avoid upscaling, use {@link #AT_LEAST} or {@link #AT_MOST}., +  public static final DownsampleStrategy CENTER_INSIDE = new CenterInside();, +   * and height. To avoid upscaling, use {@link #AT_LEAST} or {@link #AT_MOST}., +  private static class CenterInside extends DownsampleStrategy {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java, +    Canvas canvas = new Canvas(result);, +    canvas.drawBitmap(inBitmap, m, DEFAULT_PAINT);, +    clear(canvas);, +    Canvas canvas = new Canvas(toReuse);, +    canvas.drawBitmap(inBitmap, matrix, DEFAULT_PAINT);, +    clear(canvas);, +    final Canvas canvas = new Canvas(result);, +    canvas.drawBitmap(inBitmap, matrix, DEFAULT_PAINT);, +    clear(canvas);, +, +, +, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +    return optionalTransform(context, DownsampleStrategy.CENTER_INSIDE, new FitCenter(context));, +    return transform(context, DownsampleStrategy.CENTER_INSIDE, new FitCenter(context));, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java, +   * and height. To avoid upscaling, use {@link #AT_LEAST} or {@link #AT_MOST}., +  public static final DownsampleStrategy CENTER_INSIDE = new CenterInside();, +   * and height. To avoid upscaling, use {@link #AT_LEAST} or {@link #AT_MOST}., +  private static class CenterInside extends DownsampleStrategy {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java, +    Canvas canvas = new Canvas(result);, +    canvas.drawBitmap(inBitmap, m, DEFAULT_PAINT);, +    clear(canvas);, +    Canvas canvas = new Canvas(toReuse);, +    canvas.drawBitmap(inBitmap, matrix, DEFAULT_PAINT);, +    clear(canvas);, +    final Canvas canvas = new Canvas(result);, +    canvas.drawBitmap(inBitmap, matrix, DEFAULT_PAINT);, +    clear(canvas);, +, +, +, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +    return optionalTransform(context, DownsampleStrategy.CENTER_INSIDE, new FitCenter(context));, +    return transform(context, DownsampleStrategy.CENTER_INSIDE, new FitCenter(context));, +++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java, +   * and height. To avoid upscaling, use {@link #AT_LEAST} or {@link #AT_MOST}., +  public static final DownsampleStrategy CENTER_INSIDE = new CenterInside();, +   * and height. To avoid upscaling, use {@link #AT_LEAST} or {@link #AT_MOST}., +  private static class CenterInside extends DownsampleStrategy {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java]
[+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java, +import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;, +        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));, +        .isEqualTo(, +            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));, +        .isEqualTo(, +            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));, +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java, +import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;, +        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));, +        .isEqualTo(, +            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));, +        .isEqualTo(, +            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));, +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithMultipleExcludesTest.java, +import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;, +        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));, +        .isEqualTo(, +            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));, +        .isEqualTo(, +            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));, +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java, +import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;, +        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));, +        .isEqualTo(, +            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));, +        .isEqualTo(, +            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));, +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithMultipleExcludesTest.java, +import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;, +        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));, +        .isEqualTo(, +            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));, +        .isEqualTo(, +            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));, +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java, +import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;, +        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));, +        .isEqualTo(, +            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));, +        .isEqualTo(, +            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(libraryResource(expectedClassName + ".java").getCharContent(true)));, +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java, +import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;, +        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));, +        .isEqualTo(, +            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));, +        .isEqualTo(, +            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));, +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithMultipleExcludesTest.java, +import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;, +        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));, +        .isEqualTo(, +            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));, +        .isEqualTo(, +            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));, +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java, +import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;, +        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));, +        .isEqualTo(, +            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));, +        .isEqualTo(, +            asUnixChars(appResource("GeneratedRequestManagerFactory.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(libraryResource(expectedClassName + ".java").getCharContent(true)));, +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppGlideModuleTest.java, +import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;, +        .isEqualTo(asUnixChars(forResource("GlideOptions.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(forResource("GlideRequest.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(forResource("GlideRequests.java").getCharContent(true)));, +        .isEqualTo(asUnixChars(forResource("GlideApp.java").getCharContent(true)));, +        .isEqualTo(, +            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +    // Allow the request to be run and GCed without being cleared., +    concurrency.loadOnOtherThread(new Runnable() {, +      @Override, +      public void run() {, +      }, +    });, +    // Wait for the weak reference to be cleared and the request to be removed from active, +    // resources., +    for (int j = 0; j < 100; j++) {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +    // Allow the request to be run and GCed without being cleared., +    concurrency.loadOnOtherThread(new Runnable() {, +      @Override, +      public void run() {, +      }, +    });, +    // Wait for the weak reference to be cleared and the request to be removed from active, +    // resources., +    for (int j = 0; j < 100; j++) {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java, +import java.util.concurrent.atomic.AtomicBoolean;, +  public void loadOnOtherThread(final Runnable runnable) {, +    final AtomicBoolean isDone = new AtomicBoolean();, +    Thread thread = new Thread(new Runnable() {, +      @Override, +      public void run() {, +        runnable.run();, +        isDone.set(true);, +      }, +    });, +    thread.start();, +    try {, +      thread.join(TIMEOUT_MS, /*nanos=*/0);, +    } catch (InterruptedException e) {, +      throw new RuntimeException(e);, +    }, +    if (!isDone.get()) {, +      throw new IllegalStateException("Failed to finish job in available time");, +    }, +  }, +]
[+++ b/gradle.properties, +VERSION_NAME=4.0.0-RC1]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +    public void testGetOpacityReturnsTransparent() {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +    public void testGetOpacityReturnsTransparent() {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java, +        return bitmapPool.getDirty(width, height, config);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +    public void testGetOpacityReturnsTransparent() {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java, +        return bitmapPool.getDirty(width, height, config);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +        // We can't tell, so default to transparent to be safe., +        return PixelFormat.TRANSPARENT;, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +    public void testGetOpacityReturnsTransparent() {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java, +        return bitmapPool.getDirty(width, height, config);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +        // We can't tell, so default to transparent to be safe., +        return PixelFormat.TRANSPARENT;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameManager.java, +import com.bumptech.glide.util.Util;, +        this.totalFrameSize = Util.getBitmapByteSize(frameWidth, frameHeight, Bitmap.Config.ARGB_8888);, +                .diskCacheStrategy(DiskCacheStrategy.NONE), +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +    public void testGetOpacityReturnsTransparent() {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java, +        return bitmapPool.getDirty(width, height, config);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +        // We can't tell, so default to transparent to be safe., +        return PixelFormat.TRANSPARENT;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameManager.java, +import com.bumptech.glide.util.Util;, +        this.totalFrameSize = Util.getBitmapByteSize(frameWidth, frameHeight, Bitmap.Config.ARGB_8888);, +                .diskCacheStrategy(DiskCacheStrategy.NONE), +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, +import android.annotation.TargetApi;, +import android.os.Build;, +, +        // We can't tell if a gif has transparency to decode a partial frame on top of a previous frame, or if the final, +        // frame will actually have transparent pixels, so we must always use a format that supports transparency., +        if (config == Bitmap.Config.RGB_565 || config == Bitmap.Config.ARGB_4444) {, +            return Bitmap.Config.ARGB_4444;, +        setAlpha(result);, +, +    @TargetApi(12), +    private static void setAlpha(Bitmap bitmap) {, +        if (Build.VERSION.SDK_INT >= 12) {, +            bitmap.setHasAlpha(true);, +        }, +    }, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +    public void testGetOpacityReturnsTransparent() {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java, +        return bitmapPool.getDirty(width, height, config);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +        // We can't tell, so default to transparent to be safe., +        return PixelFormat.TRANSPARENT;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameManager.java, +import com.bumptech.glide.util.Util;, +        this.totalFrameSize = Util.getBitmapByteSize(frameWidth, frameHeight, Bitmap.Config.ARGB_8888);, +                .diskCacheStrategy(DiskCacheStrategy.NONE), +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, +import android.annotation.TargetApi;, +import android.os.Build;, +, +        // We can't tell if a gif has transparency to decode a partial frame on top of a previous frame, or if the final, +        // frame will actually have transparent pixels, so we must always use a format that supports transparency., +        if (config == Bitmap.Config.RGB_565 || config == Bitmap.Config.ARGB_4444) {, +            return Bitmap.Config.ARGB_4444;, +        setAlpha(result);, +, +    @TargetApi(12), +    private static void setAlpha(Bitmap bitmap) {, +        if (Build.VERSION.SDK_INT >= 12) {, +            bitmap.setHasAlpha(true);, +        }, +    }, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +    public void testGetOpacityReturnsTransparent() {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java, +        return bitmapPool.getDirty(width, height, config);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +        // We can't tell, so default to transparent to be safe., +        return PixelFormat.TRANSPARENT;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameManager.java, +import com.bumptech.glide.util.Util;, +        this.totalFrameSize = Util.getBitmapByteSize(frameWidth, frameHeight, Bitmap.Config.ARGB_8888);, +                .diskCacheStrategy(DiskCacheStrategy.NONE), +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, +import android.annotation.TargetApi;, +import android.os.Build;, +, +        // We can't tell if a gif has transparency to decode a partial frame on top of a previous frame, or if the final, +        // frame will actually have transparent pixels, so we must always use a format that supports transparency., +        if (config == Bitmap.Config.RGB_565 || config == Bitmap.Config.ARGB_4444) {, +            return Bitmap.Config.ARGB_4444;, +        setAlpha(result);, +]
[+++ b/gradle.properties, +VERSION_NAME=4.6.0-SNAPSHOT, +SUPPORT_V4_VERSION=21.0.3, +SUPPORT_V7_VERSION=21.0.3, +VOLLEY_VERSION=1.0.10, +ROBOLECTRIC_GRADLE_VERSION=0.14.1, +MOCKWEBSERVER_VERSION=2.2.0, +FINDBUGS_VERSION=3.0.0, +JACOCO_VERSION=0.7.1.201405082137, +, +COMPILE_SDK_VERSION=21, +BUILD_TOOLS_VERSION=21.1.2, +TARGET_SDK_VERSION=21, +++ b/gradle.properties, +VERSION_NAME=4.6.0-SNAPSHOT, +SUPPORT_V4_VERSION=21.0.3, +SUPPORT_V7_VERSION=21.0.3, +VOLLEY_VERSION=1.0.10, +ROBOLECTRIC_GRADLE_VERSION=0.14.1, +MOCKWEBSERVER_VERSION=2.2.0, +FINDBUGS_VERSION=3.0.0, +JACOCO_VERSION=0.7.1.201405082137, +, +COMPILE_SDK_VERSION=21, +BUILD_TOOLS_VERSION=21.1.2, +TARGET_SDK_VERSION=21, +++ b/integration/okhttp/build.gradle, +, +    compileOptions {, +        sourceCompatibility JavaVersion.VERSION_1_7, +        targetCompatibility JavaVersion.VERSION_1_7, +    }, +++ b/gradle.properties, +VERSION_NAME=4.6.0-SNAPSHOT, +SUPPORT_V4_VERSION=21.0.3, +SUPPORT_V7_VERSION=21.0.3, +VOLLEY_VERSION=1.0.10, +ROBOLECTRIC_GRADLE_VERSION=0.14.1, +MOCKWEBSERVER_VERSION=2.2.0, +FINDBUGS_VERSION=3.0.0, +JACOCO_VERSION=0.7.1.201405082137, +, +COMPILE_SDK_VERSION=21, +BUILD_TOOLS_VERSION=21.1.2, +TARGET_SDK_VERSION=21, +++ b/integration/okhttp/build.gradle, +, +    compileOptions {, +        sourceCompatibility JavaVersion.VERSION_1_7, +        targetCompatibility JavaVersion.VERSION_1_7, +    }, +++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="jdk" jdkName="Android API 21 Platform" jdkType="Android SDK" />, +++ b/gradle.properties, +VERSION_NAME=4.6.0-SNAPSHOT, +SUPPORT_V4_VERSION=21.0.3, +SUPPORT_V7_VERSION=21.0.3, +VOLLEY_VERSION=1.0.10, +ROBOLECTRIC_GRADLE_VERSION=0.14.1, +MOCKWEBSERVER_VERSION=2.2.0, +FINDBUGS_VERSION=3.0.0, +JACOCO_VERSION=0.7.1.201405082137, +, +COMPILE_SDK_VERSION=21, +BUILD_TOOLS_VERSION=21.1.2, +TARGET_SDK_VERSION=21, +++ b/integration/okhttp/build.gradle, +, +    compileOptions {, +        sourceCompatibility JavaVersion.VERSION_1_7, +        targetCompatibility JavaVersion.VERSION_1_7, +    }, +++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="jdk" jdkName="Android API 21 Platform" jdkType="Android SDK" />, +++ b/integration/volley/build.gradle, +, +    compileOptions {, +        sourceCompatibility JavaVersion.VERSION_1_7, +        targetCompatibility JavaVersion.VERSION_1_7, +    }, +++ b/gradle.properties, +VERSION_NAME=4.6.0-SNAPSHOT, +SUPPORT_V4_VERSION=21.0.3, +SUPPORT_V7_VERSION=21.0.3, +VOLLEY_VERSION=1.0.10, +ROBOLECTRIC_GRADLE_VERSION=0.14.1, +MOCKWEBSERVER_VERSION=2.2.0, +FINDBUGS_VERSION=3.0.0, +JACOCO_VERSION=0.7.1.201405082137, +, +COMPILE_SDK_VERSION=21, +BUILD_TOOLS_VERSION=21.1.2, +TARGET_SDK_VERSION=21, +++ b/integration/okhttp/build.gradle, +, +    compileOptions {, +        sourceCompatibility JavaVersion.VERSION_1_7, +        targetCompatibility JavaVersion.VERSION_1_7, +    }, +++ b/integration/okhttp/okhttp.iml]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        // Compilation with Gradle requires the type to be specified for UnitModelLoader here., +        .append(GifDecoder.class, GifDecoder.class, new UnitModelLoader.Factory<GifDecoder>()), +        // Compilation with Gradle requires the type to be specified for UnitModelLoader here., +        .append(File.class, File.class, new UnitModelLoader.Factory<File>()), +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        // Compilation with Gradle requires the type to be specified for UnitModelLoader here., +        .append(GifDecoder.class, GifDecoder.class, new UnitModelLoader.Factory<GifDecoder>()), +        // Compilation with Gradle requires the type to be specified for UnitModelLoader here., +        .append(File.class, File.class, new UnitModelLoader.Factory<File>()), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +  // Final to avoid a PMD error., +  public final Registry setResourceDecoderBucketPriorityList(List<String> buckets) {]
[+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +          && (requestListener != null, +          ? that.requestListener != null : that.requestListener == null);]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/SimpleResourceTest.java, +package com.bumptech.glide.load.resource;, +, +import org.junit.Before;, +import org.junit.Test;, +, +import static org.junit.Assert.assertEquals;, +, +public class SimpleResourceTest {, +    private Anything object;, +    private SimpleResource resource;, +, +    @Before, +    public void setUp() {, +        object = new Anything();, +        resource = new SimpleResource(object);, +    }, +, +    @Test, +    public void testReturnsGivenObject() {, +        assertEquals(object, resource.get());, +    }, +, +    @Test, +    public void testReturnsGivenObjectMultipleTimes() {, +        assertEquals(object, resource.get());, +        assertEquals(object, resource.get());, +        assertEquals(object, resource.get());, +    }, +, +    private static class Anything { }, +}, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/SimpleResourceTest.java, +package com.bumptech.glide.load.resource;, +, +import org.junit.Before;, +import org.junit.Test;, +, +import static org.junit.Assert.assertEquals;, +, +public class SimpleResourceTest {, +    private Anything object;, +    private SimpleResource resource;, +, +    @Before, +    public void setUp() {, +        object = new Anything();, +        resource = new SimpleResource(object);, +    }, +, +    @Test, +    public void testReturnsGivenObject() {, +        assertEquals(object, resource.get());, +    }, +, +    @Test, +    public void testReturnsGivenObjectMultipleTimes() {, +        assertEquals(object, resource.get());, +        assertEquals(object, resource.get());, +        assertEquals(object, resource.get());, +    }, +, +    private static class Anything { }, +}, +++ b/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java, +package com.bumptech.glide.load.resource;, +, +import com.bumptech.glide.load.engine.Resource;, +, +/**, + * Simple wrapper for an arbitrary object which helps to satisfy some of the glide engine's contracts., + * <b>Suggested usages only include resource object which don't have size and cannot be recycled/closed.</b>, + *, + * @param <T> type of the wrapped resource, + */, +// TODO: there isn't much point in caching these..., +public class SimpleResource<T> implements Resource<T> {, +    protected final T data;, +, +    public SimpleResource(T data) {, +        this.data = data;, +    }, +, +    @Override, +    public final T get() {, +        return data;, +    }, +, +    @Override, +    public final int getSize() {, +        return 1;, +    }, +, +    @Override, +    public void recycle() {, +        // no op, +    }, +}, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/SimpleResourceTest.java, +package com.bumptech.glide.load.resource;]
[+++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java, +  ImageType getType(InputStream is) throws IOException;, +  ImageType getType(ByteBuffer byteBuffer) throws IOException;, +  int getOrientation(InputStream is, ArrayPool byteArrayPool) throws IOException;, +  int getOrientation(ByteBuffer byteBuffer, ArrayPool byteArrayPool) throws IOException;, +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java, +  ImageType getType(InputStream is) throws IOException;, +  ImageType getType(ByteBuffer byteBuffer) throws IOException;, +  int getOrientation(InputStream is, ArrayPool byteArrayPool) throws IOException;, +  int getOrientation(ByteBuffer byteBuffer, ArrayPool byteArrayPool) throws IOException;, +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java, +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java, +  ImageType getType(InputStream is) throws IOException;, +  ImageType getType(ByteBuffer byteBuffer) throws IOException;, +  int getOrientation(InputStream is, ArrayPool byteArrayPool) throws IOException;, +  int getOrientation(ByteBuffer byteBuffer, ArrayPool byteArrayPool) throws IOException;, +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private final class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {, +    @Synthetic, +    DecodeCallback(DataSource dataSource) {, +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java, +  ImageType getType(InputStream is) throws IOException;, +  ImageType getType(ByteBuffer byteBuffer) throws IOException;, +  int getOrientation(InputStream is, ArrayPool byteArrayPool) throws IOException;, +  int getOrientation(ByteBuffer byteBuffer, ArrayPool byteArrayPool) throws IOException;, +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private final class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {, +    @Synthetic, +    DecodeCallback(DataSource dataSource) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java, +   * Called on a background thread so the {@link Resource} can do some eager initialization., +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java, +  ImageType getType(InputStream is) throws IOException;, +  ImageType getType(ByteBuffer byteBuffer) throws IOException;, +  int getOrientation(InputStream is, ArrayPool byteArrayPool) throws IOException;, +  int getOrientation(ByteBuffer byteBuffer, ArrayPool byteArrayPool) throws IOException;, +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private final class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {, +    @Synthetic, +    DecodeCallback(DataSource dataSource) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java, +   * Called on a background thread so the {@link Resource} can do some eager initialization., +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +      hasAlpha = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool).hasAlpha();, +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java, +  ImageType getType(InputStream is) throws IOException;, +  ImageType getType(ByteBuffer byteBuffer) throws IOException;, +  int getOrientation(InputStream is, ArrayPool byteArrayPool) throws IOException;, +  int getOrientation(ByteBuffer byteBuffer, ArrayPool byteArrayPool) throws IOException;, +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private final class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {, +    @Synthetic, +    DecodeCallback(DataSource dataSource) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java, +   * Called on a background thread so the {@link Resource} can do some eager initialization., +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +      hasAlpha = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool).hasAlpha();, +++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java, +      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,, +          ArrayPool byteArrayPool) throws IOException {, +  public void getOrientation_withExifSegmentAndPreambleBetweenLengthAndExpected_returnsUnknown(), +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java, +  ImageType getType(InputStream is) throws IOException;, +  ImageType getType(ByteBuffer byteBuffer) throws IOException;, +  int getOrientation(InputStream is, ArrayPool byteArrayPool) throws IOException;, +  int getOrientation(ByteBuffer byteBuffer, ArrayPool byteArrayPool) throws IOException;, +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private final class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {, +    @Synthetic, +    DecodeCallback(DataSource dataSource) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java, +   * Called on a background thread so the {@link Resource} can do some eager initialization., +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +      hasAlpha = ImageHeaderParserUtils.getType(parsers, is, byteArrayPool).hasAlpha();, +++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DefaultImageHeaderParserTest.java, +      public void run(DefaultImageHeaderParser parser, ByteBuffer byteBuffer,, +          ArrayPool byteArrayPool) throws IOException {, +  public void getOrientation_withExifSegmentAndPreambleBetweenLengthAndExpected_returnsUnknown(), +++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java]
[+++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java, +import android.content.Context;, +import android.graphics.Point;, +import android.support.annotation.VisibleForTesting;, +import android.view.Display;, +import android.view.WindowManager;, +    this(view, false /*waitForLayout*/);, +  }, +, +  public ViewTarget(T view, boolean waitForLayout) {, +    sizeDeterminer = new SizeDeterminer(view, waitForLayout);, +  @VisibleForTesting, +  static final class SizeDeterminer {, +    @VisibleForTesting, +    @Nullable, +    static Integer maxDisplayLength;, +    private final boolean waitForLayout;, +    SizeDeterminer(View view, boolean waitForLayout) {, +      this.waitForLayout = waitForLayout;, +    }, +, +    // Use the maximum to avoid depending on the device's current orientation., +    private static int getMaxDisplayLength(Context context) {, +      if (maxDisplayLength == null) {, +        WindowManager windowManager =, +            (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);, +        Display display = windowManager.getDefaultDisplay();, +        Point displayDimensions = new Point();, +        display.getSize(displayDimensions);, +        maxDisplayLength = Math.max(displayDimensions.x, displayDimensions.y);, +      }, +      return maxDisplayLength;, +    private boolean isViewStateAndSizeValid(int width, int height) {, +      return isDimensionValid(width) && isDimensionValid(height);, +      if (waitForLayout && view.isLayoutRequested()) {, +, +      // We consider the View state as valid if the View has non-null layout params and a non-zero, +      // layout params width and height. This is imperfect. We're making an assumption that View, +      // parents will obey their child's layout parameters, which isn't always the case., +      int adjustedParamSize = paramSize - paddingSize;, +      if (adjustedParamSize > 0) {, +        return adjustedParamSize;, +      // We also consider the View state valid if the View has a non-zero width and height. This, +      // means that the View has gone through at least one layout pass. It does not mean the Views, +      // width and height are from the current layout pass. For example, if a View is re-used in, +      // RecyclerView or ListView, this width/height may be from an old position. In some cases, +      // the dimensions of the View at the old position may be different than the dimensions of the, +      // View in the new position because the LayoutManager/ViewParent can arbitrarily decide to, +      // change them. Nevertheless, in most cases this should be a reasonable choice., +      int adjustedViewSize = viewSize - paddingSize;, +      if (adjustedViewSize > 0) {, +        return adjustedViewSize;, +      }, +, +      // Finally we consider the view valid if the layout parameter size is set to wrap_content., +      // It's difficult for Glide to figure out what to do here. Although Target.SIZE_ORIGINAL is a, +      // coherent choice, it's extremely dangerous and therefore a bad default. If users want the, +      // original image, they can always use .override(Target.SIZE_ORIGINAL). Since wrap_content, +      // may never resolve to a real size unless we load something, we aim for a square whose length, +      // is the largest screen size. That way we're loading something and that something has some, +      // hope of being downsampled to a size that the device can support. We also log a warning that, +      // tries to explain what Glide is doing and why some alternatives are preferable., +      if (paramSize == LayoutParams.WRAP_CONTENT) {, +        if (Log.isLoggable(TAG, Log.INFO)) {, +          Log.i(TAG, "Glide treats LayoutParams.WRAP_CONTENT as a request for an image the size of", +              + " this device's screen dimensions. If you want to load the original image and are", +              + " ok with the corresponding memory cost and OOMs (depending on the input size), use", +              + " .override(Target.SIZE_ORIGINAL). Otherwise, use LayoutParams.MATCH_PARENT, set", +              + " layout_width and layout_height to fixed dimension, or use .override() with fixed", +              + " dimensions.");, +        }, +        return getMaxDisplayLength(view.getContext());, +      }, +, +      // If the layout parameters are < padding, the view size is < padding, or the layout, +      // parameters are set to match_parent or wrap_content and no layout has occurred, we should, +      // wait for layout and repeat., +      return PENDING_SIZE;, +    }, +, +    private boolean isDimensionValid(int size) {, +      return size > 0 || size == SIZE_ORIGINAL;, +    }, +, +    private static final class SizeDeterminerLayoutListener, +        implements ViewTreeObserver.OnPreDrawListener {, +++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java, +import android.content.Context;, +import android.graphics.Point;, +import android.support.annotation.VisibleForTesting;, +import android.view.Display;, +import android.view.WindowManager;, +    this(view, false /*waitForLayout*/);, +  }, +, +  public ViewTarget(T view, boolean waitForLayout) {, +    sizeDeterminer = new SizeDeterminer(view, waitForLayout);, +  @VisibleForTesting, +  static final class SizeDeterminer {, +    @VisibleForTesting]
[+++ b/library/custom_rules.xml, +            basedir="bin/classes", +            excludes="com/bumptech/glide/volley/">, +++ b/library/custom_rules.xml, +            basedir="bin/classes", +            excludes="com/bumptech/glide/volley/">, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.volley.VolleyUrlLoader;, +    protected Glide() {, +        loaderFactory.register(File.class, new FileLoader.Factory());, +        loaderFactory.register(Integer.class, new ResourceLoader.Factory());, +        loaderFactory.register(String.class, new StringLoader.Factory());, +        loaderFactory.register(Uri.class, new UriLoader.Factory());, +        try {, +            Class.forName("com.bumptech.glide.volley.VolleyUrlLoader$Factory");, +            loaderFactory.register(URL.class, new VolleyUrlLoader.Factory());, +        } catch (ClassNotFoundException e) {, +            Log.d("Volley not found, missing url loader");, +            loaderFactory.register(URL.class, new ModelLoaderFactory<URL>() {, +                ModelLoader<URL> errorUrlLoader = new ModelLoader<URL>() {, +                    @Override, +                    public StreamLoader getStreamLoader(URL model, int width, int height) {, +                        throw new IllegalArgumentException("No ModelLoaderFactory for urls registered with Glide");, +                    @Override, +                    public String getId(URL model) {, +                        throw new IllegalArgumentException("No ModelLoaderFactory for urls registered with Glide");, +                    }, +                };, +, +                @Override, +                public ModelLoader<URL> build(Context context, GenericLoaderFactory factories) {, +                    return errorUrlLoader;, +                @Override @SuppressWarnings("unchecked"), +                public Class<? extends ModelLoader<URL>> loaderClass() {, +                    return (Class<ModelLoader<URL>>) errorUrlLoader.getClass();, +                @Override, +                public void teardown() {, +                }, +            });, +        }, +    }, +, +, +     *     of {@link com.bumptech.glide.loader.model.UrlModelLoader}, +++ b/library/custom_rules.xml, +            basedir="bin/classes", +            excludes="com/bumptech/glide/volley/">, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.volley.VolleyUrlLoader;, +    protected Glide() {, +        loaderFactory.register(File.class, new FileLoader.Factory());, +        loaderFactory.register(Integer.class, new ResourceLoader.Factory());, +        loaderFactory.register(String.class, new StringLoader.Factory());, +        loaderFactory.register(Uri.class, new UriLoader.Factory());, +        try {, +            Class.forName("com.bumptech.glide.volley.VolleyUrlLoader$Factory");, +            loaderFactory.register(URL.class, new VolleyUrlLoader.Factory());, +        } catch (ClassNotFoundException e) {, +            Log.d("Volley not found, missing url loader");, +            loaderFactory.register(URL.class, new ModelLoaderFactory<URL>() {, +                ModelLoader<URL> errorUrlLoader = new ModelLoader<URL>() {, +                    @Override, +                    public StreamLoader getStreamLoader(URL model, int width, int height) {, +                        throw new IllegalArgumentException("No ModelLoaderFactory for urls registered with Glide");, +                    @Override, +                    public String getId(URL model) {, +                        throw new IllegalArgumentException("No ModelLoaderFactory for urls registered with Glide");, +                    }, +                };, +, +                @Override, +                public ModelLoader<URL> build(Context context, GenericLoaderFactory factories) {, +                    return errorUrlLoader;, +                @Override @SuppressWarnings("unchecked"), +                public Class<? extends ModelLoader<URL>> loaderClass() {, +                    return (Class<ModelLoader<URL>>) errorUrlLoader.getClass();, +                @Override, +                public void teardown() {, +                }, +            });, +        }, +    }, +, +, +     *     of {@link com.bumptech.glide.loader.model.UrlModelLoader}, +++ /dev/null, +++ b/library/custom_rules.xml, +            basedir="bin/classes", +            excludes="com/bumptech/glide/volley/">, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.volley.VolleyUrlLoader;, +    protected Glide() {, +        loaderFactory.register(File.class, new FileLoader.Factory());, +        loaderFactory.register(Integer.class, new ResourceLoader.Factory());, +        loaderFactory.register(String.class, new StringLoader.Factory());, +        loaderFactory.register(Uri.class, new UriLoader.Factory());, +        try {, +            Class.forName("com.bumptech.glide.volley.VolleyUrlLoader$Factory");, +            loaderFactory.register(URL.class, new VolleyUrlLoader.Factory());, +        } catch (ClassNotFoundException e) {]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java, +     * Requests that we call startNext() again on a Glide owned thread., +     */, +    void reschedule();, +, +    /**, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java, +     * Requests that we call startNext() again on a Glide owned thread., +     */, +    void reschedule();, +, +    /**, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  public void reschedule() {, +    runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;, +    callback.reschedule(this);, +  }, +, +  @Override, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java, +     * Requests that we call startNext() again on a Glide owned thread., +     */, +    void reschedule();, +, +    /**, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  public void reschedule() {, +    runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;, +    callback.reschedule(this);, +  }, +, +  @Override, +++ b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java, +  private Object dataToCache;, +    if (dataToCache != null) {, +      cacheData();, +      dataToCache = null;, +    }, +  private void cacheData() {, +    long startTime = LogTime.getLogTime();, +    try {, +      Encoder<Object> encoder = requestContext.getSourceEncoder(dataToCache);, +      DataCacheWriter<Object> writer =, +          new DataCacheWriter<>(encoder, dataToCache, requestContext.getOptions());, +      Key originalKey = new DataCacheKey(loadData.sourceKey, requestContext.getSignature());, +      diskCache.put(originalKey, writer);, +      if (Logs.isEnabled(Log.VERBOSE)) {, +        Logs.log(Log.VERBOSE, "Finished encoding source to cache", +            + ", key: " + originalKey, +            + ", data: " + dataToCache, +            + ", encoder: " + encoder, +            + ", duration: " + LogTime.getElapsedMillis(startTime));, +      }, +    } finally {, +      loadData.fetcher.cleanup();, +    }, +, +    sourceCacheGenerator =, +        new DataCacheGenerator(Collections.singletonList(loadData.sourceKey), width, height,, +            diskCache, requestContext, this);, +  }, +, +      dataToCache = data;, +      // We might be being called back on someone else's thread. Before doing anything, we should, +      // reschedule to get back onto Glide's thread., +      cb.reschedule();, +  @Override, +  public void reschedule() {, +    // We don't expect this to happen, although if we ever need it to we can delegate to our, +    // callback., +    throw new UnsupportedOperationException();, +  }, +]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/src/com/bumptech/photos/imagemanager/ImageManager.java, +import com.bumptech.photos.imagemanager.cache.LruPhotoCache;, +import com.bumptech.photos.imagemanager.cache.PhotoDiskCache;, +import com.bumptech.photos.imagemanager.cache.SizedBitmapCache;, +    private final ImageResizer resizer;, +        this.resizer = new ImageResizer(bitmapCache);, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/src/com/bumptech/photos/imagemanager/ImageManager.java, +import com.bumptech.photos.imagemanager.cache.LruPhotoCache;, +import com.bumptech.photos.imagemanager.cache.PhotoDiskCache;, +import com.bumptech.photos.imagemanager.cache.SizedBitmapCache;, +    private final ImageResizer resizer;, +        this.resizer = new ImageResizer(bitmapCache);, +++ b/src/com/bumptech/photos/imagemanager/cache/LruPhotoCache.java, +/*, + * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved., + */, +, +package com.bumptech.photos.imagemanager.cache;, +, +import android.app.ActivityManager;, +import android.content.Context;, +import android.graphics.Bitmap;, +import android.support.v4.util.LruCache;, +, +/**, + * Created by IntelliJ IDEA., + * User: sam, + * Date: 2/9/12, + * Time: 5:57 PM, + * To change this template use File | Settings | File Templates., + */, +public class LruPhotoCache{, +    private static final float SIZE_RATIO = 1f/8f;, +    private final PhotoCache photoCache;, +    private PhotoRemovedListener photoRemovedListener;, +, +    public interface PhotoRemovedListener {, +        public void onPhotoRemoved(String key, Bitmap bitmap);, +    }, +, +    /*, +    Can only call after context is created (ie in onCreate or later...), +    */, +    public static int getMaxCacheSize(Context context){, +        final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);, +        return Math.round(SIZE_RATIO * activityManager.getMemoryClass() * 1024 * 1024);, +    }, +, +    private class PhotoCache extends LruCache<String, Bitmap> {, +, +        private PhotoCache(int maxSize) {, +            super(maxSize);, +        }, +, +, +        @Override, +        protected int sizeOf(String key, Bitmap value) {, +            //get the size, getByteCount() is API 12+..., +            return value.getHeight() * value.getRowBytes();, +        }, +, +        @Override, +        protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) {, +            super.entryRemoved(evicted, key, oldValue, newValue);    //To change body of overridden methods use File | Settings | File Templates., +            if (photoRemovedListener != null) {, +                photoRemovedListener.onPhotoRemoved(key, oldValue);, +            }, +        }, +    }, +, +    public LruPhotoCache(int size) {, +        photoCache = new PhotoCache(size);, +    }, +, +    public void setPhotoRemovedListener(PhotoRemovedListener listener) {, +        this.photoRemovedListener = listener;, +    }, +, +    public void put(String key, Bitmap bitmap) {, +        photoCache.put(key, bitmap);, +    }, +, +    public Bitmap get(String key) {, +        return photoCache.get(key);, +    }, +, +    public void remove(String key){, +        photoCache.remove(key);]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +   * <p>Replaces any previous calls to this method or {@link #placeholder(int)}., +   *, +    placeholderId = 0;, +    fields &= ~PLACEHOLDER_ID;, +, +   * <p>Replaces any previous calls to this method or {@link #placeholder(Drawable)}, +   *, +    placeholderDrawable = null;, +    fields &= ~PLACEHOLDER;, +, +   * <p>Replaces any previous calls to this method or {@link #fallback(int)}., +   *, +    fallbackId = 0;, +    fields &= ~FALLBACK_ID;, +, +   * <p>Replaces any previous calls to this method or {@link #fallback(Drawable)}., +   *, +    fallbackDrawable = null;, +    fields &= ~FALLBACK;, +, +   * <p>Replaces any previous calls to this method or {@link #error(int)}, +   *, +    this.errorId = 0;, +    fields &= ~ERROR_ID;, +, +   * <p>Replaces any previous calls to this method or {@link #error(Drawable)}, +   *, +    this.errorPlaceholder = null;, +    fields &= ~ERROR_PLACEHOLDER;, +, +      errorId = 0;, +      fields &= ~ERROR_ID;, +      errorPlaceholder = null;, +      fields &= ~ERROR_PLACEHOLDER;, +      placeholderId = 0;, +      fields &= ~PLACEHOLDER_ID;, +      placeholderDrawable = null;, +      fields &= ~PLACEHOLDER;, +      fallbackId = 0;, +      fields &= ~FALLBACK_ID;, +      fallbackDrawable = null;, +      fields &= ~FALLBACK;, +++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +   * <p>Replaces any previous calls to this method or {@link #placeholder(int)}., +   *, +    placeholderId = 0;, +    fields &= ~PLACEHOLDER_ID;, +, +   * <p>Replaces any previous calls to this method or {@link #placeholder(Drawable)}, +   *, +    placeholderDrawable = null;, +    fields &= ~PLACEHOLDER;, +, +   * <p>Replaces any previous calls to this method or {@link #fallback(int)}., +   *, +    fallbackId = 0;, +    fields &= ~FALLBACK_ID;, +, +   * <p>Replaces any previous calls to this method or {@link #fallback(Drawable)}., +   *, +    fallbackDrawable = null;, +    fields &= ~FALLBACK;, +, +   * <p>Replaces any previous calls to this method or {@link #error(int)}, +   *, +    this.errorId = 0;, +    fields &= ~ERROR_ID;, +, +   * <p>Replaces any previous calls to this method or {@link #error(Drawable)}, +   *, +    this.errorPlaceholder = null;, +    fields &= ~ERROR_PLACEHOLDER;, +, +      errorId = 0;, +      fields &= ~ERROR_ID;, +      errorPlaceholder = null;, +      fields &= ~ERROR_PLACEHOLDER;, +      placeholderId = 0;, +      fields &= ~PLACEHOLDER_ID;, +      placeholderDrawable = null;, +      fields &= ~PLACEHOLDER;, +      fallbackId = 0;, +      fields &= ~FALLBACK_ID;, +      fallbackDrawable = null;, +      fields &= ~FALLBACK;, +++ b/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java, +  public void getPlaceholder_afterSettingPlaceholderId_returnsNul() {, +    assertThat(, +        options, +            .placeholder(new ColorDrawable(Color.RED)), +            .placeholder(android.R.drawable.star_on), +            .getPlaceholderDrawable()), +        .isNull();, +  }, +, +  @Test, +  public void getPlaceholder_afterApplyingOptionsWithPlaceholderId_returnsNull() {, +    RequestOptions toApply = new RequestOptions().placeholder(android.R.drawable.star_on);, +]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +          requestOptions = requestOptions.clone().optionalCenterCrop();, +          requestOptions = requestOptions.clone().optionalCenterInside();, +          requestOptions = requestOptions.clone().optionalFitCenter();, +          requestOptions = requestOptions.clone().optionalCenterInside();]
[+++ b/gradle.properties, +VERSION_NAME=3.4.0-SNAPSHOT, +VERSION_MINOR=4, +VERSION_PATCH=0, +VERSION_CODE=7, +++ b/gradle.properties, +VERSION_NAME=3.4.0-SNAPSHOT, +VERSION_MINOR=4, +VERSION_PATCH=0, +VERSION_CODE=7, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.1.0-SNAPSHOT, +VERSION_MINOR=1, +VERSION_PATCH=0, +VERSION_CODE=3, +++ b/gradle.properties, +VERSION_NAME=3.4.0-SNAPSHOT, +VERSION_MINOR=4, +VERSION_PATCH=0, +VERSION_CODE=7, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.1.0-SNAPSHOT, +VERSION_MINOR=1, +VERSION_PATCH=0, +VERSION_CODE=3, +++ b/integration/volley/gradle.properties, +VERSION_NAME=1.1.0-SNAPSHOT, +VERSION_MINOR=1, +VERSION_PATCH=0, +VERSION_CODE=3]
[+++ b/.gitmodules, +++ b/.gitmodules, +++ /dev/null]
[+++ b/library/src/main/java/com/bumptech/glide/util/Util.java, +   * <p>See #303, #375, #322, #2262., +  @SuppressWarnings("UseBulkOperation"), +    // toArray creates a new ArrayList internally and does not guarantee that the values it contains, +    // are non-null. Collections.addAll in ArrayList uses toArray internally and therefore also, +    // doesn't guarantee that entries are non-null. WeakHashMap's iterator does avoid returning null, +    // and is therefore safe to use. See #322, #2262., +    List<T> result = new ArrayList<>(other.size());, +      if (item != null) {, +    }]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/MultiTransformationTest.java, +import static org.mockito.Mockito.doAnswer;, +import com.bumptech.glide.tests.KeyAssertions;, +import com.bumptech.glide.tests.Util;, +import org.junit.Before;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +import java.security.MessageDigest;, +import java.security.NoSuchAlgorithmException;, +  @Mock Transformation<Object> first;, +  @Mock Transformation<Object> second;, +  @Mock Resource<Object> initial;, +  @Mock Resource<Object> firstTransformed;, +  @Mock Resource<Object> secondTransformed;, +  @Before, +  public void setUp() {, +    MockitoAnnotations.initMocks(this);, +    MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);, +    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(firstTransformed);, +    MultiTransformation<Object> transformation = new MultiTransformation(first);, +    MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);, +    MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);, +    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(firstTransformed);, +    MultiTransformation<Object> transformation = new MultiTransformation<>(first);, +    verify(firstTransformed, never()).recycle();, +    MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);, +, +  @Test, +  public void testEquals() throws NoSuchAlgorithmException {, +    doAnswer(new Util.WriteDigest("first")).when(first), +        .updateDiskCacheKey(any(MessageDigest.class));, +    KeyAssertions.assertSame(new MultiTransformation<>(first), new MultiTransformation<>(first));, +, +    doAnswer(new Util.WriteDigest("second")).when(second), +        .updateDiskCacheKey(any(MessageDigest.class));, +    KeyAssertions.assertDifferent(new MultiTransformation<>(first),, +        new MultiTransformation<>(second));, +  }, +++ b/library/src/androidTest/java/com/bumptech/glide/load/MultiTransformationTest.java, +import static org.mockito.Mockito.doAnswer;, +import com.bumptech.glide.tests.KeyAssertions;, +import com.bumptech.glide.tests.Util;, +import org.junit.Before;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +import java.security.MessageDigest;, +import java.security.NoSuchAlgorithmException;, +  @Mock Transformation<Object> first;, +  @Mock Transformation<Object> second;, +  @Mock Resource<Object> initial;, +  @Mock Resource<Object> firstTransformed;, +  @Mock Resource<Object> secondTransformed;, +  @Before, +  public void setUp() {, +    MockitoAnnotations.initMocks(this);, +    MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);, +    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(firstTransformed);, +    MultiTransformation<Object> transformation = new MultiTransformation(first);, +    MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);, +    MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);, +    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(firstTransformed);, +    MultiTransformation<Object> transformation = new MultiTransformation<>(first);, +    verify(firstTransformed, never()).recycle();, +    MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);, +, +  @Test, +  public void testEquals() throws NoSuchAlgorithmException {, +    doAnswer(new Util.WriteDigest("first")).when(first), +        .updateDiskCacheKey(any(MessageDigest.class));, +    KeyAssertions.assertSame(new MultiTransformation<>(first), new MultiTransformation<>(first));, +, +    doAnswer(new Util.WriteDigest("second")).when(second), +        .updateDiskCacheKey(any(MessageDigest.class));, +    KeyAssertions.assertDifferent(new MultiTransformation<>(first),, +        new MultiTransformation<>(second));, +  }, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java, +import com.bumptech.glide.tests.Util.WriteDigest;, +++ b/library/src/androidTest/java/com/bumptech/glide/load/MultiTransformationTest.java, +import static org.mockito.Mockito.doAnswer;, +import com.bumptech.glide.tests.KeyAssertions;, +import com.bumptech.glide.tests.Util;, +import org.junit.Before;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +import java.security.MessageDigest;, +import java.security.NoSuchAlgorithmException;, +  @Mock Transformation<Object> first;, +  @Mock Transformation<Object> second;, +  @Mock Resource<Object> initial;, +  @Mock Resource<Object> firstTransformed;, +  @Mock Resource<Object> secondTransformed;, +  @Before, +  public void setUp() {, +    MockitoAnnotations.initMocks(this);, +    MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);, +    when(first.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(firstTransformed);, +    MultiTransformation<Object> transformation = new MultiTransformation(first);, +    MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);, +    MultiTransformation<Object> transformation = new MultiTransformation<>(first, second);]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +        responseBody = response.body();, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +        responseBody = response.body();, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +        responseBody = response.body();]
[+++ b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java, +import com.bumptech.glide.request.transition.TransitionFactory;, +import com.bumptech.glide.request.transition.ViewPropertyTransition;, +, +  /**, +   * Removes any existing animation put on the builder., +   *, +   * @see GenericTransitionOptions#dontTransition(), +   */, +, +  /**, +   * Returns a typed {@link GenericTransitionOptions} object that uses the given view animation., +   *, +   * @see GenericTransitionOptions#transition(int), +   */, +  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(, +      int viewAnimationId) {, +    return new GenericTransitionOptions<TranscodeType>().transition(viewAnimationId);, +  }, +, +  /**, +   * Returns a typed {@link GenericTransitionOptions} object that uses the given animator., +   *, +   * @see GenericTransitionOptions#transition(ViewPropertyTransition.Animator), +   */, +  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(, +      ViewPropertyTransition.Animator animator) {, +    return new GenericTransitionOptions<TranscodeType>().transition(animator);, +  }, +, +  /**, +   * Returns a typed {@link GenericTransitionOptions} object that uses the given transition factory., +   *, +   * @see GenericTransitionOptions#transition(TransitionFactory), +   */, +  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(, +      TransitionFactory<? super TranscodeType> transitionFactory) {, +    return new GenericTransitionOptions<TranscodeType>().transition(transitionFactory);, +  }, +++ b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java, +import com.bumptech.glide.request.transition.TransitionFactory;, +import com.bumptech.glide.request.transition.ViewPropertyTransition;, +, +  /**, +   * Removes any existing animation put on the builder., +   *, +   * @see GenericTransitionOptions#dontTransition(), +   */, +, +  /**, +   * Returns a typed {@link GenericTransitionOptions} object that uses the given view animation., +   *, +   * @see GenericTransitionOptions#transition(int), +   */, +  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(, +      int viewAnimationId) {, +    return new GenericTransitionOptions<TranscodeType>().transition(viewAnimationId);, +  }, +, +  /**, +   * Returns a typed {@link GenericTransitionOptions} object that uses the given animator., +   *, +   * @see GenericTransitionOptions#transition(ViewPropertyTransition.Animator), +   */, +  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(, +      ViewPropertyTransition.Animator animator) {, +    return new GenericTransitionOptions<TranscodeType>().transition(animator);, +  }, +, +  /**, +   * Returns a typed {@link GenericTransitionOptions} object that uses the given transition factory., +   *, +   * @see GenericTransitionOptions#transition(TransitionFactory), +   */, +  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(, +      TransitionFactory<? super TranscodeType> transitionFactory) {, +    return new GenericTransitionOptions<TranscodeType>().transition(transitionFactory);, +  }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java, +package com.bumptech.glide.load.resource.bitmap;, +, +import android.graphics.Bitmap;, +import android.graphics.drawable.Drawable;, +, +import com.bumptech.glide.TransitionOptions;, +import com.bumptech.glide.request.transition.BitmapTransitionFactory;, +import com.bumptech.glide.request.transition.DrawableCrossFadeFactory;, +import com.bumptech.glide.request.transition.TransitionFactory;, +, +/**, + * Contains {@link Bitmap} specific animation options., + */, +public final class BitmapTransitionOptions extends, +    TransitionOptions<BitmapTransitionOptions, Bitmap> {, +, +  /**, +   * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation., +   *, +   * @see #crossFade(), +   */]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +    //noinspection rawtypes, +  public void loadIntoView_withSkipMemoryCacheFalse_loadsFromMemoryCacheIfPresent() {, +    final ImageView imageView = new ImageView(context);, +    imageView.setLayoutParams(new LayoutParams(100, 100));, +, +    concurrency.loadOnMainThread(, +        GlideApp.with(context), +            .load(ResourceIds.raw.canonical), +            .listener(requestListener), +            .skipMemoryCache(false), +            .dontTransform(),, +        imageView);, +, +    // Casting avoids a varags array warning., +    //noinspection rawtypes, +    reset((RequestListener) requestListener);, +, +    // Run on the main thread, since this is already cached, we shouldn't need to try to wait. If we, +    // do end up re-using the old Target, our wait will always timeout anyway if we use, +    // loadOnMainThread. If the load doesn't complete in time, it will be caught by the listener, +    // below, which expects to be called synchronously., +    concurrency.runOnMainThread(, +        new Runnable() {, +          @Override, +          public void run() {, +            GlideApp.with(context), +                .load(ResourceIds.raw.canonical), +                .listener(requestListener), +                .skipMemoryCache(false), +                .dontTransform(), +                .into(imageView);, +          }, +        });, +, +    verify(requestListener), +        .onResourceReady(, +            anyDrawable(),, +            any(),, +            anyDrawableTarget(),, +            eq(DataSource.MEMORY_CACHE),, +            anyBoolean());, +  }, +, +  @Test, +    //noinspection rawtypes, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +    //noinspection rawtypes, +  public void loadIntoView_withSkipMemoryCacheFalse_loadsFromMemoryCacheIfPresent() {, +    final ImageView imageView = new ImageView(context);, +    imageView.setLayoutParams(new LayoutParams(100, 100));, +, +    concurrency.loadOnMainThread(, +        GlideApp.with(context), +            .load(ResourceIds.raw.canonical), +            .listener(requestListener), +            .skipMemoryCache(false), +            .dontTransform(),, +        imageView);, +, +    // Casting avoids a varags array warning., +    //noinspection rawtypes, +    reset((RequestListener) requestListener);, +, +    // Run on the main thread, since this is already cached, we shouldn't need to try to wait. If we, +    // do end up re-using the old Target, our wait will always timeout anyway if we use, +    // loadOnMainThread. If the load doesn't complete in time, it will be caught by the listener, +    // below, which expects to be called synchronously., +    concurrency.runOnMainThread(, +        new Runnable() {, +          @Override, +          public void run() {, +            GlideApp.with(context), +                .load(ResourceIds.raw.canonical), +                .listener(requestListener), +                .skipMemoryCache(false), +                .dontTransform(), +                .into(imageView);, +          }, +        });, +, +    verify(requestListener), +        .onResourceReady(, +            anyDrawable(),, +            any(),, +            anyDrawableTarget(),, +            eq(DataSource.MEMORY_CACHE),, +            anyBoolean());, +  }, +, +  @Test, +    //noinspection rawtypes, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    return !options.isMemoryCacheable() && previous.isComplete();]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    registry.register(new DefaultImageHeaderParser());]
[+++ b/gradle.properties, +VERSION_NAME=4.9.0]
[+++ b/README.md, +-keep public enum com.bumptech.glide.load.ImageHeaderParser$** {, +++ b/README.md, +-keep public enum com.bumptech.glide.load.ImageHeaderParser$** {, +++ b/library/proguard-rules.txt, +-keep public enum com.bumptech.glide.load.ImageHeaderParser$** {]
[+++ b/library/src/main/java/com/bumptech/glide/load/HttpException.java, +import android.support.annotation.Nullable;, +, +  public HttpException(String message, int statusCode, @Nullable Throwable cause) {]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.1', +  <version>3.5.1</version>, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.1', +  <version>3.5.1</version>, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }, +    }, +}, +, +subprojects {, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = 1.7, +        targetCompatibility = 1.7, +    }, +}, +, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifData.java, +, +import com.bumptech.glide.load.engine.Resource;, +import com.bumptech.glide.load.resource.UnitTransformation;, +import com.bumptech.glide.load.resource.bitmap.BitmapResource;, +    private static final GifDrawableFactory GIF_DRAWABLE_FACTORY = new DefaultGifDrawableFactory();, +    private final BitmapPool bitmapPool;, +    /** The target dimensions we should pass to Glide to use when loading individual frames */, +    private final GifDrawableFactory factory;, +, +    /** The final dimensions of the transformed frames */, +    private int frameHeight;, +    private int frameWidth;, +        this(context, bitmapPool, gifId, header, data, targetWidth, targetHeight, GIF_DRAWABLE_FACTORY);, +    }, +, +    GifData(Context context, BitmapPool bitmapPool, String gifId, GifHeader header, byte[] data,, +            int targetWidth, int targetHeight, GifDrawableFactory factory) {, +        this.bitmapPool = bitmapPool;, +        this.factory = factory;, +, +        frameWidth = header.getWidth();, +        frameHeight = header.getHeight();, +, +        // The drawable needs to be initialized with the correct width and height in order for a view displaying it, +        // to end up with the right dimensions. Since our transformations may arbitrarily modify the dimensions of, +        // our gif, here we create a stand in for a frame and pass it to the transformation to see what the final, +        // transformed dimensions will be so that our drawable can report the correct intrinsict width and height., +        Bitmap toTest = bitmapPool.get(header.getWidth(), header.getHeight(), Bitmap.Config.RGB_565);, +        if (toTest == null) {, +            toTest = Bitmap.createBitmap(header.getWidth(), header.getHeight(), Bitmap.Config.RGB_565);, +        }, +        Resource<Bitmap> bitmapResource = new BitmapResource(toTest, bitmapPool);, +        Resource<Bitmap> transformed = transformation.transform(bitmapResource, targetWidth, targetHeight);, +        if (bitmapResource != transformed) {, +            bitmapResource.recycle();, +        }, +        Bitmap bitmap = transformed.get();, +        frameWidth = bitmap.getWidth();, +        frameHeight = bitmap.getHeight();, +        transformed.recycle();, +        GifDrawable result = factory.build(context, bitmapProvider, getFrameTransformation(), targetWidth, targetHeight,, +                gifId, header, data, frameWidth, frameHeight);, +    interface GifDrawableFactory {, +        public GifDrawable build(Context context, GifDecoder.BitmapProvider provider,, +                Transformation<Bitmap> frameTransformation, int targetWidth, int targetHeight, String gifId,, +                GifHeader header, byte[] data, int frameWidth, int frameHeight);, +    }, +, +    private static class DefaultGifDrawableFactory implements GifDrawableFactory {, +, +        @Override, +        public GifDrawable build(Context context, GifDecoder.BitmapProvider provider, Transformation<Bitmap>, +                frameTransformation, int targetWidth, int targetHeight, String gifId, GifHeader header, byte[] data,, +                int frameWidth, int frameHeight) {, +            return new GifDrawable(context, provider, frameTransformation, targetWidth, targetHeight, gifId, header,, +                    data, frameWidth, frameHeight);, +        }, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifData.java, +, +import com.bumptech.glide.load.engine.Resource;, +import com.bumptech.glide.load.resource.UnitTransformation;, +import com.bumptech.glide.load.resource.bitmap.BitmapResource;, +    private static final GifDrawableFactory GIF_DRAWABLE_FACTORY = new DefaultGifDrawableFactory();, +    private final BitmapPool bitmapPool;, +    /** The target dimensions we should pass to Glide to use when loading individual frames */, +    private final GifDrawableFactory factory;, +, +    /** The final dimensions of the transformed frames */, +    private int frameHeight;, +    private int frameWidth;, +        this(context, bitmapPool, gifId, header, data, targetWidth, targetHeight, GIF_DRAWABLE_FACTORY);, +    }, +, +    GifData(Context context, BitmapPool bitmapPool, String gifId, GifHeader header, byte[] data,, +            int targetWidth, int targetHeight, GifDrawableFactory factory) {, +        this.bitmapPool = bitmapPool;, +        this.factory = factory;, +, +        frameWidth = header.getWidth();, +        frameHeight = header.getHeight();, +, +        // The drawable needs to be initialized with the correct width and height in order for a view displaying it, +        // to end up with the right dimensions. Since our transformations may arbitrarily modify the dimensions of, +        // our gif, here we create a stand in for a frame and pass it to the transformation to see what the final, +        // transformed dimensions will be so that our drawable can report the correct intrinsict width and height., +        Bitmap toTest = bitmapPool.get(header.getWidth(), header.getHeight(), Bitmap.Config.RGB_565);, +        if (toTest == null) {, +            toTest = Bitmap.createBitmap(header.getWidth(), header.getHeight(), Bitmap.Config.RGB_565);, +        }, +        Resource<Bitmap> bitmapResource = new BitmapResource(toTest, bitmapPool);, +        Resource<Bitmap> transformed = transformation.transform(bitmapResource, targetWidth, targetHeight);, +        if (bitmapResource != transformed) {, +            bitmapResource.recycle();, +        }, +        Bitmap bitmap = transformed.get();, +        frameWidth = bitmap.getWidth();, +        frameHeight = bitmap.getHeight();]
[+++ b/gradle.properties, +ANDROID_GRADLE_VERSION=1.2.2, +ROBOLECTRIC_GRADLE_VERSION=1.0.1, +JUNIT_VERSION=4.12, +MOCKITO_VERSION=1.10.19, +++ b/gradle.properties, +ANDROID_GRADLE_VERSION=1.2.2, +ROBOLECTRIC_GRADLE_VERSION=1.0.1, +JUNIT_VERSION=4.12, +MOCKITO_VERSION=1.10.19, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Thu Apr 30 12:21:55 CEST 2015, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.3-all.zip, +++ b/gradle.properties, +ANDROID_GRADLE_VERSION=1.2.2, +ROBOLECTRIC_GRADLE_VERSION=1.0.1, +JUNIT_VERSION=4.12, +MOCKITO_VERSION=1.10.19, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Thu Apr 30 12:21:55 CEST 2015, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.3-all.zip, +++ b/integration/volley/build.gradle, +apply plugin: 'org.robolectric', +++ b/gradle.properties, +ANDROID_GRADLE_VERSION=1.2.2, +ROBOLECTRIC_GRADLE_VERSION=1.0.1, +JUNIT_VERSION=4.12, +MOCKITO_VERSION=1.10.19, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Thu Apr 30 12:21:55 CEST 2015, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.3-all.zip, +++ b/integration/volley/build.gradle, +apply plugin: 'org.robolectric', +++ b/library/build.gradle, +apply plugin: 'org.robolectric', +    tasks.check.dependsOn(tasks.findbugs), +    tasks.check.dependsOn(tasks.pmd), +++ b/gradle.properties, +ANDROID_GRADLE_VERSION=1.2.2, +ROBOLECTRIC_GRADLE_VERSION=1.0.1, +JUNIT_VERSION=4.12, +MOCKITO_VERSION=1.10.19, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Thu Apr 30 12:21:55 CEST 2015, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.3-all.zip, +++ b/integration/volley/build.gradle, +apply plugin: 'org.robolectric', +++ b/library/build.gradle, +apply plugin: 'org.robolectric', +    tasks.check.dependsOn(tasks.findbugs), +    tasks.check.dependsOn(tasks.pmd), +++ b/third_party/gif_decoder/build.gradle, +apply plugin: 'org.robolectric']
[+++ b/samples/flickr/lint.xml, +    <issue id="IconMissingDensityFolder" severity="ignore"/>, +++ b/samples/flickr/lint.xml, +    <issue id="IconMissingDensityFolder" severity="ignore"/>, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java, +import android.annotation.TargetApi;, +import android.os.Build;, +  @TargetApi(Build.VERSION_CODES.LOLLIPOP), +++ b/samples/flickr/lint.xml, +    <issue id="IconMissingDensityFolder" severity="ignore"/>, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/SquareImageView.java, +import android.annotation.TargetApi;, +import android.os.Build;, +  @TargetApi(Build.VERSION_CODES.LOLLIPOP), +++ /dev/null]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java, +package com.bumptech.glide.load.engine.cache;, +, +import com.bumptech.glide.load.Key;, +, +import java.util.ArrayDeque;, +import java.util.HashMap;, +import java.util.Map;, +import java.util.Queue;, +import java.util.concurrent.locks.Lock;, +import java.util.concurrent.locks.ReentrantLock;, +, +/**, + * Keeps a map of keys to locks that allows locks to be removed from the map when no longer in use, + * so the size of the collection is bounded., + *, + * <p> This class will be accessed by multiple threads in a thread pool and ensures that the, + *  number of threads interested in each lock is updated atomically so that when the count reaches, + *  0, the lock can safely be removed from the map. </p>, + */, +final class DiskCacheWriteLocker {, +    private final Map<Key, WriteLock> locks = new HashMap<Key, WriteLock>();, +    private final WriteLockPool writeLockPool = new WriteLockPool();, +, +    void acquire(Key key) {, +        WriteLock writeLock;, +        synchronized (this) {, +            writeLock = locks.get(key);, +            if (writeLock == null) {, +                writeLock = writeLockPool.obtain();, +                locks.put(key, writeLock);, +            }, +            writeLock.interestedThreads++;, +        }, +, +        writeLock.lock.lock();, +    }, +, +    void release(Key key) {, +        WriteLock writeLock;, +        synchronized (this) {, +            writeLock = locks.get(key);, +            if (writeLock == null || writeLock.interestedThreads <= 0) {, +                throw new IllegalArgumentException(, +                    "Cannot release a lock that is not held" + ", key: " + key + ", interestedThreads: ", +                        + (writeLock == null ? 0 : writeLock.interestedThreads));, +            }, +, +            if (--writeLock.interestedThreads == 0) {, +                WriteLock removed = locks.remove(key);, +                if (!removed.equals(writeLock)) {, +                    throw new IllegalStateException("Removed the wrong lock", +                        + ", expected to remove: " + writeLock, +                        + ", but actually removed: " + removed, +                        + ", key: " + key);, +                }, +                writeLockPool.offer(removed);, +            }, +        }, +, +        writeLock.lock.unlock();, +    }, +, +    private static class WriteLock  {, +        final Lock lock = new ReentrantLock();, +        int interestedThreads;, +    }, +, +    private static class WriteLockPool {, +        private static final int MAX_POOL_SIZE = 10;, +        private final Queue<WriteLock> pool = new ArrayDeque<WriteLock>();, +, +        WriteLock obtain() {, +            WriteLock result;, +            synchronized (pool) {, +                result = pool.poll();, +            }, +            if (result == null) {, +                result = new WriteLock();, +            }, +            return result;, +        }, +, +        void offer(WriteLock writeLock) {, +            synchronized (pool) {, +                if (pool.size() < MAX_POOL_SIZE) {, +                    pool.offer(writeLock);, +                }, +            }, +        }, +    }, +}, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java, +package com.bumptech.glide.load.engine.cache;, +, +import com.bumptech.glide.load.Key;, +, +import java.util.ArrayDeque;, +import java.util.HashMap;, +import java.util.Map;]
[+++ b/library/src/com/bumptech/glide/loader/model/BaseModelStreamLoader.java, +     * @see ModelStreamLoader#fetchModelStream(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamReadyCallback), +    public final Object fetchModelStream(T model, int width, int height, ModelStreamReadyCallback cb) {, +        doFetchModelStreams(model, width, height, new InternalModelStreamReadyCallback(cb, model));, +     * @see ModelStreamLoader#fetchModelStream(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamReadyCallback), +    protected abstract void doFetchModelStreams(T model, int width, int height, ModelStreamReadyCallback cb);, +    protected class InternalModelStreamReadyCallback implements ModelStreamReadyCallback {, +        private final WeakReference<ModelStreamReadyCallback> cbRef;, +        public InternalModelStreamReadyCallback(ModelStreamReadyCallback cb, T model) {, +            this.cbRef = new WeakReference<ModelStreamReadyCallback>(cb);, +        public boolean onStreamReady(String id, StreamOpener streamOpener) {, +            ModelStreamReadyCallback cb = cbRef.get();, +                result = cb.onStreamReady(id, streamOpener);, +            ModelStreamReadyCallback cb = cbRef.get();, +++ b/library/src/com/bumptech/glide/loader/model/BaseModelStreamLoader.java, +     * @see ModelStreamLoader#fetchModelStream(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamReadyCallback), +    public final Object fetchModelStream(T model, int width, int height, ModelStreamReadyCallback cb) {, +        doFetchModelStreams(model, width, height, new InternalModelStreamReadyCallback(cb, model));, +     * @see ModelStreamLoader#fetchModelStream(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamReadyCallback), +    protected abstract void doFetchModelStreams(T model, int width, int height, ModelStreamReadyCallback cb);, +    protected class InternalModelStreamReadyCallback implements ModelStreamReadyCallback {, +        private final WeakReference<ModelStreamReadyCallback> cbRef;, +        public InternalModelStreamReadyCallback(ModelStreamReadyCallback cb, T model) {, +            this.cbRef = new WeakReference<ModelStreamReadyCallback>(cb);, +        public boolean onStreamReady(String id, StreamOpener streamOpener) {, +            ModelStreamReadyCallback cb = cbRef.get();, +                result = cb.onStreamReady(id, streamOpener);, +            ModelStreamReadyCallback cb = cbRef.get();, +++ b/library/src/com/bumptech/glide/loader/model/DirectModelStreamLoader.java, +    protected void doFetchModelStreams(T model, int width, int height, ModelStreamReadyCallback cb) {, +        cb.onStreamReady(getId(model), getStreamOpener(model, width, height));, +++ b/library/src/com/bumptech/glide/loader/model/BaseModelStreamLoader.java, +     * @see ModelStreamLoader#fetchModelStream(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamReadyCallback), +    public final Object fetchModelStream(T model, int width, int height, ModelStreamReadyCallback cb) {, +        doFetchModelStreams(model, width, height, new InternalModelStreamReadyCallback(cb, model));, +     * @see ModelStreamLoader#fetchModelStream(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamReadyCallback), +    protected abstract void doFetchModelStreams(T model, int width, int height, ModelStreamReadyCallback cb);, +    protected class InternalModelStreamReadyCallback implements ModelStreamReadyCallback {, +        private final WeakReference<ModelStreamReadyCallback> cbRef;, +        public InternalModelStreamReadyCallback(ModelStreamReadyCallback cb, T model) {, +            this.cbRef = new WeakReference<ModelStreamReadyCallback>(cb);, +        public boolean onStreamReady(String id, StreamOpener streamOpener) {, +            ModelStreamReadyCallback cb = cbRef.get();, +                result = cb.onStreamReady(id, streamOpener);, +            ModelStreamReadyCallback cb = cbRef.get();, +++ b/library/src/com/bumptech/glide/loader/model/DirectModelStreamLoader.java, +    protected void doFetchModelStreams(T model, int width, int height, ModelStreamReadyCallback cb) {, +        cb.onStreamReady(getId(model), getStreamOpener(model, width, height));, +++ b/library/src/com/bumptech/glide/loader/model/ModelStreamLoader.java, +    public interface ModelStreamReadyCallback {, +        public boolean onStreamReady(String id, StreamOpener streamOpener);, +    public Object fetchModelStream(T model, int width, int height, ModelStreamReadyCallback cb);, +++ b/library/src/com/bumptech/glide/loader/model/BaseModelStreamLoader.java, +     * @see ModelStreamLoader#fetchModelStream(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamReadyCallback), +    public final Object fetchModelStream(T model, int width, int height, ModelStreamReadyCallback cb) {, +        doFetchModelStreams(model, width, height, new InternalModelStreamReadyCallback(cb, model));, +     * @see ModelStreamLoader#fetchModelStream(Object, int, int, com.bumptech.glide.loader.model.ModelStreamLoader.ModelStreamReadyCallback), +    protected abstract void doFetchModelStreams(T model, int width, int height, ModelStreamReadyCallback cb);, +    protected class InternalModelStreamReadyCallback implements ModelStreamReadyCallback {, +        private final WeakReference<ModelStreamReadyCallback> cbRef;, +        public InternalModelStreamReadyCallback(ModelStreamReadyCallback cb, T model) {, +            this.cbRef = new WeakReference<ModelStreamReadyCallback>(cb);, +        public boolean onStreamReady(String id, StreamOpener streamOpener) {, +            ModelStreamReadyCallback cb = cbRef.get();, +                result = cb.onStreamReady(id, streamOpener);, +            ModelStreamReadyCallback cb = cbRef.get();, +++ b/library/src/com/bumptech/glide/loader/model/DirectModelStreamLoader.java, +    protected void doFetchModelStreams(T model, int width, int height, ModelStreamReadyCallback cb) {, +        cb.onStreamReady(getId(model), getStreamOpener(model, width, height));, +++ b/library/src/com/bumptech/glide/loader/model/ModelStreamLoader.java, +    public interface ModelStreamReadyCallback {, +        public boolean onStreamReady(String id, StreamOpener streamOpener);, +    public Object fetchModelStream(T model, int width, int height, ModelStreamReadyCallback cb);, +++ b/library/src/com/bumptech/glide/loader/opener/FileInputStreamOpener.java, +package com.bumptech.glide.loader.opener;, +, +import java.io.File;, +import java.io.FileInputStream;, +import java.io.IOException;, +import java.io.InputStream;, +, +/**, + * Created with IntelliJ IDEA., + * User: sam, + * Date: 7/10/13, + * Time: 11:11 PM, + * To change this template use File | Settings | File Templates., + */, +public class FileInputStreamOpener implements StreamOpener {, +    private final File file;, +, +    public FileInputStreamOpener(String path) {, +        this(new File(path));, +    }, +, +    public FileInputStreamOpener(File file) {, +        this.file = file;, +    }, +, +    @Override]
[+++ b/README.md, +./gradlew :samples:contacturi:run, +++ b/README.md, +./gradlew :samples:contacturi:run, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +   * Uri for optimized search of phones by number, +   * (e.g. content://com.android.contacts/phone_lookup/232323232, +   */, +  private static final int ID_LOOKUP_BY_PHONE = 5;, +  /**, +    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "phone_lookup/*", ID_LOOKUP_BY_PHONE);, +      case ID_LOOKUP_BY_PHONE:, +++ b/README.md, +./gradlew :samples:contacturi:run, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +   * Uri for optimized search of phones by number, +   * (e.g. content://com.android.contacts/phone_lookup/232323232, +   */, +  private static final int ID_LOOKUP_BY_PHONE = 5;, +  /**, +    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "phone_lookup/*", ID_LOOKUP_BY_PHONE);, +      case ID_LOOKUP_BY_PHONE:, +++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java, +import android.Manifest;, +import android.content.pm.PackageManager;, +import android.provider.ContactsContract;, +import android.support.v4.app.ActivityCompat;, +import android.support.v4.content.ContextCompat;, +import android.widget.EditText;, +  private static final int READ_CONTACTS = 0;, +  private EditText numberEntry;, +    numberEntry = (EditText) findViewById(R.id.number_entry);, +    // Make sure that user gives application required permissions, +    if (ContextCompat.checkSelfPermission(, +    getApplication(),, +    Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) {, +      // No explanation needed, we can request the permission., +      ActivityCompat.requestPermissions(this,, +      new String[]{Manifest.permission.READ_CONTACTS},, +      READ_CONTACTS);, +    }, +, +    findViewById(R.id.button_find).setOnClickListener(new View.OnClickListener() {, +      @Override, +      public void onClick(View v) {, +        Uri uri = Uri.withAppendedPath(ContactsContract.PhoneLookup.CONTENT_FILTER_URI,, +                                       Uri.encode(numberEntry.getText().toString()));, +        GlideApp.with(MainActivity.this), +                .load(uri), +                .override(Target.SIZE_ORIGINAL), +                .into(imageViewLookup);, +        }, +    });, +++ b/README.md, +./gradlew :samples:contacturi:run, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +   * Uri for optimized search of phones by number, +   * (e.g. content://com.android.contacts/phone_lookup/232323232, +   */, +  private static final int ID_LOOKUP_BY_PHONE = 5;, +  /**, +    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "phone_lookup/*", ID_LOOKUP_BY_PHONE);, +      case ID_LOOKUP_BY_PHONE:, +++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java, +import android.Manifest;, +import android.content.pm.PackageManager;, +import android.provider.ContactsContract;, +import android.support.v4.app.ActivityCompat;, +import android.support.v4.content.ContextCompat;, +import android.widget.EditText;, +  private static final int READ_CONTACTS = 0;, +  private EditText numberEntry;, +    numberEntry = (EditText) findViewById(R.id.number_entry);, +    // Make sure that user gives application required permissions, +    if (ContextCompat.checkSelfPermission(, +    getApplication(),, +    Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) {, +      // No explanation needed, we can request the permission., +      ActivityCompat.requestPermissions(this,, +      new String[]{Manifest.permission.READ_CONTACTS},, +      READ_CONTACTS);, +    }, +, +    findViewById(R.id.button_find).setOnClickListener(new View.OnClickListener() {, +      @Override, +      public void onClick(View v) {, +        Uri uri = Uri.withAppendedPath(ContactsContract.PhoneLookup.CONTENT_FILTER_URI,, +                                       Uri.encode(numberEntry.getText().toString()));, +        GlideApp.with(MainActivity.this), +                .load(uri), +                .override(Target.SIZE_ORIGINAL), +                .into(imageViewLookup);, +        }, +    });, +++ b/samples/contacturi/src/main/res/layout/activity_main.xml, +        <LinearLayout, +            android:layout_width="match_parent", +            android:layout_height="match_parent", +            android:orientation="horizontal">, +]
[+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java, +import android.content.ContentResolver;, +    return build(context, uri, new ImageThumbnailQuery(context.getContentResolver()));, +    return build(context, uri, new VideoThumbnailQuery(context.getContentResolver()));, +    return new ThumbFetcher(, +        uri, new ThumbnailStreamOpener(query, byteArrayPool, context.getContentResolver()));, +  ThumbFetcher(Uri mediaStoreImageUri, ThumbnailStreamOpener opener) {, +    InputStream result = opener.open(mediaStoreImageUri);, +      orientation = opener.getOrientation(mediaStoreImageUri);, +, +    private final ContentResolver contentResolver;, +, +    VideoThumbnailQuery(ContentResolver contentResolver) {, +      this.contentResolver = contentResolver;, +    }, +, +    public Cursor query(Uri uri) {, +      return contentResolver.query(, +, +    private final ContentResolver contentResolver;, +, +    ImageThumbnailQuery(ContentResolver contentResolver) {, +      this.contentResolver = contentResolver;, +    }, +, +    public Cursor query(Uri uri) {, +      return contentResolver.query(, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java, +import android.content.ContentResolver;, +    return build(context, uri, new ImageThumbnailQuery(context.getContentResolver()));, +    return build(context, uri, new VideoThumbnailQuery(context.getContentResolver()));, +    return new ThumbFetcher(, +        uri, new ThumbnailStreamOpener(query, byteArrayPool, context.getContentResolver()));, +  ThumbFetcher(Uri mediaStoreImageUri, ThumbnailStreamOpener opener) {, +    InputStream result = opener.open(mediaStoreImageUri);, +      orientation = opener.getOrientation(mediaStoreImageUri);, +, +    private final ContentResolver contentResolver;, +, +    VideoThumbnailQuery(ContentResolver contentResolver) {, +      this.contentResolver = contentResolver;, +    }, +, +    public Cursor query(Uri uri) {, +      return contentResolver.query(, +, +    private final ContentResolver contentResolver;, +, +    ImageThumbnailQuery(ContentResolver contentResolver) {, +      this.contentResolver = contentResolver;, +    }, +, +    public Cursor query(Uri uri) {, +      return contentResolver.query(, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java, +  Cursor query(Uri uri);, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java, +import android.content.ContentResolver;, +    return build(context, uri, new ImageThumbnailQuery(context.getContentResolver()));, +    return build(context, uri, new VideoThumbnailQuery(context.getContentResolver()));, +    return new ThumbFetcher(, +        uri, new ThumbnailStreamOpener(query, byteArrayPool, context.getContentResolver()));, +  ThumbFetcher(Uri mediaStoreImageUri, ThumbnailStreamOpener opener) {, +    InputStream result = opener.open(mediaStoreImageUri);, +      orientation = opener.getOrientation(mediaStoreImageUri);, +, +    private final ContentResolver contentResolver;, +, +    VideoThumbnailQuery(ContentResolver contentResolver) {, +      this.contentResolver = contentResolver;, +    }, +, +    public Cursor query(Uri uri) {, +      return contentResolver.query(, +, +    private final ContentResolver contentResolver;, +, +    ImageThumbnailQuery(ContentResolver contentResolver) {, +      this.contentResolver = contentResolver;, +    }, +, +    public Cursor query(Uri uri) {, +      return contentResolver.query(, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailQuery.java, +  Cursor query(Uri uri);, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java, +import android.content.ContentResolver;, +  private final ContentResolver contentResolver;, +  public ThumbnailStreamOpener(, +      ThumbnailQuery query, ArrayPool byteArrayPool, ContentResolver contentResolver) {, +    this(DEFAULT_SERVICE, query, byteArrayPool, contentResolver);, +  public ThumbnailStreamOpener(, +      FileService service,, +      ThumbnailQuery query,, +      ArrayPool byteArrayPool,, +      ContentResolver contentResolver) {, +    this.contentResolver = contentResolver;, +  public int getOrientation(Uri uri) {, +      is = contentResolver.openInputStream(uri);, +  public InputStream open(Uri uri) throws FileNotFoundException {]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +  @TargetApi(Build.VERSION_CODES.O), +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +  @TargetApi(Build.VERSION_CODES.O), +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java, +  // Package private to avoid PMD warning., +  MemorySizeCalculator(MemorySizeCalculator.Builder builder) {, +    int widthPixels = builder.screenDimensions.getWidthPixels();, +    int heightPixels = builder.screenDimensions.getHeightPixels();, +    int screenSize = widthPixels * heightPixels * BYTES_PER_ARGB_8888_PIXEL;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +  @TargetApi(Build.VERSION_CODES.O), +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java, +  // Package private to avoid PMD warning., +  MemorySizeCalculator(MemorySizeCalculator.Builder builder) {, +    int widthPixels = builder.screenDimensions.getWidthPixels();, +    int heightPixels = builder.screenDimensions.getHeightPixels();, +    int screenSize = widthPixels * heightPixels * BYTES_PER_ARGB_8888_PIXEL;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +  // Avoid short circuiting SDK checks., +  @SuppressWarnings("PMD.CollapsibleIfStatements"), +  @TargetApi(Build.VERSION_CODES.O), +    // Avoid short circuiting, it appears to break on some devices., +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {, +      if (options.inPreferredConfig == Config.HARDWARE) {, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +  @TargetApi(Build.VERSION_CODES.O), +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java, +  // Package private to avoid PMD warning., +  MemorySizeCalculator(MemorySizeCalculator.Builder builder) {, +    int widthPixels = builder.screenDimensions.getWidthPixels();, +    int heightPixels = builder.screenDimensions.getHeightPixels();, +    int screenSize = widthPixels * heightPixels * BYTES_PER_ARGB_8888_PIXEL;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +  // Avoid short circuiting SDK checks., +  @SuppressWarnings("PMD.CollapsibleIfStatements"), +  @TargetApi(Build.VERSION_CODES.O), +    // Avoid short circuiting, it appears to break on some devices., +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {, +      if (options.inPreferredConfig == Config.HARDWARE) {, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java, +import android.annotation.TargetApi;, +  @TargetApi(Build.VERSION_CODES.O)]
[+++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java|AnimationOptions.java|BaseDecodeOptions.java|RequestOptions.java" checks="NoClone" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java|AnimationOptions.java|BaseDecodeOptions.java|RequestOptions.java" checks="NoClone" />, +++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="module" module-name="library" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java|AnimationOptions.java|BaseDecodeOptions.java|RequestOptions.java" checks="NoClone" />, +++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="module" module-name="library" />, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +        Request request = new Request.Builder(), +, +    @Override, +    public Class<InputStream> getDataClass() {, +        return InputStream.class;, +    }, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java|AnimationOptions.java|BaseDecodeOptions.java|RequestOptions.java" checks="NoClone" />, +++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="module" module-name="library" />, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +        Request request = new Request.Builder(), +, +    @Override, +    public Class<InputStream> getDataClass() {, +        return InputStream.class;, +    }, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +import com.bumptech.glide.load.model.MultiModelLoaderFactory;, +    private final OkHttpClient client;, +, +    public OkHttpUrlLoader(OkHttpClient client) {, +        this.client = client;, +    }, +, +    @Override, +    public boolean handles(GlideUrl url) {, +        return true;, +    }, +, +    @Override, +    public DataFetcher<InputStream> getDataFetcher(GlideUrl model, int width, int height) {, +        return new OkHttpStreamFetcher(client, model);, +    }, +, +        public ModelLoader<GlideUrl, InputStream> build(Context context, MultiModelLoaderFactory multiFactory) {, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java|AnimationOptions.java|BaseDecodeOptions.java|RequestOptions.java" checks="NoClone" />, +++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="module" module-name="library" />, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +        Request request = new Request.Builder(), +, +    @Override, +    public Class<InputStream> getDataClass() {, +        return InputStream.class;, +    }, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +import com.bumptech.glide.load.model.MultiModelLoaderFactory;, +    private final OkHttpClient client;, +, +    public OkHttpUrlLoader(OkHttpClient client) {, +        this.client = client;, +    }, +, +    @Override, +    public boolean handles(GlideUrl url) {, +        return true;, +    }, +, +    @Override, +    public DataFetcher<InputStream> getDataFetcher(GlideUrl model, int width, int height) {, +        return new OkHttpStreamFetcher(client, model);, +    }, +, +        public ModelLoader<GlideUrl, InputStream> build(Context context, MultiModelLoaderFactory multiFactory) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +    @Override, +    public Class<InputStream> getDataClass() {, +        return InputStream.class;, +    }, +, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java|AnimationOptions.java|BaseDecodeOptions.java|RequestOptions.java" checks="NoClone" />, +++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="module" module-name="library" />, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +        Request request = new Request.Builder(), +, +    @Override, +    public Class<InputStream> getDataClass() {, +        return InputStream.class;, +    }, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +import com.bumptech.glide.load.model.MultiModelLoaderFactory;, +    private final OkHttpClient client;, +, +    public OkHttpUrlLoader(OkHttpClient client) {, +        this.client = client;]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +        case CENTER_INSIDE:, +          requestOptions.optionalCenterInside(context);, +          break;, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +        case CENTER_INSIDE:, +          requestOptions.optionalCenterInside(context);, +          break;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java, +package com.bumptech.glide.load.resource.bitmap;, +, +import android.content.Context;, +import android.graphics.Bitmap;, +import android.support.annotation.NonNull;, +, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +, +import java.security.MessageDigest;, +, +/**, + * Returns the image with its original size if its dimensions match or are smaller, + * than the target's, couple with {@link android.widget.ImageView.ScaleType#CENTER_INSIDE}, + * in order to center it in Target. If not, then it is scaled so that one of the dimensions of, + * the image will be equal to the given dimension and the other will be less than the given, + * dimension (maintaining the image's aspect ratio)., + */, +public class CenterInside extends BitmapTransformation {, +  private static final String ID = "com.bumptech.glide.load.resource.bitmap.CenterInside";, +  private static final byte[] ID_BYTES = ID.getBytes(CHARSET);, +, +  public CenterInside(Context context) {, +    super(context);, +  }, +, +  public CenterInside(BitmapPool bitmapPool) {, +    super(bitmapPool);, +  }, +, +  @Override, +  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,, +      int outHeight) {, +    return TransformationUtils.centerInside(pool, toTransform, outWidth, outHeight);, +  }, +, +  @Override, +  public boolean equals(Object o) {, +    return o instanceof CenterInside;, +  }, +, +  @Override, +  public int hashCode() {, +    return ID.hashCode();, +  }, +, +  @Override, +  public void updateDiskCacheKey(MessageDigest messageDigest) {, +    messageDigest.update(ID_BYTES);, +  }, +}, +, +, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +        case CENTER_INSIDE:, +          requestOptions.optionalCenterInside(context);, +          break;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java, +package com.bumptech.glide.load.resource.bitmap;, +, +import android.content.Context;, +import android.graphics.Bitmap;, +import android.support.annotation.NonNull;, +, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +, +import java.security.MessageDigest;, +, +/**, + * Returns the image with its original size if its dimensions match or are smaller, + * than the target's, couple with {@link android.widget.ImageView.ScaleType#CENTER_INSIDE}, + * in order to center it in Target. If not, then it is scaled so that one of the dimensions of, + * the image will be equal to the given dimension and the other will be less than the given, + * dimension (maintaining the image's aspect ratio)., + */, +public class CenterInside extends BitmapTransformation {, +  private static final String ID = "com.bumptech.glide.load.resource.bitmap.CenterInside";, +  private static final byte[] ID_BYTES = ID.getBytes(CHARSET);, +, +  public CenterInside(Context context) {, +    super(context);, +  }, +, +  public CenterInside(BitmapPool bitmapPool) {, +    super(bitmapPool);, +  }, +, +  @Override, +  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,, +      int outHeight) {, +    return TransformationUtils.centerInside(pool, toTransform, outWidth, outHeight);, +  }]
[+++ b/library/proguard-rules.txt, +-keep public class * extends com.bumptech.glide.module.AppGlideModule, +, +# Uncomment for DexGuard only, +#-keepresourcexmlelements manifest/application/meta-data@value=GlideModule, +++ b/library/proguard-rules.txt, +-keep public class * extends com.bumptech.glide.module.AppGlideModule, +, +# Uncomment for DexGuard only, +#-keepresourcexmlelements manifest/application/meta-data@value=GlideModule, +++ b/samples/imgur/build.gradle, +++ b/library/proguard-rules.txt, +-keep public class * extends com.bumptech.glide.module.AppGlideModule, +, +# Uncomment for DexGuard only, +#-keepresourcexmlelements manifest/application/meta-data@value=GlideModule, +++ b/samples/imgur/build.gradle, +++ /dev/null, +++ b/library/proguard-rules.txt, +-keep public class * extends com.bumptech.glide.module.AppGlideModule, +, +# Uncomment for DexGuard only, +#-keepresourcexmlelements manifest/application/meta-data@value=GlideModule, +++ b/samples/imgur/build.gradle, +++ /dev/null, +++ /dev/null]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java, +package com.bumptech.glide.load.engine;, +, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.when;, +, +import com.bumptech.glide.load.Key;, +import com.bumptech.glide.load.Transformation;, +import com.bumptech.glide.signature.StringSignature;, +import com.bumptech.glide.tests.KeyAssertions;, +, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +, +import java.io.UnsupportedEncodingException;, +import java.security.NoSuchAlgorithmException;, +, +@RunWith(JUnit4.class), +public class ResourceCacheKeyTest {, +, +  private Factory factory;, +, +  @Before, +  public void setUp() {, +    factory = new Factory();, +  }, +, +  @Test, +  public void testIdenticalWithSameArguments(), +      throws UnsupportedEncodingException, NoSuchAlgorithmException {, +    KeyAssertions.assertSame(factory.build(), factory.build());, +  }, +, +  @Test, +  public void testDifferIfSourceKeyDiffers(), +      throws UnsupportedEncodingException, NoSuchAlgorithmException {, +    mutateAndAssertDifferent(new FactoryMutation() {, +      @Override, +      public void mutate(Factory factory) {, +        factory.sourceKey = new StringSignature("secondKey");, +      }, +    });, +  }, +, +  @Test, +  public void testDiffersIfSignatureDiffers() {, +    mutateAndAssertDifferent(new FactoryMutation() {, +      @Override, +      public void mutate(Factory factory) {, +        factory.signature = new StringSignature("secondSignature");, +      }, +    });, +  }, +, +  @Test, +  public void testDiffersIfWidthDiffers() {, +    mutateAndAssertDifferent(new FactoryMutation() {, +      @Override, +      public void mutate(Factory factory) {, +        factory.width = factory.width * 2;, +      }, +    });, +  }, +, +  @Test, +  public void testDiffersIfHeightDiffers() {, +    mutateAndAssertDifferent(new FactoryMutation() {, +      @Override, +      public void mutate(Factory factory) {, +        factory.height = factory.height * 2;, +      }, +    });, +  }, +, +  @Test, +  public void tesDiffersIfTransformationDiffers() {, +    mutateAndAssertDifferent(new FactoryMutation() {, +      @Override, +      public void mutate(Factory factory) {, +        factory.transformation = mock(Transformation.class);, +        when(factory.transformation.getId()).thenReturn("otherTransformation");, +      }, +    });, +  }, +, +  @Test, +  public void testDiffersIfResourceDiffers() {, +    mutateAndAssertDifferent(new FactoryMutation() {, +      @Override, +      public void mutate(Factory factory) {, +        factory.resourceClass = Integer.class;, +      }, +    });, +  }, +, +  interface FactoryMutation {]
[+++ /dev/null, +++ /dev/null, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.presenter.target.ImageViewTarget;, +import com.bumptech.glide.presenter.target.Target;, +import java.util.Map;, +import java.util.WeakHashMap;, +    private final Map<Target, Metadata> metadataTracker = new WeakHashMap<Target, Metadata>();, +        private ModelRequest(ModelLoader<T> modelLoader) {, +        private Context context;, +        private Target target;, +, +        private Request(T model) {, +        private Request(T model, ModelLoader<T> modelLoader) {, +            //make an effort to support wrap content layout params. This will still blow, +            //up if transformation doesn't handle wrap content, but its a start, +            final ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();, +            if (layoutParams != null &&, +                    (layoutParams.width == ViewGroup.LayoutParams.WRAP_CONTENT ||, +                    layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT)) {, +                downsampler = Downsampler.NONE;, +            }, +, +            finish(imageView.getContext(), new ImageViewTarget(imageView));, +        }, +, +        public ContextRequest into(Target target) {, +            return new ContextRequest(this, target);, +        }, +, +        private void finish(Context context, Target target) {, +            this.context = context;, +            this.target = target;, +, +            ImagePresenter<T> imagePresenter = getImagePresenter(target);, +        @SuppressWarnings("unchecked"), +        private ImagePresenter<T> getImagePresenter(Target target) {, +            Metadata previous = GLIDE.metadataTracker.get(target);, +            ImagePresenter<T> result = target.getImagePresenter();, +                result = buildImagePresenter(target);, +                target.setImagePresenter(result);, +                GLIDE.metadataTracker.put(target, current);, +        private ImagePresenter<T> buildImagePresenter(Target target) {, +                    .setTarget(target, context), +                final Animation animation = AnimationUtils.loadAnimation(context, animationId);, +                    public void onImageReady(Target target, boolean fromCache) {, +                            target.startAnimation(animation);, +    public static class ContextRequest {, +        private final Request request;, +        private final Target target;, +        private ContextRequest(Request request, Target target) {, +            this.request = request;, +            this.target = target;, +        public void with(Context context) {, +            request.finish(context, target);, +        }, +, +++ /dev/null, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.presenter.target.ImageViewTarget;, +import com.bumptech.glide.presenter.target.Target;, +import java.util.Map;, +import java.util.WeakHashMap;, +    private final Map<Target, Metadata> metadataTracker = new WeakHashMap<Target, Metadata>();, +        private ModelRequest(ModelLoader<T> modelLoader) {, +        private Context context;, +        private Target target;, +, +        private Request(T model) {, +        private Request(T model, ModelLoader<T> modelLoader) {, +            //make an effort to support wrap content layout params. This will still blow, +            //up if transformation doesn't handle wrap content, but its a start, +            final ViewGroup.LayoutParams layoutParams = imageView.getLayoutParams();, +            if (layoutParams != null &&, +                    (layoutParams.width == ViewGroup.LayoutParams.WRAP_CONTENT ||, +                    layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT)) {, +                downsampler = Downsampler.NONE;, +            }, +, +            finish(imageView.getContext(), new ImageViewTarget(imageView));, +        }, +, +        public ContextRequest into(Target target) {, +            return new ContextRequest(this, target);, +        }, +, +        private void finish(Context context, Target target) {, +            this.context = context;, +            this.target = target;, +, +            ImagePresenter<T> imagePresenter = getImagePresenter(target);, +        @SuppressWarnings("unchecked"), +        private ImagePresenter<T> getImagePresenter(Target target) {, +            Metadata previous = GLIDE.metadataTracker.get(target);, +            ImagePresenter<T> result = target.getImagePresenter();, +                result = buildImagePresenter(target);, +                target.setImagePresenter(result);, +                GLIDE.metadataTracker.put(target, current);, +        private ImagePresenter<T> buildImagePresenter(Target target) {, +                    .setTarget(target, context)]
[+++ b/library/src/main/java/com/bumptech/glide/Priority.java, +  LOW,, +++ b/library/src/main/java/com/bumptech/glide/Priority.java, +  LOW,, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    return SingleRequest.obtain(, +        context,, +        model,, +        transcodeClass,, +        requestOptions,, +        overrideWidth,, +        overrideHeight,, +        target,, +        requestListener,, +        requestCoordinator,, +        context.getEngine(),, +        transitionOptions.getTransitionFactory());, +++ b/library/src/main/java/com/bumptech/glide/Priority.java, +  LOW,, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    return SingleRequest.obtain(, +        context,, +        model,, +        transcodeClass,, +        requestOptions,, +        overrideWidth,, +        overrideHeight,, +        target,, +        requestListener,, +        requestCoordinator,, +        context.getEngine(),, +        transitionOptions.getTransitionFactory());, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +  private List<Key> cacheKeys;, +  private final DecodeHelper<?> helper;, +, +  DataCacheGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {, +    this(helper.getCacheKeys(), helper, cb);, +  }, +, +  // In some cases we may want to load a specific cache key (when loading from source written to, +  // cache), so we accept a list of keys rather than just obtain the list from the helper., +  DataCacheGenerator(List<Key> cacheKeys, DecodeHelper<?> helper, FetcherReadyCallback cb) {, +    this.cacheKeys = cacheKeys;, +    this.helper = helper;, +      if (sourceIdIndex >= cacheKeys.size()) {, +      Key sourceId = cacheKeys.get(sourceIdIndex);, +      Key originalKey = new DataCacheKey(sourceId, helper.getSignature());, +      cacheFile = helper.getDiskCache().get(originalKey);, +        modelLoaders = helper.getModelLoaders(cacheFile);, +          modelLoader.buildLoadData(cacheFile, helper.getWidth(), helper.getHeight(),, +              helper.getOptions()).fetcher;, +        fetcher.loadData(helper.getPriority(), this);, +++ b/library/src/main/java/com/bumptech/glide/Priority.java, +  LOW,, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    return SingleRequest.obtain(, +        context,, +        model,, +        transcodeClass,, +        requestOptions,, +        overrideWidth,, +        overrideHeight,, +        target,, +        requestListener,, +        requestCoordinator,, +        context.getEngine(),, +        transitionOptions.getTransitionFactory());, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +  private List<Key> cacheKeys;, +  private final DecodeHelper<?> helper;, +, +  DataCacheGenerator(DecodeHelper<?> helper, FetcherReadyCallback cb) {, +    this(helper.getCacheKeys(), helper, cb);, +  }, +, +  // In some cases we may want to load a specific cache key (when loading from source written to, +  // cache), so we accept a list of keys rather than just obtain the list from the helper., +  DataCacheGenerator(List<Key> cacheKeys, DecodeHelper<?> helper, FetcherReadyCallback cb) {, +    this.cacheKeys = cacheKeys;, +    this.helper = helper;, +      if (sourceIdIndex >= cacheKeys.size()) {, +      Key sourceId = cacheKeys.get(sourceIdIndex);, +      Key originalKey = new DataCacheKey(sourceId, helper.getSignature());, +      cacheFile = helper.getDiskCache().get(originalKey);, +        modelLoaders = helper.getModelLoaders(cacheFile);, +          modelLoader.buildLoadData(cacheFile, helper.getWidth(), helper.getHeight(),, +              helper.getOptions()).fetcher;, +        fetcher.loadData(helper.getPriority(), this);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +package com.bumptech.glide.load.engine;, +, +import com.bumptech.glide.GlideContext;, +import com.bumptech.glide.Priority;, +import com.bumptech.glide.Registry;, +import com.bumptech.glide.load.Encoder;, +import com.bumptech.glide.load.Key;, +import com.bumptech.glide.load.Options;, +import com.bumptech.glide.load.ResourceEncoder;, +import com.bumptech.glide.load.Transformation;]
[+++ b/gradle.properties, +VERSION_NAME=4.9.0-SNAPSHOT, +VERSION_MINOR=9]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +import java.util.Collections;, +import java.util.Set;, +    private static final Set<Bitmap.Config> ALLOWED_CONFIGS = Collections.singleton(Bitmap.Config.ARGB_8888);, +        pool = new LruBitmapPool(MAX_SIZE, strategy, ALLOWED_CONFIGS);, +        pool = new LruBitmapPool(3, strategy, ALLOWED_CONFIGS);, +        LruBitmapPool pool = new LruBitmapPool(100, strategy, ALLOWED_CONFIGS);, +        LruBitmapPool pool = new LruBitmapPool(100, strategy, ALLOWED_CONFIGS);, +        LruBitmapPool pool = new LruBitmapPool(MAX_SIZE, strategy, ALLOWED_CONFIGS);, +    @Test, +    public void testBitmapsWithDisallowedConfigsAreIgnored() {, +        pool = new LruBitmapPool(100, strategy, Collections.singleton(Bitmap.Config.ARGB_4444));, +, +        Bitmap bitmap = createMutableBitmap(Bitmap.Config.RGB_565);, +        pool.put(bitmap);, +, +        assertEquals(0, strategy.numPuts);, +    }, +, +    @Test, +    public void testBitmapsWithAllowedNullConfigsAreAllowed() {, +        pool = new LruBitmapPool(100, strategy, Collections.<Bitmap.Config>singleton(null));, +, +        Bitmap bitmap = createMutableBitmap();, +        Robolectric.shadowOf(bitmap).setConfig(null);, +, +        pool.put(bitmap);, +, +        assertEquals(1, strategy.numPuts);, +    }, +, +        return createMutableBitmap(Bitmap.Config.ARGB_8888);, +    }, +, +    private Bitmap createMutableBitmap(Bitmap.Config config) {, +        Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, config);, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +import java.util.Collections;, +import java.util.Set;, +    private static final Set<Bitmap.Config> ALLOWED_CONFIGS = Collections.singleton(Bitmap.Config.ARGB_8888);, +        pool = new LruBitmapPool(MAX_SIZE, strategy, ALLOWED_CONFIGS);, +        pool = new LruBitmapPool(3, strategy, ALLOWED_CONFIGS);, +        LruBitmapPool pool = new LruBitmapPool(100, strategy, ALLOWED_CONFIGS);, +        LruBitmapPool pool = new LruBitmapPool(100, strategy, ALLOWED_CONFIGS);, +        LruBitmapPool pool = new LruBitmapPool(MAX_SIZE, strategy, ALLOWED_CONFIGS);, +    @Test, +    public void testBitmapsWithDisallowedConfigsAreIgnored() {, +        pool = new LruBitmapPool(100, strategy, Collections.singleton(Bitmap.Config.ARGB_4444));, +, +        Bitmap bitmap = createMutableBitmap(Bitmap.Config.RGB_565);, +        pool.put(bitmap);, +, +        assertEquals(0, strategy.numPuts);, +    }, +, +    @Test, +    public void testBitmapsWithAllowedNullConfigsAreAllowed() {, +        pool = new LruBitmapPool(100, strategy, Collections.<Bitmap.Config>singleton(null));, +, +        Bitmap bitmap = createMutableBitmap();, +        Robolectric.shadowOf(bitmap).setConfig(null);, +, +        pool.put(bitmap);, +, +        assertEquals(1, strategy.numPuts);, +    }, +, +        return createMutableBitmap(Bitmap.Config.ARGB_8888);, +    }, +, +    private Bitmap createMutableBitmap(Bitmap.Config config) {, +        Bitmap bitmap = ShadowBitmap.createBitmap(100, 100, config);, +, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import android.graphics.Bitmap;, +import java.util.Collections;, +                int size = calculator.getBitmapPoolSize();, +                if (DecodeFormat.REQUIRE_ARGB_8888) {, +                    bitmapPool = new LruBitmapPool(size, Collections.singleton(Bitmap.Config.ARGB_8888));, +                } else {, +                    bitmapPool = new LruBitmapPool(size);, +                }, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +import java.util.Collections;, +import java.util.Set;, +    private static final Set<Bitmap.Config> ALLOWED_CONFIGS = Collections.singleton(Bitmap.Config.ARGB_8888);, +        pool = new LruBitmapPool(MAX_SIZE, strategy, ALLOWED_CONFIGS);, +        pool = new LruBitmapPool(3, strategy, ALLOWED_CONFIGS);, +        LruBitmapPool pool = new LruBitmapPool(100, strategy, ALLOWED_CONFIGS);, +        LruBitmapPool pool = new LruBitmapPool(100, strategy, ALLOWED_CONFIGS);, +        LruBitmapPool pool = new LruBitmapPool(MAX_SIZE, strategy, ALLOWED_CONFIGS);, +    @Test, +    public void testBitmapsWithDisallowedConfigsAreIgnored() {, +        pool = new LruBitmapPool(100, strategy, Collections.singleton(Bitmap.Config.ARGB_4444));, +, +        Bitmap bitmap = createMutableBitmap(Bitmap.Config.RGB_565);, +        pool.put(bitmap);, +, +        assertEquals(0, strategy.numPuts);]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +      throw new IllegalArgumentException("You must call #load() before calling #into()");]
[+++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java, +    private final String stringUrl;, +    private String safeStringUrl;, +        if (headers == null) {, +            throw new IllegalArgumentException("Headers must not be null");, +        }, +        if (headers == null) {, +            throw new IllegalArgumentException("Headers must not be null");, +        }, +        if (safeUrl == null) {, +        }, +        if (TextUtils.isEmpty(safeStringUrl)) {, +            String unsafeStringUrl = stringUrl;, +            if (TextUtils.isEmpty(unsafeStringUrl)) {, +                unsafeStringUrl = url.toString();, +            safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);, +        }, +        return safeStringUrl;, +        for (Map.Entry<String, String> entry : headerMap.entrySet()) {, +            stringBuilder.append('\n'), +                .append(entry.getKey()), +                .append(entry.getValue());, +        if (o instanceof GlideUrl) {, +          GlideUrl other = (GlideUrl) o;, +          return getSafeStringUrl().equals(other.getSafeStringUrl()), +              && headers.equals(other.headers);, +        int hashCode = getSafeStringUrl().hashCode();, +        hashCode = 31 * hashCode + headers.hashCode();, +        return hashCode;, +++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java, +    private final String stringUrl;, +    private String safeStringUrl;, +        if (headers == null) {, +            throw new IllegalArgumentException("Headers must not be null");, +        }, +        if (headers == null) {, +            throw new IllegalArgumentException("Headers must not be null");, +        }, +        if (safeUrl == null) {, +        }, +        if (TextUtils.isEmpty(safeStringUrl)) {, +            String unsafeStringUrl = stringUrl;, +            if (TextUtils.isEmpty(unsafeStringUrl)) {, +                unsafeStringUrl = url.toString();, +            safeStringUrl = Uri.encode(unsafeStringUrl, ALLOWED_URI_CHARS);, +        }, +        return safeStringUrl;, +        for (Map.Entry<String, String> entry : headerMap.entrySet()) {, +            stringBuilder.append('\n'), +                .append(entry.getKey()), +                .append(entry.getValue());, +        if (o instanceof GlideUrl) {, +          GlideUrl other = (GlideUrl) o;, +          return getSafeStringUrl().equals(other.getSafeStringUrl()), +              && headers.equals(other.headers);, +        int hashCode = getSafeStringUrl().hashCode();, +        hashCode = 31 * hashCode + headers.hashCode();, +        return hashCode;, +++ b/library/src/main/java/com/bumptech/glide/load/model/Headers.java, +import android.text.TextUtils;, +, +public final class Headers {, +    Headers(Map<String, Set<String>> headers) {, +                    this.combinedHeaders = generateCombinedHeaders();, +    private Map<String, String> generateCombinedHeaders() {, +        Map<String, String> combinedHeaders = new HashMap<String, String>();, +        for (Map.Entry<String, Set<String>> entry : headers.entrySet()) {, +            combinedHeaders.put(entry.getKey(), TextUtils.join(",", entry.getValue()));, +        }, +        return Collections.unmodifiableMap(combinedHeaders);, +    }, +, +    public static final class Builder {, +        private final Map<String, Set<String>> headers = new HashMap<String, Set<String>>();, +                Set<String> values = new HashSet<String>();, +, +    @Override, +    public boolean equals(Object o) {, +        if (o instanceof Headers) {, +            Headers other = (Headers) o;, +            return headers.equals(other.headers);, +        }, +        return false;, +    }, +, +    @Override, +    public int hashCode() {, +        return headers.hashCode();, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java, +    private final String stringUrl;, +    private String safeStringUrl;, +        if (headers == null) {, +            throw new IllegalArgumentException("Headers must not be null");, +        }, +        if (headers == null) {, +            throw new IllegalArgumentException("Headers must not be null");, +        }, +        if (safeUrl == null) {, +        }]
[+++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.bitmap.ImageVideoBitmapLoadFactory;, +                throw new NullPointerException("Context can't be null");, +                    .setBitmapLoadFactory(new ImageVideoBitmapLoadFactory<ModelType, ImageResourceType, VideoResourceType>(, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.bitmap.ImageVideoBitmapLoadFactory;, +                throw new NullPointerException("Context can't be null");, +                    .setBitmapLoadFactory(new ImageVideoBitmapLoadFactory<ModelType, ImageResourceType, VideoResourceType>(, +++ /dev/null, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.bitmap.ImageVideoBitmapLoadFactory;, +                throw new NullPointerException("Context can't be null");, +                    .setBitmapLoadFactory(new ImageVideoBitmapLoadFactory<ModelType, ImageResourceType, VideoResourceType>(, +++ /dev/null, +++ b/library/src/com/bumptech/glide/loader/bitmap/BitmapLoadFactory.java, +import com.bumptech.glide.resize.BitmapLoad;, + * An interface for providing a {@link BitmapLoad} to load a bitmap for a given model, width, and height., + * @param <T> The type of the model to return a {@link BitmapLoad} for., +     * Returns a {@link BitmapLoad} that can fetch and decode a {@link Bitmap} for a given model., +    public BitmapLoad getLoadTask(T model, int width, int height);, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.bitmap.ImageVideoBitmapLoadFactory;, +                throw new NullPointerException("Context can't be null");, +                    .setBitmapLoadFactory(new ImageVideoBitmapLoadFactory<ModelType, ImageResourceType, VideoResourceType>(, +++ /dev/null, +++ b/library/src/com/bumptech/glide/loader/bitmap/BitmapLoadFactory.java, +import com.bumptech.glide.resize.BitmapLoad;, + * An interface for providing a {@link BitmapLoad} to load a bitmap for a given model, width, and height., + * @param <T> The type of the model to return a {@link BitmapLoad} for., +     * Returns a {@link BitmapLoad} that can fetch and decode a {@link Bitmap} for a given model., +    public BitmapLoad getLoadTask(T model, int width, int height);, +++ b/library/src/com/bumptech/glide/loader/bitmap/ImageVideoBitmapLoadFactory.java, +package com.bumptech.glide.loader.bitmap;, +, +import com.bumptech.glide.loader.bitmap.model.ModelLoader;, +import com.bumptech.glide.loader.bitmap.resource.ResourceFetcher;, +import com.bumptech.glide.loader.bitmap.transformation.None;, +import com.bumptech.glide.loader.bitmap.transformation.TransformationLoader;, +import com.bumptech.glide.resize.BitmapLoad;, +import com.bumptech.glide.resize.ImageVideoBitmapLoad;, +import com.bumptech.glide.resize.load.BitmapDecoder;, +import com.bumptech.glide.resize.load.Transformation;, +, +/**, + * A base {@link BitmapLoadFactory} that composes {@link ModelLoader} and {@link BitmapDecoder} sub-components, + * to create an {@link BitmapLoad} capable of loading a model that represents either an image or a video., + *, + * @param <T> The type of the model., + * @param <Y> The type of the resource that the image {@link ModelLoader} provides and the image {@link BitmapDecoder} can, + *           decode.`, + * @param <Z> The type of resource that the video {@link ModelLoader} provides and the video {@link BitmapDecoder} can, + *           decode., + */, +public class ImageVideoBitmapLoadFactory<T, Y, Z> implements BitmapLoadFactory<T> {, +    private final ModelLoader<T, Y> imageModelLoader;, +    private final BitmapDecoder<Y> imageDecoder;, +    private final ModelLoader<T, Z> videoModelLoader;, +    private final BitmapDecoder<Z> videoDecoder;, +    private final TransformationLoader<T> transformationLoader;, +, +    @SuppressWarnings("unused"), +    public ImageVideoBitmapLoadFactory(ModelLoader<T, Y> imageModelLoader, BitmapDecoder<Y> imageDecoder) {, +        this(imageModelLoader, imageDecoder, null, null, new None<T>());, +    }, +, +    @SuppressWarnings("unused"), +    public ImageVideoBitmapLoadFactory(ModelLoader<T, Y> imageModelLoader, BitmapDecoder<Y> imageDecoder,, +            TransformationLoader<T> transformationLoader) {, +        this(imageModelLoader, imageDecoder, null, null, transformationLoader);, +    }, +, +    public ImageVideoBitmapLoadFactory(ModelLoader<T, Y> imageModelLoader, BitmapDecoder<Y> imageDecoder,, +            ModelLoader<T, Z> videoModelLoader, BitmapDecoder<Z> videoDecoder,, +            TransformationLoader<T> transformationLoader) {, +        if ((imageModelLoader == null || imageDecoder == null), +                && (videoModelLoader == null || videoDecoder == null)) {, +            throw new IllegalArgumentException("You must provide at least a video model loader and a video decoder or" +, +                    "an image model loader and an image decoder");, +        }, +        if (transformationLoader == null) {, +            throw new IllegalArgumentException("You must provide a non null transformation loader");, +        }, +        this.imageModelLoader = imageModelLoader;, +        this.imageDecoder = imageDecoder;, +        this.videoModelLoader = videoModelLoader;, +        this.videoDecoder = videoDecoder;, +        this.transformationLoader = transformationLoader;, +    }, +, +    @Override, +    public BitmapLoad getLoadTask(T model, int width, int height) {, +        ResourceFetcher<Y> imageFetcher = null;, +        if (imageModelLoader != null) {, +            imageFetcher = imageModelLoader.getResourceFetcher(model, width, height);, +        }, +        ResourceFetcher<Z> videoFetcher = null;, +        if (videoModelLoader != null) {, +            videoFetcher = videoModelLoader.getResourceFetcher(model, width, height);, +        }, +        Transformation transformation = transformationLoader.getTransformation(model);]
[+++ b/src/com/bumptech/photos/imagemanager/ImageResizer.java, +/*, + * Copyright (c) 2012 Bump Technologies Inc. All rights reserved., + */, +package com.bumptech.photos.imagemanager;, +, +import android.graphics.Bitmap;, +import android.graphics.BitmapFactory;, +import android.graphics.Canvas;, +import android.graphics.Matrix;, +import android.graphics.Paint;, +import android.os.Build;, +import com.bumptech.photos.imagemanager.cache.SizedBitmapCache;, +import com.bumptech.photos.util.Log;, +import com.bumptech.photos.util.Photo;, +, +import java.io.BufferedInputStream;, +import java.io.FileInputStream;, +import java.io.FileNotFoundException;, +import java.io.IOException;, +import java.io.InputStream;, +, +/**, + * @author sam, + *, + */, +public class ImageResizer {, +, +    private final SizedBitmapCache bitmapCache;, +, +    public ImageResizer() {, +        this(null);, +    }, +, +    public ImageResizer(SizedBitmapCache bitmapCache){, +        this.bitmapCache = bitmapCache;, +    }, +, +    public Bitmap resizeCenterCrop(final String path, final int width, final int height){, +        final Bitmap streamed = streamIn(path, width, height);, +, +        if (streamed.getWidth() == width && streamed.getHeight() == height) {, +            return streamed;, +        }, +, +        return centerCrop(getRecycled(width, height), streamed, width, height);, +    }, +, +    public Bitmap fitInSpace(final String path, final int width, final int height){, +        final Bitmap streamed = streamIn(path, width > height ? 1 : width, height > width ? 1 : height);, +        return fitInSpace(streamed, width, height);, +    }, +, +    public Bitmap loadApproximate(final String path, final int width, final int height){, +        return streamIn(path, width, height);, +    }, +, +    public Bitmap loadAsIs(final InputStream is1, final InputStream is2) {, +        int[] dimens = new int[] {-1, -1};, +        try {, +            dimens = getDimension(is1);, +        } finally {, +            try {, +                is1.close();, +            } catch (IOException e) {, +                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates., +            }, +        }, +        Bitmap resized = null;, +        try {, +            resized = load(is2, getRecycled(dimens));, +        } finally {, +            try {, +                is2.close();, +            } catch (IOException e) {, +                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates., +            }, +        }, +        return resized;, +    }, +, +    public Bitmap loadAsIs(final String path, final int width, final int height) {, +        return load(path, getRecycled(width, height));, +    }, +, +    public Bitmap loadAsIs(final String path){, +        int[] dimens = getDimensions(path);, +        return load(path, getRecycled(dimens));, +    }, +, +    private Bitmap getRecycled(int[] dimens) {, +        return getRecycled(dimens[0], dimens[1]);, +    }, +, +    private Bitmap getRecycled(int width, int height) {, +        Bitmap result = null;, +        if (bitmapCache != null) {, +            result = bitmapCache.get(width, height);, +        }, +        return result;]
[+++ b/third_party/gif_decoder/build.gradle, +apply plugin: 'robolectric', +, +dependencies {, +    androidTestCompile 'org.hamcrest:hamcrest-core:1.3', +    androidTestCompile 'org.hamcrest:hamcrest-library:1.3', +    androidTestCompile 'junit:junit:4.11', +    androidTestCompile 'org.mockito:mockito-all:1.9.5', +}, +++ b/third_party/gif_decoder/build.gradle, +apply plugin: 'robolectric', +, +dependencies {, +    androidTestCompile 'org.hamcrest:hamcrest-core:1.3', +    androidTestCompile 'org.hamcrest:hamcrest-library:1.3', +    androidTestCompile 'junit:junit:4.11', +    androidTestCompile 'org.mockito:mockito-all:1.9.5', +}, +++ b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java, +package com.bumptech.glide.gifdecoder;, +, +import com.bumptech.glide.gifdecoder.test.GifBytesTestUtil;, +import org.junit.Before;, +import org.junit.Test;, +, +import java.io.ByteArrayOutputStream;, +import java.io.IOException;, +import java.io.InputStream;, +import java.nio.ByteBuffer;, +import java.nio.ByteOrder;, +, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertNotNull;, +, +/**, + * Tests for {@link com.bumptech.glide.gifdecoder.GifHeaderParser}., + */, +public class GifHeaderParserTest {, +    private GifHeaderParser parser;, +, +    @Before, +    public void setUp() {, +        parser = new GifHeaderParser();, +    }, +, +    @Test, +    public void testReturnsHeaderWithFormatErrorIfDoesNotStartWithGifHeader() {, +        parser.setData("wrong_header".getBytes());, +        GifHeader result = parser.parseHeader();, +        assertEquals(GifDecoder.STATUS_FORMAT_ERROR, result.status);, +    }, +, +    @Test, +    public void testCanReadValidHeaderAndLSD() {, +        final int width = 10;, +        final int height = 20;, +        ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH).order(ByteOrder.LITTLE_ENDIAN);, +        GifBytesTestUtil.writeHeaderAndLsd(buffer, width, height, false, 0);, +, +        parser.setData(buffer.array());, +        GifHeader header = parser.parseHeader();, +        assertEquals(width, header.width);, +        assertEquals(height, header.height);, +        assertFalse(header.gctFlag);, +        // 2^(1+0) == 2^1 == 2., +        assertEquals(2, header.gctSize);, +        assertEquals(0, header.bgIndex);, +        assertEquals(0, header.pixelAspect);, +    }, +, +    @Test, +    public void testCanParseHeaderOfTestImageWithoutGraphicalExtension() throws IOException {, +        byte[] data = readResourceData("gif_without_graphical_control_extension.gif");, +        parser.setData(data);, +        GifHeader header = parser.parseHeader();, +        assertEquals(1, header.frameCount);, +        assertNotNull(header.frames.get(0));, +        assertEquals(GifDecoder.STATUS_OK, header.status);, +    }, +, +    @Test, +    public void testCanReadImageDescriptorWithoutGraphicalExtension() {, +        ByteBuffer buffer = ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH, +                + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH + 4).order(ByteOrder.LITTLE_ENDIAN);, +        GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);, +        GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1);, +        GifBytesTestUtil.writeFakeImageData(buffer, 2);, +, +        parser.setData(buffer.array());, +        GifHeader header = parser.parseHeader();, +        assertEquals(1, header.width);, +        assertEquals(1, header.height);, +        assertEquals(1, header.frameCount);, +        assertNotNull(header.frames.get(0));, +    }, +, +    private InputStream openResource(String imageName) throws IOException {, +        return getClass().getResourceAsStream("/" + imageName);, +    }]
[+++ b/.idea/codeStyleSettings.xml, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/build.gradle, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/gradle.properties]
[+++ b/.travis.yml, +- ./gradlew jacocoTestReport coveralls, +++ b/.travis.yml, +- ./gradlew jacocoTestReport coveralls, +++ b/build.gradle, +        classpath "org.kt3k.gradle.plugin:coveralls-gradle-plugin:${COVERALLS_GRADLE_VERSION}", +++ b/.travis.yml, +- ./gradlew jacocoTestReport coveralls, +++ b/build.gradle, +        classpath "org.kt3k.gradle.plugin:coveralls-gradle-plugin:${COVERALLS_GRADLE_VERSION}", +++ b/gradle.properties, +COVERALLS_GRADLE_VERSION=2.0.1, +++ b/.travis.yml, +- ./gradlew jacocoTestReport coveralls, +++ b/build.gradle, +        classpath "org.kt3k.gradle.plugin:coveralls-gradle-plugin:${COVERALLS_GRADLE_VERSION}", +++ b/gradle.properties, +COVERALLS_GRADLE_VERSION=2.0.1, +++ b/library/build.gradle, +apply plugin: 'jacoco', +apply plugin: 'com.github.kt3k.coveralls', +jacoco {, +    toolVersion = "0.7.1.201405082137", +}, +coveralls {, +    jacocoReportPath = 'build/reports/jacoco/jacocoTestReport/jacocoTestReport.xml', +}, +, +    buildTypes {, +        debug {, +            testCoverageEnabled = true, +        }, +    }, +, +    task jacocoTestReport(type:JacocoReport, dependsOn: testDebug) {, +        def coverageSourceDirs = ['src/main/java'], +        group = "Reporting", +, +        description = "Generate Jacoco coverage reports", +, +        classDirectories = fileTree(, +                dir: 'build/intermediates/classes/debug',, +                excludes: ['**/R.class',, +                           '**/R$*.class',, +                           '**/*$ViewInjector*.*',, +                           '**/BuildConfig.*',, +                           '**/Manifest*.*'], +        ), +, +        additionalSourceDirs = files(coverageSourceDirs), +        sourceDirectories = files(coverageSourceDirs), +        executionData = files('build/jacoco/testDebug.exec'), +, +        reports {, +            xml.enabled = true, +            html.enabled = true, +        }, +    }]
[+++ b/.idea/codeStyleSettings.xml, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MAJOR=3, +VERSION_MINOR=6, +VERSION_CODE=11, +SUPPORT_V4_VERSION=19.1.0, +SUPPORT_V7_VERSION=19.1.0, +# TODO: Upgrade to latest version of Volley when we compile with Java 7., +VOLLEY_VERSION=1.0.8, +ANDROID_GRADLE_VERSION=1.0.0, +ROBOLECTRIC_GRADLE_VERSION=0.14.0, +ROBOLECTRIC_VERSION=2.4, +MOCKWEBSERVER_VERSION=1.6.0, +COMPILE_SDK_VERSION=19, +BUILD_TOOLS_VERSION=19.1.0, +TARGET_SDK_VERSION=19, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +  private static final BaseRequestOptions<?> DOWNLOAD_ONLY_OPTIONS =, +  /**, +   * Applies the given options to the request, options set or unset in the given options will, +   * replace those previously set in options in this class., +   *, +   * @see BaseRequestOptions#apply(BaseRequestOptions), +   * @return This request builder., +   */, +  public RequestBuilder<TranscodeType> apply(@NonNull BaseRequestOptions<?> requestOptions) {, +  /**, +   * Sets the {@link TransitionOptions} to use to transition from the placeholder or thumbnail when, +   * this load completes., +   *, +   * <p>The given {@link TransitionOptions} will replace any {@link TransitionOptions} set, +   * previously., +   *, +   * @return This request builder., +   */, +      @NonNull TransitionOptions<?, ? super TranscodeType> transitionOptions) {, +  public <Y extends Target<TranscodeType>> Y into(@NonNull Y target) {, +    Preconditions.checkNotNull(target);, +    Preconditions.checkNotNull(view);, +    return getDownloadOnlyRequest().submit(width, height);, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +  private static final BaseRequestOptions<?> DOWNLOAD_ONLY_OPTIONS =, +  /**, +   * Applies the given options to the request, options set or unset in the given options will, +   * replace those previously set in options in this class., +   *, +   * @see BaseRequestOptions#apply(BaseRequestOptions), +   * @return This request builder., +   */, +  public RequestBuilder<TranscodeType> apply(@NonNull BaseRequestOptions<?> requestOptions) {, +  /**, +   * Sets the {@link TransitionOptions} to use to transition from the placeholder or thumbnail when, +   * this load completes., +   *, +   * <p>The given {@link TransitionOptions} will replace any {@link TransitionOptions} set, +   * previously., +   *, +   * @return This request builder., +   */, +      @NonNull TransitionOptions<?, ? super TranscodeType> transitionOptions) {, +  public <Y extends Target<TranscodeType>> Y into(@NonNull Y target) {, +    Preconditions.checkNotNull(target);, +    Preconditions.checkNotNull(view);, +    return getDownloadOnlyRequest().submit(width, height);, +++ b/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java, +  @Test(expected = NullPointerException.class), +  @Test(expected = NullPointerException.class)]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillIdleHandlerTest.java, +package com.bumptech.glide.load.engine.prefill;, +, +import android.graphics.Bitmap;, +import com.bumptech.glide.load.Key;, +import com.bumptech.glide.load.engine.Resource;, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import com.bumptech.glide.load.engine.cache.MemoryCache;, +import com.bumptech.glide.load.resource.bitmap.BitmapResource;, +import com.bumptech.glide.util.Util;, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.mockito.InOrder;, +import org.mockito.invocation.InvocationOnMock;, +import org.mockito.stubbing.Answer;, +import org.robolectric.RobolectricTestRunner;, +, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +, +import static org.hamcrest.MatcherAssert.assertThat;, +import static org.hamcrest.Matchers.contains;, +import static org.hamcrest.Matchers.hasSize;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertNotEquals;, +import static org.junit.Assert.assertTrue;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.inOrder;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.never;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, +@RunWith(RobolectricTestRunner.class), +public class BitmapPreFillIdleHandlerTest {, +    private BitmapPreFillIdleHandler.Clock clock;, +    private BitmapPool pool;, +    private MemoryCache cache;, +    private List<Bitmap> addedBitmaps = new ArrayList<Bitmap>();, +, +    @Before, +    public void setUp() {, +        clock = mock(BitmapPreFillIdleHandler.Clock.class);, +, +        pool = mock(BitmapPool.class);, +        when(pool.put(any(Bitmap.class))).thenAnswer(new AddBitmapPoolAnswer(addedBitmaps));, +        cache = mock(MemoryCache.class);, +        when(cache.put(any(Key.class), any(Resource.class))).thenAnswer(new AddBitmapCacheAnswer(addedBitmaps));, +    }, +, +    private BitmapPreFillIdleHandler getHandler(Map<PreFillType, Integer> allocationOrder) {, +        return new BitmapPreFillIdleHandler(pool, cache, new PreFillQueue(allocationOrder), clock);, +    }, +, +    @Test, +    public void testAllocatesABitmapPerSizeInAllocationOrder() {, +        PreFillType size = new PreFillType.Builder(100), +                .setConfig(Bitmap.Config.ARGB_8888), +                .build();, +        final int toAdd = 3;, +        Map<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();, +        allocationOrder.put(size, toAdd);, +        BitmapPreFillIdleHandler handler = getHandler(allocationOrder);, +        handler.queueIdle();, +, +        Bitmap expected = Bitmap.createBitmap(size.getWidth(), size.getHeight(), size.getConfig());, +        assertThat(addedBitmaps, contains(expected, expected, expected));, +    }, +, +    @Test, +    public void testAllocatesBitmapsInOrderGivenByAllocationOrder() {, +        PreFillType smallWidth = new PreFillType.Builder(50, 100), +                .setConfig(Bitmap.Config.ARGB_8888), +                .build();, +        PreFillType smallHeight = new PreFillType.Builder(100, 50), +                .setConfig(Bitmap.Config.RGB_565), +                .build();, +, +        PreFillType[] expectedOrder = new PreFillType[] {, +                smallWidth,, +                smallHeight,, +                smallWidth,, +                smallHeight,, +        };, +, +        HashMap<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();, +        allocationOrder.put(smallWidth, 2);, +        allocationOrder.put(smallHeight, 2);, +        BitmapPreFillIdleHandler handler = getHandler(allocationOrder);, +        handler.queueIdle();, +, +, +        Bitmap[] expectedBitmaps = new Bitmap[expectedOrder.length];, +        for (int i = 0; i < expectedBitmaps.length; i++) {, +            PreFillType current = expectedOrder[i];]
[+++ b/gradle.properties, +VERSION_NAME=4.2.0-SNAPSHOT, +VERSION_MINOR=2, +VERSION_PATCH=0]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, +import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNull;, +, +import com.squareup.javapoet.ParameterSpec;, +, +            .addParameter(ParameterSpec.builder(, +                ClassName.get("android.content", "Context"), "context"), +                .addAnnotation(nonNull()), +                .build(), +            ), +            .addParameter(ParameterSpec.builder(, +                ClassName.get("com.bumptech.glide", "GlideBuilder"), "builder"), +                .addAnnotation(nonNull()), +                .build(), +            ), +            .addAnnotation(nonNull()), +        .addAnnotation(nonNull()), +            .addParameter(ParameterSpec.builder(, +                ClassName.get("android.content", "Context"), "context"), +                .addAnnotation(nonNull()), +                .build(), +            ), +            .addParameter(ParameterSpec.builder(, +                ClassName.get("com.bumptech.glide", "Glide"), "glide"), +                .addAnnotation(nonNull()), +                .build(), +            ), +            .addParameter(ParameterSpec.builder(, +                ClassName.get("com.bumptech.glide", "Registry"), "registry"), +                .addAnnotation(nonNull()), +                .build(), +            );, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, +import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNull;, +, +import com.squareup.javapoet.ParameterSpec;, +, +            .addParameter(ParameterSpec.builder(, +                ClassName.get("android.content", "Context"), "context"), +                .addAnnotation(nonNull()), +                .build(), +            ), +            .addParameter(ParameterSpec.builder(, +                ClassName.get("com.bumptech.glide", "GlideBuilder"), "builder"), +                .addAnnotation(nonNull()), +                .build(), +            ), +            .addAnnotation(nonNull()), +        .addAnnotation(nonNull()), +            .addParameter(ParameterSpec.builder(, +                ClassName.get("android.content", "Context"), "context"), +                .addAnnotation(nonNull()), +                .build(), +            ), +            .addParameter(ParameterSpec.builder(, +                ClassName.get("com.bumptech.glide", "Glide"), "glide"), +                .addAnnotation(nonNull()), +                .build(), +            ), +            .addParameter(ParameterSpec.builder(, +                ClassName.get("com.bumptech.glide", "Registry"), "registry"), +                .addAnnotation(nonNull()), +                .build(), +            );, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNull;, +, +    if (!annotationNames.contains(nonNull().reflectionName())) {, +              + " is missing the " + nonNull().reflectionName() + " annotation,", +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, +import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNull;, +, +import com.squareup.javapoet.ParameterSpec;, +, +            .addParameter(ParameterSpec.builder(, +                ClassName.get("android.content", "Context"), "context"), +                .addAnnotation(nonNull()), +                .build(), +            ), +            .addParameter(ParameterSpec.builder(, +                ClassName.get("com.bumptech.glide", "GlideBuilder"), "builder"), +                .addAnnotation(nonNull()), +                .build(), +            ), +            .addAnnotation(nonNull()), +        .addAnnotation(nonNull()), +            .addParameter(ParameterSpec.builder(, +                ClassName.get("android.content", "Context"), "context"), +                .addAnnotation(nonNull()), +                .build(), +            ), +            .addParameter(ParameterSpec.builder(, +                ClassName.get("com.bumptech.glide", "Glide"), "glide"), +                .addAnnotation(nonNull()), +                .build(), +            ), +            .addParameter(ParameterSpec.builder(, +                ClassName.get("com.bumptech.glide", "Registry"), "registry"), +                .addAnnotation(nonNull()), +                .build()]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.support.annotation.VisibleForTesting;, +  @VisibleForTesting, +  public static void tearDown() {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.support.annotation.VisibleForTesting;, +  @VisibleForTesting, +  public static void tearDown() {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +import com.bumptech.glide.Glide;, +    this(, +        new GifState(, +            bitmapPool,, +            new GifFrameLoader(, +                // TODO(b/27524013): Factor out this call to Glide.get(), +                Glide.get(context),, +                gifDecoder,, +                targetFrameWidth,, +                targetFrameHeight,, +                frameTransformation,, +                firstFrame)));, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.support.annotation.VisibleForTesting;, +  @VisibleForTesting, +  public static void tearDown() {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +import com.bumptech.glide.Glide;, +    this(, +        new GifState(, +            bitmapPool,, +            new GifFrameLoader(, +                // TODO(b/27524013): Factor out this call to Glide.get(), +                Glide.get(context),, +                gifDecoder,, +                targetFrameWidth,, +                targetFrameHeight,, +                frameTransformation,, +                firstFrame)));, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +  private final BitmapPool bitmapPool;, +  public GifFrameLoader(, +      Glide glide,, +      GifDecoder gifDecoder,, +      int width,, +      int height,, +      Transformation<Bitmap> transformation,, +      Bitmap firstFrame) {, +    this(, +        glide.getContext(),, +        glide.getBitmapPool(),, +        Glide.with(glide.getContext()),, +        getRequestBuilder(Glide.with(glide.getContext()), width, height),, +        transformation,, +        firstFrame);, +  GifFrameLoader(, +      Context context,, +      BitmapPool bitmapPool,, +      RequestManager requestManager,, +      GifDecoder gifDecoder,, +      Handler handler,, +      RequestBuilder<Bitmap> requestBuilder,, +      Transformation<Bitmap> transformation,, +    this.bitmapPool = bitmapPool;, +      bitmapPool.put(firstFrame);, +  private static RequestBuilder<Bitmap> getRequestBuilder(, +      RequestManager requestManager, int width, int height) {, +    return requestManager, +        .asBitmap(), +        .apply(, +            diskCacheStrategyOf(DiskCacheStrategy.NONE), +                .skipMemoryCache(true), +                .override(width, height));, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.support.annotation.VisibleForTesting;, +  @VisibleForTesting, +  public static void tearDown() {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +import com.bumptech.glide.Glide;, +    this(, +        new GifState(, +            bitmapPool,, +            new GifFrameLoader(, +                // TODO(b/27524013): Factor out this call to Glide.get(), +                Glide.get(context),, +                gifDecoder,, +                targetFrameWidth,, +                targetFrameHeight,, +                frameTransformation,, +                firstFrame)));, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +  private final BitmapPool bitmapPool;, +  public GifFrameLoader(, +      Glide glide,, +      GifDecoder gifDecoder,, +      int width,, +      int height,, +      Transformation<Bitmap> transformation,, +      Bitmap firstFrame) {]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +  public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +  public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {, +    request = requestFactory.create(url.toString(), callback, glideToVolleyPriority(priority));, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +  public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {, +    request = requestFactory.create(url.toString(), callback, glideToVolleyPriority(priority));, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +    doAnswer(new Util.CallDataReady(null)), +        .when(failFetcher), +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +  public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {, +    request = requestFactory.create(url.toString(), callback, glideToVolleyPriority(priority));, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +    doAnswer(new Util.CallDataReady(null)), +        .when(failFetcher), +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java, +import static org.mockito.Matchers.isNull;, +  public void testFailsOnRedirectLoops() throws Exception {, +, +    verify(callback).onDataReady(isNull(InputStream.class));, +  public void testFailsIfRedirectLocationIsNotPresent() throws Exception {, +, +    verify(callback).onDataReady(isNull(InputStream.class));, +  public void testFailsIfRedirectLocationIsPresentAndEmpty() throws Exception {, +, +    verify(callback).onDataReady(isNull(InputStream.class));, +  @Test, +  public void testFailsIfStatusCodeIsNegativeOne() throws Exception {, +, +    verify(callback).onDataReady(isNull(InputStream.class));, +  @Test, +  public void testFailsAfterTooManyRedirects() throws Exception {, +, +    verify(callback).onDataReady(isNull(InputStream.class));, +  @Test, +  public void testFailsIfStatusCodeIs500() throws Exception {, +, +    verify(callback).onDataReady(isNull(InputStream.class));, +  @Test, +  public void testFailsIfStatusCodeIs400() throws Exception {, +, +    verify(callback).onDataReady(isNull(InputStream.class));, +  @Test, +, +    verify(callback).onDataReady(isNull(InputStream.class));, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +  public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {, +    request = requestFactory.create(url.toString(), callback, glideToVolleyPriority(priority));, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +    doAnswer(new Util.CallDataReady(null)), +        .when(failFetcher), +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java, +import static org.mockito.Matchers.isNull;, +  public void testFailsOnRedirectLoops() throws Exception {, +, +    verify(callback).onDataReady(isNull(InputStream.class));, +  public void testFailsIfRedirectLocationIsNotPresent() throws Exception {, +, +    verify(callback).onDataReady(isNull(InputStream.class));, +  public void testFailsIfRedirectLocationIsPresentAndEmpty() throws Exception {, +, +    verify(callback).onDataReady(isNull(InputStream.class));, +  @Test, +  public void testFailsIfStatusCodeIsNegativeOne() throws Exception {, +, +    verify(callback).onDataReady(isNull(InputStream.class));, +  @Test, +  public void testFailsAfterTooManyRedirects() throws Exception {, +, +    verify(callback).onDataReady(isNull(InputStream.class));, +  @Test, +  public void testFailsIfStatusCodeIs500() throws Exception {, +, +    verify(callback).onDataReady(isNull(InputStream.class));, +  @Test, +  public void testFailsIfStatusCodeIs400() throws Exception {, +, +    verify(callback).onDataReady(isNull(InputStream.class));, +  @Test, +, +    verify(callback).onDataReady(isNull(InputStream.class));, +++ b/library/src/androidTest/java/com/bumptech/glide/tests/Util.java, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +  public void loadData(Priority priority, final DataCallback<? super InputStream> callback) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +  public void loadData(Priority priority, DataCallback<? super InputStream> callback) {, +    request = requestFactory.create(url.toString(), callback, glideToVolleyPriority(priority));, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +    doAnswer(new Util.CallDataReady(null)), +        .when(failFetcher)]
[+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java, +    private static final int MAX_BLOCK_SIZE = 256;, +    private final byte[] block = new byte[MAX_BLOCK_SIZE];, +    private void readContents() {, +    private void readGraphicControlExt() {, +    private void readBitmap() {, +        skipImageData();, +    private void readNetscapeExt() {, +    private void readLSD() {, +    private int[] readColorTable(int ncolors) {, +            // TODO: what bounds checks are we avoiding if we know the number of colors?, +            tab = new int[MAX_BLOCK_SIZE];, +     * Skips LZW image data for a single frame to advance buffer., +    private void skipImageData() {, +        // lzwMinCodeSize, +        read();, +        // data sub-blocks, +        skip();, +    private void skip() {, +        int blockSize;, +            blockSize = read();, +            rawData.position(rawData.position() + blockSize);, +        } while (blockSize > 0);, +    private int readBlock() {, +    private int readShort() {]
[+++ b/checkstyle.xml, +        <module name="AvoidNestedBlocks">, +          <property name="allowInSwitchCase" value="true" />, +        </module>, +++ b/checkstyle.xml, +        <module name="AvoidNestedBlocks">, +          <property name="allowInSwitchCase" value="true" />, +        </module>, +++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java, +import android.Manifest.permission;, +import android.annotation.TargetApi;, +import android.content.pm.PackageManager;, +import android.os.Build;, +import android.support.annotation.NonNull;, +import android.support.v4.app.ActivityCompat;, +import android.support.v4.app.Fragment;, +import android.support.v4.content.ContextCompat;, +import android.widget.Toast;, +  private static final int REQUEST_READ_STORAGE = 0;, +, +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M, +        && ContextCompat.checkSelfPermission(this, permission.READ_EXTERNAL_STORAGE), +        != PackageManager.PERMISSION_GRANTED) {, +      requestStoragePermission();, +    } else {, +      replaceFragment();, +    }, +  }, +, +  @TargetApi(Build.VERSION_CODES.JELLY_BEAN), +  private void requestStoragePermission() {, +     ActivityCompat.requestPermissions(this,, +        new String[]{permission.READ_EXTERNAL_STORAGE},, +        REQUEST_READ_STORAGE);, +  }, +, +  private void replaceFragment() {, +    Fragment fragment = new HorizontalGalleryFragment();, +    getSupportFragmentManager(), +        .beginTransaction(), +        .replace(R.id.fragment_container, fragment), +        .commit();, +  }, +, +  @Override, +  public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,, +      @NonNull int[] grantResults) {, +    super.onRequestPermissionsResult(requestCode, permissions, grantResults);, +    switch (requestCode) {, +      case REQUEST_READ_STORAGE: {, +        // If request is cancelled, the result arrays are empty., +        if (grantResults.length > 0, +            && grantResults[0] == PackageManager.PERMISSION_GRANTED) {, +          replaceFragment();, +        } else {, +          Toast.makeText(this, "Storage permission is required", Toast.LENGTH_LONG), +              .show();, +          requestStoragePermission();, +        }, +      }, +    }, +++ b/checkstyle.xml, +        <module name="AvoidNestedBlocks">, +          <property name="allowInSwitchCase" value="true" />, +        </module>, +++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/MainActivity.java, +import android.Manifest.permission;, +import android.annotation.TargetApi;, +import android.content.pm.PackageManager;, +import android.os.Build;, +import android.support.annotation.NonNull;, +import android.support.v4.app.ActivityCompat;, +import android.support.v4.app.Fragment;, +import android.support.v4.content.ContextCompat;, +import android.widget.Toast;, +  private static final int REQUEST_READ_STORAGE = 0;, +, +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M, +        && ContextCompat.checkSelfPermission(this, permission.READ_EXTERNAL_STORAGE), +        != PackageManager.PERMISSION_GRANTED) {, +      requestStoragePermission();, +    } else {, +      replaceFragment();, +    }, +  }, +, +  @TargetApi(Build.VERSION_CODES.JELLY_BEAN), +  private void requestStoragePermission() {, +     ActivityCompat.requestPermissions(this,, +        new String[]{permission.READ_EXTERNAL_STORAGE},, +        REQUEST_READ_STORAGE);, +  }, +, +  private void replaceFragment() {, +    Fragment fragment = new HorizontalGalleryFragment();, +    getSupportFragmentManager(), +        .beginTransaction(), +        .replace(R.id.fragment_container, fragment), +        .commit();, +  }]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +import java.util.Collections;, +import javax.annotation.Nullable;, +  private ClassName requestOptionsClassName;, +  TypeSpec generate(@Nullable TypeSpec generatedOptions) {, +    if (generatedOptions != null) {, +      requestOptionsClassName =, +              RequestOptionsGenerator.GENERATED_REQUEST_OPTIONS_PACKAGE_NAME,, +              generatedOptions.name);, +    } else {, +      requestOptionsClassName =, +          ClassName.get(, +              RequestOptionsGenerator.REQUEST_OPTIONS_PACKAGE_NAME,, +              RequestBuilderGenerator.BASE_REQUEST_OPTIONS_SIMPLE_NAME);, +    }, +      @Nullable final TypeSpec generatedOptions) {, +    if (generatedOptions == null) {, +      return Collections.emptyList();, +    }, +            .equals(requestOptionMethod.toString());, +        .addJavadoc(, +            processorUtil.generateSeeMethodJavadoc(requestOptionsClassName, requestOptionMethod)), +            "if (getMutableOptions() instanceof $T)", requestOptionsClassName), +            requestOptionsClassName), +            requestOptionsClassName)), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +import java.util.Collections;, +import javax.annotation.Nullable;, +  private ClassName requestOptionsClassName;, +  TypeSpec generate(@Nullable TypeSpec generatedOptions) {, +    if (generatedOptions != null) {, +      requestOptionsClassName =, +              RequestOptionsGenerator.GENERATED_REQUEST_OPTIONS_PACKAGE_NAME,, +              generatedOptions.name);, +    } else {, +      requestOptionsClassName =, +          ClassName.get(, +              RequestOptionsGenerator.REQUEST_OPTIONS_PACKAGE_NAME,, +              RequestBuilderGenerator.BASE_REQUEST_OPTIONS_SIMPLE_NAME);, +    }, +      @Nullable final TypeSpec generatedOptions) {, +    if (generatedOptions == null) {, +      return Collections.emptyList();, +    }, +            .equals(requestOptionMethod.toString());, +        .addJavadoc(, +            processorUtil.generateSeeMethodJavadoc(requestOptionsClassName, requestOptionMethod)), +            "if (getMutableOptions() instanceof $T)", requestOptionsClassName), +            requestOptionsClassName), +            requestOptionsClassName)), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java, +import com.google.common.base.Predicates;, +import java.util.Collections;, +  TypeSpec generate(, +      @Nullable TypeSpec requestOptions, TypeSpec requestBuilder, Set<String> glideExtensions) {, +         .addMethods(, +             FluentIterable.from(, +                 Collections.singletonList(generateOverrideSetRequestOptions(requestOptions))), +                 .filter(Predicates.<MethodSpec>notNull())), +  @Nullable, +  private MethodSpec generateOverrideSetRequestOptions(@Nullable TypeSpec generatedRequestOptions) {, +    if (generatedRequestOptions == null) {, +      return null;, +    }, +, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +import java.util.Collections;, +import javax.annotation.Nullable;, +  private ClassName requestOptionsClassName;, +  TypeSpec generate(@Nullable TypeSpec generatedOptions) {, +    if (generatedOptions != null) {, +      requestOptionsClassName =, +              RequestOptionsGenerator.GENERATED_REQUEST_OPTIONS_PACKAGE_NAME,, +              generatedOptions.name);, +    } else {, +      requestOptionsClassName =, +          ClassName.get(, +              RequestOptionsGenerator.REQUEST_OPTIONS_PACKAGE_NAME,, +              RequestBuilderGenerator.BASE_REQUEST_OPTIONS_SIMPLE_NAME);, +    }, +      @Nullable final TypeSpec generatedOptions) {, +    if (generatedOptions == null) {, +      return Collections.emptyList();, +    }, +            .equals(requestOptionMethod.toString());, +        .addJavadoc(, +            processorUtil.generateSeeMethodJavadoc(requestOptionsClassName, requestOptionMethod)), +            "if (getMutableOptions() instanceof $T)", requestOptionsClassName), +            requestOptionsClassName), +            requestOptionsClassName)), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java, +import com.google.common.base.Predicates;, +import java.util.Collections;, +  TypeSpec generate(, +      @Nullable TypeSpec requestOptions, TypeSpec requestBuilder, Set<String> glideExtensions) {, +         .addMethods(, +             FluentIterable.from(, +                 Collections.singletonList(generateOverrideSetRequestOptions(requestOptions))), +                 .filter(Predicates.<MethodSpec>notNull())), +  @Nullable]
[+++ b/library/src/androidTest/java/com/bumptech/glide/manager/RequestTrackerTest.java, +    public void testPausesInProgressRequestsWhenPaused() {, +        verify(request).pause();, +    public void testPausesAndRestartsNotYetFinishedRequestsOnRestart() {, +        verify(request).pause();, +    public void testPausesFailedRequestOnRestartIfPaused() {, +        verify(request).pause();, +    public void testPausesIncompleteRequestsOnRestartIfPaused() {, +        verify(request).pause();, +++ b/library/src/androidTest/java/com/bumptech/glide/manager/RequestTrackerTest.java, +    public void testPausesInProgressRequestsWhenPaused() {, +        verify(request).pause();, +    public void testPausesAndRestartsNotYetFinishedRequestsOnRestart() {, +        verify(request).pause();, +    public void testPausesFailedRequestOnRestartIfPaused() {, +        verify(request).pause();, +    public void testPausesIncompleteRequestsOnRestartIfPaused() {, +        verify(request).pause();, +++ b/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java, +    public void testIsPausedAfterPause() {, +        GenericRequest request = harness.getRequest();, +        request.pause();, +, +        assertTrue(request.isPaused());, +    }, +, +    @Test, +    public void testIsNotCancelledAfterPause() {, +        GenericRequest request = harness.getRequest();, +        request.pause();, +, +        assertFalse(request.isCancelled());, +    }, +, +    @Test, +    public void testIsNotPausedAfterBeginningWhilePaused() {, +        GenericRequest request = harness.getRequest();, +        request.pause();, +        request.begin();, +, +        assertFalse(request.isPaused());, +        assertTrue(request.isRunning());, +    }, +, +    @Test, +    public void testIsCancelledAfterClear() {, +        GenericRequest request = harness.getRequest();, +        request.clear();, +, +        assertTrue(request.isCancelled());, +    }, +, +    @Test, +++ b/library/src/androidTest/java/com/bumptech/glide/manager/RequestTrackerTest.java, +    public void testPausesInProgressRequestsWhenPaused() {, +        verify(request).pause();, +    public void testPausesAndRestartsNotYetFinishedRequestsOnRestart() {, +        verify(request).pause();, +    public void testPausesFailedRequestOnRestartIfPaused() {, +        verify(request).pause();, +    public void testPausesIncompleteRequestsOnRestartIfPaused() {, +        verify(request).pause();, +++ b/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java, +    public void testIsPausedAfterPause() {, +        GenericRequest request = harness.getRequest();, +        request.pause();, +, +        assertTrue(request.isPaused());, +    }, +, +    @Test, +    public void testIsNotCancelledAfterPause() {, +        GenericRequest request = harness.getRequest();, +        request.pause();, +, +        assertFalse(request.isCancelled());, +    }, +, +    @Test, +    public void testIsNotPausedAfterBeginningWhilePaused() {, +        GenericRequest request = harness.getRequest();, +        request.pause();, +        request.begin();, +, +        assertFalse(request.isPaused());, +        assertTrue(request.isRunning());, +    }, +, +    @Test, +    public void testIsCancelledAfterClear() {, +        GenericRequest request = harness.getRequest();, +        request.clear();, +, +        assertTrue(request.isCancelled());, +    }, +, +    @Test, +++ b/library/src/androidTest/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java, +    @Test, +    public void testIsPausedWhenFullIsPaused() {]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java, +      @NonNull WaitModel<Model> waitModel, int width, int height, @NonNull Options options) {, +  public boolean handles(@NonNull WaitModel<Model> waitModel) {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java, +      @NonNull WaitModel<Model> waitModel, int width, int height, @NonNull Options options) {, +  public boolean handles(@NonNull WaitModel<Model> waitModel) {, +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java, +    //noinspection ForLoopReplaceableByForEach to improve perf, +    for (int i = 0, size = parsers.size(); i < size; i++) {, +    //noinspection ForLoopReplaceableByForEach to improve perf, +    for (int i = 0, size = parsers.size(); i < size; i++) {, +    //noinspection ForLoopReplaceableByForEach to improve perf, +    for (int i = 0, size = parsers.size(); i < size; i++) {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java, +      @NonNull WaitModel<Model> waitModel, int width, int height, @NonNull Options options) {, +  public boolean handles(@NonNull WaitModel<Model> waitModel) {, +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java, +    //noinspection ForLoopReplaceableByForEach to improve perf, +    for (int i = 0, size = parsers.size(); i < size; i++) {, +    //noinspection ForLoopReplaceableByForEach to improve perf, +    for (int i = 0, size = parsers.size(); i < size; i++) {, +    //noinspection ForLoopReplaceableByForEach to improve perf, +    for (int i = 0, size = parsers.size(); i < size; i++) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +    //noinspection ForLoopReplaceableByForEach to improve perf, +    for (int i = 0, size = loadData.size(); i < size; i++) {, +      //noinspection ForLoopReplaceableByForEach to improve perf, +      for (int i = 0, size = modelLoaders.size(); i < size; i++) {, +      //noinspection ForLoopReplaceableByForEach to improve perf, +      for (int i = 0, size = loadData.size(); i < size; i++) {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java, +      @NonNull WaitModel<Model> waitModel, int width, int height, @NonNull Options options) {, +  public boolean handles(@NonNull WaitModel<Model> waitModel) {, +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java, +    //noinspection ForLoopReplaceableByForEach to improve perf, +    for (int i = 0, size = parsers.size(); i < size; i++) {, +    //noinspection ForLoopReplaceableByForEach to improve perf, +    for (int i = 0, size = parsers.size(); i < size; i++) {, +    //noinspection ForLoopReplaceableByForEach to improve perf, +    for (int i = 0, size = parsers.size(); i < size; i++) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +    //noinspection ForLoopReplaceableByForEach to improve perf, +    for (int i = 0, size = loadData.size(); i < size; i++) {, +      //noinspection ForLoopReplaceableByForEach to improve perf, +      for (int i = 0, size = modelLoaders.size(); i < size; i++) {, +      //noinspection ForLoopReplaceableByForEach to improve perf, +      for (int i = 0, size = loadData.size(); i < size; i++) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +        switch (encodeStrategy) {, +          case SOURCE:, +            break;, +          case TRANSFORMED:, +            break;, +          default:, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java, +      @NonNull WaitModel<Model> waitModel, int width, int height, @NonNull Options options) {, +  public boolean handles(@NonNull WaitModel<Model> waitModel) {, +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java, +    //noinspection ForLoopReplaceableByForEach to improve perf, +    for (int i = 0, size = parsers.size(); i < size; i++) {, +    //noinspection ForLoopReplaceableByForEach to improve perf, +    for (int i = 0, size = parsers.size(); i < size; i++) {, +    //noinspection ForLoopReplaceableByForEach to improve perf, +    for (int i = 0, size = parsers.size(); i < size; i++) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +    //noinspection ForLoopReplaceableByForEach to improve perf, +    for (int i = 0, size = loadData.size(); i < size; i++) {, +      //noinspection ForLoopReplaceableByForEach to improve perf, +      for (int i = 0, size = modelLoaders.size(); i < size; i++) {, +      //noinspection ForLoopReplaceableByForEach to improve perf, +      for (int i = 0, size = loadData.size(); i < size; i++) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +        switch (encodeStrategy) {, +          case SOURCE:, +            break;, +          case TRANSFORMED:, +            break;, +          default:, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java, +    //noinspection ForLoopReplaceableByForEach to improve perf, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java, +      @NonNull WaitModel<Model> waitModel, int width, int height, @NonNull Options options) {, +  public boolean handles(@NonNull WaitModel<Model> waitModel) {, +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java, +    //noinspection ForLoopReplaceableByForEach to improve perf, +    for (int i = 0, size = parsers.size(); i < size; i++) {, +    //noinspection ForLoopReplaceableByForEach to improve perf, +    for (int i = 0, size = parsers.size(); i < size; i++) {, +    //noinspection ForLoopReplaceableByForEach to improve perf, +    for (int i = 0, size = parsers.size(); i < size; i++) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +    //noinspection ForLoopReplaceableByForEach to improve perf, +    for (int i = 0, size = loadData.size(); i < size; i++) {, +      //noinspection ForLoopReplaceableByForEach to improve perf, +      for (int i = 0, size = modelLoaders.size(); i < size; i++) {, +      //noinspection ForLoopReplaceableByForEach to improve perf, +      for (int i = 0, size = loadData.size(); i < size; i++) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +        switch (encodeStrategy) {, +          case SOURCE:]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="OTHER_INDENT_OPTIONS">, +          <value>, +            <option name="INDENT_SIZE" value="2" />, +            <option name="CONTINUATION_INDENT_SIZE" value="4" />, +            <option name="TAB_SIZE" value="2" />, +            <option name="USE_TAB_CHARACTER" value="false" />, +            <option name="SMART_TABS" value="false" />, +            <option name="LABEL_INDENT_SIZE" value="0" />, +            <option name="LABEL_INDENT_ABSOLUTE" value="false" />, +            <option name="USE_RELATIVE_INDENTS" value="false" />, +          </value>, +        </option>, +            <package name="com.google" withSubpackages="true" static="true" />, +            <package name="" withSubpackages="true" static="true" />, +            <emptyLine />, +            <package name="com.google" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="antenna" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="antlr" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="ar" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="asposewobfuscated" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="asquare" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="atg" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="au" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="beaver" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="bibtex" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="bmsi" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="bsh" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="ccl" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="cern" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="ChartDirector" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="checkers" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="COM" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="common" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="contribs" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="corejava" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="cryptix" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="cybervillains" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="dalvik" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="danbikel" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="de" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="EDU" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="eg" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="eu" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="examples" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="fat" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="fit" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="fitlibrary" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="fmpp" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="freemarker" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="gnu" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="groovy" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="groovyjarjarantlr" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="groovyjarjarasm" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="hak" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="hep" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="ie" withSubpackages="true" static="false" />, +            <emptyLine />, +            <package name="imageinfo" withSubpackages="true" static="false" />, +            <emptyLine />]
[+++ b/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java, +    int value = super.read();, +    checkReadSoFarOrThrow(value >= 0 ? 1 : -1);, +    return value;, +++ b/library/src/main/java/com/bumptech/glide/util/ContentLengthInputStream.java, +    int value = super.read();, +    checkReadSoFarOrThrow(value >= 0 ? 1 : -1);, +    return value;, +++ b/library/src/test/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java, +import java.io.ByteArrayInputStream;, +    assertThat(is.available()).isEqualTo(contentLength - 1);, +, +  @Test, +  public void testRead_readWithZeroes_doesNotThrow() throws IOException {, +    ByteArrayInputStream inner = new ByteArrayInputStream(new byte[] {0, 0, 0});, +    InputStream is = ContentLengthInputStream.obtain(inner, 3);, +, +    assertThat(is.read()).isEqualTo(0);, +    assertThat(is.read()).isEqualTo(0);, +    assertThat(is.read()).isEqualTo(0);, +    assertThat(is.read()).isEqualTo(-1);, +  }, +, +  @Test, +  public void testRead_readWithHighValues_doesNotThrow() throws IOException {, +    ByteArrayInputStream inner =, +        new ByteArrayInputStream(new byte[] {(byte) 0xF0, (byte) 0xA0, (byte) 0xFF});, +    InputStream is = ContentLengthInputStream.obtain(inner, 3);, +, +    assertThat(is.read()).isEqualTo(0xF0);, +    assertThat(is.read()).isEqualTo(0xA0);, +    assertThat(is.read()).isEqualTo(0xFF);, +    assertThat(is.read()).isEqualTo(-1);, +  }]
[+++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="19" />, +++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="19" />, +++ b/library/src/com/bumptech/glide/Glide.java, +import android.graphics.Bitmap;, +import android.graphics.drawable.Drawable;, +import android.os.ParcelFileDescriptor;, +import android.view.View;, +import com.bumptech.glide.loader.bitmap.BaseBitmapLoadFactory;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorFileLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorModelLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorResourceLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorStringLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorUriLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamByteArrayLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamResourceLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamFileLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamModelLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamStringLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamUriLoader;, +import com.bumptech.glide.loader.bitmap.model.GenericLoaderFactory;, +import com.bumptech.glide.loader.bitmap.model.ModelLoader;, +import com.bumptech.glide.loader.bitmap.model.ModelLoaderFactory;, +import com.bumptech.glide.loader.bitmap.transformation.CenterCrop;, +import com.bumptech.glide.loader.bitmap.transformation.FitCenter;, +import com.bumptech.glide.loader.bitmap.transformation.MultiTransformationLoader;, +import com.bumptech.glide.loader.bitmap.transformation.None;, +import com.bumptech.glide.loader.bitmap.transformation.TransformationLoader;, +import com.bumptech.glide.presenter.target.ImageViewTarget;, +import com.bumptech.glide.presenter.target.ViewTarget;, +import com.bumptech.glide.resize.load.BitmapDecoder;, +import com.bumptech.glide.resize.load.VideoBitmapDecoder;, +import java.io.InputStream;, + * A singleton to present a simple static interface for Glide {@link GenericRequest} and to create and manage an, +         *     public void onException(Exception e, ModelType model, Target target) {, +        register(File.class, ParcelFileDescriptor.class, new FileDescriptorFileLoader.Factory());, +        register(File.class, InputStream.class, new StreamFileLoader.Factory());, +        register(Integer.class, ParcelFileDescriptor.class, new FileDescriptorResourceLoader.Factory());, +        register(Integer.class, InputStream.class, new StreamResourceLoader.Factory());, +        register(String.class, ParcelFileDescriptor.class, new FileDescriptorStringLoader.Factory());, +        register(String.class, InputStream.class, new StreamStringLoader.Factory());, +        register(Uri.class, ParcelFileDescriptor.class, new FileDescriptorUriLoader.Factory());, +        register(Uri.class, InputStream.class, new StreamUriLoader.Factory());, +            register(URL.class, InputStream.class, new VolleyUrlLoader.Factory());, +     * {@link ImageManager} with custom options for use with {@link GenericRequest} and/or as an, +     * Set the {@link ImageManager} to use with {@link GenericRequest}., +     * Set the {@link ImageManager} to use with {@link GenericRequest} Replaces the current, +     * models. Typically the {@link ModelRequest#using(StreamModelLoader)} or, +     * {@link ModelRequest#using(FileDescriptorModelLoader)} syntax is preferred because it directly links the model, +     * with the ModelLoader being used to load it., +     *     used for any other model class, {@link ModelLoaderFactory#teardown()}, +     * @see ModelRequest#using(FileDescriptorModelLoader), +     * @see ModelRequest#using(StreamModelLoader), +     *, +     * @param modelClass The model class., +     * @param resourceClass The resource class the model loader will translate the model type into., +     * @param factory The factory to use., +     * @param <T> The type of the model., +     * @param <Y> the type of the resource., +    public <T, Y> void register(Class<T> modelClass, Class<Y> resourceClass, ModelLoaderFactory<T, Y> factory) {, +        ModelLoaderFactory<T, Y> removed = loaderFactory.register(modelClass, resourceClass, factory);, +    @SuppressWarnings("unchecked"), +    private <T, Y> ModelLoaderFactory<T, Y> getFactory(T model, Class<Y> resourceClass) {, +        return loaderFactory.getFactory((Class<T>) model.getClass(), resourceClass);, +    }, +, +     * @param modelClass The class to get a {@link ModelLoader} for, +    public static <T, Y> ModelLoader<T, Y> buildModelLoader(Class<T> modelClass, Class<Y> resourceClass, Context context) {, +        return GLIDE.loaderFactory.buildModelLoader(modelClass, resourceClass, context);, +     * A convenience method to build a {@link ModelLoader} for the given model that produces {@link InputStream}s using, +     * a registered factory., +     * @see #buildModelLoader(Class, Class, android.content.Context), +    public static <T> ModelLoader<T, InputStream> buildStreamModelLoader(Class<T> modelClass, Context context) {, +        return buildModelLoader(modelClass, InputStream.class, context);, +     * A convenience method to build a {@link ModelLoader} for the given model class that produces, +     * {@link ParcelFileDescriptor}s using a registered factory., +     * @see #buildModelLoader(Class, Class, android.content.Context), +    public static <T> ModelLoader<T, ParcelFileDescriptor> buildFileDescriptorModelLoader(Class<T> modelClass,, +            Context context) {, +        return buildModelLoader(modelClass, ParcelFileDescriptor.class, context);, +    /**, +     * Cancel any pending loads Glide may have for the target and free any resources (such as {@link Bitmap}s) that may, +     * have been loaded for the target so they may be reused., +     *, +     * @param target The Target to cancel loads for., +     */, +    public static void clear(Target target) {, +        ImagePresenter imagePresenter = target.getImagePresenter();, +        if (imagePresenter != null) {, +            imagePresenter.clear();, +        }, +    /**, +     * Cancel any pending loads Glide may have for the view and free any resources that may have been loaded for the, +     * view., +     *, +     * <p>, +     *     Note that this will only work if {@link View#setTag(Object)} is not called on this view outside of Glide., +     * </p>, +     *]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.ImageHeaderParser;, +import com.bumptech.glide.request.RequestListener;, +      @NonNull Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions,, +      @NonNull List<RequestListener<Object>> defaultRequestListeners) {, +    List<ImageHeaderParser> imageHeaderParsers = registry.getImageHeaderParsers();, +    Downsampler downsampler =, +        new Downsampler(, +            imageHeaderParsers,, +            resources.getDisplayMetrics(),, +            bitmapPool,, +            arrayPool);, +        new ByteBufferGifDecoder(context, imageHeaderParsers, bitmapPool, arrayPool);, +            new StreamGifDecoder(imageHeaderParsers, byteBufferGifDecoder, arrayPool)), +            defaultRequestListeners,, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.ImageHeaderParser;, +import com.bumptech.glide.request.RequestListener;, +      @NonNull Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions,, +      @NonNull List<RequestListener<Object>> defaultRequestListeners) {, +    List<ImageHeaderParser> imageHeaderParsers = registry.getImageHeaderParsers();, +    Downsampler downsampler =, +        new Downsampler(, +            imageHeaderParsers,, +            resources.getDisplayMetrics(),, +            bitmapPool,, +            arrayPool);, +        new ByteBufferGifDecoder(context, imageHeaderParsers, bitmapPool, arrayPool);, +            new StreamGifDecoder(imageHeaderParsers, byteBufferGifDecoder, arrayPool)), +            defaultRequestListeners,, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.load.DataSource;, +import com.bumptech.glide.load.engine.GlideException;, +import com.bumptech.glide.request.RequestListener;, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, +  @Nullable, +  private List<RequestListener<Object>> defaultRequestListeners;, +  /**, +   * Adds a global {@link RequestListener} that will be added to every request started with Glide., +   *, +   * <p>Multiple {@link RequestListener}s can be added here, in {@link RequestManager} scopes or, +   * to individual {@link RequestBuilder}s. {@link RequestListener}s are called in the order they're, +   * added. Even if an earlier {@link RequestListener} returns {@code true} from, +   * {@link RequestListener#onLoadFailed(GlideException, Object, Target, boolean)} or, +   * {@link RequestListener#onResourceReady(Object, Object, Target, DataSource, boolean)}, it will, +   * not prevent subsequent {@link RequestListener}s from being called., +   *, +   * <p>Because Glide requests can be started for any number of individual resource types, any, +   * listener added here has to accept any generic resource type in, +   * {@link RequestListener#onResourceReady(Object, Object, Target, DataSource, boolean)}. If you, +   * must base the behavior of the listener on the resource type, you will need to use, +   * {@code instanceof} to do so. It's not safe to cast resource types without first checking, +   * with {@code instanceof}., +   */, +  @NonNull, +  public GlideBuilder addGlobalRequestListener(@NonNull RequestListener<Object> listener) {, +    if (defaultRequestListeners == null) {, +      defaultRequestListeners = new ArrayList<>();, +    }, +    defaultRequestListeners.add(listener);, +    return this;, +  }, +, +    if (defaultRequestListeners == null) {, +      defaultRequestListeners = Collections.emptyList();, +    } else {, +      defaultRequestListeners = Collections.unmodifiableList(defaultRequestListeners);, +    }, +, +        defaultTransitionOptions,, +        defaultRequestListeners);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.ImageHeaderParser;, +import com.bumptech.glide.request.RequestListener;, +      @NonNull Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions,, +      @NonNull List<RequestListener<Object>> defaultRequestListeners) {, +    List<ImageHeaderParser> imageHeaderParsers = registry.getImageHeaderParsers();, +    Downsampler downsampler =, +        new Downsampler(, +            imageHeaderParsers,, +            resources.getDisplayMetrics(),, +            bitmapPool,, +            arrayPool);, +        new ByteBufferGifDecoder(context, imageHeaderParsers, bitmapPool, arrayPool);, +            new StreamGifDecoder(imageHeaderParsers, byteBufferGifDecoder, arrayPool)), +            defaultRequestListeners,, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.load.DataSource;, +import com.bumptech.glide.load.engine.GlideException;, +import com.bumptech.glide.request.RequestListener;, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.List;, +  @Nullable, +  private List<RequestListener<Object>> defaultRequestListeners;, +  /**, +   * Adds a global {@link RequestListener} that will be added to every request started with Glide., +   *]
[+++ b/.idea/codeStyleSettings.xml, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +Proguard, +--------, +Depending on your proguard config and usage, you may need to include the following lines in your proguard.cfg:, +```, +-keep public class * implements com.bumptech.glide.module.GlideModule, +-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {, +    **[] $VALUES;, +    public *;, +}, +```, +, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +Proguard, +--------, +Depending on your proguard config and usage, you may need to include the following lines in your proguard.cfg:, +```, +-keep public class * implements com.bumptech.glide.module.GlideModule, +-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {, +    **[] $VALUES;, +    public *;, +}, +```, +, +++ b/build.gradle, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +Proguard, +--------, +Depending on your proguard config and usage, you may need to include the following lines in your proguard.cfg:, +```, +-keep public class * implements com.bumptech.glide.module.GlideModule, +-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {, +    **[] $VALUES;, +    public *;, +}, +```, +, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +Proguard, +--------, +Depending on your proguard config and usage, you may need to include the following lines in your proguard.cfg:, +```, +-keep public class * implements com.bumptech.glide.module.GlideModule, +-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {, +    **[] $VALUES;, +    public *;, +}, +```, +, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +Proguard, +--------, +Depending on your proguard config and usage, you may need to include the following lines in your proguard.cfg:, +```, +-keep public class * implements com.bumptech.glide.module.GlideModule, +-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {, +    **[] $VALUES;, +    public *;, +}, +```, +, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +  <component name="NewModuleRootManager" inherit-compiler-output="false">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +Proguard]
[+++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]src[/\\]androidTest[/\\].*" checks="Javadoc.*"/>, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]src[/\\]androidTest[/\\].*" checks="Javadoc.*"/>, +++ b/library/build.gradle, +    androidTestCompile "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}", +    androidTestCompile 'com.android.support.test:runner:0.5', +    androidTestCompile 'com.android.support.test:rules:0.5', +    androidTestCompile "com.google.truth:truth:${TRUTH_VERSION}", +    androidTestCompile "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}", +        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner", +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]src[/\\]androidTest[/\\].*" checks="Javadoc.*"/>, +++ b/library/build.gradle, +    androidTestCompile "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}", +    androidTestCompile 'com.android.support.test:runner:0.5', +    androidTestCompile 'com.android.support.test:rules:0.5', +    androidTestCompile "com.google.truth:truth:${TRUTH_VERSION}", +    androidTestCompile "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}", +        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner", +++ b/library/src/androidTest/java/com/bumptech/glide/test/TestNonBitmapResources.java, +package com.bumptech.glide.test;, +, +import static com.google.common.truth.Truth.assertThat;, +, +import android.content.ContentResolver;, +import android.content.Context;, +import android.content.pm.PackageInfo;, +import android.content.pm.PackageManager;, +import android.content.pm.PackageManager.NameNotFoundException;, +import android.content.res.Resources;, +import android.graphics.Bitmap;, +import android.graphics.drawable.Drawable;, +import android.net.Uri;, +import android.support.test.InstrumentationRegistry;, +import android.support.test.runner.AndroidJUnit4;, +import com.bumptech.glide.Glide;, +import com.google.common.collect.ImmutableList;, +import java.util.concurrent.ExecutionException;, +import org.junit.After;, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +, +@RunWith(AndroidJUnit4.class), +public class TestNonBitmapResources {, +, +  private Context context;, +, +  @Before, +  public void setUp() {, +    context = InstrumentationRegistry.getTargetContext();, +  }, +, +  @After, +  public void tearDown() {, +    Glide.tearDown();, +  }, +, +  @Test, +  public void load_withBitmapResourceId_asDrawable_producesNonNullDrawable(), +      throws ExecutionException, InterruptedException {, +    Drawable drawable = Glide.with(context), +        .load(android.R.drawable.star_big_off), +        .submit(), +        .get();, +    assertThat(drawable).isNotNull();, +  }, +, +  @Test, +  public void load_withBitmapResourceId_asBitmap_producesNonNullBitmap(), +      throws ExecutionException, InterruptedException {, +    Bitmap bitmap = Glide.with(context), +        .asBitmap(), +        .load(android.R.drawable.star_big_off), +        .submit(), +        .get();, +    assertThat(bitmap).isNotNull();, +  }, +, +  @Test, +  public void load_withBitmapAliasResourceId_asDrawable_producesNonNullDrawable(), +      throws ExecutionException, InterruptedException {, +    Drawable drawable = Glide.with(context), +        .load(R.drawable.bitmap_alias), +        .submit(), +        .get();, +    assertThat(drawable).isNotNull();, +  }, +, +  @Test, +  public void load_withShapeDrawableResourceId_asDrawable_producesNonNullDrawable(), +      throws ExecutionException, InterruptedException {, +    Drawable drawable = Glide.with(context), +        .load(R.drawable.shape_drawable), +        .submit(), +        .get();, +    assertThat(drawable).isNotNull();, +  }, +]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +   *, +   * @deprecated use {@link #noTransformation()}, +   */, +  @Deprecated, +  public static RequestOptions noTransform() {, +    return noTransformation();, +  }, +, +  /**, +   * Returns a {@link RequestOptions} object with {@link #dontTransform()} set.]
[+++ b/gradle.properties, +VERSION_NAME=4.8.0-SNAPSHOT, +VERSION_MINOR=8]
[+++ b/library/src/main/java/com/bumptech/glide/request/target/Target.java]
[+++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java, +        full.clear();, +++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java, +        full.clear();, +++ b/library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java, +import org.mockito.InOrder;, +import static org.mockito.Mockito.inOrder;, +, +    @Test, +    public void testCallsClearOnRequestsWhenCleared() {, +        coordinator.clear();, +        InOrder order = inOrder(thumb, full);, +        order.verify(thumb).clear();, +        order.verify(full).clear();, +    }, +, +    @Test, +    public void testRecyclesRequestsWhenRecycled() {, +        coordinator.recycle();, +        verify(thumb).recycle();, +        verify(full).recycle();, +    }, +]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +      target.setRequest(null);, +    target.setRequest(null);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +      target.setRequest(null);, +    target.setRequest(null);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +      cleanup();, +  private void cleanup() {, +    currentData = null;, +    currentDataSource = null;, +    currentFetcher = null;, +    currentSourceKey = null;, +    currentThread = null;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +      target.setRequest(null);, +    target.setRequest(null);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +      cleanup();, +  private void cleanup() {, +    currentData = null;, +    currentDataSource = null;, +    currentFetcher = null;, +    currentSourceKey = null;, +    currentThread = null;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +    status = Status.COMPLETE;, +    this.resource = resource;, +]
[+++ b/.gitignore, +library/build/*, +++ b/.gitignore, +library/build/*, +++ b/library/build.gradle, +buildscript {, +    repositories {, +        mavenCentral(), +    }, +    dependencies {, +        classpath 'com.android.tools.build:gradle:0.5.+', +    }, +}, +, +apply plugin: 'android-library', +, +repositories {, +    mavenCentral(), +}, +, +dependencies {, +    compile files('libs/disklrucache-2.0.2.jar'), +    compile 'com.android.support:support-v4:13.0.+', +    compile project('volley'), +}, +, +, +android {, +    compileSdkVersion 17, +    buildToolsVersion = 17, +, +    sourceSets {, +        main {, +            assets.srcDirs       = ['assets'], +            res.srcDirs          = ['res'], +            aidl.srcDirs         = ['src'], +            resources.srcDirs    = ['src'], +            renderscript.srcDirs = ['src'], +            java.srcDirs         = ['src'], +            manifest.srcFile 'AndroidManifest.xml', +, +        }, +    }, +}]
[+++ b/gradle.properties, +ANDROIDX_TEST_VERSION=1.1.0-alpha4, +++ b/gradle.properties, +ANDROIDX_TEST_VERSION=1.1.0-alpha4, +++ b/instrumentation/build.gradle, +    androidTestImplementation "androidx.test:runner:${ANDROIDX_TEST_VERSION}", +    androidTestImplementation "androidx.test:rules:${ANDROIDX_TEST_VERSION}", +        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +import javax.lang.model.element.AnnotationMirror;, +  private static final ClassName CHECK_RESULT_CLASS_NAME =, +      ClassName.get("android.support.annotation", "CheckResult");, +    MethodSpec.Builder builder = MethodSpec.overriding(methodToOverride), +            .build());, +, +    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {, +      builder.addAnnotation(AnnotationSpec.get(mirror));, +    }, +, +    return builder.build();, +                        && !input.type.equals(TypeName.get(SafeVarargs.class)), +                        // @CheckResult isn't applicable for RequestBuilder because there is no, +                        // autoClone() in RequestBuilder., +                        && !input.type.equals(CHECK_RESULT_CLASS_NAME);, +        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build()), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +import javax.lang.model.element.AnnotationMirror;, +  private static final ClassName CHECK_RESULT_CLASS_NAME =, +      ClassName.get("android.support.annotation", "CheckResult");, +    MethodSpec.Builder builder = MethodSpec.overriding(methodToOverride), +            .build());, +, +    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {, +      builder.addAnnotation(AnnotationSpec.get(mirror));, +    }, +, +    return builder.build();, +                        && !input.type.equals(TypeName.get(SafeVarargs.class)), +                        // @CheckResult isn't applicable for RequestBuilder because there is no, +                        // autoClone() in RequestBuilder., +                        && !input.type.equals(CHECK_RESULT_CLASS_NAME);, +        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build()), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java, +import javax.lang.model.element.AnnotationMirror;, +  private static final ClassName CHECK_RESULT_CLASS_NAME =, +      ClassName.get("android.support.annotation", "CheckResult");, +    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {, +      result.addAnnotation(AnnotationSpec.get(mirror));, +    }, +, +    builder.addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build());, +, +    methodSpecBuilder.addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build());, +, +    methodSpecBuilder.addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build());, +, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +import javax.lang.model.element.AnnotationMirror;, +  private static final ClassName CHECK_RESULT_CLASS_NAME =, +      ClassName.get("android.support.annotation", "CheckResult");, +    MethodSpec.Builder builder = MethodSpec.overriding(methodToOverride), +            .build());, +, +    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {, +      builder.addAnnotation(AnnotationSpec.get(mirror));, +    }, +, +    return builder.build();, +                        && !input.type.equals(TypeName.get(SafeVarargs.class)), +                        // @CheckResult isn't applicable for RequestBuilder because there is no, +                        // autoClone() in RequestBuilder., +                        && !input.type.equals(CHECK_RESULT_CLASS_NAME);, +        .addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build()), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java, +import javax.lang.model.element.AnnotationMirror;, +  private static final ClassName CHECK_RESULT_CLASS_NAME =, +      ClassName.get("android.support.annotation", "CheckResult");, +    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {, +      result.addAnnotation(AnnotationSpec.get(mirror));, +    }, +, +    builder.addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build());, +, +    methodSpecBuilder.addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build());, +, +    methodSpecBuilder.addAnnotation(AnnotationSpec.builder(CHECK_RESULT_CLASS_NAME).build());, +, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import android.support.annotation.CheckResult;, +  @CheckResult, +  @CheckResult, +  @CheckResult, +  @CheckResult, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +import javax.lang.model.element.AnnotationMirror;, +  private static final ClassName CHECK_RESULT_CLASS_NAME =, +      ClassName.get("android.support.annotation", "CheckResult");, +    MethodSpec.Builder builder = MethodSpec.overriding(methodToOverride), +            .build());, +, +    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {, +      builder.addAnnotation(AnnotationSpec.get(mirror));, +    }, +, +    return builder.build();, +                        && !input.type.equals(TypeName.get(SafeVarargs.class)), +                        // @CheckResult isn't applicable for RequestBuilder because there is no, +                        // autoClone() in RequestBuilder.]
[+++ b/integration/recyclerview/lint.xml, +    <issue id="GradleDependency" severity="ignore" />, +++ b/integration/recyclerview/lint.xml, +    <issue id="GradleDependency" severity="ignore" />, +++ b/library/lint.xml, +    <issue id="GradleDependency" severity="ignore"/>, +++ b/integration/recyclerview/lint.xml, +    <issue id="GradleDependency" severity="ignore" />, +++ b/library/lint.xml, +    <issue id="GradleDependency" severity="ignore"/>, +++ b/samples/contacturi/lint.xml, +    <issue id="GradleDependency" severity="ignore"/>, +++ b/integration/recyclerview/lint.xml, +    <issue id="GradleDependency" severity="ignore" />, +++ b/library/lint.xml, +    <issue id="GradleDependency" severity="ignore"/>, +++ b/samples/contacturi/lint.xml, +    <issue id="GradleDependency" severity="ignore"/>, +++ b/samples/flickr/lint.xml, +    <issue id="GradleDependency" severity="ignore" />, +++ b/integration/recyclerview/lint.xml, +    <issue id="GradleDependency" severity="ignore" />, +++ b/library/lint.xml, +    <issue id="GradleDependency" severity="ignore"/>, +++ b/samples/contacturi/lint.xml, +    <issue id="GradleDependency" severity="ignore"/>, +++ b/samples/flickr/lint.xml, +    <issue id="GradleDependency" severity="ignore" />, +++ b/samples/gallery/lint.xml, +    <issue id="GradleDependency" severity="ignore" />, +++ b/integration/recyclerview/lint.xml, +    <issue id="GradleDependency" severity="ignore" />, +++ b/library/lint.xml, +    <issue id="GradleDependency" severity="ignore"/>, +++ b/samples/contacturi/lint.xml, +    <issue id="GradleDependency" severity="ignore"/>, +++ b/samples/flickr/lint.xml, +    <issue id="GradleDependency" severity="ignore" />, +++ b/samples/gallery/lint.xml, +    <issue id="GradleDependency" severity="ignore" />, +++ b/samples/giphy/lint.xml, +    <issue id="GradleDependency" severity="ignore" />, +++ b/integration/recyclerview/lint.xml, +    <issue id="GradleDependency" severity="ignore" />, +++ b/library/lint.xml, +    <issue id="GradleDependency" severity="ignore"/>, +++ b/samples/contacturi/lint.xml, +    <issue id="GradleDependency" severity="ignore"/>, +++ b/samples/flickr/lint.xml, +    <issue id="GradleDependency" severity="ignore" />, +++ b/samples/gallery/lint.xml, +    <issue id="GradleDependency" severity="ignore" />, +++ b/samples/giphy/lint.xml, +    <issue id="GradleDependency" severity="ignore" />, +++ b/samples/imgur/lint.xml, +    <issue id="GradleDependency" severity="ignore" />, +++ b/integration/recyclerview/lint.xml, +    <issue id="GradleDependency" severity="ignore" />, +++ b/library/lint.xml, +    <issue id="GradleDependency" severity="ignore"/>, +++ b/samples/contacturi/lint.xml, +    <issue id="GradleDependency" severity="ignore"/>, +++ b/samples/flickr/lint.xml, +    <issue id="GradleDependency" severity="ignore" />, +++ b/samples/gallery/lint.xml, +    <issue id="GradleDependency" severity="ignore" />, +++ b/samples/giphy/lint.xml, +    <issue id="GradleDependency" severity="ignore" />, +++ b/samples/imgur/lint.xml, +    <issue id="GradleDependency" severity="ignore" />, +++ b/samples/svg/lint.xml, +    <issue id="GradleDependency" severity="ignore"/>]
[+++ b/library/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java, +import static junit.framework.Assert.assertFalse;, +import static junit.framework.Assert.assertTrue;, +, +    @Test, +    public void testDelegatesIsPausedToRequestTracker() {, +        when(requestTracker.isPaused()).thenReturn(true);, +        assertTrue(manager.isPaused());, +        when(requestTracker.isPaused()).thenReturn(false);, +        assertFalse(manager.isPaused());, +    }, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java, +import static junit.framework.Assert.assertFalse;, +import static junit.framework.Assert.assertTrue;, +, +    @Test, +    public void testDelegatesIsPausedToRequestTracker() {, +        when(requestTracker.isPaused()).thenReturn(true);, +        assertTrue(manager.isPaused());, +        when(requestTracker.isPaused()).thenReturn(false);, +        assertFalse(manager.isPaused());, +    }, +++ b/library/src/androidTest/java/com/bumptech/glide/manager/LifecycleTest.java, +    private ActivityFragmentLifecycle lifecycle;, +        lifecycle = new ActivityFragmentLifecycle();, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java, +import static junit.framework.Assert.assertFalse;, +import static junit.framework.Assert.assertTrue;, +, +    @Test, +    public void testDelegatesIsPausedToRequestTracker() {, +        when(requestTracker.isPaused()).thenReturn(true);, +        assertTrue(manager.isPaused());, +        when(requestTracker.isPaused()).thenReturn(false);, +        assertFalse(manager.isPaused());, +    }, +++ b/library/src/androidTest/java/com/bumptech/glide/manager/LifecycleTest.java, +    private ActivityFragmentLifecycle lifecycle;, +        lifecycle = new ActivityFragmentLifecycle();, +++ b/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java, +        public ActivityFragmentLifecycle getHarnessLifecycle();, +        public ActivityFragmentLifecycle getFragmentLifecycle();, +        private final ActivityFragmentLifecycle lifecycle = mock(ActivityFragmentLifecycle.class);, +        public ActivityFragmentLifecycle getHarnessLifecycle() {, +        public ActivityFragmentLifecycle getFragmentLifecycle() {, +        private final ActivityFragmentLifecycle lifecycle = mock(ActivityFragmentLifecycle.class);, +        public ActivityFragmentLifecycle getHarnessLifecycle() {, +        public ActivityFragmentLifecycle getFragmentLifecycle() {, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java, +import static junit.framework.Assert.assertFalse;, +import static junit.framework.Assert.assertTrue;, +, +    @Test, +    public void testDelegatesIsPausedToRequestTracker() {, +        when(requestTracker.isPaused()).thenReturn(true);, +        assertTrue(manager.isPaused());, +        when(requestTracker.isPaused()).thenReturn(false);, +        assertFalse(manager.isPaused());, +    }, +++ b/library/src/androidTest/java/com/bumptech/glide/manager/LifecycleTest.java, +    private ActivityFragmentLifecycle lifecycle;, +        lifecycle = new ActivityFragmentLifecycle();, +++ b/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java, +        public ActivityFragmentLifecycle getHarnessLifecycle();, +        public ActivityFragmentLifecycle getFragmentLifecycle();, +        private final ActivityFragmentLifecycle lifecycle = mock(ActivityFragmentLifecycle.class);, +        public ActivityFragmentLifecycle getHarnessLifecycle() {, +        public ActivityFragmentLifecycle getFragmentLifecycle() {, +        private final ActivityFragmentLifecycle lifecycle = mock(ActivityFragmentLifecycle.class);, +        public ActivityFragmentLifecycle getHarnessLifecycle() {, +        public ActivityFragmentLifecycle getFragmentLifecycle() {, +++ b/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java, +import static org.junit.Assert.assertFalse;, +        // Clear out static state., +        RequestManagerRetriever.reset();, +, +    public void testApplicationRequestManagerIsNotPausedWhenRetrieved() {, +        RequestManager manager = RequestManagerRetriever.get(Robolectric.application);, +        assertFalse(manager.isPaused());, +    }, +, +    @Test, +    public void testApplicationRequestManagerIsNotReResumedAfterFirstRetrieval() {, +        RequestManager manager = RequestManagerRetriever.get(Robolectric.application);, +        manager.pauseRequests();, +        manager = RequestManagerRetriever.get(Robolectric.application);, +        assertTrue(manager.isPaused());, +    }, +, +    @Test, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java, +import static junit.framework.Assert.assertFalse;, +import static junit.framework.Assert.assertTrue;, +, +    @Test, +    public void testDelegatesIsPausedToRequestTracker() {, +        when(requestTracker.isPaused()).thenReturn(true);, +        assertTrue(manager.isPaused());, +        when(requestTracker.isPaused()).thenReturn(false);, +        assertFalse(manager.isPaused());]
[+++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]instrumentation[/\\]src[/\\]androidTest[/\\].*" checks="Javadoc.*"/>, +    <suppress files=".*[/\\]instrumentation[/\\]src[/\\]androidTest[/\\].*[/\\]ResourceIds" checks=".*"/>, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]instrumentation[/\\]src[/\\]androidTest[/\\].*" checks="Javadoc.*"/>, +    <suppress files=".*[/\\]instrumentation[/\\]src[/\\]androidTest[/\\].*[/\\]ResourceIds" checks=".*"/>, +++ b/instrumentation/build.gradle, +apply plugin: 'com.android.application', +, +dependencies {, +    // Appcompat is required to ensure that Glide's runtime detection the v7 support Drawable, +    // loading classes functions. It's not clear why androidTestCompile isn't sufficient, but for, +    // whatever reason, compile is the only dependency that seems to work., +    compile "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}", +    androidTestCompile project(':library'), +    androidTestCompile "org.mockito:mockito-android:${MOCKITO_ANDROID_VERSION}", +    androidTestCompile "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}", +    androidTestCompile "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}", +    androidTestCompile 'com.android.support.test:runner:0.5', +    androidTestCompile 'com.android.support.test:rules:0.5', +    androidTestCompile "com.google.truth:truth:${TRUTH_VERSION}", +}, +, +android {, +    compileSdkVersion COMPILE_SDK_VERSION as int, +    buildToolsVersion BUILD_TOOLS_VERSION as String, +, +    defaultConfig {, +        applicationId 'com.bumptech.glide.instrumentation', +        minSdkVersion MIN_SDK_VERSION as int, +        targetSdkVersion TARGET_SDK_VERSION as int, +        versionCode 1, +        versionName '1.0', +        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner", +    }, +, +    compileOptions {, +        sourceCompatibility JavaVersion.VERSION_1_7, +        targetCompatibility JavaVersion.VERSION_1_7, +    }, +}, +, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]instrumentation[/\\]src[/\\]androidTest[/\\].*" checks="Javadoc.*"/>, +    <suppress files=".*[/\\]instrumentation[/\\]src[/\\]androidTest[/\\].*[/\\]ResourceIds" checks=".*"/>, +++ b/instrumentation/build.gradle, +apply plugin: 'com.android.application', +, +dependencies {, +    // Appcompat is required to ensure that Glide's runtime detection the v7 support Drawable, +    // loading classes functions. It's not clear why androidTestCompile isn't sufficient, but for, +    // whatever reason, compile is the only dependency that seems to work., +    compile "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}", +    androidTestCompile project(':library'), +    androidTestCompile "org.mockito:mockito-android:${MOCKITO_ANDROID_VERSION}", +    androidTestCompile "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}", +    androidTestCompile "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}", +    androidTestCompile 'com.android.support.test:runner:0.5', +    androidTestCompile 'com.android.support.test:rules:0.5', +    androidTestCompile "com.google.truth:truth:${TRUTH_VERSION}", +}, +, +android {, +    compileSdkVersion COMPILE_SDK_VERSION as int, +    buildToolsVersion BUILD_TOOLS_VERSION as String, +, +    defaultConfig {, +        applicationId 'com.bumptech.glide.instrumentation', +        minSdkVersion MIN_SDK_VERSION as int, +        targetSdkVersion TARGET_SDK_VERSION as int, +        versionCode 1, +        versionName '1.0', +        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner", +    }, +, +    compileOptions {, +        sourceCompatibility JavaVersion.VERSION_1_7, +        targetCompatibility JavaVersion.VERSION_1_7, +    }, +}, +, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java, +package com.bumptech.glide;, +, +import static com.google.common.truth.Truth.assertThat;, +, +import android.content.ContentResolver;, +import android.content.Context;, +import android.content.Intent;, +import android.content.pm.PackageInfo;, +import android.content.pm.PackageManager;, +import android.content.pm.PackageManager.NameNotFoundException;, +import android.content.pm.ResolveInfo;, +import android.content.res.Resources;, +import android.graphics.Bitmap;, +import android.graphics.drawable.Drawable;, +import android.net.Uri;, +import android.support.test.InstrumentationRegistry;, +import android.support.test.runner.AndroidJUnit4;, +import com.bumptech.glide.test.ResourceIds;]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +      Context context, DecodeFormat decodeFormat, int logLevel) {, +    glideContext = new GlideContext(context, registry, imageViewTargetFactory, options, engine,, +        this, logLevel);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +      Context context, DecodeFormat decodeFormat, int logLevel) {, +    glideContext = new GlideContext(context, registry, imageViewTargetFactory, options, engine,, +        this, logLevel);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import android.util.Log;, +public final class GlideBuilder {, +  private int logLevel = Log.INFO;, +  GlideBuilder(Context context) {, +  /**, +   * Sets a log level constant from those in {@link Log} to indicate the desired log verbosity., +   *, +   * <p>The level must be one of {@link Log#VERBOSE}, {@link Log#DEBUG}, {@link Log#INFO},, +   * {@link Log#WARN}, or {@link Log#ERROR}., +   *, +   * <p>{@link Log#VERBOSE} means one or more lines will be logged per request, including, +   * timing logs and failures. {@link Log#DEBUG} means at most one line will be logged, +   * per successful request, including timing logs, although many lines may be logged for, +   * failures including multiple complete stack traces. {@link Log#INFO} means, +   * failed loads will be logged including multiple complete stack traces, but successful loads, +   * will not be logged at all. {@link Log#WARN} means only summaries of failed loads will be, +   * logged. {@link Log#ERROR} means only exceptional cases will be logged., +   *, +   * <p>All logs will be logged using the 'Glide' tag., +   *, +   * <p>Many other debugging logs are available in individual classes. The log level supplied here, +   * only controls a small set of informative and well formatted logs. Users wishing to debug, +   * certain aspects of the library can look for individual <code>TAG</code> variables at the tops, +   * of classes and use <code>adb shell setprop log.tag.TAG</code> to enable or disable any relevant, +   * tags., +   *, +   * @param logLevel The log level to use from {@link Log}., +   * @return This builder., +   */, +  public GlideBuilder setLogLevel(int logLevel) {, +    if (logLevel < Log.VERBOSE || logLevel > Log.ERROR) {, +      throw new IllegalArgumentException("Log level must be one of Log.VERBOSE, Log.DEBUG,", +          + " Log.INFO, Log.WARN, or Log.ERROR");, +    }, +    this.logLevel = logLevel;, +    return this;, +  }, +, +    return new Glide(engine, memoryCache, bitmapPool, byteArrayPool, context, decodeFormat,, +        logLevel);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +      Context context, DecodeFormat decodeFormat, int logLevel) {, +    glideContext = new GlideContext(context, registry, imageViewTargetFactory, options, engine,, +        this, logLevel);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import android.util.Log;, +public final class GlideBuilder {, +  private int logLevel = Log.INFO;, +  GlideBuilder(Context context) {, +  /**, +   * Sets a log level constant from those in {@link Log} to indicate the desired log verbosity., +   *, +   * <p>The level must be one of {@link Log#VERBOSE}, {@link Log#DEBUG}, {@link Log#INFO},, +   * {@link Log#WARN}, or {@link Log#ERROR}., +   *, +   * <p>{@link Log#VERBOSE} means one or more lines will be logged per request, including, +   * timing logs and failures. {@link Log#DEBUG} means at most one line will be logged, +   * per successful request, including timing logs, although many lines may be logged for, +   * failures including multiple complete stack traces. {@link Log#INFO} means, +   * failed loads will be logged including multiple complete stack traces, but successful loads, +   * will not be logged at all. {@link Log#WARN} means only summaries of failed loads will be, +   * logged. {@link Log#ERROR} means only exceptional cases will be logged., +   *, +   * <p>All logs will be logged using the 'Glide' tag., +   *, +   * <p>Many other debugging logs are available in individual classes. The log level supplied here, +   * only controls a small set of informative and well formatted logs. Users wishing to debug, +   * certain aspects of the library can look for individual <code>TAG</code> variables at the tops, +   * of classes and use <code>adb shell setprop log.tag.TAG</code> to enable or disable any relevant, +   * tags., +   *, +   * @param logLevel The log level to use from {@link Log}., +   * @return This builder., +   */, +  public GlideBuilder setLogLevel(int logLevel) {, +    if (logLevel < Log.VERBOSE || logLevel > Log.ERROR) {, +      throw new IllegalArgumentException("Log level must be one of Log.VERBOSE, Log.DEBUG,", +          + " Log.INFO, Log.WARN, or Log.ERROR");, +    }, +    this.logLevel = logLevel;, +    return this;, +  }, +, +    return new Glide(engine, memoryCache, bitmapPool, byteArrayPool, context, decodeFormat,, +        logLevel);, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +  private final int logLevel;, +      ComponentCallbacks2 componentCallbacks, int logLevel) {, +    this.logLevel = logLevel;, +  public int getLogLevel() {, +    return logLevel;]
[+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java, +  static final int MIN_FRAME_DELAY = 2;]
[+++ b/gradle.properties, +VERSION_NAME=4.6.1, +VERSION_MINOR=6, +VERSION_PATCH=1]
[+++ b/LICENSE, +---------------------------------------------------------------------------------------------, +License for third_party/gif_encoder/AnimatedGifEncoder.java and, +third_party/gif_encoder/LZWEncoder.java:, +, +No copyright asserted on the source code of this class. May be used for any, +purpose, however, refer to the Unisys LZW patent for restrictions on use of, +the associated LZWEncoder class. Please forward any corrections to, +kweiner@fmsware.com., +, +-----------------------------------------------------------------------------, +License for third_party/gif_encoder/NeuQuant.java, +, +Copyright (c) 1994 Anthony Dekker, +, +NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See, +"Kohonen neural networks for optimal colour quantization" in "Network:, +Computation in Neural Systems" Vol. 5 (1994) pp 351-367. for a discussion of, +the algorithm., +, +Any party obtaining a copy of these files from the author, directly or, +indirectly, is granted, free of charge, a full and unrestricted irrevocable,, +world-wide, paid up, royalty-free, nonexclusive right and license to deal in, +this software and documentation files (the "Software"), including without, +limitation the rights to use, copy, modify, merge, publish, distribute,, +sublicense, and/or sell copies of the Software, and to permit persons who, +receive copies from any such party to do so, with the only requirement being, +that this copyright notice remain intact., +++ b/LICENSE, +---------------------------------------------------------------------------------------------, +License for third_party/gif_encoder/AnimatedGifEncoder.java and, +third_party/gif_encoder/LZWEncoder.java:, +, +No copyright asserted on the source code of this class. May be used for any, +purpose, however, refer to the Unisys LZW patent for restrictions on use of, +the associated LZWEncoder class. Please forward any corrections to, +kweiner@fmsware.com., +, +-----------------------------------------------------------------------------, +License for third_party/gif_encoder/NeuQuant.java, +, +Copyright (c) 1994 Anthony Dekker, +, +NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See, +"Kohonen neural networks for optimal colour quantization" in "Network:, +Computation in Neural Systems" Vol. 5 (1994) pp 351-367. for a discussion of, +the algorithm., +, +Any party obtaining a copy of these files from the author, directly or, +indirectly, is granted, free of charge, a full and unrestricted irrevocable,, +world-wide, paid up, royalty-free, nonexclusive right and license to deal in, +this software and documentation files (the "Software"), including without, +limitation the rights to use, copy, modify, merge, publish, distribute,, +sublicense, and/or sell copies of the Software, and to permit persons who, +receive copies from any such party to do so, with the only requirement being, +that this copyright notice remain intact., +++ b/third_party/gif_encoder/LICENSE, +License for AnimatedGifEncoder.java and LZWEncoder.java, +, +No copyright asserted on the source code of this class. May be used for any, +purpose, however, refer to the Unisys LZW patent for restrictions on use of, +the associated LZWEncoder class. Please forward any corrections to, +kweiner@fmsware.com., +, +-----------------------------------------------------------------------------, +License for NeuQuant.java, +, +Copyright (c) 1994 Anthony Dekker, +, +NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See, +"Kohonen neural networks for optimal colour quantization" in "Network:, +Computation in Neural Systems" Vol. 5 (1994) pp 351-367. for a discussion of, +the algorithm., +, +Any party obtaining a copy of these files from the author, directly or, +indirectly, is granted, free of charge, a full and unrestricted irrevocable,, +world-wide, paid up, royalty-free, nonexclusive right and license to deal in, +this software and documentation files (the "Software"), including without, +limitation the rights to use, copy, modify, merge, publish, distribute,, +sublicense, and/or sell copies of the Software, and to permit persons who, +receive copies from any such party to do so, with the only requirement being, +that this copyright notice remain intact., +++ b/LICENSE, +---------------------------------------------------------------------------------------------, +License for third_party/gif_encoder/AnimatedGifEncoder.java and, +third_party/gif_encoder/LZWEncoder.java:, +, +No copyright asserted on the source code of this class. May be used for any, +purpose, however, refer to the Unisys LZW patent for restrictions on use of, +the associated LZWEncoder class. Please forward any corrections to, +kweiner@fmsware.com., +, +-----------------------------------------------------------------------------, +License for third_party/gif_encoder/NeuQuant.java, +, +Copyright (c) 1994 Anthony Dekker, +, +NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See, +"Kohonen neural networks for optimal colour quantization" in "Network:, +Computation in Neural Systems" Vol. 5 (1994) pp 351-367. for a discussion of]
[+++ b/library/src/main/AndroidManifest.xml, +<manifest xmlns:android="http://schemas.android.com/apk/res/android", +    package="com.bumptech.glide">, +    <uses-sdk android:minSdkVersion="14" />, +++ b/library/src/main/AndroidManifest.xml, +<manifest xmlns:android="http://schemas.android.com/apk/res/android", +    package="com.bumptech.glide">, +    <uses-sdk android:minSdkVersion="14" />, +++ b/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java, + * {@link com.bumptech.glide.load.engine.Resource} loaded into it using {@link, + * com.bumptech.glide.RequestManager#clear(Target)}., + * {@link com.bumptech.glide.request.target.ViewTarget} or {@link, + * com.bumptech.glide.request.target.ImageViewTarget} are preferable., + * @deprecated Use {@link CustomViewTarget} if loading the content into a view, the download API if, + *     in the background, + *     (http://bumptech.github.io/glide/doc/getting-started.html#background-threads), or a a fully, + *     implemented {@link Target} for any specialized use-cases. Using BaseView is unsafe if the, + *     user does not implement {@link #onLoadCleared}, resulting in recycled bitmaps being, + *     referenced from the UI and hard to root-cause crashes., +@Deprecated, +++ b/library/src/main/AndroidManifest.xml, +<manifest xmlns:android="http://schemas.android.com/apk/res/android", +    package="com.bumptech.glide">, +    <uses-sdk android:minSdkVersion="14" />, +++ b/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java, + * {@link com.bumptech.glide.load.engine.Resource} loaded into it using {@link, + * com.bumptech.glide.RequestManager#clear(Target)}., + * {@link com.bumptech.glide.request.target.ViewTarget} or {@link, + * com.bumptech.glide.request.target.ImageViewTarget} are preferable., + * @deprecated Use {@link CustomViewTarget} if loading the content into a view, the download API if, + *     in the background, + *     (http://bumptech.github.io/glide/doc/getting-started.html#background-threads), or a a fully, + *     implemented {@link Target} for any specialized use-cases. Using BaseView is unsafe if the, + *     user does not implement {@link #onLoadCleared}, resulting in recycled bitmaps being, + *     referenced from the UI and hard to root-cause crashes., +@Deprecated, +++ b/library/src/main/java/com/bumptech/glide/request/target/CustomViewTarget.java, +package com.bumptech.glide.request.target;, +, +import android.content.Context;, +import android.graphics.Point;, +import android.graphics.drawable.Drawable;, +import android.support.annotation.IdRes;, +import android.support.annotation.NonNull;, +import android.support.annotation.Nullable;, +import android.support.annotation.VisibleForTesting;, +import android.util.Log;, +import android.view.Display;, +import android.view.View;, +import android.view.View.OnAttachStateChangeListener;, +import android.view.ViewGroup.LayoutParams;, +import android.view.ViewTreeObserver;, +import android.view.WindowManager;, +import com.bumptech.glide.request.Request;, +import com.bumptech.glide.request.transition.Transition;, +import com.bumptech.glide.util.Preconditions;, +import com.bumptech.glide.util.Synthetic;, +import java.lang.ref.WeakReference;, +import java.util.ArrayList;, +import java.util.List;, +, +/**, + * A base {@link Target} for loading {@link android.graphics.Bitmap}s into {@link View}s that, + * provides default implementations for most methods and can determine the size of views using a, + * {@link android.view.ViewTreeObserver.OnDrawListener}., + *, + * @param <T> The specific subclass of view wrapped by this target., + * @param <Z> The resource type this target will receive., + */, +public abstract class CustomViewTarget<T extends View, Z> implements Target<Z> {, +  private static final String TAG = "CustomViewTarget";, +  @IdRes private static final int VIEW_TAG_ID =, +      com.bumptech.glide.R.id.glide_custom_view_target_tag;, +, +  private final SizeDeterminer sizeDeterminer;, +, +  protected final T view;, +  @Nullable private OnAttachStateChangeListener attachStateListener;, +  private boolean isClearedByUs;, +  private boolean isAttachStateListenerAdded;, +  @IdRes private int overrideTag = 0;, +, +  /** Constructor that defaults {@code waitForLayout} to {@code false}. */, +  public CustomViewTarget(@NonNull T view) {, +    this.view = Preconditions.checkNotNull(view);, +    sizeDeterminer = new SizeDeterminer(view);, +  }, +, +  /**, +   * A required callback invoked when the resource is no longer valid and must be freed., +   *, +   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Z,, +   * Transition)} is no longer used before redrawing the container (usually a View) or changing its, +   * visibility. <b>Not doing so will result in crashes in your app.</b>, +   *, +   * @param placeholder The placeholder drawable to optionally show, or null., +   */, +  protected abstract void onResourceCleared(@Nullable Drawable placeholder);, +, +  /**]
[+++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Sun Feb 11 17:13:25 PST 2018, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.5.1-all.zip, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Sun Feb 11 17:13:25 PST 2018, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.5.1-all.zip, +++ b/settings.gradle, +    ignoreExitValue true]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.1', +  <version>3.5.1</version>, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.1', +  <version>3.5.1</version>, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }, +    }, +}, +, +subprojects {, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = 1.7, +        targetCompatibility = 1.7, +    }, +}, +, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />]
[+++ b/README.md, +Note: Make sure your Android SDK has the Android Support Repository installed, and that your `$ANDROID_HOME` environment variable is pointing at the SDK or add a `local.properties` file in the root project with a `sdk.dir=...` line., +, +Samples, +-------, +Follow the steps in the 'Build' section to setup the project and then:, +, +```, +gradlew :samples:flickr:run, +gradlew :samples:giphy:run, +gradlew :samples:svg:run, +```, +++ b/README.md, +Note: Make sure your Android SDK has the Android Support Repository installed, and that your `$ANDROID_HOME` environment variable is pointing at the SDK or add a `local.properties` file in the root project with a `sdk.dir=...` line., +, +Samples, +-------, +Follow the steps in the 'Build' section to setup the project and then:, +, +```, +gradlew :samples:flickr:run, +gradlew :samples:giphy:run, +gradlew :samples:svg:run, +```, +++ b/samples/flickr/build.gradle, +, +task run(type: Exec, dependsOn: 'installDebug') {, +    description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"', +    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.flickr/.FlickrSearchActivity', +}, +++ b/README.md, +Note: Make sure your Android SDK has the Android Support Repository installed, and that your `$ANDROID_HOME` environment variable is pointing at the SDK or add a `local.properties` file in the root project with a `sdk.dir=...` line., +, +Samples, +-------, +Follow the steps in the 'Build' section to setup the project and then:, +, +```, +gradlew :samples:flickr:run, +gradlew :samples:giphy:run, +gradlew :samples:svg:run, +```, +++ b/samples/flickr/build.gradle, +, +task run(type: Exec, dependsOn: 'installDebug') {, +    description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"', +    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.flickr/.FlickrSearchActivity', +}, +++ b/samples/giphy/build.gradle, +task run(type: Exec, dependsOn: 'installDebug') {, +    description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"', +    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.giphy/.MainActivity', +}, +++ b/README.md, +Note: Make sure your Android SDK has the Android Support Repository installed, and that your `$ANDROID_HOME` environment variable is pointing at the SDK or add a `local.properties` file in the root project with a `sdk.dir=...` line., +, +Samples, +-------, +Follow the steps in the 'Build' section to setup the project and then:, +, +```, +gradlew :samples:flickr:run, +gradlew :samples:giphy:run, +gradlew :samples:svg:run, +```, +++ b/samples/flickr/build.gradle, +, +task run(type: Exec, dependsOn: 'installDebug') {, +    description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"', +    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.flickr/.FlickrSearchActivity', +}, +++ b/samples/giphy/build.gradle, +task run(type: Exec, dependsOn: 'installDebug') {, +    description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"', +    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.giphy/.MainActivity', +}, +++ b/samples/svg/build.gradle, +    buildToolsVersion '19.1.0', +        applicationId 'com.bumptech.svgsample.app', +        versionName '1.0', +    compile 'com.caverock:androidsvg:1.2.1', +}, +, +task run(type: Exec, dependsOn: 'installDebug') {, +    description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"', +    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.svgsample.app/.MainActivity', +++ b/README.md, +Note: Make sure your Android SDK has the Android Support Repository installed, and that your `$ANDROID_HOME` environment variable is pointing at the SDK or add a `local.properties` file in the root project with a `sdk.dir=...` line., +, +Samples, +-------, +Follow the steps in the 'Build' section to setup the project and then:, +, +```, +gradlew :samples:flickr:run, +gradlew :samples:giphy:run, +gradlew :samples:svg:run, +```, +++ b/samples/flickr/build.gradle, +]
[+++ b/.travis.yml, +  - build-tools-25.0.2, +  - android-25, +++ b/.travis.yml, +  - build-tools-25.0.2, +  - android-25, +++ b/gradle.properties, +SUPPORT_V4_VERSION=25.1.1, +SUPPORT_V7_VERSION=25.1.1, +ANDROID_GRADLE_VERSION=2.2.3, +COMPILE_SDK_VERSION=25, +BUILD_TOOLS_VERSION=25.0.2, +TARGET_SDK_VERSION=25, +++ b/.travis.yml, +  - build-tools-25.0.2, +  - android-25, +++ b/gradle.properties, +SUPPORT_V4_VERSION=25.1.1, +SUPPORT_V7_VERSION=25.1.1, +ANDROID_GRADLE_VERSION=2.2.3, +COMPILE_SDK_VERSION=25, +BUILD_TOOLS_VERSION=25.0.2, +TARGET_SDK_VERSION=25, +++ b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java, +    } catch (InstantiationException e) {, +      throw new RuntimeException("Unable to instantiate GlideModule implementation for " + clazz,, +              e);, +      // These can't be combined until API minimum is 19., +    } catch (IllegalAccessException e) {]
[+++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +                .listener(new RequestListener<String, GifDrawable>() {, +                    public boolean onResourceReady(GifDrawable resource, String model, Target target,, +        GifDrawable firstResult = mock(GifDrawable.class);, +        Resource<GifDrawable> firstResource = mock(Resource.class);, +        GifDrawable secondResult = mock(GifDrawable.class);, +        Resource<GifDrawable> secondResource = mock(Resource.class);, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +                .listener(new RequestListener<String, GifDrawable>() {, +                    public boolean onResourceReady(GifDrawable resource, String model, Target target,, +        GifDrawable firstResult = mock(GifDrawable.class);, +        Resource<GifDrawable> firstResource = mock(Resource.class);, +        GifDrawable secondResult = mock(GifDrawable.class);, +        Resource<GifDrawable> secondResource = mock(Resource.class);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +        drawable.setLoopCount(GifDrawable.LOOP_INTRINSIC);, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +                .listener(new RequestListener<String, GifDrawable>() {, +                    public boolean onResourceReady(GifDrawable resource, String model, Target target,, +        GifDrawable firstResult = mock(GifDrawable.class);, +        Resource<GifDrawable> firstResource = mock(Resource.class);, +        GifDrawable secondResult = mock(GifDrawable.class);, +        Resource<GifDrawable> secondResource = mock(Resource.class);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +        drawable.setLoopCount(GifDrawable.LOOP_INTRINSIC);, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +                .listener(new RequestListener<String, GifDrawable>() {, +                    public boolean onResourceReady(GifDrawable resource, String model, Target target,, +        GifDrawable firstResult = mock(GifDrawable.class);, +        Resource<GifDrawable> firstResource = mock(Resource.class);, +        GifDrawable secondResult = mock(GifDrawable.class);, +        Resource<GifDrawable> secondResource = mock(Resource.class);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +        drawable.setLoopCount(GifDrawable.LOOP_INTRINSIC);, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +                .listener(new RequestListener<String, GifDrawable>() {, +                    public boolean onResourceReady(GifDrawable resource, String model, Target target,, +        GifDrawable firstResult = mock(GifDrawable.class);, +        Resource<GifDrawable> firstResource = mock(Resource.class);, +        GifDrawable secondResult = mock(GifDrawable.class);, +        Resource<GifDrawable> secondResource = mock(Resource.class);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +        drawable.setLoopCount(GifDrawable.LOOP_INTRINSIC);, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, + * A class for creating a request to load a {@link Drawable}., +     * Loads and displays the {@link Drawable} retrieved by the given thumbnail request if it finishes before this, +     * request. Best used for loading thumbnail {@link Drawable}s that are smaller and will be loaded more quickly, +     * than the fullsize {@link Drawable}. There are no guarantees about the order in which the requests will, +     * actually finish. However, if the thumb request completes after the full request, the thumb {@link Drawable}, +     *     you want an animation to occur when either the full {@link Drawable} loads or the thumbnail loads,, +     * Transform {@link Drawable}s using the given, +     * Transform {@link Drawable}s using {@link com.bumptech.glide.load.resource.bitmap.CenterCrop}., +     * Transform {@link Drawable}s using {@link com.bumptech.glide.load.resource.bitmap.FitCenter}., +     * Transform {@link Drawable}s using the given {@link android.graphics.Bitmap} transformations. Replaces any, +//            ResourceTranscoder<GifBitmapWrapper, Drawable> transcoder) {, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +                .listener(new RequestListener<String, GifDrawable>() {, +                    public boolean onResourceReady(GifDrawable resource, String model, Target target,, +        GifDrawable firstResult = mock(GifDrawable.class);, +        Resource<GifDrawable> firstResource = mock(Resource.class);, +        GifDrawable secondResult = mock(GifDrawable.class);, +        Resource<GifDrawable> secondResource = mock(Resource.class);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +        drawable.setLoopCount(GifDrawable.LOOP_INTRINSIC);, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, + * A class for creating a request to load a {@link Drawable}., +     * Loads and displays the {@link Drawable} retrieved by the given thumbnail request if it finishes before this, +     * request. Best used for loading thumbnail {@link Drawable}s that are smaller and will be loaded more quickly, +     * than the fullsize {@link Drawable}. There are no guarantees about the order in which the requests will, +     * actually finish. However, if the thumb request completes after the full request, the thumb {@link Drawable}, +     *     you want an animation to occur when either the full {@link Drawable} loads or the thumbnail loads,, +     * Transform {@link Drawable}s using the given, +     * Transform {@link Drawable}s using {@link com.bumptech.glide.load.resource.bitmap.CenterCrop}., +     * Transform {@link Drawable}s using {@link com.bumptech.glide.load.resource.bitmap.FitCenter}., +     * Transform {@link Drawable}s using the given {@link android.graphics.Bitmap} transformations. Replaces any, +//            ResourceTranscoder<GifBitmapWrapper, Drawable> transcoder) {, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +                .listener(new RequestListener<String, GifDrawable>() {, +                    public boolean onResourceReady(GifDrawable resource, String model, Target target,, +        GifDrawable firstResult = mock(GifDrawable.class);, +        Resource<GifDrawable> firstResource = mock(Resource.class);, +        GifDrawable secondResult = mock(GifDrawable.class);, +        Resource<GifDrawable> secondResource = mock(Resource.class);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +        drawable.setLoopCount(GifDrawable.LOOP_INTRINSIC);, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/request/target/ImageViewTargetFactoryTest.java, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, + * A class for creating a request to load a {@link Drawable}., +     * Loads and displays the {@link Drawable} retrieved by the given thumbnail request if it finishes before this, +     * request. Best used for loading thumbnail {@link Drawable}s that are smaller and will be loaded more quickly, +     * than the fullsize {@link Drawable}. There are no guarantees about the order in which the requests will]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java, +package com.bumptech.glide.load.resource.bitmap;, +, +import static org.junit.Assert.assertEquals;, +import static org.mockito.Mockito.when;, +, +import org.robolectric.RobolectricTestRunner;, +, +import android.annotation.TargetApi;, +import android.content.Context;, +import android.graphics.Bitmap;, +import android.graphics.Canvas;, +import android.graphics.Color;, +import android.graphics.Paint;, +import android.graphics.Rect;, +, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +, +import org.junit.Before;, +import org.junit.Rule;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +import org.robolectric.RuntimeEnvironment;, +import org.robolectric.annotation.Config;, +, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE), +public class CircleCropTest {, +  @Mock private BitmapPool bitmapPool;, +, +  private Context context;, +  private CircleCrop circleCrop;, +, +  @Before, +  public void setup() {, +    MockitoAnnotations.initMocks(this);, +    context = RuntimeEnvironment.application;, +    circleCrop = new CircleCrop(context);, +  }, +, +  @Test, +  public void testTransform_withSquare() {, +    Bitmap redSquare = createSolidRedBitmap(50, 50);, +    Bitmap result = circleCrop.transform(bitmapPool, redSquare, 50, 50);, +    Bitmap expected = createBitmapWithRedCircle(50, 50);, +, +    assertSamePixels(expected, result);, +  }, +, +  @Test, +  public void testTransform_reusesBitmap() {, +    Bitmap toReuse = Bitmap.createBitmap(50, 50, Bitmap.Config.ARGB_8888);, +    when(bitmapPool.get(50, 50, Bitmap.Config.ARGB_8888)).thenReturn(toReuse);, +, +    Bitmap redSquare = createSolidRedBitmap(50, 50);, +    Bitmap result = circleCrop.transform(bitmapPool, redSquare, 50, 50);, +, +    assertEquals(toReuse, result);, +  }, +, +  @Test, +  public void testTransform_withWideRectangle() {, +    Bitmap redWideRectangle = createSolidRedBitmap(100, 50);, +    Bitmap result = circleCrop.transform(bitmapPool, redWideRectangle, 80, 50);, +    Bitmap expected = createBitmapWithRedCircle(80, 50);, +, +    assertSamePixels(expected, result);, +  }, +, +  @Test, +  public void testTransform_withNarrowRectangle() {, +    Bitmap redNarrowRectangle = createSolidRedBitmap(20, 50);, +    Bitmap result = circleCrop.transform(bitmapPool, redNarrowRectangle, 40, 80);, +    Bitmap expected = createBitmapWithRedCircle(40, 80);, +, +    assertSamePixels(expected, result);, +  }, +, +  private void assertSamePixels(Bitmap expected, Bitmap actual) {, +    assertEquals(expected.getWidth(), actual.getWidth());, +    assertEquals(expected.getHeight(), actual.getHeight());, +    assertEquals(expected.getConfig(), actual.getConfig());, +    for (int y = 0; y < expected.getHeight(); y++) {, +      for (int x = 0; x < expected.getWidth(); x++) {, +        assertEquals(expected.getPixel(x, y), actual.getPixel(x, y));, +      }, +    }, +  }, +, +  @TargetApi(12), +  private Bitmap createBitmapWithRedCircle(int width, int height) {, +    Bitmap result = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);, +    result.setHasAlpha(true);, +    Canvas canvas = new Canvas(result);, +    Paint paint = new Paint();, +    paint.setColor(Color.RED);, +, +    int minEdge = Math.min(width, height);]
[+++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]src[/\\]androidTest[/\\].*" checks="Javadoc.*"/>, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]src[/\\]androidTest[/\\].*" checks="Javadoc.*"/>, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperTransformationTest.java, +        String expectedId = "testID";, +        BitmapPool pool = mock(BitmapPool.class);, +        GifBitmapWrapperTransformation transformation = new GifBitmapWrapperTransformation(pool, bitmapTransformation);, +, +        assertEquals(expectedId, transformation.getId());, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]src[/\\]androidTest[/\\].*" checks="Javadoc.*"/>, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperTransformationTest.java, +        String expectedId = "testID";, +        BitmapPool pool = mock(BitmapPool.class);, +        GifBitmapWrapperTransformation transformation = new GifBitmapWrapperTransformation(pool, bitmapTransformation);, +, +        assertEquals(expectedId, transformation.getId());, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/GlideBitmapDrawableTranscoderTest.java, +import org.junit.Before;, +    private GlideBitmapDrawableTranscoder transcoder;, +, +    @Before, +    public void setUp() {, +        transcoder = new GlideBitmapDrawableTranscoder(Robolectric.application.getResources(), mock(BitmapPool.class));, +    }, +, +    @Test, +    public void testHasValidId() {, +        Util.assertClassHasValidId(GlideBitmapDrawableTranscoder.class, transcoder.getId());, +    }]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/CacheLoaderTest.java, +import static org.mockito.Matchers.anyMapOf;, +import java.util.HashMap;, +    private HashMap<String, Object> options;, +        options = new HashMap<String, Object>();, +        cacheLoader.load(key, decoder, width, height, options);, +        verify(decoder).decode(eq(result), eq(width), eq(height), eq(options));, +        when(decoder.decode(eq(file), eq(width), eq(height), eq(options))).thenReturn(expected);, +        assertEquals(expected, cacheLoader.load(key, decoder, width, height, options));, +        assertNull(cacheLoader.load(key, decoder, 100, 100, options));, +        when(decoder.decode(any(File.class), anyInt(), anyInt(), anyMapOf(String.class, Object.class))), +                .thenThrow(new IOException("Test"));, +        cacheLoader.load(key, decoder, 100, 100, options);, +        when(decoder.decode(any(File.class), anyInt(), anyInt(), anyMapOf(String.class, Object.class))), +                .thenReturn(null);, +        cacheLoader.load(key, decoder, 100, 101, options);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/CacheLoaderTest.java, +import static org.mockito.Matchers.anyMapOf;, +import java.util.HashMap;, +    private HashMap<String, Object> options;, +        options = new HashMap<String, Object>();, +        cacheLoader.load(key, decoder, width, height, options);, +        verify(decoder).decode(eq(result), eq(width), eq(height), eq(options));, +        when(decoder.decode(eq(file), eq(width), eq(height), eq(options))).thenReturn(expected);, +        assertEquals(expected, cacheLoader.load(key, decoder, width, height, options));, +        assertNull(cacheLoader.load(key, decoder, 100, 100, options));, +        when(decoder.decode(any(File.class), anyInt(), anyInt(), anyMapOf(String.class, Object.class))), +                .thenThrow(new IOException("Test"));, +        cacheLoader.load(key, decoder, 100, 100, options);, +        when(decoder.decode(any(File.class), anyInt(), anyInt(), anyMapOf(String.class, Object.class))), +                .thenReturn(null);, +        cacheLoader.load(key, decoder, 100, 101, options);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java, +import static org.mockito.Matchers.anyMapOf;, +import java.util.Collections;, +import java.util.Map;, +        when(harness.cacheDecoder.decode(eq(cacheFile), eq(harness.width), eq(harness.height), eq(harness.options))), +        when(harness.cacheDecoder.decode(any(File.class), anyInt(), anyInt(), anyMapOf(String.class, Object.class))), +        verify(harness.cacheDecoder).decode(any(File.class), anyInt(), anyInt(), anyMapOf(String.class, Object.class));, +        when(harness.cacheDecoder.decode(any(File.class), anyInt(), anyInt(), anyMapOf(String.class, Object.class))), +                .thenThrow(new RuntimeException("test"));, +        when(harness.cacheDecoder.decode(any(File.class), anyInt(), anyInt(), anyMapOf(String.class, Object.class))), +                .thenReturn(null);, +        when(harness.cacheDecoder.decode(any(File.class), anyInt(), anyInt(), anyMapOf(String.class, Object.class))), +                .thenReturn(null);, +        when(harness.cacheDecoder.decode(eq(file), eq(harness.width), eq(harness.height), eq(harness.options))), +        when(harness.cacheDecoder.decode(any(File.class), anyInt(), anyInt(), anyMapOf(String.class, Object.class))), +                .thenReturn(null);, +        when(harness.cacheDecoder.decode(any(File.class), anyInt(), anyInt(), anyMapOf(String.class, Object.class))), +                .thenThrow(new RuntimeException("test"));, +        when(harness.cacheDecoder.decode(any(File.class), anyInt(), anyInt(), anyMapOf(String.class, Object.class))), +                .thenReturn(null);, +        when(harness.cacheDecoder.decode(any(File.class), anyInt(), anyInt(), anyMapOf(String.class, Object.class))), +                .thenThrow(new RuntimeException("test"));, +        when(harness.sourceDecoder.decode(eq(data), eq(harness.width), eq(harness.height),, +                anyMapOf(String.class, Object.class))), +        when(harness.cacheDecoder.decode(eq(cachedSource), eq(harness.width), eq(harness.height),, +                anyMapOf(String.class, Object.class))), +        when(harness.sourceDecoder.decode(anyObject(), anyInt(), anyInt(), anyMapOf(String.class, Object.class))), +                .thenThrow(new IOException("test"));, +            when(harness.sourceDecoder.decode(any(Object.class), anyInt(), anyInt(),, +                    anyMapOf(String.class, Object.class))).thenReturn(null);, +            when(harness.cacheDecoder.decode(any(File.class), anyInt(), anyInt(),, +                    anyMapOf(String.class, Object.class))).thenReturn(null);, +        RequestContext<Object> requestContext = mock(RequestContext.class);, +        Map<String, Object> options = Collections.emptyMap();, +        public DecodeJob<Object> getJob() {, +            return new DecodeJob<Object>(requestContext, key, width, height, diskCacheProvider, fileOpener);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/CacheLoaderTest.java, +import static org.mockito.Matchers.anyMapOf;, +import java.util.HashMap;, +    private HashMap<String, Object> options;, +        options = new HashMap<String, Object>();, +        cacheLoader.load(key, decoder, width, height, options);, +        verify(decoder).decode(eq(result), eq(width), eq(height), eq(options));, +        when(decoder.decode(eq(file), eq(width), eq(height), eq(options))).thenReturn(expected);, +        assertEquals(expected, cacheLoader.load(key, decoder, width, height, options));, +        assertNull(cacheLoader.load(key, decoder, 100, 100, options));, +        when(decoder.decode(any(File.class), anyInt(), anyInt(), anyMapOf(String.class, Object.class))), +                .thenThrow(new IOException("Test"));, +        cacheLoader.load(key, decoder, 100, 100, options);, +        when(decoder.decode(any(File.class), anyInt(), anyInt(), anyMapOf(String.class, Object.class))), +                .thenReturn(null);, +        cacheLoader.load(key, decoder, 100, 101, options);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java, +import static org.mockito.Matchers.anyMapOf;, +import java.util.Collections;, +import java.util.Map;, +        when(harness.cacheDecoder.decode(eq(cacheFile), eq(harness.width), eq(harness.height), eq(harness.options))), +        when(harness.cacheDecoder.decode(any(File.class), anyInt(), anyInt(), anyMapOf(String.class, Object.class))), +        verify(harness.cacheDecoder).decode(any(File.class), anyInt(), anyInt(), anyMapOf(String.class, Object.class));, +        when(harness.cacheDecoder.decode(any(File.class), anyInt(), anyInt(), anyMapOf(String.class, Object.class))), +                .thenThrow(new RuntimeException("test"));, +        when(harness.cacheDecoder.decode(any(File.class), anyInt(), anyInt(), anyMapOf(String.class, Object.class))), +                .thenReturn(null);, +        when(harness.cacheDecoder.decode(any(File.class), anyInt(), anyInt(), anyMapOf(String.class, Object.class))), +                .thenReturn(null);, +        when(harness.cacheDecoder.decode(eq(file), eq(harness.width), eq(harness.height), eq(harness.options))), +        when(harness.cacheDecoder.decode(any(File.class), anyInt(), anyInt(), anyMapOf(String.class, Object.class))), +                .thenReturn(null);]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java, +import com.bumptech.glide.request.target.Target;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +    @Mock, +        MockitoAnnotations.initMocks(this);, +        Resource<Bitmap> resource = mockResource(100, 100);, +        Resource<Bitmap> resource = mockResource(1, 2);, +        final Resource<Bitmap> resource = mockResource(223, 4123);, +                assertEquals(resource.get(), toTransform);, +                return resource.get();, +, +        Resource<Bitmap> resource = mockResource(100, 100);, +, +    @Test, +    public void testCallsTransformWithGivenBitmapWidthIfWidthIsSizeOriginal() {, +        SizeTrackingTransform transform = new SizeTrackingTransform();, +, +        int expectedWidth = 200;, +        Resource<Bitmap> resource = mockResource(expectedWidth, 300);, +        transform.transform(resource, Target.SIZE_ORIGINAL, 500);, +, +        assertEquals(expectedWidth, transform.givenWidth);, +    }, +, +    @Test, +    public void testCallsTransformWithGivenBitmapHeightIfHeightIsSizeOriginal() {, +        SizeTrackingTransform transform = new SizeTrackingTransform();, +, +        int expectedHeight = 500;, +        Resource<Bitmap> resource = mockResource(123, expectedHeight);, +        transform.transform(resource, 444, expectedHeight);, +, +        assertEquals(expectedHeight, transform.givenHeight);, +    }, +, +    @SuppressWarnings("unchecked"), +    private Resource<Bitmap> mockResource(int width, int height) {, +        Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);, +        Resource<Bitmap> resource = mock(Resource.class);, +        when(resource.get()).thenReturn(bitmap);, +        return resource;, +    }, +, +    private class SizeTrackingTransform extends BitmapTransformation {, +        int givenWidth;, +        int givenHeight;, +, +        public SizeTrackingTransform() {, +            super(bitmapPool);, +        }, +, +        @Override, +        protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {, +            givenWidth = outWidth;, +            givenHeight = outHeight;, +            return null;, +        }, +, +        @Override, +        public String getId() {, +            return null;, +        }, +    }, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java, +import com.bumptech.glide.request.target.Target;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +    @Mock, +        MockitoAnnotations.initMocks(this);, +        Resource<Bitmap> resource = mockResource(100, 100);, +        Resource<Bitmap> resource = mockResource(1, 2);, +        final Resource<Bitmap> resource = mockResource(223, 4123);, +                assertEquals(resource.get(), toTransform);, +                return resource.get();, +, +        Resource<Bitmap> resource = mockResource(100, 100);, +, +    @Test, +    public void testCallsTransformWithGivenBitmapWidthIfWidthIsSizeOriginal() {, +        SizeTrackingTransform transform = new SizeTrackingTransform();, +, +        int expectedWidth = 200;, +        Resource<Bitmap> resource = mockResource(expectedWidth, 300);, +        transform.transform(resource, Target.SIZE_ORIGINAL, 500);, +, +        assertEquals(expectedWidth, transform.givenWidth);, +    }, +, +    @Test, +    public void testCallsTransformWithGivenBitmapHeightIfHeightIsSizeOriginal() {, +        SizeTrackingTransform transform = new SizeTrackingTransform();, +, +        int expectedHeight = 500;, +        Resource<Bitmap> resource = mockResource(123, expectedHeight);, +        transform.transform(resource, 444, expectedHeight);, +, +        assertEquals(expectedHeight, transform.givenHeight);, +    }, +]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +        // TODO: call cancel on the client when this method is called on a background thread. See #257]
[+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +import com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder;, +import com.bumptech.glide.load.resource.gif.StreamGifDecoder;, +  /**, +   * Disables resource decoders that return animated resources so any resource returned will be, +   * static., +   *, +   * <p> To disable transitions (fades etc) use, +   * {@link com.bumptech.glide.TransitionOptions#dontTransition()}</p>, +   */, +  public final CHILD dontAnimate() {, +    set(ByteBufferGifDecoder.KEY_DISABLE_ANIMATION, true);, +    set(StreamGifDecoder.KEY_DISABLE_ANIMATION, true);, +    return selfOrThrowIfLocked();, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +import com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder;, +import com.bumptech.glide.load.resource.gif.StreamGifDecoder;, +  /**, +   * Disables resource decoders that return animated resources so any resource returned will be, +   * static., +   *, +   * <p> To disable transitions (fades etc) use, +   * {@link com.bumptech.glide.TransitionOptions#dontTransition()}</p>, +   */, +  public final CHILD dontAnimate() {, +    set(ByteBufferGifDecoder.KEY_DISABLE_ANIMATION, true);, +    set(StreamGifDecoder.KEY_DISABLE_ANIMATION, true);, +    return selfOrThrowIfLocked();, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +, +  /**, +   * Returns a new {@link com.bumptech.glide.request.RequestOptions} with {@link #dontAnimate()}, +   * called., +   */, +  public static RequestOptions noAnimation() {, +    return new RequestOptions().dontAnimate();, +  }]
[+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java, +    if (animatable != null) {, +      animatable.stop();, +    }, +++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java, +    if (animatable != null) {, +      animatable.stop();, +    }, +++ b/library/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java, +import static org.mockito.Mockito.never;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +  @Mock private AnimatedDrawable animatedDrawable;, +    MockitoAnnotations.initMocks(this);, +, +  @Test, +  public void onLoadCleared_withAnimatableDrawable_stopsDrawable() {, +    target.onResourceReady(animatedDrawable, /*transition=*/ null);, +    verify(animatedDrawable).start();, +    verify(animatedDrawable, never()).stop();, +, +    target.onLoadCleared(/*placeholder=*/ null);, +, +    verify(animatedDrawable).stop();, +  }, +]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import static org.mockito.Mockito.reset;, +import android.view.ViewGroup.LayoutParams;, +import android.widget.ImageView;, +import org.mockito.ArgumentMatchers;, +, +  @Test, +  public void loadIntoView_withoutSkipMemoryCache_loadsFromMemoryCacheIfPresent() {, +    final ImageView imageView = new ImageView(context);, +    imageView.setLayoutParams(new LayoutParams(100, 100));, +, +    concurrency.loadOnMainThread(, +        GlideApp.with(context), +            .load(ResourceIds.raw.canonical), +            .listener(requestListener), +            .dontTransform(),, +        imageView);, +, +    // Casting avoids a varags array warning., +    reset((RequestListener) requestListener);, +, +    // Run on the main thread, since this is already cached, we shouldn't need to try to wait. If we, +    // do end up re-using the old Target, our wait will always timeout anyway if we use, +    // loadOnMainThread. If the load doesn't complete in time, it will be caught by the listener, +    // below, which expects to be called synchronously., +    concurrency.runOnMainThread(, +        new Runnable() {, +          @Override, +          public void run() {, +            GlideApp.with(context), +                .load(ResourceIds.raw.canonical), +                .listener(requestListener), +                .dontTransform(), +                .into(imageView);, +          }, +        });, +, +    verify(requestListener), +        .onResourceReady(, +            anyDrawable(),, +            ArgumentMatchers.any(),, +            anyDrawableTarget(),, +            eq(DataSource.MEMORY_CACHE),, +            anyBoolean());, +  }, +, +  @Test, +  public void loadIntoView_withSkipMemoryCache_doesNotLoadFromMemoryCacheIfPresent() {, +    final ImageView imageView = new ImageView(context);, +    imageView.setLayoutParams(new LayoutParams(100, 100));, +, +    concurrency.loadOnMainThread(, +        GlideApp.with(context), +            .load(ResourceIds.raw.canonical), +            .listener(requestListener), +            .dontTransform(), +            .skipMemoryCache(true),, +        imageView);, +, +    // Casting avoids a varags array warning., +    reset((RequestListener) requestListener);, +, +    // If this test fails due to a timeout, it's because we re-used the Target from the previous, +    // request, which breaks the logic in loadOnMainThread that expects a new Target's, +    // onResourceReady callback to be called. This can be confirmed by changing this to, +    // runOnMainThread and verifying that the RequestListener assertion below fails because, +    // the DataSource was from the memory cache., +    concurrency.loadOnMainThread(, +        GlideApp.with(context), +            .load(ResourceIds.raw.canonical), +            .listener(requestListener), +            .dontTransform(), +            .skipMemoryCache(true),, +        imageView);, +, +    verify(requestListener), +        .onResourceReady(, +            anyDrawable(),, +            ArgumentMatchers.any(),, +            anyDrawableTarget(),, +            not(eq(DataSource.MEMORY_CACHE)),, +            anyBoolean());, +  }, +, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import static org.mockito.Mockito.reset;, +import android.view.ViewGroup.LayoutParams;, +import android.widget.ImageView;, +import org.mockito.ArgumentMatchers;, +, +  @Test, +  public void loadIntoView_withoutSkipMemoryCache_loadsFromMemoryCacheIfPresent() {, +    final ImageView imageView = new ImageView(context);, +    imageView.setLayoutParams(new LayoutParams(100, 100));, +, +    concurrency.loadOnMainThread(, +        GlideApp.with(context), +            .load(ResourceIds.raw.canonical), +            .listener(requestListener), +            .dontTransform(),]
[+++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java, +package com.bumptech.glide.integration.volley;, +, +import com.android.volley.Request;, +import com.android.volley.Request.Priority;, +, +import java.io.InputStream;, +, +/**, + * Used to construct a custom Volley request, such as for authentication header decoration., + */, +public interface VolleyRequestFactory {, +, +    /**, +     * Returns a Volley request for the given image url. The given future should be set as a, +     * listener or called when the request completes., +     */, +    Request<byte[]> create(String url, VolleyRequestFuture<InputStream> future, Priority priority);, +, +}, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java, +package com.bumptech.glide.integration.volley;, +, +import com.android.volley.Request;, +import com.android.volley.Request.Priority;, +, +import java.io.InputStream;, +, +/**, + * Used to construct a custom Volley request, such as for authentication header decoration., + */, +public interface VolleyRequestFactory {, +, +    /**, +     * Returns a Volley request for the given image url. The given future should be set as a, +     * listener or called when the request completes., +     */, +    Request<byte[]> create(String url, VolleyRequestFuture<InputStream> future, Priority priority);, +, +}, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +    public static final VolleyRequestFactory DEFAULT_REQUEST_FACTORY = new VolleyRequestFactory() {, +, +        @Override, +        public Request<byte[]> create(, +                    String url, VolleyRequestFuture<InputStream> future,, +                    Request.Priority priority) {, +            return new GlideRequest(url, future, priority);, +        }, +, +    };, +, +    private final VolleyRequestFactory requestFactory;, +        this(requestQueue, url, requestFuture, DEFAULT_REQUEST_FACTORY);, +    }, +, +    public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url,, +            VolleyRequestFuture<InputStream> requestFuture, VolleyRequestFactory requestFactory) {, +        this.requestFactory = requestFactory;, +        Request<byte[]> request = requestFactory.create(, +                stringUrl, requestFuture, glideToVolleyPriority(priority));, +        private final Priority priority;, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java, +package com.bumptech.glide.integration.volley;, +, +import com.android.volley.Request;, +import com.android.volley.Request.Priority;, +, +import java.io.InputStream;, +, +/**, + * Used to construct a custom Volley request, such as for authentication header decoration., + */, +public interface VolleyRequestFactory {, +, +    /**, +     * Returns a Volley request for the given image url. The given future should be set as a, +     * listener or called when the request completes., +     */, +    Request<byte[]> create(String url, VolleyRequestFuture<InputStream> future, Priority priority);, +, +}, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +    public static final VolleyRequestFactory DEFAULT_REQUEST_FACTORY = new VolleyRequestFactory() {, +, +        @Override, +        public Request<byte[]> create(, +                    String url, VolleyRequestFuture<InputStream> future,, +                    Request.Priority priority) {, +            return new GlideRequest(url, future, priority);, +        }, +, +    };, +, +    private final VolleyRequestFactory requestFactory;, +        this(requestQueue, url, requestFuture, DEFAULT_REQUEST_FACTORY);, +    }, +, +    public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url,, +            VolleyRequestFuture<InputStream> requestFuture, VolleyRequestFactory requestFactory) {]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ /dev/null, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ /dev/null, +++ b/README.md, +Before submitting pull requests, contributors must sign Google's [individual contribution license agreement][7]., +[5]: https://github.com/bumptech/glide/issues/new, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ /dev/null, +++ b/README.md, +Before submitting pull requests, contributors must sign Google's [individual contribution license agreement][7]., +[5]: https://github.com/bumptech/glide/issues/new, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }]
[+++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +     * @see com.bumptech.glide.load.resource.transcode.GlideBitmapDrawableTranscoder, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +     * @see com.bumptech.glide.load.resource.transcode.GlideBitmapDrawableTranscoder, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.bitmap.GlideBitmapDrawable;, +import com.bumptech.glide.load.resource.transcode.GlideBitmapDrawableTranscoder;, +        transcoderRegistry.register(Bitmap.class, GlideBitmapDrawable.class,, +                new GlideBitmapDrawableTranscoder(context.getResources(), bitmapPool));, +                        new GlideBitmapDrawableTranscoder(context.getResources(), bitmapPool)));, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +     * @see com.bumptech.glide.load.resource.transcode.GlideBitmapDrawableTranscoder, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.bitmap.GlideBitmapDrawable;, +import com.bumptech.glide.load.resource.transcode.GlideBitmapDrawableTranscoder;, +        transcoderRegistry.register(Bitmap.class, GlideBitmapDrawable.class,, +                new GlideBitmapDrawableTranscoder(context.getResources(), bitmapPool));, +                        new GlideBitmapDrawableTranscoder(context.getResources(), bitmapPool)));, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/GlideBitmapDrawable.java, +package com.bumptech.glide.load.resource.bitmap;, +, +import android.content.res.Resources;, +import android.graphics.Bitmap;, +import android.graphics.Canvas;, +import android.graphics.ColorFilter;, +import android.graphics.Paint;, +import android.graphics.PixelFormat;, +import android.graphics.Rect;, +import android.graphics.drawable.Drawable;, +import android.util.DisplayMetrics;, +import android.view.Gravity;, +, +import com.bumptech.glide.load.resource.drawable.GlideDrawable;, +, +/**, + * A static {@link com.bumptech.glide.load.resource.drawable.GlideDrawable} for displaying a single image., + */, +public class GlideBitmapDrawable extends GlideDrawable {, +    private final Rect destRect = new Rect();, +    private int width;, +    private int height;, +    private boolean applyGravity;, +    private BitmapState state;, +, +    public GlideBitmapDrawable(Resources res, Bitmap bitmap) {, +        this(res, new BitmapState(bitmap));, +    }, +, +    GlideBitmapDrawable(Resources res, BitmapState state) {, +        this.state = state;, +        final int targetDensity;, +        if (res != null) {, +            final int density = res.getDisplayMetrics().densityDpi;, +            targetDensity = density == 0 ? DisplayMetrics.DENSITY_DEFAULT : density;, +            state.targetDensity = targetDensity;, +        } else {, +            targetDensity = state.targetDensity;, +        }, +        width = state.bitmap.getScaledWidth(targetDensity);, +        height = state.bitmap.getScaledHeight(targetDensity);, +    }, +, +    @Override, +    public int getIntrinsicWidth() {, +        return width;, +    }, +, +    @Override, +    public int getIntrinsicHeight() {, +        return height;, +    }, +, +    @Override, +    public boolean isAnimated() {, +        return false;, +    }, +, +    @Override, +    public void setLoopCount(int loopCount) {, +        // Do nothing., +    }, +, +    @Override, +    public void start() {, +        // Do nothing., +    }, +, +    @Override, +    public void stop() {, +        // Do nothing., +    }, +, +    @Override, +    public boolean isRunning() {, +        return false;, +    }, +, +    @Override, +    protected void onBoundsChange(Rect bounds) {, +        super.onBoundsChange(bounds);]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +import com.bumptech.glide.load.model.stream.HttpGlideUrlLoader;, +   * Returns a {@link RequestOptions} object with {@link #timeout(int)} set., +   */, +  public static RequestOptions timeoutOf(int timeout) {, +    return new RequestOptions().timeout(timeout);, +  }, +, +  /**, +   * <p>This is a component option specific to {@link VideoBitmapDecoder}. If the default video, +   * decoder is replaced or skipped because of your configuration, this option may be ignored., +   *, +   * @see VideoBitmapDecoder#TARGET_FRAME, +   * Sets the {@link DecodeFormat} to use when decoding {@link Bitmap} objects using, +   * {@link Downsampler}., +   *, +   * <p>{@link DecodeFormat} is a request, not a requirement. It's possible the resource will be, +   * decoded using a decoder that cannot control the format, +   * ({@link android.media.MediaMetadataRetriever} for example), or that the decoder may choose to, +   * ignore the requested format if it can't display the image (i.e. RGB_565 is requested, but the, +   * image has alpha)., +   *, +   * <p>This is a component option specific to {@link Downsampler}. If the defautlt Bitmap decoder, +   * is replaced or skipped because of your configuration, this option may be ignored., +   *, +   * @see Downsampler#DECODE_FORMAT, +   */, +  public RequestOptions format(@NonNull DecodeFormat format) {, +    return set(Downsampler.DECODE_FORMAT, Preconditions.checkNotNull(format));, +  }, +, +  /**, +   *, +   * <p>This is a component option specific to {@link Downsampler}. If the defautlt Bitmap decoder, +   * is replaced or skipped because of your configuration, this option may be ignored., +   * Sets the read and write timeout for the http requests used to load the image., +   *, +   * <p>This is a component option specific to Glide's default networking library and, +   * {@link com.bumptech.glide.load.model.stream.HttpGlideUrlLoader}. If you use any other, +   * networking library including Glide's Volley or OkHttp integration libraries, this option will, +   * be ignored., +   *, +   * @see com.bumptech.glide.load.model.stream.HttpGlideUrlLoader#TIMEOUT, +   * @param timeoutMs The read and write timeout in milliseconds., +   */, +  public RequestOptions timeout(int timeoutMs) {, +    return set(HttpGlideUrlLoader.TIMEOUT, timeoutMs);, +  }, +, +  /**]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.when;, +    @Test, +    public void testPassesArgb888ToStrategyAsConfigForRequestsWithNullConfigsOnGet() {, +        LruPoolStrategy strategy = mock(LruPoolStrategy.class);, +        LruBitmapPool pool = new LruBitmapPool(100, strategy);, +, +        Bitmap expected = createMutableBitmap();, +        when(strategy.get(anyInt(), anyInt(), eq(Bitmap.Config.ARGB_8888))).thenReturn(expected);, +        Bitmap result = pool.get(100, 100, null);, +, +        assertEquals(expected, result);, +    }, +, +    @Test, +    public void testPassesArgb8888ToStrategyAsConfigForRequestsWithNullConfigsOnGetDirty() {, +        LruPoolStrategy strategy = mock(LruPoolStrategy.class);, +        LruBitmapPool pool = new LruBitmapPool(100, strategy);, +, +        Bitmap expected = createMutableBitmap();, +        when(strategy.get(anyInt(), anyInt(), eq(Bitmap.Config.ARGB_8888))).thenReturn(expected);, +        Bitmap result = pool.getDirty(100, 100, null);, +, +        assertEquals(expected, result);, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.when;, +    @Test, +    public void testPassesArgb888ToStrategyAsConfigForRequestsWithNullConfigsOnGet() {, +        LruPoolStrategy strategy = mock(LruPoolStrategy.class);, +        LruBitmapPool pool = new LruBitmapPool(100, strategy);, +, +        Bitmap expected = createMutableBitmap();, +        when(strategy.get(anyInt(), anyInt(), eq(Bitmap.Config.ARGB_8888))).thenReturn(expected);, +        Bitmap result = pool.get(100, 100, null);, +, +        assertEquals(expected, result);, +    }, +, +    @Test, +    public void testPassesArgb8888ToStrategyAsConfigForRequestsWithNullConfigsOnGetDirty() {, +        LruPoolStrategy strategy = mock(LruPoolStrategy.class);, +        LruBitmapPool pool = new LruBitmapPool(100, strategy);, +, +        Bitmap expected = createMutableBitmap();, +        when(strategy.get(anyInt(), anyInt(), eq(Bitmap.Config.ARGB_8888))).thenReturn(expected);, +        Bitmap result = pool.getDirty(100, 100, null);, +, +        assertEquals(expected, result);, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java, +import org.robolectric.Robolectric;, +import static org.mockito.Matchers.isNull;, +    public void testAsksBitmapPoolForArgb8888IfInConfigIsNull() {, +        Robolectric.shadowOf(harness.bitmap).setConfig(null);, +, +        harness.centerCrop.transform(harness.resource, 10, 10);, +, +        verify(harness.pool).get(anyInt(), anyInt(), eq(Bitmap.Config.ARGB_8888));, +        verify(harness.pool, never()).get(anyInt(), anyInt(), (Bitmap.Config) isNull());, +    }, +, +    @Test, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.when;, +    @Test, +    public void testPassesArgb888ToStrategyAsConfigForRequestsWithNullConfigsOnGet() {, +        LruPoolStrategy strategy = mock(LruPoolStrategy.class);, +        LruBitmapPool pool = new LruBitmapPool(100, strategy);, +, +        Bitmap expected = createMutableBitmap();, +        when(strategy.get(anyInt(), anyInt(), eq(Bitmap.Config.ARGB_8888))).thenReturn(expected);, +        Bitmap result = pool.get(100, 100, null);, +, +        assertEquals(expected, result);, +    }, +, +    @Test, +    public void testPassesArgb8888ToStrategyAsConfigForRequestsWithNullConfigsOnGetDirty() {, +        LruPoolStrategy strategy = mock(LruPoolStrategy.class);, +        LruBitmapPool pool = new LruBitmapPool(100, strategy);, +, +        Bitmap expected = createMutableBitmap();, +        when(strategy.get(anyInt(), anyInt(), eq(Bitmap.Config.ARGB_8888))).thenReturn(expected);, +        Bitmap result = pool.getDirty(100, 100, null);, +, +        assertEquals(expected, result);, +    }, +]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java, +    assertThat(toCompress.compress(CompressFormat.PNG, 100, os)).isTrue();, +    // TODO(b/71430152): Figure out whether or not this is supposed to pass in API 26 and fail in, +    // API 27., +    assumeTrue(Build.VERSION.SDK_INT != Build.VERSION_CODES.O_MR1);, +    assertThat(toCompress.compress(CompressFormat.JPEG, 100, os)).isTrue();, +    assertThat(toCompress.compress(CompressFormat.WEBP, 100, os)).isTrue();]
[+++ b/checkstyle.xml, +           <property name="groups" value="*"/>, +++ b/checkstyle.xml, +           <property name="groups" value="*"/>, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +++ b/checkstyle.xml, +           <property name="groups" value="*"/>, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import java.io.File;, +import java.io.IOException;, +import java.io.OutputStream;, +import java.nio.ByteBuffer;, +++ b/checkstyle.xml, +           <property name="groups" value="*"/>, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import java.io.File;, +import java.io.IOException;, +import java.io.OutputStream;, +import java.nio.ByteBuffer;, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +++ b/checkstyle.xml, +           <property name="groups" value="*"/>, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import java.io.File;, +import java.io.IOException;, +import java.io.OutputStream;, +import java.nio.ByteBuffer;, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +++ b/checkstyle.xml, +           <property name="groups" value="*"/>, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import java.io.File;, +import java.io.IOException;, +import java.io.OutputStream;, +import java.nio.ByteBuffer;, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +++ b/checkstyle.xml, +           <property name="groups" value="*"/>, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import java.io.File;, +import java.io.IOException;, +import java.io.OutputStream;, +import java.nio.ByteBuffer;, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +import java.io.IOException;, +import java.io.InputStream;, +import java.util.Map;, +++ b/checkstyle.xml, +           <property name="groups" value="*"/>, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import java.io.File;, +import java.io.IOException;, +import java.io.OutputStream;, +import java.nio.ByteBuffer;, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +import java.io.IOException;, +import java.io.InputStream;, +import java.util.Map;, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java, +import java.io.InputStream;, +++ b/checkstyle.xml, +           <property name="groups" value="*"/>, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import java.io.File;, +import java.io.IOException;, +import java.io.OutputStream;, +import java.nio.ByteBuffer;, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +import java.io.IOException;, +import java.io.InputStream;, +import java.util.Map;, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java, +import java.io.InputStream;, +++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java, +++ b/checkstyle.xml, +           <property name="groups" value="*"/>, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import java.io.File;, +import java.io.IOException;, +import java.io.OutputStream;]
[+++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +            public List<Object> getPreloadItems(int start, int end) {, +                assertEquals(11, start);, +                assertEquals(21, end);, +                return super.getPreloadItems(start, end);, +        assertTrue(called.get());, +            public int expectedPosition;, +, +            public int[] getPreloadSize(Object item) {, +            public List<Object> getPreloadItems(int start, int end) {, +                return objects;, +            public BitmapRequestBuilder getPreloadRequestBuilder(Object item) {, +                assertEquals(objects.get(expectedPosition), item);, +                expectedPosition++;, +        preloader.onScroll(null, 1, 10, 30);, +            public List<Object> getPreloadItems(int start, int end) {, +                if (start == 40) {, +                assertEquals(19, start);, +                assertEquals(29, end);, +                return super.getPreloadItems(start, end);, +            public int[] getPreloadSize(Object item) {, +            public List<Object> getPreloadItems(int start, int end) {, +                if (start == 40) {, +                    return Collections.emptyList();, +                return objects;, +            public BitmapRequestBuilder getPreloadRequestBuilder(Object item) {, +        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, toPreload);, +        preloader.onScroll(null, 30, 10, 40);, +        preloader.onScroll(null, 29, 10, 40);, +            public List<Object> getPreloadItems(int start, int end) {, +                assertEquals(26, start);, +                assertEquals(30, end);, +                return super.getPreloadItems(start, end);, +            public List<Object> getPreloadItems(int start, int end) {, +                if (start == 17) {, +                assertEquals(0, start);, +                assertEquals(6, end);, +                return super.getPreloadItems(start, end);, +            public List<Object> getPreloadItems(int start, int end) {, +                if (current == 0) {, +                    assertEquals(11, start);, +                    assertEquals(21, end);, +                } else if (current == 1) {, +                    assertEquals(21, start);, +                    assertEquals(24, end);, +                }, +                return super.getPreloadItems(start, end);, +        assertEquals(2, called.get());, +            public List<Object> getPreloadItems(int start, int end) {, +                if (start == 30) {, +                if (current == 0) {, +                    assertEquals(10, start);, +                    assertEquals(20, end);, +                } else if (current == 1) {, +                    assertEquals(7, start);, +                    assertEquals(10, end);, +                }, +                return super.getPreloadItems(start, end);, +        assertEquals(2, called.get());, +            public List<Object> getPreloadItems(int start, int end) {, +                return objects;, +            public GenericRequestBuilder getPreloadRequestBuilder(Object item) {, +                return super.getPreloadRequestBuilder(item);, +        preloader.onScroll(null, 1, 10, 30);, +        public List<Object> getPreloadItems(int start, int end) {, +            ArrayList<Object> result = new ArrayList<Object>(end - start);, +            Collections.fill(result, new Object());, +            return result;, +        public GenericRequestBuilder getPreloadRequestBuilder(Object item) {, +        public int[] getPreloadSize(Object item) {, +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +            public List<Object> getPreloadItems(int start, int end) {, +                assertEquals(11, start);, +                assertEquals(21, end);, +                return super.getPreloadItems(start, end);, +        assertTrue(called.get());, +            public int expectedPosition;, +, +            public int[] getPreloadSize(Object item) {, +            public List<Object> getPreloadItems(int start, int end) {, +                return objects;, +            public BitmapRequestBuilder getPreloadRequestBuilder(Object item) {, +                assertEquals(objects.get(expectedPosition), item);, +                expectedPosition++;, +        preloader.onScroll(null, 1, 10, 30);, +            public List<Object> getPreloadItems(int start, int end) {, +                if (start == 40) {, +                assertEquals(19, start);, +                assertEquals(29, end);, +                return super.getPreloadItems(start, end);, +            public int[] getPreloadSize(Object item) {, +            public List<Object> getPreloadItems(int start, int end) {, +                if (start == 40) {, +                    return Collections.emptyList();, +                return objects;, +            public BitmapRequestBuilder getPreloadRequestBuilder(Object item) {, +        ListPreloader<Object> preloader = new ListPreloader<Object>(preloaderAdapter, preloaderAdapter, toPreload);, +        preloader.onScroll(null, 30, 10, 40);, +        preloader.onScroll(null, 29, 10, 40);, +            public List<Object> getPreloadItems(int start, int end) {]
[+++ b/library/lint.xml, +    <issue id="InlinedApi">, +        <ignore path="src/com/bumptech/glide/resize/cache/LruMemoryCache.java" />, +    </issue>, +++ b/library/lint.xml, +    <issue id="InlinedApi">, +        <ignore path="src/com/bumptech/glide/resize/cache/LruMemoryCache.java" />, +    </issue>, +++ b/library/src/com/bumptech/glide/Glide.java, +     * A class for monitoring the status of a request while images load., +     *, +     * @param <T> The type of the model being loaded, +     */, +    public static abstract class RequestListener<T> {, +, +        /**, +         * Called when an exception occurs during a load. Will only be called if we currently want to display an image, +         * for the given model in the given target. It is recommended to create a single instance per activity/fragment, +         * rather than instantiate a new object for each call to {@code Glide.load()} to avoid object churn., +         *, +         * <p>, +         *     It is safe to reload this or a different model or change what is displayed in the target at this point., +         *     For example:, +         * <pre>, +         * <code>, +         *     public void onException(Exception e, T model, Target target) {, +         *         target.setPlaceholder(R.drawable.a_specific_error_for_my_exception);, +         *         Glide.load(model).into(target);, +         *     }, +         * </code>, +         * </pre>, +         * </p>, +         *, +         * <p>, +         *     Note - if you want to reload this or any other model after an exception, you will need to include all, +         *     relevant builder calls (like centerCrop, placeholder etc)., +         * </p>, +         *, +         * @param e The exception, or null, +         * @param model The model we were trying to load when the exception occurred, +         * @param target The {@link Target} we were trying to load the image into, +         */, +        public abstract void onException(Exception e, T model, Target target);, +, +        /**, +         * Called when a load completes successfully, immediately after, +         * {@link Target#onImageReady(android.graphics.Bitmap)}., +         *, +         * @param model The specific model that was used to load the image., +         * @param target The target the model was loaded into., +         */, +        public abstract void onImageReady(T model, Target target);, +, +        /**, +         * {@inheritDoc}, +         *, +         * <p>, +         *     By default we only check the both objects are not null and that their classes are identical. This assumes, +         *     that two instances of the same anonymous inner class will behave identically., +         * </p>, +         */, +        @Override, +        public boolean equals(Object o) {, +            if (this == o) return true;, +            if (o == null || getClass() != o.getClass()) return false;, +, +            return true;, +        }, +, +        /**, +         * {@inheritDoc }, +         */, +        @Override, +        public int hashCode() {, +            throw new UnsupportedOperationException();, +        }, +    }, +, +    /**, +        private RequestListener<T> requestListener;, +         * Sets a Request listener to monitor the image load. It's best to create a single instance of an exception, +         * handler per type of request (usually activity/fragment) rather than pass one in per request to avoid some, +         * redundant object allocation., +         *, +         * @param requestListener The request listener to use, +         * @return This request, +         */, +        public Request<T> listener(RequestListener<T> requestListener) {, +            this.requestListener = requestListener;, +, +            return this;, +        }, +, +        /**, +        private ImagePresenter<T> buildImagePresenter(final Target target) {, +            if (animationId != -1 || requestListener != null) {, +                final Animation animation;, +                    animation = AnimationUtils.loadAnimation(context, animationId);, +                } else {, +                    animation = null;]
[+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +   * @see #centerInside(Context) (android.content.Context), +   * @param context Any {@link android.content.Context}., +   * @see #transform(Class, com.bumptech.glide.load.Transformation), +   * @see #optionalCenterInside(Context) (android.content.Context), +   *, +   * @deprecated Use {@link #centerInside()}}, +   */, +  @Deprecated, +  @GlideOption(, +      staticMethodName = "centerInsideTransform",, +      memoizeStaticMethod = true, +  ), +  public CHILD centerInside(@SuppressWarnings("unused") Context context) {, +    return centerInside();, +  }, +, +  /**, +   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types and, +   * throws an exception if asked to transform an unknown type., +   *, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *]
[+++ b/CHANGELOG.md, +# Change Log, +, +## [v4.5.0](https://github.com/bumptech/glide/tree/HEAD), +, +[Full Changelog](https://github.com/bumptech/glide/compare/v4.4.0...v4.5.0), +, +## Features, +* Add an API to pause all requests for a given `Activity` or `Fragment` to allow callers to manually reduce memory when their Fragment or Application is backgrounded (@kurtisnelson, 09e33a2133eb1d4005b227439c0c53c9c4e8c89b) , +* Fully support Bitmap re-use for `RGBA_F16` `Bitmap`s. Previously Glide supported decoding `RGBA_F16` `Bitmap`s, but would not re-use any stored in the `BitmapPool` when doing so (cc0288c3b4bfb82a109a3f279af52c57fc5e1499), +* Support decoding Videos from resources as `AssetFileDescriptor`s (6e9866b5a19d06625006a9a8c605db21047df74b), +* Added support for the [`MediaMetadataRetriever#getScaledFrameAtTime`][2] method added in OMR1 to marginally reduce memory usage when decoding video frames (ded8f77c9f2471e3c3413aa234656df8cf72dd2f), +* Support transcoding `BitmapDrawable`s to `byte[]`s (015d2659a9ea7438ab72b94500a0921f8ff35aa3), +, +## Bugs, +* Cleaned up old and incorrect `@TargetApi` annoatations (@SUPERCILEX, 67783961c71639871cc3687894976e6caeb6609e), +* Added `@Nullable` and `@NonNull` annotations to many of Glide's APIs (@SUPERCILEX, dc12b60c8f0a21eb9b3ab2164471c93d2e20ae25, c3dafde00a061bafcd43a739336ca3503af13a7d, 0cffd1da977e9ca334032ebc1d798213a177aab7, f541b65e596a49d252ba6b80d3b05a111ce93461, 36e0b802c3a1e564caf230b351a6438fa32100ac, 650bb7770d08b279c2a7f00e25337618da54f7f3, bd2f21595d3404e6aadf1f4333bef369509c4a56, e35a73b4e78f2f05dc5c1163b8083ac1b662b02f, f37ced1512f7eabf37f6c93b1b7ffb32c3629b72, bb96b633174184965cd1bdf9027ef3843f59c54f, 276d4ff4bdce85763c985c90a87ea5e858a1ffe4, c3107801dab8ccbe121157bee7dba29b7d9723e6, ), +* Fixed a case where restarting an identical request with `skipMemoryCache(true)` would complete the load from the memory cache (#2663, 3dc1d18da75b44d8d97f4161fe0d330e4993e537), +* Fixed decoding interlaced and downsampled GIFs as static images (#2698, b64f23de2a7ba38fceac1cda85f05158e80132f9), +* Added more models to the list of devices requiring a lock when decoding or drawing Bitmaps (@strooooke, #738, c809f7ec03bbfc2c529f2c211cfc644c2073aab0, e923554b10fa9625f4fa6fe706f3d5a553843ab9), +* Fixed a race condition where starting multiple loads simultaneously the first time any request is made for a given model and resource could lead to NPEs (#2708, d427cbd33206cbcc88ac4a0f0c29ef831d4bb5b5), +* Make the annotation processor tests pass on Windows (@SUPERCILEX, #2709, 2b4be8b8c210abb34740f0778434679b644a6525), +* Fix NPE and RuntimeExceptions thrown in `DefaultConnectivityMonitor` on some devices (c902730b75085cecdd40cd5817453d8af0eff4e9), +* Only trim to half of the memory cache maximum size, not the current size, when background the app (@kurtisnelson, 429b7e2d9854da549eb0b852e2e08de176f05fbf), +* Fix a `StateVerifier` exception thrown when `ResourceEncoder` implementations unexpectedly throw exceptions while writing resources to Glide's disk cache (6c7cf3f8cae998469a7e7df8c70c459311479a38), +* Fix an NPE error message when `ResourceDrawableDecoder` fails to decode an image (d522ac7249ca1bf71f6de30e62d71a1faa8d4c4c), +* Fix an `IllegalStateException` if a request using [`.error()`][3] is cleared while the error request is running (#2767, 9c70aa5f92f523c6bac29628554fdde5428e0cdd), +* Cleaned up a number of accessor classes generated by unnecessarily strict visibility in inner classes (@TWiStErRob, e02969417a75048af0fcb61c5fbf6ea94bd2c4aa), +* Updated OkHttp and removed a no longer necessary workaround for `ClassCastException`s thrown by the Android framework on O (#2355, 642b2dc431e54cb677088e934743d78f1ad84810), +* Added missing annotations to overrides on some of Glide's generated classes (@TWiStErRob, 62d7464fb4f874897121591815ecb7503f7bc01b, 9fde00628f223e96372aeceadcb3e35a0635cb6d, d7bb6f956b34dd00ad0dbcb64f15f4b9c2fb0538), +* Avoid throwing exceptions when `LruBitmapPool` was asked to provide `Bitmap`s with a `null` config (c1036c1cdc3c85827bf566e104a12ca880e26411), +, +, +## Behavior Changes, +* Default to `aar` packaging in POMs, so `@aar` should no longer be required to avoid warnings about jars depending on aars (06ba3442fd8d25c943e986c2bd6c138aa4b390e3), +* Default active resource retention to false (73759b9eb1d3b186c4deb6412137b0b1193fbd5d), but leave the option in `GlideBuilder` to manually enable it. Enabling active resource retention can lead to recycled `Bitmap` errors or `Bitmap` re-use bugs if applications call `Bitmap.recycle()` on any images loaded by Glide or mutate the contents of `Bitmap`s loaded by Glide. , +* Treat devices with API < 19 as having `ActivityManager.isLowRam` set to `true` (#2650, b221d4bbec138efcdb1aabd07600b7df713f9e40), +, +## Breaking Changes, +* Removed deprecated constructors requiring `Context`s in most of Glide's default `Transformation` (23975d933bcda7d136340b9988f2bd575065b667, 733b2e0f25a6d3ddbb4942172e92a9fe01c87363, 9bedc2b5fe5b1b2e05203af173c73f0e599a0177, 55594baf791ccb49dd5cdc256662360717b409bb, d8f6224d127b984c3ac1356d44f62126e4843d07, d840533448fd7bde528e0af7ce10c49653430c12, 2f76842b8ef9ac15c43a2c5175f23496b5a13f37, 144ac5374eb0bd11a8f8e92d7346dafac1426621, 150ebabbd7d5e8751c8678fa01418d1b1f1259da, 92d761d002da25320f2c504267f56d73b889b2d4, a6f1b1c1bef5b4e8be736c564792715266b07463) , +, +## Deprecations, +* Deprecated [`VideoBitmapDecoder`][4], use [`VideoDecoder`][5] instead., +, +## Build Changes, +* Glide must be compiled against API 27 (@SUPERCILEX, #2730, 75c2a8b6d216013e7fbf797231839a8f4c82757a), +* Glide uses v27 of the support libraries (though v26 should work as well, to use v26 of the support library, see [Glide's Android SDK requirements docs page][1]), +* Updated to PMD 6.0.0 (@TWiStErRob, f16aef4c6ad583bafe796c7a952a0d10920c4dcd), +* Fix a PMD failure when building with --profile or any other way in which class files didn't happen to have already been compiled (@TWiStErRob, #2776, fd73179166b15af246769c9b1ae205c65c584e5b), +, +[1]: http://bumptech.github.io/glide/doc/download-setup.html#android-sdk-requirements, +[2]: https://developer.android.com/reference/android/media/MediaMetadataRetriever.html#getScaledFrameAtTime(long,%20int,%20int,%20int), +[3]: http://bumptech.github.io/glide/javadocs/440/com/bumptech/glide/RequestBuilder.html#error-com.bumptech.glide.RequestBuilder-, +[4]: http://bumptech.github.io/glide/javadocs/450/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.html, +++ b/CHANGELOG.md, +# Change Log, +, +## [v4.5.0](https://github.com/bumptech/glide/tree/HEAD), +, +[Full Changelog](https://github.com/bumptech/glide/compare/v4.4.0...v4.5.0), +, +## Features, +* Add an API to pause all requests for a given `Activity` or `Fragment` to allow callers to manually reduce memory when their Fragment or Application is backgrounded (@kurtisnelson, 09e33a2133eb1d4005b227439c0c53c9c4e8c89b) , +* Fully support Bitmap re-use for `RGBA_F16` `Bitmap`s. Previously Glide supported decoding `RGBA_F16` `Bitmap`s, but would not re-use any stored in the `BitmapPool` when doing so (cc0288c3b4bfb82a109a3f279af52c57fc5e1499), +* Support decoding Videos from resources as `AssetFileDescriptor`s (6e9866b5a19d06625006a9a8c605db21047df74b), +* Added support for the [`MediaMetadataRetriever#getScaledFrameAtTime`][2] method added in OMR1 to marginally reduce memory usage when decoding video frames (ded8f77c9f2471e3c3413aa234656df8cf72dd2f), +* Support transcoding `BitmapDrawable`s to `byte[]`s (015d2659a9ea7438ab72b94500a0921f8ff35aa3), +, +## Bugs, +* Cleaned up old and incorrect `@TargetApi` annoatations (@SUPERCILEX, 67783961c71639871cc3687894976e6caeb6609e), +* Added `@Nullable` and `@NonNull` annotations to many of Glide's APIs (@SUPERCILEX, dc12b60c8f0a21eb9b3ab2164471c93d2e20ae25, c3dafde00a061bafcd43a739336ca3503af13a7d, 0cffd1da977e9ca334032ebc1d798213a177aab7, f541b65e596a49d252ba6b80d3b05a111ce93461, 36e0b802c3a1e564caf230b351a6438fa32100ac, 650bb7770d08b279c2a7f00e25337618da54f7f3, bd2f21595d3404e6aadf1f4333bef369509c4a56, e35a73b4e78f2f05dc5c1163b8083ac1b662b02f, f37ced1512f7eabf37f6c93b1b7ffb32c3629b72, bb96b633174184965cd1bdf9027ef3843f59c54f, 276d4ff4bdce85763c985c90a87ea5e858a1ffe4, c3107801dab8ccbe121157bee7dba29b7d9723e6, ), +* Fixed a case where restarting an identical request with `skipMemoryCache(true)` would complete the load from the memory cache (#2663, 3dc1d18da75b44d8d97f4161fe0d330e4993e537), +* Fixed decoding interlaced and downsampled GIFs as static images (#2698, b64f23de2a7ba38fceac1cda85f05158e80132f9), +* Added more models to the list of devices requiring a lock when decoding or drawing Bitmaps (@strooooke, #738, c809f7ec03bbfc2c529f2c211cfc644c2073aab0, e923554b10fa9625f4fa6fe706f3d5a553843ab9), +* Fixed a race condition where starting multiple loads simultaneously the first time any request is made for a given model and resource could lead to NPEs (#2708, d427cbd33206cbcc88ac4a0f0c29ef831d4bb5b5), +* Make the annotation processor tests pass on Windows (@SUPERCILEX, #2709, 2b4be8b8c210abb34740f0778434679b644a6525), +* Fix NPE and RuntimeExceptions thrown in `DefaultConnectivityMonitor` on some devices (c902730b75085cecdd40cd5817453d8af0eff4e9), +* Only trim to half of the memory cache maximum size, not the current size, when background the app (@kurtisnelson, 429b7e2d9854da549eb0b852e2e08de176f05fbf), +* Fix a `StateVerifier` exception thrown when `ResourceEncoder` implementations unexpectedly throw exceptions while writing resources to Glide's disk cache (6c7cf3f8cae998469a7e7df8c70c459311479a38), +* Fix an NPE error message when `ResourceDrawableDecoder` fails to decode an image (d522ac7249ca1bf71f6de30e62d71a1faa8d4c4c), +* Fix an `IllegalStateException` if a request using [`.error()`][3] is cleared while the error request is running (#2767, 9c70aa5f92f523c6bac29628554fdde5428e0cdd), +* Cleaned up a number of accessor classes generated by unnecessarily strict visibility in inner classes (@TWiStErRob, e02969417a75048af0fcb61c5fbf6ea94bd2c4aa), +* Updated OkHttp and removed a no longer necessary workaround for `ClassCastException`s thrown by the Android framework on O (#2355, 642b2dc431e54cb677088e934743d78f1ad84810), +* Added missing annotations to overrides on some of Glide's generated classes (@TWiStErRob, 62d7464fb4f874897121591815ecb7503f7bc01b, 9fde00628f223e96372aeceadcb3e35a0635cb6d, d7bb6f956b34dd00ad0dbcb64f15f4b9c2fb0538), +* Avoid throwing exceptions when `LruBitmapPool` was asked to provide `Bitmap`s with a `null` config (c1036c1cdc3c85827bf566e104a12ca880e26411), +, +, +## Behavior Changes, +* Default to `aar` packaging in POMs, so `@aar` should no longer be required to avoid warnings about jars depending on aars (06ba3442fd8d25c943e986c2bd6c138aa4b390e3), +* Default active resource retention to false (73759b9eb1d3b186c4deb6412137b0b1193fbd5d), but leave the option in `GlideBuilder` to manually enable it. Enabling active resource retention can lead to recycled `Bitmap` errors or `Bitmap` re-use bugs if applications call `Bitmap.recycle()` on any images loaded by Glide or mutate the contents of `Bitmap`s loaded by Glide. , +* Treat devices with API < 19 as having `ActivityManager.isLowRam` set to `true` (#2650, b221d4bbec138efcdb1aabd07600b7df713f9e40), +, +## Breaking Changes, +* Removed deprecated constructors requiring `Context`s in most of Glide's default `Transformation` (23975d933bcda7d136340b9988f2bd575065b667, 733b2e0f25a6d3ddbb4942172e92a9fe01c87363, 9bedc2b5fe5b1b2e05203af173c73f0e599a0177, 55594baf791ccb49dd5cdc256662360717b409bb, d8f6224d127b984c3ac1356d44f62126e4843d07, d840533448fd7bde528e0af7ce10c49653430c12, 2f76842b8ef9ac15c43a2c5175f23496b5a13f37, 144ac5374eb0bd11a8f8e92d7346dafac1426621, 150ebabbd7d5e8751c8678fa01418d1b1f1259da, 92d761d002da25320f2c504267f56d73b889b2d4, a6f1b1c1bef5b4e8be736c564792715266b07463) , +, +## Deprecations, +* Deprecated [`VideoBitmapDecoder`][4], use [`VideoDecoder`][5] instead., +, +## Build Changes, +* Glide must be compiled against API 27 (@SUPERCILEX, #2730, 75c2a8b6d216013e7fbf797231839a8f4c82757a)]
[+++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import org.robolectric.shadows.ShadowBitmap;, +        GlideShadowLooper.class, GlideTest.MutableShadowBitmap.class }), +    @Implements(Bitmap.class), +    public static class MutableShadowBitmap extends ShadowBitmap {, +, +        @Implementation, +        public static Bitmap createBitmap(int width, int height, Bitmap.Config config) {, +            Bitmap bitmap = ShadowBitmap.createBitmap(width, height, config);, +            Robolectric.shadowOf(bitmap).setMutable(true);, +            return bitmap;, +        }, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import org.robolectric.shadows.ShadowBitmap;, +        GlideShadowLooper.class, GlideTest.MutableShadowBitmap.class }), +    @Implements(Bitmap.class), +    public static class MutableShadowBitmap extends ShadowBitmap {, +, +        @Implementation, +        public static Bitmap createBitmap(int width, int height, Bitmap.Config config) {, +            Bitmap bitmap = ShadowBitmap.createBitmap(width, height, config);, +            Robolectric.shadowOf(bitmap).setMutable(true);, +            return bitmap;, +        }, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java, +import android.graphics.Bitmap;, +import com.bumptech.glide.util.Util;, +    public void testReturnsDrawableSizePlusFirstFrameSize() {, +        Bitmap firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +        when(drawable.getFirstFrame()).thenReturn(firstFrame);, +        assertEquals(size + Util.getBitmapByteSize(firstFrame), resource.getSize());, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import org.robolectric.shadows.ShadowBitmap;, +        GlideShadowLooper.class, GlideTest.MutableShadowBitmap.class }), +    @Implements(Bitmap.class), +    public static class MutableShadowBitmap extends ShadowBitmap {, +, +        @Implementation, +        public static Bitmap createBitmap(int width, int height, Bitmap.Config config) {, +            Bitmap bitmap = ShadowBitmap.createBitmap(width, height, config);, +            Robolectric.shadowOf(bitmap).setMutable(true);, +            return bitmap;, +        }, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java, +import android.graphics.Bitmap;, +import com.bumptech.glide.util.Util;, +    public void testReturnsDrawableSizePlusFirstFrameSize() {, +        Bitmap firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +        when(drawable.getFirstFrame()).thenReturn(firstFrame);, +        assertEquals(size + Util.getBitmapByteSize(firstFrame), resource.getSize());, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +    private Bitmap firstFrame;, +    private BitmapPool bitmapPool;, +        firstFrame = Bitmap.createBitmap(frameWidth, frameHeight, Bitmap.Config.RGB_565);, +        bitmapPool = mock(BitmapPool.class);, +        drawable = new GifDrawable(gifDecoder, frameManager, firstFrame, bitmapPool);, +    public void testShouldDrawFirstFrameBeforeAnyFrameRead() {, +        verify(canvas).drawBitmap(eq(firstFrame), anyInt(), anyInt(), any(Paint.class));, +    }, +, +    @Test, +    public void testShouldNotDrawNullBitmapFrame() {, +        Canvas canvas = mock(Canvas.class);, +        drawable = new GifDrawable(gifDecoder, frameManager, firstFrame, bitmapPool);, +        drawable.onFrameRead(null, 0);, +        drawable.draw(canvas);, +, +        verify(canvas).drawBitmap(eq(firstFrame), anyInt(), anyInt(), any(Paint.class));, +    public void testDoesNotDrawNullFirstFrame() {, +        drawable = new GifDrawable(gifDecoder, frameManager, null, bitmapPool);, +        Canvas canvas = mock(Canvas.class);, +, +        verify(canvas, never()).drawBitmap(any(Bitmap.class), anyInt(), anyInt(), any(Paint.class));, +    }, +, +    @Test, +        verify(frameManager, never()).getNextFrame(any(GifFrameManager.FrameCallback.class));, +    public void testRecycleReturnsFirstFrameToPool() {, +        drawable.recycle();, +, +        verify(bitmapPool).put(eq(firstFrame));, +    }, +, +    @Test, +        Bitmap firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +        drawable = new GifDrawable(Robolectric.application, provider, bitmapPool, transformation, 100, 100, "fakeId",, +                gifHeader, new byte[0], firstFrame);, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import org.robolectric.shadows.ShadowBitmap;, +        GlideShadowLooper.class, GlideTest.MutableShadowBitmap.class }), +    @Implements(Bitmap.class), +    public static class MutableShadowBitmap extends ShadowBitmap {, +]
[+++ b/gradle.properties, +ANDROID_SUPPORT_VERSION=27.1.1]
[+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +    // Either the model isn't null, or there was no fallback drawable set., +    // The model isn't null, no fallback drawable was set or no error drawable was set., +    if (error == null) {, +      error = getPlaceholderDrawable();, +    }, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +    // Either the model isn't null, or there was no fallback drawable set., +    // The model isn't null, no fallback drawable was set or no error drawable was set., +    if (error == null) {, +      error = getPlaceholderDrawable();, +    }, +++ b/library/src/test/java/com/bumptech/glide/GlideTest.java, +  public void testNullModelResolvesToUsePlaceholder() {, +    Drawable placeholder = new ColorDrawable(Color.GREEN);, +, +    requestManager, +        .load(null), +        .apply(placeholderOf(placeholder)), +        .into(target);, +, +    verify(target).onLoadFailed(eq(placeholder));, +  }, +, +  @Test]
[+++ b/library/src/androidTest/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java, +import static org.mockito.Matchers.any;, +    @Test, +    public void testClearsThumbRequestOnFullRequestComplete_withNullParent() {, +        coordinator.onRequestSuccess(full);, +        verify(thumb).clear();, +    }, +, +    @Test, +    public void testNotifiesParentOnFullRequestComplete_withNonNullParent() {, +        coordinator = new ThumbnailRequestCoordinator(parent);, +        coordinator.setRequests(full, thumb);, +        coordinator.onRequestSuccess(full);, +        verify(parent).onRequestSuccess(eq(coordinator));, +    }, +, +    @Test, +    public void testDoesNotClearThumbRequestOnFullRequestComplete_withNonNullParent() {, +        coordinator = new ThumbnailRequestCoordinator(parent);, +        coordinator.setRequests(full, thumb);, +        coordinator.onRequestSuccess(full);, +        verify(thumb, never()).clear();, +    }, +, +    @Test, +    public void testDoesNotClearThumbOnThumbRequestComplete() {, +        coordinator.onRequestSuccess(thumb);, +        verify(thumb, never()).clear();, +    }, +, +    @Test, +    public void testDoesNotNotifyParentOnThumbRequestComplete() {, +        coordinator = new ThumbnailRequestCoordinator(parent);, +        coordinator.setRequests(full, thumb);, +        coordinator.onRequestSuccess(thumb);, +, +        verify(parent, never()).onRequestSuccess(any(Request.class));, +    }, +++ b/library/src/androidTest/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java, +import static org.mockito.Matchers.any;, +    @Test, +    public void testClearsThumbRequestOnFullRequestComplete_withNullParent() {, +        coordinator.onRequestSuccess(full);, +        verify(thumb).clear();, +    }, +, +    @Test, +    public void testNotifiesParentOnFullRequestComplete_withNonNullParent() {, +        coordinator = new ThumbnailRequestCoordinator(parent);, +        coordinator.setRequests(full, thumb);, +        coordinator.onRequestSuccess(full);, +        verify(parent).onRequestSuccess(eq(coordinator));, +    }, +, +    @Test, +    public void testDoesNotClearThumbRequestOnFullRequestComplete_withNonNullParent() {, +        coordinator = new ThumbnailRequestCoordinator(parent);, +        coordinator.setRequests(full, thumb);, +        coordinator.onRequestSuccess(full);, +        verify(thumb, never()).clear();, +    }, +, +    @Test, +    public void testDoesNotClearThumbOnThumbRequestComplete() {, +        coordinator.onRequestSuccess(thumb);, +        verify(thumb, never()).clear();, +    }, +, +    @Test, +    public void testDoesNotNotifyParentOnThumbRequestComplete() {, +        coordinator = new ThumbnailRequestCoordinator(parent);, +        coordinator.setRequests(full, thumb);, +        coordinator.onRequestSuccess(thumb);, +, +        verify(parent, never()).onRequestSuccess(any(Request.class));, +    }, +++ b/library/src/main/java/com/bumptech/glide/request/GenericRequest.java, +    private void notifyLoadSuccess() {, +      if (requestCoordinator != null) {, +        requestCoordinator.onRequestSuccess(this);, +      }, +    }, +, +        notifyLoadSuccess();, +++ b/library/src/androidTest/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java, +import static org.mockito.Matchers.any;, +    @Test, +    public void testClearsThumbRequestOnFullRequestComplete_withNullParent() {, +        coordinator.onRequestSuccess(full);, +        verify(thumb).clear();, +    }, +, +    @Test, +    public void testNotifiesParentOnFullRequestComplete_withNonNullParent() {, +        coordinator = new ThumbnailRequestCoordinator(parent);, +        coordinator.setRequests(full, thumb);, +        coordinator.onRequestSuccess(full);, +        verify(parent).onRequestSuccess(eq(coordinator));, +    }, +]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java, +import android.support.v4.content.ContextCompat;, +import com.bumptech.glide.util.Preconditions;, +    Drawable drawable =, +        Preconditions.checkNotNull(ContextCompat.getDrawable(context, ResourceIds.raw.canonical));]
[+++ b/library/build.gradle, +apply plugin: 'pmd', +, +, +    findbugsTestDebug {, +        enabled = false, +, +    check.dependsOn('findbugs'), +, +    task pmd(type: Pmd) {, +, +        description 'Run pmd', +        group 'verification', +, +        // If ruleSets is not empty, it seems to contain some, +        // defaults which override rules in the ruleset file..., +        ruleSets = [], +        ruleSetFiles = files('pmd-ruleset.xml'), +        source = fileTree('src/main/java'), +, +        reports {, +            xml.enabled = false, +            html.enabled = true, +        }, +    }, +, +    pmdTestDebug {, +        enabled = false, +    }, +, +    check.dependsOn('pmd'), +++ b/library/build.gradle, +apply plugin: 'pmd', +, +, +    findbugsTestDebug {, +        enabled = false, +, +    check.dependsOn('findbugs'), +, +    task pmd(type: Pmd) {, +, +        description 'Run pmd', +        group 'verification', +, +        // If ruleSets is not empty, it seems to contain some, +        // defaults which override rules in the ruleset file..., +        ruleSets = [], +        ruleSetFiles = files('pmd-ruleset.xml'), +        source = fileTree('src/main/java'), +, +        reports {, +            xml.enabled = false, +            html.enabled = true, +        }, +    }, +, +    pmdTestDebug {, +        enabled = false, +    }, +, +    check.dependsOn('pmd'), +++ b/library/pmd-ruleset.xml, +<?xml version="1.0" encoding="UTF-8" standalone="no" ?>, +<ruleset name="PMD.rul" xmlns="http://pmd.sourceforge.net/ruleset/2.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd">, +, +  <description>This ruleset was created from PMD.rul</description>, +, +  <rule ref="rulesets/java/basic.xml" >, +    <exclude name="AvoidBranchingStatementAsLastInLoop" />, +  </rule>, +  <rule ref="rulesets/java/braces.xml" />, +  <rule ref="rulesets/java/strings.xml" />, +, +  <rule ref="rulesets/java/design.xml" >, +    <exclude name="ConfusingTernary" />, +    <exclude name="EmptyMethodInAbstractClassShouldBeAbstract" />, +    <exclude name="AvoidSynchronizedAtMethodLevel" />, +, +    <!-- This check breaks on double checked locking which is safe in Java 6/7 -->, +    <exclude name="NonThreadSafeSingleton" />, +, +    <!-- TODO: Fix these -->, +    <exclude name="AvoidReassigningParameters" />, +    <exclude name="GodClass" />, +  </rule>, +, +  <rule ref="rulesets/java/empty.xml/EmptyCatchBlock" message="Commented blocks are ok">, +    <properties>, +      <property name="allowCommentedBlocks" value="true" />, +    </properties>, +  </rule>, +</ruleset>]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java, +      trimToSize(getMaxSize() / 2);]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/README.md, +    Glide.with(this).load("http://goo.gl/h8qOq7").into(imageView);, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/README.md, +    Glide.with(this).load("http://goo.gl/h8qOq7").into(imageView);, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }, +    }, +}, +, +subprojects {, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = 1.7, +        targetCompatibility = 1.7, +    }, +}, +, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />]
[+++ b/library/src/com/bumptech/glide/Glide.java, + * starting point and example., + *, + * Note - This class is not thread safe., +    /**, +     * Get the singleton., +     *, +     * @return the singleton, +     */, +     * @param requestQueue The {@link RequestQueue} to set, +     * Note - If an {@link ImageManager} has not yet been set via, +     * {@link #setImageManager(com.bumptech.glide.resize.ImageManager)}, one will be created during this call unless, +     * you specify a {@link ImageLoader} that does not use {@link #getRequestQueue(android.content.Context)} via, +     * {@link Request#resizeWith(com.bumptech.glide.loader.image.ImageLoader)}, +     *, +     * Note - If the model is a {@link URL} and an {@link RequestQueue} has not yet been set via, +     * {@link #setRequestQueue(com.android.volley.RequestQueue)}}, one will be created during this call unless you, +     * specify a {@link ModelLoader} via {@link Request#with(com.bumptech.glide.loader.model.ModelLoader)}., +     *, +     * @see #setImageManager(com.bumptech.glide.resize.ImageManager), +     * @see #setRequestQueue(com.android.volley.RequestQueue), +     * @see #isImageManagerSet(), +     * @see #isRequestQueueSet(), +     *, +     *, +         * Set the {@link ModelLoader} for the model., +         *, +         * Note - This method is required only if you are using a model other than a {@link File} or an {@link URL} or, +         * if you wish to specify a different {@link ModelLoader} for either of those models. For {@link URL} models,, +         * the {@link ModelLoader} defaults to {@link UrlLoader} and for {@link File} models, the {@link ModelLoader}, +         * defaults to {@link FileLoader}., +         * the given model. This must be called on the main thread., +++ b/library/src/com/bumptech/glide/Glide.java, + * starting point and example., + *, + * Note - This class is not thread safe., +    /**, +     * Get the singleton., +     *, +     * @return the singleton, +     */, +     * @param requestQueue The {@link RequestQueue} to set, +     * Note - If an {@link ImageManager} has not yet been set via, +     * {@link #setImageManager(com.bumptech.glide.resize.ImageManager)}, one will be created during this call unless, +     * you specify a {@link ImageLoader} that does not use {@link #getRequestQueue(android.content.Context)} via, +     * {@link Request#resizeWith(com.bumptech.glide.loader.image.ImageLoader)}, +     *, +     * Note - If the model is a {@link URL} and an {@link RequestQueue} has not yet been set via, +     * {@link #setRequestQueue(com.android.volley.RequestQueue)}}, one will be created during this call unless you, +     * specify a {@link ModelLoader} via {@link Request#with(com.bumptech.glide.loader.model.ModelLoader)}., +     *, +     * @see #setImageManager(com.bumptech.glide.resize.ImageManager), +     * @see #setRequestQueue(com.android.volley.RequestQueue), +     * @see #isImageManagerSet(), +     * @see #isRequestQueueSet(), +     *, +     *, +         * Set the {@link ModelLoader} for the model., +         *, +         * Note - This method is required only if you are using a model other than a {@link File} or an {@link URL} or, +         * if you wish to specify a different {@link ModelLoader} for either of those models. For {@link URL} models,, +         * the {@link ModelLoader} defaults to {@link UrlLoader} and for {@link File} models, the {@link ModelLoader}, +         * defaults to {@link FileLoader}., +         * the given model. This must be called on the main thread., +++ b/samples/flickr/res/layout/flickr_search_activity.xml, +          android:id="@+id/search_loading", +++ b/library/src/com/bumptech/glide/Glide.java, + * starting point and example., + *, + * Note - This class is not thread safe., +    /**, +     * Get the singleton., +     *, +     * @return the singleton, +     */, +     * @param requestQueue The {@link RequestQueue} to set, +     * Note - If an {@link ImageManager} has not yet been set via, +     * {@link #setImageManager(com.bumptech.glide.resize.ImageManager)}, one will be created during this call unless, +     * you specify a {@link ImageLoader} that does not use {@link #getRequestQueue(android.content.Context)} via, +     * {@link Request#resizeWith(com.bumptech.glide.loader.image.ImageLoader)}, +     *, +     * Note - If the model is a {@link URL} and an {@link RequestQueue} has not yet been set via, +     * {@link #setRequestQueue(com.android.volley.RequestQueue)}}, one will be created during this call unless you, +     * specify a {@link ModelLoader} via {@link Request#with(com.bumptech.glide.loader.model.ModelLoader)}., +     *, +     * @see #setImageManager(com.bumptech.glide.resize.ImageManager), +     * @see #setRequestQueue(com.android.volley.RequestQueue), +     * @see #isImageManagerSet(), +     * @see #isRequestQueueSet(), +     *, +     *, +         * Set the {@link ModelLoader} for the model., +         *, +         * Note - This method is required only if you are using a model other than a {@link File} or an {@link URL} or, +         * if you wish to specify a different {@link ModelLoader} for either of those models. For {@link URL} models,, +         * the {@link ModelLoader} defaults to {@link UrlLoader} and for {@link File} models, the {@link ModelLoader}, +         * defaults to {@link FileLoader}., +         * the given model. This must be called on the main thread., +++ b/samples/flickr/res/layout/flickr_search_activity.xml, +          android:id="@+id/search_loading"]
[+++ b/.idea/codeStyleSettings.xml, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/CONTRIBUTING.md, +# Contributing, +Contributions of all types are welcome. We use GitHub as our bug and feature tracker both for code and for other, +aspects of the library (documentation, the wiki etc.), +, +## Asking Questions, +The best way to ask general questions is to send an email to our [mailing list][2], or join [#glide-library on, +freenode.org.][3], +, +## Filing issues, +To file an issue, please use our [issue template link][1] and fill out the template as much as possible. The more, +information you can provide, the more likely we are to be able help., +, +When in doubt, file an issue. We'd rather close a few duplicate issues than let a problem go unnoticed. Similarly if, +you support a particular feature request, feel free to let us know by commenting on the issue., +, +## Contributing code, +Pull requests are welcome for all parts of the codebase, especially the integration libraries. You can find, +instructions on building the project in our README. Our code style is defined in Intellij project files in the repo, +and also by our Checkstyle config. If you'd like to submit code, but can't get the style checks to pass, feel, +free to put up your pull request anyway and we can help you fix the style issues. If you'd like to, +contribute code, you will need to sign [Google's individual contributor license agreement][4]., +, +[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20(if%20any)**:%0A**Device/Android%20Version**:%0A**Issue%20details/Repro%20steps**:%0A%0A**Glide%20load%20line**:%0A```%0AGlide.with(context)...%3B%0A```%0A%0A**Stack%20trace**:%0A```%0Apaste%20stack%20trace%20here%0A```, +[2]: https://groups.google.com/forum/#!forum/glidelibrary, +[3]: http://webchat.freenode.net/?channels=glide-library, +[4]: https://developers.google.com/open-source/cla/individual., +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/CONTRIBUTING.md, +# Contributing, +Contributions of all types are welcome. We use GitHub as our bug and feature tracker both for code and for other, +aspects of the library (documentation, the wiki etc.), +, +## Asking Questions, +The best way to ask general questions is to send an email to our [mailing list][2], or join [#glide-library on, +freenode.org.][3], +, +## Filing issues, +To file an issue, please use our [issue template link][1] and fill out the template as much as possible. The more, +information you can provide, the more likely we are to be able help., +, +When in doubt, file an issue. We'd rather close a few duplicate issues than let a problem go unnoticed. Similarly if, +you support a particular feature request, feel free to let us know by commenting on the issue., +, +## Contributing code, +Pull requests are welcome for all parts of the codebase, especially the integration libraries. You can find, +instructions on building the project in our README. Our code style is defined in Intellij project files in the repo, +and also by our Checkstyle config. If you'd like to submit code, but can't get the style checks to pass, feel, +free to put up your pull request anyway and we can help you fix the style issues. If you'd like to, +contribute code, you will need to sign [Google's individual contributor license agreement][4]., +, +[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20(if%20any)**:%0A**Device/Android%20Version**:%0A**Issue%20details/Repro%20steps**:%0A%0A**Glide%20load%20line**:%0A```%0AGlide.with(context)...%3B%0A```%0A%0A**Stack%20trace**:%0A```%0Apaste%20stack%20trace%20here%0A```, +[2]: https://groups.google.com/forum/#!forum/glidelibrary, +[3]: http://webchat.freenode.net/?channels=glide-library, +[4]: https://developers.google.com/open-source/cla/individual., +++ b/README.md, +Before submitting pull requests, contributors must sign Google's [individual contributor license agreement][7]., +[5]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20(if%20any)**:%0A**Device/Android%20Version**:%0A**Issue%20details/Repro%20steps**:%0A%0A**Glide%20load%20line**:%0A```%0AGlide.with(context)...%3B%0A```%0A%0A**Stack%20trace**:%0A```%0Apaste%20stack%20trace%20here%0A```, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/CONTRIBUTING.md, +# Contributing, +Contributions of all types are welcome. We use GitHub as our bug and feature tracker both for code and for other, +aspects of the library (documentation, the wiki etc.), +, +## Asking Questions, +The best way to ask general questions is to send an email to our [mailing list][2], or join [#glide-library on, +freenode.org.][3], +, +## Filing issues, +To file an issue, please use our [issue template link][1] and fill out the template as much as possible. The more, +information you can provide, the more likely we are to be able help., +, +When in doubt, file an issue. We'd rather close a few duplicate issues than let a problem go unnoticed. Similarly if, +you support a particular feature request, feel free to let us know by commenting on the issue., +, +## Contributing code, +Pull requests are welcome for all parts of the codebase, especially the integration libraries. You can find, +instructions on building the project in our README. Our code style is defined in Intellij project files in the repo, +and also by our Checkstyle config. If you'd like to submit code, but can't get the style checks to pass, feel, +free to put up your pull request anyway and we can help you fix the style issues. If you'd like to, +contribute code, you will need to sign [Google's individual contributor license agreement][4]., +, +[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20(if%20any)**:%0A**Device/Android%20Version**:%0A**Issue%20details/Repro%20steps**:%0A%0A**Glide%20load%20line**:%0A```%0AGlide.with(context)...%3B%0A```%0A%0A**Stack%20trace**:%0A```%0Apaste%20stack%20trace%20here%0A```, +[2]: https://groups.google.com/forum/#!forum/glidelibrary, +[3]: http://webchat.freenode.net/?channels=glide-library, +[4]: https://developers.google.com/open-source/cla/individual., +++ b/README.md, +Before submitting pull requests, contributors must sign Google's [individual contributor license agreement][7]., +[5]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20(if%20any)**:%0A**Device/Android%20Version**:%0A**Issue%20details/Repro%20steps**:%0A%0A**Glide%20load%20line**:%0A```%0AGlide.with(context)...%3B%0A```%0A%0A**Stack%20trace**:%0A```%0Apaste%20stack%20trace%20here%0A```]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +  @Test, +  public void clearDiskCache_doesNotPreventFutureLoads(), +      throws ExecutionException, InterruptedException, TimeoutException {, +    FutureTarget<Drawable> future = GlideApp.with(context), +        .load(ResourceIds.raw.canonical), +        .diskCacheStrategy(DiskCacheStrategy.DATA), +        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);, +    future.get(TIMEOUT_MS, TIMEOUT_UNIT);, +    GlideApp.with(context).clear(future);, +, +    clearMemoryCacheOnMainThread();, +    GlideApp.get(context).clearDiskCache();, +, +    future = GlideApp.with(context), +        .load(ResourceIds.raw.canonical), +        .diskCacheStrategy(DiskCacheStrategy.DATA), +        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS);, +    future.get(TIMEOUT_MS, TIMEOUT_UNIT);, +, +    GlideApp.with(context).clear(future);, +    clearMemoryCacheOnMainThread();, +, +    GlideApp.with(context), +        .load(ResourceIds.raw.canonical), +        .listener(requestListener), +        .diskCacheStrategy(DiskCacheStrategy.DATA), +        .submit(IMAGE_SIZE_PIXELS, IMAGE_SIZE_PIXELS), +        .get(TIMEOUT_MS, TIMEOUT_UNIT);, +, +    verify(requestListener).onResourceReady(, +        any(Drawable.class), any(), anyTarget(), eq(DataSource.DATA_DISK_CACHE), anyBoolean());, +  }, +]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java]
[+++ b/build.gradle, +, +    gradle.projectsEvaluated {, +        tasks.withType(JavaCompile) {, +            if (!name.contains('Test')) {, +                options.compilerArgs << '-Xlint:unchecked' << '-Xlint:deprecation', +            }, +        }, +    }, +++ b/build.gradle, +, +    gradle.projectsEvaluated {, +        tasks.withType(JavaCompile) {, +            if (!name.contains('Test')) {, +                options.compilerArgs << '-Xlint:unchecked' << '-Xlint:deprecation', +            }, +        }, +    }, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +    private GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> thumbnailRequestBuilder;, +++ b/build.gradle, +, +    gradle.projectsEvaluated {, +        tasks.withType(JavaCompile) {, +            if (!name.contains('Test')) {, +                options.compilerArgs << '-Xlint:unchecked' << '-Xlint:deprecation', +            }, +        }, +    }, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +    private GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> thumbnailRequestBuilder;, +++ b/library/src/main/java/com/bumptech/glide/GenericTranscodeRequest.java, +    @SuppressWarnings("unchecked"), +    private static <Z, R> ResourceTranscoder<Z, R> getUnitTranscoder() {, +        return (ResourceTranscoder<Z, R>) UnitTranscoder.get();, +    }, +, +            transcoder = getUnitTranscoder();, +++ b/build.gradle, +, +    gradle.projectsEvaluated {, +        tasks.withType(JavaCompile) {, +            if (!name.contains('Test')) {, +                options.compilerArgs << '-Xlint:unchecked' << '-Xlint:deprecation', +            }, +        }, +    }, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +    private GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> thumbnailRequestBuilder;, +++ b/library/src/main/java/com/bumptech/glide/GenericTranscodeRequest.java, +    @SuppressWarnings("unchecked"), +    private static <Z, R> ResourceTranscoder<Z, R> getUnitTranscoder() {, +        return (ResourceTranscoder<Z, R>) UnitTranscoder.get();, +    }, +, +            transcoder = getUnitTranscoder();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java, +++ b/build.gradle, +, +    gradle.projectsEvaluated {, +        tasks.withType(JavaCompile) {, +            if (!name.contains('Test')) {, +                options.compilerArgs << '-Xlint:unchecked' << '-Xlint:deprecation', +            }, +        }, +    }, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +    private GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> thumbnailRequestBuilder;, +++ b/library/src/main/java/com/bumptech/glide/GenericTranscodeRequest.java, +    @SuppressWarnings("unchecked"), +    private static <Z, R> ResourceTranscoder<Z, R> getUnitTranscoder() {, +        return (ResourceTranscoder<Z, R>) UnitTranscoder.get();, +    }, +, +            transcoder = getUnitTranscoder();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java, +++ b/library/src/main/java/com/bumptech/glide/request/GenericRequest.java]
[+++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java, +import android.support.annotation.Nullable;, +   * request was removed or invalid or {@code false} if the request was not found., +  public boolean clearRemoveAndRecycle(@Nullable Request request) {, +      // Nothing to do for null requests., +      return true;, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java, +import android.support.annotation.Nullable;, +   * request was removed or invalid or {@code false} if the request was not found., +  public boolean clearRemoveAndRecycle(@Nullable Request request) {, +      // Nothing to do for null requests., +      return true;, +++ b/library/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java, +  public void testClearRemoveAndRecycle_withNullRequest_doesNothingAndReturnsTrue() {, +    assertThat(tracker.clearRemoveAndRecycle(null)).isTrue();]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, +import com.bumptech.glide.annotation.GlideType;, + *     {@link GlideType}:, + *       {@link GlideType}., +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, +import com.bumptech.glide.annotation.GlideType;, + *     {@link GlideType}:, + *       {@link GlideType}., +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +import com.bumptech.glide.annotation.GlideOption;, +import com.bumptech.glide.annotation.GlideType;, +        if (executableElement.getAnnotation(GlideOption.class) != null) {, +        } else if (executableElement.getAnnotation(GlideType.class) != null) {, +    validateStaticVoid(executableElement, GlideOption.class);, +      throw new IllegalArgumentException("@GlideOption methods must take a ", +      throw new IllegalArgumentException("@GlideOption methods must take a", +    validateStaticVoid(executableElement, GlideType.class);, +      throw new IllegalArgumentException("@GlideType methods must take a", +      throw new IllegalArgumentException("@GlideType methods must take a", +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, +import com.bumptech.glide.annotation.GlideType;, + *     {@link GlideType}:, + *       {@link GlideType}., +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +import com.bumptech.glide.annotation.GlideOption;, +import com.bumptech.glide.annotation.GlideType;, +        if (executableElement.getAnnotation(GlideOption.class) != null) {, +        } else if (executableElement.getAnnotation(GlideType.class) != null) {, +    validateStaticVoid(executableElement, GlideOption.class);, +      throw new IllegalArgumentException("@GlideOption methods must take a ", +      throw new IllegalArgumentException("@GlideOption methods must take a", +    validateStaticVoid(executableElement, GlideType.class);, +      throw new IllegalArgumentException("@GlideType methods must take a", +      throw new IllegalArgumentException("@GlideType methods must take a", +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +import com.bumptech.glide.annotation.GlideOption;, + * non-override {@link GlideOption} annotated methods in {@link GlideExtension} annotated, +        .addJavadoc("{@link $T} in annotated methods in\n", GlideOption.class), +   * {@link GlideOption} in, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, +import com.bumptech.glide.annotation.GlideType;, + *     {@link GlideType}:, + *       {@link GlideType}., +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +import com.bumptech.glide.annotation.GlideOption;, +import com.bumptech.glide.annotation.GlideType;, +        if (executableElement.getAnnotation(GlideOption.class) != null) {, +        } else if (executableElement.getAnnotation(GlideType.class) != null) {, +    validateStaticVoid(executableElement, GlideOption.class);, +      throw new IllegalArgumentException("@GlideOption methods must take a ", +      throw new IllegalArgumentException("@GlideOption methods must take a", +    validateStaticVoid(executableElement, GlideType.class);, +      throw new IllegalArgumentException("@GlideType methods must take a", +      throw new IllegalArgumentException("@GlideType methods must take a", +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +import com.bumptech.glide.annotation.GlideOption;, + * non-override {@link GlideOption} annotated methods in {@link GlideExtension} annotated, +        .addJavadoc("{@link $T} in annotated methods in\n", GlideOption.class), +   * {@link GlideOption} in, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java, +import com.bumptech.glide.annotation.GlideType;, + * methods from {@link GlideExtension}s and {@link GlideType}., +             GlideExtension.class, GlideType.class), +        processorUtil.findAnnotatedElementsInClasses(glideExtensions, GlideType.class);, +        GlideType.class).iterator().next();, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, +import com.bumptech.glide.annotation.GlideType;, + *     {@link GlideType}:, + *       {@link GlideType}., +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +import com.bumptech.glide.annotation.GlideOption;, +import com.bumptech.glide.annotation.GlideType;, +        if (executableElement.getAnnotation(GlideOption.class) != null) {, +        } else if (executableElement.getAnnotation(GlideType.class) != null) {, +    validateStaticVoid(executableElement, GlideOption.class);, +      throw new IllegalArgumentException("@GlideOption methods must take a ", +      throw new IllegalArgumentException("@GlideOption methods must take a", +    validateStaticVoid(executableElement, GlideType.class);, +      throw new IllegalArgumentException("@GlideType methods must take a", +      throw new IllegalArgumentException("@GlideType methods must take a", +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +import com.bumptech.glide.annotation.GlideOption;, + * non-override {@link GlideOption} annotated methods in {@link GlideExtension} annotated, +        .addJavadoc("{@link $T} in annotated methods in\n", GlideOption.class), +   * {@link GlideOption} in, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java, +import com.bumptech.glide.annotation.GlideType;, + * methods from {@link GlideExtension}s and {@link GlideType}., +             GlideExtension.class, GlideType.class), +        processorUtil.findAnnotatedElementsInClasses(glideExtensions, GlideType.class);, +        GlideType.class).iterator().next();, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java, +import static com.bumptech.glide.annotation.GlideOption.OVERRIDE_EXTEND;, +import static com.bumptech.glide.annotation.GlideOption.OVERRIDE_NONE;, +import com.bumptech.glide.annotation.GlideOption;, + * of all methods annotated with {@link GlideOption} in classes annotated with, +            glideExtensionClassNames, GlideOption.class);, +          + " BaseRequestOptions. Add an 'override' value in the @GlideOption annotation", +    GlideOption glideOption =, +        element.getAnnotation(GlideOption.class);]
[+++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +        verify(requestTracker).runRequest(any(Request.class));, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +        verify(requestTracker).runRequest(any(Request.class));, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.manager.Lifecycle;, +    private RequestManager requestManager;, +        Lifecycle lifecycle = mock(Lifecycle.class);, +        requestManager = new RequestManager(getContext(), lifecycle);, +        requestManager.resumeRequests();, +        requestManager, +        requestManager.load(file).into(target);, +        requestManager.load(file).into(imageView);, +        requestManager.load(url).into(target);, +        requestManager.load(url).into(imageView);, +        requestManager.load(uri).asBitmap().into(target);, +        requestManager, +        requestManager.load(uri).asBitmap().toBytes().into(target);, +        requestManager.load(uri).into(target);, +        requestManager.load(uri).into(imageView);, +        requestManager, +        requestManager.load(string).into(imageView);, +        requestManager.load(integer).into(target);, +        requestManager.load(integer).into(imageView);, +        requestManager.load(bytes).into(target);, +        requestManager.load(bytes).into(imageView);, +        requestManager.load(bytes, id).into(target);, +        requestManager.load(bytes, id).into(imageView);, +        requestManager.load(unregistered).into(target);, +        requestManager, +        requestManager.load(0.5f).into(target);, +        requestManager, +        requestManager, +        requestManager, +        requestManager, +        requestManager.load((Double) null).into(target);, +        requestManager.load((Float) null).into(target);, +        requestManager.load((Double) null).into(target);, +        requestManager, +        requestManager, +        requestManager, +        requestManager.load(data).into(target);, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +        verify(requestTracker).runRequest(any(Request.class));, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.manager.Lifecycle;, +    private RequestManager requestManager;, +        Lifecycle lifecycle = mock(Lifecycle.class);, +        requestManager = new RequestManager(getContext(), lifecycle);, +        requestManager.resumeRequests();, +        requestManager, +        requestManager.load(file).into(target);, +        requestManager.load(file).into(imageView);, +        requestManager.load(url).into(target);, +        requestManager.load(url).into(imageView);, +        requestManager.load(uri).asBitmap().into(target);, +        requestManager, +        requestManager.load(uri).asBitmap().toBytes().into(target);, +        requestManager.load(uri).into(target);, +        requestManager.load(uri).into(imageView);, +        requestManager, +        requestManager.load(string).into(imageView);, +        requestManager.load(integer).into(target);, +        requestManager.load(integer).into(imageView);, +        requestManager.load(bytes).into(target);, +        requestManager.load(bytes).into(imageView);, +        requestManager.load(bytes, id).into(target);, +        requestManager.load(bytes, id).into(imageView);, +        requestManager.load(unregistered).into(target);, +        requestManager, +        requestManager.load(0.5f).into(target);, +        requestManager, +        requestManager, +        requestManager, +        requestManager, +        requestManager.load((Double) null).into(target);, +        requestManager.load((Float) null).into(target);, +        requestManager.load((Double) null).into(target);, +        requestManager, +        requestManager, +        requestManager, +        requestManager.load(data).into(target);, +++ b/library/src/androidTest/java/com/bumptech/glide/manager/RequestTrackerTest.java, +        when(request.isComplete()).thenReturn(true);, +    public void testStartsRequestOnRun() {, +        Request request = mock(Request.class);, +        tracker.runRequest(request);, +, +        verify(request).begin();, +    }, +, +    @Test, +    public void testDoesNotStartRequestOnRunIfPaused() {, +        Request request = mock(Request.class);, +        tracker.pauseRequests();, +        tracker.runRequest(request);, +, +        verify(request, never()).begin();, +    }, +]
[+++ b/library/project.properties, +target=android-18]
[+++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" />, +++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" />, +++ b/library/src/com/bumptech/glide/Glide.java, +import android.view.ViewGroup;, +import com.bumptech.glide.loader.model.FileLoader;, +import com.bumptech.glide.loader.model.GenericLoaderFactory;, +import com.bumptech.glide.loader.model.ModelLoader;, +import com.bumptech.glide.loader.model.ModelLoaderFactory;, +import com.bumptech.glide.loader.model.ResourceLoader;, +import com.bumptech.glide.loader.model.StringLoader;, +import com.bumptech.glide.loader.model.UriLoader;, +import com.bumptech.glide.loader.stream.StreamLoader;, +import com.bumptech.glide.loader.transformation.CenterCrop;, +import com.bumptech.glide.loader.transformation.FitCenter;, +import com.bumptech.glide.loader.transformation.MultiTransformationLoader;, +import com.bumptech.glide.loader.transformation.None;, +import com.bumptech.glide.loader.transformation.TransformationLoader;, +import com.bumptech.glide.presenter.target.Target;, +, +import java.util.Map;, +import java.util.WeakHashMap;, + * A singleton to present a simple static interface for Glide {@link Glide.Request} and to create and manage an, +    private final Map<Target, Metadata> metadataTracker = new WeakHashMap<Target, Metadata>();, +         *     public void onException(Exception e, T model, Target target) {, +        loaderFactory.register(File.class, new FileLoader.Factory());, +        loaderFactory.register(Integer.class, new ResourceLoader.Factory());, +        loaderFactory.register(String.class, new StringLoader.Factory());, +        loaderFactory.register(Uri.class, new UriLoader.Factory());, +            loaderFactory.register(URL.class, new VolleyUrlLoader.Factory());, +            loaderFactory.register(URL.class, new ModelLoaderFactory<URL>() {, +                ModelLoader<URL> errorUrlLoader = new ModelLoader<URL>() {, +                    @Override, +                    public StreamLoader getStreamLoader(URL model, int width, int height) {, +                        throw new IllegalArgumentException("No ModelLoaderFactory for urls registered with Glide");, +                    }, +, +                    @Override, +                    public String getId(URL model) {, +                        throw new IllegalArgumentException("No ModelLoaderFactory for urls registered with Glide");, +                    }, +                };, +, +                @Override, +                public ModelLoader<URL> build(Context context, GenericLoaderFactory factories) {, +                    return errorUrlLoader;, +                }, +, +                @Override @SuppressWarnings("unchecked"), +                public Class<? extends ModelLoader<URL>> loaderClass() {, +                    return (Class<ModelLoader<URL>>) errorUrlLoader.getClass();, +                }, +, +                @Override, +                public void teardown() {, +                }, +            });, +     * {@link ImageManager} with custom options for use with {@link com.bumptech.glide.Glide.Request} and/or as an, +     * Set the {@link ImageManager} to use with {@link Glide.Request}., +     * Set the {@link ImageManager} to use with {@link Glide.Request} Replaces the current, +     * models. Typically the {@link Glide#using(com.bumptech.glide.loader.model.ModelLoader)} syntax is preferred, +     * because it directly links the model with the ModelLoader being used to load it., +     *     used for any other model class, {@link com.bumptech.glide.loader.model.ModelLoaderFactory#teardown()}, +     * @param clazz The class, +     * @param factory The factory to use, +     * @param <T> The type of the model, +    public <T> void register(Class<T> clazz, ModelLoaderFactory<T> factory) {, +        ModelLoaderFactory<T> removed = loaderFactory.register(clazz, factory);, +     * @param clazz The class to get a {@link ModelLoader} for, +    public static <T> ModelLoader<T> buildModelLoader(Class<T> clazz, Context context) {, +        return GLIDE.loaderFactory.buildModelLoader(clazz, context);, +    }, +, +    @SuppressWarnings("unchecked"), +    private <T> ModelLoaderFactory<T> getFactory(T model) {, +        return loaderFactory.getFactory((Class<T>) model.getClass());, +    }, +, +    private ImageViewTarget getImageViewTarget(ImageView imageView) {, +        Object tag = imageView.getTag();, +        ImageViewTarget result = null;, +        if (tag instanceof ImageViewTarget) {, +            result = (ImageViewTarget) tag;, +        } else if (tag != null) {, +            throw new IllegalArgumentException("You cannot set a tag on an image view Glide is loading an image into");, +        }, +, +        return result;, +    }, +, +    private ImageViewTarget getImageViewTargetOrSet(ImageView imageView) {, +        ImageViewTarget result = getImageViewTarget(imageView);, +        if (result == null) {, +            result = new ImageViewTarget(imageView);, +            imageView.setTag(result);, +        }, +        return result;, +     * Set the {@link ModelLoaderFactory} and therefore the model type to use for a new load., +     *     Note - You can use this method to set a {@link ModelLoaderFactory} for models that don't have a default]
[+++ b/gradle.properties, +VERSION_NAME=4.0.0]
[+++ b/.gitignore, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +samples/flickr/target, +++ b/.gitignore, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +samples/flickr/target, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/.gitignore, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +samples/flickr/target, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/LICENSE, +Copyright 2014 Google, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY GOOGLE, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE, INC. OR, +or implied, of Google, Inc., +++ b/.gitignore, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +samples/flickr/target, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/LICENSE, +Copyright 2014 Google, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY GOOGLE, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE, INC. OR, +or implied, of Google, Inc., +++ b/Makefile, +	cp -f third_party/disklrucache/disklrucache*.jar library/libs, +	cd third_party/gif_decoder && ant clean && ant jar, +	cp -f third_party/gif_decoder/bin/gifdecoder*.jar library/libs, +	cd third_party/volley/volley && ant clean && ant jar, +	cp -f third_party/volley/volley/bin/volley.jar library/libs, +++ b/.gitignore, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +samples/flickr/target, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/LICENSE, +Copyright 2014 Google, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY GOOGLE, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE, INC. OR, +or implied, of Google, Inc., +++ b/Makefile, +	cp -f third_party/disklrucache/disklrucache*.jar library/libs, +	cd third_party/gif_decoder && ant clean && ant jar, +	cp -f third_party/gif_decoder/bin/gifdecoder*.jar library/libs, +	cd third_party/volley/volley && ant clean && ant jar, +	cp -f third_party/volley/volley/bin/volley.jar library/libs, +++ b/library/.gitignore, +libs/gifdecoder*.jar, +libs/disklrucache*.jar, +++ b/.gitignore, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +samples/flickr/target, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/LICENSE, +Copyright 2014 Google, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY GOOGLE, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE, INC. OR, +or implied, of Google, Inc., +++ b/Makefile, +	cp -f third_party/disklrucache/disklrucache*.jar library/libs, +	cd third_party/gif_decoder && ant clean && ant jar, +	cp -f third_party/gif_decoder/bin/gifdecoder*.jar library/libs, +	cd third_party/volley/volley && ant clean && ant jar, +	cp -f third_party/volley/volley/bin/volley.jar library/libs, +++ b/library/.gitignore, +libs/gifdecoder*.jar, +libs/disklrucache*.jar, +++ b/library/AndroidManifest.xml, +          android:versionCode="5"]
[+++ b/samples/flickr/AndroidManifest.xml, +        <activity android:name=".FlickrSearchActivity", +++ b/samples/flickr/AndroidManifest.xml, +        <activity android:name=".FlickrSearchActivity", +++ /dev/null, +++ b/samples/flickr/AndroidManifest.xml, +        <activity android:name=".FlickrSearchActivity", +++ /dev/null, +++ b/samples/flickr/src/com/bumptech/flickr/FlickrPathLoader.java, +package com.bumptech.flickr;, +, +import com.bumptech.flickr.api.Api;, +import com.bumptech.flickr.api.Photo;, +import com.bumptech.photos.loader.path.BasePathLoader;, +, +import java.io.File;, +, +/**, + * Created with IntelliJ IDEA., + * User: sam, + * Date: 1/6/13, + * Time: 11:55 AM, + * To change this template use File | Settings | File Templates., + */, +public class FlickrPathLoader extends BasePathLoader<Photo> {, +    private final Api flickrApi;, +    private final File cacheDir;, +, +    public FlickrPathLoader(Api flickApi, File cacheDir) {, +        this.flickrApi = flickApi;, +        this.cacheDir = cacheDir;, +    }, +, +    @Override, +    protected void doFetchPath(Photo model, int width, int height, final PathReadyCallback cb) {, +        flickrApi.downloadPhoto(model, width, height, cacheDir, new Api.PhotoCallback() {, +            @Override, +            public void onDownloadComplete(String path) {, +                cb.onPathReady(path);, +            }, +        });, +    }, +}, +++ b/samples/flickr/AndroidManifest.xml, +        <activity android:name=".FlickrSearchActivity", +++ /dev/null, +++ b/samples/flickr/src/com/bumptech/flickr/FlickrPathLoader.java, +package com.bumptech.flickr;, +, +import com.bumptech.flickr.api.Api;, +import com.bumptech.flickr.api.Photo;, +import com.bumptech.photos.loader.path.BasePathLoader;, +, +import java.io.File;, +, +/**, + * Created with IntelliJ IDEA., + * User: sam, + * Date: 1/6/13, + * Time: 11:55 AM, + * To change this template use File | Settings | File Templates., + */, +public class FlickrPathLoader extends BasePathLoader<Photo> {, +    private final Api flickrApi;, +    private final File cacheDir;, +, +    public FlickrPathLoader(Api flickApi, File cacheDir) {, +        this.flickrApi = flickApi;, +        this.cacheDir = cacheDir;, +    }, +, +    @Override, +    protected void doFetchPath(Photo model, int width, int height, final PathReadyCallback cb) {, +        flickrApi.downloadPhoto(model, width, height, cacheDir, new Api.PhotoCallback() {, +            @Override, +            public void onDownloadComplete(String path) {, +                cb.onPathReady(path);, +            }, +        });, +    }, +}, +++ b/samples/flickr/src/com/bumptech/flickr/FlickrPhotoGrid.java, +package com.bumptech.flickr;, +, +import android.os.Bundle;, +import android.view.LayoutInflater;, +import android.view.View;, +import android.view.ViewGroup;, +import android.view.animation.Animation;, +import android.view.animation.AnimationUtils;, +import android.widget.BaseAdapter;, +import android.widget.GridView;, +import android.widget.ImageView;, +import com.actionbarsherlock.app.SherlockFragment;, +import com.bumptech.flickr.api.Api;, +import com.bumptech.flickr.api.Photo;, +import com.bumptech.photos.presenter.ImagePresenter;, +import com.bumptech.photos.presenter.ImageSetCallback;, +import com.bumptech.photos.resize.ImageManager;, +import com.bumptech.photos.resize.loader.CenterCrop;]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.transcode.GifBitmapWrapperDrawableTranscoder;, +import com.bumptech.glide.load.resource.transcode.GifDataDrawableTranscoder;, +                new GifBitmapWrapperDrawableTranscoder(new BitmapDrawableTranscoder(context.getResources(), bitmapPool),, +                        new GifDataDrawableTranscoder()));, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.transcode.GifBitmapWrapperDrawableTranscoder;, +import com.bumptech.glide.load.resource.transcode.GifDataDrawableTranscoder;, +                new GifBitmapWrapperDrawableTranscoder(new BitmapDrawableTranscoder(context.getResources(), bitmapPool),, +                        new GifDataDrawableTranscoder()));, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java, +package com.bumptech.glide.load.resource.bitmap;, +, +import android.graphics.drawable.BitmapDrawable;, +import com.bumptech.glide.Resource;, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import com.bumptech.glide.util.Util;, +, +public class BitmapDrawableResource extends Resource<BitmapDrawable> {, +    private BitmapDrawable drawable;, +    private BitmapPool bitmapPool;, +, +    public BitmapDrawableResource(BitmapDrawable drawable, BitmapPool bitmapPool) {, +        this.drawable = drawable;, +        this.bitmapPool = bitmapPool;, +    }, +, +    @Override, +    public BitmapDrawable get() {, +        return drawable;, +    }, +, +    @Override, +    public int getSize() {, +        return Util.getSize(drawable.getBitmap());, +    }, +, +    @Override, +    protected void recycleInternal() {, +        bitmapPool.put(drawable.getBitmap());, +    }, +}, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.transcode.GifBitmapWrapperDrawableTranscoder;, +import com.bumptech.glide.load.resource.transcode.GifDataDrawableTranscoder;, +                new GifBitmapWrapperDrawableTranscoder(new BitmapDrawableTranscoder(context.getResources(), bitmapPool),, +                        new GifDataDrawableTranscoder()));, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java, +package com.bumptech.glide.load.resource.bitmap;, +, +import android.graphics.drawable.BitmapDrawable;, +import com.bumptech.glide.Resource;, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import com.bumptech.glide.util.Util;, +, +public class BitmapDrawableResource extends Resource<BitmapDrawable> {, +    private BitmapDrawable drawable;, +    private BitmapPool bitmapPool;, +, +    public BitmapDrawableResource(BitmapDrawable drawable, BitmapPool bitmapPool) {, +        this.drawable = drawable;, +        this.bitmapPool = bitmapPool;, +    }, +, +    @Override, +    public BitmapDrawable get() {, +        return drawable;, +    }, +, +    @Override, +    public int getSize() {, +        return Util.getSize(drawable.getBitmap());, +    }, +, +    @Override, +    protected void recycleInternal() {, +        bitmapPool.put(drawable.getBitmap());, +    }, +}, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.transcode.GifBitmapWrapperDrawableTranscoder;, +import com.bumptech.glide.load.resource.transcode.GifDataDrawableTranscoder;, +                new GifBitmapWrapperDrawableTranscoder(new BitmapDrawableTranscoder(context.getResources(), bitmapPool),, +                        new GifDataDrawableTranscoder()));, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java, +package com.bumptech.glide.load.resource.bitmap;, +, +import android.graphics.drawable.BitmapDrawable;, +import com.bumptech.glide.Resource;, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import com.bumptech.glide.util.Util;, +, +public class BitmapDrawableResource extends Resource<BitmapDrawable> {, +    private BitmapDrawable drawable;, +    private BitmapPool bitmapPool;, +, +    public BitmapDrawableResource(BitmapDrawable drawable, BitmapPool bitmapPool) {, +        this.drawable = drawable;, +        this.bitmapPool = bitmapPool;]
[+++ b/library/robolectric/src/com/bumptech/glide/ListPreloaderTest.java, +            protected BitmapRequestBuilder getRequestBuilder(Object item) {, +                return mock(BitmapRequestBuilder.class);, +            protected BitmapRequestBuilder getRequestBuilder(Object item) {, +                return mock(BitmapRequestBuilder.class);, +            protected BitmapRequestBuilder getRequestBuilder(Object item) {, +        protected BitmapRequestBuilder getRequestBuilder(Object item) {, +            return mock(BitmapRequestBuilder.class);, +++ b/library/robolectric/src/com/bumptech/glide/ListPreloaderTest.java, +            protected BitmapRequestBuilder getRequestBuilder(Object item) {, +                return mock(BitmapRequestBuilder.class);, +            protected BitmapRequestBuilder getRequestBuilder(Object item) {, +                return mock(BitmapRequestBuilder.class);, +            protected BitmapRequestBuilder getRequestBuilder(Object item) {, +        protected BitmapRequestBuilder getRequestBuilder(Object item) {, +            return mock(BitmapRequestBuilder.class);, +++ /dev/null, +++ b/library/robolectric/src/com/bumptech/glide/ListPreloaderTest.java, +            protected BitmapRequestBuilder getRequestBuilder(Object item) {, +                return mock(BitmapRequestBuilder.class);, +            protected BitmapRequestBuilder getRequestBuilder(Object item) {, +                return mock(BitmapRequestBuilder.class);, +            protected BitmapRequestBuilder getRequestBuilder(Object item) {, +        protected BitmapRequestBuilder getRequestBuilder(Object item) {, +            return mock(BitmapRequestBuilder.class);, +++ /dev/null, +++ b/library/robolectric/src/com/bumptech/glide/request/GenericRequestTest.java, +package com.bumptech.glide.request;, +, +import android.content.Context;, +import android.content.res.Resources;, +import android.graphics.Color;, +import android.graphics.drawable.ColorDrawable;, +import android.graphics.drawable.Drawable;, +import android.view.animation.Animation;, +import com.bumptech.glide.Priority;, +import com.bumptech.glide.Resource;, +import com.bumptech.glide.load.ResourceDecoder;, +import com.bumptech.glide.load.ResourceEncoder;, +import com.bumptech.glide.load.Transformation;, +import com.bumptech.glide.load.engine.Engine;, +import com.bumptech.glide.load.model.ModelLoader;, +import com.bumptech.glide.load.resource.ResourceFetcher;, +import com.bumptech.glide.provider.LoadProvider;, +import com.bumptech.glide.request.bitmap.GenericRequest;, +import com.bumptech.glide.request.target.Target;, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.mockito.invocation.InvocationOnMock;, +import org.mockito.stubbing.Answer;, +import org.robolectric.Robolectric;, +import org.robolectric.RobolectricTestRunner;, +, +import static junit.framework.Assert.assertEquals;, +import static junit.framework.Assert.assertFalse;, +import static junit.framework.Assert.assertTrue;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.anyString;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.doAnswer;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, +@RunWith(RobolectricTestRunner.class), +public class GenericRequestTest {, +    private RequestHarness harness;, +, +    @SuppressWarnings("unchecked"), +    private static class RequestHarness {, +        Engine engine = mock(Engine.class);, +        Object model = new Object();, +        Target target = mock(Target.class);, +        Context context = Robolectric.application;, +        Resource<Object> resource = mock(Resource.class);, +        RequestCoordinator requestCoordinator = null;, +        Priority priority = Priority.NORMAL;, +        int placeholderResourceId = 0;, +        Drawable placeholderDrawable = null;, +        int errorResourceId = 0;, +        Drawable errorDrawable = null;, +        LoadProvider<Object, Object, Object> loadProvider = mock(LoadProvider.class);, +, +        public RequestHarness() {, +            ModelLoader<Object, Object> modelLoader = mock(ModelLoader.class);, +            when(loadProvider.getModelLoader()).thenReturn(modelLoader);, +        }, +, +        public GenericRequest<Object, Object, Object> getRequest() {, +            return new GenericRequest<Object, Object, Object>(loadProvider, model, context, priority, target, 1f,, +                    placeholderDrawable, placeholderResourceId, errorDrawable, errorResourceId, null, 0, null,, +                    requestCoordinator, engine, mock(Transformation.class));, +        }, +    }, +, +    @Before, +    public void setUp() {, +        harness = new RequestHarness();]
[+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/MediaStoreUtil.java, +import com.bumptech.glide.request.target.Target;, +    return width != Target.SIZE_ORIGINAL, +        && height != Target.SIZE_ORIGINAL, +        && width <= MINI_THUMB_WIDTH, +        && height <= MINI_THUMB_HEIGHT;]
[+++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java, +    RAW(false),]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +    Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +    Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +    Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +    Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +    Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +    Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +    Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +    Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +    Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java, +  /**, +   * Returns the class of the data this fetcher will attempt to obtain., +   */, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +    Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java, +  /**, +   * Returns the class of the data this fetcher will attempt to obtain., +   */, +++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +    Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java, +  /**, +   * Returns the class of the data this fetcher will attempt to obtain., +   */, +++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +    Request.Builder requestBuilder = new Request.Builder().url(url.toStringUrl());, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java, +  /**, +   * Returns the class of the data this fetcher will attempt to obtain., +   */, +++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java]
[+++ b/.gitignore, +gen/*]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +    private static final String USER_AGENT_HEADER = "User-Agent";, +    private static final String DEFAULT_USER_AGENT = System.getProperty("http.agent");, +, +        boolean isUserAgentSet = false;, +            String key = headerEntry.getKey();, +            requestBuilder.addHeader(key, headerEntry.getValue());, +            isUserAgentSet |= USER_AGENT_HEADER.equalsIgnoreCase(key);, +        }, +        if (!isUserAgentSet) {, +            requestBuilder.addHeader(USER_AGENT_HEADER, DEFAULT_USER_AGENT);]
[+++ b/Makefile, +++ b/Makefile, +++ b/library/AndroidManifest.xml, +          android:versionCode="4", +          android:versionName="3.0.0" >, +  <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="19" />, +++ b/Makefile, +++ b/library/AndroidManifest.xml, +          android:versionCode="4", +          android:versionName="3.0.0" >, +  <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="19" />, +++ b/library/custom_rules.xml, +++ b/Makefile, +++ b/library/AndroidManifest.xml, +          android:versionCode="4", +          android:versionName="3.0.0" >, +  <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="19" />, +++ b/library/custom_rules.xml, +++ b/library/src/com/bumptech/glide/Glide.java, +import android.graphics.Bitmap;, +import android.graphics.drawable.Drawable;, +import android.os.ParcelFileDescriptor;, +import android.view.View;, +import com.android.volley.RequestQueue;, +import com.bumptech.glide.loader.bitmap.ImageVideoBitmapLoadFactory;, +import com.bumptech.glide.loader.bitmap.ResourceBitmapLoadFactory;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorFileLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorModelLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorResourceLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorStringLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorUriLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamByteArrayLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamResourceLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamFileLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamModelLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamStringLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamUriLoader;, +import com.bumptech.glide.loader.bitmap.model.GenericLoaderFactory;, +import com.bumptech.glide.loader.bitmap.model.ModelLoader;, +import com.bumptech.glide.loader.bitmap.model.ModelLoaderFactory;, +import com.bumptech.glide.loader.bitmap.transformation.CenterCrop;, +import com.bumptech.glide.loader.bitmap.transformation.FitCenter;, +import com.bumptech.glide.loader.bitmap.transformation.MultiTransformationLoader;, +import com.bumptech.glide.loader.bitmap.transformation.None;, +import com.bumptech.glide.loader.bitmap.transformation.TransformationLoader;, +import com.bumptech.glide.presenter.target.ImageViewTarget;, +import com.bumptech.glide.presenter.target.ViewTarget;, +import com.bumptech.glide.resize.load.BitmapDecoder;, +import com.bumptech.glide.resize.load.VideoBitmapDecoder;, +import java.io.InputStream;, +import java.util.UUID;, + * A singleton to present a simple static interface for Glide {@link Request} and to create and manage an, +    private static Glide GLIDE;, +    private final RequestQueue requestQueue;, +         *     public void onException(Exception e, ModelType model, Target target) {, +    public static Glide get(Context context) {, +        if (GLIDE == null) {, +            GLIDE = new GlideBuilder(context).createGlide();, +        }, +, +    public static boolean isSetup() {, +        return GLIDE != null;, +    public static void setup(GlideBuilder builder) {, +        if (GLIDE != null) {, +            throw new IllegalArgumentException("Glide is already setup, check with isSetup() first");, +        GLIDE = builder.createGlide();, +    Glide(ImageManager imageManager, RequestQueue requestQueue) {, +        this.imageManager = imageManager;, +        this.requestQueue = requestQueue;, +        register(File.class, ParcelFileDescriptor.class, new FileDescriptorFileLoader.Factory());, +        register(File.class, InputStream.class, new StreamFileLoader.Factory());, +        register(Integer.class, ParcelFileDescriptor.class, new FileDescriptorResourceLoader.Factory());, +        register(Integer.class, InputStream.class, new StreamResourceLoader.Factory());, +        register(String.class, ParcelFileDescriptor.class, new FileDescriptorStringLoader.Factory());, +        register(String.class, InputStream.class, new StreamStringLoader.Factory());, +        register(Uri.class, ParcelFileDescriptor.class, new FileDescriptorUriLoader.Factory());, +        register(Uri.class, InputStream.class, new StreamUriLoader.Factory());, +        register(URL.class, InputStream.class, new VolleyUrlLoader.Factory(requestQueue));, +     * Returns the {@link ImageManager} Glide is using to load images., +    public ImageManager getImageManager() {, +     * Returns the {@link RequestQueue} Glide is using to fetch images over http/https., +    public RequestQueue getRequestQueue() {, +        return requestQueue;, +     * models. Typically the {@link ModelRequest#using(StreamModelLoader)} or, +     * {@link ModelRequest#using(FileDescriptorModelLoader)} syntax is preferred because it directly links the model, +     * with the ModelLoader being used to load it., +     *     used for any other model class, {@link ModelLoaderFactory#teardown()}, +     * @see ModelRequest#using(FileDescriptorModelLoader), +     * @see ModelRequest#using(StreamModelLoader), +     *, +     * @param modelClass The model class., +     * @param resourceClass The resource class the model loader will translate the model type into., +     * @param factory The factory to use., +     * @param <T> The type of the model., +     * @param <Y> the type of the resource., +    public <T, Y> void register(Class<T> modelClass, Class<Y> resourceClass, ModelLoaderFactory<T, Y> factory) {, +        ModelLoaderFactory<T, Y> removed = loaderFactory.register(modelClass, resourceClass, factory);, +    @SuppressWarnings("unchecked"), +    private <T, Y> ModelLoaderFactory<T, Y> getFactory(T model, Class<Y> resourceClass) {, +        return loaderFactory.getFactory((Class<T>) model.getClass(), resourceClass);]
[+++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/ExtensionWithType.java, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/ExtensionWithType.java, +++ b/annotation/compiler/test/src/test/resources/LegacyGlideExtensionWithTypeTest/ExtensionWithType.java]
[+++ b/src/com/bumptech/photos/PhotoManager.java, +     * Loads the image for the given id assuming its width and height are exactly those given, +     * @param path - the path to the image, +     * @param width - the width of the image on disk, +     * @param height - the height of the image on disk, +     * @param cb - the callback called when the load completes, +     * @return A token tracking this request, +     */, +    public Object getImageExact(final String path, int width, int height, final LoadedCallback cb) {, +        final Object token = cb;, +        final String key = getKey(path, width, height, ResizeType.AS_IS);, +        if (!returnFromCache(key, cb)) {, +            final Runnable task = resizer.loadAsIs(path, width, height, getResizeCb(key, token, cb, false, false));, +            postJob(task, token);, +        }, +        return token;, +    }, +, +    /**, +    public Object getImageApproximate(final String path, final int width, final int height, final LoadedCallback cb){, +++ b/src/com/bumptech/photos/PhotoManager.java, +     * Loads the image for the given id assuming its width and height are exactly those given, +     * @param path - the path to the image, +     * @param width - the width of the image on disk, +     * @param height - the height of the image on disk, +     * @param cb - the callback called when the load completes, +     * @return A token tracking this request, +     */, +    public Object getImageExact(final String path, int width, int height, final LoadedCallback cb) {, +        final Object token = cb;, +        final String key = getKey(path, width, height, ResizeType.AS_IS);, +        if (!returnFromCache(key, cb)) {, +            final Runnable task = resizer.loadAsIs(path, width, height, getResizeCb(key, token, cb, false, false));, +            postJob(task, token);, +        }, +        return token;, +    }, +, +    /**, +    public Object getImageApproximate(final String path, final int width, final int height, final LoadedCallback cb){, +++ b/src/com/bumptech/photos/resize/ResizeJobGenerator.java, +    public Runnable loadAsIs(final String path, final int width, final int height, LoadedCallback cb) {, +        return new StreamResizeRunnable(cb) {, +            @Override, +            public Bitmap getRecycledBitmap() {, +                return bitmapCache.get(width, height);, +            }, +, +            @Override, +            public Bitmap resize(Bitmap recycled) {, +                return Utils.load(path, recycled);, +            }, +        };, +    }, +, +    }, +++ b/src/com/bumptech/photos/PhotoManager.java, +     * Loads the image for the given id assuming its width and height are exactly those given, +     * @param path - the path to the image, +     * @param width - the width of the image on disk, +     * @param height - the height of the image on disk, +     * @param cb - the callback called when the load completes, +     * @return A token tracking this request, +     */, +    public Object getImageExact(final String path, int width, int height, final LoadedCallback cb) {, +        final Object token = cb;, +        final String key = getKey(path, width, height, ResizeType.AS_IS);, +        if (!returnFromCache(key, cb)) {, +            final Runnable task = resizer.loadAsIs(path, width, height, getResizeCb(key, token, cb, false, false));, +            postJob(task, token);, +        }, +        return token;, +    }, +, +    /**, +    public Object getImageApproximate(final String path, final int width, final int height, final LoadedCallback cb){, +++ b/src/com/bumptech/photos/resize/ResizeJobGenerator.java, +    public Runnable loadAsIs(final String path, final int width, final int height, LoadedCallback cb) {, +        return new StreamResizeRunnable(cb) {, +            @Override, +            public Bitmap getRecycledBitmap() {, +                return bitmapCache.get(width, height);, +            }, +, +            @Override, +            public Bitmap resize(Bitmap recycled) {, +                return Utils.load(path, recycled);, +            }, +        };, +    }, +, +    }, +++ b/src/com/bumptech/photos/view/loader/Approximate.java, +        return photoManager.getImageApproximate(path, width, height, cb);, +++ b/src/com/bumptech/photos/PhotoManager.java, +     * Loads the image for the given id assuming its width and height are exactly those given, +     * @param path - the path to the image, +     * @param width - the width of the image on disk, +     * @param height - the height of the image on disk, +     * @param cb - the callback called when the load completes]
[+++ b/.travis.yml, +before_script:, +  - ./scripts/travis_before_script.sh, +, +++ b/.travis.yml, +before_script:, +  - ./scripts/travis_before_script.sh, +, +++ b/debug.keystore, +++ b/.travis.yml, +before_script:, +  - ./scripts/travis_before_script.sh, +, +++ b/debug.keystore, +++ b/scripts/travis_before_script.sh, +#!/usr/bin/env bash, +# Copies our debug.keystore file to its expected location to avoid a bug , +# where the Android build system seems to occasionally fail to generate it., +, +set -e, +, +cp debug.keystore ~/.android/debug.keystore]
[+++ b/build.gradle, +        jcenter(), +        // TODO: remove this when robolectric 2.4 is released., +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +    }, +, +        classpath 'org.robolectric:robolectric-gradle-plugin:0.11.+', +        classpath 'com.android.tools.build:gradle:0.12.+', +    }, +}, +, +allprojects {, +    repositories {, +        jcenter(), +        // TODO: remove this when robolectric 2.4 is released., +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +    gradleVersion = '1.12', +++ b/build.gradle, +        jcenter(), +        // TODO: remove this when robolectric 2.4 is released., +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +    }, +, +        classpath 'org.robolectric:robolectric-gradle-plugin:0.11.+', +        classpath 'com.android.tools.build:gradle:0.12.+', +    }, +}, +, +allprojects {, +    repositories {, +        jcenter(), +        // TODO: remove this when robolectric 2.4 is released., +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +    gradleVersion = '1.12', +++ b/gradle/wrapper/gradle-wrapper.properties, +#Sat Jun 28 20:49:51 PDT 2014, +distributionUrl=https\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/build.gradle, +        jcenter(), +        // TODO: remove this when robolectric 2.4 is released., +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +    }, +, +        classpath 'org.robolectric:robolectric-gradle-plugin:0.11.+', +        classpath 'com.android.tools.build:gradle:0.12.+', +    }, +}, +, +allprojects {, +    repositories {, +        jcenter(), +        // TODO: remove this when robolectric 2.4 is released., +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +    gradleVersion = '1.12', +++ b/gradle/wrapper/gradle-wrapper.properties, +#Sat Jun 28 20:49:51 PDT 2014, +distributionUrl=https\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/integration/volley/build.gradle, +apply plugin: 'com.android.library', +++ b/build.gradle, +        jcenter(), +        // TODO: remove this when robolectric 2.4 is released., +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +    }, +, +        classpath 'org.robolectric:robolectric-gradle-plugin:0.11.+', +        classpath 'com.android.tools.build:gradle:0.12.+', +    }, +}, +, +allprojects {, +    repositories {, +        jcenter(), +        // TODO: remove this when robolectric 2.4 is released., +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +    gradleVersion = '1.12', +++ b/gradle/wrapper/gradle-wrapper.properties, +#Sat Jun 28 20:49:51 PDT 2014, +distributionUrl=https\://services.gradle.org/distributions/gradle-1.12-all.zip, +++ b/integration/volley/build.gradle, +apply plugin: 'com.android.library', +++ b/library/build.gradle, +apply plugin: 'com.android.library', +    androidTestCompile 'org.robolectric:robolectric:2.4-SNAPSHOT', +++ b/build.gradle, +        jcenter(), +        // TODO: remove this when robolectric 2.4 is released., +        maven {]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/CanonicalBitmap.java, +    int resourceId = ResourceIds.raw.canonical;, +    Bitmap result = BitmapFactory.decodeResource(context.getResources(), resourceId, options);, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/CanonicalBitmap.java, +    int resourceId = ResourceIds.raw.canonical;, +    Bitmap result = BitmapFactory.decodeResource(context.getResources(), resourceId, options);, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ResourceIds.java, +    int canonical = getResourceId("raw", "canonical");]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java|TransitionOptions.java|BaseDecodeOptions.java|RequestOptions.java" checks="NoClone" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java|TransitionOptions.java|BaseDecodeOptions.java|RequestOptions.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java|TransitionOptions.java|BaseDecodeOptions.java|RequestOptions.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java|TransitionOptions.java|BaseDecodeOptions.java|RequestOptions.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/integration/integration.iml, +<module external.linked.project.id=":integration" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java|TransitionOptions.java|BaseDecodeOptions.java|RequestOptions.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/integration/integration.iml, +<module external.linked.project.id=":integration" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/integration/okhttp/okhttp.iml, +<module external.linked.project.id=":integration:okhttp" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +      <excludeFolder url="file://$MODULE_DIR$/build/docs" />, +      <excludeFolder url="file://$MODULE_DIR$/build/reports" />, +    <orderEntry type="module" module-name="library" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java|TransitionOptions.java|BaseDecodeOptions.java|RequestOptions.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/integration/integration.iml, +<module external.linked.project.id=":integration" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/integration/okhttp/okhttp.iml, +<module external.linked.project.id=":integration:okhttp" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +      <excludeFolder url="file://$MODULE_DIR$/build/docs" />, +      <excludeFolder url="file://$MODULE_DIR$/build/reports" />, +    <orderEntry type="module" module-name="library" />, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +import com.bumptech.glide.Registry;, +    public void registerComponents(Context context, Registry registry) {, +        registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());, +++ b/.idea/codeStyleSettings.xml]
[+++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +   * android.graphics.Bitmap.Config#HARDWARE} on Android O+., +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +   * android.graphics.Bitmap.Config#HARDWARE} on Android O+., +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +      // ResourceType in DecodeCallback below is required for compilation to work with gradle., +      return path.load(, +          rewinder, options, width, height, new DecodeCallback<ResourceType>(dataSource));, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +   * android.graphics.Bitmap.Config#HARDWARE} on Android O+., +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +      // ResourceType in DecodeCallback below is required for compilation to work with gradle., +      return path.load(, +          rewinder, options, width, height, new DecodeCallback<ResourceType>(dataSource));, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +  @TargetApi(Build.VERSION_CODES.O), +  private static void assertNotHardwareConfig(Bitmap.Config config) {, +    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {, +      return;, +    }, +, +, +  @Nullable, +  private synchronized Bitmap getDirtyOrNull(int width, int height, Bitmap.Config config) {, +    assertNotHardwareConfig(config);, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +   * android.graphics.Bitmap.Config#HARDWARE} on Android O+., +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +      // ResourceType in DecodeCallback below is required for compilation to work with gradle., +      return path.load(, +          rewinder, options, width, height, new DecodeCallback<ResourceType>(dataSource));, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +  @TargetApi(Build.VERSION_CODES.O), +  private static void assertNotHardwareConfig(Bitmap.Config config) {, +    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {, +      return;, +    }, +, +, +  @Nullable, +  private synchronized Bitmap getDirtyOrNull(int width, int height, Bitmap.Config config) {, +    assertNotHardwareConfig(config);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +    boolean isHardwareConfigAllowed =, +      options.get(ALLOW_HARDWARE_CONFIG) != null && options.get(ALLOW_HARDWARE_CONFIG);, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +   * android.graphics.Bitmap.Config#HARDWARE} on Android O+., +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +      // ResourceType in DecodeCallback below is required for compilation to work with gradle., +      return path.load(, +          rewinder, options, width, height, new DecodeCallback<ResourceType>(dataSource));, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +  @TargetApi(Build.VERSION_CODES.O), +  private static void assertNotHardwareConfig(Bitmap.Config config) {, +    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {, +      return;, +    }, +, +, +  @Nullable, +  private synchronized Bitmap getDirtyOrNull(int width, int height, Bitmap.Config config) {, +    assertNotHardwareConfig(config);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +    boolean isHardwareConfigAllowed =, +      options.get(ALLOW_HARDWARE_CONFIG) != null && options.get(ALLOW_HARDWARE_CONFIG);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java, +import android.annotation.TargetApi;, +  @TargetApi(Build.VERSION_CODES.O)]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java, +import org.robolectric.shadows.ShadowActivityManager;, +    // Keep the bitmap pool size constant, even though normally it would change., +    harness.byteArrayPoolSizeBytes *= 2;, +  @Test, +  public void testByteArrayPoolSize_withLowRamDevice_isHalfTheSpecifiedBytes() {, +    ShadowActivityManager activityManager = Shadows.shadowOf(harness.activityManager);, +    activityManager.setMemoryClass(getLargeEnoughMemoryClass());, +, +    Util.setSdkVersionInt(10);, +, +    int byteArrayPoolSize = harness.getCalculator().getByteArrayPoolSize();, +    assertThat(byteArrayPoolSize).isEqualTo(harness.byteArrayPoolSizeBytes / 2);, +  }, +, +    float totalBytes = totalScreenBytes + harness.byteArrayPoolSizeBytes;, +    float totalMb = totalBytes / (1024 * 1024);, +    float memoryClassMb = totalMb / harness.sizeMultiplier;, +    int byteArrayPoolSizeBytes = MemorySizeCalculator.Builder.BYTE_ARRAY_POOL_SIZE_BYTES;, +          .setByteArrayPoolSize(byteArrayPoolSizeBytes), +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java, +import org.robolectric.shadows.ShadowActivityManager;, +    // Keep the bitmap pool size constant, even though normally it would change., +    harness.byteArrayPoolSizeBytes *= 2;, +  @Test, +  public void testByteArrayPoolSize_withLowRamDevice_isHalfTheSpecifiedBytes() {, +    ShadowActivityManager activityManager = Shadows.shadowOf(harness.activityManager);, +    activityManager.setMemoryClass(getLargeEnoughMemoryClass());, +, +    Util.setSdkVersionInt(10);, +, +    int byteArrayPoolSize = harness.getCalculator().getByteArrayPoolSize();, +    assertThat(byteArrayPoolSize).isEqualTo(harness.byteArrayPoolSizeBytes / 2);, +  }, +, +    float totalBytes = totalScreenBytes + harness.byteArrayPoolSizeBytes;, +    float totalMb = totalBytes / (1024 * 1024);, +    float memoryClassMb = totalMb / harness.sizeMultiplier;, +    int byteArrayPoolSizeBytes = MemorySizeCalculator.Builder.BYTE_ARRAY_POOL_SIZE_BYTES;, +          .setByteArrayPoolSize(byteArrayPoolSizeBytes), +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +      byteArrayPool = new LruByteArrayPool(memorySizeCalculator.getByteArrayPoolSize());, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java, +import org.robolectric.shadows.ShadowActivityManager;, +    // Keep the bitmap pool size constant, even though normally it would change., +    harness.byteArrayPoolSizeBytes *= 2;, +  @Test, +  public void testByteArrayPoolSize_withLowRamDevice_isHalfTheSpecifiedBytes() {, +    ShadowActivityManager activityManager = Shadows.shadowOf(harness.activityManager);, +    activityManager.setMemoryClass(getLargeEnoughMemoryClass());, +, +    Util.setSdkVersionInt(10);, +, +    int byteArrayPoolSize = harness.getCalculator().getByteArrayPoolSize();, +    assertThat(byteArrayPoolSize).isEqualTo(harness.byteArrayPoolSizeBytes / 2);, +  }, +, +    float totalBytes = totalScreenBytes + harness.byteArrayPoolSizeBytes;, +    float totalMb = totalBytes / (1024 * 1024);, +    float memoryClassMb = totalMb / harness.sizeMultiplier;, +    int byteArrayPoolSizeBytes = MemorySizeCalculator.Builder.BYTE_ARRAY_POOL_SIZE_BYTES;, +          .setByteArrayPoolSize(byteArrayPoolSizeBytes), +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +      byteArrayPool = new LruByteArrayPool(memorySizeCalculator.getByteArrayPoolSize());, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java, +  static final int LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR = 2;, +  private final int byteArrayPoolSize;, +      int targetByteArrayPoolSize, float maxSizeMultiplier, float lowMemoryMaxSizeMultiplier) {, +    byteArrayPoolSize = isLowMemoryDevice(activityManager), +        ? targetByteArrayPoolSize / LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR : targetByteArrayPoolSize;, +    int availableSize = maxSize - byteArrayPoolSize;, +    if (targetMemoryCacheSize + targetPoolSize <= availableSize) {, +      float part = availableSize / (bitmapPoolScreens + memoryCacheScreens);, +          + ", byte array size: " + toMb(byteArrayPoolSize), +  /**, +   * Returns the recommended byte array pool size for the device it is run on in bytes., +   */, +  public int getByteArrayPoolSize() {, +    return byteArrayPoolSize;, +  }, +, +    return sdkInt < Build.VERSION_CODES.HONEYCOMB, +        || (sdkInt >= Build.VERSION_CODES.KITKAT && activityManager.isLowRamDevice());, +    // 4MB., +    static final int BYTE_ARRAY_POOL_SIZE_BYTES = 4 * 1024 * 1024;, +    private int byteArrayPoolSizeBytes = BYTE_ARRAY_POOL_SIZE_BYTES;, +    /**, +     * Sets the size in bytes of the {@link, +     * com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool} to use to store temporary, +     * arrays while decoding data and returns this builder., +     *, +     * <p>This number will be halved on low memory devices that return {@code true} from, +     * {@link ActivityManager#isLowRamDevice()}., +     */, +    public Builder setByteArrayPoolSize(int byteArrayPoolSizeBytes) {, +      this.byteArrayPoolSizeBytes = byteArrayPoolSizeBytes;, +      return this;, +    }, +, +          memoryCacheScreens, bitmapPoolScreens, byteArrayPoolSizeBytes, maxSizeMultiplier,]
[+++ b/library/src/androidTest/java/com/bumptech/glide/util/UtilTest.java, +package com.bumptech.glide.util;, +, +import android.graphics.Bitmap;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;, +, +import static org.junit.Assert.assertEquals;, +, +@RunWith(RobolectricTestRunner.class), +public class UtilTest {, +, +    @Test, +    public void testReturnsCorrectBitmapSizeForDifferentDimensions() {, +        int width = 100;, +        int height = 100;, +        Bitmap.Config config = Bitmap.Config.ARGB_8888;, +, +        int initialSize = Util.getBitmapPixelSize(width, height, config);, +        int sizeOne = Util.getBitmapPixelSize(width * 2, height, config);, +        int sizeTwo = Util.getBitmapPixelSize(width, height * 2, config);, +, +        assertEquals(4 * width * height, initialSize);, +        assertEquals(2 * initialSize, sizeOne);, +        assertEquals(2 * initialSize, sizeTwo);, +    }, +, +    @Test, +    public void testReturnsCorrectBitmapSizeForAlpha8Bitmap() {, +        int width = 110;, +        int height = 43;, +, +        int size = Util.getBitmapPixelSize(width, height, Bitmap.Config.ALPHA_8);, +        assertEquals(width * height, size);, +    }, +, +    @Test, +    public void testReturnsCorrectBitmapSizeForRgb565() {, +        int width = 34;, +        int height = 1444;, +, +        int size = Util.getBitmapPixelSize(width, height, Bitmap.Config.RGB_565);, +        assertEquals(width * height * 2, size);, +    }, +, +    @Test, +    public void testReturnsCorrectBitmapSizeForARGB4444() {, +        int width = 4454;, +        int height = 1235;, +, +        int size = Util.getBitmapPixelSize(width, height, Bitmap.Config.ARGB_4444);, +        assertEquals(width * height * 2, size);, +    }, +, +    @Test, +    public void testReturnsCorrectBitmapSizeForARGB8888() {, +        int width = 943;, +        int height = 3584;, +, +        int size = Util.getBitmapPixelSize(width, height, Bitmap.Config.ARGB_8888);, +        assertEquals(width * height * 4, size);, +    }, +, +    @Test, +    public void testReturnsLargestSizeForNullConfig() {, +        int width = 999;, +        int height = 41324;, +        int size = Util.getBitmapPixelSize(width, height, null);, +        assertEquals(width * height * 4, size);, +    }, +}, +++ b/library/src/androidTest/java/com/bumptech/glide/util/UtilTest.java, +package com.bumptech.glide.util;, +, +import android.graphics.Bitmap;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;, +, +import static org.junit.Assert.assertEquals;, +, +@RunWith(RobolectricTestRunner.class), +public class UtilTest {, +, +    @Test, +    public void testReturnsCorrectBitmapSizeForDifferentDimensions() {, +        int width = 100;, +        int height = 100;, +        Bitmap.Config config = Bitmap.Config.ARGB_8888;, +, +        int initialSize = Util.getBitmapPixelSize(width, height, config);, +        int sizeOne = Util.getBitmapPixelSize(width * 2, height, config);, +        int sizeTwo = Util.getBitmapPixelSize(width, height * 2, config);, +, +        assertEquals(4 * width * height, initialSize);, +        assertEquals(2 * initialSize, sizeOne);, +        assertEquals(2 * initialSize, sizeTwo);, +    }, +]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        context,]
[+++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':library'].collect { project(it) }, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':library'].collect { project(it) }, +++ b/integration/gifencoder/build.gradle, +apply plugin: 'com.android.library', +, +repositories {, +    mavenCentral(), +}, +, +dependencies {, +    compile project(':glide'), +}, +, +android {, +    compileSdkVersion COMPILE_SDK_VERSION as int, +    buildToolsVersion BUILD_TOOLS_VERSION, +, +    sourceSets {, +        main {, +          java.srcDirs = ['src/main/java', '../../third_party/gif_encoder/src/main/java'], +        }, +    }, +, +    defaultConfig {, +        minSdkVersion MIN_SDK_VERSION as int, +        targetSdkVersion TARGET_SDK_VERSION as int, +, +        versionCode = VERSION_CODE, +        versionName = VERSION_NAME, +    }, +, +    compileOptions {, +        sourceCompatibility JavaVersion.VERSION_1_7, +        targetCompatibility JavaVersion.VERSION_1_7, +    }, +}, +, +apply from: "$rootProject.projectDir/scripts/upload.gradle", +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':library'].collect { project(it) }, +++ b/integration/gifencoder/build.gradle, +apply plugin: 'com.android.library', +, +repositories {, +    mavenCentral(), +}, +, +dependencies {, +    compile project(':glide'), +}, +, +android {, +    compileSdkVersion COMPILE_SDK_VERSION as int, +    buildToolsVersion BUILD_TOOLS_VERSION, +, +    sourceSets {, +        main {, +          java.srcDirs = ['src/main/java', '../../third_party/gif_encoder/src/main/java'], +        }, +    }, +, +    defaultConfig {, +        minSdkVersion MIN_SDK_VERSION as int, +        targetSdkVersion TARGET_SDK_VERSION as int, +, +        versionCode = VERSION_CODE, +        versionName = VERSION_NAME, +    }, +, +    compileOptions {, +        sourceCompatibility JavaVersion.VERSION_1_7, +        targetCompatibility JavaVersion.VERSION_1_7, +    }, +}, +, +apply from: "$rootProject.projectDir/scripts/upload.gradle", +++ b/integration/gifencoder/gifencoder.iml, +<?xml version="1.0" encoding="UTF-8"?>, +<module external.linked.project.id=":integration:gifencoder" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +  <component name="FacetManager">, +    <facet type="android-gradle" name="Android-Gradle">, +      <configuration>, +        <option name="GRADLE_PROJECT_PATH" value=":integration:gifencoder" />, +      </configuration>, +    </facet>, +    <facet type="android" name="Android">, +      <configuration>, +        <option name="SELECTED_BUILD_VARIANT" value="debug" />, +        <option name="ASSEMBLE_TASK_NAME" value="assembleDebug" />, +        <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugSources" />, +        <option name="ASSEMBLE_TEST_TASK_NAME" value="assembleDebugTest" />, +        <option name="SOURCE_GEN_TASK_NAME" value="generateDebugSources" />, +        <option name="TEST_SOURCE_GEN_TASK_NAME" value="generateDebugTestSources" />, +        <option name="ALLOW_USER_CONFIGURATION" value="false" />, +        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/src/main/AndroidManifest.xml" />, +        <option name="RES_FOLDER_RELATIVE_PATH" value="/src/main/res" />, +        <option name="RES_FOLDERS_RELATIVE_PATH" value="" />, +        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/main/assets" />]
[+++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java, +    RequestBuilder<Drawable> thumbnailRequest = GlideApp.with(this), +        .decode(Bitmap.class);, +    GlideApp.with(this), +++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java, +    RequestBuilder<Drawable> thumbnailRequest = GlideApp.with(this), +        .decode(Bitmap.class);, +    GlideApp.with(this), +++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java, +    GlideApp.with(this), +    RequestBuilder<Drawable> gifItemRequest = GlideApp.with(this), +        .asDrawable();, +        new RecyclerViewPreloader<>(GlideApp.with(this), adapter, preloadSizeProvider, 4);, +    GifAdapter(Activity activity, RequestBuilder<Drawable> requestBuilder,, +    void setResults(Api.GifResult[] results) {, +    GifViewHolder(View itemView) {]
[+++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +import android.support.annotation.Nullable;, +    @Nullable, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +import android.support.annotation.Nullable;, +    @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/Option.java, +import android.support.annotation.Nullable;, +, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +import android.support.annotation.Nullable;, +    @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/Option.java, +import android.support.annotation.Nullable;, +, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +import android.support.annotation.Nullable;, +, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +import android.support.annotation.Nullable;, +    @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/Option.java, +import android.support.annotation.Nullable;, +, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +import android.support.annotation.Nullable;, +, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java, +import android.support.annotation.Nullable;, +, +    void onDataReady(@Nullable T data);, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +import android.support.annotation.Nullable;, +    @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/Option.java, +import android.support.annotation.Nullable;, +, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +import android.support.annotation.Nullable;, +, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java, +import android.support.annotation.Nullable;, +, +    void onDataReady(@Nullable T data);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java, +import android.support.annotation.Nullable;, +, +    void onDataFetcherReady(Key sourceKey, @Nullable Object data, DataFetcher<?> fetcher,, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +import android.support.annotation.Nullable;, +    @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/Option.java, +import android.support.annotation.Nullable;, +, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +import android.support.annotation.Nullable;, +, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java, +import android.support.annotation.Nullable;, +, +    void onDataReady(@Nullable T data);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java, +import android.support.annotation.Nullable;, +, +    void onDataFetcherReady(Key sourceKey, @Nullable Object data, DataFetcher<?> fetcher,, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java, +import android.support.annotation.Nullable;, +, +      @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +import android.support.annotation.Nullable;, +    @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/Option.java, +import android.support.annotation.Nullable;, +, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +import android.support.annotation.Nullable;, +, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java, +import android.support.annotation.Nullable;, +, +    void onDataReady(@Nullable T data);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java, +import android.support.annotation.Nullable;, +, +    void onDataFetcherReady(Key sourceKey, @Nullable Object data, DataFetcher<?> fetcher,, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java, +import android.support.annotation.Nullable;]
[+++ b/.idea/codeStyleSettings.xml, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/build.gradle, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/gradle.properties]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java, +  /**, +   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation., +   *, +   * @see #crossFade()., +   */, +  /**, +   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation., +   *, +   * @see #crossFade(int)., +   */, +  /**, +   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation., +   *, +   * @see #crossFade(int, int)., +   */, +  /**, +   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation., +   *, +   * @see #crossFade(DrawableCrossFadeFactory)., +   */, +  public static DrawableTransitionOptions withCrossFade(, +      DrawableCrossFadeFactory drawableCrossFadeFactory) {, +    return new DrawableTransitionOptions().crossFade(drawableCrossFadeFactory);, +  }, +, +  /**, +   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation., +   *, +   * @see #crossFade(DrawableCrossFadeFactory.Builder)., +   */, +  public static DrawableTransitionOptions withCrossFade(, +      DrawableCrossFadeFactory.Builder builder) {, +    return new DrawableTransitionOptions().crossFade(builder);, +  }, +, +  /**, +   * Enables a cross fade animation between both the placeholder and the first resource and between, +   * subsequent resources (if thumbnails are used)., +   */, +    return crossFade(new DrawableCrossFadeFactory.Builder());, +  /**, +   * Enables a cross fade animation between both the placeholder and the first resource and between, +   * subsequent resources (if thumbnails are used)., +   *, +   * @param duration The duration of the animation, see, +   *     {@link com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder(int)}, +   */, +    return crossFade(new DrawableCrossFadeFactory.Builder(duration));, +  /**, +   * Enables a cross fade animation between both the placeholder and the first resource and between, +   * subsequent resources (if thumbnails are used)., +   *, +   * @param animationId The id of the animation to use if no placeholder or previous resource is, +   *     set, see {@link com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder, +   *     #setDefaultAnimationId(int)}., +   * @param duration The duration of the animation, see, +   *     {@link com.bumptech.glide.request.transition.DrawableCrossFadeFactory.Builder(int)}, +   */, +    return crossFade(, +        new DrawableCrossFadeFactory.Builder(duration), +            .setDefaultAnimationId(animationId));, +  }, +, +  /**, +   * Enables a cross fade animation between both the placeholder and the first resource and between, +   * subsequent resources (if thumbnails are used)., +   */, +  public DrawableTransitionOptions crossFade(DrawableCrossFadeFactory drawableCrossFadeFactory) {, +    return transition(drawableCrossFadeFactory);, +  }, +, +  /**, +   * Enables a cross fade animation between both the placeholder and the first resource and between, +   * subsequent resources (if thumbnails are used)., +   */, +  public DrawableTransitionOptions crossFade(DrawableCrossFadeFactory.Builder builder) {, +    return crossFade(builder.build());, +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.java, +  /**, +   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation., +   *, +   * @see #crossFade()., +   */, +  /**, +   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation., +   *, +   * @see #crossFade(int)., +   */, +  /**, +   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation., +   *, +   * @see #crossFade(int, int)., +   */, +  /**, +   * Returns a {@link DrawableTransitionOptions} object that enables a cross fade animation., +   *, +   * @see #crossFade(DrawableCrossFadeFactory)., +   */, +  public static DrawableTransitionOptions withCrossFade(]
[+++ b/gradle.properties, +ROBOLECTRIC_VERSION=3.0-rc3, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=3.0-rc3, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=3.0-rc3, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.bumptech.glide.testutil.TestUtil.assertStreamOf;, +import org.robolectric.RobolectricTestRunner;, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=3.0-rc3, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.bumptech.glide.testutil.TestUtil.assertStreamOf;, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/test/java/com/bumptech/glide/GlideTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=3.0-rc3, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.bumptech.glide.testutil.TestUtil.assertStreamOf;, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/test/java/com/bumptech/glide/GlideTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=3.0-rc3, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.bumptech.glide.testutil.TestUtil.assertStreamOf;, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/test/java/com/bumptech/glide/GlideTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=3.0-rc3, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.bumptech.glide.testutil.TestUtil.assertStreamOf;, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/test/java/com/bumptech/glide/GlideTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/test/java/com/bumptech/glide/RequestManagerTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=3.0-rc3, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.bumptech.glide.testutil.TestUtil.assertStreamOf;, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/test/java/com/bumptech/glide/GlideTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/test/java/com/bumptech/glide/RequestManagerTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/test/java/com/bumptech/glide/load/OptionsTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=3.0-rc3, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.bumptech.glide.testutil.TestUtil.assertStreamOf;, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/test/java/com/bumptech/glide/GlideTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/test/java/com/bumptech/glide/RequestManagerTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/test/java/com/bumptech/glide/load/OptionsTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=3.0-rc3, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java]
[+++ b/annotation/compiler/build.gradle, +    compile 'com.google.code.findbugs:jsr305:3.0.1', +++ b/annotation/compiler/build.gradle, +    compile 'com.google.code.findbugs:jsr305:3.0.1', +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ChildModuleProcessor.java, +import java.util.Collections;, + * Generates Indexer classes annotated with {@link Index} for all, + * {@link com.bumptech.glide.module.ChildGlideModule}s., +  private IndexerGenerator indexerGenerator;, +  ChildModuleProcessor(ProcessorUtil processorUtil, IndexerGenerator indexerGenerator) {, +    this.indexerGenerator = indexerGenerator;, +    TypeSpec indexer = indexerGenerator.generate(childGlideModules);, +    processorUtil.writeIndexer(indexer);, +    return Collections.singleton(GlideModule.class.getName());, +++ b/annotation/compiler/build.gradle, +    compile 'com.google.code.findbugs:jsr305:3.0.1', +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ChildModuleProcessor.java, +import java.util.Collections;, + * Generates Indexer classes annotated with {@link Index} for all, + * {@link com.bumptech.glide.module.ChildGlideModule}s., +  private IndexerGenerator indexerGenerator;, +  ChildModuleProcessor(ProcessorUtil processorUtil, IndexerGenerator indexerGenerator) {, +    this.indexerGenerator = indexerGenerator;, +    TypeSpec indexer = indexerGenerator.generate(childGlideModules);, +    processorUtil.writeIndexer(indexer);, +    return Collections.singleton(GlideModule.class.getName());, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java, +package com.bumptech.glide.annotation.compiler;, +, +import com.bumptech.glide.annotation.GlideExtension;, +import com.squareup.javapoet.TypeSpec;, +import java.util.Collections;, +import java.util.List;, +import java.util.Set;, +import javax.annotation.processing.RoundEnvironment;, +import javax.lang.model.element.TypeElement;, +, +/**, + * Writes Indexer classes annotated with {@link Index} for all, + * classes found annotated with {@link GlideExtension}., + */, +final class ExtensionProcessor {, +  private final ProcessorUtil processorUtil;, +  private final IndexerGenerator indexerGenerator;, +, +  ExtensionProcessor(ProcessorUtil processorUtil, IndexerGenerator indexerGenerator) {, +    this.processorUtil = processorUtil;, +    this.indexerGenerator = indexerGenerator;, +  }, +, +  boolean processExtensions(Set<? extends TypeElement> set, RoundEnvironment env) {, +    List<TypeElement> elements = processorUtil.getElementsFor(GlideExtension.class, env);, +    processorUtil.debugLog("Processing types : " + elements);, +    for (TypeElement typeElement : elements) {, +      GlideExtensionValidator.validateExtension(typeElement);, +      processorUtil.debugLog("Processing elements: " + typeElement.getEnclosedElements());, +    }, +, +    if (elements.isEmpty()) {, +      return false;, +    }, +    TypeSpec spec = indexerGenerator.generate(elements);, +    processorUtil.writeIndexer(spec);, +    return true;, +  }, +, +  Set<String> getSupportedAnnotationTypes() {, +    return Collections.singleton(GlideExtension.class.getName());, +  }, +}, +++ b/annotation/compiler/build.gradle, +    compile 'com.google.code.findbugs:jsr305:3.0.1', +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ChildModuleProcessor.java, +import java.util.Collections;, + * Generates Indexer classes annotated with {@link Index} for all, + * {@link com.bumptech.glide.module.ChildGlideModule}s., +  private IndexerGenerator indexerGenerator;, +  ChildModuleProcessor(ProcessorUtil processorUtil, IndexerGenerator indexerGenerator) {, +    this.indexerGenerator = indexerGenerator;, +    TypeSpec indexer = indexerGenerator.generate(childGlideModules);, +    processorUtil.writeIndexer(indexer);, +    return Collections.singleton(GlideModule.class.getName());, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java, +package com.bumptech.glide.annotation.compiler;, +, +import com.bumptech.glide.annotation.GlideExtension;, +import com.squareup.javapoet.TypeSpec;, +import java.util.Collections;, +import java.util.List;, +import java.util.Set;, +import javax.annotation.processing.RoundEnvironment;, +import javax.lang.model.element.TypeElement;, +, +/**, + * Writes Indexer classes annotated with {@link Index} for all, + * classes found annotated with {@link GlideExtension}., + */, +final class ExtensionProcessor {, +  private final ProcessorUtil processorUtil;, +  private final IndexerGenerator indexerGenerator;]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +    if (resource != null && resource.isMemoryCacheable()) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +    if (resource != null && resource.isMemoryCacheable()) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java, +  private static volatile HardwareConfigState instance;, +, +  // See https://bit.ly/2IW5AmI, +  private static boolean isSamsungGalaxyS7Edge() {, +    return Build.MODEL.startsWith("SM-G935") || Build.MODEL.startsWith("SM-G930");, +  }]
[+++ b/src/com/bumptech/photos/loader/image/BaseImageLoader.java, +package com.bumptech.photos.loader.image;, +, +import android.graphics.Bitmap;, +, +import java.lang.ref.WeakReference;, +, +/**, + * Created with IntelliJ IDEA., + * User: sam, + * Date: 1/1/13, + * Time: 2:45 PM, + * To change this template use File | Settings | File Templates., + */, +public abstract class BaseImageLoader<T> implements ImageLoader<T> {, +    @Override, +    public final Object fetchImage(String path, T model, int width, int height, ImageReadyCallback cb) {, +        doFetchImage(path, model, width, height, cb);, +        return cb;, +    }, +, +    @Override, +    public void clear() { }, +, +    protected abstract void doFetchImage(String path, T model, int width, int height, ImageReadyCallback cb);, +, +    protected void onImageReady(Bitmap image, boolean isUsed) { }, +, +    protected void onImageLoadFailed(Exception e) { }, +, +, +    protected static class InternalImageReadyCallback {, +        private final WeakReference<ImageReadyCallback> cbRef;, +        private final WeakReference<BaseImageLoader> imageLoaderRef;, +, +        public InternalImageReadyCallback(BaseImageLoader imageLoader, ImageReadyCallback cb) {, +            this.imageLoaderRef = new WeakReference<BaseImageLoader>(imageLoader);, +            this.cbRef = new WeakReference<ImageReadyCallback>(cb);, +        }, +, +        protected final void onImageReady(Bitmap image) {, +            final BaseImageLoader imageLoader = imageLoaderRef.get();, +            final ImageReadyCallback cb = cbRef.get();, +            if (imageLoader != null && cb != null) {, +                imageLoader.onImageReady(image, cb.onImageReady(image));, +            }, +        }, +, +        protected final void onError(Exception e) {, +            final BaseImageLoader imageLoader = imageLoaderRef.get();, +            final ImageReadyCallback cb = cbRef.get();, +            if (imageLoader != null && cb != null) {, +                cb.onError(e);, +                imageLoader.onImageLoadFailed(e);, +            }, +        }, +    }, +}, +++ b/src/com/bumptech/photos/loader/image/BaseImageLoader.java, +package com.bumptech.photos.loader.image;, +, +import android.graphics.Bitmap;, +, +import java.lang.ref.WeakReference;, +, +/**, + * Created with IntelliJ IDEA., + * User: sam, + * Date: 1/1/13, + * Time: 2:45 PM, + * To change this template use File | Settings | File Templates., + */, +public abstract class BaseImageLoader<T> implements ImageLoader<T> {, +    @Override, +    public final Object fetchImage(String path, T model, int width, int height, ImageReadyCallback cb) {, +        doFetchImage(path, model, width, height, cb);, +        return cb;, +    }, +, +    @Override, +    public void clear() { }, +, +    protected abstract void doFetchImage(String path, T model, int width, int height, ImageReadyCallback cb);, +, +    protected void onImageReady(Bitmap image, boolean isUsed) { }, +, +    protected void onImageLoadFailed(Exception e) { }, +, +, +    protected static class InternalImageReadyCallback {, +        private final WeakReference<ImageReadyCallback> cbRef;, +        private final WeakReference<BaseImageLoader> imageLoaderRef;, +, +        public InternalImageReadyCallback(BaseImageLoader imageLoader, ImageReadyCallback cb) {, +            this.imageLoaderRef = new WeakReference<BaseImageLoader>(imageLoader);, +            this.cbRef = new WeakReference<ImageReadyCallback>(cb);, +        }, +, +        protected final void onImageReady(Bitmap image) {, +            final BaseImageLoader imageLoader = imageLoaderRef.get();]
[+++ b/build.gradle, +// Generate javadocs and sources containing batched documentation and sources for all subprojects., +    // Get the variant from each subproject that matches our current variant name., +    // Collect the source files from all android and java subprojects, +    def sourceFiles = childEquivalentChildVariants.collect { it.javaCompile.source } +, +                      javaProjects.collect { it.sourceSets.main.allJava }, +, +    task("${variant.name}SourceJar", type: Jar) {, +      classifier = 'sources', +      from sourceFiles, +    }, +, +    def cleanJavadocTask = task("clean${variant.name.capitalize()}Javadoc", type: Delete) {, +        delete destinationDirPath, +    }, +    clean.dependsOn(cleanJavadocTask), +, +    def javadocTask = task("${variant.name}Javadoc", type: Javadoc) {, +        classifier = 'javadoc', +, +        source = sourceFiles, +, +, +    def javadocJarTask = task("${variant.name}JavadocJar", type: Jar) {, +      classifier = 'javadoc', +      from javadocTask.destinationDir, +    }, +    javadocJarTask.dependsOn(javadocTask), +jar {, +    if (!project.getPlugins().hasPlugin('android')) {, +        jar.dependsOn(project.build), +    }, +    archives releaseJavadocJar, +    archives releaseSourceJar, +, +apply from: "$rootProject.projectDir/scripts/upload.gradle", +++ b/build.gradle, +// Generate javadocs and sources containing batched documentation and sources for all subprojects., +    // Get the variant from each subproject that matches our current variant name., +    // Collect the source files from all android and java subprojects, +    def sourceFiles = childEquivalentChildVariants.collect { it.javaCompile.source } +, +                      javaProjects.collect { it.sourceSets.main.allJava }, +, +    task("${variant.name}SourceJar", type: Jar) {, +      classifier = 'sources', +      from sourceFiles, +    }, +, +    def cleanJavadocTask = task("clean${variant.name.capitalize()}Javadoc", type: Delete) {, +        delete destinationDirPath, +    }, +    clean.dependsOn(cleanJavadocTask), +, +    def javadocTask = task("${variant.name}Javadoc", type: Javadoc) {, +        classifier = 'javadoc', +, +        source = sourceFiles, +, +, +    def javadocJarTask = task("${variant.name}JavadocJar", type: Jar) {, +      classifier = 'javadoc', +      from javadocTask.destinationDir, +    }, +    javadocJarTask.dependsOn(javadocTask), +jar {, +    if (!project.getPlugins().hasPlugin('android')) {, +        jar.dependsOn(project.build), +    }, +    archives releaseJavadocJar, +    archives releaseSourceJar, +, +apply from: "$rootProject.projectDir/scripts/upload.gradle", +++ b/gradle.properties, +VERSION_MINOR=3, +POM_NAME=Glide Library, +POM_ARTIFACT_ID=library, +POM_PACKAGING=jar, +, +++ b/build.gradle, +// Generate javadocs and sources containing batched documentation and sources for all subprojects., +    // Get the variant from each subproject that matches our current variant name., +    // Collect the source files from all android and java subprojects, +    def sourceFiles = childEquivalentChildVariants.collect { it.javaCompile.source } +, +                      javaProjects.collect { it.sourceSets.main.allJava }, +, +    task("${variant.name}SourceJar", type: Jar) {, +      classifier = 'sources', +      from sourceFiles, +    }, +, +    def cleanJavadocTask = task("clean${variant.name.capitalize()}Javadoc", type: Delete) {, +        delete destinationDirPath, +    }, +    clean.dependsOn(cleanJavadocTask), +, +    def javadocTask = task("${variant.name}Javadoc", type: Javadoc) {, +        classifier = 'javadoc', +, +        source = sourceFiles, +]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import static com.bumptech.glide.test.Matchers.anyDrawableTarget;, +            anyDrawableTarget(),, +            anyDrawableTarget(),, +            anyDrawableTarget(),, +            anyDrawableTarget(),, +            anyDrawableTarget(),, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import static com.bumptech.glide.test.Matchers.anyDrawableTarget;, +            anyDrawableTarget(),, +            anyDrawableTarget(),, +            anyDrawableTarget(),, +            anyDrawableTarget(),, +            anyDrawableTarget(),, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java, +import static com.bumptech.glide.test.Matchers.anyBitmap;, +import static com.bumptech.glide.test.Matchers.anyBitmapTarget;, +import static com.bumptech.glide.test.Matchers.anyDrawable;, +import static com.bumptech.glide.test.Matchers.anyDrawableTarget;, +import static org.mockito.Mockito.any;, +import static org.mockito.Mockito.anyBoolean;, +import static org.mockito.Mockito.eq;, +import static org.mockito.Mockito.verify;, +import com.bumptech.glide.load.DataSource;, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;, +import com.bumptech.glide.load.engine.cache.LruResourceCache;, +import com.bumptech.glide.request.RequestListener;, +import com.bumptech.glide.util.Util;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +  @Mock private RequestListener<Bitmap> bitmapListener;, +  @Mock private RequestListener<Drawable> drawableListener;, +, +    MockitoAnnotations.initMocks(this);, +  @Test, +  public void loadFromRequestManager_withBitmap_doesNotLoadFromDiskCache() {, +    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);, +    Glide.init(context, new GlideBuilder(), +        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10)), +        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));, +    FutureTarget<Drawable> target =, +        concurrency.wait(, +            GlideApp.with(context), +                .load(bitmap), +                .centerCrop(), +                .submit(100, 100));, +    Glide.with(context).clear(target);, +, +    assertThat(bitmap.isRecycled()).isFalse();, +, +    concurrency.runOnMainThread(new Runnable() {, +      @Override, +      public void run() {, +        Glide.get(context).clearMemory();, +      }, +    });, +, +    concurrency.wait(, +        GlideApp.with(context), +            .load(bitmap), +            .centerCrop(), +            .listener(drawableListener), +            .submit(100, 100));, +, +    verify(drawableListener), +        .onResourceReady(, +            anyDrawable(),, +            any(),, +            anyDrawableTarget(),, +            eq(DataSource.LOCAL),, +            anyBoolean());, +  }, +, +  @Test, +  public void loadFromRequestBuilder_asDrawable_withBitmap_doesNotLoadFromDiskCache() {, +    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);, +    Glide.init(context, new GlideBuilder(), +        .setMemoryCache(new LruResourceCache(Util.getBitmapByteSize(bitmap) * 10)), +        .setBitmapPool(new LruBitmapPool(Util.getBitmapByteSize(bitmap) * 10)));, +    FutureTarget<Drawable> target =, +        concurrency.wait(, +            GlideApp.with(context), +                .asDrawable(), +                .load(bitmap), +                .centerCrop(), +                .submit(100, 100));, +    Glide.with(context).clear(target);, +, +    assertThat(bitmap.isRecycled()).isFalse();, +, +    concurrency.runOnMainThread(new Runnable() {, +      @Override, +      public void run() {, +        Glide.get(context).clearMemory();, +      }, +    });, +, +    concurrency.wait(, +        GlideApp.with(context)]
[+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +    if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE), +        && canNotifyStatusChanged()) {]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java, +      return false;]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +   * Sets a {@link RequestBuilder} that is built and run if the load started by this]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.1', +  <version>3.5.1</version>, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.1', +  <version>3.5.1</version>, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }, +    }, +}, +, +subprojects {, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = 1.7, +        targetCompatibility = 1.7, +    }, +}, +, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />]
[+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java, +    return rawData.get() & MASK_INT_LOWEST_BYTE;, +    rawData.get(block, 0, Math.min(blockSize, rawData.remaining()));]
[+++ b/samples/flickr/build.gradle, +        minSdkVersion 11, +++ b/samples/flickr/build.gradle, +        minSdkVersion 11, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java, +import android.support.v4.view.MenuItemCompat;, +import android.support.v7.app.AppCompatActivity;, +import android.view.Menu;, +import android.view.MenuInflater;, +import android.widget.SearchView;, +import com.bumptech.glide.samples.flickr.api.Query;, +import com.bumptech.glide.samples.flickr.api.RecentQuery;, +import com.bumptech.glide.samples.flickr.api.SearchQuery;, +import java.util.Collections;, +public class FlickrSearchActivity extends AppCompatActivity, +    implements SearchView.OnQueryTextListener {, +  private static final String STATE_QUERY = "state_search_string";, +  private final QueryListener queryListener = new QueryListener();, +  private Set<PhotoViewer> photoViewers = new HashSet<>();, +  private List<Photo> currentPhotos = new ArrayList<>();, +  private SearchView searchView;, +  private Query currentQuery;, +  @Override, +  public boolean onCreateOptionsMenu(Menu menu) {, +    MenuInflater menuInflater = getMenuInflater();, +    menuInflater.inflate(R.menu.search_activity, menu);, +, +    searchView =, +        (SearchView) MenuItemCompat.getActionView(menu.findItem(R.id.search));, +    searchView.setSubmitButtonEnabled(true);, +    searchView.setIconified(false);, +    searchView.setOnQueryTextListener(this);, +, +    return true;, +  }, +, +  @Override, +  public boolean onQueryTextSubmit(String query) {, +    executeSearch(query);, +    searchView.setQuery("", false /*submit*/);, +    return true;, +  }, +, +  @Override, +  public boolean onQueryTextChange(String newText) {, +    return false;, +  }, +, +    StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder(), +        .detectAll(), +        .penaltyLog(), +        .build());, +, +    Api.get(this).registerSearchListener(queryListener);, +      Query savedQuery = savedInstanceState.getParcelable(STATE_QUERY);, +      if (savedQuery != null) {, +        executeQuery(savedQuery);, +    } else {, +      executeQuery(RecentQuery.get());, +    if (savedInstanceState == null) {, +  }, +    if (currentQuery != null) {, +      outState.putParcelable(STATE_QUERY, currentQuery);, +    Api.get(this).unregisterSearchListener(queryListener);, +  private void executeSearch(String searchString) {, +    Query query = TextUtils.isEmpty(searchString) ? null : new SearchQuery(searchString);, +    executeQuery(query);, +  private void executeQuery(Query query) {, +    currentQuery = query;, +    if (query == null) {, +      queryListener.onSearchCompleted(null, Collections.<Photo>emptyList());, +    searchTerm.setText(getString(R.string.searching_for, currentQuery.getDescription()));, +    Api.get(this).query(currentQuery);, +  private class QueryListener implements Api.QueryListener {, +    public void onSearchCompleted(Query query, List<Photo> photos) {, +      if (!isCurrentQuery(query)) {, +    private boolean isCurrentQuery(Query query) {, +      return currentQuery != null && currentQuery.equals(query);, +    }, +, +    public void onSearchFailed(Query query, Exception e) {, +      if (!isCurrentQuery(query)) {, +      searchTerm.setText(getString(R.string.search_failed, currentQuery.getDescription()));, +    @Override, +    public CharSequence getPageTitle(int position) {, +      Page page = Page.values()[position];, +      int titleId = PAGE_TO_TITLE.get(page);, +      return getString(titleId);, +    }, +, +++ b/samples/flickr/build.gradle, +        minSdkVersion 11, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java, +import android.support.v4.view.MenuItemCompat;, +import android.support.v7.app.AppCompatActivity;, +import android.view.Menu;, +import android.view.MenuInflater;, +import android.widget.SearchView;, +import com.bumptech.glide.samples.flickr.api.Query;, +import com.bumptech.glide.samples.flickr.api.RecentQuery;]
[+++ b/.gitmodules, +++ b/.gitmodules, +++ /dev/null, +++ b/.gitmodules, +++ /dev/null, +++ b/libs/disklrucache-1.2.1.jar]
[+++ b/.gitignore, +.gradle, +build, +++ b/.gitignore, +.gradle, +build, +++ b/README.md, +Build, +------, +Building Glide with gradle is fairly straight forward:, +, +```, +cd glide/library, +./gradlew build, +```, +, +Note: Make sure your Android SDK has the Android Support Repository installed, and that your `$ANDROID_HOME` environment variable is pointing at the SDK., +, +++ b/.gitignore, +.gradle, +build, +++ b/README.md, +Build, +------, +Building Glide with gradle is fairly straight forward:, +, +```, +cd glide/library, +./gradlew build, +```, +, +Note: Make sure your Android SDK has the Android Support Repository installed, and that your `$ANDROID_HOME` environment variable is pointing at the SDK., +, +++ b/library/build.gradle, +        // TODO: Remove this repository as soon as fix, +        // https://github.com/robolectric/robolectric-gradle-plugin/pull/33 is released., +        maven { url 'https://github.com/rockerhieu/mvn-repo/raw/master/' }, +        classpath 'com.android.tools.build:gradle:0.11.2', +        // TODO: Remove the snapshot dependency below and replace with, +        // classpath 'org.robolectric.gradle:gradle-android-test-plugin:0.10.+', +        // as soon as fix https://github.com/robolectric/robolectric-gradle-plugin/pull/33, +        // is released., +        classpath 'org.robolectric.gradle:gradle-android-test-plugin:0.10.1-SNAPSHOT', +apply plugin: 'android-test', +    compile project(':third_party:gif_decoder'), +, +    compile 'com.android.support:support-v4:19.0.+', +    compile 'com.mcxiaoke.volley:library:1.0.+', +    compile 'com.jakewharton:disklrucache:2.0.+', +, +    androidTestCompile 'org.hamcrest:hamcrest-core:1.3', +    androidTestCompile 'junit:junit:4.11', +    androidTestCompile 'org.mockito:mockito-all:1.9.5', +    androidTestCompile 'org.robolectric:robolectric:2.3', +    buildToolsVersion = '19.1.0', +            resources.srcDirs    = ['src/main'], +            java.srcDirs         = ['src/main'], +        }, +        instrumentTest.setRoot('src/test'), +    }, +, +    lintOptions {, +        abortOnError false, +, +task wrapper(type: Wrapper) {, +    gradleVersion = '1.10', +++ b/.gitignore, +.gradle, +build, +++ b/README.md, +Build, +------, +Building Glide with gradle is fairly straight forward:, +, +```, +cd glide/library, +./gradlew build, +```, +, +Note: Make sure your Android SDK has the Android Support Repository installed, and that your `$ANDROID_HOME` environment variable is pointing at the SDK., +, +++ b/library/build.gradle, +        // TODO: Remove this repository as soon as fix, +        // https://github.com/robolectric/robolectric-gradle-plugin/pull/33 is released., +        maven { url 'https://github.com/rockerhieu/mvn-repo/raw/master/' }, +        classpath 'com.android.tools.build:gradle:0.11.2', +        // TODO: Remove the snapshot dependency below and replace with, +        // classpath 'org.robolectric.gradle:gradle-android-test-plugin:0.10.+', +        // as soon as fix https://github.com/robolectric/robolectric-gradle-plugin/pull/33, +        // is released., +        classpath 'org.robolectric.gradle:gradle-android-test-plugin:0.10.1-SNAPSHOT', +apply plugin: 'android-test', +    compile project(':third_party:gif_decoder'), +, +    compile 'com.android.support:support-v4:19.0.+', +    compile 'com.mcxiaoke.volley:library:1.0.+', +    compile 'com.jakewharton:disklrucache:2.0.+', +, +    androidTestCompile 'org.hamcrest:hamcrest-core:1.3', +    androidTestCompile 'junit:junit:4.11']
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java, +import com.bumptech.glide.RequestBuilder;, +   * <p>It is not safe to reload this or a different model in this callback. If you need to do so, +   * use {@link com.bumptech.glide.RequestBuilder#error(RequestBuilder)} instead., +   *, +   * <p>Although you can't start an entirely new load, it is safe to change what is displayed in the, +   * {@link Target} at this point, as long as you return {@code true} from the method to prevent, +   * {@link Target#onLoadFailed(Drawable)} from being called., +   *, +   * For example:, +   * public boolean onLoadFailed(Exception e, T model, Target target, boolean isFirstResource) {, +   *     return true; // Prevent onLoadFailed from being called on the Target., +   * @return {@code true} to prevent {@link Target#onLoadFailed(Drawable)} from being called on, +   * {@code target}, typically because the listener wants to update the {@code target} or the object, +   * the {@code target} wraps itself or {@code false} to allow {@link Target#onLoadFailed(Drawable)}, +   * to be called on {@code target}., +  boolean onLoadFailed(, +      @Nullable GlideException e, Object model, Target<R> target, boolean isFirstResource);, +   *, +   * @return {@code true} to prevent {@link Target#onLoadFailed(Drawable)} from being called on, +   * {@code target}, typically because the listener wants to update the {@code target} or the object, +   * the {@code target} wraps itself or {@code false} to allow {@link Target#onLoadFailed(Drawable)}, +   * to be called on {@code target}., +  boolean onResourceReady(, +      R resource, Object model, Target<R> target, DataSource dataSource, boolean isFirstResource);]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/model/LazyHeadersTest.java, +package com.bumptech.glide.load.model;, +, +import static com.google.common.truth.Truth.assertThat;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.when;, +, +import com.google.common.testing.EqualsTester;, +, +import com.bumptech.glide.load.model.LazyHeaders.Builder;, +, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +, +import java.util.Map;, +, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +public class LazyHeadersTest {, +, +    @Test, +    public void testIncludesEagerHeaders() {, +        Map<String, String> headers = new Builder(), +            .addHeader("key", "value"), +            .build(), +            .getHeaders();, +        assertThat(headers).containsEntry("key", "value");, +        assertThat(headers).hasSize(1);, +    }, +, +    @Test, +    public void testIncludesLazyHeaders() {, +        LazyHeaderFactory factory = mock(LazyHeaderFactory.class);, +        when(factory.buildHeader()).thenReturn("value");, +        Map<String, String> headers = new Builder(), +            .addHeader("key", factory), +            .build(), +            .getHeaders();, +, +        assertThat(headers).hasSize(1);, +        assertThat(headers).containsEntry("key", "value");, +    }, +, +    @Test, +    public void testMultipleEagerValuesAreSeparatedByCommas() {, +        Map<String, String> headers = new Builder(), +            .addHeader("key", "first"), +            .addHeader("key", "second"), +            .build(), +            .getHeaders();, +, +        assertThat(headers).hasSize(1);, +        assertThat(headers).containsEntry("key", "first,second");, +    }, +, +    @Test, +    public void testMultipleLazyValuesAreSeparatedByCommas() {, +        LazyHeaderFactory first = mock(LazyHeaderFactory.class);, +        when(first.buildHeader()).thenReturn("first");, +        LazyHeaderFactory second = mock(LazyHeaderFactory.class);, +        when(second.buildHeader()).thenReturn("second");, +, +        Map<String, String> headers = new Builder(), +            .addHeader("key", first), +            .addHeader("key", second), +            .build(), +            .getHeaders();, +        assertThat(headers).hasSize(1);, +        assertThat(headers).containsEntry("key", "first,second");, +    }, +, +    @Test, +    public void testMixedEagerAndLazyValuesAreIncluded() {, +        LazyHeaderFactory factory = mock(LazyHeaderFactory.class);, +        when(factory.buildHeader()).thenReturn("first");, +        Map<String, String> headers = new Builder(), +            .addHeader("key", factory), +            .addHeader("key", "second"), +            .build(), +            .getHeaders();, +, +        assertThat(headers).hasSize(1);, +        assertThat(headers).containsEntry("key", "first,second");, +, +        headers = new Builder(), +            .addHeader("key", "second"), +            .addHeader("key", factory), +            .build(), +            .getHeaders();, +, +        assertThat(headers).hasSize(1);, +        assertThat(headers).containsEntry("key", "second,first");, +    }, +, +    @Test, +    public void testCanAddMultipleKeys() {, +        LazyHeaderFactory factory = mock(LazyHeaderFactory.class);, +        when(factory.buildHeader()).thenReturn("lazy");]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/.gitmodules, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ b/.gitignore, +++ b/.gitmodules, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ b/LICENSE, +Copyright 2013 Bump Technologies, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY BUMP TECHNOLOGIES, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BUMP TECHNOLOGIES, INC. OR, +or implied, of Bump Technologies, Inc., +++ b/.gitignore, +++ b/.gitmodules, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ b/LICENSE, +Copyright 2013 Bump Technologies, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY BUMP TECHNOLOGIES, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BUMP TECHNOLOGIES, INC. OR, +or implied, of Bump Technologies, Inc., +++ b/Makefile, +	cd library/volley && ant clean && ant jar, +	cp library/volley/bin/volley.jar library/libs, +, +glide-minus-volley:, +	cd library && ant clean && ant glide-minus-volley, +, +++ b/.gitignore, +++ b/.gitmodules, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ b/LICENSE, +Copyright 2013 Bump Technologies, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY BUMP TECHNOLOGIES, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BUMP TECHNOLOGIES, INC. OR, +or implied, of Bump Technologies, Inc., +++ b/Makefile, +	cd library/volley && ant clean && ant jar, +	cp library/volley/bin/volley.jar library/libs, +, +glide-minus-volley:, +	cd library && ant clean && ant glide-minus-volley, +, +++ b/library/.gitignore, +++ b/.gitignore, +++ b/.gitmodules, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ b/LICENSE, +Copyright 2013 Bump Technologies, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY BUMP TECHNOLOGIES, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BUMP TECHNOLOGIES, INC. OR, +or implied, of Bump Technologies, Inc., +++ b/Makefile, +	cd library/volley && ant clean && ant jar, +	cp library/volley/bin/volley.jar library/libs, +, +glide-minus-volley:, +	cd library && ant clean && ant glide-minus-volley, +, +++ b/library/.gitignore, +++ b/library/AndroidManifest.xml, +          android:versionCode="6", +          android:versionName="2.0.4" >, +  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" />, +++ b/.gitignore, +++ b/.gitmodules, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ b/LICENSE, +Copyright 2013 Bump Technologies, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY BUMP TECHNOLOGIES, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BUMP TECHNOLOGIES, INC. OR, +or implied, of Bump Technologies, Inc., +++ b/Makefile, +	cd library/volley && ant clean && ant jar, +	cp library/volley/bin/volley.jar library/libs, +, +glide-minus-volley:]
[+++ b/Makefile, +jar:, +	cd library && ant jar, +glide-minus-volley:, +	cd library && ant glide-minus-volley, +, +++ b/Makefile, +jar:, +	cd library && ant jar, +glide-minus-volley:, +	cd library && ant glide-minus-volley, +, +++ b/library/build.xml, +<project name="glide" default="help">, +++ b/Makefile, +jar:, +	cd library && ant jar, +glide-minus-volley:, +	cd library && ant glide-minus-volley, +, +++ b/library/build.xml, +<project name="glide" default="help">, +++ b/library/custom_rules.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<project name="glide-rules" default="help">, +    <target name="jar" depends="-compile">, +        <jar destfile="bin/glide.jar", +            basedir="bin/classes" >, +            <zipgroupfileset dir="libs" includes="*.jar" />, +        </jar>, +    </target>, +    <target name="glide-minus-volley" depends="-compile">, +        <jar destfile="bin/glide-minus-volley.jar", +            basedir="bin/classes" >, +            <zipgroupfileset dir="libs" includes="disklrucache*.jar" />, +        </jar>, +    </target>, +</project>, +++ b/Makefile, +jar:, +	cd library && ant jar, +glide-minus-volley:, +	cd library && ant glide-minus-volley, +, +++ b/library/build.xml, +<project name="glide" default="help">, +++ b/library/custom_rules.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<project name="glide-rules" default="help">, +    <target name="jar" depends="-compile">, +        <jar destfile="bin/glide.jar", +            basedir="bin/classes" >, +            <zipgroupfileset dir="libs" includes="*.jar" />, +        </jar>, +    </target>, +    <target name="glide-minus-volley" depends="-compile">, +        <jar destfile="bin/glide-minus-volley.jar", +            basedir="bin/classes" >, +            <zipgroupfileset dir="libs" includes="disklrucache*.jar" />, +        </jar>, +    </target>, +</project>, +++ b/library/project.properties, +, +# https://code.google.com/p/android/issues/detail?id=40487, +renderscript.opt.level=O0]
[+++ b/integration/integration.iml, +    <facet type="java-gradle" name="Java-Gradle">, +      <configuration>, +        <option name="BUILD_FOLDER_PATH" />, +      </configuration>, +    </facet>, +    <content url="file://$MODULE_DIR$">, +      <excludeFolder url="file://$MODULE_DIR$/.gradle" />, +      <excludeFolder url="file://$MODULE_DIR$/build" />, +    </content>, +++ b/integration/integration.iml, +    <facet type="java-gradle" name="Java-Gradle">, +      <configuration>, +        <option name="BUILD_FOLDER_PATH" />, +      </configuration>, +    </facet>, +    <content url="file://$MODULE_DIR$">, +      <excludeFolder url="file://$MODULE_DIR$/.gradle" />, +      <excludeFolder url="file://$MODULE_DIR$/build" />, +    </content>, +++ b/integration/okhttp/okhttp.iml, +        <option name="RES_FOLDERS_RELATIVE_PATH" value="" />, +      <excludeFolder url="file://$MODULE_DIR$/build/docs" />, +      <excludeFolder url="file://$MODULE_DIR$/build/poms" />, +      <excludeFolder url="file://$MODULE_DIR$/build/reports" />, +++ b/integration/integration.iml, +    <facet type="java-gradle" name="Java-Gradle">, +      <configuration>, +        <option name="BUILD_FOLDER_PATH" />, +      </configuration>, +    </facet>, +    <content url="file://$MODULE_DIR$">, +      <excludeFolder url="file://$MODULE_DIR$/.gradle" />, +      <excludeFolder url="file://$MODULE_DIR$/build" />, +    </content>, +++ b/integration/okhttp/okhttp.iml, +        <option name="RES_FOLDERS_RELATIVE_PATH" value="" />, +      <excludeFolder url="file://$MODULE_DIR$/build/docs" />, +      <excludeFolder url="file://$MODULE_DIR$/build/poms" />, +      <excludeFolder url="file://$MODULE_DIR$/build/reports" />, +++ b/integration/volley/volley.iml, +        <option name="RES_FOLDERS_RELATIVE_PATH" value="" />, +      <excludeFolder url="file://$MODULE_DIR$/build/dependency-cache" />, +      <excludeFolder url="file://$MODULE_DIR$/build/docs" />, +      <excludeFolder url="file://$MODULE_DIR$/build/poms" />, +      <excludeFolder url="file://$MODULE_DIR$/build/reports" />, +      <excludeFolder url="file://$MODULE_DIR$/build/test-classes" />, +      <excludeFolder url="file://$MODULE_DIR$/build/test-report" />, +      <excludeFolder url="file://$MODULE_DIR$/build/test-results" />, +    <orderEntry type="library" exported="" name="library-1.0.8" level="project" />, +++ b/integration/integration.iml, +    <facet type="java-gradle" name="Java-Gradle">, +      <configuration>, +        <option name="BUILD_FOLDER_PATH" />, +      </configuration>, +    </facet>, +    <content url="file://$MODULE_DIR$">, +      <excludeFolder url="file://$MODULE_DIR$/.gradle" />, +      <excludeFolder url="file://$MODULE_DIR$/build" />, +    </content>, +++ b/integration/okhttp/okhttp.iml, +        <option name="RES_FOLDERS_RELATIVE_PATH" value="" />, +      <excludeFolder url="file://$MODULE_DIR$/build/docs" />, +      <excludeFolder url="file://$MODULE_DIR$/build/poms" />, +      <excludeFolder url="file://$MODULE_DIR$/build/reports" />, +++ b/integration/volley/volley.iml, +        <option name="RES_FOLDERS_RELATIVE_PATH" value="" />, +      <excludeFolder url="file://$MODULE_DIR$/build/dependency-cache" />, +      <excludeFolder url="file://$MODULE_DIR$/build/docs" />, +      <excludeFolder url="file://$MODULE_DIR$/build/poms" />, +      <excludeFolder url="file://$MODULE_DIR$/build/reports" />, +      <excludeFolder url="file://$MODULE_DIR$/build/test-classes" />, +      <excludeFolder url="file://$MODULE_DIR$/build/test-report" />, +      <excludeFolder url="file://$MODULE_DIR$/build/test-results" />, +    <orderEntry type="library" exported="" name="library-1.0.8" level="project" />, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java, +, +        @Override, +        public Class<Closeable> getDataClass() {, +            return Closeable.class;, +        }, +++ b/integration/integration.iml, +    <facet type="java-gradle" name="Java-Gradle">, +      <configuration>, +        <option name="BUILD_FOLDER_PATH" />, +      </configuration>, +    </facet>, +    <content url="file://$MODULE_DIR$">, +      <excludeFolder url="file://$MODULE_DIR$/.gradle" />, +      <excludeFolder url="file://$MODULE_DIR$/build" />, +    </content>, +++ b/integration/okhttp/okhttp.iml, +        <option name="RES_FOLDERS_RELATIVE_PATH" value="" />, +      <excludeFolder url="file://$MODULE_DIR$/build/docs" />, +      <excludeFolder url="file://$MODULE_DIR$/build/poms" />, +      <excludeFolder url="file://$MODULE_DIR$/build/reports" />, +++ b/integration/volley/volley.iml, +        <option name="RES_FOLDERS_RELATIVE_PATH" value="" />, +      <excludeFolder url="file://$MODULE_DIR$/build/dependency-cache" />, +      <excludeFolder url="file://$MODULE_DIR$/build/docs" />]
[+++ b/.idea/codeStyleSettings.xml, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MAJOR=3, +VERSION_MINOR=6, +SUPPORT_V4_VERSION=19.1.0, +SUPPORT_V7_VERSION=19.1.0, +# TODO: Upgrade to latest version of Volley when we compile with Java 7., +VOLLEY_VERSION=1.0.8, +ANDROID_GRADLE_VERSION=1.0.0, +ROBOLECTRIC_GRADLE_VERSION=0.14.0, +ROBOLECTRIC_VERSION=2.4, +MOCKWEBSERVER_VERSION=1.6.0, +COMPILE_SDK_VERSION=19, +BUILD_TOOLS_VERSION=19.1.0, +TARGET_SDK_VERSION=19, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java, +import static org.junit.Assert.assertNull;, +    @Test, +    public void testReturnsNullIfTransformReturnsNull() {, +        BitmapTransformation transform = new BitmapTransformation(bitmapPool) {, +, +            @Override, +            public String getId() {, +                return null;, +            }, +, +            @Override, +            protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {, +                return null;, +            }, +        };, +, +        Resource<Bitmap> resource = mock(Resource.class);, +        when(resource.get()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565));, +        assertNull(transform.transform(resource, 100, 100));, +    }, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java, +import static org.junit.Assert.assertNull;, +    @Test, +    public void testReturnsNullIfTransformReturnsNull() {, +        BitmapTransformation transform = new BitmapTransformation(bitmapPool) {, +, +            @Override, +            public String getId() {, +                return null;, +            }, +, +            @Override, +            protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {, +                return null;, +            }, +        };, +, +        Resource<Bitmap> resource = mock(Resource.class);, +        when(resource.get()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565));, +        assertNull(transform.transform(resource, 100, 100));, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillIdleHandler.java, +                memoryCache.put(new UniqueKey(), BitmapResource.obtain(bitmap, bitmapPool));, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java, +import static org.junit.Assert.assertNull;, +    @Test, +    public void testReturnsNullIfTransformReturnsNull() {, +        BitmapTransformation transform = new BitmapTransformation(bitmapPool) {, +, +            @Override, +            public String getId() {, +                return null;, +            }, +, +            @Override, +            protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {, +                return null;, +            }, +        };, +, +        Resource<Bitmap> resource = mock(Resource.class);, +        when(resource.get()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565));, +        assertNull(transform.transform(resource, 100, 100));, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillIdleHandler.java, +                memoryCache.put(new UniqueKey(), BitmapResource.obtain(bitmap, bitmapPool));, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java, +    /**, +     * Returns a new {@link BitmapResource} wrapping the given {@link Bitmap} if the Bitmap is non-null or null if the, +     * given Bitmap is null., +     *, +     * @param bitmap A Bitmap., +     * @param bitmapPool A non-null {@link com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool}., +     */, +    public static BitmapResource obtain(Bitmap bitmap, BitmapPool bitmapPool) {, +        if (bitmap == null) {, +            return null;, +        } else {, +            return new BitmapResource(bitmap, bitmapPool);, +        }, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java, +import static org.junit.Assert.assertNull;, +    @Test, +    public void testReturnsNullIfTransformReturnsNull() {, +        BitmapTransformation transform = new BitmapTransformation(bitmapPool) {, +, +            @Override, +            public String getId() {, +                return null;, +            }, +, +            @Override, +            protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {, +                return null;, +            }, +        };, +]
[+++ b/.idea/codeStyleSettings.xml, +        <Objective-C-extensions>, +          <option name="GENERATE_INSTANCE_VARIABLES_FOR_PROPERTIES" value="ASK" />, +          <option name="RELEASE_STYLE" value="IVAR" />, +          <option name="TYPE_QUALIFIERS_PLACEMENT" value="BEFORE" />, +          <file>, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Import" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Macro" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Typedef" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Enum" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Constant" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Global" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Struct" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="FunctionPredecl" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Function" />, +          </file>, +          <class>, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Property" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Synthesize" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InitMethod" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="StaticMethod" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InstanceMethod" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="DeallocMethod" />, +          </class>, +          <extensions>, +            <pair source="cpp" header="h" />, +            <pair source="c" header="h" />, +          </extensions>, +        </Objective-C-extensions>]
[+++ b/gradle.properties, +VERSION_NAME=4.5.0]
[+++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +        if (target == null) {, +            throw new IllegalArgumentException("You must pass in a non null Target");, +        }, +, +        if (view == null) {, +            throw new IllegalArgumentException("You must pass in a non null View");, +        }, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +        if (target == null) {, +            throw new IllegalArgumentException("You must pass in a non null Target");, +        }, +, +        if (view == null) {, +            throw new IllegalArgumentException("You must pass in a non null View");, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameManager.java, +import com.bumptech.glide.load.model.NullEncoder;, +    private final NullEncoder<GifDecoder> sourceEncoder;, +        sourceEncoder = NullEncoder.get();, +                .sourceEncoder(sourceEncoder), +                .transform(transformation), +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +        if (target == null) {, +            throw new IllegalArgumentException("You must pass in a non null Target");, +        }, +, +        if (view == null) {, +            throw new IllegalArgumentException("You must pass in a non null View");, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameManager.java, +import com.bumptech.glide.load.model.NullEncoder;, +    private final NullEncoder<GifDecoder> sourceEncoder;, +        sourceEncoder = NullEncoder.get();, +                .sourceEncoder(sourceEncoder), +                .transform(transformation), +++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java, +import android.graphics.drawable.Animatable;, +        if (!(resource instanceof Animatable)) {, +            if (Math.abs(viewRatio - 1f) <= SQUARE_RATIO_MARGIN &&, +                    Math.abs(drawableRatio - 1f) <= SQUARE_RATIO_MARGIN) {, +        }, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +        if (target == null) {, +            throw new IllegalArgumentException("You must pass in a non null Target");, +        }, +, +        if (view == null) {, +            throw new IllegalArgumentException("You must pass in a non null View");, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameManager.java, +import com.bumptech.glide.load.model.NullEncoder;, +    private final NullEncoder<GifDecoder> sourceEncoder;, +        sourceEncoder = NullEncoder.get();, +                .sourceEncoder(sourceEncoder), +                .transform(transformation), +++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java, +import android.graphics.drawable.Animatable;, +        if (!(resource instanceof Animatable)) {, +            if (Math.abs(viewRatio - 1f) <= SQUARE_RATIO_MARGIN &&, +                    Math.abs(drawableRatio - 1f) <= SQUARE_RATIO_MARGIN) {, +        }, +++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java, +        if (view == null) {, +            throw new NullPointerException("View must not be null!");, +        }, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +        if (target == null) {, +            throw new IllegalArgumentException("You must pass in a non null Target");, +        }, +, +        if (view == null) {, +            throw new IllegalArgumentException("You must pass in a non null View");, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameManager.java, +import com.bumptech.glide.load.model.NullEncoder;, +    private final NullEncoder<GifDecoder> sourceEncoder;, +        sourceEncoder = NullEncoder.get();, +                .sourceEncoder(sourceEncoder), +                .transform(transformation), +++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java, +import android.graphics.drawable.Animatable;, +        if (!(resource instanceof Animatable)) {, +            if (Math.abs(viewRatio - 1f) <= SQUARE_RATIO_MARGIN &&, +                    Math.abs(drawableRatio - 1f) <= SQUARE_RATIO_MARGIN) {, +        }, +++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java, +        if (view == null) {, +            throw new NullPointerException("View must not be null!");, +        }, +++ b/library/src/test/java/com/bumptech/glide/GenericRequestBuilderTest.java, +import android.widget.ImageView;, +    @Test(expected = IllegalArgumentException.class), +    public void testThrowsIfGivenNullTarget() {, +        getNullModelRequest().into((Target) null);, +    }, +, +    @Test(expected = IllegalArgumentException.class), +    public void testThrowsIfGivenNullView() {, +        getNullModelRequest().into((ImageView) null);]
[+++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +, +import com.bumptech.glide.request.FutureTarget;, +import com.bumptech.glide.request.RequestFutureTarget;, +    /**, +     * Returns a future that can be used to do a blocking get on a background thread., +     *, +     * @param width The desired width (note this will be overriden by {@link #override(int, int)} if, +     *              previously called., +     * @param height The desired height (note this will be overriden by {@link #override(int, int)}}, +     *               if previously called., +     * @return An {@link com.bumptech.glide.request.FutureTarget} that can be used to obtain the, +     *         resource in a blocking manner., +     */, +    public FutureTarget<TranscodeType> into(int width, int height) {, +        final RequestFutureTarget<ModelType, TranscodeType> target =, +                new RequestFutureTarget<ModelType, TranscodeType>(glide.getMainHandler(), width, height);, +        listener(target);, +, +        // TODO: Currently all loads must be started on the main thread..., +        glide.getMainHandler().post(new Runnable() {, +            @Override, +            public void run() {, +                if (!target.isCancelled()) {, +                    into(target);, +                }, +            }, +        });, +, +        return target;, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +, +import com.bumptech.glide.request.FutureTarget;, +import com.bumptech.glide.request.RequestFutureTarget;, +    /**, +     * Returns a future that can be used to do a blocking get on a background thread., +     *, +     * @param width The desired width (note this will be overriden by {@link #override(int, int)} if, +     *              previously called., +     * @param height The desired height (note this will be overriden by {@link #override(int, int)}}, +     *               if previously called., +     * @return An {@link com.bumptech.glide.request.FutureTarget} that can be used to obtain the, +     *         resource in a blocking manner., +     */, +    public FutureTarget<TranscodeType> into(int width, int height) {, +        final RequestFutureTarget<ModelType, TranscodeType> target =, +                new RequestFutureTarget<ModelType, TranscodeType>(glide.getMainHandler(), width, height);, +        listener(target);, +, +        // TODO: Currently all loads must be started on the main thread..., +        glide.getMainHandler().post(new Runnable() {, +            @Override, +            public void run() {, +                if (!target.isCancelled()) {, +                    into(target);, +                }, +            }, +        });, +, +        return target;, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.os.Handler;, +import android.os.Looper;, +, +import com.bumptech.glide.request.FutureTarget;, +    private final Handler mainHandler;, +            synchronized (Glide.class) {, +                if (GLIDE == null) {, +            }, +        }, +        mainHandler = new Handler(Looper.getMainLooper());, +    Handler getMainHandler() {, +        return mainHandler;, +    }, +, +     * Cancel any pending loads Glide may have for the target and free any resources that mayhave been loaded into, +     * the target so they may be reused., +     *, +     * @param target The target to cancel loads for., +     */, +    public static void clear(FutureTarget target) {, +        target.clear();, +    }, +, +    /**, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +, +import com.bumptech.glide.request.FutureTarget;, +import com.bumptech.glide.request.RequestFutureTarget;, +    /**, +     * Returns a future that can be used to do a blocking get on a background thread., +     *, +     * @param width The desired width (note this will be overriden by {@link #override(int, int)} if, +     *              previously called., +     * @param height The desired height (note this will be overriden by {@link #override(int, int)}}, +     *               if previously called.]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/ResourceRunnerTest.java, +        verify(harness.transcoder).transcode(eq(harness.decoded));, +        verify(harness.transcoder, never()).transcode(eq(harness.decoded));, +        when(harness.transcoder.transcode(eq(harness.decoded))).thenReturn(harness.transcoded);, +        when(harness.transcoder.transcode(eq(harness.decoded))).thenReturn(harness.transcoded);, +        verify(harness.decoded, never()).recycle();, +            return new ResourceRunner(key, width, height, cacheLoader, decoder, transcoder,, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/ResourceRunnerTest.java, +        verify(harness.transcoder).transcode(eq(harness.decoded));, +        verify(harness.transcoder, never()).transcode(eq(harness.decoded));, +        when(harness.transcoder.transcode(eq(harness.decoded))).thenReturn(harness.transcoded);, +        when(harness.transcoder.transcode(eq(harness.decoded))).thenReturn(harness.transcoded);, +        verify(harness.decoded, never()).recycle();, +            return new ResourceRunner(key, width, height, cacheLoader, decoder, transcoder,, +++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/ResourceRunnerTest.java, +        verify(harness.transcoder).transcode(eq(harness.decoded));, +        verify(harness.transcoder, never()).transcode(eq(harness.decoded));, +        when(harness.transcoder.transcode(eq(harness.decoded))).thenReturn(harness.transcoded);, +        when(harness.transcoder.transcode(eq(harness.decoded))).thenReturn(harness.transcoded);, +        verify(harness.decoded, never()).recycle();, +            return new ResourceRunner(key, width, height, cacheLoader, decoder, transcoder,, +++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRunner.java, +            ResourceDecoder<File, Z> cacheDecoder, ResourceTranscoder<Z, R> transcoder,, +            SourceResourceRunner<?, Z, R> sourceRunner, ExecutorService diskCacheService,, +            DiskCacheStrategy diskCacheStrategy, ExecutorService resizeService, EngineJob job, Priority priority) {, +            transcoded = transcoder.transcode(fromCache);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/ResourceRunnerTest.java, +        verify(harness.transcoder).transcode(eq(harness.decoded));, +        verify(harness.transcoder, never()).transcode(eq(harness.decoded));, +        when(harness.transcoder.transcode(eq(harness.decoded))).thenReturn(harness.transcoded);, +        when(harness.transcoder.transcode(eq(harness.decoded))).thenReturn(harness.transcoded);, +        verify(harness.decoded, never()).recycle();, +            return new ResourceRunner(key, width, height, cacheLoader, decoder, transcoder,, +++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRunner.java, +            ResourceDecoder<File, Z> cacheDecoder, ResourceTranscoder<Z, R> transcoder,, +            SourceResourceRunner<?, Z, R> sourceRunner, ExecutorService diskCacheService,, +            DiskCacheStrategy diskCacheStrategy, ExecutorService resizeService, EngineJob job, Priority priority) {, +            transcoded = transcoder.transcode(fromCache);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRunnerFactory.java, +        return new ResourceRunner<Z, R>(key, width, height, cacheLoader, cacheDecoder, transcoder, sourceRunner,, +                diskCacheService, diskCacheStrategy, service, engineJob, priority);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/ResourceRunnerTest.java, +        verify(harness.transcoder).transcode(eq(harness.decoded));, +        verify(harness.transcoder, never()).transcode(eq(harness.decoded));, +        when(harness.transcoder.transcode(eq(harness.decoded))).thenReturn(harness.transcoded);, +        when(harness.transcoder.transcode(eq(harness.decoded))).thenReturn(harness.transcoded);, +        verify(harness.decoded, never()).recycle();, +            return new ResourceRunner(key, width, height, cacheLoader, decoder, transcoder,, +++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRunner.java, +            ResourceDecoder<File, Z> cacheDecoder, ResourceTranscoder<Z, R> transcoder,, +            SourceResourceRunner<?, Z, R> sourceRunner, ExecutorService diskCacheService,, +            DiskCacheStrategy diskCacheStrategy, ExecutorService resizeService, EngineJob job, Priority priority) {, +            transcoded = transcoder.transcode(fromCache);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRunnerFactory.java, +        return new ResourceRunner<Z, R>(key, width, height, cacheLoader, cacheDecoder, transcoder, sourceRunner,, +                diskCacheService, diskCacheStrategy, service, engineJob, priority);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java]
[+++ b/gradle.properties, +org.gradle.daemon=true, +org.gradle.configureondemand=true, +org.gradle.parallel=true, +, +TRUTH_VERSION=0.26, +++ b/gradle.properties, +org.gradle.daemon=true, +org.gradle.configureondemand=true, +org.gradle.parallel=true, +, +TRUTH_VERSION=0.26, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import static org.junit.Assume.assumeTrue;, +    // Most likely an instance of http://stackoverflow.com/q/991489/253468, +    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));, +    // Most likely an instance of http://stackoverflow.com/q/991489/253468, +    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));, +++ b/gradle.properties, +org.gradle.daemon=true, +org.gradle.configureondemand=true, +org.gradle.parallel=true, +, +TRUTH_VERSION=0.26, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import static org.junit.Assume.assumeTrue;, +    // Most likely an instance of http://stackoverflow.com/q/991489/253468, +    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));, +    // Most likely an instance of http://stackoverflow.com/q/991489/253468, +    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));, +++ b/integration/volley/build.gradle, +    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}", +++ b/gradle.properties, +org.gradle.daemon=true, +org.gradle.configureondemand=true, +org.gradle.parallel=true, +, +TRUTH_VERSION=0.26, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import static org.junit.Assume.assumeTrue;, +    // Most likely an instance of http://stackoverflow.com/q/991489/253468, +    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));, +    // Most likely an instance of http://stackoverflow.com/q/991489/253468, +    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));, +++ b/integration/volley/build.gradle, +    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}", +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +    return getFetcher(Headers.DEFAULT);, +++ b/gradle.properties, +org.gradle.daemon=true, +org.gradle.configureondemand=true, +org.gradle.parallel=true, +, +TRUTH_VERSION=0.26, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import static org.junit.Assume.assumeTrue;, +    // Most likely an instance of http://stackoverflow.com/q/991489/253468, +    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));, +    // Most likely an instance of http://stackoverflow.com/q/991489/253468, +    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));, +++ b/integration/volley/build.gradle, +    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}", +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +    return getFetcher(Headers.DEFAULT);, +++ b/library/build.gradle, +    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}", +++ b/gradle.properties, +org.gradle.daemon=true, +org.gradle.configureondemand=true, +org.gradle.parallel=true, +, +TRUTH_VERSION=0.26, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import static org.junit.Assume.assumeTrue;, +    // Most likely an instance of http://stackoverflow.com/q/991489/253468, +    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));, +    // Most likely an instance of http://stackoverflow.com/q/991489/253468, +    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));, +++ b/integration/volley/build.gradle, +    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}", +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +    return getFetcher(Headers.DEFAULT);, +++ b/library/build.gradle, +    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}", +++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java, +   * @param isFirstResource {@code true} if this exception is for the first resource to load., +   * @return {@code true} if the listener has handled updating the target for the given exception,, +   *         {@code false} to allow Glide's request to update the target., +   * @param isFirstResource   {@code true} if this is the first resource to in this load to be, +   *                          loaded into the target. For example when loading a thumbnail and a, +   *                          full-sized image, this will be {@code true} for the first image to, +   *                          load and {@code false} for the second., +   * @return {@code true} if the listener has handled setting the resource on the target,, +   *         {@code false} to allow Glide's request to update the target., +   *         Setting the resource includes handling animations, be sure to take that into account., +++ b/gradle.properties, +org.gradle.daemon=true, +org.gradle.configureondemand=true, +org.gradle.parallel=true, +]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/NullCacheDecoder.java, +package com.bumptech.glide.load.resource;, +, +import com.bumptech.glide.Resource;, +import com.bumptech.glide.load.ResourceDecoder;, +, +import java.io.IOException;, +import java.io.InputStream;, +, +public class NullCacheDecoder<Z> implements ResourceDecoder<InputStream, Z> {, +    private static final NullCacheDecoder NULL_DECODER = new NullCacheDecoder();, +, +    @SuppressWarnings("unchecked"), +    public static <Z> NullCacheDecoder<Z> get() {, +        return NULL_DECODER;, +    }, +, +    @Override, +    public Resource<Z> decode(InputStream source, int width, int height) throws IOException {, +        return null;, +    }, +, +    @Override, +    public String getId() {, +        return "";, +    }, +}, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullCacheDecoder.java, +package com.bumptech.glide.load.resource;, +, +import com.bumptech.glide.Resource;, +import com.bumptech.glide.load.ResourceDecoder;, +, +import java.io.IOException;, +import java.io.InputStream;, +, +public class NullCacheDecoder<Z> implements ResourceDecoder<InputStream, Z> {, +    private static final NullCacheDecoder NULL_DECODER = new NullCacheDecoder();, +, +    @SuppressWarnings("unchecked"), +    public static <Z> NullCacheDecoder<Z> get() {, +        return NULL_DECODER;, +    }, +, +    @Override, +    public Resource<Z> decode(InputStream source, int width, int height) throws IOException {, +        return null;, +    }, +, +    @Override, +    public String getId() {, +        return "";, +    }, +}, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifData.java, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import com.bumptech.glide.load.resource.gif.decoder.GifDecoder;, +import com.bumptech.glide.load.resource.gif.decoder.GifHeader;, +, +import java.util.ArrayList;, +import java.util.List;, +    private final BitmapPool bitmapPool;, +    private final GifHeader header;, +    private final byte[] data;, +    private String gifId;, +    private final List<GifDrawable> drawables = new ArrayList<GifDrawable>();, +    private Transformation<Bitmap> frameTransformation;, +    public GifData(Context context, BitmapPool bitmapPool, String gifId, GifHeader header, byte[] data) {, +        this.bitmapPool = bitmapPool;, +        this.header = header;, +        this.data = data;, +        this.gifId = gifId;, +    @SuppressWarnings("unchecked"), +        return frameTransformation != null ? frameTransformation : Transformation.NONE;, +    }, +, +    public void setFrameTransformation(Transformation<Bitmap> transformation) {, +        this.frameTransformation = transformation;, +        return data.length;, +        return data;, +        GifDecoder gifDecoder = new GifDecoder(bitmapPool);, +        gifDecoder.setData(gifId, header, data);, +        GifFrameManager frameManager = new GifFrameManager(context, getFrameTransformation());, +        GifDrawable result = new GifDrawable(gifDecoder, frameManager);, +        drawables.add(result);, +        return result;, +        for (GifDrawable drawable : drawables) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullCacheDecoder.java, +package com.bumptech.glide.load.resource;, +, +import com.bumptech.glide.Resource;, +import com.bumptech.glide.load.ResourceDecoder;, +, +import java.io.IOException;, +import java.io.InputStream;, +, +public class NullCacheDecoder<Z> implements ResourceDecoder<InputStream, Z> {, +    private static final NullCacheDecoder NULL_DECODER = new NullCacheDecoder();, +, +    @SuppressWarnings("unchecked")]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameManager.java, +        long targetTime = SystemClock.uptimeMillis() + decoder.getNextDelay();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameManager.java, +        long targetTime = SystemClock.uptimeMillis() + decoder.getNextDelay();, +++ b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java, +    private static ByteBuffer writeHeaderWithGceAndFrameDelay(short frameDelay) {, +        final int lzwMinCodeSize = 2;, +        ByteBuffer buffer = ByteBuffer.allocate(, +                GifBytesTestUtil.HEADER_LENGTH, +                + GifBytesTestUtil.GRAPHICS_CONTROL_EXTENSION_LENGTH, +                + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH, +                + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize), +        ).order(ByteOrder.LITTLE_ENDIAN);, +        GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);, +        GifBytesTestUtil.writeGraphicsControlExtension(buffer, frameDelay);, +        GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);, +        GifBytesTestUtil.writeFakeImageData(buffer, lzwMinCodeSize);, +        return buffer;, +    }, +, +    @Test, +    public void testCanParseFrameDelay() {, +        final short frameDelay = 50;, +        ByteBuffer buffer = writeHeaderWithGceAndFrameDelay(frameDelay);, +, +        parser.setData(buffer.array());, +        GifHeader header = parser.parseHeader();, +        GifFrame frame = header.frames.get(0);, +, +        // Convert delay in 100ths of a second to ms., +        assertEquals(frameDelay * 10, frame.delay);, +    }, +, +    @Test, +    public void testSetsDefaultFrameDelayIfFrameDelayIsZero() {, +        ByteBuffer buffer = writeHeaderWithGceAndFrameDelay((short) 0);, +, +        parser.setData(buffer.array());, +        GifHeader header = parser.parseHeader();, +        GifFrame frame = header.frames.get(0);, +, +        // Convert delay in 100ths of a second to ms., +        assertEquals(GifHeaderParser.DEFAULT_FRAME_DELAY * 10, frame.delay);, +    }, +, +    @Test, +    public void testSetsDefaultFrameDelayIfFrameDelayIsLessThanMinimum() {, +        final short frameDelay = GifHeaderParser.MIN_FRAME_DELAY - 1;, +        ByteBuffer buffer = writeHeaderWithGceAndFrameDelay(frameDelay);, +, +        parser.setData(buffer.array());, +        GifHeader header = parser.parseHeader();, +        GifFrame frame = header.frames.get(0);, +, +        // Convert delay in 100ths of a second to ms., +        assertEquals(GifHeaderParser.DEFAULT_FRAME_DELAY * 10, frame.delay);, +    }, +, +    @Test, +    public void testObeysFrameDelayIfFrameDelayIsAtMinimum() {, +        final short frameDelay = GifHeaderParser.MIN_FRAME_DELAY;, +        ByteBuffer buffer = writeHeaderWithGceAndFrameDelay(frameDelay);, +, +        parser.setData(buffer.array());, +        GifHeader header = parser.parseHeader();, +        GifFrame frame = header.frames.get(0);, +, +        // Convert delay in 100ths of a second to ms., +        assertEquals(frameDelay * 10, frame.delay);, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameManager.java, +        long targetTime = SystemClock.uptimeMillis() + decoder.getNextDelay();, +++ b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java, +    private static ByteBuffer writeHeaderWithGceAndFrameDelay(short frameDelay) {, +        final int lzwMinCodeSize = 2;, +        ByteBuffer buffer = ByteBuffer.allocate(, +                GifBytesTestUtil.HEADER_LENGTH, +                + GifBytesTestUtil.GRAPHICS_CONTROL_EXTENSION_LENGTH, +                + GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH, +                + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize), +        ).order(ByteOrder.LITTLE_ENDIAN);, +        GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);, +        GifBytesTestUtil.writeGraphicsControlExtension(buffer, frameDelay);, +        GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0);, +        GifBytesTestUtil.writeFakeImageData(buffer, lzwMinCodeSize);, +        return buffer;, +    }, +, +    @Test, +    public void testCanParseFrameDelay() {, +        final short frameDelay = 50;, +        ByteBuffer buffer = writeHeaderWithGceAndFrameDelay(frameDelay);, +, +        parser.setData(buffer.array());, +        GifHeader header = parser.parseHeader();, +        GifFrame frame = header.frames.get(0);, +, +        // Convert delay in 100ths of a second to ms., +        assertEquals(frameDelay * 10, frame.delay);]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +        .addSuperinterface(Cloneable.class), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +        .addSuperinterface(Cloneable.class), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java, +        .addSuperinterface(Cloneable.class)]
[+++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +        this.diskCacheStrategy = other.diskCacheStrategy;, +        this.isCacheable = other.isCacheable;, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +        this.diskCacheStrategy = other.diskCacheStrategy;, +        this.isCacheable = other.isCacheable;, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.model.stream.StreamByteArrayLoader;, +        register(byte[].class, InputStream.class, new StreamByteArrayLoader.Factory());, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +        this.diskCacheStrategy = other.diskCacheStrategy;, +        this.isCacheable = other.isCacheable;, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.model.stream.StreamByteArrayLoader;, +        register(byte[].class, InputStream.class, new StreamByteArrayLoader.Factory());, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +import com.bumptech.glide.load.Key;, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +import com.bumptech.glide.signature.ApplicationVersionSignature;, +import com.bumptech.glide.signature.MediaStoreSignature;, +import com.bumptech.glide.signature.StringSignature;, +        Key signature = new MediaStoreSignature(mimeType, dateModified, orientation);, +        return (DrawableTypeRequest<Uri>) loadFromMediaStore(uri), +                .signature(signature);, +     * @see com.bumptech.glide.signature.ApplicationVersionSignature, +     * @see com.bumptech.glide.GenericRequestBuilder#signature(com.bumptech.glide.load.Key), +        return (DrawableTypeRequest<Integer>) loadGeneric(resourceId), +                .signature(ApplicationVersionSignature.obtain(context));, +     * @deprecated Use {@link #load(byte[])} along with, +     * {@link com.bumptech.glide.GenericRequestBuilder#signature(com.bumptech.glide.load.Key)}} instead., +     *, +     * <p>, +     *     Note - This method does not cache results in either the disk cache or the memory cache., +     * </p>, +     *, +    @Deprecated, +        return (DrawableTypeRequest<byte[]>) loadGeneric(model), +                .signature(new StringSignature(id)), +                .diskCacheStrategy(DiskCacheStrategy.NONE), +                .skipMemoryCache(true /*skipMemoryCache*/);, +        return (DrawableTypeRequest<byte[]>) loadGeneric(model), +                .signature(new StringSignature(UUID.randomUUID().toString())), +                .diskCacheStrategy(DiskCacheStrategy.NONE), +                .skipMemoryCache(true /*skipMemoryCache*/);, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +        this.diskCacheStrategy = other.diskCacheStrategy;, +        this.isCacheable = other.isCacheable;, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.model.stream.StreamByteArrayLoader;, +        register(byte[].class, InputStream.class, new StreamByteArrayLoader.Factory());, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +import com.bumptech.glide.load.Key;, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +import com.bumptech.glide.signature.ApplicationVersionSignature;, +import com.bumptech.glide.signature.MediaStoreSignature;, +import com.bumptech.glide.signature.StringSignature;, +        Key signature = new MediaStoreSignature(mimeType, dateModified, orientation);, +        return (DrawableTypeRequest<Uri>) loadFromMediaStore(uri), +                .signature(signature);, +     * @see com.bumptech.glide.signature.ApplicationVersionSignature, +     * @see com.bumptech.glide.GenericRequestBuilder#signature(com.bumptech.glide.load.Key), +        return (DrawableTypeRequest<Integer>) loadGeneric(resourceId), +                .signature(ApplicationVersionSignature.obtain(context));, +     * @deprecated Use {@link #load(byte[])} along with, +     * {@link com.bumptech.glide.GenericRequestBuilder#signature(com.bumptech.glide.load.Key)}} instead., +     *, +     * <p>, +     *     Note - This method does not cache results in either the disk cache or the memory cache., +     * </p>, +     *, +    @Deprecated, +        return (DrawableTypeRequest<byte[]>) loadGeneric(model), +                .signature(new StringSignature(id)), +                .diskCacheStrategy(DiskCacheStrategy.NONE), +                .skipMemoryCache(true /*skipMemoryCache*/);, +        return (DrawableTypeRequest<byte[]>) loadGeneric(model), +                .signature(new StringSignature(UUID.randomUUID().toString())), +                .diskCacheStrategy(DiskCacheStrategy.NONE), +                .skipMemoryCache(true /*skipMemoryCache*/);, +++ b/library/src/main/java/com/bumptech/glide/load/model/stream/StreamByteArrayLoader.java, +import android.content.Context;, +import com.bumptech.glide.load.model.GenericLoaderFactory;, +import com.bumptech.glide.load.model.ModelLoader;, +import com.bumptech.glide.load.model.ModelLoaderFactory;, +    private final String id;, +        this("");, +    /**, +     * @deprecated Use {@link com.bumptech.glide.GenericRequestBuilder#signature(com.bumptech.glide.load.Key)}, +     * and the empty constructor instead., +     */, +    @Deprecated, +, +    /**, +     * Factory for {@link com.bumptech.glide.load.model.stream.StreamByteArrayLoader}., +     */, +    public static class Factory implements ModelLoaderFactory<byte[], InputStream> {, +, +        @Override, +        public ModelLoader<byte[], InputStream> build(Context context, GenericLoaderFactory factories) {, +            return new StreamByteArrayLoader();]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java]
[+++ b/library/custom_rules.xml, +            <zipgroupfileset dir="libs" includes="disklrucache*.jar,volley.jar" />]
[+++ b/build.gradle, +subprojects { project ->, +, +    afterEvaluate {, +        if (project.tasks.findByName('check')) {, +            check.dependsOn('checkstyle'), +        }, +    }, +++ b/build.gradle, +subprojects { project ->, +, +    afterEvaluate {, +        if (project.tasks.findByName('check')) {, +            check.dependsOn('checkstyle'), +        }, +    }, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +/**, + * An {@link DataFetcher} that uses an {@link com.squareup.okhttp.OkHttpClient} to load an {@link InputStream} for, + * an {@link GlideUrl}., + */, +++ b/build.gradle, +subprojects { project ->, +, +    afterEvaluate {, +        if (project.tasks.findByName('check')) {, +            check.dependsOn('checkstyle'), +        }, +    }, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +/**, + * An {@link DataFetcher} that uses an {@link com.squareup.okhttp.OkHttpClient} to load an {@link InputStream} for, + * an {@link GlideUrl}., + */, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/api/Api.java]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoder.java, +            ParcelFileDescriptor fileDescriptor = source.getFileDescriptor();, +            if (fileDescriptor != null) {, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoder.java, +            ParcelFileDescriptor fileDescriptor = source.getFileDescriptor();, +            if (fileDescriptor != null) {, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java, +    private static final DefaultFactory DEFAULT_FACTORY = new DefaultFactory();, +    private MediaMetadataRetrieverFactory factory;, +, +    interface MediaMetadataRetrieverFactory {, +        public MediaMetadataRetriever build();, +    }, +, +    public VideoBitmapDecoder() {, +        this(DEFAULT_FACTORY);, +    }, +, +, +    VideoBitmapDecoder(MediaMetadataRetrieverFactory factory) {, +        this.factory = factory;, +    }, +, +        MediaMetadataRetriever mediaMetadataRetriever = factory.build();, +        return "VideoBitmapDecoder.com.bumptech.glide.load.resource.bitmap";, +    }, +, +    private static class DefaultFactory implements MediaMetadataRetrieverFactory {, +        @Override, +        public MediaMetadataRetriever build() {, +            return new MediaMetadataRetriever();, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoder.java, +            ParcelFileDescriptor fileDescriptor = source.getFileDescriptor();, +            if (fileDescriptor != null) {, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java, +    private static final DefaultFactory DEFAULT_FACTORY = new DefaultFactory();, +    private MediaMetadataRetrieverFactory factory;, +, +    interface MediaMetadataRetrieverFactory {, +        public MediaMetadataRetriever build();, +    }, +, +    public VideoBitmapDecoder() {, +        this(DEFAULT_FACTORY);, +    }, +, +, +    VideoBitmapDecoder(MediaMetadataRetrieverFactory factory) {, +        this.factory = factory;, +    }, +, +        MediaMetadataRetriever mediaMetadataRetriever = factory.build();, +        return "VideoBitmapDecoder.com.bumptech.glide.load.resource.bitmap";, +    }, +, +    private static class DefaultFactory implements MediaMetadataRetrieverFactory {, +        @Override, +        public MediaMetadataRetriever build() {, +            return new MediaMetadataRetriever();, +        }, +++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoderTest.java, +    public void testDoesNotTryToDecodeNullFileDescriptor() throws IOException {, +        when(harness.wrapper.getStream()).thenReturn(null);, +        when(harness.wrapper.getFileDescriptor()).thenReturn(null);, +, +        harness.decoder.decode(harness.wrapper, 100, 102);, +, +        verify(harness.fileDescriptorDecoder, never()).decode(any(ParcelFileDescriptor.class), anyInt(), anyInt());, +    }, +, +    @Test, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoder.java, +            ParcelFileDescriptor fileDescriptor = source.getFileDescriptor();, +            if (fileDescriptor != null) {, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java, +    private static final DefaultFactory DEFAULT_FACTORY = new DefaultFactory();, +    private MediaMetadataRetrieverFactory factory;, +, +    interface MediaMetadataRetrieverFactory {, +        public MediaMetadataRetriever build();, +    }, +, +    public VideoBitmapDecoder() {, +        this(DEFAULT_FACTORY);, +    }, +, +, +    VideoBitmapDecoder(MediaMetadataRetrieverFactory factory) {, +        this.factory = factory;, +    }, +, +        MediaMetadataRetriever mediaMetadataRetriever = factory.build();, +        return "VideoBitmapDecoder.com.bumptech.glide.load.resource.bitmap";, +    }, +]
[+++ b/.travis.yml, +language: android, +android:, +  components:, +    - build-tools-19.1.0, +, +script: 'travis_retry ./gradlew clean build', +++ b/.travis.yml, +language: android, +android:, +  components:, +    - build-tools-19.1.0, +, +script: 'travis_retry ./gradlew clean build', +++ b/install_maven_dependencies/install-android-deps.sh, +#!/bin/sh, +# This script installs the necessary Android dependencies to compile Glide and run, +# the test suite., +# , +# Pre-requisites: , +# Using the android sdk tool, under Android 4.4.2 (API 19), install:, +#   SDK Platform, +#   Glass Development Kit Preview, +# Also using the android sdk tool, under Android 4.4.0 (API 14), install:, +#   SDK Platform, +, +git clone https://github.com/mosabua/maven-android-sdk-deployer.git, +cd maven-android-sdk-deployer , +mvn clean install -N && cd platforms && mvn clean install -N && cd android-19 && mvn clean install || {, +  echo 'Failed to install 4.4 SDK, install relevant packages in android SDK first';, +  exit 1; , +}, +cd ../.., +mvn clean install -N && cd platforms && mvn clean install -N && cd android-14 && mvn clean install || {, +  echo 'Failed to install 4.0 SDK, install relevant packages in android SDK first';, +  exit 1;, +}, +cd ../.., +mvn clean install -N && cd extras && mvn clean install -N && cd compatibility-v4 && mvn clean install || {, +  echo 'Failed to install android-support-v4, install support library in android SDK first';, +  exit 1;, +}, +cd ../../.., +rm -rf maven-android-sdk-deployer, +++ b/.travis.yml, +language: android, +android:, +  components:, +    - build-tools-19.1.0, +, +script: 'travis_retry ./gradlew clean build', +++ b/install_maven_dependencies/install-android-deps.sh, +#!/bin/sh, +# This script installs the necessary Android dependencies to compile Glide and run, +# the test suite., +# , +# Pre-requisites: , +# Using the android sdk tool, under Android 4.4.2 (API 19), install:, +#   SDK Platform, +#   Glass Development Kit Preview, +# Also using the android sdk tool, under Android 4.4.0 (API 14), install:, +#   SDK Platform, +, +git clone https://github.com/mosabua/maven-android-sdk-deployer.git, +cd maven-android-sdk-deployer , +mvn clean install -N && cd platforms && mvn clean install -N && cd android-19 && mvn clean install || {, +  echo 'Failed to install 4.4 SDK, install relevant packages in android SDK first';, +  exit 1; , +}, +cd ../.., +mvn clean install -N && cd platforms && mvn clean install -N && cd android-14 && mvn clean install || {, +  echo 'Failed to install 4.0 SDK, install relevant packages in android SDK first';, +  exit 1;, +}, +cd ../.., +mvn clean install -N && cd extras && mvn clean install -N && cd compatibility-v4 && mvn clean install || {, +  echo 'Failed to install android-support-v4, install support library in android SDK first';, +  exit 1;, +}, +cd ../../.., +rm -rf maven-android-sdk-deployer, +++ /dev/null]
[+++ b/annotation/gradle.properties]
[+++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +import android.annotation.TargetApi;, +import android.content.UriMatcher;, +import android.os.Build;, +import android.provider.ContactsContract;, +  /**, +   * A lookup uri (e.g. content://com.android.contacts/contacts/lookup/3570i61d948d30808e537), +   */, +  private static final int ID_CONTACTS_LOOKUP = 1;, +  /**, +   * A contact thumbnail uri (e.g. content://com.android.contacts/contacts/38/photo), +   */, +  private static final int ID_CONTACTS_THUMBNAIL = 2;, +  /**, +   * A contact uri (e.g. content://com.android.contacts/contacts/38), +   */, +  private static final int ID_CONTACTS_CONTACT = 3;, +  /**, +   * A contact display photo (high resolution) uri, +   * (e.g. content://com.android.contacts/5/display_photo), +   */, +  private static final int ID_CONTACTS_PHOTO = 4;, +  /**, +   * Match the incoming Uri for special cases which we can handle nicely., +   */, +  private static final UriMatcher URI_MATCHER;, +, +  static {, +    URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);, +    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/lookup/*/#", ID_CONTACTS_LOOKUP);, +    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/lookup/*", ID_CONTACTS_LOOKUP);, +    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/#/photo", ID_CONTACTS_THUMBNAIL);, +    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/#", ID_CONTACTS_CONTACT);, +    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/#/display_photo", ID_CONTACTS_PHOTO);, +  }, +, +    InputStream inputStream = loadResourceFromUri(uri, contentResolver);, +      throw new FileNotFoundException("InputStream is null for " + uri);, +, +  private InputStream loadResourceFromUri(Uri uri, ContentResolver contentResolver), +      throws FileNotFoundException {, +    switch (URI_MATCHER.match(uri)) {, +      case ID_CONTACTS_CONTACT:, +        return openContactPhotoInputStream(contentResolver, uri);, +      case ID_CONTACTS_LOOKUP:, +        // If it was a Lookup uri then resolve it first, then continue loading the contact uri., +        uri = ContactsContract.Contacts.lookupContact(contentResolver, uri);, +        if (uri == null) {, +          throw new FileNotFoundException("Contact cannot be found");, +        }, +        return openContactPhotoInputStream(contentResolver, uri);, +      case ID_CONTACTS_THUMBNAIL:, +      case ID_CONTACTS_PHOTO:, +      case UriMatcher.NO_MATCH:, +      default:, +        return contentResolver.openInputStream(uri);, +    }, +  }, +, +  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH), +  private InputStream openContactPhotoInputStream(ContentResolver contentResolver, Uri contactUri) {, +    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {, +      return ContactsContract.Contacts.openContactPhotoInputStream(contentResolver, contactUri);, +    } else {, +      return ContactsContract.Contacts.openContactPhotoInputStream(contentResolver, contactUri,, +          true /*preferHighres*/);, +    }, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +import android.annotation.TargetApi;, +import android.content.UriMatcher;, +import android.os.Build;, +import android.provider.ContactsContract;, +  /**, +   * A lookup uri (e.g. content://com.android.contacts/contacts/lookup/3570i61d948d30808e537), +   */, +  private static final int ID_CONTACTS_LOOKUP = 1;, +  /**, +   * A contact thumbnail uri (e.g. content://com.android.contacts/contacts/38/photo), +   */, +  private static final int ID_CONTACTS_THUMBNAIL = 2;, +  /**, +   * A contact uri (e.g. content://com.android.contacts/contacts/38), +   */, +  private static final int ID_CONTACTS_CONTACT = 3;, +  /**, +   * A contact display photo (high resolution) uri, +   * (e.g. content://com.android.contacts/5/display_photo), +   */, +  private static final int ID_CONTACTS_PHOTO = 4;, +  /**, +   * Match the incoming Uri for special cases which we can handle nicely., +   */, +  private static final UriMatcher URI_MATCHER;, +, +  static {, +    URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);, +    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/lookup/*/#", ID_CONTACTS_LOOKUP);, +    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/lookup/*", ID_CONTACTS_LOOKUP);]
[+++ b/.gitignore, +samples/flickr/.idea/*, +samples/flickr/gen/**/*, +samples/flickr/out/**/*, +samples/flickr/local.properties, +++ b/.gitignore, +samples/flickr/.idea/*, +samples/flickr/gen/**/*, +samples/flickr/out/**/*, +samples/flickr/local.properties, +++ b/samples/flickr/AndroidManifest.xml, +<?xml version="1.0" encoding="utf-8"?>, +<manifest xmlns:android="http://schemas.android.com/apk/res/android", +      package="com.bumptech.flickr", +      android:versionCode="1", +      android:versionName="1.0">, +    <application android:label="@string/app_name" android:icon="@drawable/ic_launcher", +      android:hardwareAccelerated="true">, +, +        <activity android:name="MyActivity", +                  android:label="@string/app_name", +          android:launchMode="singleTask", +          android:screenOrientation="portrait">, +            <intent-filter>, +                <action android:name="android.intent.action.MAIN" />, +                <category android:name="android.intent.category.LAUNCHER" />, +            </intent-filter>, +        </activity>, +    </application>, +, +  <uses-permission android:name="android.permission.INTERNET" />, +  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />, +  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="16" />, +</manifest>, +++ b/.gitignore, +samples/flickr/.idea/*, +samples/flickr/gen/**/*, +samples/flickr/out/**/*, +samples/flickr/local.properties, +++ b/samples/flickr/AndroidManifest.xml, +<?xml version="1.0" encoding="utf-8"?>, +<manifest xmlns:android="http://schemas.android.com/apk/res/android", +      package="com.bumptech.flickr", +      android:versionCode="1", +      android:versionName="1.0">, +    <application android:label="@string/app_name" android:icon="@drawable/ic_launcher", +      android:hardwareAccelerated="true">, +, +        <activity android:name="MyActivity", +                  android:label="@string/app_name", +          android:launchMode="singleTask", +          android:screenOrientation="portrait">, +            <intent-filter>, +                <action android:name="android.intent.action.MAIN" />, +                <category android:name="android.intent.category.LAUNCHER" />, +            </intent-filter>, +        </activity>, +    </application>, +, +  <uses-permission android:name="android.permission.INTERNET" />, +  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />, +  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="16" />, +</manifest>, +++ b/samples/flickr/ant.properties, +# This file is used to override default values used by the Ant build system., +#, +# This file must be checked into Version Control Systems, as it is, +# integral to the build system of your project., +, +# This file is only used by the Ant script., +, +# You can use this to override default values such as, +#  'source.dir' for the location of your java source folder and, +#  'out.dir' for the location of your output folder., +, +# You can also use it define how the release builds are signed by declaring, +# the following properties:, +#  'key.store' for the location of your keystore and, +#  'key.alias' for the name of the key to use., +# The password will be asked during the build when you use the 'release' target., +, +++ b/.gitignore, +samples/flickr/.idea/*, +samples/flickr/gen/**/*, +samples/flickr/out/**/*, +samples/flickr/local.properties, +++ b/samples/flickr/AndroidManifest.xml, +<?xml version="1.0" encoding="utf-8"?>, +<manifest xmlns:android="http://schemas.android.com/apk/res/android", +      package="com.bumptech.flickr", +      android:versionCode="1", +      android:versionName="1.0">, +    <application android:label="@string/app_name" android:icon="@drawable/ic_launcher", +      android:hardwareAccelerated="true">, +, +        <activity android:name="MyActivity", +                  android:label="@string/app_name", +          android:launchMode="singleTask", +          android:screenOrientation="portrait">, +            <intent-filter>]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +    @Test, +    public void testCanGetCurrentMaxSize() {, +        assertEquals(MAX_SIZE, pool.getMaxSize());, +    }, +, +    @Test, +    public void testMaxSizeChangesAfterSizeMultiplier() {, +        pool.setSizeMultiplier(2);, +        assertEquals(2 * MAX_SIZE, pool.getMaxSize());, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +    @Test, +    public void testCanGetCurrentMaxSize() {, +        assertEquals(MAX_SIZE, pool.getMaxSize());, +    }, +, +    @Test, +    public void testMaxSizeChangesAfterSizeMultiplier() {, +        pool.setSizeMultiplier(2);, +        assertEquals(2 * MAX_SIZE, pool.getMaxSize());, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java, +    @Test, +    public void testGetMaxSizeReturnsCurrentMaxSizeOfCache() {, +        assertEquals(SIZE, cache.getMaxSize());, +    }, +, +    @Test, +    public void testGetMaxSizeChangesIfMaxSizeChanges() {, +        int multiplier = 2;, +        cache.setSizeMultiplier(multiplier);, +, +        assertEquals(SIZE * multiplier, cache.getMaxSize());, +    }, +, +    @Test, +    public void getCurrentSizeReturnsZeroForEmptyCache() {, +        assertEquals(0, cache.getCurrentSize());, +    }, +, +    @Test, +    public void testGetCurrentSizeIncreasesAsSizeIncreases() {, +        cache.put(getKey(), new Object());, +        assertEquals(1, cache.getCurrentSize());, +        cache.put(getKey(), new Object());, +        assertEquals(2, cache.getCurrentSize());, +    }, +, +    @Test, +    public void testGetCurrentSizeDoesNotChangeWhenSizeMultiplierChangesIfNoItemsAreEvicted() {, +        cache.put(getKey(), new Object());, +        assertEquals(1, cache.getCurrentSize());, +        cache.setSizeMultiplier(2);, +        assertEquals(1, cache.getCurrentSize());, +    }, +, +    @Test, +    public void testGetCurrentSizeChangesIfItemsAreEvictedWhenSizeMultiplierChanges() {, +        for (int i = 0; i < SIZE; i++) {, +            cache.put(getKey(), new Object());, +        }, +        assertEquals(SIZE, cache.getCurrentSize());, +        cache.setSizeMultiplier(0.5f);, +        assertEquals(SIZE / 2, cache.getCurrentSize());, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +    @Test, +    public void testCanGetCurrentMaxSize() {, +        assertEquals(MAX_SIZE, pool.getMaxSize());, +    }, +, +    @Test, +    public void testMaxSizeChangesAfterSizeMultiplier() {, +        pool.setSizeMultiplier(2);, +        assertEquals(2 * MAX_SIZE, pool.getMaxSize());, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java, +    @Test, +    public void testGetMaxSizeReturnsCurrentMaxSizeOfCache() {, +        assertEquals(SIZE, cache.getMaxSize());, +    }, +, +    @Test, +    public void testGetMaxSizeChangesIfMaxSizeChanges() {, +        int multiplier = 2;, +        cache.setSizeMultiplier(multiplier);, +, +        assertEquals(SIZE * multiplier, cache.getMaxSize());, +    }, +, +    @Test, +    public void getCurrentSizeReturnsZeroForEmptyCache() {, +        assertEquals(0, cache.getCurrentSize());, +    }, +]
[+++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.manager.RequestManagerTreeNode;, +        RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);, +        requestManager = new RequestManager(getContext(), lifecycle, treeNode);, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.manager.RequestManagerTreeNode;, +        RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);, +        requestManager = new RequestManager(getContext(), lifecycle, treeNode);, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java, +import com.bumptech.glide.manager.RequestManagerTreeNode;, +    private RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);, +        manager =, +            new RequestManager(Robolectric.application, lifecycle, treeNode, requestTracker, factory);, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.manager.RequestManagerTreeNode;, +        RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);, +        requestManager = new RequestManager(getContext(), lifecycle, treeNode);, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java, +import com.bumptech.glide.manager.RequestManagerTreeNode;, +    private RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);, +        manager =, +            new RequestManager(Robolectric.application, lifecycle, treeNode, requestTracker, factory);, +++ b/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java, +            assertTrue(harness.hasFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG));, +            harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, requestManager);, +            harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, null);, +            harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, null);, +        assertEquals(RequestManagerRetriever.class.getPackage().getName(), RequestManagerRetriever.FRAGMENT_TAG);, +            return null != controller.get(), +                .getFragmentManager(), +                .findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG);, +                    .add(fragment, RequestManagerRetriever.FRAGMENT_TAG), +            return controller.get().getSupportFragmentManager().findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG), +                    .add(fragment, RequestManagerRetriever.FRAGMENT_TAG), +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.manager.RequestManagerTreeNode;, +        RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);, +        requestManager = new RequestManager(getContext(), lifecycle, treeNode);, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java, +import com.bumptech.glide.manager.RequestManagerTreeNode;, +    private RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);, +        manager =, +            new RequestManager(Robolectric.application, lifecycle, treeNode, requestTracker, factory);, +++ b/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java, +            assertTrue(harness.hasFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG));, +            harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, requestManager);, +            harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, null);, +            harness.addFragmentWithTag(RequestManagerRetriever.FRAGMENT_TAG, null);, +        assertEquals(RequestManagerRetriever.class.getPackage().getName(), RequestManagerRetriever.FRAGMENT_TAG);, +            return null != controller.get(), +                .getFragmentManager(), +                .findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG);, +                    .add(fragment, RequestManagerRetriever.FRAGMENT_TAG), +            return controller.get().getSupportFragmentManager().findFragmentByTag(RequestManagerRetriever.FRAGMENT_TAG), +                    .add(fragment, RequestManagerRetriever.FRAGMENT_TAG), +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +import com.bumptech.glide.manager.RequestManagerTreeNode;, +    private final RequestManagerTreeNode treeNode;, +    public RequestManager(Context context, Lifecycle lifecycle, RequestManagerTreeNode treeNode) {, +        this(context, lifecycle, treeNode, new RequestTracker(), new ConnectivityMonitorFactory());, +    RequestManager(Context context, final Lifecycle lifecycle, RequestManagerTreeNode treeNode,, +            RequestTracker requestTracker, ConnectivityMonitorFactory factory) {, +        this.treeNode = treeNode;, +     * Performs {@link #pauseRequests()} recursively for all managers that are contextually descendant, +     * to this manager based on the Activity/Fragment hierarchy:, +     *, +     * <ul>, +     * <li>When pausing on an Activity all attached fragments will also get paused., +     * <li>When pausing on an attached Fragment all descendant fragments will also get paused., +     * <li>When pausing on a detached Fragment or the application context only the current RequestManager is paused., +     * </ul>, +     *, +     * <p>Note, on pre-Jelly Bean MR1 calling pause on a Fragment will not cause child fragments to pause, in this, +     * case either call pause on the Activity or use a support Fragment., +     */, +    public void pauseRequestsRecursive() {, +        Util.assertMainThread();, +        pauseRequests();, +        for (RequestManager requestManager : treeNode.getDescendants()) {, +            requestManager.pauseRequests();, +        }, +    }, +, +    /**, +     * Performs {@link #resumeRequests()} recursively for all managers that are contextually descendant, +     * to this manager based on the Activity/Fragment hierarchy. The hierarchical semantics are identical as for, +     * {@link #pauseRequestsRecursive()}., +     */, +    public void resumeRequestsRecursive() {, +        Util.assertMainThread();, +        resumeRequests();, +        for (RequestManager requestManager : treeNode.getDescendants()) {, +            requestManager.resumeRequests();, +        }, +    }, +, +    /**, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.manager.RequestManagerTreeNode;, +        RequestManagerTreeNode treeNode = mock(RequestManagerTreeNode.class);]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java, +import android.support.v7.view.ContextThemeWrapper;, +        return loadDrawableV7(context, id, theme);, +  private static Drawable loadDrawableV7(Context context, @DrawableRes int id,, +      @Nullable Theme theme) {, +    Context resourceContext = theme != null ? new ContextThemeWrapper(context, theme) : context;, +    return AppCompatResources.getDrawable(resourceContext, id);]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +    gifDrawable.stop();, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +    gifDrawable.stop();, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java, +import android.support.test.InstrumentationRegistry;, +import com.bumptech.glide.RequestManager;, +          new ConcurrencyHelper().runOnMainThread(new Runnable() {, +            @Override, +            public void run() {, +              RequestManager requestManager =, +                  Glide.with(InstrumentationRegistry.getTargetContext());, +              requestManager.onStop();, +              requestManager.onDestroy();, +            }, +          });, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +    gifDrawable.stop();, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java, +import android.support.test.InstrumentationRegistry;, +import com.bumptech.glide.RequestManager;, +          new ConcurrencyHelper().runOnMainThread(new Runnable() {, +            @Override, +            public void run() {, +              RequestManager requestManager =, +                  Glide.with(InstrumentationRegistry.getTargetContext());, +              requestManager.onStop();, +              requestManager.onDestroy();, +            }, +          });, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +      glide.getContext(), +          .getApplicationContext(), +          .unregisterComponentCallbacks(glide);]
[+++ b/library/src/androidTest/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java, +package com.bumptech.glide.util;, +, +import org.junit.After;, +import org.junit.Before;, +import org.junit.Test;, +, +import java.io.IOException;, +import java.io.InputStream;, +import java.net.SocketTimeoutException;, +, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertNull;, +import static org.junit.Assert.assertTrue;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.anyLong;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, +public class ExceptionCatchingInputStreamTest {, +, +    private InputStream wrapped;, +    private ExceptionCatchingInputStream is;, +, +    @Before, +    public void setUp() throws Exception {, +        wrapped = mock(InputStream.class);, +        is = new ExceptionCatchingInputStream();, +        is.setInputStream(wrapped);, +    }, +, +    @After, +    public void tearDown() {, +        ExceptionCatchingInputStream.clearQueue();, +    }, +, +    @Test, +    public void testReturnsWrappedAvailable() throws IOException {, +        when(wrapped.available()).thenReturn(25);, +        assertEquals(25, is.available());, +    }, +, +    @Test, +    public void testCallsCloseOnWrapped() throws IOException {, +        is.close();, +        verify(wrapped).close();, +    }, +, +    @Test, +    public void testCallsMarkOnWrapped() {, +        int toMark = 50;, +        is.mark(toMark);, +        verify(wrapped).mark(eq(toMark));, +    }, +, +    @Test, +    public void testReturnsWrappedMarkSupported() {, +        when(wrapped.markSupported()).thenReturn(true);, +        assertTrue(is.markSupported());, +    }, +, +    @Test, +    public void testCallsReadByteArrayOnWrapped() throws IOException {, +        byte[] buffer = new byte[100];, +        when(wrapped.read(eq(buffer))).thenReturn(buffer.length);, +        assertEquals(buffer.length, is.read(buffer));, +    }, +, +    @Test, +    public void testCallsReadArrayWithOffsetAndCountOnWrapped() throws IOException {, +        int offset = 5;, +        int count = 100;, +        byte[] buffer = new byte[105];, +, +        when(wrapped.read(eq(buffer), eq(offset), eq(count))).thenReturn(count);, +        assertEquals(count, is.read(buffer, offset, count));, +    }, +, +    @Test, +    public void testCallsReadOnWrapped() throws IOException {, +        when(wrapped.read()).thenReturn(1);, +        assertEquals(1, is.read());, +    }, +, +    @Test, +    public void testCallsResetOnWrapped() throws IOException {, +        is.reset();, +        verify(wrapped).reset();, +    }, +, +    @Test, +    public void testCallsSkipOnWrapped() throws IOException {, +        long toSkip = 67;, +        long expected = 55;, +        when(wrapped.skip(eq(toSkip))).thenReturn(expected);, +        assertEquals(expected, is.skip(toSkip));, +    }]
[+++ b/.idea/codeStyleSettings.xml, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MAJOR=3, +VERSION_MINOR=6, +SUPPORT_V4_VERSION=19.1.0, +SUPPORT_V7_VERSION=19.1.0, +# TODO: Upgrade to latest version of Volley when we compile with Java 7., +VOLLEY_VERSION=1.0.8, +ANDROID_GRADLE_VERSION=1.0.0, +ROBOLECTRIC_GRADLE_VERSION=0.14.0, +ROBOLECTRIC_VERSION=2.4, +MOCKWEBSERVER_VERSION=1.6.0, +COMPILE_SDK_VERSION=19, +BUILD_TOOLS_VERSION=19.1.0, +TARGET_SDK_VERSION=19, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import com.squareup.okhttp.Response;, +import com.squareup.okhttp.ResponseBody;, +    private ResponseBody responseBody;, +        Response response = client.newCall(request).execute();, +        responseBody = response.body();, +        if (!response.isSuccessful()) {, +            throw new IOException("Request failed with code: " + response.code());, +        }, +        stream = responseBody.byteStream();, +            if (stream != null) {, +            }, +        if (responseBody != null) {, +            try {, +                responseBody.close();, +            } catch (IOException e) {, +                // Ignored., +            }, +        }]
[+++ /dev/null, +++ /dev/null, +++ b/src/com/bumptech/photos/view/ImagePresenter.java, +/*, + * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved., + */, +, +package com.bumptech.photos.view;, +, +import android.graphics.drawable.Drawable;, +import android.widget.ImageView;, +import com.bumptech.photos.util.Log;, +import com.bumptech.photos.view.assetpath.AssetPathConverter;, +import com.bumptech.photos.view.loader.ImageLoader;, +, +import java.lang.ref.WeakReference;, +, +/**, + * Created with IntelliJ IDEA., + * User: sam, + * Date: 12/25/12, + * Time: 10:05 PM, + * To change this template use File | Settings | File Templates., + */, +public class ImagePresenter<T> {, +    private int height = 0;, +    private int width = 0;, +, +    private Drawable placeholderDrawable;, +    private ImageSetCallback imageSetCallback;, +, +    private T currentModel;, +    private int currentCount;, +, +    private boolean isImageSet;, +    protected final ImageView imageView;, +, +    private final AssetPathConverter<T> assetIdToPath;, +    private final ImageLoader imageLoader;, +    private AssetPresenterCoordinator coordinator;, +    final Runnable getDimens = new Runnable() {, +        @Override, +        public void run() {, +            width = imageView.getWidth();, +            height = imageView.getHeight();, +            Log.d("AP: getDimens run width=" + width + " height=" + height);, +            if (pendingLoad != null) {, +                if (width != 0 && height != 0) {, +                    imageView.post(pendingLoad);, +                    pendingLoad = null;, +                } else {, +                    imageView.postDelayed(getDimens, 50);, +                }, +            }, +        }, +    };, +    private Runnable pendingLoad = null;, +, +    public interface AssetPresenterCoordinator<T> {, +        public boolean canSetImage(ImagePresenter<T> presenter);, +        public boolean canSetPlaceholder(ImagePresenter<T> presenter);, +    }, +, +    public ImagePresenter(final ImageView imageView, AssetPathConverter<T> assetIdToPath, final ImageLoader imageLoader) {, +        this.imageView = imageView;, +        this.assetIdToPath = assetIdToPath;, +        this.imageLoader = imageLoader;, +    }, +, +    public void setCoordinator(AssetPresenterCoordinator<T> controller) {, +        this.coordinator = controller;, +    }, +, +    public void setPlaceholderDrawable(Drawable placeholderDrawable) {, +        this.placeholderDrawable = placeholderDrawable;, +    }, +, +    public void setPlaceholderResource(int resourceId) {, +        this.placeholderDrawable = imageView.getResources().getDrawable(resourceId);, +    }, +, +    public void setOnImageSetCallback(ImageSetCallback cb) {, +        this.imageSetCallback = cb;, +    }, +, +    public void setAssetModel(final T model) {, +        if (model == null || model.equals(currentModel)) return;, +, +        final int loadCount = ++currentCount;, +        currentModel = model;, +        isImageSet = false;, +, +        assetIdToPath.fetchPath(model, new PathReadyCallback(this, loadCount));, +, +        if (!isImageSet()) {, +            resetPlaceHolder();, +        }, +    }, +, +    public void onPathReady(final String path, final int loadCount) {]
[+++ b/gradle.properties, +VERSION_NAME=4.10.0-SNAPSHOT, +VERSION_MINOR=10]
[+++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import com.bumptech.glide.load.model.ImageVideoWrapper;, +import com.bumptech.glide.request.ViewPropertyAnimation;, +    public BitmapRequestBuilder<ModelType, TranscodeType> animate(ViewPropertyAnimation.Animator animator) {, +        super.animate(animator);, +        return this;, +    }, +, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import com.bumptech.glide.load.model.ImageVideoWrapper;, +import com.bumptech.glide.request.ViewPropertyAnimation;, +    public BitmapRequestBuilder<ModelType, TranscodeType> animate(ViewPropertyAnimation.Animator animator) {, +        super.animate(animator);, +        return this;, +    }, +, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.request.DrawableCrossFadeViewAnimation;, +import com.bumptech.glide.request.ViewPropertyAnimation;, +    private final Context context;, +        this.context = context;, +    public DrawableRequestBuilder<ModelType> crossFade() {, +        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory());, +        return this;, +    }, +, +    public DrawableRequestBuilder<ModelType> crossFade(int duration) {, +        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory(duration));, +        return this;, +    }, +, +    public DrawableRequestBuilder<ModelType> crossFade(Animation animation, int duration) {, +        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory(animation, duration));, +        return this;, +    }, +, +    public DrawableRequestBuilder<ModelType> crossFade(int animationId, int duration) {, +        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory(context, animationId, duration));, +        return this;, +    }, +, +    @Override, +    public DrawableRequestBuilder<ModelType> animate(ViewPropertyAnimation.Animator animator) {, +        super.animate(animator);, +        return this;, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import com.bumptech.glide.load.model.ImageVideoWrapper;, +import com.bumptech.glide.request.ViewPropertyAnimation;, +    public BitmapRequestBuilder<ModelType, TranscodeType> animate(ViewPropertyAnimation.Animator animator) {, +        super.animate(animator);, +        return this;, +    }, +, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.request.DrawableCrossFadeViewAnimation;, +import com.bumptech.glide.request.ViewPropertyAnimation;, +    private final Context context;, +        this.context = context;, +    public DrawableRequestBuilder<ModelType> crossFade() {, +        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory());, +        return this;, +    }, +, +    public DrawableRequestBuilder<ModelType> crossFade(int duration) {, +        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory(duration));, +        return this;, +    }, +, +    public DrawableRequestBuilder<ModelType> crossFade(Animation animation, int duration) {, +        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory(animation, duration));, +        return this;, +    }, +, +    public DrawableRequestBuilder<ModelType> crossFade(int animationId, int duration) {, +        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory(context, animationId, duration));, +        return this;, +    }, +, +    @Override, +    public DrawableRequestBuilder<ModelType> animate(ViewPropertyAnimation.Animator animator) {, +        super.animate(animator);, +        return this;, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +import android.view.ViewPropertyAnimator;, +import com.bumptech.glide.request.GenericRequest;, +import com.bumptech.glide.request.GlideAnimationFactory;, +import com.bumptech.glide.request.NoAnimation;, +import com.bumptech.glide.request.ThumbnailRequestCoordinator;, +import com.bumptech.glide.request.ViewAnimation;, +import com.bumptech.glide.request.ViewPropertyAnimation;]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java, +            new EngineResource<>(, +                ref.resource,, +                /*isMemoryCacheable=*/ true,, +                /*isRecyclable=*/ false,, +                ref.key,, +                listener);, +          referent.isMemoryCacheable() && isActiveResourceRetentionAllowed, +      isCacheable = referent.isMemoryCacheable();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java, +            new EngineResource<>(, +                ref.resource,, +                /*isMemoryCacheable=*/ true,, +                /*isRecyclable=*/ false,, +                ref.key,, +                listener);, +          referent.isMemoryCacheable() && isActiveResourceRetentionAllowed, +      isCacheable = referent.isMemoryCacheable();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +import com.bumptech.glide.load.engine.EngineResource.ResourceListener;, +              diskCacheExecutor,, +              sourceExecutor,, +              sourceUnlimitedExecutor,, +              animationExecutor,, +              /*engineJobListener=*/ this,, +              /*resourceListener=*/ this);, +      result = new EngineResource<>(, +          cached, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ true, key, /*listener=*/ this);, +      if (resource.isMemoryCacheable()) {, +    if (resource.isMemoryCacheable()) {, +    @Synthetic final EngineJobListener engineJobListener;, +    @Synthetic final ResourceListener resourceListener;, +                    engineJobListener,, +                    resourceListener,, +        EngineJobListener engineJobListener,, +        ResourceListener resourceListener) {, +      this.engineJobListener = engineJobListener;, +      this.resourceListener = resourceListener;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java, +            new EngineResource<>(, +                ref.resource,, +                /*isMemoryCacheable=*/ true,, +                /*isRecyclable=*/ false,, +                ref.key,, +                listener);, +          referent.isMemoryCacheable() && isActiveResourceRetentionAllowed, +      isCacheable = referent.isMemoryCacheable();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +import com.bumptech.glide.load.engine.EngineResource.ResourceListener;, +              diskCacheExecutor,, +              sourceExecutor,, +              sourceUnlimitedExecutor,, +              animationExecutor,, +              /*engineJobListener=*/ this,, +              /*resourceListener=*/ this);, +      result = new EngineResource<>(, +          cached, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ true, key, /*listener=*/ this);, +      if (resource.isMemoryCacheable()) {, +    if (resource.isMemoryCacheable()) {, +    @Synthetic final EngineJobListener engineJobListener;, +    @Synthetic final ResourceListener resourceListener;, +                    engineJobListener,, +                    resourceListener,, +        EngineJobListener engineJobListener,, +        ResourceListener resourceListener) {, +      this.engineJobListener = engineJobListener;, +      this.resourceListener = resourceListener;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +import com.bumptech.glide.load.engine.EngineResource.ResourceListener;, +  private final ResourceListener resourceListener;, +  private final EngineJobListener engineJobListener;, +      EngineJobListener engineJobListener,, +      ResourceListener resourceListener,, +        engineJobListener,, +        resourceListener,, +      EngineJobListener engineJobListener,, +      ResourceListener resourceListener,, +    this.engineJobListener = engineJobListener;, +    this.resourceListener = resourceListener;, +    engineJobListener.onEngineJobCancelled(this, key);, +      engineResource = engineResourceFactory.build(resource, isCacheable, key, resourceListener);, +    engineJobListener.onEngineJobComplete(this, localKey, localResource);, +    engineJobListener.onEngineJobComplete(this, localKey, /*resource=*/ null);, +    public <R> EngineResource<R> build(, +        Resource<R> resource, boolean isMemoryCacheable, Key key, ResourceListener listener) {, +      return new EngineResource<>(, +          resource, isMemoryCacheable, /*isRecyclable=*/ true, key, listener);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java, +            new EngineResource<>(, +                ref.resource,, +                /*isMemoryCacheable=*/ true,, +                /*isRecyclable=*/ false,, +                ref.key,, +                listener);, +          referent.isMemoryCacheable() && isActiveResourceRetentionAllowed, +      isCacheable = referent.isMemoryCacheable();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +import com.bumptech.glide.load.engine.EngineResource.ResourceListener;, +              diskCacheExecutor,, +              sourceExecutor,]
[+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java, +   * Determines if the GIF is animated by trying to read in the first 2 frames, +   * This method reparses the data even if the header has already been read, +   */, +  public boolean isAnimated() {, +    readHeader();, +    if (!err()) {, +      readContents(2 /* maxFrames */);, +    }, +    return header.frameCount > 1;, +  }, +, +  /**, +    readContents(Integer.MAX_VALUE /* maxFrames */);, +  }, +, +  /**, +   * Main file parser. Reads GIF content blocks. Stops after reading maxFrames, +   */, +  private void readContents(int maxFrames) {, +    while (!(done || err() || header.frameCount > maxFrames)) {, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java, +   * Determines if the GIF is animated by trying to read in the first 2 frames, +   * This method reparses the data even if the header has already been read, +   */, +  public boolean isAnimated() {, +    readHeader();, +    if (!err()) {, +      readContents(2 /* maxFrames */);, +    }, +    return header.frameCount > 1;, +  }, +, +  /**, +    readContents(Integer.MAX_VALUE /* maxFrames */);, +  }, +, +  /**, +   * Main file parser. Reads GIF content blocks. Stops after reading maxFrames, +   */, +  private void readContents(int maxFrames) {, +    while (!(done || err() || header.frameCount > maxFrames)) {, +++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java, +import static org.junit.Assert.assertTrue;, +  @Test, +  public void testIsAnimatedMultipleFrames() {, +    final int lzwMinCodeSize = 2;, +    final int numFrames = 3;, +, +    final int frameSize =, +        GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH, +            + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize);, +    ByteBuffer buffer =, +        ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + numFrames * frameSize), +            .order(ByteOrder.LITTLE_ENDIAN);, +, +    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);, +    for (int i = 0; i < numFrames; i++) {, +      GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0 /*numColors*/);, +      GifBytesTestUtil.writeFakeImageData(buffer, 2);, +    }, +, +    parser.setData(buffer.array());, +    assertTrue(parser.isAnimated());, +  }, +, +  @Test, +  public void testIsNotAnimatedOneFrame() {, +    final int lzwMinCodeSize = 2;, +, +    final int frameSize =, +        GifBytesTestUtil.IMAGE_DESCRIPTOR_LENGTH, +            + GifBytesTestUtil.getImageDataSize(lzwMinCodeSize);, +, +    ByteBuffer buffer =, +        ByteBuffer.allocate(GifBytesTestUtil.HEADER_LENGTH + frameSize), +            .order(ByteOrder.LITTLE_ENDIAN);, +, +    GifBytesTestUtil.writeHeaderAndLsd(buffer, 1, 1, false, 0);, +    GifBytesTestUtil.writeImageDescriptor(buffer, 0, 0, 1, 1, false /*hasLct*/, 0 /*numColors*/);, +    GifBytesTestUtil.writeFakeImageData(buffer, 2);, +, +    parser.setData(buffer.array());, +    assertFalse(parser.isAnimated());, +  }, +, +]
[+++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.1', +  <version>3.5.1</version>, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.1', +  <version>3.5.1</version>, +++ b/gradle.properties, +VERSION_NAME=3.5.1, +VERSION_MINOR=5, +VERSION_PATCH=1, +VERSION_CODE=10, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.1', +  <version>3.5.1</version>, +++ b/gradle.properties, +VERSION_NAME=3.5.1, +VERSION_MINOR=5, +VERSION_PATCH=1, +VERSION_CODE=10, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.2.1, +VERSION_MINOR=2, +VERSION_PATCH=1, +VERSION_CODE=6, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.1', +  <version>3.5.1</version>, +++ b/gradle.properties, +VERSION_NAME=3.5.1, +VERSION_MINOR=5, +VERSION_PATCH=1, +VERSION_CODE=10, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.2.1, +VERSION_MINOR=2, +VERSION_PATCH=1, +VERSION_CODE=6, +++ b/integration/volley/gradle.properties, +VERSION_NAME=1.2.1, +VERSION_MINOR=2, +VERSION_PATCH=1, +VERSION_CODE=6, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.1', +  <version>3.5.1</version>, +++ b/gradle.properties, +VERSION_NAME=3.5.1, +VERSION_MINOR=5, +VERSION_PATCH=1, +VERSION_CODE=10, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.2.1, +VERSION_MINOR=2, +VERSION_PATCH=1, +VERSION_CODE=6, +++ b/integration/volley/gradle.properties, +VERSION_NAME=1.2.1, +VERSION_MINOR=2, +VERSION_PATCH=1, +VERSION_CODE=6, +++ b/library/build.gradle, +        versionCode = VERSION_CODE as int]
[+++ b/.gitignore, +doc/**, +*.swo, +++ b/.gitignore, +doc/**, +*.swo, +++ b/build.gradle, +evaluationDependsOnChildren();, +, +def getAndroidSdkDirectory() {, +  project("library").android.sdkDirectory, +}, +, +def getAndroidCompileSdkVersion() {, +  project("library").android.compileSdkVersion, +}, +, +def getAndroidChildren() {, +    subprojects.findAll { project -> project.plugins.hasPlugin('android-library') }, +}, +, +// For now this is just [release, debug], +def getAndroidLibraryVariants() {, +    getAndroidChildren().collect { project ->, +        project.android.libraryVariants, +    }.sum().unique{ it.name }, +}, +, +// Generate javadocs containing batched documentation for all android library subprojects., +getAndroidLibraryVariants().each { variant ->, +    def androidJar = "${getAndroidSdkDirectory()}/platforms/${getAndroidCompileSdkVersion()}/android.jar", +    def destinationDirPath = "${getProjectDir()}/doc/${variant.baseName}", +, +    task("clean${variant.name.capitalize()}Javadoc", type: Delete) {, +        delete destinationDirPath, +    }, +, +    task("generate${variant.name.capitalize()}Javadoc", type: Javadoc) {, +, +        // Get the variant from each subproject that matches our current variant's name., +        def childEquivalentChildVariants = getAndroidChildren().collect { project ->, +            project.android.libraryVariants.findAll { type -> type.name == variant.name }, +        }.sum(), +, +        source = childEquivalentChildVariants.collect { it.javaCompile.source }, +        classpath = files(childEquivalentChildVariants.collect { files(it.javaCompile.classpath.files, androidJar) }), +, +        options {, +            links("http://docs.oracle.com/javase/7/docs/api/"), +            linksOffline("http://d.android.com/reference", "${getAndroidSdkDirectory()}/docs/reference"), +        }, +, +        exclude '**/BuildConfig.java', +        exclude '**/R.java', +, +        destinationDir = new File(destinationDirPath), +, +        dependsOn("clean${variant.name.capitalize()}Javadoc"), +    }, +}, +++ b/.gitignore, +doc/**, +*.swo, +++ b/build.gradle, +evaluationDependsOnChildren();, +, +def getAndroidSdkDirectory() {, +  project("library").android.sdkDirectory, +}, +, +def getAndroidCompileSdkVersion() {, +  project("library").android.compileSdkVersion, +}, +, +def getAndroidChildren() {, +    subprojects.findAll { project -> project.plugins.hasPlugin('android-library') }, +}, +, +// For now this is just [release, debug], +def getAndroidLibraryVariants() {, +    getAndroidChildren().collect { project ->, +        project.android.libraryVariants, +    }.sum().unique{ it.name }, +}, +, +// Generate javadocs containing batched documentation for all android library subprojects., +getAndroidLibraryVariants().each { variant ->, +    def androidJar = "${getAndroidSdkDirectory()}/platforms/${getAndroidCompileSdkVersion()}/android.jar", +    def destinationDirPath = "${getProjectDir()}/doc/${variant.baseName}", +, +    task("clean${variant.name.capitalize()}Javadoc", type: Delete) {, +        delete destinationDirPath, +    }, +, +    task("generate${variant.name.capitalize()}Javadoc", type: Javadoc) {, +, +        // Get the variant from each subproject that matches our current variant's name., +        def childEquivalentChildVariants = getAndroidChildren().collect { project ->, +            project.android.libraryVariants.findAll { type -> type.name == variant.name }, +        }.sum()]
[+++ b/annotation/compiler/build.gradle, +    compileOnly "com.squareup:javapoet:${JAVAPOET_VERSION}", +    compileOnly "com.google.auto.service:auto-service:${AUTO_SERVICE_VERSION}", +    compileOnly "com.google.code.findbugs:jsr305:${JSR_305_VERSION}", +    // This is to support com.sun.tools.javac.util.List, currently used in RootModuleGenerator., +++ b/annotation/compiler/build.gradle, +    compileOnly "com.squareup:javapoet:${JAVAPOET_VERSION}", +    compileOnly "com.google.auto.service:auto-service:${AUTO_SERVICE_VERSION}", +    compileOnly "com.google.code.findbugs:jsr305:${JSR_305_VERSION}", +    // This is to support com.sun.tools.javac.util.List, currently used in RootModuleGenerator., +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, +    private final Set<String> glideModules;, +    private final Set<String> extensions;, +++ b/annotation/compiler/build.gradle, +    compileOnly "com.squareup:javapoet:${JAVAPOET_VERSION}", +    compileOnly "com.google.auto.service:auto-service:${AUTO_SERVICE_VERSION}", +    compileOnly "com.google.code.findbugs:jsr305:${JSR_305_VERSION}", +    // This is to support com.sun.tools.javac.util.List, currently used in RootModuleGenerator., +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, +    private final Set<String> glideModules;, +    private final Set<String> extensions;, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java, +  boolean processExtensions(RoundEnvironment env) {, +++ b/annotation/compiler/build.gradle, +    compileOnly "com.squareup:javapoet:${JAVAPOET_VERSION}", +    compileOnly "com.google.auto.service:auto-service:${AUTO_SERVICE_VERSION}", +    compileOnly "com.google.code.findbugs:jsr305:${JSR_305_VERSION}", +    // This is to support com.sun.tools.javac.util.List, currently used in RootModuleGenerator., +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, +    private final Set<String> glideModules;, +    private final Set<String> extensions;, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java, +  boolean processExtensions(RoundEnvironment env) {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, +    boolean newModulesWritten = libraryModuleProcessor.processModules(env);, +    boolean newExtensionWritten = extensionProcessor.processExtensions(env);, +++ b/annotation/compiler/build.gradle, +    compileOnly "com.squareup:javapoet:${JAVAPOET_VERSION}", +    compileOnly "com.google.auto.service:auto-service:${AUTO_SERVICE_VERSION}", +    compileOnly "com.google.code.findbugs:jsr305:${JSR_305_VERSION}", +    // This is to support com.sun.tools.javac.util.List, currently used in RootModuleGenerator., +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, +    private final Set<String> glideModules;, +    private final Set<String> extensions;, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java, +  boolean processExtensions(RoundEnvironment env) {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, +    boolean newModulesWritten = libraryModuleProcessor.processModules(env);, +    boolean newExtensionWritten = extensionProcessor.processExtensions(env);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +    return argument.toString().equals(expected);, +++ b/annotation/compiler/build.gradle, +    compileOnly "com.squareup:javapoet:${JAVAPOET_VERSION}", +    compileOnly "com.google.auto.service:auto-service:${AUTO_SERVICE_VERSION}", +    compileOnly "com.google.code.findbugs:jsr305:${JSR_305_VERSION}", +    // This is to support com.sun.tools.javac.util.List, currently used in RootModuleGenerator., +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, +    private final Set<String> glideModules;, +    private final Set<String> extensions;, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java, +  boolean processExtensions(RoundEnvironment env) {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, +    boolean newModulesWritten = libraryModuleProcessor.processModules(env);, +    boolean newExtensionWritten = extensionProcessor.processExtensions(env);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +    return argument.toString().equals(expected);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java, +    StringBuilder code = new StringBuilder(returnsValue ? "return " : "");, +    code.append("$T.$N(");, +        code.append("$L, ");, +      code = new StringBuilder(code.substring(0, code.length() - 2));, +    code.append(")");, +    builder.addStatement(code.toString(), args.toArray(new Object[0]));, +++ b/annotation/compiler/build.gradle, +    compileOnly "com.squareup:javapoet:${JAVAPOET_VERSION}", +    compileOnly "com.google.auto.service:auto-service:${AUTO_SERVICE_VERSION}", +    compileOnly "com.google.code.findbugs:jsr305:${JSR_305_VERSION}", +    // This is to support com.sun.tools.javac.util.List, currently used in RootModuleGenerator., +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, +    private final Set<String> glideModules;, +    private final Set<String> extensions;, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java, +  boolean processExtensions(RoundEnvironment env) {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, +    boolean newModulesWritten = libraryModuleProcessor.processModules(env);, +    boolean newExtensionWritten = extensionProcessor.processExtensions(env);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +    return argument.toString().equals(expected);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java, +    StringBuilder code = new StringBuilder(returnsValue ? "return " : "");, +    code.append("$T.$N(");, +        code.append("$L, ");, +      code = new StringBuilder(code.substring(0, code.length() - 2));, +    code.append(")");, +    builder.addStatement(code.toString(), args.toArray(new Object[0]));, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java, +    StringBuilder indexerName = new StringBuilder(, +        INDEXER_NAME_PREFIX + annotation.getSimpleName() + "_");, +      indexerName.append(element.getQualifiedName().toString().replace(".", "_"));, +      indexerName.append("_");]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java, +, +import java.util.ArrayDeque;, +import java.util.Queue;, +    private static final GifHeaderParserPool PARSER_POOL = new DefaultGifHeaderParserPool();, +    private final Context context;, +    private final BitmapPool bitmapPool;, +    private GifHeaderParserPool parserPool;, +        this(context, bitmapPool, PARSER_POOL);, +    GifResourceDecoder(Context context, BitmapPool bitmapPool, GifHeaderParserPool parserPool) {, +        this.parserPool = parserPool;, +        final GifHeaderParser parser = parserPool.obtain(data);, +        try {, +            return decode(data, width, height, parser);, +        } finally {, +            parserPool.release(parser);, +        }, +    }, +    private GifDataResource decode(byte[] data, int width, int height, GifHeaderParser parser) {, +        final GifHeader header = parser.parseHeader();, +, +    interface GifHeaderParserPool {, +        public GifHeaderParser obtain(byte[] data);, +        public void release(GifHeaderParser parser);, +    }, +, +    private static class DefaultGifHeaderParserPool implements GifHeaderParserPool {, +        private static final Queue<GifHeaderParser> POOL = new ArrayDeque<GifHeaderParser>();, +, +        @Override, +        public GifHeaderParser obtain(byte[] data) {, +            GifHeaderParser result;, +            synchronized (POOL) {, +                result = POOL.poll();, +            }, +            if (result == null) {, +                result = new GifHeaderParser();, +            }, +, +            return result.setData(data);, +        }, +, +        @Override, +        public void release(GifHeaderParser parser) {, +            synchronized (POOL) {, +                POOL.offer(parser);, +            }, +        }, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java, +, +import java.util.ArrayDeque;, +import java.util.Queue;, +    private static final GifHeaderParserPool PARSER_POOL = new DefaultGifHeaderParserPool();, +    private final Context context;, +    private final BitmapPool bitmapPool;, +    private GifHeaderParserPool parserPool;, +        this(context, bitmapPool, PARSER_POOL);, +    GifResourceDecoder(Context context, BitmapPool bitmapPool, GifHeaderParserPool parserPool) {, +        this.parserPool = parserPool;, +        final GifHeaderParser parser = parserPool.obtain(data);, +        try {, +            return decode(data, width, height, parser);, +        } finally {, +            parserPool.release(parser);, +        }, +    }, +    private GifDataResource decode(byte[] data, int width, int height, GifHeaderParser parser) {, +        final GifHeader header = parser.parseHeader();, +, +    interface GifHeaderParserPool {, +        public GifHeaderParser obtain(byte[] data);, +        public void release(GifHeaderParser parser);, +    }, +, +    private static class DefaultGifHeaderParserPool implements GifHeaderParserPool {, +        private static final Queue<GifHeaderParser> POOL = new ArrayDeque<GifHeaderParser>();, +, +        @Override, +        public GifHeaderParser obtain(byte[] data) {, +            GifHeaderParser result;, +            synchronized (POOL) {, +                result = POOL.poll();, +            }, +            if (result == null) {, +                result = new GifHeaderParser();, +            }, +, +            return result.setData(data);, +        }, +, +        @Override, +        public void release(GifHeaderParser parser) {, +            synchronized (POOL) {, +                POOL.offer(parser);, +            }, +        }, +    }, +++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java, +import org.mockito.invocation.InvocationOnMock;]
[+++ b/gradle.properties, +++ b/gradle.properties, +++ b/integration/gifencoder/build.gradle, +++ b/gradle.properties, +++ b/integration/gifencoder/build.gradle, +++ b/integration/okhttp/build.gradle, +++ b/gradle.properties, +++ b/integration/gifencoder/build.gradle, +++ b/integration/okhttp/build.gradle, +++ b/integration/okhttp3/build.gradle, +++ b/gradle.properties, +++ b/integration/gifencoder/build.gradle, +++ b/integration/okhttp/build.gradle, +++ b/integration/okhttp3/build.gradle, +++ b/integration/recyclerview/build.gradle, +++ b/gradle.properties, +++ b/integration/gifencoder/build.gradle, +++ b/integration/okhttp/build.gradle, +++ b/integration/okhttp3/build.gradle, +++ b/integration/recyclerview/build.gradle, +++ b/integration/volley/build.gradle, +++ b/gradle.properties, +++ b/integration/gifencoder/build.gradle, +++ b/integration/okhttp/build.gradle, +++ b/integration/okhttp3/build.gradle, +++ b/integration/recyclerview/build.gradle, +++ b/integration/volley/build.gradle, +++ b/library/build.gradle]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +      if (requestOptions.isLocked()) {, +        requestOptions = requestOptions.clone();, +      }, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +      if (requestOptions.isLocked()) {, +        requestOptions = requestOptions.clone();, +      }, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +  public final boolean isLocked() {, +    return isLocked;, +  }, +]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java]
[+++ b/.gitignore, +docs/**/*]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java, +        if ((cacheDirectory == null) || (!cacheDirectory.canWrite())) {]
[+++ b/README.md, +    compile('com.github.bumptech.glide:library:3.3.0a-SNAPSHOT:@aar') {, +        transitive = true, +        changing = true, +    }, +    compile 'com.android.support:support-v4:19.0.0', +<dependency>, +	<groupId>com.google.android</groupId>, +	<artifactId>support-v4</artifactId>, +	<version>r7</version>, +</dependency>, +++ b/README.md, +    compile('com.github.bumptech.glide:library:3.3.0a-SNAPSHOT:@aar') {, +        transitive = true, +        changing = true, +    }, +    compile 'com.android.support:support-v4:19.0.0', +<dependency>, +	<groupId>com.google.android</groupId>, +	<artifactId>support-v4</artifactId>, +	<version>r7</version>, +</dependency>, +++ b/build.gradle, +evaluationDependsOn(":third_party:disklrucache"), +// Currently the only excluded project is the :integration:volley project., +def androidProjects = [':third_party:gif_decoder', ':library'].collect { project(it) }, +def javaProjects = [':third_party:disklrucache'].collect { project(it) }, +def allProjects = androidProjects + javaProjects, +def releaseVariantAndroidProjects = androidProjects.collect {, +    it.android.libraryVariants.findAll { variant ->, +        variant.buildType.name.equalsIgnoreCase("release"), +    }, +}, +, +    def javadocTask = task("${variant.name}Javadoc", type: Javadoc) {, +        classifier = 'javadoc', +        source += javaProjects.collect { it.sourceSets.main.allJava }, +        classpath = files(childEquivalentChildVariants.collect {, +            files(it.javaCompile.classpath.files, androidJar), +        }), +        classpath += javaProjects.collect { files(it.configurations.compile) }, +    javadocTask.dependsOn("clean${variant.name.capitalize()}Javadoc"), +/** Build a fat jar of all internal dependencies */, +def releaseJarOut = 'bin', +    from files(, +            releaseVariantAndroidProjects.collect { variant ->, +                variant.javaCompile.destinationDir, +            }, +    ), +    exclude "**/R.class", +    exclude "**/BuildConfig.class", +    from files(javaProjects.collect { it.sourceSets.main.output }), +, +    destinationDir = file(releaseJarOut), +task cleanReleaseJar(type: Delete) {, +    delete releaseJarOut, +releaseJar.dependsOn(cleanReleaseJar), +allProjects.each { project ->, +    releaseJar.dependsOn(project.tasks.getByName("checkstyle")), +    releaseJar.dependsOn(project.build), +}, +++ b/README.md, +    compile('com.github.bumptech.glide:library:3.3.0a-SNAPSHOT:@aar') {, +        transitive = true, +        changing = true, +    }, +    compile 'com.android.support:support-v4:19.0.0', +<dependency>, +	<groupId>com.google.android</groupId>, +	<artifactId>support-v4</artifactId>, +	<version>r7</version>, +</dependency>, +++ b/build.gradle, +evaluationDependsOn(":third_party:disklrucache"), +// Currently the only excluded project is the :integration:volley project., +def androidProjects = [':third_party:gif_decoder', ':library'].collect { project(it) }, +def javaProjects = [':third_party:disklrucache'].collect { project(it) }, +def allProjects = androidProjects + javaProjects, +def releaseVariantAndroidProjects = androidProjects.collect {, +    it.android.libraryVariants.findAll { variant ->, +        variant.buildType.name.equalsIgnoreCase("release"), +    }, +}, +, +    def javadocTask = task("${variant.name}Javadoc", type: Javadoc) {, +        classifier = 'javadoc', +        source += javaProjects.collect { it.sourceSets.main.allJava }, +        classpath = files(childEquivalentChildVariants.collect {, +            files(it.javaCompile.classpath.files, androidJar), +        }), +        classpath += javaProjects.collect { files(it.configurations.compile) }, +    javadocTask.dependsOn("clean${variant.name.capitalize()}Javadoc"), +/** Build a fat jar of all internal dependencies */, +def releaseJarOut = 'bin', +    from files(, +            releaseVariantAndroidProjects.collect { variant ->, +                variant.javaCompile.destinationDir, +            }, +    ), +    exclude "**/R.class"]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import static org.mockito.Mockito.any;, +import static org.mockito.Mockito.anyBoolean;, +import static org.mockito.Mockito.eq;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import static org.mockito.Mockito.any;, +import static org.mockito.Mockito.anyBoolean;, +import static org.mockito.Mockito.eq;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +        /*activeResources=*/ null,, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import static org.mockito.Mockito.any;, +import static org.mockito.Mockito.anyBoolean;, +import static org.mockito.Mockito.eq;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +        /*activeResources=*/ null,, +++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineResourceTest.java, +        new EngineResource<>(resource, /*isCacheable=*/ true, /*isRecyclable=*/ true);]
[+++ b/.travis.yml, +    - $HOME/.gradle/caches]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +        .addModifiers(Modifier.PUBLIC, Modifier.FINAL), +        .varargs(requestOptionMethod.varargs), +        .addAnnotations(, +            FluentIterable.from(requestOptionMethod.annotations), +                .filter(new Predicate<AnnotationSpec>() {, +                  @Override, +                  public boolean apply(AnnotationSpec input) {, +                    return !input.type.equals(TypeName.get(Override.class));, +                  }, +                }), +                .toList(), +        ), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +        .addModifiers(Modifier.PUBLIC, Modifier.FINAL), +        .varargs(requestOptionMethod.varargs), +        .addAnnotations(, +            FluentIterable.from(requestOptionMethod.annotations), +                .filter(new Predicate<AnnotationSpec>() {, +                  @Override, +                  public boolean apply(AnnotationSpec input) {, +                    return !input.type.equals(TypeName.get(Override.class));, +                  }, +                }), +                .toList(), +        ), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java, +    MethodSpec.Builder result = MethodSpec.overriding(methodToOverride), +        .addModifiers(Modifier.FINAL), +            .build());, +, +    if (methodToOverride.getSimpleName().toString().equals("transforms")) {, +      result.addAnnotation(, +          AnnotationSpec.builder(SafeVarargs.class), +              .build());, +    }, +, +    return result.build();, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +        .addModifiers(Modifier.PUBLIC, Modifier.FINAL), +        .varargs(requestOptionMethod.varargs), +        .addAnnotations(, +            FluentIterable.from(requestOptionMethod.annotations), +                .filter(new Predicate<AnnotationSpec>() {, +                  @Override, +                  public boolean apply(AnnotationSpec input) {, +                    return !input.type.equals(TypeName.get(Override.class));, +                  }, +                }), +                .toList(), +        ), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java, +    MethodSpec.Builder result = MethodSpec.overriding(methodToOverride), +        .addModifiers(Modifier.FINAL), +            .build());, +, +    if (methodToOverride.getSimpleName().toString().equals("transforms")) {, +      result.addAnnotation(, +          AnnotationSpec.builder(SafeVarargs.class), +              .build());, +    }, +, +    return result.build();, +++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +  @SuppressWarnings({"unchecked", "varargs"})]
[+++ b/library/src/androidTest/java/com/bumptech/glide/request/BaseRequestOptionsTest.java, +package com.bumptech.glide.request;, +, +import static com.google.common.truth.Truth.assertThat;, +import static org.mockito.Mockito.mock;, +, +import com.bumptech.glide.load.Transformation;, +, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE), +public class BaseRequestOptionsTest {, +, +  private TestOptions options;, +, +  @Before, +  public void setUp() {, +    options = new TestOptions();, +  }, +, +  @Test, +  public void testTransformationIsSetAfterApplyingOtherOptionsWithTransformation() {, +    TestOptions other = new TestOptions();, +    other.transform(Object.class, mock(Transformation.class));, +    options.apply(other);, +    assertThat(options.isTransformationSet()).isTrue();, +  }, +, +  private static class TestOptions extends BaseRequestOptions<TestOptions> {, +    // Empty., +  }, +}, +++ b/library/src/androidTest/java/com/bumptech/glide/request/BaseRequestOptionsTest.java, +package com.bumptech.glide.request;, +, +import static com.google.common.truth.Truth.assertThat;, +import static org.mockito.Mockito.mock;, +, +import com.bumptech.glide.load.Transformation;, +, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE), +public class BaseRequestOptionsTest {, +, +  private TestOptions options;, +, +  @Before, +  public void setUp() {, +    options = new TestOptions();, +  }, +, +  @Test, +  public void testTransformationIsSetAfterApplyingOtherOptionsWithTransformation() {, +    TestOptions other = new TestOptions();, +    other.transform(Object.class, mock(Transformation.class));, +    options.apply(other);, +    assertThat(options.isTransformationSet()).isTrue();, +  }, +, +  private static class TestOptions extends BaseRequestOptions<TestOptions> {, +    // Empty., +  }, +}, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +    fields |= other.fields;]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java, +import android.graphics.drawable.Drawable;, +   * Called when an exception occurs during a load, immediately before, +   * {@link Target#onLoadFailed(Drawable)}. Will only be called if we currently want to display an, +   * image for the given model in the given target. It is recommended to create a single instance, +   * per activity/fragment rather than instantiate a new object for each call to {@code, +   * include all relevant builder calls (like centerCrop, placeholder etc)., +   * Called when a load completes successfully, immediately before {@link]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java, + *, + * @deprecated use {@link ExternalPreferredCacheDiskCacheFactory} instead., +@Deprecated, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalCacheDiskCacheFactory.java, + *, + * @deprecated use {@link ExternalPreferredCacheDiskCacheFactory} instead., +@Deprecated, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java, +package com.bumptech.glide.load.engine.cache;, +, +import android.content.Context;, +, +import android.support.annotation.Nullable;, +import java.io.File;, +, +/**, + * Creates an {@link com.bumptech.glide.disklrucache.DiskLruCache} based disk cache in the external, + * disk cache directory, which falls back to the internal disk cache if no external storage is, + * available. If ever fell back to the internal disk cache, will use that one from that moment on., + *, + * <p><b>Images can be read by everyone when using external disk cache.</b>, + */, +public final class ExternalPreferredCacheDiskCacheFactory extends DiskLruCacheFactory {, +, +  public ExternalPreferredCacheDiskCacheFactory(Context context) {, +    this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR,, +        DiskCache.Factory.DEFAULT_DISK_CACHE_SIZE);, +  }, +, +  public ExternalPreferredCacheDiskCacheFactory(Context context, int diskCacheSize) {, +    this(context, DiskCache.Factory.DEFAULT_DISK_CACHE_DIR, diskCacheSize);, +  }, +, +  public ExternalPreferredCacheDiskCacheFactory(final Context context, final String diskCacheName,, +                                                final int diskCacheSize) {, +    super(new CacheDirectoryGetter() {, +      @Nullable, +      private File getInternalCacheDirectory() {, +        File cacheDirectory = context.getCacheDir();, +        if (cacheDirectory == null) {, +          return null;, +        }, +        if (diskCacheName != null) {, +          return new File(cacheDirectory, diskCacheName);, +        }, +        return cacheDirectory;, +      }, +, +      @Override, +      public File getCacheDirectory() {, +        File internalCacheDirectory = getInternalCacheDirectory();, +, +        // Already used internal cache, so keep using that one,, +        // thus avoiding using both external and internal with transient errors., +        if ((null != internalCacheDirectory) && internalCacheDirectory.exists()) {, +          return internalCacheDirectory;, +        }, +, +        File cacheDirectory = context.getExternalCacheDir();, +, +        // Shared storage is not available., +        if (cacheDirectory == null) {, +          return internalCacheDirectory;, +        }, +        if (diskCacheName != null) {, +          return new File(cacheDirectory, diskCacheName);, +        }, +        return cacheDirectory;, +      }, +    }, diskCacheSize);, +  }, +}]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +import android.support.annotation.NonNull;, +   * configuration, and containing only transparent pixels., +   *, +   * <p> If no Bitmap with the requested attributes is present in the pool, a new one will be, +   * allocated. </p>, +  @NonNull, +   * {@link android.graphics.Bitmap} may <em>not</em> have been erased and may contain random data., +   *, +   * <p>If no Bitmap with the requested attributes is present in the pool, a new one will be, +   * allocated. </p>, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +import android.support.annotation.NonNull;, +   * configuration, and containing only transparent pixels., +   *, +   * <p> If no Bitmap with the requested attributes is present in the pool, a new one will be, +   * allocated. </p>, +  @NonNull, +   * {@link android.graphics.Bitmap} may <em>not</em> have been erased and may contain random data., +   *, +   * <p>If no Bitmap with the requested attributes is present in the pool, a new one will be, +   * allocated. </p>, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java, +import android.support.annotation.NonNull;, +  @NonNull, +    return Bitmap.createBitmap(width, height, config);, +  @NonNull, +    return get(width, height, config);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +import android.support.annotation.NonNull;, +   * configuration, and containing only transparent pixels., +   *, +   * <p> If no Bitmap with the requested attributes is present in the pool, a new one will be, +   * allocated. </p>, +  @NonNull, +   * {@link android.graphics.Bitmap} may <em>not</em> have been erased and may contain random data., +   *, +   * <p>If no Bitmap with the requested attributes is present in the pool, a new one will be, +   * allocated. </p>, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java, +import android.support.annotation.NonNull;, +  @NonNull, +    return Bitmap.createBitmap(width, height, config);, +  @NonNull, +    return get(width, height, config);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +import android.support.annotation.NonNull;, +  @NonNull, +  public Bitmap get(int width, int height, Bitmap.Config config) {, +    Bitmap result = getDirtyOrNull(width, height, config);, +    } else {, +      result = Bitmap.createBitmap(width, height, config);, +  @NonNull, +  public Bitmap getDirty(int width, int height, Bitmap.Config config) {, +    Bitmap result = getDirtyOrNull(width, height, config);, +    if (result == null) {, +      result = Bitmap.createBitmap(width, height, config);, +    }, +    return result;, +  }, +, +  private synchronized Bitmap getDirtyOrNull(int width, int height, Bitmap.Config config) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +import android.support.annotation.NonNull;, +   * configuration, and containing only transparent pixels., +   *, +   * <p> If no Bitmap with the requested attributes is present in the pool, a new one will be, +   * allocated. </p>, +  @NonNull, +   * {@link android.graphics.Bitmap} may <em>not</em> have been erased and may contain random data., +   *, +   * <p>If no Bitmap with the requested attributes is present in the pool, a new one will be, +   * allocated. </p>, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java, +import android.support.annotation.NonNull;, +  @NonNull, +    return Bitmap.createBitmap(width, height, config);, +  @NonNull, +    return get(width, height, config);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +import android.support.annotation.NonNull;, +  @NonNull, +  public Bitmap get(int width, int height, Bitmap.Config config) {, +    Bitmap result = getDirtyOrNull(width, height, config);, +    } else {, +      result = Bitmap.createBitmap(width, height, config);, +  @NonNull, +  public Bitmap getDirty(int width, int height, Bitmap.Config config) {, +    Bitmap result = getDirtyOrNull(width, height, config);, +    if (result == null) {, +      result = Bitmap.createBitmap(width, height, config);, +    }, +    return result;, +  }, +, +  private synchronized Bitmap getDirtyOrNull(int width, int height, Bitmap.Config config) {]
[+++ b/library/pmd-ruleset.xml, +  <rule ref="rulesets/java/unusedcode.xml" />, +++ b/library/pmd-ruleset.xml, +  <rule ref="rulesets/java/unusedcode.xml" />, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +        <T> void apply(T model, GenericRequestBuilder<T, ?, ?, ?> requestBuilder);, +++ b/library/pmd-ruleset.xml, +  <rule ref="rulesets/java/unusedcode.xml" />, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +        <T> void apply(T model, GenericRequestBuilder<T, ?, ?, ?> requestBuilder);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java, +    interface Writer {, +++ b/library/pmd-ruleset.xml, +  <rule ref="rulesets/java/unusedcode.xml" />, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +        <T> void apply(T model, GenericRequestBuilder<T, ?, ?, ?> requestBuilder);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java, +    interface Writer {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemoryCache.java, +    interface ResourceRemovedListener {]
[+++ b/gradle.properties, +VERSION_NAME=4.3.1, +VERSION_MINOR=3, +VERSION_PATCH=1]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java, +import com.squareup.javapoet.ParameterSpec;, +    List<ParameterSpec> parameters = ProcessorUtil.getParameters(methodToOverride);, +            .addParameters(parameters);, +      for (ParameterSpec param : parameters) {, +        args.add(param.name);, +    List<ParameterSpec> parameters = ProcessorUtil.getParameters(methodToOverride);, +    ParameterSpec parameter = parameters.iterator().next();, +        .addParameters(parameters), +            parameter.name);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java, +import com.squareup.javapoet.ParameterSpec;, +    List<ParameterSpec> parameters = ProcessorUtil.getParameters(methodToOverride);, +            .addParameters(parameters);, +      for (ParameterSpec param : parameters) {, +        args.add(param.name);, +    List<ParameterSpec> parameters = ProcessorUtil.getParameters(methodToOverride);, +    ParameterSpec parameter = parameters.iterator().next();, +        .addParameters(parameters), +            parameter.name);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +  static CodeBlock generateCastingSuperCall(TypeName toReturn, MethodSpec method) {, +        .add("return ($T) super.$N(", toReturn, method.name), +            FluentIterable.from(method.parameters), +                .transform(new Function<ParameterSpec, String>() {, +                  public String apply(ParameterSpec input) {, +                    return input.name;, +    return dedupedParameters(result);, +  private static List<ParameterSpec> dedupedParameters(List<ParameterSpec> parameters) {, +    boolean hasDupes = false;, +    Set<String> names = new HashSet<>();, +    for (ParameterSpec parameter : parameters) {, +      String name = parameter.name;, +      if (names.contains(name)) {, +        hasDupes = true;, +      } else {, +        names.add(name);, +      }, +    }, +, +    if (hasDupes) {, +      List<ParameterSpec> copy = parameters;, +      parameters = new ArrayList<>();, +      for (int i = 0; i < copy.size(); i++) {, +        ParameterSpec parameter = copy.get(i);, +        parameters.add(ParameterSpec.builder(parameter.type, parameter.name + i), +            .addModifiers(parameter.modifiers), +            .addAnnotations(parameter.annotations), +            .build());, +      }, +    }, +, +    return parameters;, +  }, +, +  private static ParameterSpec getParameter(VariableElement parameter) {, +    TypeName type = TypeName.get(parameter.asType());, +    return ParameterSpec.builder(type, computeParameterName(parameter, type)), +        .addModifiers(parameter.getModifiers()), +        .addAnnotations(getAnnotations(parameter)), +  private static String computeParameterName(VariableElement parameter, TypeName type) {, +    String rawClassName = type.withoutAnnotations().toString();, +, +    String name;, +, +    if (type.isPrimitive() || type.isBoxedPrimitive()) {, +      name = getSmartPrimitiveParameterName(parameter);, +    } else {, +      if (rawClassName.contains("<") && rawClassName.contains(">")) {, +        String[] preGenericSplit = rawClassName.split("<");, +        String preGeneric = preGenericSplit[0];, +        String[] postGenericSplit = rawClassName.split(">");, +        String postGeneric = postGenericSplit[postGenericSplit.length - 1];, +        if (postGenericSplit.length > 1) {, +          rawClassName = preGeneric + postGeneric;, +        } else {, +          rawClassName = preGeneric;, +        }, +      }, +, +      String[] qualifiers = rawClassName.split("\\.");, +      rawClassName = qualifiers[qualifiers.length - 1];, +, +      rawClassName = applySmartParameterNameReplacements(rawClassName);, +, +      boolean allCaps = true;, +      for (char c : rawClassName.toCharArray()) {, +        if (Character.isLowerCase(c)) {, +          allCaps = false;, +          break;, +        }, +      }, +      if (allCaps) {, +        name = rawClassName.toLowerCase();, +      } else {, +        int indexOfLastWordStart = 0;, +        char[] chars = rawClassName.toCharArray();, +        for (int i = 0, charArrayLength = chars.length; i < charArrayLength; i++) {, +          char c = chars[i];, +          if (Character.isUpperCase(c)) {]
[+++ b/.travis.yml, +before_install:, +  - mkdir "$ANDROID_HOME/licenses" || true, +  - echo -e "\n8933bad161af4178b1185d1a37fbf41ea5269c55\nd56f5187479451eabf01fb78af6dfcb131a6481e" > "$ANDROID_HOME/licenses/android-sdk-license", +  - echo -e "\n84831b9409646a918e30573bab4c9c91346d8abd\n504667f4c0de7af1a06de9f4b1727b84351f2910" > "$ANDROID_HOME/licenses/android-sdk-preview-license", +]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +    return new LoadData<>(model, new OkHttpStreamFetcher(client, model));, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +    return new LoadData<>(model, new OkHttpStreamFetcher(client, model));, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java, +    return new LoadData<>(url, new VolleyStreamFetcher(requestQueue, url, requestFactory));, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +    return new LoadData<>(model, new OkHttpStreamFetcher(client, model));, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java, +    return new LoadData<>(url, new VolleyStreamFetcher(requestQueue, url, requestFactory));, +++ /dev/null, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +    return new LoadData<>(model, new OkHttpStreamFetcher(client, model));, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java, +    return new LoadData<>(url, new VolleyStreamFetcher(requestQueue, url, requestFactory));, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java, +package com.bumptech.glide.load.engine.cache;, +, +import static org.junit.Assert.assertTrue;, +, +import com.bumptech.glide.load.Key;, +, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +, +import java.security.MessageDigest;, +import java.util.regex.Matcher;, +import java.util.regex.Pattern;, +, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +public class SafeKeyGeneratorTest {, +  private SafeKeyGenerator keyGenerator;, +  private int nextId;, +, +  @Before, +  public void setUp() throws Exception {, +    nextId = 0;, +    keyGenerator = new SafeKeyGenerator();, +  }, +, +  @Test, +  public void testKeysAreValidForDiskCache() {, +    final Pattern diskCacheRegex = Pattern.compile("[a-z0-9_-]{64}");, +    for (int i = 0; i < 1000; i++) {, +      String key = getRandomKeyFromGenerator();, +      Matcher matcher = diskCacheRegex.matcher(key);, +      assertTrue(key, matcher.matches());, +    }, +  }, +, +  private String getRandomKeyFromGenerator() {, +    return keyGenerator.getSafeKey(new MockKey(getNextId()));, +  }, +, +  private String getNextId() {, +    return String.valueOf(nextId++);, +  }, +, +  private static class MockKey implements Key {, +    private String id;, +, +    public MockKey(String id) {, +      this.id = id;, +    }, +, +    @Override, +    public void updateDiskCacheKey(MessageDigest messageDigest) {, +      messageDigest.update(id.getBytes(CHARSET));, +    }, +  }, +}, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +    return new LoadData<>(model, new OkHttpStreamFetcher(client, model));, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java, +    return new LoadData<>(url, new VolleyStreamFetcher(requestQueue, url, requestFactory));, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/SafeKeyGeneratorTest.java, +package com.bumptech.glide.load.engine.cache;, +, +import static org.junit.Assert.assertTrue;, +, +import com.bumptech.glide.load.Key;, +, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +, +import java.security.MessageDigest;, +import java.util.regex.Matcher;, +import java.util.regex.Pattern;, +, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18)]
[+++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java, +import com.bumptech.glide.load.DataSource;, +      Target<PictureDrawable> target, DataSource dataSource, boolean isFirstResource) {]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +  private static final ImmutableSet<String> EXCLUDED_METHODS_FROM_BASE_REQUEST_OPTIONS =]
[+++ b/checkstyle.xml, +        <!-- Default sun.* packages -->, +        <module name="IllegalImport">, +            <property name="illegalPkgs" value="sun" />, +            <message key="import.illegal" value="Import from illegal package - {0}. Programs that contain direct calls to the sun.* packages are not 100% Pure Java." />, +        </module>, +        <!-- Prevent importing JUnit 3 classes and Assert methods -->, +        <module name="IllegalImport">, +            <property name="illegalPkgs" value="junit" />, +            <message key="import.illegal" value="Import from illegal package - {0}. Tests are written in JUnit 4, use org.junit.* equivalents." />, +        </module>, +++ b/checkstyle.xml, +        <!-- Default sun.* packages -->, +        <module name="IllegalImport">, +            <property name="illegalPkgs" value="sun" />, +            <message key="import.illegal" value="Import from illegal package - {0}. Programs that contain direct calls to the sun.* packages are not 100% Pure Java." />, +        </module>, +        <!-- Prevent importing JUnit 3 classes and Assert methods -->, +        <module name="IllegalImport">, +            <property name="illegalPkgs" value="junit" />, +            <message key="import.illegal" value="Import from illegal package - {0}. Tests are written in JUnit 4, use org.junit.* equivalents." />, +        </module>, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import static org.junit.Assert.assertNotNull;, +++ b/checkstyle.xml, +        <!-- Default sun.* packages -->, +        <module name="IllegalImport">, +            <property name="illegalPkgs" value="sun" />, +            <message key="import.illegal" value="Import from illegal package - {0}. Programs that contain direct calls to the sun.* packages are not 100% Pure Java." />, +        </module>, +        <!-- Prevent importing JUnit 3 classes and Assert methods -->, +        <module name="IllegalImport">, +            <property name="illegalPkgs" value="junit" />, +            <message key="import.illegal" value="Import from illegal package - {0}. Tests are written in JUnit 4, use org.junit.* equivalents." />, +        </module>, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import static org.junit.Assert.assertNotNull;, +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertTrue;, +++ b/checkstyle.xml, +        <!-- Default sun.* packages -->, +        <module name="IllegalImport">, +            <property name="illegalPkgs" value="sun" />, +            <message key="import.illegal" value="Import from illegal package - {0}. Programs that contain direct calls to the sun.* packages are not 100% Pure Java." />, +        </module>, +        <!-- Prevent importing JUnit 3 classes and Assert methods -->, +        <module name="IllegalImport">, +            <property name="illegalPkgs" value="junit" />, +            <message key="import.illegal" value="Import from illegal package - {0}. Tests are written in JUnit 4, use org.junit.* equivalents." />, +        </module>, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import static org.junit.Assert.assertNotNull;, +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertTrue;, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertTrue;, +++ b/checkstyle.xml, +        <!-- Default sun.* packages -->, +        <module name="IllegalImport">, +            <property name="illegalPkgs" value="sun" />, +            <message key="import.illegal" value="Import from illegal package - {0}. Programs that contain direct calls to the sun.* packages are not 100% Pure Java." />, +        </module>, +        <!-- Prevent importing JUnit 3 classes and Assert methods -->, +        <module name="IllegalImport">, +            <property name="illegalPkgs" value="junit" />, +            <message key="import.illegal" value="Import from illegal package - {0}. Tests are written in JUnit 4, use org.junit.* equivalents." />, +        </module>, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import static org.junit.Assert.assertNotNull;, +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertTrue;, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertTrue;, +++ b/library/src/androidTest/java/com/bumptech/glide/load/MultiTransformationTest.java, +import static org.junit.Assert.assertEquals;, +++ b/checkstyle.xml, +        <!-- Default sun.* packages -->, +        <module name="IllegalImport">, +            <property name="illegalPkgs" value="sun" />, +            <message key="import.illegal" value="Import from illegal package - {0}. Programs that contain direct calls to the sun.* packages are not 100% Pure Java." />, +        </module>, +        <!-- Prevent importing JUnit 3 classes and Assert methods -->, +        <module name="IllegalImport">, +            <property name="illegalPkgs" value="junit" />, +            <message key="import.illegal" value="Import from illegal package - {0}. Tests are written in JUnit 4, use org.junit.* equivalents." />, +        </module>, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import static org.junit.Assert.assertNotNull;, +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertTrue;, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertTrue;, +++ b/library/src/androidTest/java/com/bumptech/glide/load/MultiTransformationTest.java]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +, +    gifDrawable.stop();, +    drawableFromView.stop();]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }, +    }, +}, +, +subprojects {, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = 1.7, +        targetCompatibility = 1.7, +    }, +}, +, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java, +import com.bumptech.glide.load.engine.GlideException;, +   * @param e               The maybe {@code null} exception containing information about why the, +   *                        request failed., +  boolean onLoadFailed(GlideException e, Object model, Target<R> target, boolean isFirstResource);, +++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java, +import com.bumptech.glide.load.engine.GlideException;, +   * @param e               The maybe {@code null} exception containing information about why the, +   *                        request failed., +  boolean onLoadFailed(GlideException e, Object model, Target<R> target, boolean isFirstResource);, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +    if (requestListener == null || !requestListener.onLoadFailed(e, model, target,, +++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java, +import com.bumptech.glide.load.engine.GlideException;, +   * @param e               The maybe {@code null} exception containing information about why the, +   *                        request failed., +  boolean onLoadFailed(GlideException e, Object model, Target<R> target, boolean isFirstResource);, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +    if (requestListener == null || !requestListener.onLoadFailed(e, model, target,, +++ b/library/src/test/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.engine.GlideException;, +      public boolean onLoadFailed(GlideException e, Object model, Target target,, +++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java, +import com.bumptech.glide.load.engine.GlideException;, +   * @param e               The maybe {@code null} exception containing information about why the, +   *                        request failed., +  boolean onLoadFailed(GlideException e, Object model, Target<R> target, boolean isFirstResource);, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +    if (requestListener == null || !requestListener.onLoadFailed(e, model, target,, +++ b/library/src/test/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.engine.GlideException;, +      public boolean onLoadFailed(GlideException e, Object model, Target target,, +++ b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java, +import static org.mockito.Matchers.isA;, +    Map<Class<?>, Transformation<?>>  transformations = new HashMap<>();, +    verify(harness.requestListener).onLoadFailed(isAGlideException(), isA(Number.class),, +        eq(harness.target), anyBoolean());, +    verify(harness.requestListener).onLoadFailed(isAGlideException(), any(Number.class),, +        eq(harness.target), anyBoolean());, +    verify(harness.requestListener).onLoadFailed(isAGlideException(), any(Number.class),, +        eq(harness.target), anyBoolean());, +    verify(harness.target).onResourceReady(eq(harness.result), anyTransition());, +    verify(harness.target).onResourceReady(eq(harness.result), anyTransition());, +    verify(harness.target, never()).onResourceReady(any(List.class), anyTransition());, +    when(harness.requestListener.onLoadFailed(isAGlideException(), any(Number.class),, +        eq(harness.target), anyBoolean())), +    when(harness.requestListener.onLoadFailed(isAGlideException(), any(Number.class),, +        eq(harness.target), anyBoolean())), +        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(), anyBoolean(),, +        .onResourceReady(any(List.class), eq(harness.model), isAListTarget(), anyBoolean(),, +        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(), eq(true),, +        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(), eq(false),, +        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(), anyBoolean(),, +        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(), anyBoolean(),, +        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(),, +            anyBoolean(), eq(false));, +    Transition<List> transition = mockTransition();, +    verify(harness.target, times(2)).onResourceReady(eq(harness.result), anyTransition());, +  @SuppressWarnings("unchecked"), +  private static <T> Transition<T> mockTransition() {, +    return mock(Transition.class);, +  }, +, +  @SuppressWarnings("unchecked"), +  private static Target<List> isAListTarget() {, +    return isA(Target.class);, +  }, +, +  private static GlideException isAGlideException() {, +    return isA(GlideException.class);, +  }, +, +  @SuppressWarnings("unchecked"), +  private static <T> Transition<T> anyTransition() {, +    return any(Transition.class);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java, +import com.bumptech.glide.load.engine.GlideException;, +   * @param e               The maybe {@code null} exception containing information about why the, +   *                        request failed., +  boolean onLoadFailed(GlideException e, Object model, Target<R> target, boolean isFirstResource);, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +    if (requestListener == null || !requestListener.onLoadFailed(e, model, target,, +++ b/library/src/test/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.engine.GlideException;, +      public boolean onLoadFailed(GlideException e, Object model, Target target,, +++ b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java, +import static org.mockito.Matchers.isA;, +    Map<Class<?>, Transformation<?>>  transformations = new HashMap<>();, +    verify(harness.requestListener).onLoadFailed(isAGlideException(), isA(Number.class),, +        eq(harness.target), anyBoolean());, +    verify(harness.requestListener).onLoadFailed(isAGlideException(), any(Number.class),, +        eq(harness.target), anyBoolean());, +    verify(harness.requestListener).onLoadFailed(isAGlideException(), any(Number.class),, +        eq(harness.target), anyBoolean());, +    verify(harness.target).onResourceReady(eq(harness.result), anyTransition());, +    verify(harness.target).onResourceReady(eq(harness.result), anyTransition());, +    verify(harness.target, never()).onResourceReady(any(List.class), anyTransition());, +    when(harness.requestListener.onLoadFailed(isAGlideException(), any(Number.class),]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/ResourceRunnerFactoryTest.java, +package com.bumptech.glide.load.engine;, +, +import android.os.Handler;, +, +import com.bumptech.glide.Priority;, +import com.bumptech.glide.load.Encoder;, +import com.bumptech.glide.load.ResourceDecoder;, +import com.bumptech.glide.load.ResourceEncoder;, +import com.bumptech.glide.load.Transformation;, +import com.bumptech.glide.load.data.DataFetcher;, +import com.bumptech.glide.load.engine.cache.DiskCache;, +import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;, +, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;, +, +import java.io.File;, +import java.util.concurrent.ExecutorService;, +, +import static org.junit.Assert.assertNotNull;, +import static org.mockito.Mockito.mock;, +, +@RunWith(RobolectricTestRunner.class), +public class ResourceRunnerFactoryTest {, +    private DefaultFactoryHarness harness;, +, +    @Before, +    public void setUp() {, +        harness = new DefaultFactoryHarness();, +    }, +, +    @Test, +    public void testProducesNonNullRunners() {, +        assertNotNull(harness.build());, +    }, +, +    @SuppressWarnings("unchecked"), +    private class DefaultFactoryHarness {, +        EngineJobListener listener = mock(EngineJobListener.class);, +        DiskCache diskCache = mock(DiskCache.class);, +        Handler mainHandler = new Handler();, +        ExecutorService diskCacheService = mock(ExecutorService.class);, +        ExecutorService resizeService = mock(ExecutorService.class);, +        Transformation<Object> transformation = mock(Transformation.class);, +        int width = 100;, +        int height = 100;, +, +        ResourceRunnerFactory factory = new ResourceRunnerFactory(diskCache,, +                mainHandler, diskCacheService, resizeService);, +, +        ResourceDecoder<File, Object> cacheDecoder = mock(ResourceDecoder.class);, +        DataFetcher<Object> fetcher = mock(DataFetcher.class);, +        ResourceDecoder<Object, Object> decoder = mock(ResourceDecoder.class);, +        ResourceEncoder<Object> encoder = mock(ResourceEncoder.class);, +        Priority priority = Priority.LOW;, +        boolean isMemoryCacheable;, +        DiskCacheStrategy diskCacheStrategy;, +, +        public ResourceRunner build() {, +            return factory.build(mock(EngineKey.class), width, height, cacheDecoder, fetcher, mock(Encoder.class),, +                    decoder, transformation, encoder, mock(ResourceTranscoder.class), priority, isMemoryCacheable,, +                    diskCacheStrategy, listener);, +        }, +    }, +}, +++ /dev/null, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/ResourceRunnerFactoryTest.java, +package com.bumptech.glide.load.engine;, +, +import android.os.Handler;, +, +import com.bumptech.glide.Priority;, +import com.bumptech.glide.load.Encoder;, +import com.bumptech.glide.load.ResourceDecoder;, +import com.bumptech.glide.load.ResourceEncoder;, +import com.bumptech.glide.load.Transformation;, +import com.bumptech.glide.load.data.DataFetcher;, +import com.bumptech.glide.load.engine.cache.DiskCache;, +import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;, +, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;, +, +import java.io.File;, +import java.util.concurrent.ExecutorService;, +, +import static org.junit.Assert.assertNotNull;, +import static org.mockito.Mockito.mock;, +]
[+++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.load.resource.drawable.GlideDrawable;, +import com.bumptech.glide.request.animation.DrawableCrossFadeViewAnimation;, + * A class for creating a request to load a {@link GlideDrawable}., +        extends GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable>, +            LoadProvider<ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable> loadProvider, Glide glide,, +        super(context, model, loadProvider, GlideDrawable.class, glide, requestTracker, lifecycle);, +     * Loads and displays the {@link GlideDrawable} retrieved by the given thumbnail request if it finishes before this, +     * request. Best used for loading thumbnail {@link GlideDrawable}s that are smaller and will be loaded more quickly, +     * than the fullsize {@link GlideDrawable}. There are no guarantees about the order in which the requests will, +     * actually finish. However, if the thumb request completes after the full request, the thumb {@link GlideDrawable}, +     * will never replace the full image., +     *     you want an animation to occur when either the full {@link GlideDrawable} loads or the thumbnail loads,, +            GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable> thumbnailRequest) {, +     * Transform {@link GlideDrawable}s using the given, +     * Transform {@link GlideDrawable}s using {@link com.bumptech.glide.load.resource.bitmap.CenterCrop}., +     * Transform {@link GlideDrawable}s using {@link com.bumptech.glide.load.resource.bitmap.FitCenter}., +     * Transform {@link GlideDrawable}s using the given {@link android.graphics.Bitmap} transformations. Replaces any, +     * previous transformations., +    public DrawableRequestBuilder<ModelType> transcoder(, +            ResourceTranscoder<GifBitmapWrapper, GlideDrawable> transcoder) {, +        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory<GlideDrawable>());, +        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory<GlideDrawable>(duration));, +        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory<GlideDrawable>(animation, duration));, +        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory<GlideDrawable>(context, animationId,, +    public DrawableRequestBuilder<ModelType> listener(RequestListener<ModelType, GlideDrawable> requestListener) {, +    public Target<GlideDrawable> into(ImageView view) {, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.load.resource.drawable.GlideDrawable;, +import com.bumptech.glide.request.animation.DrawableCrossFadeViewAnimation;, + * A class for creating a request to load a {@link GlideDrawable}., +        extends GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable>, +            LoadProvider<ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable> loadProvider, Glide glide,, +        super(context, model, loadProvider, GlideDrawable.class, glide, requestTracker, lifecycle);, +     * Loads and displays the {@link GlideDrawable} retrieved by the given thumbnail request if it finishes before this, +     * request. Best used for loading thumbnail {@link GlideDrawable}s that are smaller and will be loaded more quickly, +     * than the fullsize {@link GlideDrawable}. There are no guarantees about the order in which the requests will, +     * actually finish. However, if the thumb request completes after the full request, the thumb {@link GlideDrawable}, +     * will never replace the full image., +     *     you want an animation to occur when either the full {@link GlideDrawable} loads or the thumbnail loads,, +            GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable> thumbnailRequest) {, +     * Transform {@link GlideDrawable}s using the given, +     * Transform {@link GlideDrawable}s using {@link com.bumptech.glide.load.resource.bitmap.CenterCrop}., +     * Transform {@link GlideDrawable}s using {@link com.bumptech.glide.load.resource.bitmap.FitCenter}., +     * Transform {@link GlideDrawable}s using the given {@link android.graphics.Bitmap} transformations. Replaces any, +     * previous transformations., +    public DrawableRequestBuilder<ModelType> transcoder(, +            ResourceTranscoder<GifBitmapWrapper, GlideDrawable> transcoder) {, +        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory<GlideDrawable>());, +        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory<GlideDrawable>(duration));, +        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory<GlideDrawable>(animation, duration));, +        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory<GlideDrawable>(context, animationId,, +    public DrawableRequestBuilder<ModelType> listener(RequestListener<ModelType, GlideDrawable> requestListener) {, +    public Target<GlideDrawable> into(ImageView view) {, +++ b/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java, +import com.bumptech.glide.load.resource.drawable.GlideDrawable;, +                        GlideDrawable.class, null),, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.load.resource.drawable.GlideDrawable;, +import com.bumptech.glide.request.animation.DrawableCrossFadeViewAnimation;, + * A class for creating a request to load a {@link GlideDrawable}., +        extends GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable>, +            LoadProvider<ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable> loadProvider, Glide glide,, +        super(context, model, loadProvider, GlideDrawable.class, glide, requestTracker, lifecycle);, +     * Loads and displays the {@link GlideDrawable} retrieved by the given thumbnail request if it finishes before this, +     * request. Best used for loading thumbnail {@link GlideDrawable}s that are smaller and will be loaded more quickly, +     * than the fullsize {@link GlideDrawable}. There are no guarantees about the order in which the requests will, +     * actually finish. However, if the thumb request completes after the full request, the thumb {@link GlideDrawable}, +     * will never replace the full image., +     *     you want an animation to occur when either the full {@link GlideDrawable} loads or the thumbnail loads,, +            GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable> thumbnailRequest) {, +     * Transform {@link GlideDrawable}s using the given, +     * Transform {@link GlideDrawable}s using {@link com.bumptech.glide.load.resource.bitmap.CenterCrop}., +     * Transform {@link GlideDrawable}s using {@link com.bumptech.glide.load.resource.bitmap.FitCenter}., +     * Transform {@link GlideDrawable}s using the given {@link android.graphics.Bitmap} transformations. Replaces any, +     * previous transformations., +    public DrawableRequestBuilder<ModelType> transcoder(, +            ResourceTranscoder<GifBitmapWrapper, GlideDrawable> transcoder) {, +        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory<GlideDrawable>());, +        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory<GlideDrawable>(duration));, +        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory<GlideDrawable>(animation, duration));, +        super.animate(new DrawableCrossFadeViewAnimation.DrawableCrossFadeFactory<GlideDrawable>(context, animationId,, +    public DrawableRequestBuilder<ModelType> listener(RequestListener<ModelType, GlideDrawable> requestListener) {, +    public Target<GlideDrawable> into(ImageView view) {, +++ b/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java, +import com.bumptech.glide.load.resource.drawable.GlideDrawable;, +                        GlideDrawable.class, null),, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.drawable.GlideDrawable;, +import com.bumptech.glide.load.resource.transcode.GlideBitmapDrawableTranscoder;, +        transcoderRegistry.register(GifBitmapWrapper.class, GlideDrawable.class,, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.load.resource.drawable.GlideDrawable;, +import com.bumptech.glide.request.animation.DrawableCrossFadeViewAnimation;, + * A class for creating a request to load a {@link GlideDrawable}., +        extends GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable>, +            LoadProvider<ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable> loadProvider, Glide glide,, +        super(context, model, loadProvider, GlideDrawable.class, glide, requestTracker, lifecycle);, +     * Loads and displays the {@link GlideDrawable} retrieved by the given thumbnail request if it finishes before this, +     * request. Best used for loading thumbnail {@link GlideDrawable}s that are smaller and will be loaded more quickly]
[+++ b/Makefile, +	cd library/volley && ant jar, +	cp library/volley/bin/volley.jar library/libs, +, +update-ant: setup, +++ b/Makefile, +	cd library/volley && ant jar, +	cp library/volley/bin/volley.jar library/libs, +, +update-ant: setup, +++ b/library/build.gradle, +    compile files('libs/volley.jar'), +++ b/Makefile, +	cd library/volley && ant jar, +	cp library/volley/bin/volley.jar library/libs, +, +update-ant: setup, +++ b/library/build.gradle, +    compile files('libs/volley.jar'), +++ b/library/project.properties, +++ b/Makefile, +	cd library/volley && ant jar, +	cp library/volley/bin/volley.jar library/libs, +, +update-ant: setup, +++ b/library/build.gradle, +    compile files('libs/volley.jar'), +++ b/library/project.properties, +++ b/library/tests/project.properties, +]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java, +    private GifHeaderParser parser;, +        this(context, bitmapPool, new GifHeaderParser());, +    }, +, +    GifResourceDecoder(Context context, BitmapPool bitmapPool, GifHeaderParser parser) {, +        this.parser = parser;, +        GifHeader header = parser.setData(data).parseHeader();, +, +        if (header.getNumFrames() <= 0) {, +            // If we couldn't decode the GIF, we will end up with a frame count of 0., +            return null;, +        }, +, +        GifData gifData = new GifData(context, bitmapPool, id, header, data, width, height);, +        return new GifDataResource(gifData);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java, +    private GifHeaderParser parser;, +        this(context, bitmapPool, new GifHeaderParser());, +    }, +, +    GifResourceDecoder(Context context, BitmapPool bitmapPool, GifHeaderParser parser) {, +        this.parser = parser;, +        GifHeader header = parser.setData(data).parseHeader();, +, +        if (header.getNumFrames() <= 0) {, +            // If we couldn't decode the GIF, we will end up with a frame count of 0., +            return null;, +        }, +, +        GifData gifData = new GifData(context, bitmapPool, id, header, data, width, height);, +        return new GifDataResource(gifData);, +++ b/library/src/test/java/com/bumptech/glide/GlideTest.java, +    public void testReceivesGif() throws IOException {, +        InputStream testGifData = openResource("test.gif");, +        mockUri(Uri.parse(fakeUri), testGifData);, +, +, +    public void testReceivesGifBytes() throws IOException {, +        InputStream testGifData = openResource("test.gif");, +        mockUri(Uri.parse(fakeUri), testGifData);, +, +    @Test, +    public void testByteData() {, +        byte[] data = new byte[] { 1, 2, 3, 4, 5, 6 };, +        Glide.with(getContext()).load(data).into(target);, +    private void mockUri(String uriString) {, +        mockUri(Uri.parse(uriString), null);, +    }, +        mockUri(uri, null);, +    }, +, +    private void mockUri(Uri uri, InputStream is) {, +        if (is == null) {, +            is = new ByteArrayInputStream(new byte[0]);, +        }, +        shadowContentResolver.registerInputStream(uri, is);, +, +    private InputStream openResource(String imageName) throws IOException {, +        return getClass().getResourceAsStream("/" + imageName);, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java, +    private GifHeaderParser parser;, +        this(context, bitmapPool, new GifHeaderParser());, +    }, +, +    GifResourceDecoder(Context context, BitmapPool bitmapPool, GifHeaderParser parser) {, +        this.parser = parser;, +        GifHeader header = parser.setData(data).parseHeader();, +, +        if (header.getNumFrames() <= 0) {, +            // If we couldn't decode the GIF, we will end up with a frame count of 0., +            return null;, +        }, +, +        GifData gifData = new GifData(context, bitmapPool, id, header, data, width, height);, +        return new GifDataResource(gifData);, +++ b/library/src/test/java/com/bumptech/glide/GlideTest.java, +    public void testReceivesGif() throws IOException {, +        InputStream testGifData = openResource("test.gif");, +        mockUri(Uri.parse(fakeUri), testGifData);, +, +, +    public void testReceivesGifBytes() throws IOException {, +        InputStream testGifData = openResource("test.gif");, +        mockUri(Uri.parse(fakeUri), testGifData);, +, +    @Test, +    public void testByteData() {, +        byte[] data = new byte[] { 1, 2, 3, 4, 5, 6 };, +        Glide.with(getContext()).load(data).into(target);, +    private void mockUri(String uriString) {, +        mockUri(Uri.parse(uriString), null);, +    }, +        mockUri(uri, null);, +    }, +, +    private void mockUri(Uri uri, InputStream is) {, +        if (is == null) {]
[+++ b/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java, +      // See https://errorprone.info/bugpattern/NarrowingCompoundAssignment., +++ b/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java, +      // See https://errorprone.info/bugpattern/NarrowingCompoundAssignment., +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java, +    // See https://errorprone.info/bugpattern/IntLongMath., +        // See https://errorprone.info/bugpattern/NarrowingCompoundAssignment., +++ b/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java, +      // See https://errorprone.info/bugpattern/NarrowingCompoundAssignment., +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java, +    // See https://errorprone.info/bugpattern/IntLongMath., +        // See https://errorprone.info/bugpattern/NarrowingCompoundAssignment., +++ b/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java, +      // See https://errorprone.info/bugpattern/NarrowingCompoundAssignment., +++ b/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java, +      // See https://errorprone.info/bugpattern/NarrowingCompoundAssignment., +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java, +    // See https://errorprone.info/bugpattern/IntLongMath., +        // See https://errorprone.info/bugpattern/NarrowingCompoundAssignment., +++ b/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java, +      // See https://errorprone.info/bugpattern/NarrowingCompoundAssignment., +++ b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java, +      // See https://errorprone.info/bugpattern/NarrowingCompoundAssignment.]
[+++ b/library/src/main/java/com/bumptech/glide/util/LruCache.java, +, +import java.util.Iterator;, +    Iterator<Map.Entry<T, Y>> cacheIterator;, +      cacheIterator  = cache.entrySet().iterator();, +      last = cacheIterator.next();, +      cacheIterator.remove();]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +    boolean isWeakRefCleared = false;, +        isWeakRefCleared = true;, +    if (!isWeakRefCleared) {, +      fail("Failed to clear weak ref.");, +    }, +]
[+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +  private GlideExecutor sourceUnlimitedExecutor;, +, +    sourceUnlimitedExecutor = GlideExecutor.newUnlimitedSourceExecutor();, +, +      engine = new Engine(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor,, +          sourceUnlimitedExecutor);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +  private GlideExecutor sourceUnlimitedExecutor;, +, +    sourceUnlimitedExecutor = GlideExecutor.newUnlimitedSourceExecutor();, +, +      engine = new Engine(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor,, +          sourceUnlimitedExecutor);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +      GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,, +      GlideExecutor sourceUnlimitedExecutor) {, +    this(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor,, +        null, null, null, null, null, null);, +      GlideExecutor sourceExecutor, GlideExecutor sourceUnlimitedExecutor, Map<Key, EngineJob> jobs,, +      EngineKeyFactory keyFactory, Map<Key, WeakReference<EngineResource<?>>> activeResources,, +      EngineJobFactory engineJobFactory, DecodeJobFactory decodeJobFactory,, +      ResourceRecycler resourceRecycler) {, +      engineJobFactory = new EngineJobFactory(diskCacheExecutor, sourceExecutor,, +          sourceUnlimitedExecutor, this);, +      boolean useUnlimitedSourceExecutorPool,, +    EngineJob<R> engineJob = engineJobFactory.build(key, isMemoryCacheable,, +        useUnlimitedSourceExecutorPool);, +    private final GlideExecutor sourceUnlimitedExecutor;, +            return new EngineJob<Object>(diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor,, +                listener, pool);, +        GlideExecutor sourceUnlimitedExecutor, EngineJobListener listener) {, +      this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;, +    <R> EngineJob<R> build(Key key, boolean isMemoryCacheable,, +        boolean useUnlimitedSourceGeneratorPool) {, +      return result.init(key, isMemoryCacheable, useUnlimitedSourceGeneratorPool);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +  private GlideExecutor sourceUnlimitedExecutor;, +, +    sourceUnlimitedExecutor = GlideExecutor.newUnlimitedSourceExecutor();, +, +      engine = new Engine(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor,, +          sourceUnlimitedExecutor);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +      GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,, +      GlideExecutor sourceUnlimitedExecutor) {, +    this(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor,, +        null, null, null, null, null, null);, +      GlideExecutor sourceExecutor, GlideExecutor sourceUnlimitedExecutor, Map<Key, EngineJob> jobs,, +      EngineKeyFactory keyFactory, Map<Key, WeakReference<EngineResource<?>>> activeResources,, +      EngineJobFactory engineJobFactory, DecodeJobFactory decodeJobFactory,, +      ResourceRecycler resourceRecycler) {, +      engineJobFactory = new EngineJobFactory(diskCacheExecutor, sourceExecutor,, +          sourceUnlimitedExecutor, this);, +      boolean useUnlimitedSourceExecutorPool,, +    EngineJob<R> engineJob = engineJobFactory.build(key, isMemoryCacheable,, +        useUnlimitedSourceExecutorPool);, +    private final GlideExecutor sourceUnlimitedExecutor;, +            return new EngineJob<Object>(diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor,, +                listener, pool);, +        GlideExecutor sourceUnlimitedExecutor, EngineJobListener listener) {, +      this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;, +    <R> EngineJob<R> build(Key key, boolean isMemoryCacheable,, +        boolean useUnlimitedSourceGeneratorPool) {, +      return result.init(key, isMemoryCacheable, useUnlimitedSourceGeneratorPool);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +  private final GlideExecutor sourceUnlimitedExecutor;, +  private boolean useUnlimitedSourceGeneratorPool;, +      GlideExecutor sourceUnlimitedExecutor,, +    this(diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor, listener, pool,, +        DEFAULT_FACTORY);, +      GlideExecutor sourceUnlimitedExecutor,, +    this.sourceUnlimitedExecutor = sourceUnlimitedExecutor;, +  EngineJob<R> init(Key key, boolean isCacheable, boolean useUnlimitedSourceGeneratorPool) {, +    this.useUnlimitedSourceGeneratorPool = useUnlimitedSourceGeneratorPool;, +    GlideExecutor executor = decodeJob.willDecodeFromCache(), +        ? diskCacheExecutor, +        : getActiveSourceExecutor();, +  private GlideExecutor getActiveSourceExecutor() {, +    return useUnlimitedSourceGeneratorPool ? sourceUnlimitedExecutor : sourceExecutor;, +  }, +, +    boolean isPendingJobRemoved = diskCacheExecutor.remove(decodeJob), +        || sourceExecutor.remove(decodeJob), +        || sourceUnlimitedExecutor.remove(decodeJob);, +      getActiveSourceExecutor().execute(job);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +  private GlideExecutor sourceUnlimitedExecutor;, +, +    sourceUnlimitedExecutor = GlideExecutor.newUnlimitedSourceExecutor();, +, +      engine = new Engine(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor,, +          sourceUnlimitedExecutor);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +      GlideExecutor diskCacheExecutor, GlideExecutor sourceExecutor,, +      GlideExecutor sourceUnlimitedExecutor) {, +    this(memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor,, +        null, null, null, null, null, null);, +      GlideExecutor sourceExecutor, GlideExecutor sourceUnlimitedExecutor, Map<Key, EngineJob> jobs,, +      EngineKeyFactory keyFactory, Map<Key, WeakReference<EngineResource<?>>> activeResources,]
[+++ b/library/build.gradle, +, +++ b/library/build.gradle, +, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.engine.EngineResource;, +        verify(target).onResourceReady(any(EngineResource.class), any(GlideAnimation.class));, +++ b/library/build.gradle, +, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.engine.EngineResource;, +        verify(target).onResourceReady(any(EngineResource.class), any(GlideAnimation.class));, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineJobTest.java, +import static org.mockito.Mockito.when;, +        verify(harness.cb).onResourceReady(eq(harness.engineResource));, +        verify(harness.listener).onEngineJobComplete(eq(harness.key), eq(harness.engineResource));, +            verify(cb).onResourceReady(eq(harness.engineResource));, +        verify(harness.engineResource).acquire(eq(harness.numCbs));, +        verify(harness.listener).onEngineJobComplete(eq(harness.key), (EngineResource) isNull());, +        verify(harness.engineResource).setCacheable(eq(harness.isCacheable));, +        verify(harness.engineResource).setCacheable(eq(harness.isCacheable));, +        verify(harness.engineResource, times(2)).acquire(eq(1));, +        verify(harness.engineResource, times(2)).acquire(eq(1));, +        EngineResource<Object> engineResource = mock(EngineResource.class);, +        EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);, +        EngineJob job;, +            when(factory.build(eq(resource))).thenReturn(engineResource);, +            job = new EngineJob(key, mainHandler, isCacheable, listener, factory);, +        EngineResource<Object> engineResource = mock(EngineResource.class);, +            EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);, +            when(factory.build(eq(resource))).thenReturn(engineResource);, +            EngineJob result = new EngineJob(key, mainHandler, isCacheable, listener, factory);, +++ b/library/build.gradle, +, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.engine.EngineResource;, +        verify(target).onResourceReady(any(EngineResource.class), any(GlideAnimation.class));, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineJobTest.java, +import static org.mockito.Mockito.when;, +        verify(harness.cb).onResourceReady(eq(harness.engineResource));, +        verify(harness.listener).onEngineJobComplete(eq(harness.key), eq(harness.engineResource));, +            verify(cb).onResourceReady(eq(harness.engineResource));, +        verify(harness.engineResource).acquire(eq(harness.numCbs));, +        verify(harness.listener).onEngineJobComplete(eq(harness.key), (EngineResource) isNull());, +        verify(harness.engineResource).setCacheable(eq(harness.isCacheable));, +        verify(harness.engineResource).setCacheable(eq(harness.isCacheable));, +        verify(harness.engineResource, times(2)).acquire(eq(1));, +        verify(harness.engineResource, times(2)).acquire(eq(1));, +        EngineResource<Object> engineResource = mock(EngineResource.class);, +        EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);, +        EngineJob job;, +            when(factory.build(eq(resource))).thenReturn(engineResource);, +            job = new EngineJob(key, mainHandler, isCacheable, listener, factory);, +        EngineResource<Object> engineResource = mock(EngineResource.class);, +            EngineJob.EngineResourceFactory factory = mock(EngineJob.EngineResourceFactory.class);, +            when(factory.build(eq(resource))).thenReturn(engineResource);, +            EngineJob result = new EngineJob(key, mainHandler, isCacheable, listener, factory);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineResourceTest.java, +package com.bumptech.glide.load.engine;, +, +import com.bumptech.glide.load.Key;, +import junit.framework.Assert;, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;, +, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertFalse;, +import static org.junit.Assert.assertTrue;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, +@RunWith(RobolectricTestRunner.class), +public class EngineResourceTest {, +    private EngineResource<Object> engineResource;, +    private EngineResource.ResourceListener listener;, +    private Key cacheKey = mock(Key.class);, +    private Resource<Object> resource;, +, +    @SuppressWarnings("unchecked"), +    @Before, +    public void setUp() {, +        resource = mock(Resource.class);, +        engineResource = new EngineResource<Object>(resource);, +        listener = mock(EngineResource.ResourceListener.class);, +        engineResource.setResourceListener(cacheKey, listener);, +    }, +, +    @Test, +    public void testCanAcquireAndRelease() {, +        engineResource.acquire(1);, +        engineResource.release();, +, +        verify(listener).onResourceReleased(cacheKey, engineResource);, +    }, +, +    @Test]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java, +        new GlideBuilder().setSourceExecutor(GlideExecutor.newUnlimitedSourceExecutor()));, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java, +        new GlideBuilder().setSourceExecutor(GlideExecutor.newUnlimitedSourceExecutor()));, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java, +  protected String actualCustomStringRepresentation() {, +    return getDisplayString(actual());, +    if (!actual().isMutable()) {, +    if (actual().isMutable()) {, +    if (actual().isRecycled()) {, +    if (!actual().sameAs(other)) {]
[+++ b/.idea/codeStyleSettings.xml, +            <package name="java" withSubpackages="true" static="true" />, +            <package name="java" withSubpackages="true" static="false" />]
[+++ b/library/src/com/bumptech/photos/resize/BitmapTracker.java, +import com.bumptech.photos.resize.cache.BitmapPool;, +    private final BitmapPool target;, +    public BitmapTracker(BitmapPool target, int bitmapsPerSize) {, +++ b/library/src/com/bumptech/photos/resize/BitmapTracker.java, +import com.bumptech.photos.resize.cache.BitmapPool;, +    private final BitmapPool target;, +    public BitmapTracker(BitmapPool target, int bitmapsPerSize) {, +++ b/library/src/com/bumptech/photos/resize/ImageManager.java, +import com.bumptech.photos.resize.cache.BitmapPool;, +    private final BitmapPool bitmapCache;, +            bitmapCache = new BitmapPool(options.maxPerSize);, +++ b/library/src/com/bumptech/photos/resize/BitmapTracker.java, +import com.bumptech.photos.resize.cache.BitmapPool;, +    private final BitmapPool target;, +    public BitmapTracker(BitmapPool target, int bitmapsPerSize) {, +++ b/library/src/com/bumptech/photos/resize/ImageManager.java, +import com.bumptech.photos.resize.cache.BitmapPool;, +    private final BitmapPool bitmapCache;, +            bitmapCache = new BitmapPool(options.maxPerSize);, +++ b/library/src/com/bumptech/photos/resize/ImageResizer.java, +import com.bumptech.photos.resize.cache.BitmapPool;, +    private final BitmapPool bitmapPool;, +    public ImageResizer(BitmapPool bitmapPool) {, +        this(bitmapPool, null);, +     * @param bitmapPool The cache to try to recycle {@link android.graphics.Bitmap}s from, +    public ImageResizer(BitmapPool bitmapPool, BitmapFactory.Options defaultOptions){, +        this.bitmapPool = bitmapPool;, +, +        if (bitmapPool != null) {, +            result = bitmapPool.get(width, height);, +++ b/library/src/com/bumptech/photos/resize/BitmapTracker.java, +import com.bumptech.photos.resize.cache.BitmapPool;, +    private final BitmapPool target;, +    public BitmapTracker(BitmapPool target, int bitmapsPerSize) {, +++ b/library/src/com/bumptech/photos/resize/ImageManager.java, +import com.bumptech.photos.resize.cache.BitmapPool;, +    private final BitmapPool bitmapCache;, +            bitmapCache = new BitmapPool(options.maxPerSize);, +++ b/library/src/com/bumptech/photos/resize/ImageResizer.java, +import com.bumptech.photos.resize.cache.BitmapPool;, +    private final BitmapPool bitmapPool;, +    public ImageResizer(BitmapPool bitmapPool) {, +        this(bitmapPool, null);, +     * @param bitmapPool The cache to try to recycle {@link android.graphics.Bitmap}s from, +    public ImageResizer(BitmapPool bitmapPool, BitmapFactory.Options defaultOptions){, +        this.bitmapPool = bitmapPool;, +, +        if (bitmapPool != null) {, +            result = bitmapPool.get(width, height);, +++ b/library/src/com/bumptech/photos/resize/cache/BitmapPool.java, +/*, + * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved., + */, +, +package com.bumptech.photos.resize.cache;, +, +import android.graphics.Bitmap;, +import com.bumptech.photos.util.Log;, +, +import java.util.ArrayDeque;, +import java.util.HashMap;, +import java.util.Map;, +import java.util.Queue;, +, +/**, + * A cache of Bitmaps made available by size used to manage recycled bitmaps, + */, +public class BitmapPool {, +    private static final int DEFAULT_MAX_PER_SIZE = 20;, +    private Map<String, Queue<Bitmap>> availableBitmaps = new HashMap<String, Queue<Bitmap>>();, +    private final int maxPerSize;, +, +    public BitmapPool(int maxPerSize) {, +        this.maxPerSize = maxPerSize == 0 ? DEFAULT_MAX_PER_SIZE : maxPerSize;, +    }, +, +    public synchronized void put(Bitmap bitmap) {, +        final String sizeKey = getSizeKey(bitmap.getWidth(), bitmap.getHeight());, +        Queue<Bitmap> available = availableBitmaps.get(sizeKey);, +        if (available == null) {, +            available = new ArrayDeque<Bitmap>();, +            availableBitmaps.put(sizeKey, available);, +        }, +, +        if (available.size() < maxPerSize) {, +            available.offer(bitmap);, +        }, +    }, +, +    public synchronized Bitmap get(int width, int height) {, +        final String sizeKey = getSizeKey(width, height);, +        final Queue<Bitmap> available = availableBitmaps.get(sizeKey);, +, +        if (available == null) {, +            Log.d("SBC: missing bitmap for key= " + sizeKey);, +            return null;, +        } else {, +            //Log.d("SBC:  get key=" + sizeKey + " available=" + (available.size() - 1));, +            return available.poll();]
[+++ b/README.md, +You can download a jar from GitHub's [release page](https://github.com/bumptech/glide/releases)., +    compile 'com.github.bumptech.glide:glide:3.3.+', +  <version>3.3.1</version>, +Checkout the [GitHub wiki](https://github.com/bumptech/glide/wiki) for pages on a variety of topics, and see the [javadocs](http://bumptech.github.io/glide/javadocs/latest/index.html)., +Volley is now an optional dependency that can be included via a utility library. To use Volley to fetch media over http/https:, +    compile 'com.github.bumptech.glide:volley-integration:1.0.+', +    <version>1.0.1</version>, +In addition to Volley, Glide also includes support for fetching media using OkHttp. To use OkHttp to fetch media over http/https:, +    compile 'com.github.bumptech.glide:okhttp-integration:1.0.+', +    <version>1.0.1</version>, +Version 3.x is a stable public release used in multiple open source projects at Google including in the Android Camera app and in the 2014 Google IO app. Comments/bugs/questions/pull requests welcome!, +Note: Make sure your Android SDK has the Android Support Repository installed, and that your `$ANDROID_HOME` environment variable is pointing at the SDK or add a `local.properties` file in the root project with a `sdk.dir=...` line., +Follow the steps in the 'Build' section to setup the project and then edit the files however you wish. Intellij's [IDEA 14 early access build](http://confluence.jetbrains.com/display/IDEADEV/IDEA+14+EAP) cleanly imports both Glide's source and tests and is the recommended way to work with Glide. Earlier versions of intellij do not import the gradle project cleanly. Although Android Studio imports the source cleanly, it is not possible to run or debug the tests without manually modifying the tests' classpath., +4. Select settings.gradle., +To report a specific problem or feature request, [open a new issue on Github](https://github.com/bumptech/glide/issues/new). For questions, suggestions, or anything else, join or email [Glide's discussion group](https://groups.google.com/forum/#!forum/glidelibrary), +Before submitting pull requests, contributors must sign Google's [individual contribution license agreement](https://developers.google.com/open-source/cla/individual)., +* The Android team and Jake Wharton for the [disk cache implementation](https://github.com/JakeWharton/DiskLruCache) Glide's disk cache is based on., +* Dave Smith for the [gif decoder gist](https://gist.github.com/devunwired/4479231) Glide's gif decoder is based on., +* Chris Banes for his [gradle-mvn-push](https://github.com/chrisbanes/gradle-mvn-push) script., +* Corey Hall for Glide's [amazing logo](static/glide_logo.png)., +++ b/README.md, +You can download a jar from GitHub's [release page](https://github.com/bumptech/glide/releases)., +    compile 'com.github.bumptech.glide:glide:3.3.+', +  <version>3.3.1</version>, +Checkout the [GitHub wiki](https://github.com/bumptech/glide/wiki) for pages on a variety of topics, and see the [javadocs](http://bumptech.github.io/glide/javadocs/latest/index.html)., +Volley is now an optional dependency that can be included via a utility library. To use Volley to fetch media over http/https:, +    compile 'com.github.bumptech.glide:volley-integration:1.0.+', +    <version>1.0.1</version>, +In addition to Volley, Glide also includes support for fetching media using OkHttp. To use OkHttp to fetch media over http/https:, +    compile 'com.github.bumptech.glide:okhttp-integration:1.0.+', +    <version>1.0.1</version>, +Version 3.x is a stable public release used in multiple open source projects at Google including in the Android Camera app and in the 2014 Google IO app. Comments/bugs/questions/pull requests welcome!, +Note: Make sure your Android SDK has the Android Support Repository installed, and that your `$ANDROID_HOME` environment variable is pointing at the SDK or add a `local.properties` file in the root project with a `sdk.dir=...` line., +Follow the steps in the 'Build' section to setup the project and then edit the files however you wish. Intellij's [IDEA 14 early access build](http://confluence.jetbrains.com/display/IDEADEV/IDEA+14+EAP) cleanly imports both Glide's source and tests and is the recommended way to work with Glide. Earlier versions of intellij do not import the gradle project cleanly. Although Android Studio imports the source cleanly, it is not possible to run or debug the tests without manually modifying the tests' classpath., +4. Select settings.gradle., +To report a specific problem or feature request, [open a new issue on Github](https://github.com/bumptech/glide/issues/new). For questions, suggestions, or anything else, join or email [Glide's discussion group](https://groups.google.com/forum/#!forum/glidelibrary), +Before submitting pull requests, contributors must sign Google's [individual contribution license agreement](https://developers.google.com/open-source/cla/individual)., +* The Android team and Jake Wharton for the [disk cache implementation](https://github.com/JakeWharton/DiskLruCache) Glide's disk cache is based on., +* Dave Smith for the [gif decoder gist](https://gist.github.com/devunwired/4479231) Glide's gif decoder is based on., +* Chris Banes for his [gradle-mvn-push](https://github.com/chrisbanes/gradle-mvn-push) script., +* Corey Hall for Glide's [amazing logo](static/glide_logo.png)., +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import static org.mockito.Mockito.atLeastOnce;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +import com.bumptech.glide.request.target.SizeReadyCallback;, +import com.bumptech.glide.request.target.Target;, +, +import org.junit.Before;, +import org.mockito.ArgumentCaptor;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +import org.mockito.verification.VerificationMode;, +import java.util.Arrays;, +    @Mock, +    private BitmapRequestBuilder request;, +, +    @Before, +    public void setUp() throws Exception {, +        MockitoAnnotations.initMocks(this);, +    }, +, +        final AtomicInteger calledCount = new AtomicInteger();, +, +            public List<Object> getPreloadItems(int position) {, +                final int count = calledCount.getAndIncrement();, +                assertEquals(11 + count, position);, +                return super.getPreloadItems(position);, +        assertEquals(10, calledCount.get());, +            objects.add(new Integer(i));, +            public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {, +            public List<Object> getPreloadItems(int position) {, +                return objects.subList(position - 11, position + 1 - 11);, +        preloader.onScroll(null, 1, 10, 20);, +        final AtomicInteger calledCount = new AtomicInteger();, +            public List<Object> getPreloadItems(int position) {, +                if (position >= 40) {, +                final int count = calledCount.getAndIncrement();, +                assertEquals(28 - count, position);, +                return super.getPreloadItems(position);, +            public int[] getPreloadSize(Object item, int adapterPostion, int itemPosition) {, +            public List<Object> getPreloadItems(int position) {, +                if (position == 40) {, +                    return null;, +                return objects.subList(position, position + 1);, +        preloader.onScroll(null, 30, 10, 10);, +        preloader.onScroll(null, 29, 10, 10);, +        final AtomicInteger calledCount = new AtomicInteger();, +            public List<Object> getPreloadItems(int position) {, +                final int count = calledCount.getAndIncrement();, +                assertEquals(26 + count, position);, +                return super.getPreloadItems(position);, +        final AtomicInteger calledCount = new AtomicInteger();, +            public List<Object> getPreloadItems(int position) {, +                if (position >= 17) {, +                final int count = calledCount.getAndIncrement();, +                assertEquals(5 - count, position);, +                return super.getPreloadItems(position);, +            public List<Object> getPreloadItems(int position) {]
[+++ b/library/src/main/java/com/bumptech/glide/BitmapOptions.java, +package com.bumptech.glide;, +, +interface BitmapOptions {, +, +    public GenericRequestBuilder<?, ?, ?, ?> fitCenter();, +, +    public GenericRequestBuilder<?, ?, ?, ?> centerCrop();, +, +}, +++ b/library/src/main/java/com/bumptech/glide/BitmapOptions.java, +package com.bumptech.glide;, +, +interface BitmapOptions {, +, +    public GenericRequestBuilder<?, ?, ?, ?> fitCenter();, +, +    public GenericRequestBuilder<?, ?, ?, ?> centerCrop();, +, +}, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.request.animation.ViewPropertyAnimation;, +        extends GenericRequestBuilder<ModelType, ImageVideoWrapper, Bitmap, TranscodeType> implements BitmapOptions {, +     * @return This request builder., +     * @return This request builder., +     * Load images at a size that is at most exactly as big as the target using, +     * {@link com.bumptech.glide.load.resource.bitmap.Downsampler#AT_MOST}., +     *, +     * @see #downsample(com.bumptech.glide.load.resource.bitmap.Downsampler), +     *, +     * @return This request builder., +     */, +    public BitmapRequestBuilder<ModelType, TranscodeType> atMost() {, +        return downsample(Downsampler.AT_MOST);, +    }, +, +    /**, +     * @param downsampler The downsampler., +     * @return This request builder., +    /**, +     * {@inheritDoc}, +     */, +    /**, +     * Loads and displays the {@link android.graphics.Bitmap} retrieved by the given thumbnail request if it finishes, +     * before this request. Best used for loading thumbnail {@link Bitmap}s that are smaller and will be loaded more, +     * quickly than the fullsize {@link Bitmap}. There are no guarantees about the order in which the requests will, +     * actually finish. However, if the thumb request completes after the full request, the thumb, +     * {@link android.graphics.Bitmap} will never replace the full image., +     *, +     * @see #thumbnail(float), +     *, +     * <p>, +     *     Note - Any options on the main request will not be passed on to the thumbnail request. For example, if, +     *     you want an animation to occur when either the full {@link android.graphics.Bitmap} loads or the thumbnail, +     *     loads, you need to call {@link #animate(int)} on both the thumb and the full request. For a simpler thumbnail, +     *     option where these options are applied to the humbnail as well, see {@link #thumbnail(float)}., +     * </p>, +     *, +     * <p>, +     *     Only the thumbnail call on the main request will be obeyed, recursive calls to this method are ignored., +     * </p>, +     *, +     * @param thumbnailRequest The request to use to load the thumbnail., +     * @return This request builder., +     */, +    /**, +     * {@inheritDoc}, +     */, +    /**, +     * {@inheritDoc}, +     */, +    /**, +     * {@inheritDoc}, +     */, +    /**, +     * {@inheritDoc}, +     */, +    /**, +     * Sets the {@link com.bumptech.glide.load.ResourceDecoder} that will be used to decode {@link Bitmap}s obtained, +     * from an {@link java.io.InputStream}., +     *, +     * @see #videoDecoder, +     *, +     * @param decoder The decoder to use to decode {@link Bitmap}s., +     * @return This request builder., +     */, +    /**, +     * Sets the {@link com.bumptech.glide.load.ResourceDecoder} that will be used to decode {@link Bitmap}s obtained, +     * from an {@link android.os.ParcelFileDescriptor}., +     *, +     * @param decoder The decoder to use to decode {@link Bitmap}s., +     * @return This request builder., +     */, +     * @return This request builder., +     * @return This request builder., +    /**, +     * {@inheritDoc}, +     */, +    /**, +     * {@inheritDoc}]
[+++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +                null, glide, null, null);, +++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +                null, glide, null, null);, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +        new GenericRequestBuilder(null, Object.class, Object.class, mock(Glide.class),, +++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +                null, glide, null, null);, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +        new GenericRequestBuilder(null, Object.class, Object.class, mock(Glide.class),, +++ b/library/src/androidTest/java/com/bumptech/glide/GifTypeRequestTest.java, +                null, glide, null, null);, +++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +                null, glide, null, null);, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +        new GenericRequestBuilder(null, Object.class, Object.class, mock(Glide.class),, +++ b/library/src/androidTest/java/com/bumptech/glide/GifTypeRequestTest.java, +                null, glide, null, null);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +                null, glide, null, null);, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +        new GenericRequestBuilder(null, Object.class, Object.class, mock(Glide.class),, +++ b/library/src/androidTest/java/com/bumptech/glide/GifTypeRequestTest.java, +                null, glide, null, null);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +                null, glide, null, null);, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +        new GenericRequestBuilder(null, Object.class, Object.class, mock(Glide.class),, +++ b/library/src/androidTest/java/com/bumptech/glide/GifTypeRequestTest.java, +                null, glide, null, null);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java, +                any(Transformation.class), any(ResourceTranscoder.class),, +                any(Transformation.class), any(ResourceTranscoder.class),, +                any(Transformation.class), any(ResourceTranscoder.class),, +                any(Transformation.class), any(ResourceTranscoder.class),, +                any(DataFetcher.class), any(Transformation.class),, +                any(Transformation.class), any(ResourceTranscoder.class),, +                any(Transformation.class), any(ResourceTranscoder.class),, +++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +                null, glide, null, null);, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +        new GenericRequestBuilder(null, Object.class, Object.class, mock(Glide.class),, +++ b/library/src/androidTest/java/com/bumptech/glide/GifTypeRequestTest.java, +                null, glide, null, null);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java, +                any(Transformation.class), any(ResourceTranscoder.class),, +                any(Transformation.class), any(ResourceTranscoder.class),, +                any(Transformation.class), any(ResourceTranscoder.class),, +                any(Transformation.class), any(ResourceTranscoder.class),, +                any(DataFetcher.class), any(Transformation.class),, +                any(Transformation.class), any(ResourceTranscoder.class),, +                any(Transformation.class), any(ResourceTranscoder.class),, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +                null, glide, null, null);, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +        new GenericRequestBuilder(null, Object.class, Object.class, mock(Glide.class),, +++ b/library/src/androidTest/java/com/bumptech/glide/GifTypeRequestTest.java, +                null, glide, null, null);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java, +                any(Transformation.class), any(ResourceTranscoder.class),, +                any(Transformation.class), any(ResourceTranscoder.class),, +                any(Transformation.class), any(ResourceTranscoder.class),, +                any(Transformation.class), any(ResourceTranscoder.class),, +                any(DataFetcher.class), any(Transformation.class),, +                any(Transformation.class), any(ResourceTranscoder.class),, +                any(Transformation.class), any(ResourceTranscoder.class),, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +                null, glide, null, null);, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +        new GenericRequestBuilder(null, Object.class, Object.class, mock(Glide.class),, +++ b/library/src/androidTest/java/com/bumptech/glide/GifTypeRequestTest.java, +                null, glide, null, null);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java, +                any(Transformation.class), any(ResourceTranscoder.class),, +                any(Transformation.class), any(ResourceTranscoder.class),, +                any(Transformation.class), any(ResourceTranscoder.class),, +                any(Transformation.class), any(ResourceTranscoder.class),, +                any(DataFetcher.class), any(Transformation.class),, +                any(Transformation.class), any(ResourceTranscoder.class),, +                any(Transformation.class), any(ResourceTranscoder.class),, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ /dev/null, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +                null, glide, null, null);, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java]
[+++ b/library/src/main/java/com/bumptech/glide/load/Key.java, +    @Override, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/load/Key.java, +    @Override, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +++ b/library/src/main/java/com/bumptech/glide/load/Key.java, +    @Override, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java, +    private static <K, V> void updateEntry(LinkedEntry<K, V> entry) {, +    private static <K, V> void removeEntry(LinkedEntry<K, V> entry) {, +++ b/library/src/main/java/com/bumptech/glide/load/Key.java, +    @Override, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java, +    private static <K, V> void updateEntry(LinkedEntry<K, V> entry) {, +    private static <K, V> void removeEntry(LinkedEntry<K, V> entry) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullDecoder.java, +    private static final NullDecoder<?, ?> NULL_DECODER = new NullDecoder<Object, Object>();, +++ b/library/src/main/java/com/bumptech/glide/load/Key.java, +    @Override, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java, +    private static <K, V> void updateEntry(LinkedEntry<K, V> entry) {, +    private static <K, V> void removeEntry(LinkedEntry<K, V> entry) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullDecoder.java, +    private static final NullDecoder<?, ?> NULL_DECODER = new NullDecoder<Object, Object>();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullEncoder.java, +    private static final NullEncoder<?> NULL_ENCODER = new NullEncoder<Object>();, +++ b/library/src/main/java/com/bumptech/glide/load/Key.java, +    @Override, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java, +    private static <K, V> void updateEntry(LinkedEntry<K, V> entry) {, +    private static <K, V> void removeEntry(LinkedEntry<K, V> entry) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullDecoder.java, +    private static final NullDecoder<?, ?> NULL_DECODER = new NullDecoder<Object, Object>();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullEncoder.java, +    private static final NullEncoder<?> NULL_ENCODER = new NullEncoder<Object>();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullResourceEncoder.java, +    private static final NullResourceEncoder<?> NULL_ENCODER = new NullResourceEncoder<Object>();, +++ b/library/src/main/java/com/bumptech/glide/load/Key.java, +    @Override, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java, +    private static <K, V> void updateEntry(LinkedEntry<K, V> entry) {, +    private static <K, V> void removeEntry(LinkedEntry<K, V> entry) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullDecoder.java, +    private static final NullDecoder<?, ?> NULL_DECODER = new NullDecoder<Object, Object>();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullEncoder.java, +    private static final NullEncoder<?> NULL_ENCODER = new NullEncoder<Object>();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullResourceEncoder.java, +    private static final NullResourceEncoder<?> NULL_ENCODER = new NullResourceEncoder<Object>();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java, +    private static final Transformation<?> TRANSFORMATION = new UnitTransformation<Object>();, +++ b/library/src/main/java/com/bumptech/glide/load/Key.java, +    @Override, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java, +    private static <K, V> void updateEntry(LinkedEntry<K, V> entry) {, +    private static <K, V> void removeEntry(LinkedEntry<K, V> entry) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullDecoder.java, +    private static final NullDecoder<?, ?> NULL_DECODER = new NullDecoder<Object, Object>();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullEncoder.java, +    private static final NullEncoder<?> NULL_ENCODER = new NullEncoder<Object>();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullResourceEncoder.java, +    private static final NullResourceEncoder<?> NULL_ENCODER = new NullResourceEncoder<Object>();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java, +    private static final Transformation<?> TRANSFORMATION = new UnitTransformation<Object>();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java, +    private static final UnitTranscoder<?> UNIT_TRANSCODER = new UnitTranscoder<Object>();, +++ b/library/src/main/java/com/bumptech/glide/load/Key.java, +    @Override, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java, +    private static <K, V> void updateEntry(LinkedEntry<K, V> entry) {, +    private static <K, V> void removeEntry(LinkedEntry<K, V> entry) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullDecoder.java, +    private static final NullDecoder<?, ?> NULL_DECODER = new NullDecoder<Object, Object>();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullEncoder.java, +    private static final NullEncoder<?> NULL_ENCODER = new NullEncoder<Object>();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullResourceEncoder.java, +    private static final NullResourceEncoder<?> NULL_ENCODER = new NullResourceEncoder<Object>();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/UnitTransformation.java, +    private static final Transformation<?> TRANSFORMATION = new UnitTransformation<Object>();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/UnitTranscoder.java, +    private static final UnitTranscoder<?> UNIT_TRANSCODER = new UnitTranscoder<Object>();, +++ b/library/src/main/java/com/bumptech/glide/provider/EmptyDataLoadProvider.java, +import java.io.File;, +, + *]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +        callback.onLoadFailed(e);, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +        callback.onLoadFailed(e);, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +      callback.onLoadFailed(volleyError);, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +        callback.onLoadFailed(e);, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +      callback.onLoadFailed(volleyError);, +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static org.mockito.Matchers.isA;, +import com.android.volley.VolleyError;, +    doAnswer(new CountDown()).when(callback).onDataReady(any(InputStream.class));, +    doAnswer(new CountDown()).when(callback).onLoadFailed(any(Exception.class));, +  public void testCallsLoadFailedIfRedirectLocationIsEmpty() throws Exception {, +    verify(callback).onLoadFailed(isA(VolleyError.class));, +  public void testCallsLoadFailedIfStatusCodeIsNegativeOne() throws Exception {, +    verify(callback).onLoadFailed(isA(VolleyError.class));, +  public void testCallsLoadFailedAfterTooManyRedirects() throws Exception {, +    verify(callback).onLoadFailed(isA(VolleyError.class));, +  public void testCallsLoadFailedIfStatusCodeIs500() throws Exception {, +    verify(callback).onLoadFailed(isA(VolleyError.class));, +  public void testCallsLoadFailedIfStatusCodeIs400() throws Exception {, +    verify(callback).onLoadFailed(isA(VolleyError.class));, +  private class CountDown implements Answer<Void> {, +, +    @Override, +    public Void answer(InvocationOnMock invocation) throws Throwable {, +      waitForResponseLatch.countDown();, +      return null;, +    }, +  }, +, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +        callback.onLoadFailed(e);, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +      callback.onLoadFailed(volleyError);, +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static org.mockito.Matchers.isA;, +import com.android.volley.VolleyError;, +    doAnswer(new CountDown()).when(callback).onDataReady(any(InputStream.class));, +    doAnswer(new CountDown()).when(callback).onLoadFailed(any(Exception.class));, +  public void testCallsLoadFailedIfRedirectLocationIsEmpty() throws Exception {, +    verify(callback).onLoadFailed(isA(VolleyError.class));, +  public void testCallsLoadFailedIfStatusCodeIsNegativeOne() throws Exception {, +    verify(callback).onLoadFailed(isA(VolleyError.class));, +  public void testCallsLoadFailedAfterTooManyRedirects() throws Exception {, +    verify(callback).onLoadFailed(isA(VolleyError.class));, +  public void testCallsLoadFailedIfStatusCodeIs500() throws Exception {, +    verify(callback).onLoadFailed(isA(VolleyError.class));, +  public void testCallsLoadFailedIfStatusCodeIs400() throws Exception {, +    verify(callback).onLoadFailed(isA(VolleyError.class));, +  private class CountDown implements Answer<Void> {, +, +    @Override, +    public Void answer(InvocationOnMock invocation) throws Throwable {, +      waitForResponseLatch.countDown();, +      return null;, +    }, +  }, +, +++ b/library/findbugs-exclude.xml, +    <Match>, +       <Class name="com.bumptech.glide.load.engine.GlideException$IndentedPrintStream" />, +       <Bug pattern="DM_DEFAULT_ENCODING" />, +    </Match>, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +        callback.onLoadFailed(e);, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +      callback.onLoadFailed(volleyError);, +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static org.mockito.Matchers.isA;, +import com.android.volley.VolleyError;, +    doAnswer(new CountDown()).when(callback).onDataReady(any(InputStream.class));, +    doAnswer(new CountDown()).when(callback).onLoadFailed(any(Exception.class));, +  public void testCallsLoadFailedIfRedirectLocationIsEmpty() throws Exception {, +    verify(callback).onLoadFailed(isA(VolleyError.class));, +  public void testCallsLoadFailedIfStatusCodeIsNegativeOne() throws Exception {, +    verify(callback).onLoadFailed(isA(VolleyError.class));, +  public void testCallsLoadFailedAfterTooManyRedirects() throws Exception {, +    verify(callback).onLoadFailed(isA(VolleyError.class));, +  public void testCallsLoadFailedIfStatusCodeIs500() throws Exception {, +    verify(callback).onLoadFailed(isA(VolleyError.class));, +  public void testCallsLoadFailedIfStatusCodeIs400() throws Exception {, +    verify(callback).onLoadFailed(isA(VolleyError.class));, +  private class CountDown implements Answer<Void> {, +, +    @Override, +    public Void answer(InvocationOnMock invocation) throws Throwable {, +      waitForResponseLatch.countDown();, +      return null;, +    }, +  }, +, +++ b/library/findbugs-exclude.xml, +    <Match>, +       <Class name="com.bumptech.glide.load.engine.GlideException$IndentedPrintStream" />, +       <Bug pattern="DM_DEFAULT_ENCODING" />, +    </Match>]
[+++ b/.gitignore, +.gradle, +build, +*.iws, +doc/**, +bin/**, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +*.swo, +samples/flickr/target, +integration/volley/target/**, +**/local.properties, +**/out/**, +**/gen-external-apklibs/**, +++ b/.gitignore, +.gradle, +build, +*.iws, +doc/**, +bin/**, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +*.swo, +samples/flickr/target, +integration/volley/target/**, +**/local.properties, +**/out/**, +**/gen-external-apklibs/**, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +[submodule "third_party/disklrucache"], +	path = third_party/disklrucache, +	url = https://github.com/sjudd/DiskLruCache.git, +++ b/.gitignore, +.gradle, +build, +*.iws, +doc/**, +bin/**, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +*.swo, +samples/flickr/target, +integration/volley/target/**, +**/local.properties, +**/out/**, +**/gen-external-apklibs/**, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +[submodule "third_party/disklrucache"], +	path = third_party/disklrucache, +	url = https://github.com/sjudd/DiskLruCache.git, +++ b/.travis.yml, +language: android, +android:, +  components:, +    - build-tools-19.1.0, +  licenses: , +    - 'android-sdk-license.*', +, +script: 'travis_retry ./gradlew build', +++ b/.gitignore, +.gradle, +build, +*.iws, +doc/**, +bin/**, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +*.swo, +samples/flickr/target, +integration/volley/target/**, +**/local.properties, +**/out/**, +**/gen-external-apklibs/**, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +[submodule "third_party/disklrucache"], +	path = third_party/disklrucache, +	url = https://github.com/sjudd/DiskLruCache.git, +++ b/.travis.yml, +language: android, +android:, +  components:, +    - build-tools-19.1.0, +  licenses: , +    - 'android-sdk-license.*', +]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +   * Returns a {@link RequestOptions} object with {@link #centerCrop(Context)} set.]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }, +    }, +}, +, +subprojects {, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = 1.7, +        targetCompatibility = 1.7, +    }, +}, +, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }]
[+++ b/library/src/androidTest/java/com/bumptech/glide/request/SingleRequestTest.java, +      when(requestContext.getModel()).thenReturn(model);, +      when(requestContext.getTranscodeClass()).thenReturn(List.class);, +      when(requestContext.getErrorDrawable()).thenReturn(errorDrawable);, +      when(requestContext.getPlaceholderDrawable()).thenReturn(placeholderDrawable);, +      when(requestContext.getOverrideWidth()).thenReturn(overrideWidth);, +      when(requestContext.getOverrideHeight()).thenReturn(overrideHeight);, +      when(requestContext.getSizeMultiplier()).thenReturn(1f);, +, +          .obtain(requestContext, target, requestListener, requestCoordinator, engine, factory);, +++ b/library/src/androidTest/java/com/bumptech/glide/request/SingleRequestTest.java, +      when(requestContext.getModel()).thenReturn(model);, +      when(requestContext.getTranscodeClass()).thenReturn(List.class);, +      when(requestContext.getErrorDrawable()).thenReturn(errorDrawable);, +      when(requestContext.getPlaceholderDrawable()).thenReturn(placeholderDrawable);, +      when(requestContext.getOverrideWidth()).thenReturn(overrideWidth);, +      when(requestContext.getOverrideHeight()).thenReturn(overrideHeight);, +      when(requestContext.getSizeMultiplier()).thenReturn(1f);, +, +          .obtain(requestContext, target, requestListener, requestCoordinator, engine, factory);, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +  private final GlideContext context;, +  private final Class<TranscodeType> transcodeClass;, +  private final RequestTracker requestTracker;, +  private final Lifecycle lifecycle;, +    model = other.model;, +    isModelSet = other.isModelSet;, +    requestOptions = other.requestOptions;, +    requestOptions.lock();, +  private Priority getThumbnailPriority(Priority current) {, +    switch (current) {, +    return buildRequestRecursive(target, null, transitionOptions, requestOptions.getPriority(),, +        requestOptions.getOverrideWidth(), requestOptions.getOverrideHeight());, +      ThumbnailRequestCoordinator parentCoordinator,, +      TransitionOptions<?, ? super TranscodeType> transitionOptions,, +      Priority priority, int overrideWidth, int overrideHeight) {, +, +      TransitionOptions<?, ? super TranscodeType> thumbTransitionOptions =, +          thumbnailBuilder.transitionOptions;, +      if (DEFAULT_ANIMATION_OPTIONS.equals(thumbTransitionOptions)) {, +        thumbTransitionOptions = transitionOptions;, +      Priority thumbPriority = thumbnailBuilder.requestOptions.isPrioritySet(), +          ? thumbnailBuilder.requestOptions.getPriority() : getThumbnailPriority(priority);, +      int thumbOverrideWidth = thumbnailBuilder.requestOptions.getOverrideWidth();, +      int thumbOverrideHeight = thumbnailBuilder.requestOptions.getOverrideHeight();, +      if (Util.isValidDimensions(overrideWidth, overrideHeight), +          && !thumbnailBuilder.requestOptions.isValidOverride()) {, +        thumbOverrideWidth = requestOptions.getOverrideWidth();, +        thumbOverrideHeight = requestOptions.getOverrideHeight();, +      Request fullRequest = obtainRequest(target, requestOptions, coordinator,, +          transitionOptions, priority, overrideWidth, overrideHeight);, +      Request thumbRequest = thumbnailBuilder.buildRequestRecursive(target, coordinator,, +          thumbTransitionOptions, thumbPriority, thumbOverrideWidth, thumbOverrideHeight);, +      Request fullRequest = obtainRequest(target, requestOptions, coordinator, transitionOptions,, +          priority, overrideWidth, overrideHeight);, +      BaseRequestOptions<?> thumbnailOptions = requestOptions.clone(), +          .sizeMultiplier(thumbSizeMultiplier);, +, +      Request thumbnailRequest = obtainRequest(target, thumbnailOptions, coordinator,, +          transitionOptions, getThumbnailPriority(priority), overrideWidth, overrideHeight);, +, +      return obtainRequest(target, requestOptions, parentCoordinator, transitionOptions, priority,, +          overrideWidth, overrideHeight);, +  private Request obtainRequest(Target<TranscodeType> target,, +      BaseRequestOptions<?> requestOptions, RequestCoordinator requestCoordinator,, +      TransitionOptions<?, ? super TranscodeType> transitionOptions, Priority priority,, +      int overrideWidth, int overrideHeight) {, +    requestOptions.lock();, +, +        new RequestContext<>(context, model, transcodeClass, requestOptions, priority,, +            overrideWidth, overrideHeight);, +    return SingleRequest.obtain(requestContext, target, requestListener, requestCoordinator,, +        context.getEngine(), transitionOptions.getTransitionFactory());, +++ b/library/src/androidTest/java/com/bumptech/glide/request/SingleRequestTest.java, +      when(requestContext.getModel()).thenReturn(model);, +      when(requestContext.getTranscodeClass()).thenReturn(List.class);, +      when(requestContext.getErrorDrawable()).thenReturn(errorDrawable);, +      when(requestContext.getPlaceholderDrawable()).thenReturn(placeholderDrawable);, +      when(requestContext.getOverrideWidth()).thenReturn(overrideWidth);, +      when(requestContext.getOverrideHeight()).thenReturn(overrideHeight);, +      when(requestContext.getSizeMultiplier()).thenReturn(1f);, +, +          .obtain(requestContext, target, requestListener, requestCoordinator, engine, factory);, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +  private final GlideContext context;, +  private final Class<TranscodeType> transcodeClass;, +  private final RequestTracker requestTracker;, +  private final Lifecycle lifecycle;, +    model = other.model;, +    isModelSet = other.isModelSet;, +    requestOptions = other.requestOptions;, +    requestOptions.lock();, +  private Priority getThumbnailPriority(Priority current) {, +    switch (current) {, +    return buildRequestRecursive(target, null, transitionOptions, requestOptions.getPriority(),, +        requestOptions.getOverrideWidth(), requestOptions.getOverrideHeight());, +      ThumbnailRequestCoordinator parentCoordinator,, +      TransitionOptions<?, ? super TranscodeType> transitionOptions,, +      Priority priority, int overrideWidth, int overrideHeight) {, +]
[+++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]src[/\\]androidTest[/\\].*" checks="[a-zA-Z0-9]*"/>, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]src[/\\]androidTest[/\\].*" checks="[a-zA-Z0-9]*"/>, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, + * Fetches an {@link InputStream} using the okhttp library., +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]src[/\\]androidTest[/\\].*" checks="[a-zA-Z0-9]*"/>, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, + * Fetches an {@link InputStream} using the okhttp library., +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java, +import static junit.framework.Assert.assertEquals;, +    //@org.junit.Ignore, +    // on windows it will fail because new FileOutputStream keeps to lock, +    //@org.junit.Ignore, +    // on windows it will fail because new FileOutputStream keeps to lock, +            assertEquals(length, is.read(result));, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]src[/\\]androidTest[/\\].*" checks="[a-zA-Z0-9]*"/>, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, + * Fetches an {@link InputStream} using the okhttp library., +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java, +import static junit.framework.Assert.assertEquals;, +    //@org.junit.Ignore, +    // on windows it will fail because new FileOutputStream keeps to lock, +    //@org.junit.Ignore, +    // on windows it will fail because new FileOutputStream keeps to lock, +            assertEquals(length, is.read(result));, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/StringLoaderTest.java, +import com.bumptech.glide.tests.Util;, +, +import static org.junit.Assume.assumeTrue;, +        // TODO on windows it will fail with schema being the drive letter (C:\... -> C), +        assumeTrue(!Util.isWindows());, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]src[/\\]androidTest[/\\].*" checks="[a-zA-Z0-9]*"/>, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, + * Fetches an {@link InputStream} using the okhttp library., +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java, +import static junit.framework.Assert.assertEquals;, +    //@org.junit.Ignore, +    // on windows it will fail because new FileOutputStream keeps to lock, +    //@org.junit.Ignore, +    // on windows it will fail because new FileOutputStream keeps to lock, +            assertEquals(length, is.read(result));, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/StringLoaderTest.java, +import com.bumptech.glide.tests.Util;, +, +import static org.junit.Assume.assumeTrue;, +        // TODO on windows it will fail with schema being the drive letter (C:\... -> C), +        assumeTrue(!Util.isWindows());, +++ b/library/src/androidTest/java/com/bumptech/glide/tests/Util.java, +, +    public static boolean isWindows() {, +        return System.getProperty("os.name").startsWith("Windows");, +    }, +]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +import com.google.common.base.Function;, +import com.google.common.collect.FluentIterable;, +import java.util.Set;, +import javax.lang.model.element.AnnotationMirror;, +import javax.tools.Diagnostic.Kind;, +    validateNewGlideOptionAnnotations(executableElement);, +  private void validateNewGlideOptionAnnotations(ExecutableElement executableElement) {, +    Set<String> annotationNames =, +        FluentIterable.from(executableElement.getAnnotationMirrors()), +            .transform(new Function<AnnotationMirror, String>() {, +              @Override, +              public String apply(AnnotationMirror input) {, +                return input.getAnnotationType().asElement().toString();, +              }, +            }), +            .toSet();, +    if (!annotationNames.contains("android.support.annotation.NonNull")) {, +      processingEnvironment.getMessager().printMessage(, +          Kind.WARNING,, +          executableElement.getEnclosingElement() + "#" + executableElement.getSimpleName(), +              + " is missing the @NonNull annotation,", +              + " please add it to ensure that your extension methods are always returning non-null", +              + " values");, +    }, +  }, +, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +import com.google.common.base.Function;, +import com.google.common.collect.FluentIterable;, +import java.util.Set;, +import javax.lang.model.element.AnnotationMirror;, +import javax.tools.Diagnostic.Kind;, +    validateNewGlideOptionAnnotations(executableElement);, +  private void validateNewGlideOptionAnnotations(ExecutableElement executableElement) {, +    Set<String> annotationNames =, +        FluentIterable.from(executableElement.getAnnotationMirrors()), +            .transform(new Function<AnnotationMirror, String>() {, +              @Override, +              public String apply(AnnotationMirror input) {, +                return input.getAnnotationType().asElement().toString();, +              }, +            }), +            .toSet();, +    if (!annotationNames.contains("android.support.annotation.NonNull")) {, +      processingEnvironment.getMessager().printMessage(, +          Kind.WARNING,, +          executableElement.getEnclosingElement() + "#" + executableElement.getSimpleName(), +              + " is missing the @NonNull annotation,", +              + " please add it to ensure that your extension methods are always returning non-null", +              + " values");, +    }, +  }, +, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java, +  private static final ClassName NON_NULL_CLASS_NAME =, +      ClassName.get("android.support.annotation", "NonNull");, +, +    builder.addAnnotation(AnnotationSpec.builder(NON_NULL_CLASS_NAME).build());, +    builder.addAnnotation(AnnotationSpec.builder(NON_NULL_CLASS_NAME).build());, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +import com.google.common.base.Function;, +import com.google.common.collect.FluentIterable;, +import java.util.Set;, +import javax.lang.model.element.AnnotationMirror;, +import javax.tools.Diagnostic.Kind;, +    validateNewGlideOptionAnnotations(executableElement);, +  private void validateNewGlideOptionAnnotations(ExecutableElement executableElement) {, +    Set<String> annotationNames =, +        FluentIterable.from(executableElement.getAnnotationMirrors()), +            .transform(new Function<AnnotationMirror, String>() {, +              @Override, +              public String apply(AnnotationMirror input) {, +                return input.getAnnotationType().asElement().toString();, +              }, +            }), +            .toSet();, +    if (!annotationNames.contains("android.support.annotation.NonNull")) {, +      processingEnvironment.getMessager().printMessage(, +          Kind.WARNING,, +          executableElement.getEnclosingElement() + "#" + executableElement.getSimpleName(), +              + " is missing the @NonNull annotation,", +              + " please add it to ensure that your extension methods are always returning non-null", +              + " values");, +    }, +  }, +, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java, +  private static final ClassName NON_NULL_CLASS_NAME =, +      ClassName.get("android.support.annotation", "NonNull");, +, +    builder.addAnnotation(AnnotationSpec.builder(NON_NULL_CLASS_NAME).build());, +    builder.addAnnotation(AnnotationSpec.builder(NON_NULL_CLASS_NAME).build());, +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java, +                "import android.support.annotation.NonNull;",, +                "  @NonNull",, +                "import android.support.annotation.NonNull;",, +                "import com.bumptech.glide.annotation.GlideExtension;",, +                "import com.bumptech.glide.annotation.GlideOption;",, +                "import com.bumptech.glide.request.RequestOptions;",]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +        if (!cacheKeys.contains(data.sourceKey)) {, +        }, +        for (int j = 0; j < data.alternateKeys.size(); j++) {, +          if (!cacheKeys.contains(data.alternateKeys.get(j))) {, +            cacheKeys.add(data.alternateKeys.get(j));, +          }, +        }]
[+++ b/gradle.properties, +VERSION_NAME=4.8.0-SNAPSHOT, +VERSION_MINOR=8, +VERSION_PATCH=0]
[+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ExifInterfaceImageHeaderParser.java, +import android.os.Build;, +import android.support.annotation.RequiresApi;, +@RequiresApi(Build.VERSION_CODES.O_MR1), +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ExifInterfaceImageHeaderParser.java, +import android.os.Build;, +import android.support.annotation.RequiresApi;, +@RequiresApi(Build.VERSION_CODES.O_MR1), +++ b/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java, +    final SingleRequest<List> request = builder.addRequestListener(listener1).build();]
[+++ b/library/src/main/java/com/bumptech/glide/request/FutureTarget.java, + * {@link java.util.concurrent.Future}. For example:, + *                                       .into(250, 250);]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/.gitmodules, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +++ b/.gitignore, +++ b/.gitmodules, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +++ b/Makefile, +, +glide-minus-volley:, +	cd library && ant clean && ant glide-minus-volley, +, +++ b/.gitignore, +++ b/.gitmodules, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +++ b/Makefile, +, +glide-minus-volley:, +	cd library && ant clean && ant glide-minus-volley, +, +++ b/library/AndroidManifest.xml, +          android:versionName="2.0.3" >, +  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" />, +++ b/.gitignore, +++ b/.gitmodules, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +++ b/Makefile, +, +glide-minus-volley:, +	cd library && ant clean && ant glide-minus-volley, +, +++ b/library/AndroidManifest.xml, +          android:versionName="2.0.3" >, +  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" />, +++ b/library/custom_rules.xml, +            <zipgroupfileset dir="libs" includes="*.jar" />, +        </jar>, +    </target>, +    <target name="glide-minus-volley" depends="-compile">, +        <jar destfile="bin/glide-minus-volley-${mymanifest.manifest.android:versionName}.jar", +            basedir="bin/classes", +            excludes="com/bumptech/glide/volley/">, +            <zipgroupfileset dir="libs" includes="disklrucache*.jar" />, +++ b/.gitignore, +++ b/.gitmodules, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +++ b/Makefile, +, +glide-minus-volley:, +	cd library && ant clean && ant glide-minus-volley, +, +++ b/library/AndroidManifest.xml, +          android:versionName="2.0.3" >, +  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" />, +++ b/library/custom_rules.xml, +            <zipgroupfileset dir="libs" includes="*.jar" />, +        </jar>, +    </target>, +    <target name="glide-minus-volley" depends="-compile">, +        <jar destfile="bin/glide-minus-volley-${mymanifest.manifest.android:versionName}.jar", +            basedir="bin/classes", +            excludes="com/bumptech/glide/volley/">, +            <zipgroupfileset dir="libs" includes="disklrucache*.jar" />, +++ /dev/null, +++ b/.gitignore, +++ b/.gitmodules, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +++ b/Makefile, +, +glide-minus-volley:, +	cd library && ant clean && ant glide-minus-volley, +, +++ b/library/AndroidManifest.xml, +          android:versionName="2.0.3" >, +  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" />, +++ b/library/custom_rules.xml, +            <zipgroupfileset dir="libs" includes="*.jar" />, +        </jar>, +    </target>, +    <target name="glide-minus-volley" depends="-compile">, +        <jar destfile="bin/glide-minus-volley-${mymanifest.manifest.android:versionName}.jar", +            basedir="bin/classes", +            excludes="com/bumptech/glide/volley/">, +            <zipgroupfileset dir="libs" includes="disklrucache*.jar" />, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +++ b/.gitmodules, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +++ b/Makefile, +, +glide-minus-volley:, +	cd library && ant clean && ant glide-minus-volley]
[+++ b/gradle.properties, +VERSION_NAME=4.5.0-SNAPSHOT, +VERSION_MINOR=5]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="INSERT_INNER_CLASS_IMPORTS" value="true" />, +        <option name="CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND" value="999" />, +        <option name="NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND" value="999" />, +        <option name="PACKAGES_TO_USE_IMPORT_ON_DEMAND">, +          <value />, +        </option>, +        <option name="KEEP_BLANK_LINES_BEFORE_RBRACE" value="0" />, +        <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />, +        <option name="ALIGN_MULTILINE_FOR" value="false" />, +        <option name="SPACE_BEFORE_ARRAY_INITIALIZER_LBRACE" value="true" />, +        <AndroidXmlCodeStyleSettings>, +          <option name="USE_CUSTOM_SETTINGS" value="true" />, +          <option name="LAYOUT_SETTINGS">, +            <value>, +              <option name="INSERT_BLANK_LINE_BEFORE_TAG" value="false" />, +            </value>, +          </option>, +        </AndroidXmlCodeStyleSettings>, +        <JSCodeStyleSettings>, +          <option name="INDENT_CHAINED_CALLS" value="false" />, +        </JSCodeStyleSettings>, +        <JavaCodeStyleSettings>, +          <option name="DO_NOT_WRAP_AFTER_SINGLE_ANNOTATION" value="true" />, +        </JavaCodeStyleSettings>, +        <Python>, +          <option name="USE_CONTINUATION_INDENT_FOR_ARGUMENTS" value="true" />, +        </Python>, +        <TypeScriptCodeStyleSettings>, +          <option name="INDENT_CHAINED_CALLS" value="false" />, +        </TypeScriptCodeStyleSettings>, +          <option name="XML_ALIGN_ATTRIBUTES" value="false" />, +        <codeStyleSettings language="CSS">, +        <codeStyleSettings language="ECMA Script Level 4">, +          <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />, +          <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />, +          <option name="ALIGN_MULTILINE_FOR" value="false" />, +          <option name="CALL_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="EXTENDS_LIST_WRAP" value="1" />, +          <option name="BINARY_OPERATION_WRAP" value="1" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="TERNARY_OPERATION_WRAP" value="1" />, +          <option name="TERNARY_OPERATION_SIGNS_ON_NEXT_LINE" value="true" />, +          <option name="FOR_STATEMENT_WRAP" value="1" />, +          <option name="ARRAY_INITIALIZER_WRAP" value="1" />, +          <option name="IF_BRACE_FORCE" value="3" />, +          <option name="DOWHILE_BRACE_FORCE" value="3" />, +          <option name="WHILE_BRACE_FORCE" value="3" />, +          <option name="FOR_BRACE_FORCE" value="3" />, +          <option name="PARENT_SETTINGS_INSTALLED" value="true" />, +        </codeStyleSettings>, +        <codeStyleSettings language="HTML">, +          <indentOptions>, +            <option name="INDENT_SIZE" value="2" />, +            <option name="CONTINUATION_INDENT_SIZE" value="4" />, +            <option name="TAB_SIZE" value="2" />, +          </indentOptions>, +        </codeStyleSettings>, +        <codeStyleSettings language="JAVA">, +          <option name="KEEP_CONTROL_STATEMENT_IN_ONE_LINE" value="false" />, +          <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />, +          <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />, +          <option name="ALIGN_MULTILINE_RESOURCES" value="false" />, +          <option name="ALIGN_MULTILINE_FOR" value="false" />, +          <option name="CALL_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="EXTENDS_LIST_WRAP" value="1" />, +          <option name="THROWS_KEYWORD_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="1" />, +          <option name="BINARY_OPERATION_WRAP" value="1" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="TERNARY_OPERATION_WRAP" value="1" />, +          <option name="TERNARY_OPERATION_SIGNS_ON_NEXT_LINE" value="true" />, +          <option name="KEEP_SIMPLE_BLOCKS_IN_ONE_LINE" value="true" />, +          <option name="KEEP_SIMPLE_METHODS_IN_ONE_LINE" value="true" />, +          <option name="KEEP_SIMPLE_LAMBDAS_IN_ONE_LINE" value="true" />, +          <option name="KEEP_SIMPLE_CLASSES_IN_ONE_LINE" value="true" />, +          <option name="FOR_STATEMENT_WRAP" value="1" />, +          <option name="ARRAY_INITIALIZER_WRAP" value="1" />, +          <option name="IF_BRACE_FORCE" value="3" />, +          <option name="DOWHILE_BRACE_FORCE" value="3" />, +          <option name="WHILE_BRACE_FORCE" value="3" />, +          <option name="FOR_BRACE_FORCE" value="3" />, +          <option name="PARENT_SETTINGS_INSTALLED" value="true" />, +          <indentOptions>, +            <option name="INDENT_SIZE" value="2" />, +            <option name="CONTINUATION_INDENT_SIZE" value="4" />, +            <option name="TAB_SIZE" value="2" />, +          </indentOptions>, +        </codeStyleSettings>, +        <codeStyleSettings language="JSON">, +          <indentOptions>, +            <option name="CONTINUATION_INDENT_SIZE" value="4" />, +            <option name="TAB_SIZE" value="2" />, +          </indentOptions>, +        </codeStyleSettings>, +        <codeStyleSettings language="JavaScript">, +          <option name="RIGHT_MARGIN" value="80" />, +          <option name="KEEP_BLANK_LINES_IN_CODE" value="1" />]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +          checkAndInitializeGlide(context);, +        }, +      }, +    }, +, +    return glide;, +  }, +, +  private static void checkAndInitializeGlide(Context context) {, +    initializeGlide(context);, +  private static void initializeGlide(Context context) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +          checkAndInitializeGlide(context);, +        }, +      }, +    }, +, +    return glide;, +  }, +, +  private static void checkAndInitializeGlide(Context context) {, +    initializeGlide(context);, +  private static void initializeGlide(Context context) {, +++ b/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +          checkAndInitializeGlide(context);, +        }, +      }, +    }, +, +    return glide;, +  }, +, +  private static void checkAndInitializeGlide(Context context) {, +    initializeGlide(context);, +  private static void initializeGlide(Context context) {, +++ b/library/src/main/java/com/bumptech/glide/module/RegistersComponents.java, +++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgModule.java, +import com.bumptech.glide.Glide;, +  public void registerComponents(Context context, Glide glide, Registry registry) {]
[+++ b/.idea/codeStyleSettings.xml, +++ b/.idea/codeStyleSettings.xml, +++ b/build.gradle, +        toolVersion = "6.6", +    }, +, +    checkstyle {, +++ b/.idea/codeStyleSettings.xml, +++ b/build.gradle, +        toolVersion = "6.6", +    }, +, +    checkstyle {, +++ b/checkstyle.xml, +          <property name="sortStaticImportsAlphabetically" value="true"/>, +++ b/.idea/codeStyleSettings.xml, +++ b/build.gradle, +        toolVersion = "6.6", +    }, +, +    checkstyle {, +++ b/checkstyle.xml, +          <property name="sortStaticImportsAlphabetically" value="true"/>, +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.google.common.truth.Truth.assertThat;, +++ b/.idea/codeStyleSettings.xml, +++ b/build.gradle, +        toolVersion = "6.6", +    }, +, +    checkstyle {, +++ b/checkstyle.xml, +          <property name="sortStaticImportsAlphabetically" value="true"/>, +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.google.common.truth.Truth.assertThat;, +++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +import static com.google.common.truth.Truth.assertThat;, +++ b/.idea/codeStyleSettings.xml, +++ b/build.gradle, +        toolVersion = "6.6", +    }, +, +    checkstyle {, +++ b/checkstyle.xml, +          <property name="sortStaticImportsAlphabetically" value="true"/>, +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.google.common.truth.Truth.assertThat;, +++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +import static com.google.common.truth.Truth.assertThat;, +++ b/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java, +import static com.google.common.truth.Truth.assertThat;, +++ b/.idea/codeStyleSettings.xml, +++ b/build.gradle, +        toolVersion = "6.6", +    }, +, +    checkstyle {, +++ b/checkstyle.xml, +          <property name="sortStaticImportsAlphabetically" value="true"/>, +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.google.common.truth.Truth.assertThat;, +++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +import static com.google.common.truth.Truth.assertThat;, +++ b/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java, +import static com.google.common.truth.Truth.assertThat;, +++ b/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java, +import static com.google.common.truth.Truth.assertThat;, +++ b/.idea/codeStyleSettings.xml, +++ b/build.gradle, +        toolVersion = "6.6", +    }, +, +    checkstyle {, +++ b/checkstyle.xml, +          <property name="sortStaticImportsAlphabetically" value="true"/>, +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.google.common.truth.Truth.assertThat;, +++ b/library/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +import static com.google.common.truth.Truth.assertThat;, +++ b/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java, +import static com.google.common.truth.Truth.assertThat;, +++ b/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java, +import static com.google.common.truth.Truth.assertThat;, +++ b/third_party/disklrucache, +Subproject commit 847e0dad08098c57e6dd12104463780e47e8e24e]
[+++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="18" />]
[+++ b/gradle.properties, +OK_HTTP_VERSION=3.9.1, +++ b/gradle.properties, +OK_HTTP_VERSION=3.9.1, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +  private InputStream stream;, +  private ResponseBody responseBody;, +  // call may be accessed on the main thread while the object is in use on other threads. All other, +  // accesses to variables may occur on different threads, but only one at a time., +  private volatile Call call;]
[+++ b/library/pom.xml, +  <modelVersion>4.0.0</modelVersion>, +    <groupId>com.bumptech.glide</groupId>, +    <artifactId>glide-parent</artifactId>, +    <version>3.3.0-SNAPSHOT</version>, +    <relativePath>../pom.xml</relativePath>, +  <name>Glide</name>, +      <scope>test</scope>, +++ b/library/pom.xml, +  <modelVersion>4.0.0</modelVersion>, +    <groupId>com.bumptech.glide</groupId>, +    <artifactId>glide-parent</artifactId>, +    <version>3.3.0-SNAPSHOT</version>, +    <relativePath>../pom.xml</relativePath>, +  <name>Glide</name>, +      <scope>test</scope>, +++ b/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">, +  <modelVersion>4.0.0</modelVersion>, +, +  <parent>, +    <groupId>org.sonatype.oss</groupId>, +    <artifactId>oss-parent</artifactId>, +    <version>7</version>, +  </parent>, +, +  <groupId>com.bumptech.glide</groupId>, +  <artifactId>glide-parent</artifactId>, +  <version>3.3.0-SNAPSHOT</version>, +  <packaging>pom</packaging>, +, +  <name>Glide (Parent)</name>, +  , +  <modules>, +    <module>library</module>, +    <module>samples</module>, +  </modules>, +, +  <build>, +    <plugins>, +      <plugin>, +        <groupId>com.jayway.maven.plugins.android.generation2</groupId>, +        <artifactId>android-maven-plugin</artifactId>, +        <version>3.9.0-rc.1</version>, +        <configuration>, +          <sdk>, +            <platform>19</platform>, +          </sdk>, +          <deleteConflictingFiles>true</deleteConflictingFiles>, +          <undeployBeforeDeploy>true</undeployBeforeDeploy>, +        </configuration>, +        <extensions>true</extensions>, +      </plugin>, +      <plugin>, +        <artifactId>maven-compiler-plugin</artifactId>, +        <version>3.1</version>, +        <configuration>, +            <source>1.6</source>, +            <target>1.6</target>, +        </configuration>, +      </plugin>, +    </plugins>, +  </build>, +</project>, +++ b/library/pom.xml, +  <modelVersion>4.0.0</modelVersion>, +    <groupId>com.bumptech.glide</groupId>, +    <artifactId>glide-parent</artifactId>, +    <version>3.3.0-SNAPSHOT</version>, +    <relativePath>../pom.xml</relativePath>, +  <name>Glide</name>, +      <scope>test</scope>, +++ b/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">, +  <modelVersion>4.0.0</modelVersion>, +, +  <parent>, +    <groupId>org.sonatype.oss</groupId>, +    <artifactId>oss-parent</artifactId>, +    <version>7</version>, +  </parent>, +, +  <groupId>com.bumptech.glide</groupId>, +  <artifactId>glide-parent</artifactId>, +  <version>3.3.0-SNAPSHOT</version>, +  <packaging>pom</packaging>, +, +  <name>Glide (Parent)</name>, +  , +  <modules>, +    <module>library</module>, +    <module>samples</module>, +  </modules>, +, +  <build>, +    <plugins>, +      <plugin>, +        <groupId>com.jayway.maven.plugins.android.generation2</groupId>]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java, +      throw new IllegalStateException(, +         "Failed to find any load path from " + helper.getModelClass() + " to ", +             + helper.getTranscodeClass());]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import com.bumptech.glide.util.ContentLengthInputStream;, +    private static final String CONTENT_LENGTH_HEADER = "Content-Length";, +, +        String contentLength = response.header(CONTENT_LENGTH_HEADER);, +        stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import com.bumptech.glide.util.ContentLengthInputStream;, +    private static final String CONTENT_LENGTH_HEADER = "Content-Length";, +, +        String contentLength = response.header(CONTENT_LENGTH_HEADER);, +        stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import com.bumptech.glide.util.ContentLengthInputStream;, +    private static final String CONTENT_LENGTH_HEADER = "Content-Length";, +, +        String contentLength = response.header(CONTENT_LENGTH_HEADER);, +        stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +++ b/library/src/androidTest/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java, +package com.bumptech.glide.util;, +, +import static com.google.common.truth.Truth.assertThat;, +import static org.junit.Assert.fail;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Mockito.when;, +, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +, +import java.io.IOException;, +import java.io.InputStream;, +, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +public class ContentLengthInputStreamTest {, +  @Mock InputStream wrapped;, +, +  @Before, +  public void setUp() {, +    MockitoAnnotations.initMocks(this);, +  }, +, +  @Test, +  public void testAvailable_withZeroReadsAndValidContentLength_returnsContentLength(), +      throws IOException {, +    int value = 123356;, +    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(value));, +, +    assertThat(is.available()).isEqualTo(value);, +  }, +, +  @Test, +  public void testAvailable_withNullContentLength_returnsWrappedAvailable(), +      throws IOException {, +    InputStream is = ContentLengthInputStream.obtain(wrapped, null /*contentLengthHeader*/);, +    int expected = 1234;, +    when(wrapped.available()).thenReturn(expected);, +, +    assertThat(is.available()).isEqualTo(expected);, +  }, +, +  @Test, +  public void testAvailable_withInvalidContentLength_returnsWrappedAvailable() throws IOException {, +    InputStream is = ContentLengthInputStream.obtain(wrapped, "invalid_length");, +    int expected = 567;, +    when(wrapped.available()).thenReturn(expected);, +, +    assertThat(is.available()).isEqualTo(expected);, +  }, +, +  @Test, +  public void testAvailable_withRead_returnsContentLengthOffsetByRead() throws IOException {, +    int contentLength = 999;, +    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));, +    when(wrapped.read()).thenReturn(1);, +, +    assertThat(is.read()).isEqualTo(1);, +    assertThat(is.available()).isEqualTo(contentLength - 1);, +  }, +, +  @Test, +  public void testAvailable_handlesReadValueOfZero() throws IOException {, +    int contentLength = 999;, +    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));]
[+++ b/library/src/main/java/com/bumptech/glide/DownloadOptions.java, +     * @param width The width in pixels to use to fetch the data., +     * @param height The height in pixels to use to fetch the data., +++ b/library/src/main/java/com/bumptech/glide/DownloadOptions.java, +     * @param width The width in pixels to use to fetch the data., +     * @param height The height in pixels to use to fetch the data., +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +     * @param width The width in pixels to use to load the resource., +     * @param height The height in pixels to use to load the resource., +     * @param width The desired width in pixels (note this will be overriden by {@link #override(int, int)} if, +     *              previously called)., +     * @param height The desired height in pixels (note this will be overriden by {@link #override(int, int)}}, +     *               if previously called)., +++ b/library/src/main/java/com/bumptech/glide/DownloadOptions.java, +     * @param width The width in pixels to use to fetch the data., +     * @param height The height in pixels to use to fetch the data., +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +     * @param width The width in pixels to use to load the resource., +     * @param height The height in pixels to use to load the resource., +     * @param width The desired width in pixels (note this will be overriden by {@link #override(int, int)} if, +     *              previously called)., +     * @param height The desired height in pixels (note this will be overriden by {@link #override(int, int)}}, +     *               if previously called)., +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +     * @param width The ideal width in pixels of the decoded resource., +     * @param height The ideal height in pixels of the decoded resource., +++ b/library/src/main/java/com/bumptech/glide/DownloadOptions.java, +     * @param width The width in pixels to use to fetch the data., +     * @param height The height in pixels to use to fetch the data., +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +     * @param width The width in pixels to use to load the resource., +     * @param height The height in pixels to use to load the resource., +     * @param width The desired width in pixels (note this will be overriden by {@link #override(int, int)} if, +     *              previously called)., +     * @param height The desired height in pixels (note this will be overriden by {@link #override(int, int)}}, +     *               if previously called)., +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +     * @param width The ideal width in pixels of the decoded resource., +     * @param height The ideal height in pixels of the decoded resource., +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +     * @param width The target width in pixels of the desired resource., +     * @param height The target height in pixels of the desired resource., +++ b/library/src/main/java/com/bumptech/glide/DownloadOptions.java, +     * @param width The width in pixels to use to fetch the data., +     * @param height The height in pixels to use to fetch the data., +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +     * @param width The width in pixels to use to load the resource., +     * @param height The height in pixels to use to load the resource., +     * @param width The desired width in pixels (note this will be overriden by {@link #override(int, int)} if, +     *              previously called)., +     * @param height The desired height in pixels (note this will be overriden by {@link #override(int, int)}}, +     *               if previously called)., +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +     * @param width The ideal width in pixels of the decoded resource., +     * @param height The ideal height in pixels of the decoded resource., +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +     * @param width The target width in pixels of the desired resource., +     * @param height The target height in pixels of the desired resource., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +     * @param width The width in pixels of the desired {@link android.graphics.Bitmap}., +     * @param height The height in pixels of the desired {@link android.graphics.Bitmap}., +     * @param width The width in pixels of the desired {@link android.graphics.Bitmap}., +     * @param height The height in pixels of the desired {@link android.graphics.Bitmap}., +++ b/library/src/main/java/com/bumptech/glide/DownloadOptions.java, +     * @param width The width in pixels to use to fetch the data., +     * @param height The height in pixels to use to fetch the data., +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +     * @param width The width in pixels to use to load the resource., +     * @param height The height in pixels to use to load the resource., +     * @param width The desired width in pixels (note this will be overriden by {@link #override(int, int)} if, +     *              previously called)., +     * @param height The desired height in pixels (note this will be overriden by {@link #override(int, int)}}, +     *               if previously called)., +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +     * @param width The ideal width in pixels of the decoded resource., +     * @param height The ideal height in pixels of the decoded resource., +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +     * @param width The target width in pixels of the desired resource., +     * @param height The target height in pixels of the desired resource., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +     * @param width The width in pixels of the desired {@link android.graphics.Bitmap}., +     * @param height The height in pixels of the desired {@link android.graphics.Bitmap}., +     * @param width The width in pixels of the desired {@link android.graphics.Bitmap}., +     * @param height The height in pixels of the desired {@link android.graphics.Bitmap}., +++ b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java, +     * @param width The width in pixels of the view the image is being loaded into., +     * @param height The height in pixels of the view the image is being loaded into., +     * @param width The width in pixels of the view the image is being loaded into., +     * @param height The height in pixels of the view the image is being loaded into., +++ b/library/src/main/java/com/bumptech/glide/DownloadOptions.java, +     * @param width The width in pixels to use to fetch the data., +     * @param height The height in pixels to use to fetch the data., +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +     * @param width The width in pixels to use to load the resource., +     * @param height The height in pixels to use to load the resource., +     * @param width The desired width in pixels (note this will be overriden by {@link #override(int, int)} if, +     *              previously called)., +     * @param height The desired height in pixels (note this will be overriden by {@link #override(int, int)}}, +     *               if previously called)., +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    return into(target, /*targetListener=*/ null);, +  private <Y extends Target<TranscodeType>> Y into(, +      @NonNull Y target,, +      @Nullable RequestListener<TranscodeType> targetListener) {, +    return into(target, targetListener, getMutableOptions());, +  }, +, +  private <Y extends Target<TranscodeType>> Y into(, +      @NonNull Y target,, +      @Nullable RequestListener<TranscodeType> targetListener,, +      RequestOptions options) {, +    Request request = buildRequest(target, targetListener, options);, +    return into(, +        glideContext.buildImageViewTarget(view, transcodeClass),, +        /*targetListener=*/ null,, +        requestOptions);, +            into(target, target);, +      into(target, target);, +  private Request buildRequest(, +      Target<TranscodeType> target,, +      @Nullable RequestListener<TranscodeType> targetListener,, +      RequestOptions requestOptions) {, +    return buildRequestRecursive(, +        target,, +        targetListener,, +        /*requestCoordinator=*/ null,, +        transitionOptions,, +        requestOptions.getPriority(),, +        requestOptions.getOverrideWidth(),, +        requestOptions.getOverrideHeight(),, +        requestOptions);, +  private Request buildRequestRecursive(, +      Target<TranscodeType> target,, +      @Nullable RequestListener<TranscodeType> targetListener,, +      Priority priority,, +      int overrideWidth,, +      int overrideHeight,, +      RequestOptions requestOptions) {, +            targetListener,, +        targetListener,, +  private Request buildThumbnailRequestRecursive(, +      Target<TranscodeType> target,, +      RequestListener<TranscodeType> targetListener,, +      Priority priority,, +      int overrideWidth,, +      int overrideHeight,, +      RequestOptions requestOptions) {, +      Request fullRequest =, +          obtainRequest(, +              target,, +              targetListener,, +              requestOptions,, +              coordinator,, +              transitionOptions,, +              priority,, +              overrideWidth,, +              overrideHeight);, +              targetListener,, +      Request fullRequest =, +          obtainRequest(, +              target,, +              targetListener,, +              requestOptions,, +              coordinator,, +              transitionOptions,, +              priority,, +              overrideWidth,, +              overrideHeight);, +      Request thumbnailRequest =, +          obtainRequest(, +              target,, +              targetListener,, +              thumbnailOptions,, +              coordinator,, +              transitionOptions,, +              getThumbnailPriority(priority),, +              overrideWidth,, +              overrideHeight);, +      return obtainRequest(, +          target,, +          targetListener,, +          requestOptions,, +          parentCoordinator,, +          transitionOptions,, +          priority,, +          overrideWidth,, +          overrideHeight);, +  private Request obtainRequest(, +      Target<TranscodeType> target,, +      RequestListener<TranscodeType> targetListener,, +      RequestOptions requestOptions,, +      RequestCoordinator requestCoordinator,, +      TransitionOptions<?, ? super TranscodeType> transitionOptions,, +      Priority priority,, +      int overrideWidth,, +      int overrideHeight) {, +        targetListener,, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    return into(target, /*targetListener=*/ null);]
[+++ b/library/src/main/java/com/bumptech/glide/Registry.java, +import android.support.annotation.NonNull;, +  @NonNull, +  public <Data> Registry register(@NonNull Class<Data> dataClass, @NonNull Encoder<Data> encoder) {, +  @NonNull, +  public <Data> Registry append(@NonNull Class<Data> dataClass, @NonNull Encoder<Data> encoder) {, +  @NonNull, +  public <Data> Registry prepend(@NonNull Class<Data> dataClass, @NonNull Encoder<Data> encoder) {, +  @NonNull, +      @NonNull Class<Data> dataClass,, +      @NonNull Class<TResource> resourceClass,, +      @NonNull ResourceDecoder<Data, TResource> decoder) {, +  @NonNull, +      @NonNull String bucket,, +      @NonNull Class<Data> dataClass,, +      @NonNull Class<TResource> resourceClass,, +      @NonNull ResourceDecoder<Data, TResource> decoder) {, +  @NonNull, +      @NonNull Class<Data> dataClass,, +      @NonNull Class<TResource> resourceClass,, +      @NonNull ResourceDecoder<Data, TResource> decoder) {, +  @NonNull, +      @NonNull String bucket,, +      @NonNull Class<Data> dataClass,, +      @NonNull Class<TResource> resourceClass,, +      @NonNull ResourceDecoder<Data, TResource> decoder) {, +  @NonNull, +  public final Registry setResourceDecoderBucketPriorityList(@NonNull List<String> buckets) {, +  @NonNull, +      @NonNull Class<TResource> resourceClass, @NonNull ResourceEncoder<TResource> encoder) {, +  @NonNull, +      @NonNull Class<TResource> resourceClass, @NonNull ResourceEncoder<TResource> encoder) {, +  @NonNull, +      @NonNull Class<TResource> resourceClass, @NonNull ResourceEncoder<TResource> encoder) {, +  @NonNull, +  public Registry register(@NonNull DataRewinder.Factory<?> factory) {, +  @NonNull, +  public <TResource, Transcode> Registry register(, +      @NonNull Class<TResource> resourceClass, @NonNull Class<Transcode> transcodeClass,, +      @NonNull ResourceTranscoder<TResource, Transcode> transcoder) {, +  @NonNull, +  public Registry register(@NonNull ImageHeaderParser parser) {, +  @NonNull, +  @NonNull, +  @NonNull, +      @NonNull Class<Data> dataClass, @NonNull Class<TResource> resourceClass,, +      @NonNull Class<Transcode> transcodeClass) {, +  @NonNull, +      @NonNull Class<Data> dataClass, @NonNull Class<TResource> resourceClass,, +      @NonNull Class<Transcode> transcodeClass) {, +  @Nullable, +      Class<Model> modelClass, @NonNull Class<TResource> resourceClass,, +      @NonNull Class<Transcode> transcodeClass) {, +  public boolean isResourceEncoderAvailable(@NonNull Resource<?> resource) {, +  @Nullable, +  public <X> ResourceEncoder<X> getResultEncoder(@NonNull Resource<X> resource), +  @Nullable, +  public <X> Encoder<X> getSourceEncoder(@NonNull X data) throws NoSourceEncoderAvailableException {, +  @NonNull, +  public <X> DataRewinder<X> getRewinder(@NonNull X data) {, +  @NonNull, +  public <Model> List<ModelLoader<Model, ?>> getModelLoaders(@NonNull Model model) {, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +import android.support.annotation.NonNull;, +  @NonNull, +  public <Data> Registry register(@NonNull Class<Data> dataClass, @NonNull Encoder<Data> encoder) {, +  @NonNull, +  public <Data> Registry append(@NonNull Class<Data> dataClass, @NonNull Encoder<Data> encoder) {, +  @NonNull, +  public <Data> Registry prepend(@NonNull Class<Data> dataClass, @NonNull Encoder<Data> encoder) {, +  @NonNull, +      @NonNull Class<Data> dataClass,, +      @NonNull Class<TResource> resourceClass,, +      @NonNull ResourceDecoder<Data, TResource> decoder) {, +  @NonNull, +      @NonNull String bucket,, +      @NonNull Class<Data> dataClass,, +      @NonNull Class<TResource> resourceClass,, +      @NonNull ResourceDecoder<Data, TResource> decoder) {, +  @NonNull, +      @NonNull Class<Data> dataClass,, +      @NonNull Class<TResource> resourceClass,, +      @NonNull ResourceDecoder<Data, TResource> decoder) {, +  @NonNull, +      @NonNull String bucket,, +      @NonNull Class<Data> dataClass,, +      @NonNull Class<TResource> resourceClass,, +      @NonNull ResourceDecoder<Data, TResource> decoder) {, +  @NonNull, +  public final Registry setResourceDecoderBucketPriorityList(@NonNull List<String> buckets) {, +  @NonNull, +      @NonNull Class<TResource> resourceClass, @NonNull ResourceEncoder<TResource> encoder) {, +  @NonNull, +      @NonNull Class<TResource> resourceClass, @NonNull ResourceEncoder<TResource> encoder) {, +  @NonNull, +      @NonNull Class<TResource> resourceClass, @NonNull ResourceEncoder<TResource> encoder) {, +  @NonNull, +  public Registry register(@NonNull DataRewinder.Factory<?> factory) {, +  @NonNull]
[+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +    // We must call isFirstReadyResource before setting status., +    boolean isFirstResource = isFirstReadyResource();, +        loadedFromMemoryCache, isFirstResource)) {, +          animationFactory.build(loadedFromMemoryCache, isFirstResource);, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +    // We must call isFirstReadyResource before setting status., +    boolean isFirstResource = isFirstReadyResource();, +        loadedFromMemoryCache, isFirstResource)) {, +          animationFactory.build(loadedFromMemoryCache, isFirstResource);, +++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java, +  private DrawableCrossFadeTransition firstResourceTransition;, +  private DrawableCrossFadeTransition secondResourceTransition;, +    this(new ViewAnimationFactory<Drawable>(, +        new DefaultViewTransitionAnimationFactory(duration)), duration);, +    } else if (isFirstResource) {, +      return getFirstResourceTransition();, +    } else {, +      return getSecondResourceTransition();, +    }, +, +  private Transition<Drawable> getFirstResourceTransition() {, +      if (firstResourceTransition == null) {, +          Transition<Drawable> defaultAnimation =, +              viewAnimationFactory.build(false /*isFromMemoryCache*/, true /*isFirstResource*/);, +          firstResourceTransition = new DrawableCrossFadeTransition(defaultAnimation, duration);, +      }, +      return firstResourceTransition;, +  private Transition<Drawable> getSecondResourceTransition() {, +      if (secondResourceTransition == null) {, +          Transition<Drawable> defaultAnimation =, +              viewAnimationFactory.build(false /*isFromMemoryCache*/, false /*isFirstResource*/);, +          secondResourceTransition = new DrawableCrossFadeTransition(defaultAnimation, duration);, +      }, +      return secondResourceTransition;, +    private final int duration;, +, +    DefaultViewTransitionAnimationFactory(int duration) {, +      this.duration = duration;, +    }, +, +      animation.setDuration(duration);, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +    // We must call isFirstReadyResource before setting status., +    boolean isFirstResource = isFirstReadyResource();, +        loadedFromMemoryCache, isFirstResource)) {, +          animationFactory.build(loadedFromMemoryCache, isFirstResource);, +++ b/library/src/main/java/com/bumptech/glide/request/transition/DrawableCrossFadeFactory.java, +  private DrawableCrossFadeTransition firstResourceTransition;, +  private DrawableCrossFadeTransition secondResourceTransition;, +    this(new ViewAnimationFactory<Drawable>(, +        new DefaultViewTransitionAnimationFactory(duration)), duration);, +    } else if (isFirstResource) {, +      return getFirstResourceTransition();, +    } else {, +      return getSecondResourceTransition();, +    }, +, +  private Transition<Drawable> getFirstResourceTransition() {, +      if (firstResourceTransition == null) {, +          Transition<Drawable> defaultAnimation =, +              viewAnimationFactory.build(false /*isFromMemoryCache*/, true /*isFirstResource*/);, +          firstResourceTransition = new DrawableCrossFadeTransition(defaultAnimation, duration);, +      }, +      return firstResourceTransition;, +  private Transition<Drawable> getSecondResourceTransition() {, +      if (secondResourceTransition == null) {, +          Transition<Drawable> defaultAnimation =, +              viewAnimationFactory.build(false /*isFromMemoryCache*/, false /*isFirstResource*/);, +          secondResourceTransition = new DrawableCrossFadeTransition(defaultAnimation, duration);, +      }, +      return secondResourceTransition;, +    private final int duration;, +, +    DefaultViewTransitionAnimationFactory(int duration) {, +      this.duration = duration;, +    }, +, +      animation.setDuration(duration);, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java, +        .transition(withCrossFade(R.anim.fade_in, 150)), +        .apply(centerCropTransform(getActivity()));, +        .transition(withCrossFade(R.anim.fade_in, 150))]
[+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +import com.bumptech.glide.load.resource.bitmap.CircleCrop;, +   * Applies {@link CircleCrop} to all default types, and ignores unknown types., +   *, +   * @param context Any {@link Context}., +   * @see #optionalTransform(Context, Transformation), +   * @see #circleCrop(Context), +   */, +  public CHILD optionalCircleCrop(Context context) {, +    downsample(DownsampleStrategy.CENTER_OUTSIDE);, +    return optionalTransform(context, new CircleCrop(context));, +  }, +, +  /**, +   * Applies {@link CircleCrop} to all default types and throws an exception if asked to transform, +   * an unknown type., +   *, +   * @param context Any {@link Context}., +   * @see #transform(Class, Transformation), +   * @see #optionalCenterCrop(Context), +   */, +  public CHILD circleCrop(Context context) {, +    downsample(DownsampleStrategy.CENTER_OUTSIDE);, +    return transform(context, new CircleCrop(context));, +  }, +, +  /**, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +import com.bumptech.glide.load.resource.bitmap.CircleCrop;, +   * Applies {@link CircleCrop} to all default types, and ignores unknown types., +   *, +   * @param context Any {@link Context}., +   * @see #optionalTransform(Context, Transformation), +   * @see #circleCrop(Context), +   */, +  public CHILD optionalCircleCrop(Context context) {, +    downsample(DownsampleStrategy.CENTER_OUTSIDE);, +    return optionalTransform(context, new CircleCrop(context));, +  }, +, +  /**, +   * Applies {@link CircleCrop} to all default types and throws an exception if asked to transform, +   * an unknown type., +   *, +   * @param context Any {@link Context}., +   * @see #transform(Class, Transformation), +   * @see #optionalCenterCrop(Context), +   */, +  public CHILD circleCrop(Context context) {, +    downsample(DownsampleStrategy.CENTER_OUTSIDE);, +    return transform(context, new CircleCrop(context));, +  }, +, +  /**, +++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +  /**, +   * Returns a {@link RequestOptions} object with {@link RequestOptions#circleCrop(Context)} set., +   */, +  public static RequestOptions circleCropTransform(Context context) {, +    return new RequestOptions().circleCrop(context);, +  }, +]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +import com.bumptech.glide.GlideContext;, +import com.bumptech.glide.Priority;, +import com.bumptech.glide.load.Options;, +import com.bumptech.glide.load.Transformation;, +    harness.isMemoryCacheable = false;, +    harness.isMemoryCacheable = false;, +        .buildKey(eq(harness.model), eq(harness.signature), eq(harness.width), eq(harness.height),, +            eq(harness.transformations), eq(Object.class), eq(Object.class), eq(harness.options));, +    Object model = new Object();, +    Key signature = mock(Key.class);, +    Map<Class<?>, Transformation<?>> transformations = new HashMap<>();, +    Options options = new Options();, +    GlideContext glideContext = mock(GlideContext.class);, +    boolean isMemoryCacheable = true;, +      when(keyFactory.buildKey(eq(model), eq(signature), anyInt(), anyInt(), eq(transformations),, +          eq(Object.class), eq(Object.class), eq(options))).thenReturn(cacheKey);, +      return engine.load(glideContext,, +          model,, +          signature,, +          width,, +          height,, +          Object.class,, +          Object.class,, +          Priority.HIGH,, +          DiskCacheStrategy.ALL,, +          transformations,, +          false /*isTransformationRequired*/,, +          options,, +          isMemoryCacheable,, +          cb);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +import com.bumptech.glide.GlideContext;, +import com.bumptech.glide.Priority;, +import com.bumptech.glide.load.Options;, +import com.bumptech.glide.load.Transformation;, +    harness.isMemoryCacheable = false;, +    harness.isMemoryCacheable = false;, +        .buildKey(eq(harness.model), eq(harness.signature), eq(harness.width), eq(harness.height),, +            eq(harness.transformations), eq(Object.class), eq(Object.class), eq(harness.options));, +    Object model = new Object();, +    Key signature = mock(Key.class);, +    Map<Class<?>, Transformation<?>> transformations = new HashMap<>();, +    Options options = new Options();, +    GlideContext glideContext = mock(GlideContext.class);, +    boolean isMemoryCacheable = true;, +      when(keyFactory.buildKey(eq(model), eq(signature), anyInt(), anyInt(), eq(transformations),, +          eq(Object.class), eq(Object.class), eq(options))).thenReturn(cacheKey);, +      return engine.load(glideContext,, +          model,, +          signature,, +          width,, +          height,, +          Object.class,, +          Object.class,, +          Priority.HIGH,, +          DiskCacheStrategy.ALL,, +          transformations,, +          false /*isTransformationRequired*/,, +          options,, +          isMemoryCacheable,, +          cb);, +++ b/library/src/androidTest/java/com/bumptech/glide/request/SingleRequestTest.java, +import com.bumptech.glide.GlideContext;, +import com.bumptech.glide.Priority;, +import com.bumptech.glide.load.Key;, +import com.bumptech.glide.load.Options;, +import com.bumptech.glide.load.Transformation;, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +import java.util.HashMap;, +import java.util.Map;, +    GlideContext glideContext = mock(GlideContext.class);, +    Key signature = mock(Key.class);, +    Priority priority = Priority.HIGH;, +, +    Map<Class<?>, Transformation<?>>  transformations = new HashMap<Class<?>, Transformation<?>>();, +       RequestOptions requestOptions = new RequestOptions(), +        .error(errorDrawable), +        .placeholder(placeholderDrawable), +        .fallback(fallbackDrawable), +        .override(overrideWidth, overrideHeight), +        .priority(priority), +        .signature(signature);, +          .obtain(glideContext, model, List.class, requestOptions, overrideWidth, overrideHeight,, +              priority, target, requestListener, requestCoordinator, engine, factory);, +        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), eq(100), eq(100),, +            eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),, +            eq(harness.transformations), anyBoolean(), any(Options.class),, +            anyBoolean(), any(ResourceCallback.class));, +       .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(), anyInt(),, +          eq(Object.class), eq(List.class), any(Priority.class), any(DiskCacheStrategy.class),, +          eq(harness.transformations), anyBoolean(), any(Options.class),, +          anyBoolean(), any(ResourceCallback.class))), +        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),, +            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),, +            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),, +            any(Options.class), anyBoolean(), any(ResourceCallback.class))), +        .load(eq(harness.glideContext), eq(harness.model), eq(harness.signature), anyInt(),, +            anyInt(), eq(Object.class), eq(List.class), any(Priority.class),, +            any(DiskCacheStrategy.class), eq(harness.transformations), anyBoolean(),]
[+++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +    InputStream inputStream = contentResolver.openInputStream(uri);, +      throw new FileNotFoundException("InputStream is null for :" + uri);, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +    InputStream inputStream = contentResolver.openInputStream(uri);, +      throw new FileNotFoundException("InputStream is null for :" + uri);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +    this.context = context.getApplicationContext();, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +    InputStream inputStream = contentResolver.openInputStream(uri);, +      throw new FileNotFoundException("InputStream is null for :" + uri);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +    this.context = context.getApplicationContext();, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +    InputStream inputStream = contentResolver.openInputStream(uri);, +      throw new FileNotFoundException("InputStream is null for :" + uri);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +    this.context = context.getApplicationContext();, +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +    InputStream inputStream = contentResolver.openInputStream(uri);, +      throw new FileNotFoundException("InputStream is null for :" + uri);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +    this.context = context.getApplicationContext();, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +    InputStream inputStream = contentResolver.openInputStream(uri);, +      throw new FileNotFoundException("InputStream is null for :" + uri);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +    this.context = context.getApplicationContext();, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +    InputStream inputStream = contentResolver.openInputStream(uri);, +      throw new FileNotFoundException("InputStream is null for :" + uri);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +    this.context = context.getApplicationContext();, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +    InputStream inputStream = contentResolver.openInputStream(uri);, +      throw new FileNotFoundException("InputStream is null for :" + uri);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +    this.context = context.getApplicationContext();, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +    InputStream inputStream = contentResolver.openInputStream(uri);, +      throw new FileNotFoundException("InputStream is null for :" + uri);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +    this.context = context.getApplicationContext();, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/settings.gradle]
[+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java, +    byte transparentColorIndex = -1;, +, +        byte byteCurrentColorIndex = mainPixels[sx];, +        int currentColorIndex = ((int) byteCurrentColorIndex) & MASK_INT_LOWEST_BYTE;, +        if (currentColorIndex != transparentColorIndex) {, +          int color = act[currentColorIndex];, +          if (color != COLOR_TRANSPARENT_BLACK) {, +            dest[dx] = color;, +            transparentColorIndex = byteCurrentColorIndex;, +          }, +    isFirstFrameTransparent =, +        isFirstFrameTransparent == null && isFirstFrame && transparentColorIndex != -1;]
[+++ b/library/src/main/java/com/bumptech/glide/manager/LifecycleRequestManager.java, +class LifecycleRequestManager implements RequestManager {, +    private final RequestTracker requestTracker;, +        this(context, new RequestTracker(), new ConnectivityMonitorFactory());, +    LifecycleRequestManager(Context context, RequestTracker requestTracker, ConnectivityMonitorFactory factory) {, +        this.requestTracker = requestTracker;, +        this.connectivityMonitor = factory.build(context, new RequestManagerConnectivityListener());, +        requestTracker.addRequest(request);, +        requestTracker.removeRequest(request);, +    void onStart() {, +        requestTracker.resumeRequests();, +    void onStop() {, +        requestTracker.pauseRequests();, +    void onDestroy() {, +        requestTracker.clearRequests();, +, +    private class RequestManagerConnectivityListener implements ConnectivityMonitor.ConnectivityListener {, +            if (isConnected) {, +                requestTracker.restartRequests();, +++ b/library/src/main/java/com/bumptech/glide/manager/LifecycleRequestManager.java, +class LifecycleRequestManager implements RequestManager {, +    private final RequestTracker requestTracker;, +        this(context, new RequestTracker(), new ConnectivityMonitorFactory());, +    LifecycleRequestManager(Context context, RequestTracker requestTracker, ConnectivityMonitorFactory factory) {, +        this.requestTracker = requestTracker;, +        this.connectivityMonitor = factory.build(context, new RequestManagerConnectivityListener());, +        requestTracker.addRequest(request);, +        requestTracker.removeRequest(request);, +    void onStart() {, +        requestTracker.resumeRequests();, +    void onStop() {, +        requestTracker.pauseRequests();, +    void onDestroy() {, +        requestTracker.clearRequests();, +, +    private class RequestManagerConnectivityListener implements ConnectivityMonitor.ConnectivityListener {, +            if (isConnected) {, +                requestTracker.restartRequests();, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java, +package com.bumptech.glide.manager;, +, +import com.bumptech.glide.request.Request;, +, +import java.util.Collections;, +import java.util.Set;, +import java.util.WeakHashMap;, +, +public class RequestTracker {, +    // Most requests will be for views and will therefore be held strongly (and safely) by the view via the tag., +    // However, a user can always pass in a different type of target which may end up not being strongly referenced even, +    // though the user still would like the request to finish. Weak references are therefore only really functional in, +    // this context for view targets. Despite the side affects, WeakReferences are still essentially required. A user, +    // can always make repeated requests into targets other than views, or use an activity manager in a fragment pager, +    // where holding strong references would steadily leak bitmaps and/or views., +    private final Set<Request> requests = Collections.newSetFromMap(new WeakHashMap<Request, Boolean>());, +, +    public void addRequest(Request request) {, +        requests.add(request);, +    }, +, +    public void removeRequest(Request request) {, +        requests.remove(request);, +    }, +, +    /**, +     * Stops any in progress requests., +     */, +    public void pauseRequests() {, +        for (Request request : requests) {, +            if (!request.isComplete() && !request.isFailed()) {, +                request.clear();, +            }, +        }, +    }, +, +    /**, +     * Starts any not yet completed or failed requests., +     */, +    public void resumeRequests() {, +        for (Request request : requests) {, +            if (!request.isComplete() && !request.isRunning()) {, +                request.run();, +            }, +        }, +    }, +, +    /**, +     * Cancels all requests and clears their resources., +     */, +    public void clearRequests() {, +        for (Request request : requests) {, +            request.clear();, +        }, +    }, +, +    /**, +     * Restarts failed requests and cancels and restarts in progress requests., +     */, +    public void restartRequests() {, +        for (Request request : requests) {]
[+++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.manager.RequestTracker;, +            Class<TranscodeType> transcodeClass, Glide glide, RequestTracker requestTracker) {, +        super(context, model, streamLoadProvider, transcodeClass, glide, requestTracker);, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.manager.RequestTracker;, +            Class<TranscodeType> transcodeClass, Glide glide, RequestTracker requestTracker) {, +        super(context, model, streamLoadProvider, transcodeClass, glide, requestTracker);, +++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +import com.bumptech.glide.manager.RequestTracker;, +    private RequestTracker requestTracker;, +            Glide glide, RequestTracker requestTracker) {, +                glide, requestTracker);, +        this.requestTracker= requestTracker;, +                transcodeClass, glide, requestTracker);, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.manager.RequestTracker;, +            Class<TranscodeType> transcodeClass, Glide glide, RequestTracker requestTracker) {, +        super(context, model, streamLoadProvider, transcodeClass, glide, requestTracker);, +++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +import com.bumptech.glide.manager.RequestTracker;, +    private RequestTracker requestTracker;, +            Glide glide, RequestTracker requestTracker) {, +                glide, requestTracker);, +        this.requestTracker= requestTracker;, +                transcodeClass, glide, requestTracker);, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.manager.RequestTracker;, +            RequestTracker requestTracker) {, +        super(context, model, loadProvider, Drawable.class, glide, requestTracker);, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.manager.RequestTracker;, +            Class<TranscodeType> transcodeClass, Glide glide, RequestTracker requestTracker) {, +        super(context, model, streamLoadProvider, transcodeClass, glide, requestTracker);, +++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +import com.bumptech.glide.manager.RequestTracker;, +    private RequestTracker requestTracker;, +            Glide glide, RequestTracker requestTracker) {, +                glide, requestTracker);, +        this.requestTracker= requestTracker;, +                transcodeClass, glide, requestTracker);, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.manager.RequestTracker;, +            RequestTracker requestTracker) {, +        super(context, model, loadProvider, Drawable.class, glide, requestTracker);, +++ b/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java, +import com.bumptech.glide.manager.RequestTracker;, +    private RequestTracker requestTracker;, +            RequestTracker requestTracker) {, +                glide, requestTracker);, +        this.requestTracker = requestTracker;, +                requestTracker);, +        return new GifTypeRequest<A>(context, model, streamModelLoader, glide, requestTracker);, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.manager.RequestTracker;, +            Class<TranscodeType> transcodeClass, Glide glide, RequestTracker requestTracker) {, +        super(context, model, streamLoadProvider, transcodeClass, glide, requestTracker);, +++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +import com.bumptech.glide.manager.RequestTracker;, +    private RequestTracker requestTracker;, +            Glide glide, RequestTracker requestTracker) {, +                glide, requestTracker);, +        this.requestTracker= requestTracker;, +                transcodeClass, glide, requestTracker);, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.manager.RequestTracker;, +            RequestTracker requestTracker) {, +        super(context, model, loadProvider, Drawable.class, glide, requestTracker);, +++ b/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java, +import com.bumptech.glide.manager.RequestTracker;, +    private RequestTracker requestTracker;, +            RequestTracker requestTracker) {, +                glide, requestTracker);, +        this.requestTracker = requestTracker;, +                requestTracker);, +        return new GifTypeRequest<A>(context, model, streamModelLoader, glide, requestTracker);, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +import com.bumptech.glide.manager.RequestTracker;, +    private final RequestTracker requestTracker;, +            Class<TranscodeType> transcodeClass, Glide glide, RequestTracker requestTracker) {, +        this.requestTracker = requestTracker;, +            requestTracker.removeRequest(previous);, +        requestTracker.addRequest(request);, +, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.manager.RequestTracker;, +            Class<TranscodeType> transcodeClass, Glide glide, RequestTracker requestTracker) {, +        super(context, model, streamLoadProvider, transcodeClass, glide, requestTracker);, +++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +import com.bumptech.glide.manager.RequestTracker;, +    private RequestTracker requestTracker;, +            Glide glide, RequestTracker requestTracker) {, +                glide, requestTracker);, +        this.requestTracker= requestTracker;, +                transcodeClass, glide, requestTracker);, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.manager.RequestTracker;, +            RequestTracker requestTracker) {, +        super(context, model, loadProvider, Drawable.class, glide, requestTracker);, +++ b/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java, +        builder.setConfig(, +            defaultFormat == DecodeFormat.PREFER_ARGB_8888, +                || defaultFormat == DecodeFormat.PREFER_ARGB_8888_DISALLOW_HARDWARE, +++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java, +        builder.setConfig(, +            defaultFormat == DecodeFormat.PREFER_ARGB_8888, +                || defaultFormat == DecodeFormat.PREFER_ARGB_8888_DISALLOW_HARDWARE, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +        || format == DecodeFormat.PREFER_ARGB_8888_DISALLOW_HARDWARE]
[+++ b/build.gradle, +, +task wrapper(type: Wrapper) {, +    gradleVersion = '1.10', +}, +, +++ b/build.gradle, +, +task wrapper(type: Wrapper) {, +    gradleVersion = '1.10', +}, +, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, +, +task wrapper(type: Wrapper) {, +    gradleVersion = '1.10', +}, +, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Mon Jun 23 11:25:59 PDT 2014, +distributionUrl=https\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/build.gradle, +, +task wrapper(type: Wrapper) {, +    gradleVersion = '1.10', +}, +, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Mon Jun 23 11:25:59 PDT 2014, +distributionUrl=https\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/library/build.gradle, +++ b/build.gradle, +, +task wrapper(type: Wrapper) {, +    gradleVersion = '1.10', +}, +, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Mon Jun 23 11:25:59 PDT 2014, +distributionUrl=https\://services.gradle.org/distributions/gradle-1.10-bin.zip, +++ b/library/build.gradle, +++ b/library/gradlew, +#!/usr/bin/env bash, +, +##############################################################################, +##, +##  Gradle start up script for UN*X, +##, +##############################################################################, +, +# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script., +DEFAULT_JVM_OPTS="", +, +APP_NAME="Gradle", +APP_BASE_NAME=`basename "$0"`, +, +# Use the maximum available, or set MAX_FD != -1 to use that value., +MAX_FD="maximum", +, +warn ( ) {, +    echo "$*", +}, +, +die ( ) {, +    echo, +    echo "$*", +    echo, +    exit 1, +}, +, +# OS specific support (must be 'true' or 'false')., +cygwin=false, +msys=false, +darwin=false, +case "`uname`" in, +  CYGWIN* ), +    cygwin=true, +    ;;, +  Darwin* ), +    darwin=true, +    ;;, +  MINGW* ), +    msys=true, +    ;;, +esac, +, +# For Cygwin, ensure paths are in UNIX format before anything is touched., +if $cygwin ; then, +    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`, +fi, +, +# Attempt to set APP_HOME, +# Resolve links: $0 may be a link, +PRG="$0", +# Need this for relative symlinks., +while [ -h "$PRG" ] ; do]
[+++ b/samples/contacturi/build.gradle, +    annotationProcessor project(':annotation:compiler'), +++ b/samples/contacturi/build.gradle, +    annotationProcessor project(':annotation:compiler'), +++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java, +package com.bumptech.glide.samples.contacturi;, +, +import com.bumptech.glide.annotation.GlideModule;, +import com.bumptech.glide.module.AppGlideModule;, +, +/**, + * Ensures that Glide's generated API is created for the Contact Uri sample., + */, +@GlideModule, +public class ContactUriModule extends AppGlideModule {, +  // Intentionally empty., +}, +++ b/samples/contacturi/build.gradle, +    annotationProcessor project(':annotation:compiler'), +++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java, +package com.bumptech.glide.samples.contacturi;, +, +import com.bumptech.glide.annotation.GlideModule;, +import com.bumptech.glide.module.AppGlideModule;, +, +/**, + * Ensures that Glide's generated API is created for the Contact Uri sample., + */, +@GlideModule, +public class ContactUriModule extends AppGlideModule {, +  // Intentionally empty., +}, +++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java, +    GlideRequests glideRequests = GlideApp.with(this);, +    glideRequests.load(contactUri).apply(originalSize).into(imageViewContact);, +    glideRequests.load(lookupUri).apply(originalSize).into(imageViewLookup);, +    glideRequests.load(photoUri).apply(originalSize).into(imageViewPhoto);, +      glideRequests.load(displayPhotoUri).apply(originalSize).into(imageViewDisplayPhoto);, +++ b/samples/contacturi/build.gradle, +    annotationProcessor project(':annotation:compiler'), +++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java, +package com.bumptech.glide.samples.contacturi;, +, +import com.bumptech.glide.annotation.GlideModule;, +import com.bumptech.glide.module.AppGlideModule;, +, +/**, + * Ensures that Glide's generated API is created for the Contact Uri sample., + */, +@GlideModule, +public class ContactUriModule extends AppGlideModule {, +  // Intentionally empty., +}, +++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java, +    GlideRequests glideRequests = GlideApp.with(this);, +    glideRequests.load(contactUri).apply(originalSize).into(imageViewContact);, +    glideRequests.load(lookupUri).apply(originalSize).into(imageViewLookup);, +    glideRequests.load(photoUri).apply(originalSize).into(imageViewPhoto);, +      glideRequests.load(displayPhotoUri).apply(originalSize).into(imageViewDisplayPhoto);, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java, +  private GlideRequest<Drawable> fullRequest;, +  private GlideRequest<Drawable> thumbnailRequest;, +  private GlideRequest<Drawable> preloadRequest;, +    fullRequest = GlideApp.with(this), +        .centerCrop(), +        .transition(withNoTransition());, +    thumbnailRequest = GlideApp.with(this), +        .diskCacheStrategy(DiskCacheStrategy.DATA), +        .centerCrop(), +        .override(Api.SQUARE_THUMB_SIZE), +        .transition(withNoTransition());, +        thumbnail ? thumbnailRequest.clone().priority(Priority.HIGH) : fullRequest;, +        GlideApp.with(FlickrPhotoGrid.this).clear(photoViewHolder.imageView);, +++ b/samples/contacturi/build.gradle, +    annotationProcessor project(':annotation:compiler'), +++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/ContactUriModule.java, +package com.bumptech.glide.samples.contacturi;, +, +import com.bumptech.glide.annotation.GlideModule;, +import com.bumptech.glide.module.AppGlideModule;, +, +/**, + * Ensures that Glide's generated API is created for the Contact Uri sample., + */, +@GlideModule, +public class ContactUriModule extends AppGlideModule {, +  // Intentionally empty., +}, +++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java, +    GlideRequests glideRequests = GlideApp.with(this);, +    glideRequests.load(contactUri).apply(originalSize).into(imageViewContact);, +    glideRequests.load(lookupUri).apply(originalSize).into(imageViewLookup);, +    glideRequests.load(photoUri).apply(originalSize).into(imageViewPhoto);, +      glideRequests.load(displayPhotoUri).apply(originalSize).into(imageViewDisplayPhoto);, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java, +  private GlideRequest<Drawable> fullRequest;, +  private GlideRequest<Drawable> thumbnailRequest;, +  private GlideRequest<Drawable> preloadRequest;, +    fullRequest = GlideApp.with(this), +        .centerCrop()]
[+++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java, +import android.support.annotation.Nullable;, +, +    /**, +     * Returns an http header, or {@code null} if no header could be built., +     *, +     * <p>Returning {@code null} or an empty String from this method will result in this particular, +     * key/value being excluded from the headers provided in the request. If there are multiple, +     * factories or values for a particular key, any non-null values will still be included for that, +     * key., +     */, +    @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java, +import android.support.annotation.Nullable;, +, +    /**, +     * Returns an http header, or {@code null} if no header could be built., +     *, +     * <p>Returning {@code null} or an empty String from this method will result in this particular, +     * key/value being excluded from the headers provided in the request. If there are multiple, +     * factories or values for a particular key, any non-null values will still be included for that, +     * key., +     */, +    @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java, +        String header = factory.buildHeader();, +        if (!TextUtils.isEmpty(header)) {, +          sb.append(header);, +      }, +      String values = sb.toString();, +      if (!TextUtils.isEmpty(values)) {, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaderFactory.java, +import android.support.annotation.Nullable;, +, +    /**, +     * Returns an http header, or {@code null} if no header could be built., +     *, +     * <p>Returning {@code null} or an empty String from this method will result in this particular, +     * key/value being excluded from the headers provided in the request. If there are multiple, +     * factories or values for a particular key, any non-null values will still be included for that, +     * key., +     */, +    @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java, +        String header = factory.buildHeader();, +        if (!TextUtils.isEmpty(header)) {, +          sb.append(header);, +      }, +      String values = sb.toString();, +      if (!TextUtils.isEmpty(values)) {, +    }, +++ b/library/src/test/java/com/bumptech/glide/load/model/LazyHeadersTest.java, +import android.support.annotation.Nullable;, +, +  public void testKeyNotIncludedWithFactoryThatReturnsNullValue() {, +    Builder builder = new Builder();, +    builder.setHeader("test", new LazyHeaderFactory() {, +      @Nullable, +      @Override, +      public String buildHeader() {, +        return null;, +      }, +    });, +    LazyHeaders headers = builder.build();, +    assertThat(headers.getHeaders()).doesNotContainKey("test");, +  }, +, +  @Test, +  public void testKeyNotIncludedWithFactoryThatReturnsEmptyValue() {, +    Builder builder = new Builder();, +    builder.setHeader("test", new LazyHeaderFactory() {, +      @Nullable, +      @Override, +      public String buildHeader() {, +        return "";, +      }, +    });, +    LazyHeaders headers = builder.build();, +    assertThat(headers.getHeaders()).doesNotContainKey("test");, +  }, +, +  @Test, +  public void testKeyIncludedWithOneFactoryThatReturnsNullAndOneFactoryThatDoesNotReturnNull() {, +    Builder builder = new Builder();, +    builder.addHeader("test", new LazyHeaderFactory() {, +      @Nullable, +      @Override, +      public String buildHeader() {, +        return null;, +      }, +    });, +    builder.addHeader("test", new LazyHeaderFactory() {, +      @Nullable, +      @Override, +      public String buildHeader() {, +        return "value";, +      }, +    });, +    LazyHeaders headers = builder.build();]
[+++ b/.idea/codeStyleSettings.xml, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MAJOR=3, +VERSION_MINOR=6, +SUPPORT_V4_VERSION=19.1.0, +SUPPORT_V7_VERSION=19.1.0, +# TODO: Upgrade to latest version of Volley when we compile with Java 7., +VOLLEY_VERSION=1.0.8, +ANDROID_GRADLE_VERSION=1.0.0, +ROBOLECTRIC_GRADLE_VERSION=0.14.0, +ROBOLECTRIC_VERSION=2.4, +MOCKWEBSERVER_VERSION=1.6.0, +COMPILE_SDK_VERSION=19, +BUILD_TOOLS_VERSION=19.1.0, +TARGET_SDK_VERSION=19, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml]
[+++ b/library/AndroidManifest.xml, +          android:versionCode="7", +          android:versionName="2.0.5" >]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +      ImmutableSet.of("clone", "apply", "autoLock", "lock", "autoClone");, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +      ImmutableSet.of("clone", "apply", "autoLock", "lock", "autoClone");, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java, +              "autoClone()"), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +      ImmutableSet.of("clone", "apply", "autoLock", "lock", "autoClone");, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java, +              "autoClone()"), +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +    this.requestOptions = toSet.clone().autoClone();, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +      ImmutableSet.of("clone", "apply", "autoLock", "lock", "autoClone");, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java, +              "autoClone()"), +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +    this.requestOptions = toSet.clone().autoClone();, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +   *, +   * @deprecated Use {@link #autoClone()} instead., +  @Deprecated, +    return autoClone();, +  }, +, +  /**, +   * Similar to {@link #lock()} except that mutations cause a {@link #clone()} operation to happen, +   * before the mutation resulting in all methods returning a new Object and leaving the original, +   * locked object unmodified., +   *, +   * <p>Auto clone is not retained by cloned objects returned from mutations. The cloned objects, +   * are mutable and are not locked., +   */, +  public final CHILD autoClone() {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +      ImmutableSet.of("clone", "apply", "autoLock", "lock", "autoClone");, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java, +              "autoClone()"), +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +    this.requestOptions = toSet.clone().autoClone();, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +   *, +   * @deprecated Use {@link #autoClone()} instead., +  @Deprecated, +    return autoClone();, +  }, +, +  /**, +   * Similar to {@link #lock()} except that mutations cause a {@link #clone()} operation to happen, +   * before the mutation resulting in all methods returning a new Object and leaving the original, +   * locked object unmodified., +   *, +   * <p>Auto clone is not retained by cloned objects returned from mutations. The cloned objects, +   * are mutable and are not locked., +   */, +  public final CHILD autoClone() {, +++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +        skipMemoryCacheTrueOptions = new RequestOptions().skipMemoryCache(true).autoClone();, +        skipMemoryCacheFalseOptions = new RequestOptions().skipMemoryCache(false).autoClone();, +          .autoClone();, +              .autoClone();, +          .autoClone();, +          .autoClone();, +          .autoClone();, +          .autoClone();]
[+++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +import com.bumptech.glide.gifdecoder.StandardGifDecoder;, +      return new StandardGifDecoder(bitmapProvider);, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +import com.bumptech.glide.gifdecoder.StandardGifDecoder;, +      return new StandardGifDecoder(bitmapProvider);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +import com.bumptech.glide.gifdecoder.StandardGifDecoder;, +      return new StandardGifDecoder(provider, header, data, sampleSize);, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +import com.bumptech.glide.gifdecoder.StandardGifDecoder;, +      return new StandardGifDecoder(bitmapProvider);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +import com.bumptech.glide.gifdecoder.StandardGifDecoder;, +      return new StandardGifDecoder(provider, header, data, sampleSize);, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, + * Shared interface for GIF decoders., +public interface GifDecoder {, +  int getWidth();, +  int getHeight();, +  ByteBuffer getData();, +  int getStatus();, +  void advance();, +  int getDelay(int n);, +  int getNextDelay();, +  int getFrameCount();, +  int getCurrentFrameIndex();, +  void resetFrameIndex();, +  int getLoopCount();, +  int getByteSize();, +  Bitmap getNextFrame();, +  int read(InputStream is, int contentLength);, +  void clear();, +  void setData(GifHeader header, byte[] data);, +  void setData(GifHeader header, ByteBuffer buffer);, +  void setData(GifHeader header, ByteBuffer buffer, int sampleSize);, +  int read(byte[] data);, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +import com.bumptech.glide.gifdecoder.StandardGifDecoder;, +      return new StandardGifDecoder(bitmapProvider);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +import com.bumptech.glide.gifdecoder.StandardGifDecoder;, +      return new StandardGifDecoder(provider, header, data, sampleSize);, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, + * Shared interface for GIF decoders., +public interface GifDecoder {, +  int getWidth();, +  int getHeight();, +  ByteBuffer getData();, +  int getStatus();, +  void advance();, +  int getDelay(int n);, +  int getNextDelay();, +  int getFrameCount();, +  int getCurrentFrameIndex();, +  void resetFrameIndex();, +  int getLoopCount();, +  int getByteSize();, +  Bitmap getNextFrame();, +  int read(InputStream is, int contentLength);, +  void clear();, +  void setData(GifHeader header, byte[] data);, +  void setData(GifHeader header, ByteBuffer buffer);, +  void setData(GifHeader header, ByteBuffer buffer, int sampleSize);, +  int read(byte[] data);, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java, +package com.bumptech.glide.gifdecoder;, +, +/**, + * Copyright (c) 2013 Xcellent Creations, Inc., + *, + * Permission is hereby granted, free of charge, to any person obtaining, + * a copy of this software and associated documentation files (the, + * "Software"), to deal in the Software without restriction, including, + * without limitation the rights to use, copy, modify, merge, publish,, + * distribute, sublicense, and/or sell copies of the Software, and to, + * permit persons to whom the Software is furnished to do so, subject to, + * the following conditions:, + *, + * The above copyright notice and this permission notice shall be, + * included in all copies or substantial portions of the Software., + *, + * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,, + * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF, + * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND, + * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE, + * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION, + * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION, + * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE., + */, +, +import android.annotation.TargetApi;, +import android.graphics.Bitmap;, +import android.os.Build;, +import android.support.annotation.Nullable;, +import android.util.Log;, +, +import java.io.ByteArrayOutputStream;, +import java.io.IOException;, +import java.io.InputStream;]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java, +import android.support.annotation.RequiresApi;, +@RequiresApi(Build.VERSION_CODES.KITKAT), +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java, +import android.support.annotation.RequiresApi;, +@RequiresApi(Build.VERSION_CODES.KITKAT), +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java, +import android.support.annotation.RequiresApi;, +@RequiresApi(Build.VERSION_CODES.KITKAT), +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java, +import android.support.annotation.RequiresApi;, +@RequiresApi(Build.VERSION_CODES.KITKAT), +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java, +import android.support.annotation.RequiresApi;, +@RequiresApi(Build.VERSION_CODES.KITKAT), +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java, +import android.annotation.TargetApi;, +  @TargetApi(Build.VERSION_CODES.KITKAT), +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java, +import android.support.annotation.RequiresApi;, +@RequiresApi(Build.VERSION_CODES.KITKAT), +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java, +import android.support.annotation.RequiresApi;, +@RequiresApi(Build.VERSION_CODES.KITKAT), +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java, +import android.annotation.TargetApi;, +  @TargetApi(Build.VERSION_CODES.KITKAT), +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +    public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java, +import android.support.annotation.RequiresApi;, +@RequiresApi(Build.VERSION_CODES.KITKAT), +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java, +import android.support.annotation.RequiresApi;, +@RequiresApi(Build.VERSION_CODES.KITKAT), +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java, +import android.annotation.TargetApi;, +  @TargetApi(Build.VERSION_CODES.KITKAT), +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +    public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) {, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java, +import android.support.annotation.RequiresApi;, +@RequiresApi(Build.VERSION_CODES.KITKAT), +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java, +import android.support.annotation.RequiresApi;, +@RequiresApi(Build.VERSION_CODES.KITKAT), +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java, +import android.annotation.TargetApi;, +  @TargetApi(Build.VERSION_CODES.KITKAT), +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +    public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) {, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java, +++ b/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java, +import android.support.annotation.RequiresApi;, +  @RequiresApi(Build.VERSION_CODES.KITKAT), +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java, +import android.support.annotation.RequiresApi;, +@RequiresApi(Build.VERSION_CODES.KITKAT), +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java, +import android.support.annotation.RequiresApi;, +@RequiresApi(Build.VERSION_CODES.KITKAT), +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java, +import android.annotation.TargetApi;, +  @TargetApi(Build.VERSION_CODES.KITKAT), +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +    public void onDecodeComplete(BitmapPool bitmapPool, Bitmap downsampled) {, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java, +++ b/library/src/main/java/com/bumptech/glide/request/target/FixedSizeDrawable.java, +import android.support.annotation.RequiresApi;, +  @RequiresApi(Build.VERSION_CODES.KITKAT), +++ b/library/src/main/java/com/bumptech/glide/util/LogTime.java, +      Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1 ? 1d / Math.pow(10, 6) : 1d;]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java, +   * @return {@code true} to prevent {@link Target#onResourceReady(Object, Transition)} from, +   * being called on {@code target}, typically because the listener wants to, +   * update the {@code target} or the object the {@code target} wraps, +   * itself or {@code false} to allow {@link Target#onResourceReady(Object, Transition)}]
[+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +    defaultRequestOptions = defaultRequestOptions.apply(new RequestOptions().format(decodeFormat));]
[+++ b/library/src/main/java/com/bumptech/glide/util/Util.java, +    @Deprecated]
[+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +  private GlideExecutor animationExecutor;, +   * Sets the {@link GlideExecutor} to use when retrieving, +   * <p>The thread count defaults to the number of cores available on the device, with a maximum of, +   * 4., +   *, +   * <p>Use the {@link GlideExecutor#newSourceExecutor()} methods if you'd like to specify options, +   * for the source executor., +   *, +   * @param service The ExecutorService to use., +   * @return This builder., +   * @see #setDiskCacheExecutor(GlideExecutor), +   * @see GlideExecutor, +   *, +   * @deprecated Use {@link #setSourceExecutor(GlideExecutor)}, +   */, +  @Deprecated, +  public GlideBuilder setResizeExecutor(GlideExecutor service) {, +    return setSourceExecutor(service);, +  }, +, +  /**, +   * Sets the {@link GlideExecutor} to use when retrieving, +   * {@link com.bumptech.glide.load.engine.Resource}s that are not already in the cache., +   *, +   * <p>The thread count defaults to the number of cores available on the device, with a maximum of, +   * 4., +   *, +   * <p>Use the {@link GlideExecutor#newSourceExecutor()} methods if you'd like to specify options, +   * for the source executor., +  public GlideBuilder setSourceExecutor(GlideExecutor service) {, +   * Sets the {@link GlideExecutor} to use when retrieving, +   * {@link com.bumptech.glide.load.engine.Resource}s that are currently in Glide's disk caches., +   * <p>Defaults to a single thread which is usually the best combination of memory usage,, +   * jank, and performance, even on high end devices., +   * <p>Use the {@link GlideExecutor#newDiskCacheExecutor()} if you'd like to specify options, +   * for the disk cache executor., +   *, +   * @param service The {@link GlideExecutor} to use., +   * @see #setSourceExecutor(GlideExecutor), +   * Sets the {@link GlideExecutor} to use when loading frames of animated images and particularly, +   * of {@link com.bumptech.glide.load.resource.gif.GifDrawable}s., +   *, +   * <p>Defaults to one or two threads, depending on the number of cores available., +   *, +   * <p>Use the {@link GlideExecutor#newAnimationExecutor()} methods  if you'd like to specify, +   * options for the animation executor., +   *, +   * @param service The {@link GlideExecutor} to use., +   * @return This builder., +   */, +  public GlideBuilder setAnimationExecutor(GlideExecutor service) {, +    this.animationExecutor = service;, +    return this;, +  }, +, +  /**, +    if (animationExecutor == null) {, +      animationExecutor = GlideExecutor.newAnimationExecutor();, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +  private GlideExecutor animationExecutor;, +   * Sets the {@link GlideExecutor} to use when retrieving, +   * <p>The thread count defaults to the number of cores available on the device, with a maximum of, +   * 4., +   *, +   * <p>Use the {@link GlideExecutor#newSourceExecutor()} methods if you'd like to specify options, +   * for the source executor., +   *, +   * @param service The ExecutorService to use., +   * @return This builder., +   * @see #setDiskCacheExecutor(GlideExecutor), +   * @see GlideExecutor, +   *, +   * @deprecated Use {@link #setSourceExecutor(GlideExecutor)}, +   */, +  @Deprecated, +  public GlideBuilder setResizeExecutor(GlideExecutor service) {, +    return setSourceExecutor(service);, +  }, +, +  /**, +   * Sets the {@link GlideExecutor} to use when retrieving, +   * {@link com.bumptech.glide.load.engine.Resource}s that are not already in the cache., +   *, +   * <p>The thread count defaults to the number of cores available on the device, with a maximum of, +   * 4., +   *, +   * <p>Use the {@link GlideExecutor#newSourceExecutor()} methods if you'd like to specify options, +   * for the source executor., +  public GlideBuilder setSourceExecutor(GlideExecutor service) {, +   * Sets the {@link GlideExecutor} to use when retrieving, +   * {@link com.bumptech.glide.load.engine.Resource}s that are currently in Glide's disk caches., +   * <p>Defaults to a single thread which is usually the best combination of memory usage,, +   * jank, and performance, even on high end devices., +   * <p>Use the {@link GlideExecutor#newDiskCacheExecutor()} if you'd like to specify options, +   * for the disk cache executor., +   *, +   * @param service The {@link GlideExecutor} to use.]
[+++ b/.gitignore, +library/.gradle, +library/.settings]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +                // File wasn't able to create a directory, or the result exists but not a directory, +                return null;, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +                // File wasn't able to create a directory, or the result exists but not a directory, +                return null;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java, +        // TODO calling twice with different arguments makes it return the cache for the same directory, it's public!, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +                // File wasn't able to create a directory, or the result exists but not a directory, +                return null;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java, +        // TODO calling twice with different arguments makes it return the cache for the same directory, it's public!, +++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java, +            if (Log.isLoggable(TAG, Log.WARN)) {, +                Log.w(TAG, "Failed to encode data onto the OutputStream", e);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +                // File wasn't able to create a directory, or the result exists but not a directory, +                return null;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java, +        // TODO calling twice with different arguments makes it return the cache for the same directory, it's public!, +++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java, +            if (Log.isLoggable(TAG, Log.WARN)) {, +                Log.w(TAG, "Failed to encode data onto the OutputStream", e);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameManager.java, +        if (transformation == null) {, +            throw new NullPointerException("Transformation must not be null");, +        }, +, +        this.frameResourceDecoder = new GifFrameResourceDecoder(bitmapPool);, +        this.calculator = new MemorySizeCalculator(context);, +        this.frameLoader = new GifFrameModelLoader();, +        this.sourceEncoder = NullEncoder.get();, +            this.cacheDecoder = new FileToStreamDecoder<Bitmap>(new StreamBitmapDecoder(context));, +            this.encoder = new BitmapEncoder();, +            this.cacheDecoder = NullDecoder.get();, +            this.encoder = NullResourceEncoder.get();]
[+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java, +          int averageColor;, +          if (sampleSize == 1) {, +            int currentColorIndex = ((int) mainPixels[sx]) & 0xff;, +            averageColor = act[currentColorIndex];, +          } else {, +            // TODO: This is substantially slower (up to 50ms per frame) than just grabbing the, +            // current color index above, even with a sample size of 1., +            averageColor = averageColorsNear(sx, maxPositionInSource, currentFrame.iw);, +          }]
[+++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +            RequestListener<? super ModelType, TranscodeType> requestListener) {, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +            RequestListener<? super ModelType, TranscodeType> requestListener) {, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +    public DrawableRequestBuilder<ModelType> listener(, +            RequestListener<? super ModelType, GlideDrawable> requestListener) {, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +            RequestListener<? super ModelType, TranscodeType> requestListener) {, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +    public DrawableRequestBuilder<ModelType> listener(, +            RequestListener<? super ModelType, GlideDrawable> requestListener) {, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +    private RequestListener<? super ModelType, TranscodeType> requestListener;, +            RequestListener<? super ModelType, TranscodeType> requestListener) {, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +            RequestListener<? super ModelType, TranscodeType> requestListener) {, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +    public DrawableRequestBuilder<ModelType> listener(, +            RequestListener<? super ModelType, GlideDrawable> requestListener) {, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +    private RequestListener<? super ModelType, TranscodeType> requestListener;, +            RequestListener<? super ModelType, TranscodeType> requestListener) {, +++ b/library/src/main/java/com/bumptech/glide/GifRequestBuilder.java, +            RequestListener<? super ModelType, GifDrawable> requestListener) {, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +            RequestListener<? super ModelType, TranscodeType> requestListener) {, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +    public DrawableRequestBuilder<ModelType> listener(, +            RequestListener<? super ModelType, GlideDrawable> requestListener) {, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +    private RequestListener<? super ModelType, TranscodeType> requestListener;, +            RequestListener<? super ModelType, TranscodeType> requestListener) {, +++ b/library/src/main/java/com/bumptech/glide/GifRequestBuilder.java, +            RequestListener<? super ModelType, GifDrawable> requestListener) {, +++ b/library/src/main/java/com/bumptech/glide/request/GenericRequest.java, +    private RequestListener<? super A, R> requestListener;, +            RequestListener<? super A, R> requestListener,, +            RequestListener<? super A, R> requestListener,, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +            RequestListener<? super ModelType, TranscodeType> requestListener) {, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +    public DrawableRequestBuilder<ModelType> listener(, +            RequestListener<? super ModelType, GlideDrawable> requestListener) {, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +    private RequestListener<? super ModelType, TranscodeType> requestListener;, +            RequestListener<? super ModelType, TranscodeType> requestListener) {, +++ b/library/src/main/java/com/bumptech/glide/GifRequestBuilder.java, +            RequestListener<? super ModelType, GifDrawable> requestListener) {, +++ b/library/src/main/java/com/bumptech/glide/request/GenericRequest.java, +    private RequestListener<? super A, R> requestListener;, +            RequestListener<? super A, R> requestListener,, +            RequestListener<? super A, R> requestListener,, +++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/FullscreenActivity.java, +                .listener(new RequestListener<Object, GlideDrawable>() {, +                    public boolean onException(Exception e, Object model, Target<GlideDrawable> target,, +                    public boolean onResourceReady(GlideDrawable resource, Object model, Target<GlideDrawable> target,]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +      List<?> values = (List<?>) value;, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +      List<?> values = (List<?>) value;, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +import java.util.HashSet;, +import java.util.Set;, +          .addAnnotation(SafeVarargs.class), +          .addAnnotation(, +              AnnotationSpec.builder(SuppressWarnings.class), +                  .addMember("value", "$S", "varargs"), +                  .build());, +                        && !input.type.equals(TypeName.get(SafeVarargs.class)), +                        // We need to combine warnings below., +                        && !input.type.equals(TypeName.get(SuppressWarnings.class));, +    AnnotationSpec suppressWarnings = buildSuppressWarnings(requestOptionMethod);, +    if (suppressWarnings != null) {, +      result.addAnnotation(suppressWarnings);, +    }, +    return result.build();, +  @Nullable, +  private AnnotationSpec buildSuppressWarnings(MethodSpec requestOptionMethod) {, +    Set<String> suppressions = new HashSet<>();, +    if (requestOptionMethod.annotations.contains(, +        AnnotationSpec.builder(SuppressWarnings.class).build())) {, +      for (AnnotationSpec annotation : requestOptionMethod.annotations) {, +        if (annotation.type.equals(TypeName.get(SuppressWarnings.class))) {, +          List<CodeBlock> codeBlocks = annotation.members.get("value");, +          suppressions.addAll(FluentIterable.from(codeBlocks).transform(, +              new Function<CodeBlock, String>() {, +                @Override, +                public String apply(CodeBlock input) {, +                  return input.toString();, +                }, +              }).toSet());, +        }, +      }, +    }, +, +    if (requestOptionMethod.annotations.contains(, +        AnnotationSpec.builder(SafeVarargs.class).build())) {, +      suppressions.add("unchecked");, +      suppressions.add("varargs");, +    }, +, +    if (suppressions.isEmpty()) {, +      return null;, +    }, +, +    AnnotationSpec.Builder builder = AnnotationSpec.builder(SuppressWarnings.class);, +    for (String suppression : suppressions) {, +      builder.addMember("value", "$S", suppression);, +    }, +, +    return builder.build();, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +      List<?> values = (List<?>) value;, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +import java.util.HashSet;, +import java.util.Set;, +          .addAnnotation(SafeVarargs.class), +          .addAnnotation(, +              AnnotationSpec.builder(SuppressWarnings.class), +                  .addMember("value", "$S", "varargs"), +                  .build());, +                        && !input.type.equals(TypeName.get(SafeVarargs.class)), +                        // We need to combine warnings below., +                        && !input.type.equals(TypeName.get(SuppressWarnings.class));, +    AnnotationSpec suppressWarnings = buildSuppressWarnings(requestOptionMethod);, +    if (suppressWarnings != null) {, +      result.addAnnotation(suppressWarnings);, +    }, +    return result.build();, +  @Nullable, +  private AnnotationSpec buildSuppressWarnings(MethodSpec requestOptionMethod) {, +    Set<String> suppressions = new HashSet<>();, +    if (requestOptionMethod.annotations.contains(, +        AnnotationSpec.builder(SuppressWarnings.class).build())) {, +      for (AnnotationSpec annotation : requestOptionMethod.annotations) {, +        if (annotation.type.equals(TypeName.get(SuppressWarnings.class))) {, +          List<CodeBlock> codeBlocks = annotation.members.get("value");, +          suppressions.addAll(FluentIterable.from(codeBlocks).transform(, +              new Function<CodeBlock, String>() {, +                @Override, +                public String apply(CodeBlock input) {, +                  return input.toString();, +                }, +              }).toSet());, +        }, +      }, +    }, +, +    if (requestOptionMethod.annotations.contains(, +        AnnotationSpec.builder(SafeVarargs.class).build())) {, +      suppressions.add("unchecked");, +      suppressions.add("varargs");, +    }, +, +    if (suppressions.isEmpty()) {, +      return null;]
[+++ b/gradle.properties, +SUPPORT_V4_VERSION=22.2.0, +SUPPORT_V7_VERSION=22.2.0]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java, +import com.bumptech.glide.tests.Util;, +        Util.setSdkVersionInt(initialSdkVersion);, +        Util.setSdkVersionInt(10);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java, +import com.bumptech.glide.tests.Util;, +        Util.setSdkVersionInt(initialSdkVersion);, +        Util.setSdkVersionInt(10);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java, +import com.bumptech.glide.tests.Util;, +        Util.setSdkVersionInt(currentBuildVersion);, +        Util.setSdkVersionInt(18);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java, +import com.bumptech.glide.tests.Util;, +        Util.setSdkVersionInt(initialSdkVersion);, +        Util.setSdkVersionInt(10);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java, +import com.bumptech.glide.tests.Util;, +        Util.setSdkVersionInt(currentBuildVersion);, +        Util.setSdkVersionInt(18);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +import android.os.Build;, +import com.bumptech.glide.tests.Util;, +import org.junit.After;, +    private int initialSdkVersion;, +        initialSdkVersion = Build.VERSION.SDK_INT;, +    }, +, +    @After, +    public void tearDown() {, +        Util.setSdkVersionInt(initialSdkVersion);, +    public void testStopsWhenCurrentFrameFinishesIfHasNoCallbackAndIsAtLeastAtHoneycomb() {, +    public void testDoesNotStopWhenCurrentFrameFinishesIfHasNoCallbackAndIsPreHoneycomb() {, +        Util.setSdkVersionInt(10);, +, +        drawable.setIsRunning(true);, +        drawable.setCallback(null);, +        drawable.onFrameRead(0);, +, +        assertTrue(drawable.isRunning());, +    }, +, +    @Test, +    public void testResetsFrameManagerWhenCurrentFinishesIfHasNoCallbackAndIsAtLeastAtHoneycomb() {, +        drawable.setIsRunning(true);, +        drawable.setCallback(null);, +        drawable.onFrameRead(0);, +, +, +        verify(frameManager).clear();, +    }, +, +    @Test, +    public void testDoesNotResetFrameManagerWhenCurrentFinishesIfHasNoCallbackPreHoneycomb() {, +        Util.setSdkVersionInt(10);, +, +        drawable.setIsRunning(true);, +        drawable.setCallback(null);, +        drawable.onFrameRead(0);, +, +        verify(frameManager, never()).clear();, +    }, +, +    @Test, +    public void testDoesNotResetOnStopIfAtLeastAtHoneycomb() {, +        drawable.start();, +        drawable.stop();, +, +        verify(frameManager, never()).clear();, +        // invalidate once from start., +        verify(cb, times(1)).invalidateDrawable(eq(drawable));, +    }, +, +    @Test, +    public void testDoesResetOnStopIfPreHoneycomb() {, +        Util.setSdkVersionInt(10);, +        drawable.start();, +        drawable.stop();, +, +        verify(frameManager).clear();, +        verify(cb, times(2)).invalidateDrawable(eq(drawable));, +    }, +, +    @Test, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java, +import com.bumptech.glide.tests.Util;, +        Util.setSdkVersionInt(initialSdkVersion);, +        Util.setSdkVersionInt(10);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java, +import com.bumptech.glide.tests.Util;, +        Util.setSdkVersionInt(currentBuildVersion);, +        Util.setSdkVersionInt(18);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +import android.os.Build;, +import com.bumptech.glide.tests.Util;, +import org.junit.After;, +    private int initialSdkVersion;, +        initialSdkVersion = Build.VERSION.SDK_INT;, +    }, +]
[+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java, +import dagger.android.AndroidInjectionModule;, +/** Specifies Dagger modules for {@link ImgurApplication}. */, +@Component(, +    modules = {, +      AndroidInjectionModule.class,, +public interface ImgurApplicationComponent extends AndroidInjector<ImgurApplication> {}]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import com.bumptech.glide.signature.ObjectKey;, +    return loadGeneric(model).apply(signatureOf(new ObjectKey(UUID.randomUUID().toString())), +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import com.bumptech.glide.signature.ObjectKey;, +    return loadGeneric(model).apply(signatureOf(new ObjectKey(UUID.randomUUID().toString())), +++ b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java, +    return new ObjectKey(versionCode);, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import com.bumptech.glide.signature.ObjectKey;, +    return loadGeneric(model).apply(signatureOf(new ObjectKey(UUID.randomUUID().toString())), +++ b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java, +    return new ObjectKey(versionCode);, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import com.bumptech.glide.signature.ObjectKey;, +    return loadGeneric(model).apply(signatureOf(new ObjectKey(UUID.randomUUID().toString())), +++ b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java, +    return new ObjectKey(versionCode);, +++ /dev/null, +++ b/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java, +import com.bumptech.glide.signature.ObjectKey;, +        factory.sourceKey = new ObjectKey("secondKey");, +        factory.signature = new ObjectKey("secondSignature");, +    Key sourceKey = new ObjectKey("sourceKey");, +    Key signature = new ObjectKey("signature");, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import com.bumptech.glide.signature.ObjectKey;, +    return loadGeneric(model).apply(signatureOf(new ObjectKey(UUID.randomUUID().toString())), +++ b/library/src/main/java/com/bumptech/glide/signature/ApplicationVersionSignature.java, +    return new ObjectKey(versionCode);, +++ /dev/null, +++ b/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java, +import com.bumptech.glide.signature.ObjectKey;, +        factory.sourceKey = new ObjectKey("secondKey");, +        factory.signature = new ObjectKey("secondSignature");, +    Key sourceKey = new ObjectKey("sourceKey");, +    Key signature = new ObjectKey("signature");, +++ /dev/null]
[+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +import android.content.res.Resources;, +  private static final int THEME = 1 << 16;, +  private Resources.Theme theme;, +   * Sets the {@link android.content.res.Resources.Theme} to apply when loading {@link Drawable}s, +   * for resource ids provided via {@link #error(int)}, {@link #placeholder(int)}, and, +   * {@link #fallback(Drawable)}., +   *, +   * @param theme The theme to use when loading Drawables., +   * @return this request builder., +   */, +  public final CHILD theme(Resources.Theme theme) {, +    this.theme = theme;, +    fields |= THEME;, +, +    return selfOrThrowIfLocked();, +  }, +, +  /**, +    if (isSet(other.fields, THEME)) {, +      theme = other.theme;, +    }, +  public final Resources.Theme getTheme() {, +    return theme;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +import android.content.res.Resources;, +  private static final int THEME = 1 << 16;, +  private Resources.Theme theme;, +   * Sets the {@link android.content.res.Resources.Theme} to apply when loading {@link Drawable}s, +   * for resource ids provided via {@link #error(int)}, {@link #placeholder(int)}, and, +   * {@link #fallback(Drawable)}., +   *, +   * @param theme The theme to use when loading Drawables., +   * @return this request builder., +   */, +  public final CHILD theme(Resources.Theme theme) {, +    this.theme = theme;, +    fields |= THEME;, +, +    return selfOrThrowIfLocked();, +  }, +, +  /**, +    if (isSet(other.fields, THEME)) {, +      theme = other.theme;, +    }, +  public final Resources.Theme getTheme() {, +    return theme;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +import android.content.res.Resources;, +import android.support.v4.content.res.ResourcesCompat;, +        errorDrawable = loadDrawable(requestOptions.getErrorId());, +        placeholderDrawable = loadDrawable(requestOptions.getPlaceholderId());, +        fallbackDrawable = loadDrawable(requestOptions.getFallbackId());, +  private Drawable loadDrawable(int resouceId) {, +    Resources resources = glideContext.getResources();, +    return ResourcesCompat.getDrawable(resources, resouceId, requestOptions.getTheme());, +  }, +]
[+++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.model.MultiModelLoaderFactory;, +import static com.bumptech.glide.request.RequestOptions.placeholderOf;, +import static org.junit.Assert.assertNotNull;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.anyObject;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Matchers.notNull;, +import static org.mockito.Mockito.doAnswer;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, +        when(mockUrlLoaderFactory.build(any(Context.class), any(MultiModelLoaderFactory.class))), +        Glide.get(getContext()).prepend(GlideUrl.class, InputStream.class, mockUrlLoaderFactory);, +        when(failFactory.build(any(Context.class), any(MultiModelLoaderFactory.class))).thenReturn(failLoader);, +        Glide.get(getContext()).prepend(failModel, failResource, failFactory);, +        when(modelLoaderFactory.build(any(Context.class), any(MultiModelLoaderFactory.class))), +        Glide.get(Robolectric.application).prepend(modelClass, InputStream.class, modelLoaderFactory);, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.model.MultiModelLoaderFactory;, +import static com.bumptech.glide.request.RequestOptions.placeholderOf;, +import static org.junit.Assert.assertNotNull;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.anyObject;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Matchers.notNull;, +import static org.mockito.Mockito.doAnswer;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, +        when(mockUrlLoaderFactory.build(any(Context.class), any(MultiModelLoaderFactory.class))), +        Glide.get(getContext()).prepend(GlideUrl.class, InputStream.class, mockUrlLoaderFactory);, +        when(failFactory.build(any(Context.class), any(MultiModelLoaderFactory.class))).thenReturn(failLoader);, +        Glide.get(getContext()).prepend(failModel, failResource, failFactory);, +        when(modelLoaderFactory.build(any(Context.class), any(MultiModelLoaderFactory.class))), +        Glide.get(Robolectric.application).prepend(modelClass, InputStream.class, modelLoaderFactory);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/resource/ByteArrayFetcherTest.java, +import static com.google.common.truth.Truth.assertThat;, +        ByteArrayFetcher fetcher = new ByteArrayFetcher(bytes);, +    public void testReturnsEmptyId() {, +        ByteArrayFetcher fetcher = new ByteArrayFetcher(new byte[0]);, +        assertThat(fetcher.getId()).isEmpty();, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.model.MultiModelLoaderFactory;, +import static com.bumptech.glide.request.RequestOptions.placeholderOf;, +import static org.junit.Assert.assertNotNull;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.anyObject;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Matchers.notNull;, +import static org.mockito.Mockito.doAnswer;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, +        when(mockUrlLoaderFactory.build(any(Context.class), any(MultiModelLoaderFactory.class))), +        Glide.get(getContext()).prepend(GlideUrl.class, InputStream.class, mockUrlLoaderFactory);, +        when(failFactory.build(any(Context.class), any(MultiModelLoaderFactory.class))).thenReturn(failLoader);, +        Glide.get(getContext()).prepend(failModel, failResource, failFactory);, +        when(modelLoaderFactory.build(any(Context.class), any(MultiModelLoaderFactory.class))), +        Glide.get(Robolectric.application).prepend(modelClass, InputStream.class, modelLoaderFactory);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/resource/ByteArrayFetcherTest.java, +import static com.google.common.truth.Truth.assertThat;, +        ByteArrayFetcher fetcher = new ByteArrayFetcher(bytes);, +    public void testReturnsEmptyId() {, +        ByteArrayFetcher fetcher = new ByteArrayFetcher(new byte[0]);, +        assertThat(fetcher.getId()).isEmpty();, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertNull;, +import static org.junit.Assert.fail;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.anyObject;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.doAnswer;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.never;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, +        DataFetcherSet<?> dataFetcherSet = mock(DataFetcherSet.class);, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.model.MultiModelLoaderFactory;, +import static com.bumptech.glide.request.RequestOptions.placeholderOf;, +import static org.junit.Assert.assertNotNull;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.anyObject;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Matchers.notNull;, +import static org.mockito.Mockito.doAnswer;]
[+++ b/library/src/main/java/com/bumptech/glide/util/Util.java, +      throw new IllegalArgumentException("You must call this method on a background thread");]
[+++ b/gradle.properties, +VERSION_NAME=4.4.0-SNAPSHOT, +VERSION_MINOR=4, +VERSION_PATCH=0]
[+++ b/library/AndroidManifest.xml, +          android:versionName="3.1.0a" >]
[+++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import com.bumptech.glide.load.model.GlideUrl;, +        return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString()), requestFuture);, +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import com.bumptech.glide.load.model.GlideUrl;, +        return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString()), requestFuture);, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +import com.bumptech.glide.load.model.GlideUrl;, +import java.lang.reflect.Method;, +    private final GlideUrl url;, +    public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url) {, +    public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url,, +            VolleyRequestFuture<InputStream> requestFuture) {, +        // Make sure the string url safely encodes non ascii characters., +        String stringUrl = url.toURL().toString();, +        GlideRequest request = new GlideRequest(stringUrl, requestFuture, glideToVolleyPriority(priority));, +        return url.toString();, +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import com.bumptech.glide.load.model.GlideUrl;, +        return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString()), requestFuture);, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +import com.bumptech.glide.load.model.GlideUrl;, +import java.lang.reflect.Method;, +    private final GlideUrl url;, +    public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url) {, +    public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url,, +            VolleyRequestFuture<InputStream> requestFuture) {, +        // Make sure the string url safely encodes non ascii characters., +        String stringUrl = url.toURL().toString();, +        GlideRequest request = new GlideRequest(stringUrl, requestFuture, glideToVolleyPriority(priority));, +        return url.toString();, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java, +        return new VolleyStreamFetcher(requestQueue, url, new VolleyRequestFuture<InputStream>());, +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import com.bumptech.glide.load.model.GlideUrl;, +        return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString()), requestFuture);, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +import com.bumptech.glide.load.model.GlideUrl;, +import java.lang.reflect.Method;, +    private final GlideUrl url;, +    public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url) {, +    public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url,, +            VolleyRequestFuture<InputStream> requestFuture) {, +        // Make sure the string url safely encodes non ascii characters., +        String stringUrl = url.toURL().toString();, +        GlideRequest request = new GlideRequest(stringUrl, requestFuture, glideToVolleyPriority(priority));, +        return url.toString();, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java, +        return new VolleyStreamFetcher(requestQueue, url, new VolleyRequestFuture<InputStream>());, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/GlideUrlTest.java, +, +    @Test, +    public void testIssue133() throws MalformedURLException {, +        // u00e0=, +        final String original =  "http://www.commitstrip.com/wp-content/uploads/2014/07/", +                + "Excel-\u00E0-toutes-les-sauces-650-finalenglish.jpg";, +, +        final String escaped = "http://www.commitstrip.com/wp-content/uploads/2014/07/", +                + "Excel-%C3%A0-toutes-les-sauces-650-finalenglish.jpg";, +, +        GlideUrl glideUrlFromString = new GlideUrl(original);, +        assertEquals(escaped, glideUrlFromString.toURL().toString());, +, +        GlideUrl glideUrlFromEscapedString = new GlideUrl(escaped);, +        assertEquals(escaped, glideUrlFromEscapedString.toURL().toString());, +, +        GlideUrl glideUrlFromUrl = new GlideUrl(new URL(original));, +        assertEquals(escaped, glideUrlFromUrl.toURL().toString());, +, +        GlideUrl glideUrlFromEscapedUrl = new GlideUrl(new URL(escaped));, +        assertEquals(escaped, glideUrlFromEscapedUrl.toURL().toString());, +    }, +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import com.bumptech.glide.load.model.GlideUrl;, +        return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString()), requestFuture);, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +import com.bumptech.glide.load.model.GlideUrl;, +import java.lang.reflect.Method;, +    private final GlideUrl url;, +    public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url) {, +    public VolleyStreamFetcher(RequestQueue requestQueue, GlideUrl url,, +            VolleyRequestFuture<InputStream> requestFuture) {, +        // Make sure the string url safely encodes non ascii characters., +        String stringUrl = url.toURL().toString();, +        GlideRequest request = new GlideRequest(stringUrl, requestFuture, glideToVolleyPriority(priority));, +        return url.toString();, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java, +        return new VolleyStreamFetcher(requestQueue, url, new VolleyRequestFuture<InputStream>());, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/GlideUrlTest.java, +, +    @Test, +    public void testIssue133() throws MalformedURLException {, +        // u00e0=, +        final String original =  "http://www.commitstrip.com/wp-content/uploads/2014/07/", +                + "Excel-\u00E0-toutes-les-sauces-650-finalenglish.jpg";, +, +        final String escaped = "http://www.commitstrip.com/wp-content/uploads/2014/07/", +                + "Excel-%C3%A0-toutes-les-sauces-650-finalenglish.jpg";, +, +        GlideUrl glideUrlFromString = new GlideUrl(original);]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    context.getApplicationContext().registerComponentCallbacks(glide);, +    glideContext =, +        new GlideContext(, +            context, registry, imageViewTargetFactory, defaultRequestOptions, engine, logLevel);, +    Log.d("TEST", "trimMemory: " + level);, +    Log.d("TEST", "onLowMemory");, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    context.getApplicationContext().registerComponentCallbacks(glide);, +    glideContext =, +        new GlideContext(, +            context, registry, imageViewTargetFactory, defaultRequestOptions, engine, logLevel);, +    Log.d("TEST", "trimMemory: " + level);, +    Log.d("TEST", "onLowMemory");, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +public class GlideContext extends ContextWrapper {, +      Engine engine, int logLevel) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    context.getApplicationContext().registerComponentCallbacks(glide);, +    glideContext =, +        new GlideContext(, +            context, registry, imageViewTargetFactory, defaultRequestOptions, engine, logLevel);, +    Log.d("TEST", "trimMemory: " + level);, +    Log.d("TEST", "onLowMemory");, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +public class GlideContext extends ContextWrapper {, +      Engine engine, int logLevel) {, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +   *, +   * @deprecated This method is called automatically by Glide's internals and shouldn't be called, +   * externally., +  @Deprecated, +    glide.onTrimMemory(level);, +   *, +   * @deprecated This method is called automatically by Glide's internals and shouldn't be called, +   * externally., +  @Deprecated, +    glide.onLowMemory();, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    context.getApplicationContext().registerComponentCallbacks(glide);, +    glideContext =, +        new GlideContext(, +            context, registry, imageViewTargetFactory, defaultRequestOptions, engine, logLevel);, +    Log.d("TEST", "trimMemory: " + level);, +    Log.d("TEST", "onLowMemory");, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +public class GlideContext extends ContextWrapper {, +      Engine engine, int logLevel) {, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +   *, +   * @deprecated This method is called automatically by Glide's internals and shouldn't be called, +   * externally., +  @Deprecated, +    glide.onTrimMemory(level);, +   *, +   * @deprecated This method is called automatically by Glide's internals and shouldn't be called, +   * externally., +  @Deprecated, +    glide.onLowMemory();, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    context.getApplicationContext().registerComponentCallbacks(glide);, +    glideContext =, +        new GlideContext(, +            context, registry, imageViewTargetFactory, defaultRequestOptions, engine, logLevel);, +    Log.d("TEST", "trimMemory: " + level);, +    Log.d("TEST", "onLowMemory");, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +public class GlideContext extends ContextWrapper {, +      Engine engine, int logLevel) {, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +   *, +   * @deprecated This method is called automatically by Glide's internals and shouldn't be called, +   * externally., +  @Deprecated, +    glide.onTrimMemory(level);, +   *, +   * @deprecated This method is called automatically by Glide's internals and shouldn't be called, +   * externally., +  @Deprecated, +    glide.onLowMemory();, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java, +++ b/library/src/main/java/com/bumptech/glide/manager/SupportRequestManagerFragment.java, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    context.getApplicationContext().registerComponentCallbacks(glide);, +    glideContext =, +        new GlideContext(, +            context, registry, imageViewTargetFactory, defaultRequestOptions, engine, logLevel);, +    Log.d("TEST", "trimMemory: " + level);, +    Log.d("TEST", "onLowMemory");, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +public class GlideContext extends ContextWrapper {, +      Engine engine, int logLevel) {, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +   *, +   * @deprecated This method is called automatically by Glide's internals and shouldn't be called, +   * externally., +  @Deprecated, +    glide.onTrimMemory(level);, +   *]
[+++ b/gradle.properties, +VERSION_NAME=4.2.0-SNAPSHOT, +VERSION_MINOR=2]
[+++ b/.gitignore, +.settings, +/library/.classpath, +/library/.project]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +      try {, +      } catch (AbstractMethodError e) {, +        throw new IllegalStateException(, +            "Attempting to register a Glide v3 module. If you see this, you or one of your", +                + " dependencies may be including Glide v3 even though you're using Glide v4.", +                + " You'll need to find and remove (or update) the offending dependency.", +                + " The v3 module name is: " + module.getClass().getName(), e);, +      }]
[+++ b/gradle.properties, +VERSION_NAME=4.2.0]
[+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java, +import android.util.Log;, +  private static final String TAG = "ConnectivityMonitor";, +    try {, +    } catch (SecurityException e) {, +      // See #1417., +      if (Log.isLoggable(TAG, Log.WARN)) {, +        Log.w(TAG, "Failed to register", e);, +      }, +    }]
[+++ b/.travis.yml]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +  private static volatile boolean isInitializing;, +          // In the thread running initGlide(), one or more classes may call Glide.get(context)., +          // Without this check, those calls could trigger infinite recursion., +          if (isInitializing) {, +            throw new IllegalStateException("You cannot call Glide.get() in registerComponents(),", +                + " use the provided Glide instance instead");, +          }, +          isInitializing = true;, +          isInitializing = false;, +  public static synchronized void init(Glide glide) {, +  public static synchronized void tearDown() {, +    Glide glide = builder.build(applicationContext);, +    Glide.glide = glide;]
[+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +import android.support.annotation.Nullable;, +  @Nullable, +          && Util.bothNullOrEqual(model, that.model), +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +import android.support.annotation.Nullable;, +  @Nullable, +          && Util.bothNullOrEqual(model, that.model), +++ b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java, +    harness.model = null;, +    SingleRequest<List> nullModelRequest = harness.getRequest();, +    assertTrue(nullModelRequest.isEquivalentTo(nullModelRequest));, +    assertFalse(nullModelRequest.isEquivalentTo(originalRequest1));, +    assertFalse(originalRequest1.isEquivalentTo(nullModelRequest));, +, +    harness = new RequestHarness();]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java, +++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java]
[+++ b/library/project.properties, +android.library.reference.1=volley]
[+++ b/.travis.yml, +  licenses: , +    - 'android-sdk-license.*']
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java, +import java.util.Collection;, +import java.util.List;, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.TimeoutException;, +public final class GlideExecutor implements ExecutorService {, +, +, +, +  private static final String ANIMATION_EXECUTOR_NAME = "animation";, +, +  // Don't use more than four threads when automatically determining thread count.., +  private static final int MAXIMUM_AUTOMATIC_THREAD_COUNT = 4;, +, +  // May be accessed on other threads, but this is an optimization only so it's ok if we set its, +  // value more than once., +  private static volatile int bestThreadCount;, +, +  private final ExecutorService delegate;, +    return newDiskCacheExecutor(, +        DEFAULT_DISK_CACHE_EXECUTOR_THREADS,, +        DEFAULT_DISK_CACHE_EXECUTOR_NAME,, +        UncaughtThrowableStrategy.DEFAULT);, +    return newDiskCacheExecutor(, +        DEFAULT_DISK_CACHE_EXECUTOR_THREADS,, +        DEFAULT_DISK_CACHE_EXECUTOR_NAME,, +        uncaughtThrowableStrategy);, +    return new GlideExecutor(new ThreadPoolExecutor(, +        threadCount /* corePoolSize */,, +        threadCount /* maximumPoolSize */,, +        0 /* keepAliveTime */,, +        TimeUnit.MILLISECONDS,, +        new PriorityBlockingQueue<Runnable>(),, +        new DefaultThreadFactory(name, uncaughtThrowableStrategy, true)));, +    return newSourceExecutor(, +        calculateBestThreadCount(),, +        DEFAULT_SOURCE_EXECUTOR_NAME,, +    return newSourceExecutor(, +        DEFAULT_DISK_CACHE_EXECUTOR_THREADS,, +        DEFAULT_DISK_CACHE_EXECUTOR_NAME,, +        uncaughtThrowableStrategy);, +  public static GlideExecutor newSourceExecutor(, +      int threadCount, String name, UncaughtThrowableStrategy uncaughtThrowableStrategy) {, +    return new GlideExecutor(new ThreadPoolExecutor(, +        threadCount /* corePoolSize */,, +        threadCount /* maximumPoolSize */,, +        0 /* keepAliveTime */,, +        TimeUnit.MILLISECONDS,, +        new PriorityBlockingQueue<Runnable>(),, +        new DefaultThreadFactory(name, uncaughtThrowableStrategy, false)));, +    return new GlideExecutor(new ThreadPoolExecutor(, +        0,, +        Integer.MAX_VALUE,, +        TimeUnit.MILLISECONDS,, +        new SynchronousQueue<Runnable>(),, +        new DefaultThreadFactory(, +            false)));, +    return new GlideExecutor(new ThreadPoolExecutor(, +        0 /* corePoolSize */,, +        TimeUnit.MILLISECONDS,, +        new PriorityBlockingQueue<Runnable>(),, +        new DefaultThreadFactory(, +            true)));, +  GlideExecutor(ExecutorService delegate) {, +    this.delegate = delegate;, +    delegate.execute(command);, +    return delegate.submit(task);, +  @NonNull, +  @Override, +  public <T> List<Future<T>> invokeAll(@NonNull Collection<? extends Callable<T>> tasks), +      throws InterruptedException {, +    return delegate.invokeAll(tasks);, +, +  @NonNull, +  @Override, +  public <T> List<Future<T>> invokeAll(, +      @NonNull Collection<? extends Callable<T>> tasks,, +      long timeout,, +      @NonNull TimeUnit unit) throws InterruptedException {, +    return delegate.invokeAll(tasks, timeout, unit);, +, +  @NonNull, +  @Override, +  public <T> T invokeAny(@NonNull Collection<? extends Callable<T>> tasks), +      throws InterruptedException, ExecutionException {, +    return delegate.invokeAny(tasks);, +, +  @Override, +  public <T> T invokeAny(, +      @NonNull Collection<? extends Callable<T>> tasks,, +      long timeout,, +      @NonNull TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {, +    return delegate.invokeAny(tasks, timeout, unit);, +    return delegate.submit(task, result);, +    return delegate.submit(task);, +  }, +, +  @Override, +  public void shutdown() {, +    delegate.shutdown();]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java, +import org.robolectric.RobolectricTestRunner;, +, +import org.robolectric.RuntimeEnvironment;, +    downsampler = new Downsampler(RuntimeEnvironment.application.getResources().getDisplayMetrics(),, +        bitmapPool);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java, +import org.robolectric.RobolectricTestRunner;, +, +import org.robolectric.RuntimeEnvironment;, +    downsampler = new Downsampler(RuntimeEnvironment.application.getResources().getDisplayMetrics(),, +        bitmapPool);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +, +    Downsampler downsampler = new Downsampler(resources.getDisplayMetrics(), bitmapPool);, +            new ByteBufferBitmapDecoder(downsampler)), +            new StreamBitmapDecoder(downsampler)), +                new ByteBufferBitmapDecoder(downsampler))), +                new StreamBitmapDecoder(downsampler))), +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java, +import org.robolectric.RobolectricTestRunner;, +, +import org.robolectric.RuntimeEnvironment;, +    downsampler = new Downsampler(RuntimeEnvironment.application.getResources().getDisplayMetrics(),, +        bitmapPool);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +, +    Downsampler downsampler = new Downsampler(resources.getDisplayMetrics(), bitmapPool);, +            new ByteBufferBitmapDecoder(downsampler)), +            new StreamBitmapDecoder(downsampler)), +                new ByteBufferBitmapDecoder(downsampler))), +                new StreamBitmapDecoder(downsampler))), +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +import android.util.DisplayMetrics;, +  private final DisplayMetrics displayMetrics;, +  public Downsampler(DisplayMetrics displayMetrics, BitmapPool bitmapPool) {, +    this.displayMetrics = displayMetrics;, +, +    } else {, +      options.inDensity = options.inTargetDensity = 0;, +    // If we scaled, the Bitmap density will be our inTargetDensity. Here we correct it back to, +    // the expected density dpi., +    downsampled.setDensity(displayMetrics.densityDpi);, +]
[+++ b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java, +                    if (GLIDE_MODULE_VALUE.equals(appInfo.metaData.get(key))) {]
[+++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" />, +++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" />, +++ b/library/src/com/bumptech/glide/Glide.java, +import android.view.ViewGroup;, +import com.bumptech.glide.loader.model.FileLoader;, +import com.bumptech.glide.loader.model.GenericLoaderFactory;, +import com.bumptech.glide.loader.model.ModelLoader;, +import com.bumptech.glide.loader.model.ModelLoaderFactory;, +import com.bumptech.glide.loader.model.ResourceLoader;, +import com.bumptech.glide.loader.model.StringLoader;, +import com.bumptech.glide.loader.model.UriLoader;, +import com.bumptech.glide.loader.stream.StreamLoader;, +import com.bumptech.glide.loader.transformation.CenterCrop;, +import com.bumptech.glide.loader.transformation.FitCenter;, +import com.bumptech.glide.loader.transformation.MultiTransformationLoader;, +import com.bumptech.glide.loader.transformation.None;, +import com.bumptech.glide.loader.transformation.TransformationLoader;, +import com.bumptech.glide.presenter.target.Target;, +, +import java.util.Map;, +import java.util.WeakHashMap;, + * A singleton to present a simple static interface for Glide {@link Glide.Request} and to create and manage an, +    private final Map<Target, Metadata> metadataTracker = new WeakHashMap<Target, Metadata>();, +         *     public void onException(Exception e, T model, Target target) {, +        loaderFactory.register(File.class, new FileLoader.Factory());, +        loaderFactory.register(Integer.class, new ResourceLoader.Factory());, +        loaderFactory.register(String.class, new StringLoader.Factory());, +        loaderFactory.register(Uri.class, new UriLoader.Factory());, +            loaderFactory.register(URL.class, new VolleyUrlLoader.Factory());, +            loaderFactory.register(URL.class, new ModelLoaderFactory<URL>() {, +                ModelLoader<URL> errorUrlLoader = new ModelLoader<URL>() {, +                    @Override, +                    public StreamLoader getStreamLoader(URL model, int width, int height) {, +                        throw new IllegalArgumentException("No ModelLoaderFactory for urls registered with Glide");, +                    }, +, +                    @Override, +                    public String getId(URL model) {, +                        throw new IllegalArgumentException("No ModelLoaderFactory for urls registered with Glide");, +                    }, +                };, +, +                @Override, +                public ModelLoader<URL> build(Context context, GenericLoaderFactory factories) {, +                    return errorUrlLoader;, +                }, +, +                @Override @SuppressWarnings("unchecked"), +                public Class<? extends ModelLoader<URL>> loaderClass() {, +                    return (Class<ModelLoader<URL>>) errorUrlLoader.getClass();, +                }, +, +                @Override, +                public void teardown() {, +                }, +            });, +     * {@link ImageManager} with custom options for use with {@link com.bumptech.glide.Glide.Request} and/or as an, +     * Set the {@link ImageManager} to use with {@link Glide.Request}., +     * Set the {@link ImageManager} to use with {@link Glide.Request} Replaces the current, +     * models. Typically the {@link Glide#using(com.bumptech.glide.loader.model.ModelLoader)} syntax is preferred, +     * because it directly links the model with the ModelLoader being used to load it., +     *     used for any other model class, {@link com.bumptech.glide.loader.model.ModelLoaderFactory#teardown()}, +     * @param clazz The class, +     * @param factory The factory to use, +     * @param <T> The type of the model, +    public <T> void register(Class<T> clazz, ModelLoaderFactory<T> factory) {, +        ModelLoaderFactory<T> removed = loaderFactory.register(clazz, factory);, +     * @param clazz The class to get a {@link ModelLoader} for, +    public static <T> ModelLoader<T> buildModelLoader(Class<T> clazz, Context context) {, +        return GLIDE.loaderFactory.buildModelLoader(clazz, context);, +    }, +, +    @SuppressWarnings("unchecked"), +    private <T> ModelLoaderFactory<T> getFactory(T model) {, +        return loaderFactory.getFactory((Class<T>) model.getClass());, +    }, +, +    private ImageViewTarget getImageViewTarget(ImageView imageView) {, +        Object tag = imageView.getTag();, +        ImageViewTarget result = null;, +        if (tag instanceof ImageViewTarget) {, +            result = (ImageViewTarget) tag;, +        } else if (tag != null) {, +            throw new IllegalArgumentException("You cannot set a tag on an image view Glide is loading an image into");, +        }, +, +        return result;, +    }, +, +    private ImageViewTarget getImageViewTargetOrSet(ImageView imageView) {, +        ImageViewTarget result = getImageViewTarget(imageView);, +        if (result == null) {, +            result = new ImageViewTarget(imageView);, +            imageView.setTag(result);, +        }, +        return result;, +     * Set the {@link ModelLoaderFactory} and therefore the model type to use for a new load., +     *     Note - You can use this method to set a {@link ModelLoaderFactory} for models that don't have a default]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +  private MemoryCategory memoryCategory = MemoryCategory.NORMAL;, +   *, +   * @return the previous MemoryCategory used by Glide., +  public MemoryCategory setMemoryCategory(MemoryCategory memoryCategory) {, +    MemoryCategory oldCategory = this.memoryCategory;, +    this.memoryCategory = memoryCategory;, +    return oldCategory;]
[+++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +        return optionsApplier.apply(new BitmapRequestBuilder<ModelType, R>(transcodeClass, this)), +                .transcoder(transcoder);, +++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +        return optionsApplier.apply(new BitmapRequestBuilder<ModelType, R>(transcodeClass, this)), +                .transcoder(transcoder);, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +    private ResourceTranscoder<ResourceType, TranscodeType> transcoder;, +        this.transcoder = transcoder;, +        return this;, +                transcoder != null ? transcoder : glide.buildTranscoder(resourceClass, transcodeClass),, +++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +        return optionsApplier.apply(new BitmapRequestBuilder<ModelType, R>(transcodeClass, this)), +                .transcoder(transcoder);, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +    private ResourceTranscoder<ResourceType, TranscodeType> transcoder;, +        this.transcoder = transcoder;, +        return this;, +                transcoder != null ? transcoder : glide.buildTranscoder(resourceClass, transcodeClass),, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.gifdecoder.GifDecoder;, +import com.bumptech.glide.load.resource.gif.GifFrameModelLoader;, +import com.bumptech.glide.load.resource.gif.GifFrameResourceDecoder;, +        /** Gifs */, +        decoderRegistry.prepend(new GifResourceDecoder(context, bitmapPool), InputStream.class, GifDrawable.class);, +        decoderRegistry.prepend(new FileToStreamDecoder<GifDrawable>(new GifResourceDecoder(context, bitmapPool)),, +                File.class, GifDrawable.class);, +        /** Gif Frames */, +        register(GifDecoder.class, GifDecoder.class, new GifFrameModelLoader.Factory());, +        decoderRegistry.append(new GifFrameResourceDecoder(bitmapPool), GifDecoder.class, Bitmap.class);, +++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +        return optionsApplier.apply(new BitmapRequestBuilder<ModelType, R>(transcodeClass, this)), +                .transcoder(transcoder);, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +    private ResourceTranscoder<ResourceType, TranscodeType> transcoder;, +        this.transcoder = transcoder;, +        return this;, +                transcoder != null ? transcoder : glide.buildTranscoder(resourceClass, transcodeClass),, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.gifdecoder.GifDecoder;, +import com.bumptech.glide.load.resource.gif.GifFrameModelLoader;, +import com.bumptech.glide.load.resource.gif.GifFrameResourceDecoder;, +        /** Gifs */, +        decoderRegistry.prepend(new GifResourceDecoder(context, bitmapPool), InputStream.class, GifDrawable.class);, +        decoderRegistry.prepend(new FileToStreamDecoder<GifDrawable>(new GifResourceDecoder(context, bitmapPool)),, +                File.class, GifDrawable.class);, +        /** Gif Frames */, +        register(GifDecoder.class, GifDecoder.class, new GifFrameModelLoader.Factory());, +        decoderRegistry.append(new GifFrameResourceDecoder(bitmapPool), GifDecoder.class, Bitmap.class);, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +    boolean handles(T source) throws IOException;, +++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +        return optionsApplier.apply(new BitmapRequestBuilder<ModelType, R>(transcodeClass, this)), +                .transcoder(transcoder);, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +    private ResourceTranscoder<ResourceType, TranscodeType> transcoder;, +        this.transcoder = transcoder;, +        return this;, +                transcoder != null ? transcoder : glide.buildTranscoder(resourceClass, transcodeClass),, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.gifdecoder.GifDecoder;, +import com.bumptech.glide.load.resource.gif.GifFrameModelLoader;, +import com.bumptech.glide.load.resource.gif.GifFrameResourceDecoder;, +        /** Gifs */, +        decoderRegistry.prepend(new GifResourceDecoder(context, bitmapPool), InputStream.class, GifDrawable.class);, +        decoderRegistry.prepend(new FileToStreamDecoder<GifDrawable>(new GifResourceDecoder(context, bitmapPool)),, +                File.class, GifDrawable.class);, +        /** Gif Frames */, +        register(GifDecoder.class, GifDecoder.class, new GifFrameModelLoader.Factory());, +        decoderRegistry.append(new GifFrameResourceDecoder(bitmapPool), GifDecoder.class, Bitmap.class);, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +    boolean handles(T source) throws IOException;, +++ b/library/src/main/java/com/bumptech/glide/load/data/DataRewinderRegistry.java, +        DataRewinder.Factory result = rewinders.get(data.getClass());, +        if (result == null) {, +            for (DataRewinder.Factory<?> registeredFactory : rewinders.values()) {, +                if (registeredFactory.getDataClass().isAssignableFrom(data.getClass())) {, +                    result = registeredFactory;, +                    break;, +            }, +        }, +, +        if (result == null) {, +            result = DEFAULT_FACTORY;, +        }, +        return result.build(data);, +++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +        return optionsApplier.apply(new BitmapRequestBuilder<ModelType, R>(transcodeClass, this)), +                .transcoder(transcoder);, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +    private ResourceTranscoder<ResourceType, TranscodeType> transcoder;, +        this.transcoder = transcoder;, +        return this;, +                transcoder != null ? transcoder : glide.buildTranscoder(resourceClass, transcodeClass),, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.gifdecoder.GifDecoder;, +import com.bumptech.glide.load.resource.gif.GifFrameModelLoader;, +import com.bumptech.glide.load.resource.gif.GifFrameResourceDecoder;, +        /** Gifs */, +        decoderRegistry.prepend(new GifResourceDecoder(context, bitmapPool), InputStream.class, GifDrawable.class);]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +import android.support.v4.os.TraceCompat;, +    TraceCompat.beginSection("DecodeJob#run");, +    } finally {, +      TraceCompat.endSection();, +      TraceCompat.beginSection("DecodeJob.decodeFromRetrievedData");, +      try {, +      } finally {, +        TraceCompat.endSection();, +      }, +      TraceCompat.beginSection("DecodeJob.encode");, +        TraceCompat.endSection();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +import android.support.v4.os.TraceCompat;, +    TraceCompat.beginSection("DecodeJob#run");, +    } finally {, +      TraceCompat.endSection();, +      TraceCompat.beginSection("DecodeJob.decodeFromRetrievedData");, +      try {, +      } finally {, +        TraceCompat.endSection();, +      }, +      TraceCompat.beginSection("DecodeJob.encode");, +        TraceCompat.endSection();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +import android.support.v4.os.TraceCompat;, +    TraceCompat.beginSection("encode: [" + bitmap.getWidth() + "x" + bitmap.getHeight() + "]");, +    try {, +    } finally {, +      TraceCompat.endSection();, +    }]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java, +   *, +   * <p>This class makes no guarantees about the contents of the returned array., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java, +   *, +   * <p>This class makes no guarantees about the contents of the returned array., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java, +   *, +   * <p>This class makes no guarantees about the contents of the returned array., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java, +   *, +   * <p>This class makes no guarantees about the contents of the returned array., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java, +    if (result == null) {]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java, + *     private static final byte[] ID_BYTES = ID.getBytes(Charset.forName("UTF-8"));, + *     public boolean equals(Object o) {, + *     public void updateDiskCacheKey(MessageDigest messageDigest) {]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadVideoResourceTest.java, +package com.bumptech.glide;, +, +import static com.google.common.truth.Truth.assertThat;, +, +import android.content.ContentResolver;, +import android.content.Context;, +import android.content.res.Resources;, +import android.graphics.Bitmap;, +import android.graphics.drawable.Drawable;, +import android.net.Uri;, +import android.support.test.InstrumentationRegistry;, +import android.support.test.runner.AndroidJUnit4;, +import com.bumptech.glide.test.ConcurrencyHelper;, +import com.bumptech.glide.test.GlideApp;, +import com.bumptech.glide.test.ResourceIds;, +import com.bumptech.glide.test.TearDownGlide;, +import java.io.IOException;, +import java.util.concurrent.TimeUnit;, +import org.junit.Before;, +import org.junit.Rule;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.mockito.MockitoAnnotations;, +, +/**, + * Tests that Glide is able to load videos stored in resources and loaded as, + * {@link android.content.res.AssetFileDescriptor}s., + */, +@RunWith(AndroidJUnit4.class), +public class LoadVideoResourceTest {, +  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();, +  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();, +, +  private Context context;, +, +  @Before, +  public void setUp() throws IOException {, +    MockitoAnnotations.initMocks(this);, +    context = InstrumentationRegistry.getTargetContext();, +  }, +, +  @Test, +  public void loadVideoResourceId_fromInt_decodesFrame() {, +    Drawable frame =, +        concurrency.get(, +            Glide.with(context), +                .load(ResourceIds.raw.video), +                .submit());, +, +    assertThat(frame).isNotNull();, +  }, +, +  @Test, +  public void loadVideoResourceId_fromInt_withFrameTime_decodesFrame() {, +    Drawable frame =, +        concurrency.get(, +            GlideApp.with(context), +                .load(ResourceIds.raw.video), +                .frame(TimeUnit.SECONDS.toMicros(1)), +                .submit());, +, +    assertThat(frame).isNotNull();, +  }, +, +  // Testing boxed integer., +  @SuppressWarnings("UnnecessaryBoxing"), +  @Test, +  public void loadVideoResourceId_fromInteger_decodesFrame() {, +    Drawable frame =, +        concurrency.get(, +            Glide.with(context), +                .load(new Integer(ResourceIds.raw.video)), +                .submit());, +, +    assertThat(frame).isNotNull();, +  }, +, +  // Testing boxed integer., +  @SuppressWarnings("UnnecessaryBoxing"), +  @Test, +  public void loadVideoResourceId_fromInteger_withFrameTime_decodesFrame() {, +    Drawable frame =, +        concurrency.get(, +            GlideApp.with(context), +                .load(new Integer(ResourceIds.raw.video)), +                .frame(TimeUnit.SECONDS.toMicros(1)), +                .submit());, +, +    assertThat(frame).isNotNull();, +  }, +, +  @Test, +  public void loadVideoResourceId_asBitmap_decodesFrame() {, +    Bitmap frame =, +        concurrency.get(, +            Glide.with(context), +                .asBitmap()]
[+++ b/gradle.properties, +VERSION_NAME=4.7.1, +VERSION_MINOR=7, +VERSION_PATCH=1]
[+++ b/gradle.properties, +# TODO: Upgrade to latest version of Volley when we compile with Java 7., +VOLLEY_VERSION=1.0.8, +OK_HTTP_VERSION=2.2.0, +++ b/gradle.properties, +# TODO: Upgrade to latest version of Volley when we compile with Java 7., +VOLLEY_VERSION=1.0.8, +OK_HTTP_VERSION=2.2.0, +++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="library" exported="" name="okio-1.2.0" level="project" />, +    <orderEntry type="library" exported="" name="okhttp-2.2.0" level="project" />, +++ b/gradle.properties, +# TODO: Upgrade to latest version of Volley when we compile with Java 7., +VOLLEY_VERSION=1.0.8, +OK_HTTP_VERSION=2.2.0, +++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="library" exported="" name="okio-1.2.0" level="project" />, +    <orderEntry type="library" exported="" name="okhttp-2.2.0" level="project" />, +++ b/integration/volley/volley.iml, +    <orderEntry type="library" exported="" name="library-1.0.10" level="project" />, +++ b/gradle.properties, +# TODO: Upgrade to latest version of Volley when we compile with Java 7., +VOLLEY_VERSION=1.0.8, +OK_HTTP_VERSION=2.2.0, +++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="library" exported="" name="okio-1.2.0" level="project" />, +    <orderEntry type="library" exported="" name="okhttp-2.2.0" level="project" />, +++ b/integration/volley/volley.iml, +    <orderEntry type="library" exported="" name="library-1.0.10" level="project" />, +++ b/samples/flickr/flickr.iml, +    <orderEntry type="library" exported="" name="library-1.0.10" level="project" />, +++ b/gradle.properties, +# TODO: Upgrade to latest version of Volley when we compile with Java 7., +VOLLEY_VERSION=1.0.8, +OK_HTTP_VERSION=2.2.0, +++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="library" exported="" name="okio-1.2.0" level="project" />, +    <orderEntry type="library" exported="" name="okhttp-2.2.0" level="project" />, +++ b/integration/volley/volley.iml, +    <orderEntry type="library" exported="" name="library-1.0.10" level="project" />, +++ b/samples/flickr/flickr.iml, +    <orderEntry type="library" exported="" name="library-1.0.10" level="project" />, +++ b/samples/giphy/giphy.iml, +++ b/gradle.properties, +# TODO: Upgrade to latest version of Volley when we compile with Java 7., +VOLLEY_VERSION=1.0.8, +OK_HTTP_VERSION=2.2.0, +++ b/integration/okhttp/okhttp.iml, +    <orderEntry type="library" exported="" name="okio-1.2.0" level="project" />, +    <orderEntry type="library" exported="" name="okhttp-2.2.0" level="project" />, +++ b/integration/volley/volley.iml, +    <orderEntry type="library" exported="" name="library-1.0.10" level="project" />, +++ b/samples/flickr/flickr.iml, +    <orderEntry type="library" exported="" name="library-1.0.10" level="project" />, +++ b/samples/giphy/giphy.iml, +++ b/samples/svg/svg.iml]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +    return !options.get(GifOptions.DISABLE_ANIMATION), +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +    return !options.get(GifOptions.DISABLE_ANIMATION), +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifOptions.java, +package com.bumptech.glide.load.resource.gif;, +, +import com.bumptech.glide.load.DecodeFormat;, +import com.bumptech.glide.load.Option;, +import com.bumptech.glide.load.Options;, +import com.bumptech.glide.load.ResourceDecoder;, +, +/**, + * Options related to decoding GIFs., + */, +public final class GifOptions {, +, +  /**, +   * Indicates the {@link com.bumptech.glide.load.DecodeFormat} that will be used in conjunction, +   * with the particular GIF to determine the {@link android.graphics.Bitmap.Config} to use when, +   * decoding frames of GIFs., +   */, +  public static final Option<DecodeFormat> DECODE_FORMAT = Option.memory(, +      "com.bumptech.glide.load.resource.gif.DecodeFormat", DecodeFormat.DEFAULT);, +, +  /**, +   * If set to {@code true}, disables the GIF {@link com.bumptech.glide.load.ResourceDecoder}s, +   * ({@link ResourceDecoder#handles(Object, Options)} will return {@code false}). Defaults to, +   * {@code false}., +   */, +  public static final Option<Boolean> DISABLE_ANIMATION = Option.memory(, +      "com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder.DisableAnimation", false);, +, +  private GifOptions() {, +    // Utility class., +  }, +}, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +    return !options.get(GifOptions.DISABLE_ANIMATION), +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifOptions.java, +package com.bumptech.glide.load.resource.gif;, +, +import com.bumptech.glide.load.DecodeFormat;, +import com.bumptech.glide.load.Option;, +import com.bumptech.glide.load.Options;, +import com.bumptech.glide.load.ResourceDecoder;, +, +/**, + * Options related to decoding GIFs., + */, +public final class GifOptions {, +, +  /**, +   * Indicates the {@link com.bumptech.glide.load.DecodeFormat} that will be used in conjunction, +   * with the particular GIF to determine the {@link android.graphics.Bitmap.Config} to use when, +   * decoding frames of GIFs., +   */, +  public static final Option<DecodeFormat> DECODE_FORMAT = Option.memory(, +      "com.bumptech.glide.load.resource.gif.DecodeFormat", DecodeFormat.DEFAULT);, +, +  /**, +   * If set to {@code true}, disables the GIF {@link com.bumptech.glide.load.ResourceDecoder}s, +   * ({@link ResourceDecoder#handles(Object, Options)} will return {@code false}). Defaults to, +   * {@code false}., +   */, +  public static final Option<Boolean> DISABLE_ANIMATION = Option.memory(, +      "com.bumptech.glide.load.resource.gif.ByteBufferGifDecoder.DisableAnimation", false);, +, +  private GifOptions() {, +    // Utility class., +  }, +}, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java, +    return !options.get(GifOptions.DISABLE_ANIMATION), +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +    return !options.get(GifOptions.DISABLE_ANIMATION), +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifOptions.java, +package com.bumptech.glide.load.resource.gif;, +, +import com.bumptech.glide.load.DecodeFormat;, +import com.bumptech.glide.load.Option;, +import com.bumptech.glide.load.Options;, +import com.bumptech.glide.load.ResourceDecoder;, +, +/**, + * Options related to decoding GIFs., + */, +public final class GifOptions {, +, +  /**, +   * Indicates the {@link com.bumptech.glide.load.DecodeFormat} that will be used in conjunction, +   * with the particular GIF to determine the {@link android.graphics.Bitmap.Config} to use when, +   * decoding frames of GIFs., +   */, +  public static final Option<DecodeFormat> DECODE_FORMAT = Option.memory(, +      "com.bumptech.glide.load.resource.gif.DecodeFormat", DecodeFormat.DEFAULT);, +, +  /**, +   * If set to {@code true}, disables the GIF {@link com.bumptech.glide.load.ResourceDecoder}s, +   * ({@link ResourceDecoder#handles(Object, Options)} will return {@code false}). Defaults to]
[+++ b/gradle.properties, +OK_HTTP_VERSION=3.0.1, +++ b/gradle.properties, +OK_HTTP_VERSION=3.0.1, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +      public void onFailure(Call call, IOException e) {, +      public void onResponse(Call call, Response response) throws IOException {]
[+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +  private boolean isCallingCallbacks;, +    assertNotCallingCallbacks();, +    assertNotCallingCallbacks();, +    assertNotCallingCallbacks();, +  // Avoids difficult to understand errors like #2413., +  private void assertNotCallingCallbacks() {, +    if (isCallingCallbacks) {, +      throw new IllegalStateException("You can't start or clear loads in RequestListener or", +          + " Target callbacks. If you must do so, consider posting your into() or clear() calls", +          + " to the main thread using a Handler instead.");, +    }, +  }, +, +    assertNotCallingCallbacks();, +    isCallingCallbacks = true;, +    try {, +    } finally {, +      isCallingCallbacks = false;, +    }, +, +    isCallingCallbacks = true;, +    try {, +    } finally {, +      isCallingCallbacks = false;, +    }, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +  private boolean isCallingCallbacks;, +    assertNotCallingCallbacks();, +    assertNotCallingCallbacks();, +    assertNotCallingCallbacks();, +  // Avoids difficult to understand errors like #2413., +  private void assertNotCallingCallbacks() {, +    if (isCallingCallbacks) {, +      throw new IllegalStateException("You can't start or clear loads in RequestListener or", +          + " Target callbacks. If you must do so, consider posting your into() or clear() calls", +          + " to the main thread using a Handler instead.");, +    }, +  }, +, +    assertNotCallingCallbacks();, +    isCallingCallbacks = true;, +    try {, +    } finally {, +      isCallingCallbacks = false;, +    }, +, +    isCallingCallbacks = true;, +    try {, +    } finally {, +      isCallingCallbacks = false;, +    }, +++ b/library/src/main/java/com/bumptech/glide/request/target/PreloadTarget.java, +import android.os.Handler;, +import android.os.Handler.Callback;, +import android.os.Looper;, +import android.os.Message;, +  private static final int MESSAGE_CLEAR = 1;, +  private static final Handler HANDLER = new Handler(Looper.getMainLooper(), new Callback() {, +    @Override, +    public boolean handleMessage(Message message) {, +      if (message.what == MESSAGE_CLEAR) {, +        ((PreloadTarget<?>) message.obj).clear();, +        return true;, +      }, +      return false;, +    }, +  });, +    HANDLER.obtainMessage(MESSAGE_CLEAR, this).sendToTarget();, +  }, +, +  private void clear() {]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }, +    }, +}, +, +subprojects {, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = 1.7, +        targetCompatibility = 1.7, +    }, +}, +, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }]
[+++ b/.gitignore, +integration/volley/target/**, +**/local.properties, +++ b/.gitignore, +integration/volley/target/**, +**/local.properties, +++ b/README.md, +Glide is fast and efficient image loading library for Android that wraps image downloading, resizing, memory and disk, +caching, and bitmap recycling into one simple and easy to use interface. Glide includes a flexible api allowing it to, +plug in to almost any network stack. By default Glide uses a custom HttpUrlConnection based stack, but also includes a, +utility library to plug in to Google's Volley project instead., +Glide's primary focus is on making scrolling any kind of a list of images as smooth and fast as possible, but Glide is, +also effective for almost any case where you need to fetch, resize, and display a remote image., +You can download a jar from GitHub's [release page](https://github.com/bumptech/glide/releases) or to use the 3.0 alpha, +branch, use Gradle:, +  <artifactId>library</artifactId>, +Volley, +-------, +Volley is now an optional dependency that can be included via a utility library. More utility libraries for other, +projects will hopefully be coming soon. To use the utility library with Gradle, add:, +, +```groovy, +dependencies {, +    compile group: 'com.github.bumptech.glide', name:'volley', version:'3.3.0-SNAPSHOT', changing:true, +    compile 'com.mcxiaoke.volley:library:1.0.+', +}, +```, +, +Or with maven:, +, +```xml, +<dependency>, +    <groupId>com.github.bumptech.glide</groupId>, +    <artifactId>volley</artifactId>, +    <version>3.3.0-SNAPSHOT</version>, +    <type>aar</type>, +</dependency>, +<dependency>, +    <groupId>com.mcxiaoke.volley</groupId>, +    <artifactId>library</artifactId>, +    <version>1.0.5</version>, +    <type>aar</type>, +</dependency>, +```, +, +++ b/.gitignore, +integration/volley/target/**, +**/local.properties, +++ b/README.md, +Glide is fast and efficient image loading library for Android that wraps image downloading, resizing, memory and disk, +caching, and bitmap recycling into one simple and easy to use interface. Glide includes a flexible api allowing it to, +plug in to almost any network stack. By default Glide uses a custom HttpUrlConnection based stack, but also includes a, +utility library to plug in to Google's Volley project instead., +Glide's primary focus is on making scrolling any kind of a list of images as smooth and fast as possible, but Glide is, +also effective for almost any case where you need to fetch, resize, and display a remote image., +You can download a jar from GitHub's [release page](https://github.com/bumptech/glide/releases) or to use the 3.0 alpha, +branch, use Gradle:, +  <artifactId>library</artifactId>, +Volley, +-------, +Volley is now an optional dependency that can be included via a utility library. More utility libraries for other, +projects will hopefully be coming soon. To use the utility library with Gradle, add:, +, +```groovy, +dependencies {, +    compile group: 'com.github.bumptech.glide', name:'volley', version:'3.3.0-SNAPSHOT', changing:true, +    compile 'com.mcxiaoke.volley:library:1.0.+', +}, +```, +, +Or with maven:, +, +```xml, +<dependency>, +    <groupId>com.github.bumptech.glide</groupId>, +    <artifactId>volley</artifactId>, +    <version>3.3.0-SNAPSHOT</version>, +    <type>aar</type>, +</dependency>, +<dependency>, +    <groupId>com.mcxiaoke.volley</groupId>, +    <artifactId>library</artifactId>, +    <version>1.0.5</version>, +    <type>aar</type>, +</dependency>, +```, +, +++ b/build.gradle, +evaluationDependsOn(":integration:volley"), +evaluationDependsOn(":third_party:gif_decoder"), +evaluationDependsOn(":library"), +++ b/.gitignore, +integration/volley/target/**, +**/local.properties, +++ b/README.md, +Glide is fast and efficient image loading library for Android that wraps image downloading, resizing, memory and disk, +caching, and bitmap recycling into one simple and easy to use interface. Glide includes a flexible api allowing it to, +plug in to almost any network stack. By default Glide uses a custom HttpUrlConnection based stack, but also includes a, +utility library to plug in to Google's Volley project instead., +Glide's primary focus is on making scrolling any kind of a list of images as smooth and fast as possible, but Glide is]
[+++ b/integration/okhttp/build.gradle, +    compile "com.android.support:support-annotations:{$SUPPORT_V4_VERSION}", +++ b/integration/okhttp/build.gradle, +    compile "com.android.support:support-annotations:{$SUPPORT_V4_VERSION}", +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/integration/okhttp/build.gradle, +    compile "com.android.support:support-annotations:{$SUPPORT_V4_VERSION}", +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/integration/okhttp3/build.gradle, +    compile "com.android.support:support-annotations:{$SUPPORT_V4_VERSION}", +++ b/integration/okhttp/build.gradle, +    compile "com.android.support:support-annotations:{$SUPPORT_V4_VERSION}", +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/integration/okhttp3/build.gradle, +    compile "com.android.support:support-annotations:{$SUPPORT_V4_VERSION}", +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/integration/okhttp/build.gradle, +    compile "com.android.support:support-annotations:{$SUPPORT_V4_VERSION}", +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/integration/okhttp3/build.gradle, +    compile "com.android.support:support-annotations:{$SUPPORT_V4_VERSION}", +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/integration/volley/build.gradle, +    compile "com.android.support:support-annotations:{$SUPPORT_V4_VERSION}", +++ b/integration/okhttp/build.gradle, +    compile "com.android.support:support-annotations:{$SUPPORT_V4_VERSION}", +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/integration/okhttp3/build.gradle, +    compile "com.android.support:support-annotations:{$SUPPORT_V4_VERSION}", +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/integration/volley/build.gradle, +    compile "com.android.support:support-annotations:{$SUPPORT_V4_VERSION}", +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/integration/okhttp/build.gradle, +    compile "com.android.support:support-annotations:{$SUPPORT_V4_VERSION}", +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/integration/okhttp3/build.gradle, +    compile "com.android.support:support-annotations:{$SUPPORT_V4_VERSION}", +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/integration/volley/build.gradle, +    compile "com.android.support:support-annotations:{$SUPPORT_V4_VERSION}", +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java, +import android.support.annotation.NonNull;, +  @NonNull, +++ b/integration/okhttp/build.gradle, +    compile "com.android.support:support-annotations:{$SUPPORT_V4_VERSION}", +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/integration/okhttp3/build.gradle, +    compile "com.android.support:support-annotations:{$SUPPORT_V4_VERSION}", +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/integration/volley/build.gradle, +    compile "com.android.support:support-annotations:{$SUPPORT_V4_VERSION}", +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }, +    }, +}, +, +subprojects {, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = 1.7, +        targetCompatibility = 1.7, +    }, +}, +, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +    return useUnlimitedSourceGeneratorPool, +        ? sourceUnlimitedExecutor : (useAnimationPool ? animationExecutor : sourceExecutor);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +    return useUnlimitedSourceGeneratorPool, +        ? sourceUnlimitedExecutor : (useAnimationPool ? animationExecutor : sourceExecutor);, +++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +   *, +   * <p>If both {@link #useUnlimitedSourceGeneratorsPool(boolean)} and, +   * {@link #useAnimationPool(boolean)} are set, {@link #useUnlimitedSourceGeneratorsPool(boolean)}, +   * will be preferred and {@link #useAnimationPool(boolean)} will be ignored., +   *, +   * <p>If both {@link #useUnlimitedSourceGeneratorsPool(boolean)} and, +   * {@link #useAnimationPool(boolean)} are set, {@link #useUnlimitedSourceGeneratorsPool(boolean)}, +   * will be preferred and {@link #useAnimationPool(boolean)} will be ignored.]
[+++ b/build.gradle, +++ b/build.gradle, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=2.4]
[+++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamAssetPathFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/ByteArrayLoader.java, +++ b/library/src/main/java/com/bumptech/glide/load/model/UnitModelLoader.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/LocalUriFetcherTest.java]
[+++ b/.travis.yml, +    - COMPONENT=firebase, +++ b/.travis.yml, +    - COMPONENT=firebase, +++ b/gcloud-bumptech.json.enc, +++ b/.travis.yml, +    - COMPONENT=firebase, +++ b/gcloud-bumptech.json.enc, +++ b/gcloud-sjudd.json.enc, +++ b/.travis.yml, +    - COMPONENT=firebase, +++ b/gcloud-bumptech.json.enc, +++ b/gcloud-sjudd.json.enc, +++ b/scripts/travis_firebase.sh, +#!/usr/bin/env bash, +, +set -e, +, +./gradlew :instrumentation:assembleDebug :instrumentation:assembleDebugAndroidTest --parallel &, +pid=$!, +, +openssl aes-256-cbc -K $encrypted_ad2664a1c4dd_key -iv $encrypted_ad2664a1c4dd_iv -in $GCLOUD_FILE -out gcloud.json -d, +, +wget https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-sdk-176.0.0-linux-x86_64.tar.gz, +tar xf google-cloud-sdk-176.0.0-linux-x86_64.tar.gz, +echo "y" | ./google-cloud-sdk/bin/gcloud components update beta, +./google-cloud-sdk/bin/gcloud auth activate-service-account --key-file gcloud.json, +, +wait $pid, +, +apk_dir=instrumentation/build/outputs/apk, +./google-cloud-sdk/bin/gcloud firebase test android run \, +  --type instrumentation \, +  --app $apk_dir/instrumentation-debug.apk \, +  --test $apk_dir/instrumentation-debug-androidTest.apk \, +  --device model=Nexus6P,version=26,locale=en,orientation=portrait  \, +  --project android-glide \, +  --no-auto-google-login \, +++ b/.travis.yml, +    - COMPONENT=firebase, +++ b/gcloud-bumptech.json.enc, +++ b/gcloud-sjudd.json.enc, +++ b/scripts/travis_firebase.sh, +#!/usr/bin/env bash, +, +set -e, +, +./gradlew :instrumentation:assembleDebug :instrumentation:assembleDebugAndroidTest --parallel &, +pid=$!, +, +openssl aes-256-cbc -K $encrypted_ad2664a1c4dd_key -iv $encrypted_ad2664a1c4dd_iv -in $GCLOUD_FILE -out gcloud.json -d, +, +wget https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-sdk-176.0.0-linux-x86_64.tar.gz, +tar xf google-cloud-sdk-176.0.0-linux-x86_64.tar.gz, +echo "y" | ./google-cloud-sdk/bin/gcloud components update beta, +./google-cloud-sdk/bin/gcloud auth activate-service-account --key-file gcloud.json, +, +wait $pid, +, +apk_dir=instrumentation/build/outputs/apk, +./google-cloud-sdk/bin/gcloud firebase test android run \, +  --type instrumentation \, +  --app $apk_dir/instrumentation-debug.apk \, +  --test $apk_dir/instrumentation-debug-androidTest.apk \, +  --device model=Nexus6P,version=26,locale=en,orientation=portrait  \, +  --project android-glide \, +  --no-auto-google-login \, +++ b/scripts/travis_instrumentation.sh, +./gradlew :instrumentation:assembleDebug :instrumentation:assembleDebugAndroidTest --parallel, +++ b/.travis.yml, +    - COMPONENT=firebase, +++ b/gcloud-bumptech.json.enc, +++ b/gcloud-sjudd.json.enc, +++ b/scripts/travis_firebase.sh, +#!/usr/bin/env bash, +, +set -e, +, +./gradlew :instrumentation:assembleDebug :instrumentation:assembleDebugAndroidTest --parallel &, +pid=$!, +, +openssl aes-256-cbc -K $encrypted_ad2664a1c4dd_key -iv $encrypted_ad2664a1c4dd_iv -in $GCLOUD_FILE -out gcloud.json -d, +, +wget https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-sdk-176.0.0-linux-x86_64.tar.gz, +tar xf google-cloud-sdk-176.0.0-linux-x86_64.tar.gz, +echo "y" | ./google-cloud-sdk/bin/gcloud components update beta, +./google-cloud-sdk/bin/gcloud auth activate-service-account --key-file gcloud.json, +, +wait $pid, +, +apk_dir=instrumentation/build/outputs/apk, +./google-cloud-sdk/bin/gcloud firebase test android run \, +  --type instrumentation \, +  --app $apk_dir/instrumentation-debug.apk \, +  --test $apk_dir/instrumentation-debug-androidTest.apk \, +  --device model=Nexus6P,version=26,locale=en,orientation=portrait  \, +  --project android-glide \, +  --no-auto-google-login \, +++ b/scripts/travis_instrumentation.sh, +./gradlew :instrumentation:assembleDebug :instrumentation:assembleDebugAndroidTest --parallel]
[+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +    private ExecutorService sourceService;, +        this.sourceService = service;, +        if (sourceService == null) {, +            sourceService = new FifoPriorityThreadPoolExecutor(cores);, +            engine = new Engine(memoryCache, diskCache, diskCacheService, sourceService);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +    private ExecutorService sourceService;, +        this.sourceService = service;, +        if (sourceService == null) {, +            sourceService = new FifoPriorityThreadPoolExecutor(cores);, +            engine = new Engine(memoryCache, diskCache, diskCacheService, sourceService);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +    public Engine(MemoryCache memoryCache, DiskCache diskCache, ExecutorService diskCacheService,, +            ExecutorService sourceService) {, +        this(memoryCache, diskCache, diskCacheService, sourceService, null, null, null, null);, +    Engine(MemoryCache cache, DiskCache diskCache, ExecutorService diskCacheService, ExecutorService sourceService,, +            Map<Key, EngineJob> jobs, EngineKeyFactory keyFactory,, +            engineJobFactory = new EngineJobFactory(diskCacheService, sourceService, this);, +        private final ExecutorService sourceService;, +        public EngineJobFactory(ExecutorService diskCacheService, ExecutorService sourceService,, +            this.sourceService = sourceService;, +            return new EngineJob(key, diskCacheService, sourceService, isMemoryCacheable, listener);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +    private ExecutorService sourceService;, +        this.sourceService = service;, +        if (sourceService == null) {, +            sourceService = new FifoPriorityThreadPoolExecutor(cores);, +            engine = new Engine(memoryCache, diskCache, diskCacheService, sourceService);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +    public Engine(MemoryCache memoryCache, DiskCache diskCache, ExecutorService diskCacheService,, +            ExecutorService sourceService) {, +        this(memoryCache, diskCache, diskCacheService, sourceService, null, null, null, null);, +    Engine(MemoryCache cache, DiskCache diskCache, ExecutorService diskCacheService, ExecutorService sourceService,, +            Map<Key, EngineJob> jobs, EngineKeyFactory keyFactory,, +            engineJobFactory = new EngineJobFactory(diskCacheService, sourceService, this);, +        private final ExecutorService sourceService;, +        public EngineJobFactory(ExecutorService diskCacheService, ExecutorService sourceService,, +            this.sourceService = sourceService;, +            return new EngineJob(key, diskCacheService, sourceService, isMemoryCacheable, listener);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java]
[+++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +    private Glide glide;, +        this.glide = glide;, +        return transform(glide.getBitmapCenterCrop());, +        return transform(glide.getBitmapFitCenter());, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +    private Glide glide;, +        this.glide = glide;, +        return transform(glide.getBitmapCenterCrop());, +        return transform(glide.getBitmapFitCenter());, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +        return transform(glide.getDrawableCenterCrop());, +        return transform(glide.getDrawableFitCenter());, +    public DrawableRequestBuilder<ModelType> transform(Transformation<GifBitmapWrapper> transformation) {, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +    private Glide glide;, +        this.glide = glide;, +        return transform(glide.getBitmapCenterCrop());, +        return transform(glide.getBitmapFitCenter());, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +        return transform(glide.getDrawableCenterCrop());, +        return transform(glide.getDrawableFitCenter());, +    public DrawableRequestBuilder<ModelType> transform(Transformation<GifBitmapWrapper> transformation) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.bitmap.CenterCrop;, +import com.bumptech.glide.load.resource.bitmap.FitCenter;, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapperTransformation;, +    private final CenterCrop bitmapCenterCrop;, +    private final GifBitmapWrapperTransformation drawableCenterCrop;, +    private final FitCenter bitmapFitCenter;, +    private final GifBitmapWrapperTransformation drawableFitCenter;, +, +        bitmapCenterCrop = new CenterCrop(bitmapPool);, +        drawableCenterCrop = new GifBitmapWrapperTransformation(bitmapCenterCrop);, +, +        bitmapFitCenter = new FitCenter(bitmapPool);, +        drawableFitCenter = new GifBitmapWrapperTransformation(bitmapFitCenter);, +    CenterCrop getBitmapCenterCrop() {, +        return bitmapCenterCrop;, +    }, +, +    FitCenter getBitmapFitCenter() {, +        return bitmapFitCenter;, +    }, +, +    GifBitmapWrapperTransformation getDrawableCenterCrop() {, +        return drawableCenterCrop;, +    }, +, +    GifBitmapWrapperTransformation getDrawableFitCenter() {, +        return drawableFitCenter;, +    }, +]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        throw new IllegalStateException("Cannot unregister not yet registered manager");]
[+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideModule.java, +import com.bumptech.glide.GlideBuilder;, +import com.bumptech.glide.load.DecodeFormat;, +import com.bumptech.glide.request.RequestOptions;, +, +  @Override, +  public void applyOptions(Context context, GlideBuilder builder) {, +    super.applyOptions(context, builder);, +    builder.setDefaultRequestOptions(new RequestOptions().format(DecodeFormat.PREFER_ARGB_8888));, +  }, +]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java, +            return new EngineKey(id, signature, width, height, resourceClass, transcodeClass);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java, +            return new EngineKey(id, signature, width, height, resourceClass, transcodeClass);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java, +import com.bumptech.glide.load.engine.DecodeOptions;, +import org.robolectric.Robolectric;, +        loader = new GifFrameLoader(Robolectric.application, callback, gifDecoder, handler, requestBuilder);, +        verify(requestBuilder).decode(any(DecodeOptions.class));, +        loader = new GifFrameLoader(Robolectric.application, callback, gifDecoder, null /*handler*/, requestBuilder);, +        loader = new GifFrameLoader(Robolectric.application, callback, gifDecoder, null /*handler*/, requestBuilder);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java, +            return new EngineKey(id, signature, width, height, resourceClass, transcodeClass);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java, +import com.bumptech.glide.load.engine.DecodeOptions;, +import org.robolectric.Robolectric;, +        loader = new GifFrameLoader(Robolectric.application, callback, gifDecoder, handler, requestBuilder);, +        verify(requestBuilder).decode(any(DecodeOptions.class));, +        loader = new GifFrameLoader(Robolectric.application, callback, gifDecoder, null /*handler*/, requestBuilder);, +        loader = new GifFrameLoader(Robolectric.application, callback, gifDecoder, null /*handler*/, requestBuilder);, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java, +            return new EngineKey(id, signature, width, height, resourceClass, transcodeClass);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java, +import com.bumptech.glide.load.engine.DecodeOptions;, +import org.robolectric.Robolectric;, +        loader = new GifFrameLoader(Robolectric.application, callback, gifDecoder, handler, requestBuilder);, +        verify(requestBuilder).decode(any(DecodeOptions.class));, +        loader = new GifFrameLoader(Robolectric.application, callback, gifDecoder, null /*handler*/, requestBuilder);, +        loader = new GifFrameLoader(Robolectric.application, callback, gifDecoder, null /*handler*/, requestBuilder);, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import com.bumptech.glide.load.engine.BaseDecodeOptions;, +import com.bumptech.glide.load.engine.DecodeOptions;, +    private BaseDecodeOptions<?> decodeOptions;, +        decodeOptions = new DecodeOptions(context);, +    public RequestBuilder<ResourceType, TranscodeType> decode(DecodeOptions options) {, +        this.decodeOptions.apply(Preconditions.checkNotNull(options));, +            result.decodeOptions = decodeOptions.clone();, +        if (!decodeOptions.isTransformationSet() && view.getScaleType() != null) {, +                    decodeOptions.centerCrop();, +                    decodeOptions.fitCenter();, +                        transcodeClass, decodeOptions, transcoder, requestOptions);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java, +            return new EngineKey(id, signature, width, height, resourceClass, transcodeClass);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java, +import com.bumptech.glide.load.engine.DecodeOptions;, +import org.robolectric.Robolectric;, +        loader = new GifFrameLoader(Robolectric.application, callback, gifDecoder, handler, requestBuilder);, +        verify(requestBuilder).decode(any(DecodeOptions.class));, +        loader = new GifFrameLoader(Robolectric.application, callback, gifDecoder, null /*handler*/, requestBuilder);, +        loader = new GifFrameLoader(Robolectric.application, callback, gifDecoder, null /*handler*/, requestBuilder);, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import com.bumptech.glide.load.engine.BaseDecodeOptions;, +import com.bumptech.glide.load.engine.DecodeOptions;, +    private BaseDecodeOptions<?> decodeOptions;, +        decodeOptions = new DecodeOptions(context);, +    public RequestBuilder<ResourceType, TranscodeType> decode(DecodeOptions options) {, +        this.decodeOptions.apply(Preconditions.checkNotNull(options));, +            result.decodeOptions = decodeOptions.clone();, +        if (!decodeOptions.isTransformationSet() && view.getScaleType() != null) {, +                    decodeOptions.centerCrop();, +                    decodeOptions.fitCenter();, +                        transcodeClass, decodeOptions, transcoder, requestOptions);, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +                .animate(new BitmapAnimationOptions());, +                .animate(new DrawableAnimationOptions());, +                .animate(new DrawableAnimationOptions());, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java, +            return new EngineKey(id, signature, width, height, resourceClass, transcodeClass);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java, +import com.bumptech.glide.load.engine.DecodeOptions;, +import org.robolectric.Robolectric;, +        loader = new GifFrameLoader(Robolectric.application, callback, gifDecoder, handler, requestBuilder);, +        verify(requestBuilder).decode(any(DecodeOptions.class));, +        loader = new GifFrameLoader(Robolectric.application, callback, gifDecoder, null /*handler*/, requestBuilder);, +        loader = new GifFrameLoader(Robolectric.application, callback, gifDecoder, null /*handler*/, requestBuilder);, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import com.bumptech.glide.load.engine.BaseDecodeOptions;, +import com.bumptech.glide.load.engine.DecodeOptions;, +    private BaseDecodeOptions<?> decodeOptions;, +        decodeOptions = new DecodeOptions(context);, +    public RequestBuilder<ResourceType, TranscodeType> decode(DecodeOptions options) {, +        this.decodeOptions.apply(Preconditions.checkNotNull(options));, +            result.decodeOptions = decodeOptions.clone();, +        if (!decodeOptions.isTransformationSet() && view.getScaleType() != null) {, +                    decodeOptions.centerCrop();, +                    decodeOptions.fitCenter();, +                        transcodeClass, decodeOptions, transcoder, requestOptions);, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +                .animate(new BitmapAnimationOptions());, +                .animate(new DrawableAnimationOptions());, +                .animate(new DrawableAnimationOptions());, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java, +            return new EngineKey(id, signature, width, height, resourceClass, transcodeClass);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java, +import com.bumptech.glide.load.engine.DecodeOptions;]
[+++ b/library/src/main/java/com/bumptech/glide/util/LruCache.java, +  protected synchronized int getCount() {]
[+++ b/CONTRIBUTING.md, +Similarly if you support a particular feature request, feel free to let us know by commenting on the issue., +<pre>**Glide Version/Integration library (if any)**:, +[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20%28if%20any%29**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details/Repro%20steps/Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60, +[5]: /bumptech/glide, +++ b/CONTRIBUTING.md, +Similarly if you support a particular feature request, feel free to let us know by commenting on the issue., +<pre>**Glide Version/Integration library (if any)**:, +[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20%28if%20any%29**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details/Repro%20steps/Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60, +[5]: /bumptech/glide, +++ b/README.md, +    mavenCentral(), +@Override, +public void onCreate(Bundle savedInstanceState) {, +@Override, +public View getView(int position, View recycled, ViewGroup container) {, +    Glide.with(myFragment), +OkHttp and Volley, +-----------------, +Support for OkHttp and Volley is provided by integration libraries you can optionally include as dependencies., +The integration libraries are available via Maven or the [releases page][1]., +, +For instructions on including either the OkHttp or the Volley integration libraries, see the [Integration Libraries][12] wiki page., +, +Android SDK Version, +-------------------, +Glide requires a minimum SDK version of 10., +, +License, +-------, +BSD, part MIT and Apache 2.0. See the [LICENSE][16] file for details., +, +[*Version 3*][14] is a stable public release used in multiple open source projects at Google including in the Android Camera, +Comments/bugs/questions/pull requests welcome!, +To open the project in Intellij 14:, +Sam Judd - @samajudd, +[5]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20%28if%20any%29**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details/Repro%20steps/Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60, +++ b/CONTRIBUTING.md, +Similarly if you support a particular feature request, feel free to let us know by commenting on the issue., +<pre>**Glide Version/Integration library (if any)**:, +[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20%28if%20any%29**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details/Repro%20steps/Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60, +[5]: /bumptech/glide, +++ b/README.md, +    mavenCentral(), +@Override, +public void onCreate(Bundle savedInstanceState) {, +@Override, +public View getView(int position, View recycled, ViewGroup container) {, +    Glide.with(myFragment), +OkHttp and Volley, +-----------------, +Support for OkHttp and Volley is provided by integration libraries you can optionally include as dependencies., +The integration libraries are available via Maven or the [releases page][1]., +, +For instructions on including either the OkHttp or the Volley integration libraries, see the [Integration Libraries][12] wiki page., +, +Android SDK Version, +-------------------, +Glide requires a minimum SDK version of 10., +, +License, +-------, +BSD, part MIT and Apache 2.0. See the [LICENSE][16] file for details., +, +[*Version 3*][14] is a stable public release used in multiple open source projects at Google including in the Android Camera, +Comments/bugs/questions/pull requests welcome!, +To open the project in Intellij 14:, +Sam Judd - @samajudd, +[5]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20%28if%20any%29**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details/Repro%20steps/Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60, +++ b/integration/gifencoder/gradle.properties, +++ b/CONTRIBUTING.md, +Similarly if you support a particular feature request, feel free to let us know by commenting on the issue., +<pre>**Glide Version/Integration library (if any)**:, +[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20%28if%20any%29**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details/Repro%20steps/Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60, +[5]: /bumptech/glide, +++ b/README.md, +    mavenCentral(), +@Override, +public void onCreate(Bundle savedInstanceState) {, +@Override, +public View getView(int position, View recycled, ViewGroup container) {, +    Glide.with(myFragment), +OkHttp and Volley, +-----------------, +Support for OkHttp and Volley is provided by integration libraries you can optionally include as dependencies., +The integration libraries are available via Maven or the [releases page][1]., +, +For instructions on including either the OkHttp or the Volley integration libraries, see the [Integration Libraries][12] wiki page., +, +Android SDK Version, +-------------------, +Glide requires a minimum SDK version of 10., +, +License, +-------, +BSD, part MIT and Apache 2.0. See the [LICENSE][16] file for details., +, +[*Version 3*][14] is a stable public release used in multiple open source projects at Google including in the Android Camera, +Comments/bugs/questions/pull requests welcome!, +To open the project in Intellij 14:]
[+++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +package com.bumptech.glide;, +, +import android.content.Context;, +import android.graphics.Bitmap;, +import android.os.ParcelFileDescriptor;, +import com.bumptech.glide.load.model.ImageVideoModelLoader;, +import com.bumptech.glide.load.model.ImageVideoWrapper;, +import com.bumptech.glide.load.model.ModelLoader;, +import com.bumptech.glide.load.resource.transcode.BitmapBytesTranscoder;, +import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;, +import com.bumptech.glide.provider.FixedLoadProvider;, +, +import java.io.InputStream;, +, +public class BitmapTypeRequest<A> extends BitmapRequestBuilder<A, Bitmap> {, +    private final Context context;, +    private final A model;, +    private final ModelLoader<A, InputStream> streamModelLoader;, +    private ModelLoader<A, ParcelFileDescriptor> fileDescriptorModelLoader;, +    private final Glide glide;, +, +    private static <A, R> FixedLoadProvider<A, ImageVideoWrapper, Bitmap, R> buildProvider(Glide glide,, +            ModelLoader<A, InputStream> streamModelLoader,, +            ModelLoader<A, ParcelFileDescriptor> fileDescriptorModelLoader,, +            Class<R> transcodedClass,, +            ResourceTranscoder<Bitmap, R> transcoder) {, +            return streamModelLoader == null && fileDescriptorModelLoader == null ? null :, +                    new FixedLoadProvider<A, ImageVideoWrapper, Bitmap, R>(, +                            new ImageVideoModelLoader<A>(streamModelLoader, fileDescriptorModelLoader),, +                            transcoder != null ? transcoder : glide.buildTranscoder(Bitmap.class, transcodedClass),, +                            glide.buildDataProvider(ImageVideoWrapper.class, Bitmap.class));, +    }, +, +    BitmapTypeRequest(Context context, A model,, +            ModelLoader<A, InputStream> streamModelLoader,, +            ModelLoader<A, ParcelFileDescriptor> fileDescriptorModelLoader,, +            Glide glide) {, +        super(context, model,, +                buildProvider(glide, streamModelLoader, fileDescriptorModelLoader, Bitmap.class, null),, +                Bitmap.class,, +                glide);, +        this.context = context;, +        this.model = model;, +        this.streamModelLoader = streamModelLoader;, +        this.fileDescriptorModelLoader = fileDescriptorModelLoader;, +        this.glide = glide;, +    }, +, +    public <R> BitmapRequestBuilder<A, R> transcode(ResourceTranscoder<Bitmap, R> transcoder, Class<R> transcodeClass) {, +        return new BitmapRequestBuilder<A, R>(context, model,, +                buildProvider(glide, streamModelLoader, fileDescriptorModelLoader, transcodeClass, transcoder),, +                transcodeClass, glide);, +    }, +, +    public BitmapRequestBuilder<A, byte[]> toBytes() {, +        return transcode(new BitmapBytesTranscoder(), byte[].class);, +    }, +, +    public BitmapRequestBuilder<A, byte[]> toBytes(Bitmap.CompressFormat compressFormat, int quality) {, +        return transcode(new BitmapBytesTranscoder(compressFormat, quality), byte[].class);, +    }, +}, +++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +package com.bumptech.glide;, +, +import android.content.Context;, +import android.graphics.Bitmap;, +import android.os.ParcelFileDescriptor;, +import com.bumptech.glide.load.model.ImageVideoModelLoader;, +import com.bumptech.glide.load.model.ImageVideoWrapper;, +import com.bumptech.glide.load.model.ModelLoader;, +import com.bumptech.glide.load.resource.transcode.BitmapBytesTranscoder;, +import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;, +import com.bumptech.glide.provider.FixedLoadProvider;, +, +import java.io.InputStream;, +, +public class BitmapTypeRequest<A> extends BitmapRequestBuilder<A, Bitmap> {, +    private final Context context;, +    private final A model;, +    private final ModelLoader<A, InputStream> streamModelLoader;, +    private ModelLoader<A, ParcelFileDescriptor> fileDescriptorModelLoader;, +    private final Glide glide;, +, +    private static <A, R> FixedLoadProvider<A, ImageVideoWrapper, Bitmap, R> buildProvider(Glide glide,, +            ModelLoader<A, InputStream> streamModelLoader,, +            ModelLoader<A, ParcelFileDescriptor> fileDescriptorModelLoader,, +            Class<R> transcodedClass,, +            ResourceTranscoder<Bitmap, R> transcoder) {, +            return streamModelLoader == null && fileDescriptorModelLoader == null ? null :, +                    new FixedLoadProvider<A, ImageVideoWrapper, Bitmap, R>(, +                            new ImageVideoModelLoader<A>(streamModelLoader, fileDescriptorModelLoader),, +                            transcoder != null ? transcoder : glide.buildTranscoder(Bitmap.class, transcodedClass),, +                            glide.buildDataProvider(ImageVideoWrapper.class, Bitmap.class));, +    }, +, +    BitmapTypeRequest(Context context, A model,, +            ModelLoader<A, InputStream> streamModelLoader,, +            ModelLoader<A, ParcelFileDescriptor> fileDescriptorModelLoader,]
[+++ b/.idea/codeStyleSettings.xml, +++ b/.idea/codeStyleSettings.xml, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +      sourceExecutor = new GlideExecutor("source");, +      diskCacheExecutor = new GlideExecutor("disk-cache", 1);, +++ b/.idea/codeStyleSettings.xml, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +      sourceExecutor = new GlideExecutor("source");, +      diskCacheExecutor = new GlideExecutor("disk-cache", 1);, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +  private static final BaseRequestOptions DOWNLOAD_ONLY_OPTIONS =, +  public RequestBuilder<TranscodeType> apply(BaseRequestOptions requestOptions) {, +      TransitionOptions<?, ? super TranscodeType> transitionOptions) {, +  public <Y extends Target<TranscodeType>> Y into(Y target) {, +    if (target == null) {, +      throw new IllegalArgumentException("You must pass in a non null Target");, +    }, +    if (view == null) {, +      throw new IllegalArgumentException("You must pass in a non null View");, +    }, +        case CENTER_INSIDE:, +          requestOptions.optionalCenterInside(context);, +          break;, +    return getDownloadOnlyRequest().into(width, height);, +++ b/.idea/codeStyleSettings.xml, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +      sourceExecutor = new GlideExecutor("source");, +      diskCacheExecutor = new GlideExecutor("disk-cache", 1);, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +  private static final BaseRequestOptions DOWNLOAD_ONLY_OPTIONS =, +  public RequestBuilder<TranscodeType> apply(BaseRequestOptions requestOptions) {, +      TransitionOptions<?, ? super TranscodeType> transitionOptions) {, +  public <Y extends Target<TranscodeType>> Y into(Y target) {, +    if (target == null) {, +      throw new IllegalArgumentException("You must pass in a non null Target");, +    }, +    if (view == null) {, +      throw new IllegalArgumentException("You must pass in a non null View");, +    }, +        case CENTER_INSIDE:, +          requestOptions.optionalCenterInside(context);, +          break;, +    return getDownloadOnlyRequest().into(width, height);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java, +    final int sdkInt = Build.VERSION.SDK_INT;, +    return sdkInt < Build.VERSION_CODES.HONEYCOMB, +        || (sdkInt >= Build.VERSION_CODES.KITKAT && activityManager.isLowRamDevice());, +++ b/.idea/codeStyleSettings.xml, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +      sourceExecutor = new GlideExecutor("source");, +      diskCacheExecutor = new GlideExecutor("disk-cache", 1);, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +  private static final BaseRequestOptions DOWNLOAD_ONLY_OPTIONS =, +  public RequestBuilder<TranscodeType> apply(BaseRequestOptions requestOptions) {, +      TransitionOptions<?, ? super TranscodeType> transitionOptions) {, +  public <Y extends Target<TranscodeType>> Y into(Y target) {, +    if (target == null) {, +      throw new IllegalArgumentException("You must pass in a non null Target");, +    }, +    if (view == null) {, +      throw new IllegalArgumentException("You must pass in a non null View");, +    }, +        case CENTER_INSIDE:, +          requestOptions.optionalCenterInside(context);, +          break;, +    return getDownloadOnlyRequest().into(width, height);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java, +    final int sdkInt = Build.VERSION.SDK_INT;, +    return sdkInt < Build.VERSION_CODES.HONEYCOMB, +        || (sdkInt >= Build.VERSION_CODES.KITKAT && activityManager.isLowRamDevice());, +++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java, +  private static final String DEFAULT_NAME = "fifo-pool";, +   * Constructor to build a fixed thread pool with an automatically determined number of threads., +   * @see #calculateBestThreadCount(), +  public GlideExecutor() {, +    this(calculateBestThreadCount());, +   * Constructor to build a fixed thread pool with the given pool size., +   * @param poolSize The number of threads., +   */, +  public GlideExecutor(int poolSize) {, +    this(poolSize, new DefaultThreadFactory());, +  }, +, +  /**, +   * Constructor to build a fixed thread pool with the given pool size., +   * @param poolSize The number of threads., +   * @param uncaughtThrowableStrategy Dictates how the pool should handle uncaught and unexpected, +   *                                  throwables thrown by Futures run by the pool., +   */, +  public GlideExecutor(int poolSize,, +      UncaughtThrowableStrategy uncaughtThrowableStrategy) {, +    this(poolSize, new DefaultThreadFactory(uncaughtThrowableStrategy));, +  }, +, +  /**, +   * Constructor to build a fixed thread pool with the given name and an automatically determined, +   * number of threads., +   *, +   * @see #calculateBestThreadCount(), +   */]
[+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +      if (Util.isValidDimensions(overrideWidth, overrideHeight)) {, +        width = overrideWidth;, +        height = overrideHeight;, +      }]
[+++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java, +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java, +++ b/library/src/main/java/com/bumptech/glide/request/target/GlideDrawableImageViewTarget.java]
[+++ b/gradle.properties, +VERSION_NAME=4.1.0-SNAPSHOT, +VERSION_MINOR=1]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java, +  TypeSpec generate(, +      String generatedCodePackageName, String glideName, TypeSpec generatedRequestManager) {, +        .addMethods(, +            generateOverridesForGlideMethods(generatedCodePackageName, generatedRequestManager)), +      final String generatedCodePackageName, final TypeSpec generatedRequestManager) {, +              return overrideGlideWithMethod(, +                  generatedCodePackageName, generatedRequestManager, input);, +      String packageName, TypeSpec generatedRequestManager, ExecutableElement methodToOverride) {, +        ClassName.get(packageName, generatedRequestManager.name);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java, +  TypeSpec generate(, +      String generatedCodePackageName, String glideName, TypeSpec generatedRequestManager) {, +        .addMethods(, +            generateOverridesForGlideMethods(generatedCodePackageName, generatedRequestManager)), +      final String generatedCodePackageName, final TypeSpec generatedRequestManager) {, +              return overrideGlideWithMethod(, +                  generatedCodePackageName, generatedRequestManager, input);, +      String packageName, TypeSpec generatedRequestManager, ExecutableElement methodToOverride) {, +        ClassName.get(packageName, generatedRequestManager.name);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +  private static final String REQUEST_BUILDER_PACKAGE_NAME = "com.bumptech.glide";, +  private ClassName generatedRequestBuilderClassName;, +  private ParameterizedTypeName generatedRequestBuilderOfTranscodeType;, +  TypeSpec generate(String generatedCodePackageName, @Nullable TypeSpec generatedOptions) {, +    generatedRequestBuilderClassName =, +        ClassName.get(generatedCodePackageName, GENERATED_REQUEST_BUILDER_SIMPLE_NAME);, +    generatedRequestBuilderOfTranscodeType =, +        ParameterizedTypeName.get(generatedRequestBuilderClassName, transcodeTypeName);, +, +          ClassName.get(generatedCodePackageName, generatedOptions.name);, +                .addMember("value", "$S", "deprecation"), +    ClassName glide = ClassName.get("com.bumptech.glide", "Glide");, +            .addParameter(glide, "glide"), +            .addStatement("super($N, $N ,$N)", "glide", "requestManager", "transcodeClass"), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java, +  TypeSpec generate(, +      String generatedCodePackageName, String glideName, TypeSpec generatedRequestManager) {, +        .addMethods(, +            generateOverridesForGlideMethods(generatedCodePackageName, generatedRequestManager)), +      final String generatedCodePackageName, final TypeSpec generatedRequestManager) {, +              return overrideGlideWithMethod(, +                  generatedCodePackageName, generatedRequestManager, input);, +      String packageName, TypeSpec generatedRequestManager, ExecutableElement methodToOverride) {, +        ClassName.get(packageName, generatedRequestManager.name);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +  private static final String REQUEST_BUILDER_PACKAGE_NAME = "com.bumptech.glide";, +  private ClassName generatedRequestBuilderClassName;, +  private ParameterizedTypeName generatedRequestBuilderOfTranscodeType;, +  TypeSpec generate(String generatedCodePackageName, @Nullable TypeSpec generatedOptions) {, +    generatedRequestBuilderClassName =, +        ClassName.get(generatedCodePackageName, GENERATED_REQUEST_BUILDER_SIMPLE_NAME);, +    generatedRequestBuilderOfTranscodeType =, +        ParameterizedTypeName.get(generatedRequestBuilderClassName, transcodeTypeName);, +, +          ClassName.get(generatedCodePackageName, generatedOptions.name);, +                .addMember("value", "$S", "deprecation"), +    ClassName glide = ClassName.get("com.bumptech.glide", "Glide");, +            .addParameter(glide, "glide"), +            .addStatement("super($N, $N ,$N)", "glide", "requestManager", "transcodeClass"), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java, +  TypeSpec generate(String generatedCodePackageName, TypeSpec generatedRequestManagerSpec) {, +                    ClassName.get(generatedCodePackageName, generatedRequestManagerSpec.name)), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java, +  TypeSpec generate(, +      String generatedCodePackageName, String glideName, TypeSpec generatedRequestManager) {, +        .addMethods(, +            generateOverridesForGlideMethods(generatedCodePackageName, generatedRequestManager)), +      final String generatedCodePackageName, final TypeSpec generatedRequestManager) {, +              return overrideGlideWithMethod(, +                  generatedCodePackageName, generatedRequestManager, input);, +      String packageName, TypeSpec generatedRequestManager, ExecutableElement methodToOverride) {, +        ClassName.get(packageName, generatedRequestManager.name);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +  private static final String REQUEST_BUILDER_PACKAGE_NAME = "com.bumptech.glide";, +  private ClassName generatedRequestBuilderClassName;, +  private ParameterizedTypeName generatedRequestBuilderOfTranscodeType;, +  TypeSpec generate(String generatedCodePackageName, @Nullable TypeSpec generatedOptions) {, +    generatedRequestBuilderClassName =, +        ClassName.get(generatedCodePackageName, GENERATED_REQUEST_BUILDER_SIMPLE_NAME);, +    generatedRequestBuilderOfTranscodeType =, +        ParameterizedTypeName.get(generatedRequestBuilderClassName, transcodeTypeName);, +, +          ClassName.get(generatedCodePackageName, generatedOptions.name);, +                .addMember("value", "$S", "deprecation"), +    ClassName glide = ClassName.get("com.bumptech.glide", "Glide");, +            .addParameter(glide, "glide"), +            .addStatement("super($N, $N ,$N)", "glide", "requestManager", "transcodeClass"), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java, +  TypeSpec generate(String generatedCodePackageName, TypeSpec generatedRequestManagerSpec) {, +                    ClassName.get(generatedCodePackageName, generatedRequestManagerSpec.name)), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java, +      String generatedCodePackageName, @Nullable TypeSpec requestOptions, TypeSpec requestBuilder,, +      Set<String> glideExtensions) {, +    generatedRequestBuilderClassName = ClassName.get(generatedCodePackageName, requestBuilder.name);, +         .addMethod(generateAsMethod(generatedCodePackageName, requestBuilder)), +                 Collections.singletonList(, +                     generateOverrideSetRequestOptions(generatedCodePackageName, requestOptions))), +        .addModifiers(Modifier.PUBLIC), +  private MethodSpec generateAsMethod(String generatedCodePackageName, TypeSpec requestBuilder) {]
[+++ b/README.md, +You can download a jar from GitHub's [releases page][1]., +    compile 'com.github.bumptech.glide:glide:3.4.+', +  <version>3.4.0</version>, +Checkout the [GitHub wiki][2] for pages on a variety of topics, and see the [javadocs][3]., +Volley is now an optional dependency that can be included via a utility library. To use Volley to fetch media over, +http/https:, +    compile 'com.github.bumptech.glide:volley-integration:1.1.+', +    <version>1.1.0</version>, +In addition to Volley, Glide also includes support for fetching media using OkHttp. To use OkHttp to fetch media over, +http/https:, +    compile 'com.github.bumptech.glide:okhttp-integration:1.1.+', +    <version>1.1.0</version>, +Version 3.x is a stable public release used in multiple open source projects at Google including in the Android Camera, +app and in the 2014 Google IO app. Comments/bugs/questions/pull requests welcome!, +Note: Make sure your Android SDK has the Android Support Repository installed, and that your `$ANDROID_HOME` environment, +variable is pointing at the SDK or add a `local.properties` file in the root project with a `sdk.dir=...` line., +Follow the steps in the 'Build' section to setup the project and then edit the files however you wish., +[Intellij IDEA 14][4] cleanly imports both Glide's source and tests and is the recommended way to work with Glide., +4. Select glide-parent.iml, +To report a specific problem or feature request, [open a new issue on Github][5]. For questions, suggestions, or, +anything else, join or email [Glide's discussion group][6]., +Before submitting pull requests, contributors must sign Google's [individual contribution license agreement][7]., +* The Android team and Jake Wharton for the [disk cache implementation][8] Glide's disk cache is based on., +* Dave Smith for the [gif decoder gist][9] Glide's gif decoder is based on., +* Chris Banes for his [gradle-mvn-push][10] script., +* Corey Hall for Glide's [amazing logo][11]., +, +[1]: https://github.com/bumptech/glide/releases, +[2]: https://github.com/bumptech/glide/wiki, +[3]: http://bumptech.github.io/glide/javadocs/latest/index.html, +[4]: https://www.jetbrains.com/idea/download/, +[5]: https://github.com/bumptech/glide/issues/new, +[6]: https://groups.google.com/forum/#!forum/glidelibrary, +[7]: https://developers.google.com/open-source/cla/individual, +[8]: https://github.com/JakeWharton/DiskLruCache, +[9]: https://gist.github.com/devunwired/4479231, +[10]: https://github.com/chrisbanes/gradle-mvn-push, +[11]: static/glide_logo.png, +++ b/README.md, +You can download a jar from GitHub's [releases page][1]., +    compile 'com.github.bumptech.glide:glide:3.4.+', +  <version>3.4.0</version>, +Checkout the [GitHub wiki][2] for pages on a variety of topics, and see the [javadocs][3]., +Volley is now an optional dependency that can be included via a utility library. To use Volley to fetch media over, +http/https:, +    compile 'com.github.bumptech.glide:volley-integration:1.1.+', +    <version>1.1.0</version>, +In addition to Volley, Glide also includes support for fetching media using OkHttp. To use OkHttp to fetch media over, +http/https:, +    compile 'com.github.bumptech.glide:okhttp-integration:1.1.+', +    <version>1.1.0</version>, +Version 3.x is a stable public release used in multiple open source projects at Google including in the Android Camera, +app and in the 2014 Google IO app. Comments/bugs/questions/pull requests welcome!, +Note: Make sure your Android SDK has the Android Support Repository installed, and that your `$ANDROID_HOME` environment, +variable is pointing at the SDK or add a `local.properties` file in the root project with a `sdk.dir=...` line., +Follow the steps in the 'Build' section to setup the project and then edit the files however you wish., +[Intellij IDEA 14][4] cleanly imports both Glide's source and tests and is the recommended way to work with Glide., +4. Select glide-parent.iml, +To report a specific problem or feature request, [open a new issue on Github][5]. For questions, suggestions, or, +anything else, join or email [Glide's discussion group][6]., +Before submitting pull requests, contributors must sign Google's [individual contribution license agreement][7]., +* The Android team and Jake Wharton for the [disk cache implementation][8] Glide's disk cache is based on., +* Dave Smith for the [gif decoder gist][9] Glide's gif decoder is based on., +* Chris Banes for his [gradle-mvn-push][10] script., +* Corey Hall for Glide's [amazing logo][11]., +, +[1]: https://github.com/bumptech/glide/releases, +[2]: https://github.com/bumptech/glide/wiki, +[3]: http://bumptech.github.io/glide/javadocs/latest/index.html, +[4]: https://www.jetbrains.com/idea/download/, +[5]: https://github.com/bumptech/glide/issues/new, +[6]: https://groups.google.com/forum/#!forum/glidelibrary, +[7]: https://developers.google.com/open-source/cla/individual, +[8]: https://github.com/JakeWharton/DiskLruCache, +[9]: https://gist.github.com/devunwired/4479231, +[10]: https://github.com/chrisbanes/gradle-mvn-push, +[11]: static/glide_logo.png, +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +            public List<Object> getPreloadItems(int start, int end) {, +                assertEquals(11, start);, +                assertEquals(21, end);, +                return super.getPreloadItems(start, end);, +        assertTrue(called.get());, +            objects.add(new Object());, +            public int[] getPreloadSize(Object item) {, +            public List<Object> getPreloadItems(int start, int end) {, +                return objects;, +        preloader.onScroll(null, 1, 10, 30);, +            public List<Object> getPreloadItems(int start, int end) {, +                if (start == 40) {, +                assertEquals(19, start);, +                assertEquals(29, end);, +                return super.getPreloadItems(start, end);, +            public int[] getPreloadSize(Object item) {, +            public List<Object> getPreloadItems(int start, int end) {, +                if (start == 40) {, +                    return Collections.emptyList();, +                return objects;, +        preloader.onScroll(null, 30, 10, 40);]
[+++ b/checkstyle.xml, +++ b/checkstyle.xml, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java, +import com.bumptech.glide.load.resource.bitmap.RoundedCorners;, +  @Test, +  public void circleCrop_withWideGamutBitmap_producesWideGamutBitmap() {, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Config.RGBA_F16);, +    byte[] data = asPng(bitmap);, +, +    Bitmap result =, +        concurrency.get(, +            GlideApp.with(context), +                .asBitmap(), +                .load(data), +                .circleCrop(), +                .submit());, +    assertThat(result).isNotNull();, +    assertThat(result.getConfig()).isEqualTo(Config.RGBA_F16);, +  }, +, +  @Test, +  public void roundedCorners_withWideGamutBitmap_producesWideGamutBitmap() {, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Config.RGBA_F16);, +    byte[] data = asPng(bitmap);, +, +    Bitmap result =, +        concurrency.get(, +            GlideApp.with(context), +                .asBitmap(), +                .load(data), +                .transform(new RoundedCorners(/*roundingRadius=*/ 10)), +                .submit());, +    assertThat(result).isNotNull();, +    assertThat(result.getConfig()).isEqualTo(Config.RGBA_F16);, +  }, +, +++ b/checkstyle.xml, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java, +import com.bumptech.glide.load.resource.bitmap.RoundedCorners;, +  @Test, +  public void circleCrop_withWideGamutBitmap_producesWideGamutBitmap() {, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Config.RGBA_F16);, +    byte[] data = asPng(bitmap);, +, +    Bitmap result =, +        concurrency.get(, +            GlideApp.with(context), +                .asBitmap(), +                .load(data), +                .circleCrop(), +                .submit());, +    assertThat(result).isNotNull();, +    assertThat(result.getConfig()).isEqualTo(Config.RGBA_F16);, +  }, +, +  @Test, +  public void roundedCorners_withWideGamutBitmap_producesWideGamutBitmap() {, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Config.RGBA_F16);, +    byte[] data = asPng(bitmap);, +, +    Bitmap result =, +        concurrency.get(, +            GlideApp.with(context), +                .asBitmap(), +                .load(data), +                .transform(new RoundedCorners(/*roundingRadius=*/ 10)), +                .submit());, +    assertThat(result).isNotNull();, +    assertThat(result.getConfig()).isEqualTo(Config.RGBA_F16);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java, +import android.graphics.Bitmap.Config;, +    Bitmap result = pool.get(width, height, getNonNullConfig(inBitmap));, +    Bitmap.Config config = getNonNullConfig(inBitmap);, +    Bitmap.Config config = getNonNullConfig(inBitmap);, +    Bitmap.Config outConfig = getAlphaSafeConfig(inBitmap);, +    Bitmap result = pool.get(destMinEdge, destMinEdge, outConfig);, +  private static Bitmap getAlphaSafeBitmap(, +      @NonNull BitmapPool pool, @NonNull Bitmap maybeAlphaSafe) {, +    Bitmap.Config safeConfig = getAlphaSafeConfig(maybeAlphaSafe);, +    if (safeConfig.equals(maybeAlphaSafe.getConfig())) {, +    Bitmap argbBitmap =, +        pool.get(maybeAlphaSafe.getWidth(), maybeAlphaSafe.getHeight(), safeConfig);, +  @NonNull, +  private static Config getAlphaSafeConfig(@NonNull Bitmap inBitmap) {, +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {, +      // Avoid short circuiting the sdk check., +      if (Bitmap.Config.RGBA_F16.equals(inBitmap.getConfig())) { // NOPMD, +        return Bitmap.Config.RGBA_F16;, +      }, +    }, +, +    return Bitmap.Config.ARGB_8888;, +  }, +, +    Bitmap.Config safeConfig = getAlphaSafeConfig(inBitmap);, +    Bitmap result = pool.get(toTransform.getWidth(), toTransform.getHeight(), safeConfig);, +  @NonNull, +  private static Bitmap.Config getNonNullConfig(@NonNull Bitmap bitmap) {]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java]
[+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import android.graphics.Bitmap;, +import com.bumptech.glide.request.target.Target;, +  private boolean isActiveResourceRetentionAllowed;, +   * <p>Defaults to {@code false}., +   *, +   * <p>Leaving this method at the default {@code false} value will allow the platform to garbage, +   * collect resources more quickly, but will lead to unexpected memory cache misses if callers load, +   * resources into {@link com.bumptech.glide.request.target.Target}s but never clear them., +   *, +   * <p>If you set this method to {@code true} you <em>must not</em> call, +   * {@link Bitmap#recycle()} or mutate any Bitmaps returned by Glide. If this method is set to, +   * {@code false}, recycling or mutating Bitmaps is inefficient but safe as long as you do not, +   * clear the corresponding {@link com.bumptech.glide.request.target.Target} used to load the, +   * {@link Bitmap}. However, if you set this method to {@code true} and recycle or mutate any, +   * returned {@link Bitmap}s or other mutable resources, Glide may recover those resources and, +   * attempt to use them later on, resulting in crashes, graphical corruption or undefined behavior., +   * edge cases. If you use {@link RequestManager#clear(Target)}, calling {@link Bitmap#recycle()}, +   * or mutating {@link Bitmap}s is not only unsafe, it's also totally unnecessary and should be, +   * avoided. In all cases, prefer {@link RequestManager#clear(Target)} to {@link Bitmap#recycle()}.]
[+++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;, +    @Test, +    public void testClone() throws IOException {, +        GlideDrawable firstResult = mock(GlideDrawable.class);, +        Resource<GlideDrawable> firstResource = mock(Resource.class);, +        when(firstResource.get()).thenReturn(firstResult);, +        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> firstTranscoder = mock(ResourceTranscoder.class);, +        when(firstTranscoder.transcode(any(Resource.class))).thenReturn(firstResource);, +        when(firstTranscoder.getId()).thenReturn("transcoder1");, +, +        GlideDrawable secondResult = mock(GlideDrawable.class);, +        Resource<GlideDrawable> secondResource = mock(Resource.class);, +        when(secondResource.get()).thenReturn(secondResult);, +        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> secondTranscoder = mock(ResourceTranscoder.class);, +        when(secondTranscoder.transcode(any(Resource.class))).thenReturn(secondResource);, +        when(secondTranscoder.getId()).thenReturn("transcoder2");, +, +        DrawableRequestBuilder<String> firstRequest = requestManager.from(String.class).transcoder(firstTranscoder), +                .override(100, 100);, +        DrawableRequestBuilder<String> secondRequest = firstRequest.clone().transcoder(secondTranscoder);, +, +        Target firstTarget = mock(Target.class);, +        Target secondTarget = mock(Target.class);, +, +        String fakeUri = mockUri("content://fakeUri");, +, +        firstRequest.load(fakeUri).into(firstTarget);, +        verify(firstTarget).onResourceReady(eq(firstResult), any(GlideAnimation.class));, +, +        secondRequest.load(fakeUri).into(secondTarget);, +        verify(secondTarget).onResourceReady(eq(secondResult), any(GlideAnimation.class));, +    }, +, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;, +    @Test, +    public void testClone() throws IOException {, +        GlideDrawable firstResult = mock(GlideDrawable.class);, +        Resource<GlideDrawable> firstResource = mock(Resource.class);, +        when(firstResource.get()).thenReturn(firstResult);, +        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> firstTranscoder = mock(ResourceTranscoder.class);, +        when(firstTranscoder.transcode(any(Resource.class))).thenReturn(firstResource);, +        when(firstTranscoder.getId()).thenReturn("transcoder1");, +, +        GlideDrawable secondResult = mock(GlideDrawable.class);, +        Resource<GlideDrawable> secondResource = mock(Resource.class);, +        when(secondResource.get()).thenReturn(secondResult);, +        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> secondTranscoder = mock(ResourceTranscoder.class);, +        when(secondTranscoder.transcode(any(Resource.class))).thenReturn(secondResource);, +        when(secondTranscoder.getId()).thenReturn("transcoder2");, +, +        DrawableRequestBuilder<String> firstRequest = requestManager.from(String.class).transcoder(firstTranscoder), +                .override(100, 100);, +        DrawableRequestBuilder<String> secondRequest = firstRequest.clone().transcoder(secondTranscoder);, +, +        Target firstTarget = mock(Target.class);, +        Target secondTarget = mock(Target.class);, +, +        String fakeUri = mockUri("content://fakeUri");, +, +        firstRequest.load(fakeUri).into(firstTarget);, +        verify(firstTarget).onResourceReady(eq(firstResult), any(GlideAnimation.class));, +, +        secondRequest.load(fakeUri).into(secondTarget);, +        verify(secondTarget).onResourceReady(eq(secondResult), any(GlideAnimation.class));, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +, +    @Override, +    public BitmapRequestBuilder<ModelType, TranscodeType> clone() {, +        return (BitmapRequestBuilder<ModelType, TranscodeType>) super.clone();, +    }, +, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;, +    @Test, +    public void testClone() throws IOException {, +        GlideDrawable firstResult = mock(GlideDrawable.class);, +        Resource<GlideDrawable> firstResource = mock(Resource.class);, +        when(firstResource.get()).thenReturn(firstResult);, +        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> firstTranscoder = mock(ResourceTranscoder.class);, +        when(firstTranscoder.transcode(any(Resource.class))).thenReturn(firstResource);, +        when(firstTranscoder.getId()).thenReturn("transcoder1");, +, +        GlideDrawable secondResult = mock(GlideDrawable.class);, +        Resource<GlideDrawable> secondResource = mock(Resource.class);, +        when(secondResource.get()).thenReturn(secondResult);, +        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> secondTranscoder = mock(ResourceTranscoder.class);, +        when(secondTranscoder.transcode(any(Resource.class))).thenReturn(secondResource);, +        when(secondTranscoder.getId()).thenReturn("transcoder2");]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +                        && !input.type.equals(TypeName.get(SafeVarargs.class));, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +                        && !input.type.equals(TypeName.get(SafeVarargs.class));, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +  @CheckResult, +  @CheckResult, +  @CheckResult, +  @CheckResult, +  @CheckResult, +  @CheckResult, +  @CheckResult, +  @CheckResult, +  @CheckResult, +  @CheckResult, +  @CheckResult, +  @CheckResult]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +      // If the request is completed, beginning again will ensure the result is re-delivered,, +      // triggering RequestListeners and Targets. If the request is failed, beginning again will, +      // restart the request, giving it another chance to complete. If the request is already, +      // running, we can let it continue running without interruption., +      if (!Preconditions.checkNotNull(previous).isRunning()) {, +        previous.begin();, +      }, +    requestManager.clear(target);, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +      // If the request is completed, beginning again will ensure the result is re-delivered,, +      // triggering RequestListeners and Targets. If the request is failed, beginning again will, +      // restart the request, giving it another chance to complete. If the request is already, +      // running, we can let it continue running without interruption., +      if (!Preconditions.checkNotNull(previous).isRunning()) {, +        previous.begin();, +      }, +    requestManager.clear(target);, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +    if (status == Status.RUNNING) {, +      throw new IllegalArgumentException("Cannot restart a running request");, +    }, +, +    // If we're restarted after we're complete (usually via something like a notifyDataSetChanged, +    // that starts an identical request into the same Target or View), we can simply use the, +    // resource and size we retrieved the last time around and skip obtaining a new size, starting a, +    // new load etc. This does mean that users who want to restart a load because they expect that, +    // the view size has changed will need to explicitly clear the View or Target before starting, +    // the new load., +    if (status == Status.COMPLETE) {, +      onResourceReady(resource, DataSource.MEMORY_CACHE);, +      return;, +    }, +, +    // Restarts for requests that are neither complete nor running can be treated as new requests, +    // and can run again from the beginning., +]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/third_party/gif_decoder/build.gradle, +, +    defaultConfig {, +        applicationId 'com.bumptech.glide.gifdecoder', +        minSdkVersion 10, +        targetSdkVersion 19, +++ /dev/null, +++ /dev/null, +++ b/third_party/gif_decoder/build.gradle, +, +    defaultConfig {, +        applicationId 'com.bumptech.glide.gifdecoder', +        minSdkVersion 10, +        targetSdkVersion 19, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/third_party/gif_decoder/build.gradle, +, +    defaultConfig {, +        applicationId 'com.bumptech.glide.gifdecoder', +        minSdkVersion 10, +        targetSdkVersion 19, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/third_party/gif_decoder/build.gradle, +, +    defaultConfig {, +        applicationId 'com.bumptech.glide.gifdecoder', +        minSdkVersion 10, +        targetSdkVersion 19, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/third_party/gif_decoder/build.gradle, +, +    defaultConfig {, +        applicationId 'com.bumptech.glide.gifdecoder', +        minSdkVersion 10, +        targetSdkVersion 19, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/third_party/gif_decoder/src/main/AndroidManifest.xml, +<?xml version="1.0" encoding="utf-8"?>, +<manifest xmlns:android="http://schemas.android.com/apk/res/android", +          package="com.bumptech.glide.gifdecoder">, +  <application />, +</manifest>]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +        case FIT_XY:, +          requestOptions.optionalCenterInside();, +          break;, +        case CENTER:, +        case MATRIX:]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java, +  // See TODO below., +  @SuppressWarnings("PMD.CollapsibleIfStatements"), +      // TODO(b/73882030): This case gets triggered when it shouldn't. With this assertion it causes, +      // all loads to fail. Without this assertion it causes loads to miss the disk cache, +      // unnecessarily, +      // throw new IllegalStateException(, +      //    "Failed to find any load path from " + helper.getModelClass() + " to ", +      //        + helper.getTranscodeClass());, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java, +  // See TODO below., +  @SuppressWarnings("PMD.CollapsibleIfStatements"), +      // TODO(b/73882030): This case gets triggered when it shouldn't. With this assertion it causes, +      // all loads to fail. Without this assertion it causes loads to miss the disk cache, +      // unnecessarily, +      // throw new IllegalStateException(, +      //    "Failed to find any load path from " + helper.getModelClass() + " to ", +      //        + helper.getTranscodeClass());, +++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoader.java]
[+++ b/gradle.properties, +DAGGER_VERSION=2.11, +++ b/gradle.properties, +DAGGER_VERSION=2.11, +++ b/samples/imgur/build.gradle, +    annotationProcessor "com.google.dagger:dagger-compiler:${DAGGER_VERSION}", +    compile "com.google.dagger:dagger-android:${DAGGER_VERSION}", +    compile "com.google.dagger:dagger-android-support:${DAGGER_VERSION}", +    annotationProcessor "com.google.dagger:dagger-android-processor:${DAGGER_VERSION}", +++ b/gradle.properties, +DAGGER_VERSION=2.11, +++ b/samples/imgur/build.gradle, +    annotationProcessor "com.google.dagger:dagger-compiler:${DAGGER_VERSION}", +    compile "com.google.dagger:dagger-android:${DAGGER_VERSION}", +    compile "com.google.dagger:dagger-android-support:${DAGGER_VERSION}", +    annotationProcessor "com.google.dagger:dagger-android-processor:${DAGGER_VERSION}", +++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplication.java, +import dagger.android.AndroidInjector;, +import dagger.android.support.DaggerApplication;, +public final class ImgurApplication extends DaggerApplication {, +  protected AndroidInjector<? extends DaggerApplication> applicationInjector() {, +    return DaggerImgurApplicationComponent.create();, +++ b/gradle.properties, +DAGGER_VERSION=2.11, +++ b/samples/imgur/build.gradle, +    annotationProcessor "com.google.dagger:dagger-compiler:${DAGGER_VERSION}", +    compile "com.google.dagger:dagger-android:${DAGGER_VERSION}", +    compile "com.google.dagger:dagger-android-support:${DAGGER_VERSION}", +    annotationProcessor "com.google.dagger:dagger-android-processor:${DAGGER_VERSION}", +++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplication.java, +import dagger.android.AndroidInjector;, +import dagger.android.support.DaggerApplication;, +public final class ImgurApplication extends DaggerApplication {, +  protected AndroidInjector<? extends DaggerApplication> applicationInjector() {, +    return DaggerImgurApplicationComponent.create();, +++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java, +import dagger.android.AndroidInjector;, +import dagger.android.support.AndroidSupportInjectionModule;, +, +@Component(modules = {, +    AndroidSupportInjectionModule.class,, +    MainActivityModule.class,, +    ApplicationModule.class,, +    ApiModule.class, +}), +public interface ImgurApplicationComponent extends AndroidInjector<ImgurApplication> {, +++ b/gradle.properties, +DAGGER_VERSION=2.11, +++ b/samples/imgur/build.gradle, +    annotationProcessor "com.google.dagger:dagger-compiler:${DAGGER_VERSION}", +    compile "com.google.dagger:dagger-android:${DAGGER_VERSION}", +    compile "com.google.dagger:dagger-android-support:${DAGGER_VERSION}", +    annotationProcessor "com.google.dagger:dagger-android-processor:${DAGGER_VERSION}", +++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplication.java, +import dagger.android.AndroidInjector;, +import dagger.android.support.DaggerApplication;, +public final class ImgurApplication extends DaggerApplication {, +  protected AndroidInjector<? extends DaggerApplication> applicationInjector() {, +    return DaggerImgurApplicationComponent.create();, +++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java, +import dagger.android.AndroidInjector;, +import dagger.android.support.AndroidSupportInjectionModule;, +, +@Component(modules = {, +    AndroidSupportInjectionModule.class,, +    MainActivityModule.class,, +    ApplicationModule.class,, +    ApiModule.class, +}), +public interface ImgurApplicationComponent extends AndroidInjector<ImgurApplication> {, +++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivityModule.java, +import dagger.android.ContributesAndroidInjector;, +@Module, +  @ContributesAndroidInjector, +  abstract MainActivity contributeMainActivityInjector();, +++ b/gradle.properties, +DAGGER_VERSION=2.11, +++ b/samples/imgur/build.gradle, +    annotationProcessor "com.google.dagger:dagger-compiler:${DAGGER_VERSION}", +    compile "com.google.dagger:dagger-android:${DAGGER_VERSION}", +    compile "com.google.dagger:dagger-android-support:${DAGGER_VERSION}", +    annotationProcessor "com.google.dagger:dagger-android-processor:${DAGGER_VERSION}", +++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplication.java, +import dagger.android.AndroidInjector;, +import dagger.android.support.DaggerApplication;, +public final class ImgurApplication extends DaggerApplication {, +  protected AndroidInjector<? extends DaggerApplication> applicationInjector() {, +    return DaggerImgurApplicationComponent.create();, +++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/ImgurApplicationComponent.java, +import dagger.android.AndroidInjector;, +import dagger.android.support.AndroidSupportInjectionModule;, +, +@Component(modules = {, +    AndroidSupportInjectionModule.class,, +    MainActivityModule.class,, +    ApplicationModule.class,, +    ApiModule.class, +}), +public interface ImgurApplicationComponent extends AndroidInjector<ImgurApplication> {, +++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/MainActivityModule.java]
[+++ b/.idea/codeStyleSettings.xml, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/build.gradle, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/gradle.properties]
[+++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import java.util.Map;, +    Request.Builder requestBuilder = new Request.Builder(), +            .url(url.toStringUrl());, +    for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {, +      requestBuilder.addHeader(headerEntry.getKey(), headerEntry.getValue());, +    }, +    Request request = requestBuilder.build();, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import java.util.Map;, +    Request.Builder requestBuilder = new Request.Builder(), +            .url(url.toStringUrl());, +    for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {, +      requestBuilder.addHeader(headerEntry.getKey(), headerEntry.getValue());, +    }, +    Request request = requestBuilder.build();, +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.when;, +import com.bumptech.glide.load.model.Headers;, +import java.util.HashMap;, +import java.util.Map;, +@Config(manifest = Config.NONE, emulateSdk = 18,, +    shadows = VolleyStreamFetcherServerTest.FakeSystemClock.class), +  @Test, +  public void testAppliesHeadersInGlideUrl() throws Exception {, +    mockWebServer.enqueue(new MockResponse().setResponseCode(200));, +    String headerField = "field";, +    String headerValue = "value";, +    Map<String, String> headersMap = new HashMap<String, String>();, +    headersMap.put(headerField, headerValue);, +    Headers headers = mock(Headers.class);, +    when(headers.getHeaders()).thenReturn(headersMap);, +, +    getFetcher(headers).loadData(Priority.HIGH, callback);, +    waitForResponseLatch.await();, +, +    assertThat(mockWebServer.takeRequest().getHeader(headerField)).isEqualTo(headerValue);, +  }, +, +    return getFetcher(Headers.NONE);, +  }, +, +  private DataFetcher<InputStream> getFetcher(Headers headers) {, +    return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString(), headers));, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2', +  <version>3.5.2</version>, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import java.util.Map;, +    Request.Builder requestBuilder = new Request.Builder(), +            .url(url.toStringUrl());, +    for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {, +      requestBuilder.addHeader(headerEntry.getKey(), headerEntry.getValue());, +    }, +    Request request = requestBuilder.build();, +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.when;, +import com.bumptech.glide.load.model.Headers;, +import java.util.HashMap;, +import java.util.Map;, +@Config(manifest = Config.NONE, emulateSdk = 18,, +    shadows = VolleyStreamFetcherServerTest.FakeSystemClock.class), +  @Test, +  public void testAppliesHeadersInGlideUrl() throws Exception {, +    mockWebServer.enqueue(new MockResponse().setResponseCode(200));, +    String headerField = "field";, +    String headerValue = "value";, +    Map<String, String> headersMap = new HashMap<String, String>();, +    headersMap.put(headerField, headerValue);, +    Headers headers = mock(Headers.class);, +    when(headers.getHeaders()).thenReturn(headersMap);, +, +    getFetcher(headers).loadData(Priority.HIGH, callback);, +    waitForResponseLatch.await();, +, +    assertThat(mockWebServer.takeRequest().getHeader(headerField)).isEqualTo(headerValue);, +  }, +, +    return getFetcher(Headers.NONE);, +  }, +, +  private DataFetcher<InputStream> getFetcher(Headers headers) {, +    return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString(), headers));, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java, +import java.util.Map;, +    Request<byte[]> create(String url, DataCallback<? super InputStream> future, Priority priority,, +        Map<String, String> headers);, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.5.2']
[+++ b/library/src/main/java/com/bumptech/glide/Registry.java, +  private final Pool<List<Throwable>> throwableListPool = FactoryPools.threadSafeList();, +    this.modelLoaderRegistry = new ModelLoaderRegistry(throwableListPool);, +        result =, +            new LoadPath<>(, +                dataClass, resourceClass, transcodeClass, decodePaths, throwableListPool);, +            registeredTranscodeClass, decoders, transcoder, throwableListPool));, +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +  private final Pool<List<Throwable>> throwableListPool = FactoryPools.threadSafeList();, +    this.modelLoaderRegistry = new ModelLoaderRegistry(throwableListPool);, +        result =, +            new LoadPath<>(, +                dataClass, resourceClass, transcodeClass, decodePaths, throwableListPool);, +            registeredTranscodeClass, decoders, transcoder, throwableListPool));, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private final List<Throwable> throwables = new ArrayList<>();, +    throwables.clear();, +    } catch (Throwable t) {, +      // Catch Throwable and not Exception to handle OOMs. Throwables are swallowed by our, +      // usage of .submit() in GlideExecutor so we're not silently hiding crashes by doing this. We, +      // are however ensuring that our callbacks are always notified when a load fails. Without this, +      // notification, uncaught throwables never notify the corresponding callbacks, which can cause, +      // loads to silently hang forever, a case that's especially bad for users using Futures on, +      // background threads., +            + ", stage: " + stage, t);, +        throwables.add(t);, +        throw t;, +    GlideException e = new GlideException("Failed to load resource", new ArrayList<>(throwables));, +    throwables.add(exception);, +      throwables.add(e);, +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +  private final Pool<List<Throwable>> throwableListPool = FactoryPools.threadSafeList();, +    this.modelLoaderRegistry = new ModelLoaderRegistry(throwableListPool);, +        result =, +            new LoadPath<>(, +                dataClass, resourceClass, transcodeClass, decodePaths, throwableListPool);, +            registeredTranscodeClass, decoders, transcoder, throwableListPool));, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private final List<Throwable> throwables = new ArrayList<>();, +    throwables.clear();, +    } catch (Throwable t) {, +      // Catch Throwable and not Exception to handle OOMs. Throwables are swallowed by our, +      // usage of .submit() in GlideExecutor so we're not silently hiding crashes by doing this. We, +      // are however ensuring that our callbacks are always notified when a load fails. Without this, +      // notification, uncaught throwables never notify the corresponding callbacks, which can cause, +      // loads to silently hang forever, a case that's especially bad for users using Futures on, +      // background threads., +            + ", stage: " + stage, t);, +        throwables.add(t);, +        throw t;, +    GlideException e = new GlideException("Failed to load resource", new ArrayList<>(throwables));, +    throwables.add(exception);, +      throwables.add(e);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java, +  private final Pool<List<Throwable>> listPool;, +      ResourceTranscoder<ResourceType, Transcode> transcoder, Pool<List<Throwable>> listPool) {, +    List<Throwable> exceptions = listPool.acquire();, +      int height, Options options, List<Throwable> exceptions) throws GlideException {, +      } catch (IOException | RuntimeException | OutOfMemoryError e) {, +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +  private final Pool<List<Throwable>> throwableListPool = FactoryPools.threadSafeList();, +    this.modelLoaderRegistry = new ModelLoaderRegistry(throwableListPool);, +        result =, +            new LoadPath<>(, +                dataClass, resourceClass, transcodeClass, decodePaths, throwableListPool);, +            registeredTranscodeClass, decoders, transcoder, throwableListPool));, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private final List<Throwable> throwables = new ArrayList<>();, +    throwables.clear();, +    } catch (Throwable t) {, +      // Catch Throwable and not Exception to handle OOMs. Throwables are swallowed by our, +      // usage of .submit() in GlideExecutor so we're not silently hiding crashes by doing this. We, +      // are however ensuring that our callbacks are always notified when a load fails. Without this, +      // notification, uncaught throwables never notify the corresponding callbacks, which can cause, +      // loads to silently hang forever, a case that's especially bad for users using Futures on, +      // background threads., +            + ", stage: " + stage, t);, +        throwables.add(t);, +        throw t;, +    GlideException e = new GlideException("Failed to load resource", new ArrayList<>(throwables));, +    throwables.add(exception);, +      throwables.add(e);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java, +  private final Pool<List<Throwable>> listPool;, +      ResourceTranscoder<ResourceType, Transcode> transcoder, Pool<List<Throwable>> listPool) {, +    List<Throwable> exceptions = listPool.acquire();, +      int height, Options options, List<Throwable> exceptions) throws GlideException {, +      } catch (IOException | RuntimeException | OutOfMemoryError e) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/GlideException.java, +  private final List<Throwable> causes;, +    this(message, Collections.<Throwable>emptyList());, +  public GlideException(String detailMessage, Throwable cause) {, +  public GlideException(String detailMessage, List<Throwable> causes) {, +  public List<Throwable> getCauses() {, +  public List<Throwable> getRootCauses() {, +    List<Throwable> rootCauses = new ArrayList<>();, +    List<Throwable> causes = getRootCauses();, +  private void addRootCauses(Throwable throwable, List<Throwable> rootCauses) {, +    if (throwable instanceof GlideException) {, +      GlideException glideException = (GlideException) throwable;]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +  /**, +   * @return The context associated with this instance. , +   */, +  public Context getContext() {, +    return glideContext.getBaseContext();, +  }, +]
[+++ b/.gitignore, +*.iws, +bin/**, +++ b/.gitignore, +*.iws, +bin/**, +++ b/build.gradle, +apply plugin: 'java', +, +, +task addChildJarTasks {, +    configure(getAndroidChildren()) { project ->, +        def copyTask = task("makeJar", type: Copy) {, +            from("${project.buildDir}/intermediates/bundles/release/"), +            into("${project.buildDir}/lib"), +            include('classes.jar'), +            rename('classes.jar', "${project.name}.jar"), +        }, +        copyTask.dependsOn project.build, +    }, +}, +, +task childJars(type: Copy) {, +    destinationDir = file("${buildDir}/lib"), +, +    into("${buildDir}/lib") {, +        getAndroidChildren().each { p ->, +            from(p.tasks.getByName("makeJar")*.outputs), +        }, +    }, +}, +, +task cleanChildJars(type: Delete) {, +    delete "${buildDir}/lib", +}, +, +childJars.dependsOn(addChildJarTasks, cleanChildJars), +, +def binDirName = "bin", +, +task releaseJar(type: Jar) {, +    from(file("${buildDir}/lib").listFiles().collect { zipTree(it)}), +    into("${buildDir}/lib"), +    destinationDir = file(binDirName), +    baseName = "glide-${VERSION_NAME}", +}, +, +task cleanJar(type: Delete) {, +    delete binDirName, +}, +, +releaseJar.dependsOn(cleanJar, childJars), +, +artifacts {, +    archives releaseJar, +}, +, +++ b/.gitignore, +*.iws, +bin/**, +++ b/build.gradle, +apply plugin: 'java', +, +, +task addChildJarTasks {, +    configure(getAndroidChildren()) { project ->, +        def copyTask = task("makeJar", type: Copy) {, +            from("${project.buildDir}/intermediates/bundles/release/"), +            into("${project.buildDir}/lib"), +            include('classes.jar'), +            rename('classes.jar', "${project.name}.jar"), +        }, +        copyTask.dependsOn project.build, +    }, +}, +, +task childJars(type: Copy) {, +    destinationDir = file("${buildDir}/lib"), +, +    into("${buildDir}/lib") {, +        getAndroidChildren().each { p ->, +            from(p.tasks.getByName("makeJar")*.outputs), +        }, +    }, +}, +, +task cleanChildJars(type: Delete) {, +    delete "${buildDir}/lib", +}, +, +childJars.dependsOn(addChildJarTasks, cleanChildJars), +, +def binDirName = "bin", +, +task releaseJar(type: Jar) {, +    from(file("${buildDir}/lib").listFiles().collect { zipTree(it)}), +    into("${buildDir}/lib"), +    destinationDir = file(binDirName), +    baseName = "glide-${VERSION_NAME}", +}]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +import static com.bumptech.glide.gifdecoder.GifDecoder.TOTAL_ITERATION_COUNT_FOREVER;, +, +      int intrinsicCount = state.frameLoader.getLoopCount();, +      maxLoopCount =, +          (intrinsicCount == TOTAL_ITERATION_COUNT_FOREVER) ? LOOP_FOREVER : intrinsicCount;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +import static com.bumptech.glide.gifdecoder.GifDecoder.TOTAL_ITERATION_COUNT_FOREVER;, +, +      int intrinsicCount = state.frameLoader.getLoopCount();, +      maxLoopCount =, +          (intrinsicCount == TOTAL_ITERATION_COUNT_FOREVER) ? LOOP_FOREVER : intrinsicCount;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java, +    return gifDecoder.getTotalIterationCount();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +import static com.bumptech.glide.gifdecoder.GifDecoder.TOTAL_ITERATION_COUNT_FOREVER;, +, +      int intrinsicCount = state.frameLoader.getLoopCount();, +      maxLoopCount =, +          (intrinsicCount == TOTAL_ITERATION_COUNT_FOREVER) ? LOOP_FOREVER : intrinsicCount;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java, +    return gifDecoder.getTotalIterationCount();, +++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertTrue("drawable should be still running", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +  public void testUsesDecoderTotalLoopCountIfLoopCountIsLoopIntrinsic() {, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +  public void testLoopsForeverIfLoopCountIsLoopIntrinsicAndTotalIterationCountIsForever() {, +    final int frameCount = 3;, +    final int loopCount = 40;, +    when(frameLoader.getLoopCount()).thenReturn(GifDecoder.TOTAL_ITERATION_COUNT_FOREVER);, +    when(frameLoader.getFrameCount()).thenReturn(frameCount);, +    drawable.setLoopCount(GifDrawable.LOOP_INTRINSIC);, +    drawable.setVisible(true, true);, +    drawable.start();, +, +    runLoops(loopCount, frameCount);, +, +    verifyRanLoops(loopCount, frameCount);, +    assertTrue("drawable should be still running", drawable.isRunning());, +  }, +, +, +  @Test, +        assertTrue("drawable should be started before calling drawable.onFrameReady()",, +            drawable.isRunning());, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +import static com.bumptech.glide.gifdecoder.GifDecoder.TOTAL_ITERATION_COUNT_FOREVER;, +, +      int intrinsicCount = state.frameLoader.getLoopCount();, +      maxLoopCount =, +          (intrinsicCount == TOTAL_ITERATION_COUNT_FOREVER) ? LOOP_FOREVER : intrinsicCount;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java, +    return gifDecoder.getTotalIterationCount();, +++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertTrue("drawable should be still running", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +  public void testUsesDecoderTotalLoopCountIfLoopCountIsLoopIntrinsic() {, +    assertFalse("drawable should be stopped after loop is completed", drawable.isRunning());, +  public void testLoopsForeverIfLoopCountIsLoopIntrinsicAndTotalIterationCountIsForever() {, +    final int frameCount = 3;, +    final int loopCount = 40;, +    when(frameLoader.getLoopCount()).thenReturn(GifDecoder.TOTAL_ITERATION_COUNT_FOREVER);, +    when(frameLoader.getFrameCount()).thenReturn(frameCount);, +    drawable.setLoopCount(GifDrawable.LOOP_INTRINSIC);, +    drawable.setVisible(true, true);, +    drawable.start();, +, +    runLoops(loopCount, frameCount);, +, +    verifyRanLoops(loopCount, frameCount);, +    assertTrue("drawable should be still running", drawable.isRunning());, +  }, +, +, +  @Test, +        assertTrue("drawable should be started before calling drawable.onFrameReady()",, +            drawable.isRunning());, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, +  /** The total iteration count which means repeat forever. */, +  int TOTAL_ITERATION_COUNT_FOREVER = 0;, +   * Gets the "Netscape" loop count, if any. A count of 0 means repeat indefinitely., +   * @deprecated Use {@link #getNetscapeLoopCount()} instead., +   *             This method cannot distinguish whether the loop count is 1 or doesn't exist., +   * @return loop count if one was specified, else 1., +  @Deprecated, +   * Gets the "Netscape" loop count, if any., +   * A count of 0 ({@link GifHeader#NETSCAPE_LOOP_COUNT_FOREVER}) means repeat indefinitely.]
[+++ b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java, +import android.graphics.drawable.Drawable;, +import android.view.View;, + * Target<Bitmap> target =, + *     Glide.with(fragment), + *       .load("http://somefakeurl.com/fakeImage.jpeg"), + *       .apply(fitCenterTransform()), + * // At some later point, clear the Target to release the resources, prevent load queues from, + * // blowing out proportion, and to improve load times for future requests:, + * Glide.with(fragment).clear(target);, + * <p><em>Warning!</em> this class is extremely prone to mis-use. Use SimpleTarget only as a last, + * resort. {@link ViewTarget} or a subclass of {@link ViewTarget} is almost always a better choice., + *, + * <p><em>Don't forget to clear instances of this class!</em>. If you must use this class, keep in, + * mind that unlike {@link ViewTarget} it is not safe to load into new instances of this class, + * repeatedly if every instance updates the same underlying {@link View} or caller. If you need to, + * load into the same {@link View} or caller repeatedly using this class, always retain a reference, + * to the previous instance and either call {@link com.bumptech.glide.RequestManager#clear(Target)}, + * on the old instance before starting a new load or you must re-use the old instance for the new, + * load. Glide's {@link com.bumptech.glide.RequestBuilder#into(Target)} method returns the, + * {@link Target} instance you provided to make retaining a reference to the {@link Target} as easy, + * as possible. That said, you must wait until you're completely finished with the resource before, + * calling {@link com.bumptech.glide.RequestManager#clear(Target)} and you should always null out, + * references to any loaded resources in {@link Target#onLoadCleared(Drawable)}., + *, + * <p>Always try to provide a size when using this class. Use, + * {@link SimpleTarget#SimpleTarget(int, int)} whenever possible with values that are <em>not</em>, + * {@link Target#SIZE_ORIGINAL}. Using {@link Target#SIZE_ORIGINAL} is unsafe if you're loading, + * large images or are running your application on older or memory constrained devices because it, + * can cause Glide to load very large images into memory. In some cases those images may throw, + * {@link OutOfMemoryError} and in others they may exceed the texture limit for the device, which, + * will prevent them from being rendered. Providing a valid size allows Glide to downsample large, + * images, which can avoid issues with texture size or memory limitations. You don't have to worry, + * about providing a size in most cases if you use {@link ViewTarget} so prefer {@link ViewTarget}, + * over this class whenver possible., + *, + * @see <a href="http://bumptech.github.io/glide/doc/targets.html">Glide's Target docs page</a>, + *]
[+++ b/.idea/codeStyleSettings.xml, +++ b/.idea/codeStyleSettings.xml, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/.idea/codeStyleSettings.xml, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/integration/integration.iml, +<module external.linked.project.id=":integration" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="glide-parent" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +, +++ b/.idea/codeStyleSettings.xml, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/integration/integration.iml, +<module external.linked.project.id=":integration" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="glide-parent" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +, +++ b/integration/okhttp/okhttp.iml, +<module external.linked.project.id=":integration:okhttp" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="1.2.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/integration/integration.iml, +<module external.linked.project.id=":integration" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="glide-parent" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +, +++ b/integration/okhttp/okhttp.iml, +<module external.linked.project.id=":integration:okhttp" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="1.2.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +import com.bumptech.glide.Glide;, +    public void registerComponents(Context context, Glide glide) {, +        glide.register(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());, +++ b/.idea/codeStyleSettings.xml, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/integration/integration.iml, +<module external.linked.project.id=":integration" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="glide-parent" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +, +++ b/integration/okhttp/okhttp.iml, +<module external.linked.project.id=":integration:okhttp" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="1.2.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +import com.bumptech.glide.Glide;, +    public void registerComponents(Context context, Glide glide) {, +        glide.register(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +    private volatile Request request;, +        request = new Request.Builder(), +++ b/.idea/codeStyleSettings.xml, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/integration/integration.iml, +<module external.linked.project.id=":integration" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="glide-parent" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +, +++ b/integration/okhttp/okhttp.iml, +<module external.linked.project.id=":integration:okhttp" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="1.2.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +import com.bumptech.glide.Glide;, +    public void registerComponents(Context context, Glide glide) {, +        glide.register(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +    private volatile Request request;, +        request = new Request.Builder(), +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +import com.bumptech.glide.load.model.GenericLoaderFactory;, +        public ModelLoader<GlideUrl, InputStream> build(Context context, GenericLoaderFactory factories) {, +, +    private final OkHttpClient client;, +, +    public OkHttpUrlLoader(OkHttpClient client) {, +        this.client = client;]
[+++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +, +    @Override, +    public void removeCallback(SizeReadyCallback cb) {, +      // Do nothing because we don't retain references to SizeReadyCallbacks., +    }, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +, +    @Override, +    public void removeCallback(SizeReadyCallback cb) {, +      // Do nothing because we don't retain references to SizeReadyCallbacks., +    }, +++ b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java, +  @Override, +  public void removeCallback(SizeReadyCallback cb) {, +    // Do nothing because we do not retain references to SizeReadyCallbacks., +  }, +, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +, +    @Override, +    public void removeCallback(SizeReadyCallback cb) {, +      // Do nothing because we don't retain references to SizeReadyCallbacks., +    }, +++ b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java, +  @Override, +  public void removeCallback(SizeReadyCallback cb) {, +    // Do nothing because we do not retain references to SizeReadyCallbacks., +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +    target.removeCallback(this);, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +, +    @Override, +    public void removeCallback(SizeReadyCallback cb) {, +      // Do nothing because we don't retain references to SizeReadyCallbacks., +    }, +++ b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java, +  @Override, +  public void removeCallback(SizeReadyCallback cb) {, +    // Do nothing because we do not retain references to SizeReadyCallbacks., +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +    target.removeCallback(this);, +++ b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java, +, +  @Override, +  public void removeCallback(SizeReadyCallback cb) {, +    // Do nothing, we never retain a reference to the callback., +  }, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +, +    @Override, +    public void removeCallback(SizeReadyCallback cb) {, +      // Do nothing because we don't retain references to SizeReadyCallbacks., +    }, +++ b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java, +  @Override, +  public void removeCallback(SizeReadyCallback cb) {, +    // Do nothing because we do not retain references to SizeReadyCallbacks., +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +    target.removeCallback(this);, +++ b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java, +, +  @Override, +  public void removeCallback(SizeReadyCallback cb) {, +    // Do nothing, we never retain a reference to the callback., +  }, +++ b/library/src/main/java/com/bumptech/glide/request/target/Target.java, +   * Removes the given callback from the pending set if it's still retained., +   *, +   * @param cb The callback to remove., +   */, +  void removeCallback(SizeReadyCallback cb);, +, +  /**, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +, +    @Override, +    public void removeCallback(SizeReadyCallback cb) {, +      // Do nothing because we don't retain references to SizeReadyCallbacks., +    }, +++ b/library/src/main/java/com/bumptech/glide/request/RequestFutureTarget.java, +  @Override, +  public void removeCallback(SizeReadyCallback cb) {, +    // Do nothing because we do not retain references to SizeReadyCallbacks., +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +    target.removeCallback(this);, +++ b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java, +, +  @Override, +  public void removeCallback(SizeReadyCallback cb) {, +    // Do nothing, we never retain a reference to the callback., +  }]
[+++ b/library/AndroidManifest.xml, +          android:versionCode="4", +          android:versionName="2.0.2" >]
[+++ b/build.gradle, +++ b/build.gradle, +++ b/gradle.properties, +ANDROID_SUPPORT_VERSION=27.0.2, +COMPILE_SDK_VERSION=27, +TARGET_SDK_VERSION=27, +++ b/build.gradle, +++ b/gradle.properties, +ANDROID_SUPPORT_VERSION=27.0.2, +COMPILE_SDK_VERSION=27, +TARGET_SDK_VERSION=27, +++ b/integration/okhttp/build.gradle, +    api "com.squareup.okhttp:okhttp:2.7.2", +++ b/build.gradle, +++ b/gradle.properties, +ANDROID_SUPPORT_VERSION=27.0.2, +COMPILE_SDK_VERSION=27, +TARGET_SDK_VERSION=27, +++ b/integration/okhttp/build.gradle, +    api "com.squareup.okhttp:okhttp:2.7.2", +++ b/samples/imgur/build.gradle, +    implementation 'com.squareup.retrofit2:retrofit:2.3.0', +    implementation 'com.squareup.retrofit2:converter-gson:2.3.0', +    implementation 'com.squareup.retrofit2:adapter-rxjava:2.3.0', +    implementation 'io.reactivex:rxjava:1.3.4', +    compileOnly "com.google.errorprone:error_prone_annotations:2.1.3"]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +++ /dev/null, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +++ /dev/null, +++ /dev/null, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericTranscodeRequestTest.java, +    private TranscodeRequest<String, Object, Object> request;, +        when(optionsApplier.apply(any(RequestBuilder.class))).thenAnswer(arg(0));, +        request = new TranscodeRequest<String, Object, Object>(Robolectric.application,, +        RequestBuilder<String, Object, Object, Object> builder = request.transcode(transcoder, Object.class);, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericTranscodeRequestTest.java, +    private TranscodeRequest<String, Object, Object> request;, +        when(optionsApplier.apply(any(RequestBuilder.class))).thenAnswer(arg(0));, +        request = new TranscodeRequest<String, Object, Object>(Robolectric.application,, +        RequestBuilder<String, Object, Object, Object> builder = request.transcode(transcoder, Object.class);, +++ /dev/null, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericTranscodeRequestTest.java, +    private TranscodeRequest<String, Object, Object> request;, +        when(optionsApplier.apply(any(RequestBuilder.class))).thenAnswer(arg(0));, +        request = new TranscodeRequest<String, Object, Object>(Robolectric.application,, +        RequestBuilder<String, Object, Object, Object> builder = request.transcode(transcoder, Object.class);, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        RequestBuilder<Drawable, Drawable> firstRequest = requestManager.from(String.class).transcoder, +                (firstTranscoder), +        RequestBuilder<Drawable, Drawable> secondRequest = firstRequest.clone().transcoder(secondTranscoder);, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericTranscodeRequestTest.java, +    private TranscodeRequest<String, Object, Object> request;, +        when(optionsApplier.apply(any(RequestBuilder.class))).thenAnswer(arg(0));, +        request = new TranscodeRequest<String, Object, Object>(Robolectric.application,, +        RequestBuilder<String, Object, Object, Object> builder = request.transcode(transcoder, Object.class);, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        RequestBuilder<Drawable, Drawable> firstRequest = requestManager.from(String.class).transcoder, +                (firstTranscoder), +        RequestBuilder<Drawable, Drawable> secondRequest = firstRequest.clone().transcoder(secondTranscoder);, +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import android.graphics.Bitmap;, +, +    private RequestBuilder<Bitmap, Bitmap> request;, +            public RequestBuilder<Bitmap, Bitmap> getPreloadRequestBuilder(Object item) {, +                return mock(RequestBuilder.class);, +            public RequestBuilder<Bitmap, Bitmap> getPreloadRequestBuilder(Object item) {, +                return mock(RequestBuilder.class);, +            public RequestBuilder getPreloadRequestBuilder(Object item) {, +            public RequestBuilder getPreloadRequestBuilder(Object item) {, +    private List<Integer> getTagetsSizes(RequestBuilder<?, ?> requestBuilder,, +            VerificationMode callVerificationMode) {, +        // TODO: fixme., +            public RequestBuilder getPreloadRequestBuilder(Object item) {, +        public RequestBuilder getPreloadRequestBuilder(Object item) {, +            return mock(RequestBuilder.class);, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericTranscodeRequestTest.java, +    private TranscodeRequest<String, Object, Object> request;, +        when(optionsApplier.apply(any(RequestBuilder.class))).thenAnswer(arg(0));, +        request = new TranscodeRequest<String, Object, Object>(Robolectric.application,, +        RequestBuilder<String, Object, Object, Object> builder = request.transcode(transcoder, Object.class);, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        RequestBuilder<Drawable, Drawable> firstRequest = requestManager.from(String.class).transcoder, +                (firstTranscoder), +        RequestBuilder<Drawable, Drawable> secondRequest = firstRequest.clone().transcoder(secondTranscoder);, +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import android.graphics.Bitmap;, +, +    private RequestBuilder<Bitmap, Bitmap> request;]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.graphics.drawable.Drawable;, +import com.bumptech.glide.load.resource.drawable.ResourceDrawableDecoder;, +        /* Drawables */, +        .append(Uri.class, Drawable.class, new ResourceDrawableDecoder(context)), +        .append(Integer.class, Uri.class, new ResourceLoader.UriFactory(resources)), +        .append(int.class, Uri.class, new ResourceLoader.UriFactory(resources)), +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.graphics.drawable.Drawable;, +import com.bumptech.glide.load.resource.drawable.ResourceDrawableDecoder;, +        /* Drawables */, +        .append(Uri.class, Drawable.class, new ResourceDrawableDecoder(context)), +        .append(Integer.class, Uri.class, new ResourceLoader.UriFactory(resources)), +        .append(int.class, Uri.class, new ResourceLoader.UriFactory(resources)), +++ b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java, +, +  /**, +   * Factory for loading resource {@link Uri}s from Android resource ids., +   */, +  public static class UriFactory implements ModelLoaderFactory<Integer, Uri> {, +, +    private final Resources resources;, +, +    public UriFactory(Resources resources) {, +      this.resources = resources;, +    }, +, +    @Override, +    public ModelLoader<Integer, Uri> build(MultiModelLoaderFactory multiFactory) {, +      return new ResourceLoader<>(resources, new UnitModelLoader<Uri>());, +    }, +, +    @Override, +    public void teardown() {, +      // Do nothing., +    }, +  }, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.graphics.drawable.Drawable;, +import com.bumptech.glide.load.resource.drawable.ResourceDrawableDecoder;, +        /* Drawables */, +        .append(Uri.class, Drawable.class, new ResourceDrawableDecoder(context)), +        .append(Integer.class, Uri.class, new ResourceLoader.UriFactory(resources)), +        .append(int.class, Uri.class, new ResourceLoader.UriFactory(resources)), +++ b/library/src/main/java/com/bumptech/glide/load/model/ResourceLoader.java, +, +  /**, +   * Factory for loading resource {@link Uri}s from Android resource ids., +   */, +  public static class UriFactory implements ModelLoaderFactory<Integer, Uri> {, +, +    private final Resources resources;, +, +    public UriFactory(Resources resources) {, +      this.resources = resources;, +    }, +, +    @Override, +    public ModelLoader<Integer, Uri> build(MultiModelLoaderFactory multiFactory) {, +      return new ResourceLoader<>(resources, new UnitModelLoader<Uri>());, +    }, +, +    @Override, +    public void teardown() {, +      // Do nothing., +    }, +  }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java, +package com.bumptech.glide.load.resource.drawable;, +, +import android.content.Context;, +import android.content.res.Resources;, +import android.content.res.Resources.Theme;, +import android.graphics.drawable.Drawable;, +import android.support.annotation.DrawableRes;, +import android.support.annotation.Nullable;, +import android.support.v4.content.res.ResourcesCompat;, +import android.support.v7.content.res.AppCompatResources;, +, +/**, + * Handles decoding Drawables with the v7 support library if present and falling back to the v4, + * support library otherwise., + */, +public final class DrawableDecoderCompat {, +  private static volatile boolean shouldCallAppCompatResources = true;, +  private DrawableDecoderCompat() {, +    // Utility class., +  }, +, +  /**, +   * Loads a Drawable using {@link AppCompatResources} if available and {@link ResourcesCompat}, +   * otherwise, depending on whether or not the v7 support library is included in the application., +   */, +  public static Drawable getDrawable(Context context, @DrawableRes int id, @Nullable Theme theme) {, +    try {, +      // Race conditions may cause us to attempt to load using v7 more than once. That's ok since, +      // this check is a modest optimization and the output will be correct anyway., +      if (shouldCallAppCompatResources) {, +        return loadDrawableV7(context, id);, +      }]
[+++ b/gradle.properties, +VERSION_NAME=4.6.0]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.bitmap.UnitBitmapDecoder;, +import com.bumptech.glide.load.resource.drawable.UnitDrawableDecoder;, +        .append(, +            Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, new UnitBitmapDecoder(bitmapPool)), +        .append(Bitmap.class, Bitmap.class, UnitModelLoader.Factory.<Bitmap>getInstance()), +        .append(Drawable.class, Drawable.class, UnitModelLoader.Factory.<Drawable>getInstance()), +        .append(Drawable.class, Drawable.class, new UnitDrawableDecoder(bitmapPool)), +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.bitmap.UnitBitmapDecoder;, +import com.bumptech.glide.load.resource.drawable.UnitDrawableDecoder;, +        .append(, +            Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, new UnitBitmapDecoder(bitmapPool)), +        .append(Bitmap.class, Bitmap.class, UnitModelLoader.Factory.<Bitmap>getInstance()), +        .append(Drawable.class, Drawable.class, UnitModelLoader.Factory.<Drawable>getInstance()), +        .append(Drawable.class, Drawable.class, new UnitDrawableDecoder(bitmapPool)), +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;, +import android.graphics.Bitmap;, +import android.graphics.drawable.Drawable;, +   * Returns a request builder to load the given {@link Bitmap}., +   *, +   * <p>{@link Bitmap}s provided to this method become owned by Glide. The {@link Bitmap} may be, +   * recycled or re-used at any time. If you do not own the Bitmap or you need to continue to use, +   * the {@link Bitmap} after passing it in to Glide, consider passing a copy of the {@link Bitmap}, +   * to Glide instead. It's almost always better to allow Glide to load {@link Bitmap}s than, +   * pass {@link Bitmap}s into Glide. If you have a custom way to obtain {@link Bitmap}s that is, +   * not supported by Glide, consider registering a custom, +   * {@link com.bumptech.glide.load.model.ModelLoader} or, +   * {@link com.bumptech.glide.load.ResourceDecoder} instead., +   *, +   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Using other, +   * strategies may result in undefined behavior., +   *, +   * <p>In memory caching relies on Object equality. The contents of the {@link Bitmap}s are not, +   * compared., +   *, +   * @see #load(Object), +   */, +  @CheckResult, +  public RequestBuilder<TranscodeType> load(@Nullable Bitmap bitmap) {, +    return loadGeneric(bitmap), +        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));, +  }, +, +  /**, +   * Returns a request builder to load the given {@link Drawable}., +   *, +   * <p>{@link Drawable}s provided to this method become owned by Glide. They or {@link Bitmap}s, +   * they contain may be recycled or re-used at any time. If you do not own the {@link Drawable},, +   * do not pass it in to Glide. It's almost always better to allow Glide to load {@link Bitmap}s, +   * than pass {@link Bitmap}s into Glide. If you have a custom way to obtain {@link Bitmap}s that, +   * is not supported by Glide, consider registering a custom, +   * {@link com.bumptech.glide.load.model.ModelLoader} or, +   * {@link com.bumptech.glide.load.ResourceDecoder} instead., +   *, +   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Using other, +   * strategies may result in undefined behavior., +   *, +   * <p>In memory caching relies on Object equality. The contents of the {@link Drawable}s are not, +   * compared., +   *, +   * @see #load(Object), +   */, +  @CheckResult, +  public RequestBuilder<TranscodeType> load(@Nullable Drawable drawable) {, +    return loadGeneric(drawable), +        .apply(diskCacheStrategyOf(DiskCacheStrategy.NONE));, +  }, +, +  /**, +   * Returns a request builder to load the given {@link java.lang.String}., +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.bitmap.UnitBitmapDecoder;, +import com.bumptech.glide.load.resource.drawable.UnitDrawableDecoder;, +        .append(, +            Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, new UnitBitmapDecoder(bitmapPool)), +        .append(Bitmap.class, Bitmap.class, UnitModelLoader.Factory.<Bitmap>getInstance()), +        .append(Drawable.class, Drawable.class, UnitModelLoader.Factory.<Drawable>getInstance()), +        .append(Drawable.class, Drawable.class, new UnitDrawableDecoder(bitmapPool)), +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;, +import android.graphics.Bitmap;, +import android.graphics.drawable.Drawable;, +   * Returns a request builder to load the given {@link Bitmap}., +   *, +   * <p>{@link Bitmap}s provided to this method become owned by Glide. The {@link Bitmap} may be, +   * recycled or re-used at any time. If you do not own the Bitmap or you need to continue to use, +   * the {@link Bitmap} after passing it in to Glide, consider passing a copy of the {@link Bitmap}, +   * to Glide instead. It's almost always better to allow Glide to load {@link Bitmap}s than, +   * pass {@link Bitmap}s into Glide. If you have a custom way to obtain {@link Bitmap}s that is, +   * not supported by Glide, consider registering a custom, +   * {@link com.bumptech.glide.load.model.ModelLoader} or, +   * {@link com.bumptech.glide.load.ResourceDecoder} instead., +   *, +   * <p>The {@link DiskCacheStrategy} is set to {@link DiskCacheStrategy#NONE}. Using other, +   * strategies may result in undefined behavior., +   *, +   * <p>In memory caching relies on Object equality. The contents of the {@link Bitmap}s are not, +   * compared.]
[+++ b/library/src/main/java/com/bumptech/glide/load/Options.java, +import com.bumptech.glide.util.CachedHashCodeArrayMap;, +  private final ArrayMap<Option<?>, Object> values = new CachedHashCodeArrayMap<>();, +++ b/library/src/main/java/com/bumptech/glide/load/Options.java, +import com.bumptech.glide.util.CachedHashCodeArrayMap;, +  private final ArrayMap<Option<?>, Object> values = new CachedHashCodeArrayMap<>();, +++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +import com.bumptech.glide.util.CachedHashCodeArrayMap;, +  private Map<Class<?>, Transformation<?>> transformations = new CachedHashCodeArrayMap<>();, +      result.transformations = new CachedHashCodeArrayMap<>();, +++ b/library/src/main/java/com/bumptech/glide/load/Options.java, +import com.bumptech.glide.util.CachedHashCodeArrayMap;, +  private final ArrayMap<Option<?>, Object> values = new CachedHashCodeArrayMap<>();, +++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +import com.bumptech.glide.util.CachedHashCodeArrayMap;, +  private Map<Class<?>, Transformation<?>> transformations = new CachedHashCodeArrayMap<>();, +      result.transformations = new CachedHashCodeArrayMap<>();, +++ b/library/src/main/java/com/bumptech/glide/util/CachedHashCodeArrayMap.java, +package com.bumptech.glide.util;, +, +import android.support.v4.util.ArrayMap;, +import android.support.v4.util.SimpleArrayMap;, +, +/** An {@link ArrayMap} that caches its hashCode to support efficient lookup. */, +public final class CachedHashCodeArrayMap<K, V> extends ArrayMap<K, V> {, +, +  private int hashCode;, +, +  @Override, +  public void clear() {, +    hashCode = 0;, +    super.clear();, +  }, +, +  @Override, +  public V setValueAt(int index, V value) {, +    hashCode = 0;, +    return super.setValueAt(index, value);, +  }, +, +  @Override, +  public V put(K key, V value) {, +    hashCode = 0;, +    return super.put(key, value);, +  }, +, +  @Override, +  public void putAll(SimpleArrayMap<? extends K, ? extends V> simpleArrayMap) {, +    hashCode = 0;, +    super.putAll(simpleArrayMap);, +  }, +, +  @Override, +  public V removeAt(int index) {, +    hashCode = 0;, +    return super.removeAt(index);, +  }, +, +  @Override, +  public int hashCode() {, +    if (hashCode == 0) {, +      hashCode = super.hashCode();, +    }, +    return hashCode;, +  }, +}]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +        private static volatile OkHttpClient internalClient;, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +        private static volatile OkHttpClient internalClient;, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    private static volatile Glide glide;, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +        private static volatile OkHttpClient internalClient;, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    private static volatile Glide glide;, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java, +    private static final RequestManagerRetriever INSTANCE = new RequestManagerRetriever();, +        return INSTANCE;, +                    // events, we must force the manager to start resumed using ApplicationLifecycle.]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }, +    }, +}, +, +subprojects {, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = 1.7, +        targetCompatibility = 1.7, +    }, +}, +, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }]
[+++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.model.ResourceLoader;, +     * Use {@link com.bumptech.glide.loader.model.ResourceLoader} to load the given model, +            return new ResourceLoader(context);, +            return ResourceLoader.class;, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.model.ResourceLoader;, +     * Use {@link com.bumptech.glide.loader.model.ResourceLoader} to load the given model, +            return new ResourceLoader(context);, +            return ResourceLoader.class;, +++ /dev/null, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.model.ResourceLoader;, +     * Use {@link com.bumptech.glide.loader.model.ResourceLoader} to load the given model, +            return new ResourceLoader(context);, +            return ResourceLoader.class;, +++ /dev/null, +++ b/library/src/com/bumptech/glide/loader/model/ResourceLoader.java, +package com.bumptech.glide.loader.model;, +, +import android.content.Context;, +import android.net.Uri;, +import com.bumptech.glide.loader.stream.LocalUriLoader;, +import com.bumptech.glide.loader.stream.StreamLoader;, +, +/**, + * A model loader for handling resources. Model must be a resource id in the package of, + * the given context., + */, +public class ResourceLoader implements ModelLoader<Integer> {, +    private final Context context;, +, +    public ResourceLoader(Context context) {, +        this.context = context;, +    }, +, +    @Override, +    public StreamLoader getStreamLoader(Integer model, int width, int height) {, +        Uri uri = Uri.parse("android.resource://" + context.getPackageName() + "/" + model.toString());, +        return new LocalUriLoader(context, uri);, +    }, +, +    @Override, +    public String getId(Integer model) {, +        return model.toString();, +    }, +, +    @Override, +    public void clear() { }, +}, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.model.ResourceLoader;, +     * Use {@link com.bumptech.glide.loader.model.ResourceLoader} to load the given model, +            return new ResourceLoader(context);, +            return ResourceLoader.class;, +++ /dev/null, +++ b/library/src/com/bumptech/glide/loader/model/ResourceLoader.java, +package com.bumptech.glide.loader.model;, +, +import android.content.Context;, +import android.net.Uri;, +import com.bumptech.glide.loader.stream.LocalUriLoader;, +import com.bumptech.glide.loader.stream.StreamLoader;, +, +/**, + * A model loader for handling resources. Model must be a resource id in the package of, + * the given context., + */, +public class ResourceLoader implements ModelLoader<Integer> {, +    private final Context context;, +, +    public ResourceLoader(Context context) {, +        this.context = context;, +    }, +, +    @Override, +    public StreamLoader getStreamLoader(Integer model, int width, int height) {, +        Uri uri = Uri.parse("android.resource://" + context.getPackageName() + "/" + model.toString());, +        return new LocalUriLoader(context, uri);, +    }, +, +    @Override, +    public String getId(Integer model) {, +        return model.toString();, +    }, +, +    @Override, +    public void clear() { }, +}, +++ /dev/null, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.model.ResourceLoader;, +     * Use {@link com.bumptech.glide.loader.model.ResourceLoader} to load the given model, +            return new ResourceLoader(context);, +            return ResourceLoader.class;, +++ /dev/null, +++ b/library/src/com/bumptech/glide/loader/model/ResourceLoader.java, +package com.bumptech.glide.loader.model;, +, +import android.content.Context;]
[+++ b/.gitignore, +_site/*, +_pages/*, +++ b/.gitignore, +_site/*, +_pages/*, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples, +++ b/.gitignore, +_site/*, +_pages/*, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples, +++ b/.idea/.name, +glide, +++ b/.gitignore, +_site/*, +_pages/*, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples, +++ b/.idea/.name, +glide, +++ /dev/null, +++ b/.gitignore, +_site/*, +_pages/*, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples, +++ b/.idea/.name, +glide, +++ /dev/null, +++ /dev/null, +++ b/.gitignore, +_site/*, +_pages/*, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples, +++ b/.idea/.name, +glide, +++ /dev/null, +++ /dev/null, +++ b/.idea/codeStyleSettings.xml, +            <emptyLine />, +            <package name="" withSubpackages="true" static="true" />, +            <emptyLine />, +        <option name="RIGHT_MARGIN" value="100" />, +            <rules>, +              <section>, +                <rule>, +                  <match>, +                    <AND>, +                      <NAME>xmlns:android</NAME>, +                      <XML_NAMESPACE>Namespace:</XML_NAMESPACE>, +                    </AND>, +                  </match>, +                </rule>, +              </section>, +              <section>, +                <rule>, +                  <match>, +                    <AND>, +                      <NAME>xmlns:.*</NAME>, +                      <XML_NAMESPACE>Namespace:</XML_NAMESPACE>, +                    </AND>, +                  </match>, +                  <order>BY_NAME</order>, +                </rule>, +              </section>, +              <section>, +                <rule>, +                  <match>, +                    <AND>, +                      <NAME>.*:id</NAME>, +                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>, +                    </AND>, +                  </match>, +                </rule>, +              </section>, +              <section>, +                <rule>, +                  <match>, +                    <AND>, +                      <NAME>.*:name</NAME>, +                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>, +                    </AND>, +                  </match>, +                </rule>, +              </section>, +              <section>, +                <rule>]
[+++ b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java, +import android.util.Log;, +  private static final String TAG = "ManifestParser";, +    if (Log.isLoggable(TAG, Log.DEBUG)) {, +      Log.d(TAG, "Loading Glide modules");, +    }, +            if (Log.isLoggable(TAG, Log.DEBUG)) {, +              Log.d(TAG, "Loaded Glide module: " + key);, +            }, +    if (Log.isLoggable(TAG, Log.DEBUG)) {, +      Log.d(TAG, "Finished loading Glide modules");, +    }]
[+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +  private boolean isAutoCloneEnabled;, +    if (isAutoCloneEnabled) {, +      return clone().sizeMultiplier(sizeMultiplier);, +    }, +, +    if (isAutoCloneEnabled) {, +      return clone().diskCacheStrategy(strategy);, +    }, +    if (isAutoCloneEnabled) {, +      return clone().priority(priority);, +    }, +, +    if (isAutoCloneEnabled) {, +      return clone().placeholder(drawable);, +    }, +, +    if (isAutoCloneEnabled) {, +      return clone().placeholder(resourceId);, +    }, +, +    if (isAutoCloneEnabled) {, +      return clone().fallback(drawable);, +    }, +, +    if (isAutoCloneEnabled) {, +      return clone().fallback(resourceId);, +    }, +, +    if (isAutoCloneEnabled) {, +      return clone().error(drawable);, +    }, +, +    if (isAutoCloneEnabled) {, +      return clone().error(resourceId);, +    }, +    if (isAutoCloneEnabled) {, +      return clone().theme(theme);, +    }, +, +    if (isAutoCloneEnabled) {, +      return clone().skipMemoryCache(true);, +    }, +, +    if (isAutoCloneEnabled) {, +      return clone().override(width, height);, +    }, +, +    if (isAutoCloneEnabled) {, +      return clone().signature(signature);, +    }, +, +      result.isAutoCloneEnabled = false;, +    if (isAutoCloneEnabled) {, +      return clone().set(option, value);, +    }, +, +    if (isAutoCloneEnabled) {, +      return clone().decode(resourceClass);, +    }, +, +    return optionalTransform(context, DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop(context));, +    return transform(context, DownsampleStrategy.CENTER_OUTSIDE, new CenterCrop(context));, +    return optionalTransform(context, DownsampleStrategy.CENTER_INSIDE, new FitCenter(context));, +    return transform(context, DownsampleStrategy.CENTER_INSIDE, new FitCenter(context));, +    return optionalTransform(context, DownsampleStrategy.CENTER_OUTSIDE, new CircleCrop(context));, +    return transform(context, DownsampleStrategy.CENTER_OUTSIDE, new CircleCrop(context));, +  }, +, +  final CHILD optionalTransform(Context context, DownsampleStrategy downsampleStrategy,, +      Transformation<Bitmap> transformation) {, +    if (isAutoCloneEnabled) {, +      return clone().optionalTransform(context, downsampleStrategy, transformation);, +    }, +, +    downsample(downsampleStrategy);, +    return optionalTransform(context, transformation);, +  }, +, +  final CHILD transform(Context context, DownsampleStrategy downsampleStrategy,, +      Transformation<Bitmap> transformation) {, +    if (isAutoCloneEnabled) {, +      return clone().transform(context, downsampleStrategy, transformation);, +    }, +, +    downsample(downsampleStrategy);, +    return transform(context, transformation);, +    if (isAutoCloneEnabled) {, +      return clone().transform(context, transformation);, +    }, +, +    if (isAutoCloneEnabled) {, +      return clone().optionalTransform(context, transformation);, +    }, +, +    if (isAutoCloneEnabled) {, +      return clone().optionalTransform(resourceClass, transformation);, +    }, +, +    if (isAutoCloneEnabled) {]
[+++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import org.robolectric.RobolectricTestRunner;, +, +  @Mock private RequestBuilder<Bitmap> request;, +  @Mock private RequestManager requestManager;, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, toPreload);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, toPreload);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import org.robolectric.RobolectricTestRunner;, +, +  @Mock private RequestBuilder<Bitmap> request;, +  @Mock private RequestManager requestManager;, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, toPreload);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, toPreload);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestBuilderTest.java, +import org.robolectric.RobolectricTestRunner;, +, +  @Mock RequestManager requestManager;, +    new RequestBuilder(null /*context*/, requestManager, Object.class);, +    Target target = mock(Target.class);, +    getNullModelRequest().into(target);, +, +    verify(requestManager).track(eq(target), any(Request.class));, +    verify(requestManager).clear(eq(target));, +    return new RequestBuilder(glideContext, requestManager, Object.class), +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import org.robolectric.RobolectricTestRunner;, +, +  @Mock private RequestBuilder<Bitmap> request;, +  @Mock private RequestManager requestManager;, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, toPreload);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +        new ListPreloader<>(requestManager, preloaderAdapter, preloaderAdapter, toPreload);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +    ListPreloader<Object> preloader = new ListPreloader<>(requestManager,, +        preloaderAdapter, preloaderAdapter, 10);, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestBuilderTest.java, +import org.robolectric.RobolectricTestRunner;, +, +  @Mock RequestManager requestManager;, +    new RequestBuilder(null /*context*/, requestManager, Object.class);, +    Target target = mock(Target.class);, +    getNullModelRequest().into(target);, +, +    verify(requestManager).track(eq(target), any(Request.class));, +    verify(requestManager).clear(eq(target));, +    return new RequestBuilder(glideContext, requestManager, Object.class), +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameLoaderTest.java, +import org.robolectric.RobolectricTestRunner;, +import com.bumptech.glide.RequestManager;]
[+++ b/gradle.properties, +ANDROID_SUPPORT_VERSION=26.0.2, +++ b/gradle.properties, +ANDROID_SUPPORT_VERSION=26.0.2, +++ b/integration/recyclerview/build.gradle, +    provided "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}", +++ b/gradle.properties, +ANDROID_SUPPORT_VERSION=26.0.2, +++ b/integration/recyclerview/build.gradle, +    provided "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}", +++ b/library/build.gradle, +    provided "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}", +++ b/gradle.properties, +ANDROID_SUPPORT_VERSION=26.0.2, +++ b/integration/recyclerview/build.gradle, +    provided "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}", +++ b/library/build.gradle, +    provided "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}", +++ b/samples/gallery/build.gradle, +    compile "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}", +++ b/gradle.properties, +ANDROID_SUPPORT_VERSION=26.0.2, +++ b/integration/recyclerview/build.gradle, +    provided "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}", +++ b/library/build.gradle, +    provided "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}", +++ b/samples/gallery/build.gradle, +    compile "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}", +++ b/samples/giphy/build.gradle, +    compile 'com.google.code.gson:gson:2.8.0', +    compile "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}", +++ b/gradle.properties, +ANDROID_SUPPORT_VERSION=26.0.2, +++ b/integration/recyclerview/build.gradle, +    provided "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}", +++ b/library/build.gradle, +    provided "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}", +++ b/samples/gallery/build.gradle, +    compile "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}", +++ b/samples/giphy/build.gradle, +    compile 'com.google.code.gson:gson:2.8.0', +    compile "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}", +++ b/samples/svg/build.gradle, +    compile "com.android.support:support-fragment:${ANDROID_SUPPORT_VERSION}"]
[+++ b/library/src/main/java/com/bumptech/glide/ModelRequest.java, +        final StreamByteArrayLoader loader = new StreamByteArrayLoader(id);, +++ b/library/src/main/java/com/bumptech/glide/ModelRequest.java, +        final StreamByteArrayLoader loader = new StreamByteArrayLoader(id);, +++ b/library/src/main/java/com/bumptech/glide/load/data/ByteArrayFetcher.java, +    private final String id;, +    public ByteArrayFetcher(byte[] bytes, String id) {, +        this.id = id;, +    public String getId() {, +        return id;, +    }, +, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/ModelRequest.java, +        final StreamByteArrayLoader loader = new StreamByteArrayLoader(id);, +++ b/library/src/main/java/com/bumptech/glide/load/data/ByteArrayFetcher.java, +    private final String id;, +    public ByteArrayFetcher(byte[] bytes, String id) {, +        this.id = id;, +    public String getId() {, +        return id;, +    }, +, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java, +     * Returns a string uniquely identifying the data that this fetcher will fetch including the specific size., +     *, +     * <p>, +     *     A hash of the bytes of the data that will be fetched is the ideal id but since that is in many cases, +     *     impractical and not performant, urls, file paths, and uris are normally sufficient., +     * </p>, +     */, +    public String getId();, +, +    /**, +++ b/library/src/main/java/com/bumptech/glide/ModelRequest.java, +        final StreamByteArrayLoader loader = new StreamByteArrayLoader(id);, +++ b/library/src/main/java/com/bumptech/glide/load/data/ByteArrayFetcher.java, +    private final String id;, +    public ByteArrayFetcher(byte[] bytes, String id) {, +        this.id = id;, +    public String getId() {, +        return id;, +    }, +, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java, +     * Returns a string uniquely identifying the data that this fetcher will fetch including the specific size., +     *, +     * <p>, +     *     A hash of the bytes of the data that will be fetched is the ideal id but since that is in many cases, +     *     impractical and not performant, urls, file paths, and uris are normally sufficient., +     * </p>, +     */, +    public String getId();, +, +    /**, +++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java, +    @Override, +    public String getId() {, +        return uri.toString();, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/ModelRequest.java, +        final StreamByteArrayLoader loader = new StreamByteArrayLoader(id);, +++ b/library/src/main/java/com/bumptech/glide/load/data/ByteArrayFetcher.java, +    private final String id;, +    public ByteArrayFetcher(byte[] bytes, String id) {, +        this.id = id;, +    public String getId() {, +        return id;, +    }, +, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/load/data/DataFetcher.java, +     * Returns a string uniquely identifying the data that this fetcher will fetch including the specific size., +     *, +     * <p>, +     *     A hash of the bytes of the data that will be fetched is the ideal id but since that is in many cases, +     *     impractical and not performant, urls, file paths, and uris are normally sufficient., +     * </p>, +     */, +    public String getId();, +, +    /**, +++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java, +    @Override, +    public String getId() {, +        return uri.toString();, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/load/data/MediaStoreThumbFetcher.java, +    private final long dateModified;, +    private final int orientation;, +    private String mimeType;, +            int width, int height, String mimeType, long dateModified, int orientation) {, +        this(context, mediaStoreUri, defaultFetcher, width, height, mimeType, dateModified, orientation,, +                DEFAULT_FACTORY);, +            int height, String mimeType, long dateModified, int orientation, ThumbnailStreamOpenerFactory factory) {, +        this.mimeType = mimeType;]
[+++ b/.travis.yml, +, +cache:, +  directories:, +    - $HOME/.gradle, +]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +      if (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,, +          encodeStrategy)) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +      if (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,, +          encodeStrategy)) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java, +  ALL(true /*decodeCachedData*/, true /*decodeCachedResource*/) {, +    public boolean isDataCacheable(DataSource dataSource) {, +    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,, +  },, +  NONE(false /*decodeCachedData*/, false /*decodeCachedResource*/) {, +    public boolean isDataCacheable(DataSource dataSource) {, +    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,, +  },, +  DATA(true /*decodeCachedData*/, false /*decodeCachedResource*/) {, +    public boolean isDataCacheable(DataSource dataSource) {, +    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,, +  },, +  RESOURCE(false /*decodeCachedData*/, true /*decodeCachedResource*/) {, +    public boolean isDataCacheable(DataSource dataSource) {, +    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,, +  },, +  AUTOMATIC(true /*decodeCachedData*/, true /*decodeCachedResource*/) {, +    public boolean isDataCacheable(DataSource dataSource) {, +    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,, +  };, +  DiskCacheStrategy(boolean decodeCachedData,, +  public abstract boolean isDataCacheable(DataSource dataSource);, +   * Returns true if this request should cache the final transformed resource., +  public abstract boolean isResourceCacheable(boolean isFromAlternateCacheKey,, +      DataSource dataSource, EncodeStrategy encodeStrategy);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +      if (diskCacheStrategy.isResourceCacheable(isFromAlternateCacheKey, dataSource,, +          encodeStrategy)) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java, +  ALL(true /*decodeCachedData*/, true /*decodeCachedResource*/) {, +    public boolean isDataCacheable(DataSource dataSource) {, +    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,, +  },, +  NONE(false /*decodeCachedData*/, false /*decodeCachedResource*/) {, +    public boolean isDataCacheable(DataSource dataSource) {, +    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,, +  },, +  DATA(true /*decodeCachedData*/, false /*decodeCachedResource*/) {, +    public boolean isDataCacheable(DataSource dataSource) {, +    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,, +  },, +  RESOURCE(false /*decodeCachedData*/, true /*decodeCachedResource*/) {, +    public boolean isDataCacheable(DataSource dataSource) {, +    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,, +  },, +  AUTOMATIC(true /*decodeCachedData*/, true /*decodeCachedResource*/) {, +    public boolean isDataCacheable(DataSource dataSource) {, +    public boolean isResourceCacheable(boolean isFromAlternateCacheKey, DataSource dataSource,, +  };, +  DiskCacheStrategy(boolean decodeCachedData,, +  public abstract boolean isDataCacheable(DataSource dataSource);, +   * Returns true if this request should cache the final transformed resource., +  public abstract boolean isResourceCacheable(boolean isFromAlternateCacheKey,, +      DataSource dataSource, EncodeStrategy encodeStrategy);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java, +    DiskCacheStrategy diskCacheStrategy = requestContext.getDiskCacheStrategy();, +    if (data != null && diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) {]
[+++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="16" />]
[+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java, +    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java, +    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    registry = new Registry(), +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java, +    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    registry = new Registry(), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +  public Registry() {, +    this.modelLoaderRegistry = new ModelLoaderRegistry(exceptionListPool);, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java, +    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    registry = new Registry(), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +  public Registry() {, +    this.modelLoaderRegistry = new ModelLoaderRegistry(exceptionListPool);, +++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java, +   * @param contentResolver Any {@link android.content.ContentResolver}., +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java, +    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    registry = new Registry(), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +  public Registry() {, +    this.modelLoaderRegistry = new ModelLoaderRegistry(exceptionListPool);, +++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java, +   * @param contentResolver Any {@link android.content.ContentResolver}., +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java, +@SuppressWarnings("PMD.FieldDeclarationsShouldBeAtStartOfClass"), +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java, +    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    registry = new Registry(), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +  public Registry() {, +    this.modelLoaderRegistry = new ModelLoaderRegistry(exceptionListPool);, +++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java, +   * @param contentResolver Any {@link android.content.ContentResolver}., +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java, +@SuppressWarnings("PMD.FieldDeclarationsShouldBeAtStartOfClass"), +++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java, +   * {@code corePoolSize} threads., +   * See <a href=, +   * "http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html">, +   * ThreadPoolExecutor documentation</a>., +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java, +    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    registry = new Registry(), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +  public Registry() {, +    this.modelLoaderRegistry = new ModelLoaderRegistry(exceptionListPool);, +++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java, +   * @param contentResolver Any {@link android.content.ContentResolver}., +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java, +@SuppressWarnings("PMD.FieldDeclarationsShouldBeAtStartOfClass"), +++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java, +   * {@code corePoolSize} threads., +   * See <a href=, +   * "http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html">, +   * ThreadPoolExecutor documentation</a>., +++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java, +  public ModelLoaderRegistry(Pool<List<Exception>> exceptionListPool) {, +    this(new MultiModelLoaderFactory(exceptionListPool));, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java, +    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    registry = new Registry(), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +  public Registry() {, +    this.modelLoaderRegistry = new ModelLoaderRegistry(exceptionListPool);, +++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java, +   * @param contentResolver Any {@link android.content.ContentResolver}., +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java, +@SuppressWarnings("PMD.FieldDeclarationsShouldBeAtStartOfClass"), +++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java, +   * {@code corePoolSize} threads., +   * See <a href=, +   * "http://developer.android.com/reference/java/util/concurrent/ThreadPoolExecutor.html">, +   * ThreadPoolExecutor documentation</a>., +++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderRegistry.java, +  public ModelLoaderRegistry(Pool<List<Exception>> exceptionListPool) {, +    this(new MultiModelLoaderFactory(exceptionListPool));, +++ b/library/src/main/java/com/bumptech/glide/load/model/MultiModelLoaderFactory.java, +  public MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool) {, +    this(exceptionListPool, DEFAULT_FACTORY);, +  MultiModelLoaderFactory(Pool<List<Exception>> exceptionListPool,, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java, +    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    registry = new Registry(), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +  public Registry() {, +    this.modelLoaderRegistry = new ModelLoaderRegistry(exceptionListPool);, +++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java, +   * @param contentResolver Any {@link android.content.ContentResolver}.]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +class DecodeJob<R> implements DataFetcher.Callback<Object> {, +    Resource<R> result = null;, +    try {, +      Data data = fetcher.loadData(requestContext.getPriority());, +      if (data == null) {, +        return null;, +      }, +      result = path.load(data, requestContext, width, height,, +    } catch (IOException e) {, +      if (Logs.isEnabled(Log.VERBOSE)) {, +        Logs.log(Log.VERBOSE, "Fetcher failed: " + fetcher, e);, +      }, +    } finally {, +      fetcher.cleanup();, +    }, +    return result;, +  @Override, +  public void onDataReady(Object data) {, +, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +class DecodeJob<R> implements DataFetcher.Callback<Object> {, +    Resource<R> result = null;, +    try {, +      Data data = fetcher.loadData(requestContext.getPriority());, +      if (data == null) {, +        return null;, +      }, +      result = path.load(data, requestContext, width, height,, +    } catch (IOException e) {, +      if (Logs.isEnabled(Log.VERBOSE)) {, +        Logs.log(Log.VERBOSE, "Fetcher failed: " + fetcher, e);, +      }, +    } finally {, +      fetcher.cleanup();, +    }, +    return result;, +  @Override, +  public void onDataReady(Object data) {, +, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/LoadPath.java, +  public Resource<Transcode> load(Data data, RequestContext<Transcode> context,, +    Preconditions.checkNotNull(data);, +    Resource<Transcode> result = null;]
[+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +  public static final DecodeFormat DEFAULT = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT, +      ? PREFER_ARGB_8888 : PREFER_RGB_565;, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +  public static final DecodeFormat DEFAULT = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT, +      ? PREFER_ARGB_8888 : PREFER_RGB_565;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +        Log.v(TAG, "Reject bitmap from pool", +                + ", bitmap: " + strategy.logBitmap(bitmap), +                + ", is mutable: " + bitmap.isMutable(), +                + ", is allowed config: " + allowedConfigs.contains(bitmap.getConfig()));]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +    MethodSpec.Builder result = MethodSpec.methodBuilder(requestOptionMethod.name), +        .addModifiers(Modifier.PUBLIC), +                    return !input.type.equals(TypeName.get(Override.class)), +                        // SafeVarargs can only be applied to final methods. GlideRequest is, +                        // non-final to allow for mocking., +                        && !input.type.equals(TypeName.get(SafeVarargs.class));, +        .addStatement("return this");, +, +    if (requestOptionMethod.annotations.contains(, +        AnnotationSpec.builder(SafeVarargs.class).build())) {, +      result.addAnnotation(, +          AnnotationSpec.builder(SuppressWarnings.class), +              .addMember("value", "$S", "unchecked"), +              .addMember("value", "$S", "varargs"), +              .build());, +    }, +, +    return result.build();]
[+++ b/gradle.properties, +DAGGER_VERSION=2.10, +++ b/gradle.properties, +DAGGER_VERSION=2.10, +++ b/library/build.gradle, +, +++ b/gradle.properties, +DAGGER_VERSION=2.10, +++ b/library/build.gradle, +, +++ b/samples/imgur/.gitignore, +/build, +++ b/gradle.properties, +DAGGER_VERSION=2.10, +++ b/library/build.gradle, +, +++ b/samples/imgur/.gitignore, +/build, +++ b/samples/imgur/build.gradle, +apply plugin: 'com.android.application', +, +android {, +    compileSdkVersion COMPILE_SDK_VERSION as int, +    buildToolsVersion BUILD_TOOLS_VERSION, +, +    defaultConfig {, +        applicationId "com.bumptech.glide.samples.imgur", +        minSdkVersion MIN_SDK_VERSION as int, +        targetSdkVersion TARGET_SDK_VERSION as int, +        versionCode 1, +        versionName "1.0", +, +        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner", +, +    }, +    compileOptions {, +        sourceCompatibility JavaVersion.VERSION_1_7, +        targetCompatibility JavaVersion.VERSION_1_7, +    }, +    buildTypes {, +        release {, +            minifyEnabled false, +            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro', +        }, +    }, +}, +, +dependencies {, +    compile project(':library'), +    annotationProcessor project(':annotation:compiler'), +, +    compile "com.google.dagger:dagger:${DAGGER_VERSION}", +    annotationProcessor("com.google.dagger:dagger-compiler:${DAGGER_VERSION}", {, +        exclude group: 'com.google.code.findbugs', module: "jsr305", +    }), +    compile("com.google.dagger:dagger-android:${DAGGER_VERSION}", {, +        exclude group: 'com.google.code.findbugs', module: "jsr305", +    }), +, +    compile "com.squareup.okhttp3:okhttp:${OK_HTTP_VERSION}", +    compile 'com.squareup.retrofit2:retrofit:2.2.0', +    compile 'com.squareup.retrofit2:converter-gson:2.2.0', +    compile 'com.squareup.retrofit2:adapter-rxjava:2.2.0', +, +    compile 'io.reactivex:rxandroid:1.2.1', +    compile 'io.reactivex:rxjava:1.2.9', +, +    compile "com.android.support:appcompat-v7:${ANDROID_SUPPORT_VERSION}", +    compile "com.android.support:cardview-v7:${ANDROID_SUPPORT_VERSION}", +    compile "com.android.support:recyclerview-v7:${ANDROID_SUPPORT_VERSION}", +}, +, +task run(type: Exec, dependsOn: 'installDebug') {, +    description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"', +    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.card/.MainActivity', +}, +++ b/gradle.properties, +DAGGER_VERSION=2.10, +++ b/library/build.gradle, +, +++ b/samples/imgur/.gitignore, +/build, +++ b/samples/imgur/build.gradle, +apply plugin: 'com.android.application', +, +android {, +    compileSdkVersion COMPILE_SDK_VERSION as int, +    buildToolsVersion BUILD_TOOLS_VERSION, +, +    defaultConfig {, +        applicationId "com.bumptech.glide.samples.imgur", +        minSdkVersion MIN_SDK_VERSION as int, +        targetSdkVersion TARGET_SDK_VERSION as int, +        versionCode 1, +        versionName "1.0", +, +        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner", +, +    }, +    compileOptions {]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +import android.Manifest.permission;, +import android.support.test.rule.GrantPermissionRule;, +  @Rule public final TestName testName = new TestName();, +  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();, +  @Rule public final GrantPermissionRule grantPermissionRule;, +, +  {, +    if (Build.VERSION.SDK_INT > Build.VERSION_CODES.M) {, +      grantPermissionRule = GrantPermissionRule.grant(permission.SYSTEM_ALERT_WINDOW);, +    } else {, +      grantPermissionRule = GrantPermissionRule.grant();, +    }, +  }, +, +    layoutParams.type =, +        Build.VERSION.SDK_INT >= Build.VERSION_CODES.O, +            ? LayoutParams.TYPE_APPLICATION_OVERLAY, +            : Build.VERSION.SDK_INT == Build.VERSION_CODES.M, +                ? LayoutParams.TYPE_TOAST : LayoutParams.TYPE_SYSTEM_ALERT;]
[+++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +         if (modelClass == null) {, +            if (Log.isLoggable(TAG, Log.DEBUG)) {, +                Log.d(TAG, "Unable to load null model, setting placeholder only");, +            }, +            return null;, +        }, +        return buildModelLoader(model != null ? (Class<T>) model.getClass() : null, resourceClass, context);, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +         if (modelClass == null) {, +            if (Log.isLoggable(TAG, Log.DEBUG)) {, +                Log.d(TAG, "Unable to load null model, setting placeholder only");, +            }, +            return null;, +        }, +        return buildModelLoader(model != null ? (Class<T>) model.getClass() : null, resourceClass, context);, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +     * Returns a request builder to load the given {@link java.lang.String}., +     * @see #fromString(), +     * @see #load(Object), +     *, +     * @param string A file path, or a uri or url handled by {@link com.bumptech.glide.load.model.UriLoader}., +     */, +    public DrawableTypeRequest<String> load(String string) {, +        return (DrawableTypeRequest<String>) fromString().load(string);, +    }, +, +    /**, +     * Returns a request builder that loads data from {@link String}s using an empty signature., +     *, +     * @see #from(Class), +     * @see #load(String), +    public DrawableTypeRequest<String> fromString() {, +        return loadGeneric(String.class);, +     * Returns a request builder to load the given {@link Uri}., +     *, +     * @see #fromUri(), +     * @see #load(Object), +     *, +     * @param uri The Uri representing the image. Must be of a type handled by, +     * {@link com.bumptech.glide.load.model.UriLoader}., +     */, +    public DrawableTypeRequest<Uri> load(Uri uri) {, +        return (DrawableTypeRequest<Uri>) fromUri().load(uri);, +    }, +, +    /**, +     * Returns a request builder to load data from {@link android.net.Uri}s using no signature., +     * @see #from(Class), +    public DrawableTypeRequest<Uri> fromUri() {, +        return loadGeneric(Uri.class);, +        return (DrawableTypeRequest<Uri>) loadFromMediaStore(uri).signature(signature);, +    }, +, +    /**, +     * Returns a request builder to load the given media store {@link android.net.Uri}., +     *, +     * @see #fromMediaStore(), +     * @see #load(Object), +     *, +     * @param uri The uri representing the media., +     */, +    public DrawableTypeRequest<Uri> loadFromMediaStore(Uri uri) {, +        return (DrawableTypeRequest<Uri>) fromMediaStore().load(uri);, +     * {@link android.provider.MediaStore.Video.Thumbnails} to retrieve pre-generated thumbnails for, +     * {@link android.net.Uri}s., +     * @see #from(Class), +    public DrawableTypeRequest<Uri> fromMediaStore() {, +        ModelLoader<Uri, InputStream> genericStreamLoader = Glide.buildStreamModelLoader(Uri.class, context);, +        ModelLoader<Uri, ParcelFileDescriptor> fileDescriptorModelLoader =, +                Glide.buildFileDescriptorModelLoader(Uri.class, context);, +        return optionsApplier.apply(new DrawableTypeRequest<Uri>(Uri.class, mediaStoreLoader,, +                fileDescriptorModelLoader, context, glide, requestTracker, lifecycle, optionsApplier));, +    }, +, +    /**, +     * Returns a request builder to load the given {@link File}., +     *, +     * @see #fromFile(), +     * @see #load(Object), +     *, +     * @param file The File containing the image, +     */, +    public DrawableTypeRequest<File> load(File file) {, +        return (DrawableTypeRequest<File>) fromFile().load(file);, +     * {@link com.bumptech.glide.load.model.stream.StreamFileLoader} to load images from {@link File}s., +     * @see #from(Class), +    public DrawableTypeRequest<File> fromFile() {, +        return loadGeneric(File.class);, +    }, +, +    /**, +     * Returns a request builder to load the given resource id., +     *, +     * @see #fromResource(), +     * @see #load(Object), +     *]
[+++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.6.1', +    <version>3.6.1</version>, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.6.1', +    <version>3.6.1</version>, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, +    GifFrame previousFrame = null;, +    // clear all pixels when meet first frame, +    if (previousFrame == null) {, +      Arrays.fill(dest, 0);, +    }, +, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.6.1', +    <version>3.6.1</version>, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, +    GifFrame previousFrame = null;, +    // clear all pixels when meet first frame, +    if (previousFrame == null) {, +      Arrays.fill(dest, 0);, +    }, +, +++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java, +  public void testFirstFrameMustClearBeforeDrawingWhenLastFrameIsDisposalBackground(), +      throws IOException {, +    byte[] data = TestUtil.resourceToBytes(getClass(), "transparent_disposal_background.gif");, +    GifHeaderParser headerParser = new GifHeaderParser();, +    headerParser.setData(data);, +    GifHeader header = headerParser.parseHeader();, +    GifDecoder decoder = new GifDecoder(provider);, +    decoder.setData(header, data);, +    decoder.advance();, +    Bitmap firstFrame = decoder.getNextFrame();, +    decoder.advance();, +    decoder.getNextFrame();, +    decoder.advance();, +    Bitmap firstFrameTwice = decoder.getNextFrame();, +    assertTrue(Arrays.equals((((CustomShadowBitmap) shadowOf(firstFrame))).getPixels(),, +        (((CustomShadowBitmap) shadowOf(firstFrameTwice))).getPixels()));, +  }, +, +  @Test, +  @Config(shadows = {CustomShadowBitmap.class}), +  public void testFirstFrameMustClearBeforeDrawingWhenLastFrameIsDisposalNone() throws IOException {, +    byte[] data = TestUtil.resourceToBytes(getClass(), "transparent_disposal_none.gif");, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.6.1', +    <version>3.6.1</version>, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, +    GifFrame previousFrame = null;, +    // clear all pixels when meet first frame, +    if (previousFrame == null) {, +      Arrays.fill(dest, 0);, +    }, +, +++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java, +  public void testFirstFrameMustClearBeforeDrawingWhenLastFrameIsDisposalBackground(), +      throws IOException {, +    byte[] data = TestUtil.resourceToBytes(getClass(), "transparent_disposal_background.gif");, +    GifHeaderParser headerParser = new GifHeaderParser();, +    headerParser.setData(data);, +    GifHeader header = headerParser.parseHeader();, +    GifDecoder decoder = new GifDecoder(provider);, +    decoder.setData(header, data);, +    decoder.advance();, +    Bitmap firstFrame = decoder.getNextFrame();, +    decoder.advance();, +    decoder.getNextFrame();, +    decoder.advance();, +    Bitmap firstFrameTwice = decoder.getNextFrame();, +    assertTrue(Arrays.equals((((CustomShadowBitmap) shadowOf(firstFrame))).getPixels(),, +        (((CustomShadowBitmap) shadowOf(firstFrameTwice))).getPixels()));, +  }, +, +  @Test, +  @Config(shadows = {CustomShadowBitmap.class}), +  public void testFirstFrameMustClearBeforeDrawingWhenLastFrameIsDisposalNone() throws IOException {, +    byte[] data = TestUtil.resourceToBytes(getClass(), "transparent_disposal_none.gif");, +++ b/third_party/gif_decoder/src/test/resources/transparent_disposal_background.gif, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.6.1', +    <version>3.6.1</version>, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, +    GifFrame previousFrame = null;, +    // clear all pixels when meet first frame, +    if (previousFrame == null) {, +      Arrays.fill(dest, 0);, +    }, +, +++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java, +  public void testFirstFrameMustClearBeforeDrawingWhenLastFrameIsDisposalBackground(), +      throws IOException {, +    byte[] data = TestUtil.resourceToBytes(getClass(), "transparent_disposal_background.gif");, +    GifHeaderParser headerParser = new GifHeaderParser();, +    headerParser.setData(data);, +    GifHeader header = headerParser.parseHeader();, +    GifDecoder decoder = new GifDecoder(provider);, +    decoder.setData(header, data);, +    decoder.advance();]
[+++ b/CONTRIBUTING.md, +# Contributing, +Contributions of all types are welcome. We use GitHub as our bug and feature tracker both for code and for other, +aspects of the library (documentation, the wiki etc.), +, +## Asking Questions, +The best way to ask general questions is to send an email to our [mailing list][2], or join [#glide-library on, +freenode.org.][3], +, +## Filing issues, +To file an issue, please use our [issue template link][1] and fill out the template as much as possible. The more, +information you can provide, the more likely we are to be able help., +, +When in doubt, file an issue. We'd rather close a few duplicate issues than let a problem go unnoticed. Similarly if, +you support a particular feature request, feel free to let us know by commenting on the issue., +, +## Contributing code, +Pull requests are welcome for all parts of the codebase, especially the integration libraries. You can find, +instructions on building the project in our README. Our code style is defined in Intellij project files in the repo, +and also by our Checkstyle config. If you'd like to submit code, but can't get the style checks to pass, feel, +free to put up your pull request anyway and we can help you fix the style issues. If you'd like to, +contribute code, you will need to sign [Google's individual contributor license agreement][4]., +, +[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20(if%20any)**:%0A**Device/Android%20Version**:%0A**Issue%20details/Repro%20steps**:%0A%0A**Glide%20load%20line**:%0A```%0AGlide.with(context)...%3B%0A```%0A%0A**Stack%20trace**:%0A```%0Apaste%20stack%20trace%20here%0A```, +[2]: https://groups.google.com/forum/#!forum/glidelibrary, +[3]: http://webchat.freenode.net/?channels=glide-library, +[4]: https://developers.google.com/open-source/cla/individual., +++ b/CONTRIBUTING.md, +# Contributing, +Contributions of all types are welcome. We use GitHub as our bug and feature tracker both for code and for other, +aspects of the library (documentation, the wiki etc.), +, +## Asking Questions, +The best way to ask general questions is to send an email to our [mailing list][2], or join [#glide-library on, +freenode.org.][3], +, +## Filing issues, +To file an issue, please use our [issue template link][1] and fill out the template as much as possible. The more, +information you can provide, the more likely we are to be able help., +, +When in doubt, file an issue. We'd rather close a few duplicate issues than let a problem go unnoticed. Similarly if, +you support a particular feature request, feel free to let us know by commenting on the issue., +, +## Contributing code, +Pull requests are welcome for all parts of the codebase, especially the integration libraries. You can find, +instructions on building the project in our README. Our code style is defined in Intellij project files in the repo, +and also by our Checkstyle config. If you'd like to submit code, but can't get the style checks to pass, feel, +free to put up your pull request anyway and we can help you fix the style issues. If you'd like to, +contribute code, you will need to sign [Google's individual contributor license agreement][4]., +, +[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20(if%20any)**:%0A**Device/Android%20Version**:%0A**Issue%20details/Repro%20steps**:%0A%0A**Glide%20load%20line**:%0A```%0AGlide.with(context)...%3B%0A```%0A%0A**Stack%20trace**:%0A```%0Apaste%20stack%20trace%20here%0A```, +[2]: https://groups.google.com/forum/#!forum/glidelibrary, +[3]: http://webchat.freenode.net/?channels=glide-library, +[4]: https://developers.google.com/open-source/cla/individual., +++ b/README.md, +Before submitting pull requests, contributors must sign Google's [individual contributor license agreement][7]., +[5]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20(if%20any)**:%0A**Device/Android%20Version**:%0A**Issue%20details/Repro%20steps**:%0A%0A**Glide%20load%20line**:%0A```%0AGlide.with(context)...%3B%0A```%0A%0A**Stack%20trace**:%0A```%0Apaste%20stack%20trace%20here%0A```, +++ b/CONTRIBUTING.md, +# Contributing, +Contributions of all types are welcome. We use GitHub as our bug and feature tracker both for code and for other, +aspects of the library (documentation, the wiki etc.), +, +## Asking Questions, +The best way to ask general questions is to send an email to our [mailing list][2], or join [#glide-library on, +freenode.org.][3], +, +## Filing issues, +To file an issue, please use our [issue template link][1] and fill out the template as much as possible. The more, +information you can provide, the more likely we are to be able help., +, +When in doubt, file an issue. We'd rather close a few duplicate issues than let a problem go unnoticed. Similarly if, +you support a particular feature request, feel free to let us know by commenting on the issue., +, +## Contributing code, +Pull requests are welcome for all parts of the codebase, especially the integration libraries. You can find, +instructions on building the project in our README. Our code style is defined in Intellij project files in the repo, +and also by our Checkstyle config. If you'd like to submit code, but can't get the style checks to pass, feel, +free to put up your pull request anyway and we can help you fix the style issues. If you'd like to, +contribute code, you will need to sign [Google's individual contributor license agreement][4]., +, +[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20(if%20any)**:%0A**Device/Android%20Version**:%0A**Issue%20details/Repro%20steps**:%0A%0A**Glide%20load%20line**:%0A```%0AGlide.with(context)...%3B%0A```%0A%0A**Stack%20trace**:%0A```%0Apaste%20stack%20trace%20here%0A```, +[2]: https://groups.google.com/forum/#!forum/glidelibrary, +[3]: http://webchat.freenode.net/?channels=glide-library, +[4]: https://developers.google.com/open-source/cla/individual., +++ b/README.md, +Before submitting pull requests, contributors must sign Google's [individual contributor license agreement][7]., +[5]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20(if%20any)**:%0A**Device/Android%20Version**:%0A**Issue%20details/Repro%20steps**:%0A%0A**Glide%20load%20line**:%0A```%0AGlide.with(context)...%3B%0A```%0A%0A**Stack%20trace**:%0A```%0Apaste%20stack%20trace%20here%0A```, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java, +package com.bumptech.glide.integration.volley;, +, +import com.android.volley.Request;, +import com.android.volley.Request.Priority;, +, +import java.io.InputStream;, +, +/**, + * Used to construct a custom Volley request, such as for authentication header decoration., + */, +public interface VolleyRequestFactory {, +]
[+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +              animationExecutor,]
[+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java, +import android.support.annotation.Nullable;, +  private int workBufferSize;, +  private int workBufferPosition;, +  @Nullable, +  private Boolean isFirstFrameTransparent;, +    if (block == null) {, +      block = bitmapProvider.obtainByteArray(255);, +    }, +    if (workBuffer == null) {, +      workBuffer = bitmapProvider.obtainByteArray(WORK_BUFFER_SIZE);, +    }, +, +    isFirstFrameTransparent = null;, +    if (currentFrame.interlace || sampleSize != 1) {, +      copyCopyIntoScratchRobust(currentFrame);, +    } else {, +      copyIntoScratchFast(currentFrame);, +    }, +, +    // Copy pixels into previous image, +    if (savePrevious && (currentFrame.dispose == DISPOSAL_UNSPECIFIED, +        || currentFrame.dispose == DISPOSAL_NONE)) {, +      if (previousImage == null) {, +        previousImage = getNextBitmap();, +      }, +      previousImage.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth,, +          downsampledHeight);, +    }, +, +    // Set pixels for current image., +    Bitmap result = getNextBitmap();, +    result.setPixels(dest, 0, downsampledWidth, 0, 0, downsampledWidth, downsampledHeight);, +    return result;, +  }, +, +  private void copyIntoScratchFast(GifFrame currentFrame) {, +    int[] dest = mainScratch;, +    int downsampledIH = currentFrame.ih;, +    int downsampledIY = currentFrame.iy;, +    int downsampledIW = currentFrame.iw;, +    int downsampledIX = currentFrame.ix;, +    // Copy each source line to the appropriate place in the destination., +    boolean isFirstFrame = framePointer == 0;, +    int width = this.downsampledWidth;, +    byte[] mainPixels = this.mainPixels;, +    int[] act = this.act;, +    @Nullable Boolean isFirstFrameTransparent = this.isFirstFrameTransparent;, +    for (int i = 0; i < downsampledIH; i++) {, +      int line = i + downsampledIY;, +      int k = line * width;, +      // Start of line in dest., +      int dx = k + downsampledIX;, +      // End of dest line., +      int dlim = dx + downsampledIW;, +      if (k + width < dlim) {, +        // Past dest edge., +        dlim = k + width;, +      }, +      // Start of line in source., +      int sx = i * currentFrame.iw;, +      int averageColor;, +      if (isFirstFrameTransparent == null && isFirstFrame) {, +        while (dx < dlim) {, +          int currentColorIndex = ((int) mainPixels[sx]) & MASK_INT_LOWEST_BYTE;, +          averageColor = act[currentColorIndex];, +          if (averageColor != COLOR_TRANSPARENT_BLACK) {, +            dest[dx] = averageColor;, +          } else if (isFirstFrameTransparent == null) {, +            isFirstFrameTransparent = true;, +          }, +          ++sx;, +          ++dx;, +        }, +      } else {, +        while (dx < dlim) {, +          int currentColorIndex = ((int) mainPixels[sx]) & MASK_INT_LOWEST_BYTE;, +          averageColor = act[currentColorIndex];, +          if (averageColor != COLOR_TRANSPARENT_BLACK) {, +            dest[dx] = averageColor;, +          }, +          ++sx;, +          ++dx;, +        }, +      }, +    }, +, +    this.isFirstFrameTransparent = isFirstFrameTransparent == null, +        ? false : isFirstFrameTransparent;, +  }, +, +  private void copyCopyIntoScratchRobust(GifFrame currentFrame) {, +    int[] dest = mainScratch;, +    @Nullable, +    Boolean isFirstFrameTransparent = this.isFirstFrameTransparent;, +      boolean isNotDownsampling = sampleSize == 1;, +        if (isNotDownsampling) {, +          int averageColor;, +          while (dx < dlim) {, +            int currentColorIndex = ((int) mainPixels[sx]) & MASK_INT_LOWEST_BYTE;]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import com.bumptech.glide.util.Synthetic;, +  @Synthetic InputStream stream;, +  @Synthetic ResponseBody responseBody;, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import com.bumptech.glide.util.Synthetic;, +  @Synthetic InputStream stream;, +  @Synthetic ResponseBody responseBody;, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +import com.bumptech.glide.util.Synthetic;, +  @Synthetic InputStream stream;, +  @Synthetic ResponseBody responseBody;, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import com.bumptech.glide.util.Synthetic;, +  @Synthetic InputStream stream;, +  @Synthetic ResponseBody responseBody;, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +import com.bumptech.glide.util.Synthetic;, +  @Synthetic InputStream stream;, +  @Synthetic ResponseBody responseBody;, +++ b/library/pmd-ruleset.xml, +    <!--Overrides default check to avoid violation when @Synthetic annotation is present-->, +    <rule ref="rulesets/java/design.xml/UncommentedEmptyConstructor", +          message="Document empty constructor">, +, +        <properties>, +            <property name="xpath">, +                <value>, +                    <![CDATA[, +//ConstructorDeclaration[@Private='false'][count(BlockStatement) = 0 and, +($ignoreExplicitConstructorInvocation = 'true' or not(ExplicitConstructorInvocation)) and @containsComment = 'false', + and not(../Annotation/MarkerAnnotation/Name[@Image='Synthetic'])], + ]]>, +                </value>, +            </property>, +, +        </properties>, +, +    </rule>, +, +, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import com.bumptech.glide.util.Synthetic;, +  @Synthetic InputStream stream;, +  @Synthetic ResponseBody responseBody;, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +import com.bumptech.glide.util.Synthetic;, +  @Synthetic InputStream stream;, +  @Synthetic ResponseBody responseBody;, +++ b/library/pmd-ruleset.xml, +    <!--Overrides default check to avoid violation when @Synthetic annotation is present-->, +    <rule ref="rulesets/java/design.xml/UncommentedEmptyConstructor", +          message="Document empty constructor">, +, +        <properties>, +            <property name="xpath">, +                <value>, +                    <![CDATA[, +//ConstructorDeclaration[@Private='false'][count(BlockStatement) = 0 and, +($ignoreExplicitConstructorInvocation = 'true' or not(ExplicitConstructorInvocation)) and @containsComment = 'false', + and not(../Annotation/MarkerAnnotation/Name[@Image='Synthetic'])], + ]]>, +                </value>, +            </property>, +, +        </properties>, +, +    </rule>, +, +, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +import com.bumptech.glide.util.Synthetic;, +    @Synthetic int photoHeight;, +    @Synthetic int photoWidth;, +, +    @Synthetic, +    PreloadTarget() { }, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import com.bumptech.glide.util.Synthetic;, +  @Synthetic InputStream stream;, +  @Synthetic ResponseBody responseBody;, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +import com.bumptech.glide.util.Synthetic;, +  @Synthetic InputStream stream;, +  @Synthetic ResponseBody responseBody;, +++ b/library/pmd-ruleset.xml, +    <!--Overrides default check to avoid violation when @Synthetic annotation is present-->, +    <rule ref="rulesets/java/design.xml/UncommentedEmptyConstructor", +          message="Document empty constructor">, +, +        <properties>, +            <property name="xpath">, +                <value>, +                    <![CDATA[, +//ConstructorDeclaration[@Private='false'][count(BlockStatement) = 0 and, +($ignoreExplicitConstructorInvocation = 'true' or not(ExplicitConstructorInvocation)) and @containsComment = 'false', + and not(../Annotation/MarkerAnnotation/Name[@Image='Synthetic'])], + ]]>, +                </value>, +            </property>]
[+++ b/library/lint.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<lint>, +    <issue id="MissingApplicationIcon" severity="ignore" />, +    <issue id="AllowBackup" severity="ignore" />, +</lint>]
[+++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java, +    rootRequestManagerFragment =, +        Glide.get(activity).getRequestManagerRetriever().getRequestManagerFragment(activity);, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java, +    rootRequestManagerFragment =, +        Glide.get(activity).getRequestManagerRetriever().getRequestManagerFragment(activity);, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java, +      return supportFragmentGet(, +          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));, +      return supportFragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());, +      return fragmentGet(, +          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));, +      return fragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());, +  RequestManagerFragment getRequestManagerFragment(Activity activity) {, +    return getRequestManagerFragment(, +        activity.getFragmentManager(), /*parentHint=*/ null, isActivityVisible(activity));, +  }, +, +  @SuppressWarnings("deprecation"), +  @NonNull, +  private RequestManagerFragment getRequestManagerFragment(, +      @NonNull final android.app.FragmentManager fm,, +      @Nullable android.app.Fragment parentHint,, +      boolean isParentVisible) {, +        if (isParentVisible) {, +          current.getGlideLifecycle().onStart();, +        }, +      @Nullable android.app.Fragment parentHint,, +      boolean isParentVisible) {, +    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, isParentVisible);, +  SupportRequestManagerFragment getSupportRequestManagerFragment(FragmentActivity activity) {, +    return getSupportRequestManagerFragment(, +        activity.getSupportFragmentManager(), /*parentHint=*/ null, isActivityVisible(activity));, +  }, +, +  private static boolean isActivityVisible(Activity activity) {, +    // This is a poor heuristic, but it's about all we have. We'd rather err on the side of visible, +    // and start requests than on the side of invisible and ignore valid requests., +    return !activity.isFinishing();, +  }, +, +  @NonNull, +  private SupportRequestManagerFragment getSupportRequestManagerFragment(, +      @NonNull final FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) {, +        if (isParentVisible) {, +          current.getGlideLifecycle().onStart();, +        }, +  private RequestManager supportFragmentGet(, +      @NonNull Context context,, +      @NonNull FragmentManager fm,, +      @Nullable Fragment parentHint,, +      boolean isParentVisible) {, +    SupportRequestManagerFragment current =, +        getSupportRequestManagerFragment(fm, parentHint, isParentVisible);, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java, +    rootRequestManagerFragment =, +        Glide.get(activity).getRequestManagerRetriever().getRequestManagerFragment(activity);, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java, +      return supportFragmentGet(, +          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));, +      return supportFragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());, +      return fragmentGet(, +          activity, fm, /*parentHint=*/ null, isActivityVisible(activity));, +      return fragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());, +  RequestManagerFragment getRequestManagerFragment(Activity activity) {, +    return getRequestManagerFragment(, +        activity.getFragmentManager(), /*parentHint=*/ null, isActivityVisible(activity));, +  }, +, +  @SuppressWarnings("deprecation"), +  @NonNull, +  private RequestManagerFragment getRequestManagerFragment(, +      @NonNull final android.app.FragmentManager fm,, +      @Nullable android.app.Fragment parentHint,, +      boolean isParentVisible) {, +        if (isParentVisible) {, +          current.getGlideLifecycle().onStart();, +        }, +      @Nullable android.app.Fragment parentHint,, +      boolean isParentVisible) {, +    RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, isParentVisible);, +  SupportRequestManagerFragment getSupportRequestManagerFragment(FragmentActivity activity) {, +    return getSupportRequestManagerFragment(, +        activity.getSupportFragmentManager(), /*parentHint=*/ null, isActivityVisible(activity));, +  }, +, +  private static boolean isActivityVisible(Activity activity) {, +    // This is a poor heuristic, but it's about all we have. We'd rather err on the side of visible, +    // and start requests than on the side of invisible and ignore valid requests., +    return !activity.isFinishing();, +  }, +, +  @NonNull, +  private SupportRequestManagerFragment getSupportRequestManagerFragment(, +      @NonNull final FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) {, +        if (isParentVisible) {, +          current.getGlideLifecycle().onStart();, +        }, +  private RequestManager supportFragmentGet(, +      @NonNull Context context,]
[+++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +import com.bumptech.glide.provider.DataLoadProvider;, +import com.bumptech.glide.provider.LoadProvider;, +        Glide glide = mock(Glide.class);, +        when(glide.buildTranscoder(any(Class.class), any(Class.class))).thenReturn(mock(ResourceTranscoder.class));, +        when(glide.buildDataProvider(any(Class.class), any(Class.class))).thenReturn(mock(DataLoadProvider.class));, +, +        GenericRequestBuilder original = new GenericRequestBuilder(Robolectric.application, model,, +                mock(LoadProvider.class), null, glide, null, null);, +        request = new BitmapTypeRequest(original, mock(ModelLoader.class), mock(ModelLoader.class), optionsApplier);, +++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +import com.bumptech.glide.provider.DataLoadProvider;, +import com.bumptech.glide.provider.LoadProvider;, +        Glide glide = mock(Glide.class);, +        when(glide.buildTranscoder(any(Class.class), any(Class.class))).thenReturn(mock(ResourceTranscoder.class));, +        when(glide.buildDataProvider(any(Class.class), any(Class.class))).thenReturn(mock(DataLoadProvider.class));, +, +        GenericRequestBuilder original = new GenericRequestBuilder(Robolectric.application, model,, +                mock(LoadProvider.class), null, glide, null, null);, +        request = new BitmapTypeRequest(original, mock(ModelLoader.class), mock(ModelLoader.class), optionsApplier);, +++ b/library/src/androidTest/java/com/bumptech/glide/DrawableTypeRequestTest.java, +        request = new DrawableTypeRequest<String>(model, mock(ModelLoader.class),, +                mock(ModelLoader.class), Robolectric.application, Glide.get(Robolectric.application),, +                mock(RequestTracker.class), mock(Lifecycle.class), optionsApplier);, +++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +import com.bumptech.glide.provider.DataLoadProvider;, +import com.bumptech.glide.provider.LoadProvider;, +        Glide glide = mock(Glide.class);, +        when(glide.buildTranscoder(any(Class.class), any(Class.class))).thenReturn(mock(ResourceTranscoder.class));, +        when(glide.buildDataProvider(any(Class.class), any(Class.class))).thenReturn(mock(DataLoadProvider.class));, +, +        GenericRequestBuilder original = new GenericRequestBuilder(Robolectric.application, model,, +                mock(LoadProvider.class), null, glide, null, null);, +        request = new BitmapTypeRequest(original, mock(ModelLoader.class), mock(ModelLoader.class), optionsApplier);, +++ b/library/src/androidTest/java/com/bumptech/glide/DrawableTypeRequestTest.java, +        request = new DrawableTypeRequest<String>(model, mock(ModelLoader.class),, +                mock(ModelLoader.class), Robolectric.application, Glide.get(Robolectric.application),, +                mock(RequestTracker.class), mock(Lifecycle.class), optionsApplier);, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +        new GenericRequestBuilder(null, new Object(), mock(LoadProvider.class), Object.class, mock(Glide.class),, +        new GenericRequestBuilder(Robolectric.application, null, null, Object.class, mock(Glide.class), requestTracker,, +                mock(Lifecycle.class));, +        return new GenericRequestBuilder(Robolectric.application, null, null, Object.class, glide, requestTracker,, +                mock(Lifecycle.class));, +++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +import com.bumptech.glide.provider.DataLoadProvider;, +import com.bumptech.glide.provider.LoadProvider;, +        Glide glide = mock(Glide.class);, +        when(glide.buildTranscoder(any(Class.class), any(Class.class))).thenReturn(mock(ResourceTranscoder.class));, +        when(glide.buildDataProvider(any(Class.class), any(Class.class))).thenReturn(mock(DataLoadProvider.class));, +, +        GenericRequestBuilder original = new GenericRequestBuilder(Robolectric.application, model,, +                mock(LoadProvider.class), null, glide, null, null);, +        request = new BitmapTypeRequest(original, mock(ModelLoader.class), mock(ModelLoader.class), optionsApplier);, +++ b/library/src/androidTest/java/com/bumptech/glide/DrawableTypeRequestTest.java, +        request = new DrawableTypeRequest<String>(model, mock(ModelLoader.class),, +                mock(ModelLoader.class), Robolectric.application, Glide.get(Robolectric.application),, +                mock(RequestTracker.class), mock(Lifecycle.class), optionsApplier);, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +        new GenericRequestBuilder(null, new Object(), mock(LoadProvider.class), Object.class, mock(Glide.class),, +        new GenericRequestBuilder(Robolectric.application, null, null, Object.class, mock(Glide.class), requestTracker,, +                mock(Lifecycle.class));, +        return new GenericRequestBuilder(Robolectric.application, null, null, Object.class, glide, requestTracker,, +                mock(Lifecycle.class));, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericTranscodeRequestTest.java, +                Glide.get(Robolectric.application), model, mock(ModelLoader.class), Object.class,, +                Object.class, mock(RequestTracker.class), mock(Lifecycle.class), optionsApplier);, +++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +import com.bumptech.glide.provider.DataLoadProvider;, +import com.bumptech.glide.provider.LoadProvider;, +        Glide glide = mock(Glide.class);, +        when(glide.buildTranscoder(any(Class.class), any(Class.class))).thenReturn(mock(ResourceTranscoder.class));, +        when(glide.buildDataProvider(any(Class.class), any(Class.class))).thenReturn(mock(DataLoadProvider.class));, +, +        GenericRequestBuilder original = new GenericRequestBuilder(Robolectric.application, model,, +                mock(LoadProvider.class), null, glide, null, null);, +        request = new BitmapTypeRequest(original, mock(ModelLoader.class), mock(ModelLoader.class), optionsApplier);, +++ b/library/src/androidTest/java/com/bumptech/glide/DrawableTypeRequestTest.java, +        request = new DrawableTypeRequest<String>(model, mock(ModelLoader.class),, +                mock(ModelLoader.class), Robolectric.application, Glide.get(Robolectric.application),, +                mock(RequestTracker.class), mock(Lifecycle.class), optionsApplier);, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +        new GenericRequestBuilder(null, new Object(), mock(LoadProvider.class), Object.class, mock(Glide.class),, +        new GenericRequestBuilder(Robolectric.application, null, null, Object.class, mock(Glide.class), requestTracker,, +                mock(Lifecycle.class));, +        return new GenericRequestBuilder(Robolectric.application, null, null, Object.class, glide, requestTracker,, +                mock(Lifecycle.class));, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericTranscodeRequestTest.java, +                Glide.get(Robolectric.application), model, mock(ModelLoader.class), Object.class,, +                Object.class, mock(RequestTracker.class), mock(Lifecycle.class), optionsApplier);, +++ b/library/src/androidTest/java/com/bumptech/glide/GifTypeRequestTest.java, +import com.bumptech.glide.provider.DataLoadProvider;, +import com.bumptech.glide.provider.LoadProvider;, +, +        Glide glide = mock(Glide.class);, +        when(glide.buildTranscoder(any(Class.class), any(Class.class))).thenReturn(mock(ResourceTranscoder.class));, +        when(glide.buildDataProvider(any(Class.class), any(Class.class))).thenReturn(mock(DataLoadProvider.class));, +, +        GenericRequestBuilder original = new GenericRequestBuilder(Robolectric.application, model,, +                mock(LoadProvider.class), null, glide, null, null);]
[+++ b/.idea/codeStyleSettings.xml, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.idea/codeStyleSettings.xml, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        when(mockUrlLoader.getDataFetcher(any(GlideUrl.class), anyInt(), anyInt())).thenReturn(mockStreamFetcher);, +        when(modelLoader.getDataFetcher(eq(glideUrl), anyInt(), anyInt())), +        when(failLoader.getDataFetcher(any(failModel), anyInt(), anyInt())).thenReturn(failFetcher);, +        when(modelLoader.getDataFetcher(any(modelClass), anyInt(), anyInt())), +++ b/.idea/codeStyleSettings.xml, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        when(mockUrlLoader.getDataFetcher(any(GlideUrl.class), anyInt(), anyInt())).thenReturn(mockStreamFetcher);, +        when(modelLoader.getDataFetcher(eq(glideUrl), anyInt(), anyInt())), +        when(failLoader.getDataFetcher(any(failModel), anyInt(), anyInt())).thenReturn(failFetcher);, +        when(modelLoader.getDataFetcher(any(modelClass), anyInt(), anyInt())), +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/ImageVideoModelLoaderTest.java, +        String id = harness.getLoader().getDataFetcher(model, 1, 2).getId();, +        String id = harness.getLoader().getDataFetcher(model, 1, 2).getId();, +        String id = harness.getLoader().getDataFetcher(model, 1, 2).getId();, +                .getDataFetcher(any(Uri.class), anyInt(), anyInt())), +                .getDataFetcher(any(Uri.class), anyInt(), anyInt())), +                .getDataFetcher(new Object(), 100, 100), +        assertNotNull(harness.getLoader().getDataFetcher(new Object(), 100, 100));, +        assertNotNull(harness.getLoader().getDataFetcher(new Object(), 100, 100));, +        when(harness.streamModelLoader.getDataFetcher(anyObject(), anyInt(), anyInt())).thenReturn(null);, +        when(harness.fileDescriptorModelLoader.getDataFetcher(anyObject(), anyInt(), anyInt())).thenReturn(null);, +        assertNull(harness.getLoader().getDataFetcher(new Object(), 100, 100));, +        when(harness.fileDescriptorModelLoader.getDataFetcher(anyObject(), anyInt(), anyInt())).thenReturn(null);, +        assertNull(harness.getLoader().getDataFetcher(new Object(), 100, 100));, +        when(harness.streamModelLoader.getDataFetcher(anyObject(), anyInt(), anyInt())).thenReturn(null);, +        assertNull(harness.getLoader().getDataFetcher(new Object(), 100, 100));, +        String firstId = harness.getLoader().getDataFetcher(first, 1, 2).getId();, +        String secondId = harness.getLoader().getDataFetcher(second, 1, 2).getId();, +            when(streamModelLoader.getDataFetcher(anyObject(), anyInt(), anyInt())).thenReturn(streamFetcher);, +            when(fileDescriptorModelLoader.getDataFetcher(anyObject(), anyInt(), anyInt())), +++ b/.idea/codeStyleSettings.xml, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        when(mockUrlLoader.getDataFetcher(any(GlideUrl.class), anyInt(), anyInt())).thenReturn(mockStreamFetcher);, +        when(modelLoader.getDataFetcher(eq(glideUrl), anyInt(), anyInt())), +        when(failLoader.getDataFetcher(any(failModel), anyInt(), anyInt())).thenReturn(failFetcher);, +        when(modelLoader.getDataFetcher(any(modelClass), anyInt(), anyInt())), +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/ImageVideoModelLoaderTest.java, +        String id = harness.getLoader().getDataFetcher(model, 1, 2).getId();, +        String id = harness.getLoader().getDataFetcher(model, 1, 2).getId();, +        String id = harness.getLoader().getDataFetcher(model, 1, 2).getId();, +                .getDataFetcher(any(Uri.class), anyInt(), anyInt())), +                .getDataFetcher(any(Uri.class), anyInt(), anyInt())), +                .getDataFetcher(new Object(), 100, 100), +        assertNotNull(harness.getLoader().getDataFetcher(new Object(), 100, 100));, +        assertNotNull(harness.getLoader().getDataFetcher(new Object(), 100, 100));, +        when(harness.streamModelLoader.getDataFetcher(anyObject(), anyInt(), anyInt())).thenReturn(null);, +        when(harness.fileDescriptorModelLoader.getDataFetcher(anyObject(), anyInt(), anyInt())).thenReturn(null);, +        assertNull(harness.getLoader().getDataFetcher(new Object(), 100, 100));, +        when(harness.fileDescriptorModelLoader.getDataFetcher(anyObject(), anyInt(), anyInt())).thenReturn(null);, +        assertNull(harness.getLoader().getDataFetcher(new Object(), 100, 100));, +        when(harness.streamModelLoader.getDataFetcher(anyObject(), anyInt(), anyInt())).thenReturn(null);, +        assertNull(harness.getLoader().getDataFetcher(new Object(), 100, 100));, +        String firstId = harness.getLoader().getDataFetcher(first, 1, 2).getId();, +        String secondId = harness.getLoader().getDataFetcher(second, 1, 2).getId();, +            when(streamModelLoader.getDataFetcher(anyObject(), anyInt(), anyInt())).thenReturn(streamFetcher);, +            when(fileDescriptorModelLoader.getDataFetcher(anyObject(), anyInt(), anyInt())), +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java, +        assertNull(urlLoader.getDataFetcher(new Object(), 100, 100));, +        assertNull(urlLoader.getDataFetcher(new Object(), 100, 100));, +        when(wrapped.getDataFetcher(eq(expectedUrl), eq(width), eq(height))).thenReturn(expectedFetcher);, +        assertEquals(expectedFetcher, urlLoader.getDataFetcher(model, width, height));, +        when(wrapped.getDataFetcher(any(GlideUrl.class), eq(width), eq(height))).thenAnswer(, +        assertEquals(expected, urlLoader.getDataFetcher(new Object(), width, height));, +        urlLoader.getDataFetcher(model, width, height);, +        when(wrapped.getDataFetcher(any(GlideUrl.class), eq(width), eq(height))).thenReturn(expected);, +        assertEquals(expected, urlLoader.getDataFetcher(new Object(), width, height));, +++ b/.idea/codeStyleSettings.xml, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        when(mockUrlLoader.getDataFetcher(any(GlideUrl.class), anyInt(), anyInt())).thenReturn(mockStreamFetcher);, +        when(modelLoader.getDataFetcher(eq(glideUrl), anyInt(), anyInt())), +        when(failLoader.getDataFetcher(any(failModel), anyInt(), anyInt())).thenReturn(failFetcher);, +        when(modelLoader.getDataFetcher(any(modelClass), anyInt(), anyInt()))]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java, +package com.bumptech.glide.load.engine.cache;, +, +import com.bumptech.glide.load.Key;, +import com.bumptech.glide.util.Preconditions;, +, +import java.util.ArrayDeque;, +import java.util.HashMap;, +import java.util.Map;, +import java.util.Queue;, +import java.util.concurrent.locks.Lock;, +import java.util.concurrent.locks.ReentrantLock;, +, +/**, + * Keeps a map of keys to locks that allows locks to be removed from the map when no longer in use, + * so the size of the collection is bounded., + *, + * <p> This class will be accessed by multiple threads in a thread pool and ensures that the, + *  number of threads interested in each lock is updated atomically so that when the count reaches, + *  0, the lock can safely be removed from the map. </p>, + */, +final class DiskCacheWriteLocker {, +  private final Map<Key, WriteLock> locks = new HashMap<>();, +  private final WriteLockPool writeLockPool = new WriteLockPool();, +, +  void acquire(Key key) {, +    WriteLock writeLock;, +    synchronized (this) {, +      writeLock = locks.get(key);, +      if (writeLock == null) {, +        writeLock = writeLockPool.obtain();, +        locks.put(key, writeLock);, +      }, +      writeLock.interestedThreads++;, +    }, +, +    writeLock.lock.lock();, +  }, +, +  void release(Key key) {, +    WriteLock writeLock;, +    synchronized (this) {, +      writeLock = Preconditions.checkNotNull(locks.get(key));, +      Preconditions.checkArgument(writeLock.interestedThreads >= 1,, +          "Cannot release a lock that is not held", +              + ", key: " + key, +              + ", interestedThreads: " + writeLock.interestedThreads);, +, +      writeLock.interestedThreads--;, +      if (writeLock.interestedThreads == 0) {, +        WriteLock removed = locks.remove(key);, +        if (!removed.equals(writeLock)) {, +          throw new IllegalStateException("Removed the wrong lock", +              + ", expected to remove: " + writeLock, +              + ", but actually removed: " + removed, +              + ", key: " + key);, +        }, +        writeLockPool.offer(removed);, +      }, +    }, +, +    writeLock.lock.unlock();, +  }, +, +  private static class WriteLock  {, +    final Lock lock = new ReentrantLock();, +    int interestedThreads;, +  }, +, +  private static class WriteLockPool {, +    private static final int MAX_POOL_SIZE = 10;, +    private final Queue<WriteLock> pool = new ArrayDeque<>();, +, +    WriteLock obtain() {, +      WriteLock result;, +      synchronized (pool) {, +        result = pool.poll();, +      }, +      if (result == null) {, +        result = new WriteLock();, +      }, +      return result;, +    }, +, +    void offer(WriteLock writeLock) {, +      synchronized (pool) {, +        if (pool.size() < MAX_POOL_SIZE) {, +          pool.offer(writeLock);, +        }, +      }, +    }, +  }, +}, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheWriteLocker.java, +package com.bumptech.glide.load.engine.cache;, +, +import com.bumptech.glide.load.Key;, +import com.bumptech.glide.util.Preconditions;, +, +import java.util.ArrayDeque;]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        new ResourceDrawableDecoder(context);, +            Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, new UnitBitmapDecoder()), +        .append(Drawable.class, Drawable.class, new UnitDrawableDecoder()), +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        new ResourceDrawableDecoder(context);, +            Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, new UnitBitmapDecoder()), +        .append(Drawable.class, Drawable.class, new UnitDrawableDecoder()), +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than, +   * not supported by Glide by default, consider registering a custom, +   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method., +   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than to pass, +   * {@link Bitmap}s into Glide using this method . If you have a custom way to obtain, +   * {@link Bitmap}s that is not supported by Glide by default, consider registering a custom, +   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method., +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        new ResourceDrawableDecoder(context);, +            Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, new UnitBitmapDecoder()), +        .append(Drawable.class, Drawable.class, new UnitDrawableDecoder()), +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than, +   * not supported by Glide by default, consider registering a custom, +   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method., +   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than to pass, +   * {@link Bitmap}s into Glide using this method . If you have a custom way to obtain, +   * {@link Bitmap}s that is not supported by Glide by default, consider registering a custom, +   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method., +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;, +/**, + * Passes through a (hopefully) non-owned {@link Bitmap} as a {@link Bitmap} based {@link Resource}, + * so that the given {@link Bitmap} is not recycled., + */, +  private static final BitmapPoolAdapter BITMAP_POOL = new BitmapPoolAdapter();, +    return new BitmapResource(source, BITMAP_POOL);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        new ResourceDrawableDecoder(context);, +            Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, new UnitBitmapDecoder()), +        .append(Drawable.class, Drawable.class, new UnitDrawableDecoder()), +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than, +   * not supported by Glide by default, consider registering a custom, +   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method., +   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than to pass, +   * {@link Bitmap}s into Glide using this method . If you have a custom way to obtain, +   * {@link Bitmap}s that is not supported by Glide by default, consider registering a custom, +   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method., +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;, +/**, + * Passes through a (hopefully) non-owned {@link Bitmap} as a {@link Bitmap} based {@link Resource}, + * so that the given {@link Bitmap} is not recycled., + */, +  private static final BitmapPoolAdapter BITMAP_POOL = new BitmapPoolAdapter();, +    return new BitmapResource(source, BITMAP_POOL);, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        new ResourceDrawableDecoder(context);, +            Registry.BUCKET_BITMAP, Bitmap.class, Bitmap.class, new UnitBitmapDecoder()), +        .append(Drawable.class, Drawable.class, new UnitDrawableDecoder()), +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than, +   * not supported by Glide by default, consider registering a custom, +   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method., +   * <p>It's almost always better to allow Glide to load {@link Bitmap}s than to pass, +   * {@link Bitmap}s into Glide using this method . If you have a custom way to obtain, +   * {@link Bitmap}s that is not supported by Glide by default, consider registering a custom, +   * {@link com.bumptech.glide.load.ResourceDecoder} instead of using this method., +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/UnitBitmapDecoder.java, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;, +/**, + * Passes through a (hopefully) non-owned {@link Bitmap} as a {@link Bitmap} based {@link Resource}, + * so that the given {@link Bitmap} is not recycled., + */, +  private static final BitmapPoolAdapter BITMAP_POOL = new BitmapPoolAdapter();, +    return new BitmapResource(source, BITMAP_POOL);, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java, +package com.bumptech.glide.load.resource.drawable;, +, +import android.graphics.drawable.Drawable;, +import com.bumptech.glide.load.engine.Resource;, +, +/**, + * Handles generic {@link Drawable} types where we may be uncertain of their size or type and, + * where we don't know that it's safe for us to recycle or re-use the Drawable., + */, +final class NonOwnedDrawableResource extends DrawableResource<Drawable> {, +, +  @SuppressWarnings("unchecked"), +  public static Resource<Drawable> newInstance(Drawable drawable) {, +    return new NonOwnedDrawableResource(drawable);, +  }, +, +  private NonOwnedDrawableResource(Drawable drawable) {, +    super(drawable);, +  }, +, +  @SuppressWarnings("unchecked")]
[+++ b/library/src/androidTest/java/com/bumptech/glide/manager/RequestTrackerTest.java, +import static com.google.common.truth.Truth.assertThat;, +import static org.mockito.Mockito.times;, +    verify(request).recycle();, +  }, +, +  @Test, +  public void testClearRemoveAndRecycle_withNullRequest_doesNothingAndReturnsFalse() {, +    assertThat(tracker.clearRemoveAndRecycle(null)).isFalse();, +  }, +, +  @Test, +  public void testClearRemoveAndRecycle_withUnTrackedRequest_doesNothingAndReturnsFalse() {, +    Request request = mock(Request.class);, +, +    assertThat(tracker.clearRemoveAndRecycle(request)).isFalse();, +, +    verify(request, never()).clear();, +    verify(request, never()).recycle();, +  }, +, +  @Test, +  public void testClearRemoveAndRecycle_withTrackedRequest_clearsRecyclesAndReturnsTrue() {, +    Request request = mock(Request.class);, +    tracker.addRequest(request);, +, +    assertThat(tracker.clearRemoveAndRecycle(request)).isTrue();, +    verify(request).clear();, +    verify(request).recycle();, +  }, +, +  @Test, +  public void testClearRemoveAndRecyle_withAlreadyRemovedRequest_doesNothingAndReturnsFalse() {, +    Request request = mock(Request.class);, +    tracker.addRequest(request);, +    tracker.clearRemoveAndRecycle(request);, +    assertThat(tracker.clearRemoveAndRecycle(request)).isFalse();, +, +    verify(request, times(1)).clear();, +    verify(request, times(1)).recycle();, +    tracker.clearRemoveAndRecycle(request);, +    verify(request, times(1)).clear();, +    doAnswer(new ClearAndRemoveRequest(second)).when(first).begin();, +    doAnswer(new ClearAndRemoveRequest(second)).when(first).pause();, +    doAnswer(new ClearAndRemoveRequest(second)).when(first).clear();, +    doAnswer(new ClearAndRemoveRequest(second)).when(first).pause();, +  private class ClearAndRemoveRequest implements Answer<Void> {, +    public ClearAndRemoveRequest(Request toRemove) {, +      tracker.clearRemoveAndRecycle(toRemove);, +++ b/library/src/androidTest/java/com/bumptech/glide/manager/RequestTrackerTest.java, +import static com.google.common.truth.Truth.assertThat;, +import static org.mockito.Mockito.times;, +    verify(request).recycle();, +  }, +, +  @Test, +  public void testClearRemoveAndRecycle_withNullRequest_doesNothingAndReturnsFalse() {, +    assertThat(tracker.clearRemoveAndRecycle(null)).isFalse();, +  }, +, +  @Test, +  public void testClearRemoveAndRecycle_withUnTrackedRequest_doesNothingAndReturnsFalse() {, +    Request request = mock(Request.class);, +, +    assertThat(tracker.clearRemoveAndRecycle(request)).isFalse();, +, +    verify(request, never()).clear();, +    verify(request, never()).recycle();, +  }, +, +  @Test, +  public void testClearRemoveAndRecycle_withTrackedRequest_clearsRecyclesAndReturnsTrue() {, +    Request request = mock(Request.class);, +    tracker.addRequest(request);, +, +    assertThat(tracker.clearRemoveAndRecycle(request)).isTrue();, +    verify(request).clear();, +    verify(request).recycle();, +  }, +, +  @Test, +  public void testClearRemoveAndRecyle_withAlreadyRemovedRequest_doesNothingAndReturnsFalse() {, +    Request request = mock(Request.class);, +    tracker.addRequest(request);, +    tracker.clearRemoveAndRecycle(request);, +    assertThat(tracker.clearRemoveAndRecycle(request)).isFalse();, +, +    verify(request, times(1)).clear();, +    verify(request, times(1)).recycle();, +    tracker.clearRemoveAndRecycle(request);, +    verify(request, times(1)).clear();, +    doAnswer(new ClearAndRemoveRequest(second)).when(first).begin();, +    doAnswer(new ClearAndRemoveRequest(second)).when(first).pause();, +    doAnswer(new ClearAndRemoveRequest(second)).when(first).clear();, +    doAnswer(new ClearAndRemoveRequest(second)).when(first).pause();, +  private class ClearAndRemoveRequest implements Answer<Void> {, +    public ClearAndRemoveRequest(Request toRemove) {, +      tracker.clearRemoveAndRecycle(toRemove);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    if (request != null) {]
[+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java, +package com.bumptech.glide.annotation.compiler;, +, +import static com.bumptech.glide.annotation.compiler.test.Util.appResource;, +import static com.bumptech.glide.annotation.compiler.test.Util.emptyLibraryModule;, +import static com.bumptech.glide.annotation.compiler.test.Util.glide;, +import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;, +import static com.google.testing.compile.CompilationSubject.assertThat;, +import static com.google.testing.compile.Compiler.javac;, +, +import com.bumptech.glide.annotation.compiler.test.Util;, +import com.google.testing.compile.Compilation;, +import java.io.IOException;, +import javax.tools.JavaFileObject;, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +, +@RunWith(JUnit4.class), +public class AppGlideModuleWithExcludesTest {, +  private Compilation compilation;, +, +  @Before, +  public void setUp() {, +    compilation =, +        javac(), +            .withProcessors(new GlideAnnotationProcessor()), +            .compile(, +                forResource("AppModuleWithExcludes.java"),, +                emptyLibraryModule());, +    assertThat(compilation).succeededWithoutWarnings();, +  }, +, +  @Test, +  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {, +    assertThat(compilation), +        .generatedSourceFile(subpackage("GlideOptions")), +        .contentsAsUtf8String(), +        .isEqualTo(appResource("GlideOptions.java").getCharContent(true));, +  }, +, +  @Test, +  public void compilation_generatesExpectedGlideRequestClass() throws IOException {, +    assertThat(compilation), +        .generatedSourceFile(subpackage("GlideRequest")), +        .contentsAsUtf8String(), +        .isEqualTo(appResource("GlideRequest.java").getCharContent(true));, +  }, +, +  @Test, +  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {, +    assertThat(compilation), +        .generatedSourceFile(subpackage("GlideRequests")), +        .contentsAsUtf8String(), +        .isEqualTo(appResource("GlideRequests.java").getCharContent(true));, +  }, +, +  @Test, +  public void compilationGeneratesExpectedGlideAppClass() throws IOException {, +    assertThat(compilation), +        .generatedSourceFile(subpackage("GlideApp")), +        .contentsAsUtf8String(), +        .isEqualTo(appResource("GlideApp.java").getCharContent(true));, +  }, +, +  @Test, +  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {, +    assertThat(compilation), +        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl")), +        .contentsAsUtf8String(), +        .isEqualTo(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true));, +  }, +, +  @Test, +  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {, +    assertThat(compilation), +        .generatedSourceFile(glide("GeneratedRequestManagerFactory")), +        .contentsAsUtf8String(), +        .isEqualTo(appResource("GeneratedRequestManagerFactory.java").getCharContent(true));, +  }, +, +  private JavaFileObject forResource(String name) {, +    return Util.forResource(getClass().getSimpleName(), name);, +  }, +}, +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java, +package com.bumptech.glide.annotation.compiler;, +, +import static com.bumptech.glide.annotation.compiler.test.Util.appResource;, +import static com.bumptech.glide.annotation.compiler.test.Util.emptyLibraryModule;, +import static com.bumptech.glide.annotation.compiler.test.Util.glide;, +import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;, +import static com.google.testing.compile.CompilationSubject.assertThat;, +import static com.google.testing.compile.Compiler.javac;, +, +import com.bumptech.glide.annotation.compiler.test.Util;, +import com.google.testing.compile.Compilation;, +import java.io.IOException;, +import javax.tools.JavaFileObject;]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +package com.bumptech.glide;, +, +import android.content.Context;, +import com.bumptech.glide.manager.ConnectivityMonitor;, +import com.bumptech.glide.manager.ConnectivityMonitorFactory;, +import com.bumptech.glide.manager.RequestTracker;, +, +public class RequestManager {, +, +    private final ConnectivityMonitor connectivityMonitor;, +    private final RequestTracker requestTracker;, +, +    public RequestManager(Context context) {, +        this(context, new RequestTracker(), new ConnectivityMonitorFactory());, +    }, +, +    RequestManager(Context context, RequestTracker requestTracker, ConnectivityMonitorFactory factory) {, +        this.requestTracker = requestTracker;, +        this.connectivityMonitor = factory.build(context, new RequestManagerConnectivityListener());, +        connectivityMonitor.register();, +    }, +, +    public RequestTracker getRequestTracker() {, +        return requestTracker;, +    }, +, +    public void onStart() {, +        // onStart might not be called because this object may be created after the fragment/activity's onStart method., +        connectivityMonitor.register();, +, +        requestTracker.resumeRequests();, +    }, +, +    public void onStop() {, +        connectivityMonitor.unregister();, +        requestTracker.pauseRequests();, +    }, +, +    public void onDestroy() {, +        requestTracker.clearRequests();, +    }, +, +    private class RequestManagerConnectivityListener implements ConnectivityMonitor.ConnectivityListener {, +, +        @Override, +        public void onConnectivityChanged(boolean isConnected) {, +            if (isConnected) {, +                requestTracker.restartRequests();, +            }, +        }, +    }, +}, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +package com.bumptech.glide;, +, +import android.content.Context;, +import com.bumptech.glide.manager.ConnectivityMonitor;, +import com.bumptech.glide.manager.ConnectivityMonitorFactory;, +import com.bumptech.glide.manager.RequestTracker;, +, +public class RequestManager {, +, +    private final ConnectivityMonitor connectivityMonitor;, +    private final RequestTracker requestTracker;, +, +    public RequestManager(Context context) {, +        this(context, new RequestTracker(), new ConnectivityMonitorFactory());, +    }, +, +    RequestManager(Context context, RequestTracker requestTracker, ConnectivityMonitorFactory factory) {, +        this.requestTracker = requestTracker;, +        this.connectivityMonitor = factory.build(context, new RequestManagerConnectivityListener());, +        connectivityMonitor.register();, +    }, +, +    public RequestTracker getRequestTracker() {, +        return requestTracker;, +    }, +, +    public void onStart() {, +        // onStart might not be called because this object may be created after the fragment/activity's onStart method., +        connectivityMonitor.register();, +, +        requestTracker.resumeRequests();, +    }, +, +    public void onStop() {, +        connectivityMonitor.unregister();, +        requestTracker.pauseRequests();, +    }, +, +    public void onDestroy() {, +        requestTracker.clearRequests();, +    }, +, +    private class RequestManagerConnectivityListener implements ConnectivityMonitor.ConnectivityListener {]
[+++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888;, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +  public static final DecodeFormat DEFAULT = PREFER_ARGB_8888;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java, +++ b/library/test/src/test/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillerTest.java, +    order.verify(builder).setConfig(, +        DecodeFormat.DEFAULT == DecodeFormat.PREFER_ARGB_8888]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java, +package com.bumptech.glide.load.resource.bitmap;, +, +import android.content.Context;, +import android.graphics.Bitmap;, +import android.support.annotation.Nullable;, +, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import com.bumptech.glide.util.Preconditions;, +, +import java.nio.ByteBuffer;, +import java.security.MessageDigest;, +, +/**, + * A {@link BitmapTransformation} which rounds the corners of a bitmap., + */, +public final class RoundedCorners extends BitmapTransformation {, +  private static final String ID = "com.bumptech.glide.load.resource.bitmap.RoundedCorners";, +  private static final byte[] ID_BYTES = ID.getBytes(CHARSET);, +, +  private final int roundingRadius;, +, +  /**, +   * @param roundingRadius the corner radius (in device-specific pixels)., +   * @throws IllegalArgumentException if rounding radius is 0 or less., +   */, +  public RoundedCorners(BitmapPool bitmapPool, int roundingRadius) {, +    super(bitmapPool);, +    Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");, +    this.roundingRadius = roundingRadius;, +  }, +, +  /**, +   * @param roundingRadius the corner radius (in device-specific pixels)., +   * @throws IllegalArgumentException if rounding radius is 0 or less., +   */, +  public RoundedCorners(Context context, int roundingRadius) {, +    super(context);, +    Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");, +    this.roundingRadius = roundingRadius;, +  }, +, +  @Override, +  protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {, +    return TransformationUtils.roundedCorners(pool, toTransform, outWidth, outHeight,, +        roundingRadius);, +  }, +, +  @Override, +  public boolean equals(@Nullable Object o) {, +    return (o instanceof RoundedCorners) && ((RoundedCorners) o).roundingRadius == roundingRadius;, +  }, +, +  @Override, +  public int hashCode() {, +    return ID.hashCode() + roundingRadius;, +  }, +, +  @Override, +  public void updateDiskCacheKey(MessageDigest messageDigest) {, +    messageDigest.update(ID_BYTES);, +, +    byte[] radiusData = ByteBuffer.allocate(4).putInt(roundingRadius).array();, +    messageDigest.update(radiusData);, +  }, +}, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java, +package com.bumptech.glide.load.resource.bitmap;, +, +import android.content.Context;, +import android.graphics.Bitmap;, +import android.support.annotation.Nullable;, +, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import com.bumptech.glide.util.Preconditions;, +, +import java.nio.ByteBuffer;, +import java.security.MessageDigest;, +, +/**, + * A {@link BitmapTransformation} which rounds the corners of a bitmap., + */, +public final class RoundedCorners extends BitmapTransformation {, +  private static final String ID = "com.bumptech.glide.load.resource.bitmap.RoundedCorners";, +  private static final byte[] ID_BYTES = ID.getBytes(CHARSET);, +, +  private final int roundingRadius;, +, +  /**, +   * @param roundingRadius the corner radius (in device-specific pixels)., +   * @throws IllegalArgumentException if rounding radius is 0 or less., +   */, +  public RoundedCorners(BitmapPool bitmapPool, int roundingRadius) {, +    super(bitmapPool);, +    Preconditions.checkArgument(roundingRadius > 0, "roundingRadius must be greater than 0.");, +    this.roundingRadius = roundingRadius;, +  }, +, +  /**, +   * @param roundingRadius the corner radius (in device-specific pixels).]
[+++ b/integration/okhttp/gradle.properties, +POM_NAME=Glide Volley Integration, +POM_ARTIFACT_ID=volley-integration, +POM_PACKAGING=aar, +++ b/integration/okhttp/gradle.properties, +POM_NAME=Glide Volley Integration, +POM_ARTIFACT_ID=volley-integration, +POM_PACKAGING=aar, +++ b/integration/okhttp/lint.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<lint>, +    <issue id="AllowBackup" severity="ignore" />, +</lint>, +++ b/integration/okhttp/gradle.properties, +POM_NAME=Glide Volley Integration, +POM_ARTIFACT_ID=volley-integration, +POM_PACKAGING=aar, +++ b/integration/okhttp/lint.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<lint>, +    <issue id="AllowBackup" severity="ignore" />, +</lint>, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +package com.bumptech.glide.integration.okhttp;, +, +public class OkHttpStreamFetcher {, +}, +++ b/integration/okhttp/gradle.properties, +POM_NAME=Glide Volley Integration, +POM_ARTIFACT_ID=volley-integration, +POM_PACKAGING=aar, +++ b/integration/okhttp/lint.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<lint>, +    <issue id="AllowBackup" severity="ignore" />, +</lint>, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +package com.bumptech.glide.integration.okhttp;, +, +public class OkHttpStreamFetcher {, +}, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +package com.bumptech.glide.integration.okhttp;, +, +public class OkHttpUrlLoader {, +}, +++ b/integration/okhttp/gradle.properties, +POM_NAME=Glide Volley Integration, +POM_ARTIFACT_ID=volley-integration, +POM_PACKAGING=aar, +++ b/integration/okhttp/lint.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<lint>, +    <issue id="AllowBackup" severity="ignore" />, +</lint>, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +package com.bumptech.glide.integration.okhttp;, +, +public class OkHttpStreamFetcher {, +}, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +package com.bumptech.glide.integration.okhttp;, +, +public class OkHttpUrlLoader {, +}, +++ b/integration/volley/src/main/AndroidManifest.xml, +<?xml version="1.0" encoding="utf-8"?>, +<manifest xmlns:android="http://schemas.android.com/apk/res/android", +          package="com.bumptech.glide.volley", +          android:versionCode="1", +          android:versionName="1.0.0" >, +  <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="19" />, +  <application />, +</manifest>, +++ b/integration/okhttp/gradle.properties, +POM_NAME=Glide Volley Integration, +POM_ARTIFACT_ID=volley-integration, +POM_PACKAGING=aar, +++ b/integration/okhttp/lint.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<lint>, +    <issue id="AllowBackup" severity="ignore" />, +</lint>, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +package com.bumptech.glide.integration.okhttp;, +, +public class OkHttpStreamFetcher {, +}, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +package com.bumptech.glide.integration.okhttp;, +, +public class OkHttpUrlLoader {, +}, +++ b/integration/volley/src/main/AndroidManifest.xml, +<?xml version="1.0" encoding="utf-8"?>, +<manifest xmlns:android="http://schemas.android.com/apk/res/android", +          package="com.bumptech.glide.volley", +          android:versionCode="1", +          android:versionName="1.0.0" >, +  <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="19" />]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +import com.bumptech.glide.GlideBuilder;, +    public void applyOptions(Context context, GlideBuilder builder) {, +        // Do nothing., +    }, +, +    @Override, +    public void registerComponents(Context context, Glide glide) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +import com.bumptech.glide.GlideBuilder;, +    public void applyOptions(Context context, GlideBuilder builder) {, +        // Do nothing., +    }, +, +    @Override, +    public void registerComponents(Context context, Glide glide) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java, +import com.bumptech.glide.GlideBuilder;, +    public void applyOptions(Context context, GlideBuilder builder) {, +        // Do nothing., +    }, +, +    @Override, +    public void registerComponents(Context context, Glide glide) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +import com.bumptech.glide.GlideBuilder;, +    public void applyOptions(Context context, GlideBuilder builder) {, +        // Do nothing., +    }, +, +    @Override, +    public void registerComponents(Context context, Glide glide) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java, +import com.bumptech.glide.GlideBuilder;, +    public void applyOptions(Context context, GlideBuilder builder) {, +        // Do nothing., +    }, +, +    @Override, +    public void registerComponents(Context context, Glide glide) {, +++ b/library/src/androidTest/java/com/bumptech/glide/module/ManifestParserTest.java, +import com.bumptech.glide.GlideBuilder;, +        public void applyOptions(Context context, GlideBuilder builder) { }, +, +        @Override, +        public void registerComponents(Context context, Glide glide) { }, +        public void applyOptions(Context context, GlideBuilder builder) { }, +, +        @Override, +        public void registerComponents(Context context, Glide glide) { }, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +import com.bumptech.glide.GlideBuilder;, +    public void applyOptions(Context context, GlideBuilder builder) {, +        // Do nothing., +    }, +, +    @Override, +    public void registerComponents(Context context, Glide glide) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java, +import com.bumptech.glide.GlideBuilder;, +    public void applyOptions(Context context, GlideBuilder builder) {, +        // Do nothing., +    }, +, +    @Override, +    public void registerComponents(Context context, Glide glide) {, +++ b/library/src/androidTest/java/com/bumptech/glide/module/ManifestParserTest.java, +import com.bumptech.glide.GlideBuilder;, +        public void applyOptions(Context context, GlideBuilder builder) { }, +, +        @Override, +        public void registerComponents(Context context, Glide glide) { }, +        public void applyOptions(Context context, GlideBuilder builder) { }, +, +        @Override, +        public void registerComponents(Context context, Glide glide) { }, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import java.util.List;, +                    Context applicationContext = context.getApplicationContext();, +                    List<GlideModule> modules = new ManifestParser(applicationContext).parse();, +, +                    GlideBuilder builder = new GlideBuilder(applicationContext);, +                    for (GlideModule module : modules) {, +                        module.applyOptions(applicationContext, builder);, +                    }, +                    glide = builder.createGlide();, +                    for (GlideModule module : modules) {, +                        module.registerComponents(applicationContext, glide);, +                    }, +     *, +     * @deprecated Use {@link com.bumptech.glide.module.GlideModule} instead. Scheduled to be removed in Glide 4.0., +    @Deprecated, +     * @deprecated Use {@link com.bumptech.glide.module.GlideModule} instead. Scheduled to be removed in Glide 4.0., +    @Deprecated, +     * @deprecated Use {@link #register(Class, Class, com.bumptech.glide.load.model.ModelLoaderFactory)} to replace, +     * a registered loader rather than simply removing it., +    @Deprecated, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +import com.bumptech.glide.GlideBuilder;, +    public void applyOptions(Context context, GlideBuilder builder) {]
[+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java, +          mainPixels[pi] = suffix[code];, +          ++pi;, +          ++i;, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java, +          mainPixels[pi] = suffix[code];, +          ++pi;, +          ++i;, +++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java, +  public void testCorrectPixelsDecoded() throws IOException {, +    byte[] data = TestUtil.resourceToBytes(getClass(), "white_black_row.gif");, +    GifHeaderParser headerParser = new GifHeaderParser();, +    headerParser.setData(data);, +    GifHeader header = headerParser.parseHeader();, +    GifDecoder decoder = new StandardGifDecoder(provider);, +    decoder.setData(header, data);, +    decoder.advance();, +    Bitmap bitmap = decoder.getNextFrame();, +    assertNotNull(bitmap);, +    assertEquals(bitmap.getPixel(2, 0), bitmap.getPixel(0, 0));, +    assertEquals(bitmap.getPixel(3, 0), bitmap.getPixel(1, 0));, +  }, +, +  @Test, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java, +          mainPixels[pi] = suffix[code];, +          ++pi;, +          ++i;, +++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java, +  public void testCorrectPixelsDecoded() throws IOException {, +    byte[] data = TestUtil.resourceToBytes(getClass(), "white_black_row.gif");, +    GifHeaderParser headerParser = new GifHeaderParser();, +    headerParser.setData(data);, +    GifHeader header = headerParser.parseHeader();, +    GifDecoder decoder = new StandardGifDecoder(provider);, +    decoder.setData(header, data);, +    decoder.advance();, +    Bitmap bitmap = decoder.getNextFrame();, +    assertNotNull(bitmap);, +    assertEquals(bitmap.getPixel(2, 0), bitmap.getPixel(0, 0));, +    assertEquals(bitmap.getPixel(3, 0), bitmap.getPixel(1, 0));, +  }, +, +  @Test, +++ b/third_party/gif_decoder/src/test/resources/white_black_row.gif]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +import javax.lang.model.type.DeclaredType;, +        validateExtensionConstructor(element);, +      } else if (element.getKind() == ElementKind.METHOD) {, +        ExecutableElement executableElement = (ExecutableElement) element;, +        if (executableElement.getAnnotation(GlideOption.class) != null) {, +          validateGlideOption(executableElement);, +        } else if (executableElement.getAnnotation(GlideType.class) != null) {, +          validateGlideType(executableElement);, +        }, +      }, +    }, +  }, +, +  private static void validateExtensionConstructor(Element element) {, +    if (returnsVoid(executableElement)) {, +  private void validateGlideType(ExecutableElement executableElement) {, +    if (returnsVoid(executableElement)) {, +      validateDeprecatedGlideType(executableElement);, +    } else {, +      validateNewGlideType(executableElement);, +    }, +  }, +  private void validateNewGlideType(ExecutableElement executableElement) {, +    TypeMirror returnType = executableElement.getReturnType();, +    if (!isRequestBuilder(returnType) || !typeMatchesExpected(returnType, executableElement)) {, +      String expectedClassName = getGlideTypeValue(executableElement);, +      throw new IllegalArgumentException("@GlideType methods should return a RequestBuilder<", +          + expectedClassName + "> object, but given: " + returnType + ". If you're", +          + " using old style @GlideType methods, your method may have a void return type, but", +          + " doing so is deprecated and support will be removed in a future version");, +    }, +    validateGlideTypeParameters(executableElement);, +  }, +, +  private String getGlideTypeValue(ExecutableElement executableElement) {, +    return, +        processorUtil, +            .findClassValuesFromAnnotationOnClassAsNames(, +                executableElement, GlideType.class).iterator().next();, +  }, +, +  private boolean typeMatchesExpected(, +      TypeMirror returnType, ExecutableElement executableElement) {, +    if (!(returnType instanceof DeclaredType)) {, +      return false;, +    }, +    List<? extends TypeMirror> typeArguments = ((DeclaredType) returnType).getTypeArguments();, +    if (typeArguments.size() != 1) {, +      return false;, +    }, +    TypeMirror argument = typeArguments.get(0);, +    String expected = getGlideTypeValue(executableElement);, +    if (!argument.toString().equals(expected)) {, +      return false;, +    }, +    return true;, +  }, +, +  private boolean isRequestBuilder(TypeMirror typeMirror) {, +    TypeMirror toCompare = processingEnvironment.getTypeUtils().erasure(typeMirror);, +    return toCompare.toString().equals("com.bumptech.glide.RequestBuilder");, +  }, +, +  private static void validateDeprecatedGlideType(ExecutableElement executableElement) {, +    validateGlideTypeParameters(executableElement);, +  }, +, +  private static void validateGlideTypeParameters(ExecutableElement executableElement) {, +  private static boolean returnsVoid(ExecutableElement executableElement) {, +    if (!returnsVoid(executableElement)) {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +import javax.lang.model.type.DeclaredType;, +        validateExtensionConstructor(element);, +      } else if (element.getKind() == ElementKind.METHOD) {, +        ExecutableElement executableElement = (ExecutableElement) element;, +        if (executableElement.getAnnotation(GlideOption.class) != null) {, +          validateGlideOption(executableElement);, +        } else if (executableElement.getAnnotation(GlideType.class) != null) {, +          validateGlideType(executableElement);, +        }, +      }, +    }, +  }, +, +  private static void validateExtensionConstructor(Element element) {, +    if (returnsVoid(executableElement)) {, +  private void validateGlideType(ExecutableElement executableElement) {, +    if (returnsVoid(executableElement)) {, +      validateDeprecatedGlideType(executableElement);, +    } else {, +      validateNewGlideType(executableElement);, +    }, +  }, +  private void validateNewGlideType(ExecutableElement executableElement) {, +    TypeMirror returnType = executableElement.getReturnType();, +    if (!isRequestBuilder(returnType) || !typeMatchesExpected(returnType, executableElement)) {, +      String expectedClassName = getGlideTypeValue(executableElement);, +      throw new IllegalArgumentException("@GlideType methods should return a RequestBuilder<", +          + expectedClassName + "> object, but given: " + returnType + ". If you're"]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java, +@SuppressWarnings("PMD.UseVarargs"), +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java, +@SuppressWarnings("PMD.UseVarargs"), +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java, +@SuppressWarnings("PMD.UseVarargs"), +  public int getArrayLength(int[] array) {]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +import com.bumptech.glide.util.pool.GlideTrace;, +  private Object model;, +    this.model = model;, +    model = null;, +    GlideTrace.beginSectionFormat("DecodeJob#run(model=%s)", model);, +      GlideTrace.endSection();, +      GlideTrace.beginSection("DecodeJob.decodeFromRetrievedData");, +        GlideTrace.endSection();, +      GlideTrace.beginSection("DecodeJob.encode");, +        GlideTrace.endSection();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +import com.bumptech.glide.util.pool.GlideTrace;, +  private Object model;, +    this.model = model;, +    model = null;, +    GlideTrace.beginSectionFormat("DecodeJob#run(model=%s)", model);, +      GlideTrace.endSection();, +      GlideTrace.beginSection("DecodeJob.decodeFromRetrievedData");, +        GlideTrace.endSection();, +      GlideTrace.beginSection("DecodeJob.encode");, +        GlideTrace.endSection();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +import com.bumptech.glide.util.pool.GlideTrace;, +    GlideTrace., +        beginSectionFormat("encode: [%dx%d] %s", bitmap.getWidth(), bitmap.getHeight(), format);, +      GlideTrace.endSection();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +import com.bumptech.glide.util.pool.GlideTrace;, +  private Object model;, +    this.model = model;, +    model = null;, +    GlideTrace.beginSectionFormat("DecodeJob#run(model=%s)", model);, +      GlideTrace.endSection();, +      GlideTrace.beginSection("DecodeJob.decodeFromRetrievedData");, +        GlideTrace.endSection();, +      GlideTrace.beginSection("DecodeJob.encode");, +        GlideTrace.endSection();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +import com.bumptech.glide.util.pool.GlideTrace;, +    GlideTrace., +        beginSectionFormat("encode: [%dx%d] %s", bitmap.getWidth(), bitmap.getHeight(), format);, +      GlideTrace.endSection();, +++ b/library/src/main/java/com/bumptech/glide/util/pool/GlideTrace.java, +package com.bumptech.glide.util.pool;, +, +import android.support.v4.os.TraceCompat;, +, +/**, + * Systracing utilities for Glide., + */, +public final class GlideTrace {, +, +  // Enable this locally to see tracing statements., +  private static final boolean TRACING_ENABLED = false;, +, +  /** Maximum length of a systrace tag. */, +  private static final int MAX_LENGTH = 127;, +, +  private static String truncateTag(String tag) {, +    if (tag.length() > MAX_LENGTH) {, +      return tag.substring(0, MAX_LENGTH - 1);, +    }, +    return tag;, +  }, +, +  public static void beginSection(String tag) {, +    if (TRACING_ENABLED) {, +      TraceCompat.beginSection(truncateTag(tag));, +    }, +  }, +, +  public static void beginSectionFormat(String format, Object arg1) {, +    if (TRACING_ENABLED) {, +      TraceCompat.beginSection(truncateTag(String.format(format, arg1)));, +    }, +  }, +, +  public static void beginSectionFormat(String format, Object arg1, Object arg2) {, +    if (TRACING_ENABLED) {, +      TraceCompat.beginSection(truncateTag(String.format(format, arg1, arg2)));, +    }, +  }, +, +  public static void beginSectionFormat(String format, Object arg1, Object arg2, Object arg3) {, +    if (TRACING_ENABLED) {, +      TraceCompat.beginSection(truncateTag(String.format(format, arg1, arg2, arg3)));, +    }, +  }, +, +  public static void endSection() {, +    if (TRACING_ENABLED) {, +      TraceCompat.endSection();, +    }, +  }, +}]
[+++ b/gradle.properties, +ANDROID_GRADLE_VERSION=3.0.1]
[+++ b/library/src/main/java/com/bumptech/glide/load/Option.java, +    public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {, +  private final T defaultValue;, +  private final CacheKeyUpdater<T> cacheKeyUpdater;, +  private final String key;, +  private volatile byte[] keyBytes;, +, +    cacheKeyUpdater.update(getKeyBytes(), value, messageDigest);, +  }, +, +  private byte[] getKeyBytes() {, +    if (keyBytes == null) {, +      keyBytes = key.getBytes(Key.CHARSET);, +    }, +    return keyBytes;, +    void update(byte[] keyBytes, T value, MessageDigest messageDigest);, +++ b/library/src/main/java/com/bumptech/glide/load/Option.java, +    public void update(byte[] keyBytes, Object value, MessageDigest messageDigest) {, +  private final T defaultValue;, +  private final CacheKeyUpdater<T> cacheKeyUpdater;, +  private final String key;, +  private volatile byte[] keyBytes;, +, +    cacheKeyUpdater.update(getKeyBytes(), value, messageDigest);, +  }, +, +  private byte[] getKeyBytes() {, +    if (keyBytes == null) {, +      keyBytes = key.getBytes(Key.CHARSET);, +    }, +    return keyBytes;, +    void update(byte[] keyBytes, T value, MessageDigest messageDigest);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java, +        public void update(byte[] keyBytes, Long value, MessageDigest messageDigest) {, +          messageDigest.update(keyBytes);]
[+++ b/src/com/bumptech/photos/imagemanager/ImageManager.java, +/*, + * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved., + */, +, +package com.bumptech.photos.imagemanager;, +, +import android.graphics.Bitmap;, +import android.os.Build;, +import android.os.Handler;, +import android.os.SystemClock;, +import com.bumptech.photos.cache.LruPhotoCache;, +import com.bumptech.photos.cache.PhotoDiskCache;, +import com.bumptech.photos.cache.SizedBitmapCache;, +import com.bumptech.photos.resize.ResizeJobGenerator;, +, +import java.io.File;, +import java.io.InputStream;, +import java.util.HashMap;, +import java.util.Map;, +, +/**, + * Created by IntelliJ IDEA., + * User: sam, + * Date: 2/9/12, + * Time: 5:02 PM, + * To change this template use File | Settings | File Templates., + */, +public class ImageManager {, +    public static final boolean CAN_RECYCLE = Build.VERSION.SDK_INT >= 11;, +, +    private PhotoDiskCache diskCache;, +    private LruPhotoCache memoryCache;, +    private ResizeJobGenerator resizer;, +    private Handler backgroundHandler;, +    private Map<Integer, Integer> bitmapReferenceCounter = new HashMap<Integer, Integer>();, +    private SizedBitmapCache bitmapCache = new SizedBitmapCache();, +, +    private enum ResizeType {, +        CENTER_CROP,, +        FIT_CENTER,, +        APPROXIMATE,, +        AS_IS, +    }, +, +    public ImageManager(int maxMemCacheSize, long maxDiskCacheSize, File diskCacheDir, Handler mainHandler, Handler backgroundHandler) {, +        this.backgroundHandler = backgroundHandler;, +        this.memoryCache = new LruPhotoCache(maxMemCacheSize);, +        memoryCache.setPhotoRemovedListener(new LruPhotoCache.PhotoRemovedListener() {, +            @Override, +            public void onPhotoRemoved(String key, Bitmap bitmap) {, +                releaseBitmap(bitmap);, +            }, +        });, +        this.diskCache = new PhotoDiskCache(diskCacheDir, maxDiskCacheSize, mainHandler, backgroundHandler);, +        this.resizer = new ResizeJobGenerator(mainHandler, CAN_RECYCLE ? bitmapCache : null);, +    }, +, +    /**, +     * Loads the image for the given id, +     * @param path - the path id to the image, +     * @param cb - the callback called when the load completes, +     * @return A token tracking this request, +     */, +    public Object getImage(final String path, final LoadedCallback cb){, +        final Object token = cb;, +        final String key = getKey(path, 0, 0, ResizeType.AS_IS);, +        if (!returnFromCache(key, cb)) {, +            final Runnable task = resizer.loadAsIs(path, getResizeCb(key, token, cb, false, false));, +            postJob(task, token);, +        }, +        return token;, +    }, +, +    /**, +     * Loads the image for the given id assuming its width and height are exactly those given, +     * @param path - the path to the image, +     * @param width - the width of the image on disk, +     * @param height - the height of the image on disk, +     * @param cb - the callback called when the load completes, +     * @return A token tracking this request, +     */, +    public Object getImageExact(final String path, int width, int height, final LoadedCallback cb) {, +        final Object token = cb;, +        final String key = getKey(path, width, height, ResizeType.AS_IS);, +        if (!returnFromCache(key, cb)) {, +            final Runnable task = resizer.loadAsIs(path, width, height, getResizeCb(key, token, cb, false, false));, +            postJob(task, token);, +        }, +        return token;, +    }, +, +    /**, +     * Loads the image for the given id to nearly the given width and height maintaining the original proportions, +     * @param path - the id of the image, +     * @param width - the desired width in pixels, +     * @param height - the desired height of the slice, +     * @param cb - the callback called when the task finishes, +     * @return A token tracking this request, +     */]
[+++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +, +    @Override, +    public BitmapRequestBuilder<ModelType, TranscodeType> skipMemoryCache(boolean skip) {, +        super.skipMemoryCache(skip);, +        return this;, +    }, +, +    @Override, +    public BitmapRequestBuilder<ModelType, TranscodeType> skipDiskCache(boolean skip) {, +        super.skipDiskCache(skip);, +        return this;, +    }, +, +    @Override, +    public BitmapRequestBuilder<ModelType, TranscodeType> skipCache(boolean skip) {, +        super.skipCache(skip);, +        return this;, +    }, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +, +    @Override, +    public BitmapRequestBuilder<ModelType, TranscodeType> skipMemoryCache(boolean skip) {, +        super.skipMemoryCache(skip);, +        return this;, +    }, +, +    @Override, +    public BitmapRequestBuilder<ModelType, TranscodeType> skipDiskCache(boolean skip) {, +        super.skipDiskCache(skip);, +        return this;, +    }, +, +    @Override, +    public BitmapRequestBuilder<ModelType, TranscodeType> skipCache(boolean skip) {, +        super.skipCache(skip);, +        return this;, +    }, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +import com.bumptech.glide.load.SkipCache;, +    private boolean isCacheable = true;, +    private ResourceEncoder<ResourceType> preSkipEncoder;, +        preSkipEncoder = loadProvider != null ? loadProvider.getEncoder() : null;, +        preSkipEncoder = encoder;, +     * @param requestListener The request listener to use., +     * @return This RequestBuilder., +     * Allows the loaded resource to skip the memory cache., +     *, +     * <p>, +     *     Note - this is not a guarantee. If a request is already pending for this resource and that request is not, +     *     also skipping the memory cache, the resource will be cached in memory., +     * </p>, +     *, +     * @param skip True to allow the resource to skip the memory cache., +     * @return This RequestBuilder., +     */, +    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> skipMemoryCache(boolean skip) {, +        this.isCacheable = !skip;, +, +        return this;, +    }, +, +    /**, +     * Allows the loaded resource to skip the disk cache., +     *, +     * <p>, +     *     Note - this is not a guarantee. If a request is already pending for this resource and that request is not, +     *     also skipping the disk cache, the resource will be cached on disk., +     * </p>, +     *, +     * @param skip True to allow the resource to skip the disk cache., +     * @return This RequestBuilder., +     */, +    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> skipDiskCache(boolean skip) {, +        if (skip) {, +            preSkipEncoder = loadProvider.getEncoder();, +            final SkipCache<ResourceType> skipCache = SkipCache.get();, +            return encoder(skipCache);, +        } else {, +            return encoder(preSkipEncoder);, +        }, +    }, +, +    /**, +     * Allows the resource to skip both the memory and the disk cache., +     *, +     * @see #skipDiskCache(boolean), +     * @see #skipMemoryCache(boolean), +     *, +     * @param skip True to allow the resource to skip both the memory and the disk cache., +     * @return This RequestBuilder., +     */, +    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> skipCache(boolean skip) {, +        skipMemoryCache(skip);, +        skipDiskCache(skip);, +, +        return this;, +    }, +, +    /**]
[+++ b/gradle.properties, +org.gradle.daemon=true, +org.gradle.configureondemand=true, +org.gradle.parallel=true, +, +TRUTH_VERSION=0.26, +++ b/gradle.properties, +org.gradle.daemon=true, +org.gradle.configureondemand=true, +org.gradle.parallel=true, +, +TRUTH_VERSION=0.26, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import static org.junit.Assume.assumeTrue;, +    // Most likely an instance of http://stackoverflow.com/q/991489/253468, +    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));, +    // Most likely an instance of http://stackoverflow.com/q/991489/253468, +    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));, +++ b/gradle.properties, +org.gradle.daemon=true, +org.gradle.configureondemand=true, +org.gradle.parallel=true, +, +TRUTH_VERSION=0.26, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import static org.junit.Assume.assumeTrue;, +    // Most likely an instance of http://stackoverflow.com/q/991489/253468, +    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));, +    // Most likely an instance of http://stackoverflow.com/q/991489/253468, +    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));, +++ b/integration/volley/build.gradle, +    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}", +++ b/gradle.properties, +org.gradle.daemon=true, +org.gradle.configureondemand=true, +org.gradle.parallel=true, +, +TRUTH_VERSION=0.26, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import static org.junit.Assume.assumeTrue;, +    // Most likely an instance of http://stackoverflow.com/q/991489/253468, +    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));, +    // Most likely an instance of http://stackoverflow.com/q/991489/253468, +    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));, +++ b/integration/volley/build.gradle, +    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}", +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +    return getFetcher(Headers.DEFAULT);, +++ b/gradle.properties, +org.gradle.daemon=true, +org.gradle.configureondemand=true, +org.gradle.parallel=true, +, +TRUTH_VERSION=0.26, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import static org.junit.Assume.assumeTrue;, +    // Most likely an instance of http://stackoverflow.com/q/991489/253468, +    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));, +    // Most likely an instance of http://stackoverflow.com/q/991489/253468, +    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));, +++ b/integration/volley/build.gradle, +    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}", +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +    return getFetcher(Headers.DEFAULT);, +++ b/library/build.gradle, +    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}", +++ b/gradle.properties, +org.gradle.daemon=true, +org.gradle.configureondemand=true, +org.gradle.parallel=true, +, +TRUTH_VERSION=0.26, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import static org.junit.Assume.assumeTrue;, +    // Most likely an instance of http://stackoverflow.com/q/991489/253468, +    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));, +    // Most likely an instance of http://stackoverflow.com/q/991489/253468, +    assumeTrue(!System.getProperty("os.name").startsWith("Windows"));, +++ b/integration/volley/build.gradle, +    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}", +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +    return getFetcher(Headers.DEFAULT);, +++ b/library/build.gradle, +    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}", +++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java, +   * @param isFirstResource {@code true} if this exception is for the first resource to load., +   * @return {@code true} if the listener has handled updating the target for the given exception,, +   *         {@code false} to allow Glide's request to update the target., +   * @param isFirstResource   {@code true} if this is the first resource to in this load to be, +   *                          loaded into the target. For example when loading a thumbnail and a, +   *                          full-sized image, this will be {@code true} for the first image to, +   *                          load and {@code false} for the second., +   * @return {@code true} if the listener has handled setting the resource on the target,, +   *         {@code false} to allow Glide's request to update the target., +   *         Setting the resource includes handling animations, be sure to take that into account., +++ b/gradle.properties, +org.gradle.daemon=true, +org.gradle.configureondemand=true, +org.gradle.parallel=true, +]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java, +package com.bumptech.glide;, +, +import android.content.Context;, +import android.graphics.drawable.Drawable;, +import android.support.test.InstrumentationRegistry;, +import android.support.test.runner.AndroidJUnit4;, +import android.widget.ImageView;, +import com.bumptech.glide.manager.Lifecycle;, +import com.bumptech.glide.manager.LifecycleListener;, +import com.bumptech.glide.manager.RequestManagerTreeNode;, +import com.bumptech.glide.request.FutureTarget;, +import com.bumptech.glide.test.ConcurrencyHelper;, +import com.bumptech.glide.test.ResourceIds;, +import com.bumptech.glide.test.ResourceIds.raw;, +import com.bumptech.glide.test.TearDownGlide;, +import org.junit.Before;, +import org.junit.Rule;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +, +@RunWith(AndroidJUnit4.class), +public class RequestManagerTest {, +  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();, +  @Mock private RequestManagerTreeNode treeNode;, +, +  private ConcurrencyHelper concurrency = new ConcurrencyHelper();, +  private RequestManager requestManager;, +  private Context context;, +, +  @Before, +  public void setUp() {, +    MockitoAnnotations.initMocks(this);, +    context = InstrumentationRegistry.getTargetContext();, +    Glide glide = Glide.get(context);, +    requestManager = new RequestManager(glide, new Lifecycle() {, +      @Override, +      public void addListener(LifecycleListener listener) {, +        listener.onStart();, +      }, +, +      @Override, +      public void removeListener(LifecycleListener listener) {, +        // Do nothing., +      }, +    }, treeNode, context);, +  }, +, +  /**, +   * Tests #2262., +   */, +  @Test, +  public void clear_withNonOwningRequestManager_afterOwningManagerIsDestroyed_doesNotThrow() {, +    // First destroy our Fragment/Activity RequestManager., +    requestManager.onDestroy();, +, +    final ImageView imageView = new ImageView(context);, +    imageView.measure(100, 100);, +    imageView.layout(0, 0, 100, 100);, +    // Then start a new load with our now destroyed RequestManager., +    concurrency.loadOnMainThread(requestManager.load(ResourceIds.raw.canonical), imageView);, +, +    // Finally clear our new load with any RequestManager other than the one we used to start it., +    concurrency.runOnMainThread(new Runnable() {, +      @Override, +      public void run() {, +        Glide.with(context).clear(imageView);, +      }, +    });, +  }, +, +  /**, +   * Tests b/69361054., +   */, +  @Test, +  public void clear_withNonOwningRequestManager_onBackgroundTHread_doesNotThrow() {, +    concurrency.runOnMainThread(new Runnable() {, +      @Override, +      public void run() {, +        requestManager.onDestroy();, +      }, +    });, +, +    final FutureTarget<Drawable> target =, +        concurrency.wait(requestManager.load(raw.canonical).submit());, +, +    concurrency.runOnMainThread(new Runnable() {, +      @Override, +      public void run() {, +        Glide.with(context).clear(target);, +      }, +    });, +  }, +}, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java, +package com.bumptech.glide;, +, +import android.content.Context;]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, +            .addParameter(ClassName.get("com.bumptech.glide", "Glide"), "glide"), +          "new $T().registerComponents(context, glide, registry)", moduleClassName);, +    registerComponents.addStatement("appGlideModule.registerComponents(context, glide, registry)");, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, +            .addParameter(ClassName.get("com.bumptech.glide", "Glide"), "glide"), +          "new $T().registerComponents(context, glide, registry)", moduleClassName);, +    registerComponents.addStatement("appGlideModule.registerComponents(context, glide, registry)");, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +import com.bumptech.glide.Glide;, +  public void registerComponents(Context context, Glide glide, Registry registry) {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, +            .addParameter(ClassName.get("com.bumptech.glide", "Glide"), "glide"), +          "new $T().registerComponents(context, glide, registry)", moduleClassName);, +    registerComponents.addStatement("appGlideModule.registerComponents(context, glide, registry)");, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +import com.bumptech.glide.Glide;, +  public void registerComponents(Context context, Glide glide, Registry registry) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java, +import com.bumptech.glide.Glide;, +  public void registerComponents(Context context, Glide glide, Registry registry) {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, +            .addParameter(ClassName.get("com.bumptech.glide", "Glide"), "glide"), +          "new $T().registerComponents(context, glide, registry)", moduleClassName);, +    registerComponents.addStatement("appGlideModule.registerComponents(context, glide, registry)");, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +import com.bumptech.glide.Glide;, +  public void registerComponents(Context context, Glide glide, Registry registry) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java, +import com.bumptech.glide.Glide;, +  public void registerComponents(Context context, Glide glide, Registry registry) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java, +import com.bumptech.glide.Glide;, +  public void registerComponents(Context context, Glide glide, Registry registry) {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, +            .addParameter(ClassName.get("com.bumptech.glide", "Glide"), "glide"), +          "new $T().registerComponents(context, glide, registry)", moduleClassName);, +    registerComponents.addStatement("appGlideModule.registerComponents(context, glide, registry)");, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +import com.bumptech.glide.Glide;, +  public void registerComponents(Context context, Glide glide, Registry registry) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java, +import com.bumptech.glide.Glide;, +  public void registerComponents(Context context, Glide glide, Registry registry) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java, +import com.bumptech.glide.Glide;, +  public void registerComponents(Context context, Glide glide, Registry registry) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java, +import com.bumptech.glide.Glide;, +  public void registerComponents(Context context, Glide glide, Registry registry) {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, +            .addParameter(ClassName.get("com.bumptech.glide", "Glide"), "glide"), +          "new $T().registerComponents(context, glide, registry)", moduleClassName);, +    registerComponents.addStatement("appGlideModule.registerComponents(context, glide, registry)");, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +import com.bumptech.glide.Glide;, +  public void registerComponents(Context context, Glide glide, Registry registry) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java, +import com.bumptech.glide.Glide;, +  public void registerComponents(Context context, Glide glide, Registry registry) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java, +import com.bumptech.glide.Glide;, +  public void registerComponents(Context context, Glide glide, Registry registry) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java, +import com.bumptech.glide.Glide;, +  public void registerComponents(Context context, Glide glide, Registry registry) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java, +import com.bumptech.glide.Glide;, +  public void registerComponents(Context context, Glide glide, Registry registry) {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, +            .addParameter(ClassName.get("com.bumptech.glide", "Glide"), "glide"), +          "new $T().registerComponents(context, glide, registry)", moduleClassName);, +    registerComponents.addStatement("appGlideModule.registerComponents(context, glide, registry)");, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +import com.bumptech.glide.Glide;, +  public void registerComponents(Context context, Glide glide, Registry registry) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java, +import com.bumptech.glide.Glide;, +  public void registerComponents(Context context, Glide glide, Registry registry) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java, +import com.bumptech.glide.Glide;, +  public void registerComponents(Context context, Glide glide, Registry registry) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java, +import com.bumptech.glide.Glide;, +  public void registerComponents(Context context, Glide glide, Registry registry) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java, +import com.bumptech.glide.Glide;, +  public void registerComponents(Context context, Glide glide, Registry registry) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java, +import com.bumptech.glide.Glide;, +  public void registerComponents(Context context, Glide glide, Registry registry) {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, +            .addParameter(ClassName.get("com.bumptech.glide", "Glide"), "glide"), +          "new $T().registerComponents(context, glide, registry)", moduleClassName);, +    registerComponents.addStatement("appGlideModule.registerComponents(context, glide, registry)");, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +import com.bumptech.glide.Glide;, +  public void registerComponents(Context context, Glide glide, Registry registry) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java, +import com.bumptech.glide.Glide;]
[+++ b/library/AndroidManifest.xml, +          android:versionCode="2", +          android:versionName="2.0.0">]
[+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java, +    Glide.with(this).load(photo).apply(fitCenterTransform()).into(fullscreenView);, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FullscreenActivity.java, +    Glide.with(this).load(photo).apply(fitCenterTransform()).into(fullscreenView);, +++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java, +import com.bumptech.glide.request.RequestOptions;, +    requestBuilder = requestManager.asDrawable().apply(RequestOptions.fitCenterTransform());]
[+++ b/samples/svg/src/main/res/drawable/image_loading.xml, +            android:src="@mipmap/ic_launcher", +++ b/samples/svg/src/main/res/drawable/image_loading.xml, +            android:src="@mipmap/ic_launcher", +++ b/samples/svg/src/main/res/mipmap-hdpi/ic_launcher.png, +++ b/samples/svg/src/main/res/drawable/image_loading.xml, +            android:src="@mipmap/ic_launcher", +++ b/samples/svg/src/main/res/mipmap-hdpi/ic_launcher.png, +++ b/samples/svg/src/main/res/mipmap-mdpi/ic_launcher.png, +++ b/samples/svg/src/main/res/drawable/image_loading.xml, +            android:src="@mipmap/ic_launcher", +++ b/samples/svg/src/main/res/mipmap-hdpi/ic_launcher.png, +++ b/samples/svg/src/main/res/mipmap-mdpi/ic_launcher.png, +++ b/samples/svg/src/main/res/mipmap-xhdpi/ic_launcher.png, +++ b/samples/svg/src/main/res/drawable/image_loading.xml, +            android:src="@mipmap/ic_launcher", +++ b/samples/svg/src/main/res/mipmap-hdpi/ic_launcher.png, +++ b/samples/svg/src/main/res/mipmap-mdpi/ic_launcher.png, +++ b/samples/svg/src/main/res/mipmap-xhdpi/ic_launcher.png, +++ b/samples/svg/src/main/res/mipmap-xxhdpi/ic_launcher.png, +++ b/samples/svg/src/main/res/drawable/image_loading.xml, +            android:src="@mipmap/ic_launcher", +++ b/samples/svg/src/main/res/mipmap-hdpi/ic_launcher.png, +++ b/samples/svg/src/main/res/mipmap-mdpi/ic_launcher.png, +++ b/samples/svg/src/main/res/mipmap-xhdpi/ic_launcher.png, +++ b/samples/svg/src/main/res/mipmap-xxhdpi/ic_launcher.png, +++ b/samples/svg/src/main/res/mipmap-xxxhdpi/ic_launcher.png]
[+++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java]
[+++ b/.travis.yml, +sudo: false, +]
[+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +      sourceExecutor = new GlideExecutor("source");, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +      sourceExecutor = new GlideExecutor("source");, +++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java, +import android.support.annotation.NonNull;, +import java.io.File;, +import java.io.FilenameFilter;, +import java.util.regex.Pattern;, +, +  private static final String CPU_NAME_REGEX = "cpu[0-9]+";, +  private static final String CPU_LOCATION = "/sys/devices/system/cpu/";, +  // Don't use more than four threads when automatically determining thread count.., +  private static final int MAXIMUM_AUTOMATIC_THREAD_COUNT = 4;, +, +  /**, +   * Constructor to build a fixed thread pool with an automatically determined number of threads., +   *, +   * @see #calculateBestThreadCount(), +   */, +  public GlideExecutor() {, +    this(calculateBestThreadCount());, +  }, +   * Constructor to build a fixed thread pool with the given name and an automatically determined, +   * number of threads., +   *, +   * @see #calculateBestThreadCount(), +   */, +  public GlideExecutor(String name) {, +    this(calculateBestThreadCount(), new DefaultThreadFactory(name));, +  }, +, +  /**, +    super(, +        corePoolSize /*corePoolSize*/,, +        corePoolSize /*maximumPoolSize*/,, +        0 /*keepAliveTime*/,, +        TimeUnit.MILLISECONDS,, +        new PriorityBlockingQueue<Runnable>(),, +        threadFactory);, +   * Determines the number of cores available on the device., +   *, +   * <p>{@link Runtime#availableProcessors()} returns the number of awake cores, which may not, +   * be the number of available cores depending on the device's current state. See, +   * http://goo.gl/8H670N., +   */, +  public static int calculateBestThreadCount() {, +    File cpuInfo = new File(CPU_LOCATION);, +    final Pattern cpuNamePattern = Pattern.compile(CPU_NAME_REGEX);, +    File[] cpus = cpuInfo.listFiles(new FilenameFilter() {, +      @Override, +      public boolean accept(File file, String s) {, +        return cpuNamePattern.matcher(s).matches();, +      }, +    });, +, +    int cpuCount = cpus != null ? cpus.length : 0;, +    int availableProcessors = Math.max(1, Runtime.getRuntime().availableProcessors());, +    return Math.min(MAXIMUM_AUTOMATIC_THREAD_COUNT, Math.max(availableProcessors, cpuCount));, +  }, +, +  /**, +   * A strategy for handling unexpected and uncaught {@link Throwable}s thrown by futures run on the, +   * pool., +     * Silently catches and ignores the uncaught {@link Throwable}s., +     * Logs the uncaught {@link Throwable}s using {@link #TAG} and {@link Log}., +     * Rethrows the uncaught {@link Throwable}s to crash the app., +    public Thread newThread(@NonNull Runnable runnable) {, +      synchronized (this) {, +      }]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java, +   * A long indicating the time position (in microseconds) of the target frame which will be, +   * retrieved. {@link android.media.MediaMetadataRetriever#getFrameAtTime(long)} is used to, +   * extract the video frame., +   *, +   * <p>When retrieving the frame at the given time position, there is no guarantee that the data, +   * source has a frame located at the position. When this happens, a frame nearby will be returned., +   * If the long is negative, time position and option will ignored, and any frame that the, +   * implementation considers as representative may be returned., +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java, +   * A long indicating the time position (in microseconds) of the target frame which will be, +   * retrieved. {@link android.media.MediaMetadataRetriever#getFrameAtTime(long)} is used to, +   * extract the video frame., +   *, +   * <p>When retrieving the frame at the given time position, there is no guarantee that the data, +   * source has a frame located at the position. When this happens, a frame nearby will be returned., +   * If the long is negative, time position and option will ignored, and any frame that the, +   * implementation considers as representative may be returned., +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +  /**, +   * Sets the time position of the frame to extract from a video., +   * @param frame The time position in microseconds of the desired frame. If negative, the Android, +   *     framework implementation return a representative frame., +   */]
[+++ b/samples/imgur/src/main/res/layout/image_card.xml, +  <androidx.cardview.widget.CardView, +  </androidx.cardview.widget.CardView>]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java, +import com.bumptech.glide.request.target.Target;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +    @Mock, +        MockitoAnnotations.initMocks(this);, +        Resource<Bitmap> resource = mockResource(100, 100);, +        Resource<Bitmap> resource = mockResource(1, 2);, +        final Resource<Bitmap> resource = mockResource(223, 4123);, +                assertEquals(resource.get(), toTransform);, +                return resource.get();, +, +        Resource<Bitmap> resource = mockResource(100, 100);, +, +    @Test, +    public void testCallsTransformWithGivenBitmapWidthIfWidthIsSizeOriginal() {, +        SizeTrackingTransform transform = new SizeTrackingTransform();, +, +        int expectedWidth = 200;, +        Resource<Bitmap> resource = mockResource(expectedWidth, 300);, +        transform.transform(resource, Target.SIZE_ORIGINAL, 500);, +, +        assertEquals(expectedWidth, transform.givenWidth);, +    }, +, +    @Test, +    public void testCallsTransformWithGivenBitmapHeightIfHeightIsSizeOriginal() {, +        SizeTrackingTransform transform = new SizeTrackingTransform();, +, +        int expectedHeight = 500;, +        Resource<Bitmap> resource = mockResource(123, expectedHeight);, +        transform.transform(resource, 444, expectedHeight);, +, +        assertEquals(expectedHeight, transform.givenHeight);, +    }, +, +    @SuppressWarnings("unchecked"), +    private Resource<Bitmap> mockResource(int width, int height) {, +        Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);, +        Resource<Bitmap> resource = mock(Resource.class);, +        when(resource.get()).thenReturn(bitmap);, +        return resource;, +    }, +, +    private class SizeTrackingTransform extends BitmapTransformation {, +        int givenWidth;, +        int givenHeight;, +, +        public SizeTrackingTransform() {, +            super(bitmapPool);, +        }, +, +        @Override, +        protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {, +            givenWidth = outWidth;, +            givenHeight = outHeight;, +            return null;, +        }, +, +        @Override, +        public String getId() {, +            return null;, +        }, +    }, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java, +import com.bumptech.glide.request.target.Target;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +    @Mock, +        MockitoAnnotations.initMocks(this);, +        Resource<Bitmap> resource = mockResource(100, 100);, +        Resource<Bitmap> resource = mockResource(1, 2);, +        final Resource<Bitmap> resource = mockResource(223, 4123);, +                assertEquals(resource.get(), toTransform);, +                return resource.get();, +, +        Resource<Bitmap> resource = mockResource(100, 100);, +, +    @Test, +    public void testCallsTransformWithGivenBitmapWidthIfWidthIsSizeOriginal() {, +        SizeTrackingTransform transform = new SizeTrackingTransform();, +, +        int expectedWidth = 200;, +        Resource<Bitmap> resource = mockResource(expectedWidth, 300);, +        transform.transform(resource, Target.SIZE_ORIGINAL, 500);, +, +        assertEquals(expectedWidth, transform.givenWidth);, +    }, +, +    @Test, +    public void testCallsTransformWithGivenBitmapHeightIfHeightIsSizeOriginal() {, +        SizeTrackingTransform transform = new SizeTrackingTransform();, +, +        int expectedHeight = 500;, +        Resource<Bitmap> resource = mockResource(123, expectedHeight);, +        transform.transform(resource, 444, expectedHeight);, +, +        assertEquals(expectedHeight, transform.givenHeight);, +    }, +]
[+++ b/samples/flickr/res/layout/grid_fragment.xml, +  android:gravity="center", +  android:stretchMode="spacingWidthUniform", +++ b/samples/flickr/res/layout/grid_fragment.xml, +  android:gravity="center", +  android:stretchMode="spacingWidthUniform", +++ b/samples/flickr/res/layout/main.xml, +      <android.support.v4.view.ViewPager, +        android:id="@+id/view_pager", +++ b/samples/flickr/res/layout/grid_fragment.xml, +  android:gravity="center", +  android:stretchMode="spacingWidthUniform", +++ b/samples/flickr/res/layout/main.xml, +      <android.support.v4.view.ViewPager, +        android:id="@+id/view_pager", +++ b/samples/flickr/src/com/bumptech/flickr/GridFragment.java, +public class GridFragment extends SherlockFragment implements PhotoViewer{, +    @Override, +    public void onPhotosUpdated(List<Photo> photos) {, +++ b/samples/flickr/res/layout/grid_fragment.xml, +  android:gravity="center", +  android:stretchMode="spacingWidthUniform", +++ b/samples/flickr/res/layout/main.xml, +      <android.support.v4.view.ViewPager, +        android:id="@+id/view_pager", +++ b/samples/flickr/src/com/bumptech/flickr/GridFragment.java, +public class GridFragment extends SherlockFragment implements PhotoViewer{, +    @Override, +    public void onPhotosUpdated(List<Photo> photos) {, +++ b/samples/flickr/src/com/bumptech/flickr/MyActivity.java, +import android.support.v4.app.Fragment;, +import android.support.v4.app.FragmentManager;, +import android.support.v4.app.FragmentPagerAdapter;, +import android.support.v4.view.ViewPager;, +import android.view.ViewGroup;, +, +    private List<PhotoViewer> photoViewers = new ArrayList<PhotoViewer>();, +, +                        for (PhotoViewer viewer : photoViewers) {, +                            viewer.onPhotosUpdated(photos);, +                        }, +        ViewPager pager = (ViewPager) findViewById(R.id.view_pager);, +, +        final List<Fragment> fragments = new ArrayList<Fragment>();, +, +        fragments.add(small);, +        photoViewers.add(small);, +, +        final GridFragment medium = new GridFragment();, +        medium.setup(flickerApi,  imageManager, cacheDir, res.getDimensionPixelSize(R.dimen.medium_photo_side));, +        fragments.add(medium);, +        photoViewers.add(medium);, +, +        actionBar.addTab(actionBar.newTab().setText(R.string.small).setTabListener(new TabListener2(pager)));, +        actionBar.addTab(actionBar.newTab().setText(R.string.medium).setTabListener(new TabListener2(pager)));, +, +        pager.setAdapter(new FlickrPagerAdapter(getSupportFragmentManager(), fragments, new FlickrPagerAdapter.PrimaryItemListener() {, +            public void onPrimaryItemSet(int position) {, +                actionBar.getTabAt(position).select();, +    private static class TabListener2 implements ActionBar.TabListener {, +        private final ViewPager pager;, +        public TabListener2(ViewPager pager) {, +            this.pager = pager;, +            pager.setCurrentItem(tab.getPosition());, +        public void onTabUnselected(ActionBar.Tab tab, FragmentTransaction ft) { }, +, +        @Override, +        public void onTabReselected(ActionBar.Tab tab, FragmentTransaction ft) { }, +, +    private static class FlickrPagerAdapter extends FragmentPagerAdapter {, +        private final PrimaryItemListener listener;, +, +        private interface PrimaryItemListener {, +            public void onPrimaryItemSet(int position);, +        }, +        private final List<Fragment> fragments;, +        private int lastPosition = 0;, +, +        public FlickrPagerAdapter(FragmentManager fm, List<Fragment> fragments, PrimaryItemListener listener) {, +            super(fm);, +            this.fragments = fragments;, +            this.listener = listener;, +        public Fragment getItem(int i) {, +            return fragments.get(i);  //To change body of implemented methods use File | Settings | File Templates., +        @Override, +        public int getCount() {, +            return fragments.size();  //To change body of implemented methods use File | Settings | File Templates., +        }, +, +        @Override, +        public void setPrimaryItem(ViewGroup container, int position, Object object) {, +            if (lastPosition != position) {, +                listener.onPrimaryItemSet(position);, +                lastPosition = position;, +            }, +            super.setPrimaryItem(container, position, object);    //To change body of overridden methods use File | Settings | File Templates., +        }, +++ b/samples/flickr/res/layout/grid_fragment.xml, +  android:gravity="center", +  android:stretchMode="spacingWidthUniform"]
[+++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +import android.os.Handler;, +import android.os.Looper;, +import com.bumptech.glide.manager.Lifecycle;, +import com.bumptech.glide.manager.LifecycleListener;, +public class RequestManager implements LifecycleListener {, +    public RequestManager(Context context, Lifecycle lifecycle) {, +        this(context, lifecycle, new RequestTracker(), new ConnectivityMonitorFactory());, +    RequestManager(Context context, final Lifecycle lifecycle, RequestTracker requestTracker,, +            ConnectivityMonitorFactory factory) {, +, +        ConnectivityMonitor connectivityMonitor = factory.build(context,, +                new RequestManagerConnectivityListener(requestTracker));, +, +        // If we're the application level request manager, we may be created on a background thread. In that case we, +        // cannot risk synchronously pausing or resuming requests, so we hack around the issue by delaying adding, +        // ourselves as a lifecycle listener by posting to the main thread. This should be entirely safe., +        if (Util.isOnBackgroundThread()) {, +            new Handler(Looper.getMainLooper()).post(new Runnable() {, +                @Override, +                public void run() {, +                    lifecycle.addListener(RequestManager.this);, +                }, +            });, +        } else {, +            lifecycle.addListener(this);, +        }, +        lifecycle.addListener(connectivityMonitor);, +    @Override, +    @Override, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +import android.os.Handler;, +import android.os.Looper;, +import com.bumptech.glide.manager.Lifecycle;, +import com.bumptech.glide.manager.LifecycleListener;, +public class RequestManager implements LifecycleListener {, +    public RequestManager(Context context, Lifecycle lifecycle) {, +        this(context, lifecycle, new RequestTracker(), new ConnectivityMonitorFactory());, +    RequestManager(Context context, final Lifecycle lifecycle, RequestTracker requestTracker,, +            ConnectivityMonitorFactory factory) {, +, +        ConnectivityMonitor connectivityMonitor = factory.build(context,, +                new RequestManagerConnectivityListener(requestTracker));, +, +        // If we're the application level request manager, we may be created on a background thread. In that case we, +        // cannot risk synchronously pausing or resuming requests, so we hack around the issue by delaying adding, +        // ourselves as a lifecycle listener by posting to the main thread. This should be entirely safe., +        if (Util.isOnBackgroundThread()) {, +            new Handler(Looper.getMainLooper()).post(new Runnable() {, +                @Override, +                public void run() {, +                    lifecycle.addListener(RequestManager.this);, +                }, +            });, +        } else {, +            lifecycle.addListener(this);, +        }, +        lifecycle.addListener(connectivityMonitor);, +    @Override, +    @Override, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitor.java, +public interface ConnectivityMonitor extends LifecycleListener {, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +import android.os.Handler;, +import android.os.Looper;, +import com.bumptech.glide.manager.Lifecycle;, +import com.bumptech.glide.manager.LifecycleListener;, +public class RequestManager implements LifecycleListener {, +    public RequestManager(Context context, Lifecycle lifecycle) {, +        this(context, lifecycle, new RequestTracker(), new ConnectivityMonitorFactory());, +    RequestManager(Context context, final Lifecycle lifecycle, RequestTracker requestTracker,, +            ConnectivityMonitorFactory factory) {, +, +        ConnectivityMonitor connectivityMonitor = factory.build(context,, +                new RequestManagerConnectivityListener(requestTracker));, +, +        // If we're the application level request manager, we may be created on a background thread. In that case we, +        // cannot risk synchronously pausing or resuming requests, so we hack around the issue by delaying adding, +        // ourselves as a lifecycle listener by posting to the main thread. This should be entirely safe., +        if (Util.isOnBackgroundThread()) {, +            new Handler(Looper.getMainLooper()).post(new Runnable() {, +                @Override, +                public void run() {, +                    lifecycle.addListener(RequestManager.this);, +                }, +            });, +        } else {, +            lifecycle.addListener(this);, +        }, +        lifecycle.addListener(connectivityMonitor);, +    @Override, +    @Override, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitor.java, +public interface ConnectivityMonitor extends LifecycleListener {, +++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java, +    private void register() {, +    private void unregister() {]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java, +import android.support.annotation.NonNull;, +  protected abstract Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,, +      int outWidth, int outHeight);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java, +import android.support.annotation.NonNull;, +  protected abstract Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,, +      int outWidth, int outHeight);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java, +import android.support.annotation.NonNull;, +  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,, +      int outHeight) {, +    return TransformationUtils.centerCrop(pool, toTransform, outWidth, outHeight);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java, +import android.support.annotation.NonNull;, +  protected abstract Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,, +      int outWidth, int outHeight);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java, +import android.support.annotation.NonNull;, +  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,, +      int outHeight) {, +    return TransformationUtils.centerCrop(pool, toTransform, outWidth, outHeight);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java, +import android.support.annotation.NonNull;, +  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,, +      int outHeight) {, +    return TransformationUtils.circleCrop(pool, toTransform, outWidth, outHeight);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java, +import android.support.annotation.NonNull;, +  protected abstract Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,, +      int outWidth, int outHeight);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java, +import android.support.annotation.NonNull;, +  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,, +      int outHeight) {, +    return TransformationUtils.centerCrop(pool, toTransform, outWidth, outHeight);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java, +import android.support.annotation.NonNull;, +  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,, +      int outHeight) {, +    return TransformationUtils.circleCrop(pool, toTransform, outWidth, outHeight);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +      rotated = TransformationUtils.rotateImageExif(bitmapPool, downsampled, orientation);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java, +import android.support.annotation.NonNull;, +  protected abstract Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,, +      int outWidth, int outHeight);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java, +import android.support.annotation.NonNull;, +  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,, +      int outHeight) {, +    return TransformationUtils.centerCrop(pool, toTransform, outWidth, outHeight);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java, +import android.support.annotation.NonNull;, +  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,, +      int outHeight) {, +    return TransformationUtils.circleCrop(pool, toTransform, outWidth, outHeight);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +      rotated = TransformationUtils.rotateImageExif(bitmapPool, downsampled, orientation);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java, +import android.support.annotation.NonNull;, +  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,, +      int outHeight) {, +    return TransformationUtils.fitCenter(pool, toTransform, outWidth, outHeight);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java, +import android.support.annotation.NonNull;, +  protected abstract Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,, +      int outWidth, int outHeight);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java, +import android.support.annotation.NonNull;, +  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,, +      int outHeight) {, +    return TransformationUtils.centerCrop(pool, toTransform, outWidth, outHeight);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java, +import android.support.annotation.NonNull;, +  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,, +      int outHeight) {, +    return TransformationUtils.circleCrop(pool, toTransform, outWidth, outHeight);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +      rotated = TransformationUtils.rotateImageExif(bitmapPool, downsampled, orientation);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java, +import android.support.annotation.NonNull;, +  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,, +      int outHeight) {, +    return TransformationUtils.fitCenter(pool, toTransform, outWidth, outHeight);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java, +   * @param toCrop   The Bitmap to resize., +  public static Bitmap centerCrop(@NonNull BitmapPool pool, @NonNull Bitmap toCrop, int width,, +      int height) {, +   * @param toFit  The Bitmap to shrink., +  public static Bitmap fitCenter(@NonNull BitmapPool pool, @NonNull Bitmap toFit, int width,, +      int height) {, +   * @param toOrient        The bitmap to rotate/flip., +  public static Bitmap rotateImageExif(@NonNull BitmapPool pool, @NonNull Bitmap toOrient,, +   * @param toCrop   The Bitmap to resize., +  public static Bitmap circleCrop(@NonNull BitmapPool pool, @NonNull Bitmap toCrop, int destWidth,, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java, +import android.support.annotation.NonNull;, +  protected abstract Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform,, +      int outWidth, int outHeight);]
[+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java]
[+++ b/library/src/main/java/com/bumptech/glide/util/pool/GlideTrace.java, +  private GlideTrace() {, +    // Utility class., +  }, +]
[+++ b/gradle.properties, +VERSION_NAME=4.0.0-SNAPSHOT]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +      if (fetcher != null && helper.hasLoadPath(fetcher.getDataClass())) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +      if (fetcher != null && helper.hasLoadPath(fetcher.getDataClass())) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +  boolean hasLoadPath(Class<?> dataClass) {, +    return getLoadPath(dataClass) != null;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +      if (fetcher != null && helper.hasLoadPath(fetcher.getDataClass())) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +  boolean hasLoadPath(Class<?> dataClass) {, +    return getLoadPath(dataClass) != null;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +      if (fetcher != null && helper.hasLoadPath(fetcher.getDataClass())) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +  boolean hasLoadPath(Class<?> dataClass) {, +    return getLoadPath(dataClass) != null;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java, +      if (fetcher != null && helper.hasLoadPath(fetcher.getDataClass())) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +      if (fetcher != null && helper.hasLoadPath(fetcher.getDataClass())) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +  boolean hasLoadPath(Class<?> dataClass) {, +    return getLoadPath(dataClass) != null;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java, +      if (fetcher != null && helper.hasLoadPath(fetcher.getDataClass())) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java, +      if (loadData != null, +          && (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource()), +          || helper.hasLoadPath(loadData.fetcher.getDataClass()))) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +      if (fetcher != null && helper.hasLoadPath(fetcher.getDataClass())) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +  boolean hasLoadPath(Class<?> dataClass) {, +    return getLoadPath(dataClass) != null;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java, +      if (fetcher != null && helper.hasLoadPath(fetcher.getDataClass())) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java, +      if (loadData != null, +          && (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource()), +          || helper.hasLoadPath(loadData.fetcher.getDataClass()))) {, +++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java, +   * then it is acceptable to return a null data fetcher from this method. </p>]
[+++ b/gradle/wrapper/gradle-wrapper.properties, +#Mon Mar 04 18:37:29 PST 2019, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.10.1-all.zip]
[+++ b/.gitmodules, +[submodule "library/volley"], +	path = library/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/.gitmodules, +[submodule "library/volley"], +	path = library/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/library/project.properties, +android.library.reference=volley, +++ b/.gitmodules, +[submodule "library/volley"], +	path = library/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/library/project.properties, +android.library.reference=volley, +++ b/library/volley, +Subproject commit ba7d701bc2a0fa657422242537ace9bd63b14798]
[+++ b/.idea/codeStyleSettings.xml, +        <Objective-C-extensions>, +          <option name="GENERATE_INSTANCE_VARIABLES_FOR_PROPERTIES" value="ASK" />, +          <option name="RELEASE_STYLE" value="IVAR" />, +          <option name="TYPE_QUALIFIERS_PLACEMENT" value="BEFORE" />, +          <file>, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Import" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Macro" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Typedef" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Enum" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Constant" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Global" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Struct" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="FunctionPredecl" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Function" />, +          </file>, +          <class>, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Property" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Synthesize" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InitMethod" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="StaticMethod" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InstanceMethod" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="DeallocMethod" />, +          </class>, +          <extensions>, +            <pair source="cpp" header="h" />, +            <pair source="c" header="h" />, +          </extensions>, +        </Objective-C-extensions>, +++ b/.idea/codeStyleSettings.xml, +        <Objective-C-extensions>, +          <option name="GENERATE_INSTANCE_VARIABLES_FOR_PROPERTIES" value="ASK" />, +          <option name="RELEASE_STYLE" value="IVAR" />, +          <option name="TYPE_QUALIFIERS_PLACEMENT" value="BEFORE" />, +          <file>, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Import" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Macro" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Typedef" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Enum" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Constant" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Global" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Struct" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="FunctionPredecl" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Function" />, +          </file>, +          <class>, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Property" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Synthesize" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InitMethod" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="StaticMethod" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InstanceMethod" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="DeallocMethod" />, +          </class>, +          <extensions>, +            <pair source="cpp" header="h" />, +            <pair source="c" header="h" />, +          </extensions>, +        </Objective-C-extensions>, +++ b/library/build.gradle, +, +        consumerProguardFiles 'proguard-rules.txt', +++ b/.idea/codeStyleSettings.xml, +        <Objective-C-extensions>, +          <option name="GENERATE_INSTANCE_VARIABLES_FOR_PROPERTIES" value="ASK" />, +          <option name="RELEASE_STYLE" value="IVAR" />, +          <option name="TYPE_QUALIFIERS_PLACEMENT" value="BEFORE" />, +          <file>, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Import" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Macro" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Typedef" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Enum" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Constant" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Global" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Struct" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="FunctionPredecl" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Function" />, +          </file>, +          <class>, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Property" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Synthesize" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InitMethod" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="StaticMethod" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InstanceMethod" />, +            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="DeallocMethod" />, +          </class>, +          <extensions>, +            <pair source="cpp" header="h" />, +            <pair source="c" header="h" />, +          </extensions>, +        </Objective-C-extensions>, +++ b/library/build.gradle, +, +        consumerProguardFiles 'proguard-rules.txt', +++ b/library/proguard-rules.txt, +-keep public class * implements com.bumptech.glide.module.GlideModule, +-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {, +    **[] $VALUES;, +    public *;, +}, +++ b/.idea/codeStyleSettings.xml]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java, + * Interface for handling operations on a primitive array type., +   * TAG for logging., +   * Return the length of the given array., +   * Reset the array for re-use (e.g. set all values to 0)., +   * Allocate and return an array of the specified size., +   * Return the size of an element in the array in bytes (e.g. for int return 4)., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java, + * Interface for handling operations on a primitive array type., +   * TAG for logging., +   * Return the length of the given array., +   * Reset the array for re-use (e.g. set all values to 0)., +   * Allocate and return an array of the specified size., +   * Return the size of an element in the array in bytes (e.g. for int return 4)., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java, + * Interface for an array pool that pools arrays of different types., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java, + * Interface for handling operations on a primitive array type., +   * TAG for logging., +   * Return the length of the given array., +   * Reset the array for re-use (e.g. set all values to 0)., +   * Allocate and return an array of the specified size., +   * Return the size of an element in the array in bytes (e.g. for int return 4)., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java, + * Interface for an array pool that pools arrays of different types., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java, + * Adapter for handling primitive byte arrays., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java, + * Interface for handling operations on a primitive array type., +   * TAG for logging., +   * Return the length of the given array., +   * Reset the array for re-use (e.g. set all values to 0)., +   * Allocate and return an array of the specified size., +   * Return the size of an element in the array in bytes (e.g. for int return 4)., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java, + * Interface for an array pool that pools arrays of different types., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java, + * Adapter for handling primitive byte arrays., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java, + * Adapter for handling primitive int arrays., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java, + * Interface for handling operations on a primitive array type., +   * TAG for logging., +   * Return the length of the given array., +   * Reset the array for re-use (e.g. set all values to 0)., +   * Allocate and return an array of the specified size., +   * Return the size of an element in the array in bytes (e.g. for int return 4)., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java, + * Interface for an array pool that pools arrays of different types., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java, + * Adapter for handling primitive byte arrays., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java, + * Adapter for handling primitive int arrays., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java, +import android.support.annotation.Nullable;, +import com.bumptech.glide.util.Preconditions;, +, +    ArrayAdapterInterface<T> arrayAdapter = getAdapterFromType(arrayClass);, +      result = getArrayForKey(key);, +  @SuppressWarnings("unchecked"), +  @Nullable, +  private <T> T getArrayForKey(Key key) {, +    return (T) groupedMap.get(key);, +  }, +, +      Preconditions.checkNotNull(evicted);, +      ArrayAdapterInterface<Object> arrayAdapter = getAdapterFromObject(evicted);, +  private void decrementArrayOfSize(int size, Class<?> arrayClass) {, +  private NavigableMap<Integer, Integer> getSizesForAdapter(Class<?> arrayClass) {, +  @SuppressWarnings("unchecked"), +  private <T> ArrayAdapterInterface<T> getAdapterFromObject(T object) {, +    return (ArrayAdapterInterface<T>) getAdapterFromType(object.getClass());, +  }, +, +  @SuppressWarnings("unchecked"), +  private <T> ArrayAdapterInterface<T> getAdapterFromType(Class<T> arrayPoolClass) {, +    int currentSize = 0;, +    for (Class<?> type : sortedSizes.keySet()) {, +        ArrayAdapterInterface<?> adapter = getAdapterFromType(type);, +        currentSize += size * sortedSizes.get(type).get(size) * adapter.getElementSizeInBytes();, +    return currentSize;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayAdapterInterface.java, + * Interface for handling operations on a primitive array type., +   * TAG for logging., +   * Return the length of the given array., +   * Reset the array for re-use (e.g. set all values to 0)., +   * Allocate and return an array of the specified size., +   * Return the size of an element in the array in bytes (e.g. for int return 4)., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java, + * Interface for an array pool that pools arrays of different types., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ByteArrayAdapter.java, + * Adapter for handling primitive byte arrays., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/IntegerArrayAdapter.java, + * Adapter for handling primitive int arrays., +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java, +import android.support.annotation.Nullable;, +import com.bumptech.glide.util.Preconditions;, +, +    ArrayAdapterInterface<T> arrayAdapter = getAdapterFromType(arrayClass);, +      result = getArrayForKey(key);]
[+++ b/third_party/gif_decoder/build.gradle, +    androidTestCompile 'com.android.support:support-v4:19.1.0', +    androidTestCompile 'org.robolectric:robolectric:2.4-SNAPSHOT', +++ b/third_party/gif_decoder/build.gradle, +    androidTestCompile 'com.android.support:support-v4:19.1.0', +    androidTestCompile 'org.robolectric:robolectric:2.4-SNAPSHOT', +++ b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java, +package com.bumptech.glide.gifdecoder;, +, +import android.graphics.Bitmap;, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.Robolectric;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertNotNull;, +, +/**, + * Tests for {@link com.bumptech.glide.gifdecoder.GifDecoder}., + */, +@RunWith(RobolectricTestRunner.class), +@Config(emulateSdk = 18), +public class GifDecoderTest {, +, +    private MockProvider provider;, +, +    @Before, +    public void setUp() {, +        provider = new MockProvider();, +    }, +, +    @Test, +    public void testCanDecodeFramesFromTestGif() {, +        byte[] data = TestUtil.readResourceData("partial_gif_decode.gif");, +        GifHeaderParser headerParser = new GifHeaderParser();, +        headerParser.setData(data);, +        GifHeader header = headerParser.parseHeader();, +        GifDecoder decoder = new GifDecoder(provider);, +        decoder.setData(header, data);, +        decoder.advance();, +        Bitmap bitmap = decoder.getNextFrame();, +        assertNotNull(bitmap);, +        assertEquals(GifDecoder.STATUS_OK, decoder.getStatus());, +    }, +, +    private static class MockProvider implements GifDecoder.BitmapProvider {, +, +        @Override, +        public Bitmap obtain(int width, int height, Bitmap.Config config) {, +            Bitmap result = Bitmap.createBitmap(width, height, config);, +            Robolectric.shadowOf(result).setMutable(true);, +            return result;, +        }, +    }, +}, +++ b/third_party/gif_decoder/build.gradle, +    androidTestCompile 'com.android.support:support-v4:19.1.0', +    androidTestCompile 'org.robolectric:robolectric:2.4-SNAPSHOT', +++ b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java, +package com.bumptech.glide.gifdecoder;, +, +import android.graphics.Bitmap;, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.Robolectric;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertNotNull;, +, +/**, + * Tests for {@link com.bumptech.glide.gifdecoder.GifDecoder}., + */, +@RunWith(RobolectricTestRunner.class), +@Config(emulateSdk = 18), +public class GifDecoderTest {, +, +    private MockProvider provider;, +, +    @Before, +    public void setUp() {, +        provider = new MockProvider();, +    }, +, +    @Test, +    public void testCanDecodeFramesFromTestGif() {, +        byte[] data = TestUtil.readResourceData("partial_gif_decode.gif");, +        GifHeaderParser headerParser = new GifHeaderParser();, +        headerParser.setData(data);, +        GifHeader header = headerParser.parseHeader();, +        GifDecoder decoder = new GifDecoder(provider);, +        decoder.setData(header, data);, +        decoder.advance();, +        Bitmap bitmap = decoder.getNextFrame();, +        assertNotNull(bitmap);]
[+++ b/gradle.properties, +TRUTH_VERSION=0.24, +++ b/gradle.properties, +TRUTH_VERSION=0.24, +++ b/integration/volley/build.gradle, +    androidTestCompile "com.google.truth:truth:${TRUTH_VERSION}", +++ b/gradle.properties, +TRUTH_VERSION=0.24, +++ b/integration/volley/build.gradle, +    androidTestCompile "com.google.truth:truth:${TRUTH_VERSION}", +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.google.common.truth.Truth.assertThat;, +import static org.junit.Assert.assertEquals;, +        assertEquals(expected, isToString(is));, +        assertEquals(expected, isToString(is));, +        assertEquals(expected, isToString(is));, +        assertEquals(expected, isToString(is));, +        assertThat(mockWebServer.takeRequest().getPath()).contains(DEFAULT_PATH);, +            assertThat(mockWebServer.takeRequest().getPath()).contains(redirectBase + i);, +            assertThat(e.getCause()).isInstanceOf(VolleyError.class);, +            assertThat(e.getCause()).isInstanceOf(NoConnectionError.class);, +            assertThat(e.getCause()).isInstanceOf(NoConnectionError.class);, +            assertThat(e.getCause().getCause()).isInstanceOf(ProtocolException.class);, +            assertThat(e.getCause()).isInstanceOf(ServerError.class);, +            assertThat(e.getCause()).isInstanceOf(ServerError.class);, +++ b/gradle.properties, +TRUTH_VERSION=0.24, +++ b/integration/volley/build.gradle, +    androidTestCompile "com.google.truth:truth:${TRUTH_VERSION}", +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.google.common.truth.Truth.assertThat;, +import static org.junit.Assert.assertEquals;, +        assertEquals(expected, isToString(is));, +        assertEquals(expected, isToString(is));, +        assertEquals(expected, isToString(is));, +        assertEquals(expected, isToString(is));, +        assertThat(mockWebServer.takeRequest().getPath()).contains(DEFAULT_PATH);, +            assertThat(mockWebServer.takeRequest().getPath()).contains(redirectBase + i);, +            assertThat(e.getCause()).isInstanceOf(VolleyError.class);, +            assertThat(e.getCause()).isInstanceOf(NoConnectionError.class);, +            assertThat(e.getCause()).isInstanceOf(NoConnectionError.class);, +            assertThat(e.getCause().getCause()).isInstanceOf(ProtocolException.class);, +            assertThat(e.getCause()).isInstanceOf(ServerError.class);, +            assertThat(e.getCause()).isInstanceOf(ServerError.class);, +++ b/library/build.gradle, +    androidTestCompile "com.google.truth:truth:${TRUTH_VERSION}", +++ b/gradle.properties, +TRUTH_VERSION=0.24, +++ b/integration/volley/build.gradle, +    androidTestCompile "com.google.truth:truth:${TRUTH_VERSION}", +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.google.common.truth.Truth.assertThat;, +import static org.junit.Assert.assertEquals;, +        assertEquals(expected, isToString(is));, +        assertEquals(expected, isToString(is));, +        assertEquals(expected, isToString(is));, +        assertEquals(expected, isToString(is));, +        assertThat(mockWebServer.takeRequest().getPath()).contains(DEFAULT_PATH);, +            assertThat(mockWebServer.takeRequest().getPath()).contains(redirectBase + i);, +            assertThat(e.getCause()).isInstanceOf(VolleyError.class);, +            assertThat(e.getCause()).isInstanceOf(NoConnectionError.class);, +            assertThat(e.getCause()).isInstanceOf(NoConnectionError.class);, +            assertThat(e.getCause().getCause()).isInstanceOf(ProtocolException.class);, +            assertThat(e.getCause()).isInstanceOf(ServerError.class);, +            assertThat(e.getCause()).isInstanceOf(ServerError.class);, +++ b/library/build.gradle, +    androidTestCompile "com.google.truth:truth:${TRUTH_VERSION}", +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import static com.google.common.truth.Truth.assertThat;, +        assertThat(loadedObjects).containsAllIn(objects);, +++ b/gradle.properties, +TRUTH_VERSION=0.24, +++ b/integration/volley/build.gradle, +    androidTestCompile "com.google.truth:truth:${TRUTH_VERSION}", +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.google.common.truth.Truth.assertThat;, +import static org.junit.Assert.assertEquals;, +        assertEquals(expected, isToString(is));, +        assertEquals(expected, isToString(is));, +        assertEquals(expected, isToString(is));, +        assertEquals(expected, isToString(is));, +        assertThat(mockWebServer.takeRequest().getPath()).contains(DEFAULT_PATH);, +            assertThat(mockWebServer.takeRequest().getPath()).contains(redirectBase + i);, +            assertThat(e.getCause()).isInstanceOf(VolleyError.class);, +            assertThat(e.getCause()).isInstanceOf(NoConnectionError.class);, +            assertThat(e.getCause()).isInstanceOf(NoConnectionError.class);, +            assertThat(e.getCause().getCause()).isInstanceOf(ProtocolException.class);, +            assertThat(e.getCause()).isInstanceOf(ServerError.class);, +            assertThat(e.getCause()).isInstanceOf(ServerError.class);, +++ b/library/build.gradle, +    androidTestCompile "com.google.truth:truth:${TRUTH_VERSION}", +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import static com.google.common.truth.Truth.assertThat;, +        assertThat(loadedObjects).containsAllIn(objects);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherServerTest.java, +import static com.google.common.truth.Truth.assertThat;, +import static org.junit.Assert.assertEquals;, +        assertEquals(expected, isToString(is));, +        assertEquals(expected, isToString(is));, +        assertEquals(expected, isToString(is));]
[+++ b/gradle.properties, +VERSION_NAME=4.3.0]
[+++ b/integration/okhttp/gradle.properties, +, +# Prefix and postfix for source and javadoc jars., +JAR_PREFIX=glide-, +JAR_POSTFIX=-integration, +++ b/integration/okhttp/gradle.properties, +, +# Prefix and postfix for source and javadoc jars., +JAR_PREFIX=glide-, +JAR_POSTFIX=-integration, +++ b/integration/volley/gradle.properties, +, +# Prefix and postfix for source and javadoc jars., +JAR_PREFIX=glide-, +JAR_POSTFIX=-integration, +++ b/integration/okhttp/gradle.properties, +, +# Prefix and postfix for source and javadoc jars., +JAR_PREFIX=glide-, +JAR_POSTFIX=-integration, +++ b/integration/volley/gradle.properties, +, +# Prefix and postfix for source and javadoc jars., +JAR_PREFIX=glide-, +JAR_POSTFIX=-integration, +++ b/scripts/upload.gradle, +            baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}", +            baseName "${JAR_PREFIX}${project.name}${JAR_POSTFIX}"]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    BitmapEncoder bitmapEncoder = new BitmapEncoder(arrayPool);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    BitmapEncoder bitmapEncoder = new BitmapEncoder(arrayPool);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +import android.support.annotation.Nullable;, +import com.bumptech.glide.load.data.BufferedOutputStream;, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +  @Nullable, +  private final ArrayPool arrayPool;, +, +  public BitmapEncoder(@NonNull ArrayPool arrayPool) {, +    this.arrayPool = arrayPool;, +  }, +, +  /**, +   * @deprecated Use {@link #BitmapEncoder(ArrayPool)} instead., +   */, +  @Deprecated, +  public BitmapEncoder() {, +    arrayPool = null;, +  }, +        if (arrayPool != null) {, +          os = new BufferedOutputStream(os, arrayPool);, +        }, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    BitmapEncoder bitmapEncoder = new BitmapEncoder(arrayPool);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +import android.support.annotation.Nullable;, +import com.bumptech.glide.load.data.BufferedOutputStream;, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +  @Nullable, +  private final ArrayPool arrayPool;, +, +  public BitmapEncoder(@NonNull ArrayPool arrayPool) {, +    this.arrayPool = arrayPool;, +  }, +, +  /**, +   * @deprecated Use {@link #BitmapEncoder(ArrayPool)} instead., +   */, +  @Deprecated, +  public BitmapEncoder() {, +    arrayPool = null;, +  }, +        if (arrayPool != null) {, +          os = new BufferedOutputStream(os, arrayPool);, +        }, +++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoderTest.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;, +    BitmapEncoder encoder = new BitmapEncoder(harness.arrayPool);, +    BitmapEncoder encoder = new BitmapEncoder(harness.arrayPool);, +    final ArrayPool arrayPool = new LruArrayPool();, +      BitmapEncoder encoder = new BitmapEncoder(arrayPool);]
[+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java, +import android.net.Uri;, +import java.lang.Deprecated;, +import java.lang.Integer;, +import java.lang.String;, +import java.net.URL;, +  public GlideRequest<Drawable> load(@Nullable Bitmap arg0) {, +    return (GlideRequest<Drawable>) super.load(arg0);, +  }, +, +  @Override, +  @CheckResult, +  public GlideRequest<Drawable> load(@Nullable Drawable arg0) {, +    return (GlideRequest<Drawable>) super.load(arg0);, +  }, +, +  @Override, +  @CheckResult, +  public GlideRequest<Drawable> load(@Nullable String arg0) {, +    return (GlideRequest<Drawable>) super.load(arg0);, +  }, +, +  @Override, +  @CheckResult, +  public GlideRequest<Drawable> load(@Nullable Uri arg0) {, +    return (GlideRequest<Drawable>) super.load(arg0);, +  }, +, +  @Override, +  @CheckResult, +  public GlideRequest<Drawable> load(@Nullable File arg0) {, +    return (GlideRequest<Drawable>) super.load(arg0);, +  }, +, +  @Override, +  @CheckResult, +  public GlideRequest<Drawable> load(@Nullable Integer arg0) {, +    return (GlideRequest<Drawable>) super.load(arg0);, +  }, +, +  @Override, +  @Deprecated, +  @CheckResult, +  public GlideRequest<Drawable> load(@Nullable URL arg0) {, +    return (GlideRequest<Drawable>) super.load(arg0);, +  }, +, +  @Override, +  @CheckResult, +  public GlideRequest<Drawable> load(@Nullable byte[] arg0) {, +    return (GlideRequest<Drawable>) super.load(arg0);, +  }, +, +  @Override, +  @CheckResult, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java, +import android.net.Uri;, +import java.lang.Deprecated;, +import java.lang.Integer;, +import java.lang.String;, +import java.net.URL;, +  public GlideRequest<Drawable> load(@Nullable Bitmap arg0) {, +    return (GlideRequest<Drawable>) super.load(arg0);, +  }, +, +  @Override, +  @CheckResult, +  public GlideRequest<Drawable> load(@Nullable Drawable arg0) {, +    return (GlideRequest<Drawable>) super.load(arg0);, +  }, +, +  @Override, +  @CheckResult, +  public GlideRequest<Drawable> load(@Nullable String arg0) {, +    return (GlideRequest<Drawable>) super.load(arg0);, +  }, +, +  @Override, +  @CheckResult, +  public GlideRequest<Drawable> load(@Nullable Uri arg0) {, +    return (GlideRequest<Drawable>) super.load(arg0);, +  }, +, +  @Override, +  @CheckResult, +  public GlideRequest<Drawable> load(@Nullable File arg0) {, +    return (GlideRequest<Drawable>) super.load(arg0);, +  }, +, +  @Override, +  @CheckResult, +  public GlideRequest<Drawable> load(@Nullable Integer arg0) {, +    return (GlideRequest<Drawable>) super.load(arg0);, +  }, +, +  @Override, +  @Deprecated, +  @CheckResult, +  public GlideRequest<Drawable> load(@Nullable URL arg0) {, +    return (GlideRequest<Drawable>) super.load(arg0);]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import android.support.annotation.Nullable;, +  @Nullable private Object model;, +  @Nullable private RequestListener<TranscodeType> requestListener;, +  @Nullable private RequestBuilder<TranscodeType> thumbnailBuilder;, +  @Nullable private Float thumbSizeMultiplier;, +  public RequestBuilder<TranscodeType> listener(, +      @Nullable RequestListener<TranscodeType> requestListener) {, +  public RequestBuilder<TranscodeType> thumbnail(, +      @Nullable RequestBuilder<TranscodeType> thumbnailRequest) {, +  public RequestBuilder<TranscodeType> load(@Nullable Object model) {, +  private RequestBuilder<TranscodeType> loadGeneric(@Nullable Object model) {, +      @Nullable ThumbnailRequestCoordinator parentCoordinator,, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import android.support.annotation.Nullable;, +  @Nullable private Object model;, +  @Nullable private RequestListener<TranscodeType> requestListener;, +  @Nullable private RequestBuilder<TranscodeType> thumbnailBuilder;, +  @Nullable private Float thumbSizeMultiplier;, +  public RequestBuilder<TranscodeType> listener(, +      @Nullable RequestListener<TranscodeType> requestListener) {, +  public RequestBuilder<TranscodeType> thumbnail(, +      @Nullable RequestBuilder<TranscodeType> thumbnailRequest) {, +  public RequestBuilder<TranscodeType> load(@Nullable Object model) {, +  private RequestBuilder<TranscodeType> loadGeneric(@Nullable Object model) {, +      @Nullable ThumbnailRequestCoordinator parentCoordinator,, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +import android.support.annotation.Nullable;, +  public void clear(@Nullable Target<?> target) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import android.support.annotation.Nullable;, +  @Nullable private Object model;, +  @Nullable private RequestListener<TranscodeType> requestListener;, +  @Nullable private RequestBuilder<TranscodeType> thumbnailBuilder;, +  @Nullable private Float thumbSizeMultiplier;, +  public RequestBuilder<TranscodeType> listener(, +      @Nullable RequestListener<TranscodeType> requestListener) {, +  public RequestBuilder<TranscodeType> thumbnail(, +      @Nullable RequestBuilder<TranscodeType> thumbnailRequest) {, +  public RequestBuilder<TranscodeType> load(@Nullable Object model) {, +  private RequestBuilder<TranscodeType> loadGeneric(@Nullable Object model) {, +      @Nullable ThumbnailRequestCoordinator parentCoordinator,, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +import android.support.annotation.Nullable;, +  public void clear(@Nullable Target<?> target) {, +++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java, +import android.support.annotation.Nullable;, +  @Nullable private final URL url;, +  @Nullable private final String stringUrl;, +  @Nullable private String safeStringUrl;, +  @Nullable private URL safeUrl;, +  @Nullable private volatile byte[] cacheKeyBytes;, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import android.support.annotation.Nullable;, +  @Nullable private Object model;, +  @Nullable private RequestListener<TranscodeType> requestListener;, +  @Nullable private RequestBuilder<TranscodeType> thumbnailBuilder;, +  @Nullable private Float thumbSizeMultiplier;, +  public RequestBuilder<TranscodeType> listener(, +      @Nullable RequestListener<TranscodeType> requestListener) {, +  public RequestBuilder<TranscodeType> thumbnail(, +      @Nullable RequestBuilder<TranscodeType> thumbnailRequest) {, +  public RequestBuilder<TranscodeType> load(@Nullable Object model) {, +  private RequestBuilder<TranscodeType> loadGeneric(@Nullable Object model) {, +      @Nullable ThumbnailRequestCoordinator parentCoordinator,, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +import android.support.annotation.Nullable;, +  public void clear(@Nullable Target<?> target) {, +++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java, +import android.support.annotation.Nullable;, +  @Nullable private final URL url;, +  @Nullable private final String stringUrl;, +  @Nullable private String safeStringUrl;, +  @Nullable private URL safeUrl;, +  @Nullable private volatile byte[] cacheKeyBytes;, +++ b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java, +import android.support.annotation.Nullable;, +, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/Glide.java]
[+++ b/.travis.yml, +- scripts/travis-sonatype-publish.sh, +++ b/.travis.yml, +- scripts/travis-sonatype-publish.sh, +++ b/scripts/travis-sonatype-publish.sh, +#!/bin/bash, +# Publishes the latest snapshot to Sonatype. Works only for SNAPSHOT versions., +# Based closely on material from, +# http://benlimmer.com/2014/01/04/automatically-publish-to-sonatype-with-gradle-and-travis-ci., +, +if [ "$TRAVIS_REPO_SLUG" == "bumptech/glide" ] && [ "$TRAVIS_PULL_REQUEST" == "false" ] && [ "$TRAVIS_BRANCH" == "3.0a" ]; then, +  if [[ $(./gradlew -q getVersion) != *SNAPSHOT* ]]; then, +      echo 'Travis can only publish snapshots.', +      return 0, +  fi, +, +  echo -e "Starting publish to Sonatype...\n", +, +  ./gradlew uploadArchives -PnexusUsername="${NEXUS_USERNAME}" -PnexusPassword="${NEXUS_PASSWORD}", +  RETVAL=$?, +, +  if [ $RETVAL -eq 0 ]; then, +    echo 'Completed publish!', +  else, +    echo 'Publish failed.', +    return 1, +  fi, +else, +    echo 'Skipping Sonatype push', +fi]
[+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java, +import android.support.v4.content.ContextCompat;, +  private static final String NETWORK_PERMISSION = "android.permission.ACCESS_NETWORK_STATE";, +    int permissionResult = ContextCompat.checkSelfPermission(context, NETWORK_PERMISSION);, +    boolean hasPermission = permissionResult == PackageManager.PERMISSION_GRANTED;, +    return hasPermission, +        ? new DefaultConnectivityMonitor(context, listener) : new NullConnectivityMonitor();]
[+++ b/.gitmodules, +[submodule "third_party/disklrucache"], +	path = third_party/disklrucache, +++ b/.gitmodules, +[submodule "third_party/disklrucache"], +	path = third_party/disklrucache, +++ b/library/build.gradle, +apply plugin: 'maven', +    compile project(':third_party:disklrucache'), +, +// All dependencies are written to the pom file with the default type (.jar). Since we're uploading the gif decoder, +// as an aar we need to change the type in the pom file to match or maven/gradle wont' be able to find the transitive, +// dependency., +afterEvaluate {, +    def installer = install.repositories.mavenInstaller, +    def deployer = uploadArchives.repositories.mavenDeployer, +, +    [installer, deployer]*.pom*.whenConfigured { pom ->, +        pom.dependencies.find { dep ->, +            dep.groupId == 'com.github.bumptech.glide' && dep.artifactId == 'glide-gif-decoder', +        }.type = "aar", +    }, +}, +++ b/.gitmodules, +[submodule "third_party/disklrucache"], +	path = third_party/disklrucache, +++ b/library/build.gradle, +apply plugin: 'maven', +    compile project(':third_party:disklrucache'), +, +// All dependencies are written to the pom file with the default type (.jar). Since we're uploading the gif decoder, +// as an aar we need to change the type in the pom file to match or maven/gradle wont' be able to find the transitive, +// dependency., +afterEvaluate {, +    def installer = install.repositories.mavenInstaller, +    def deployer = uploadArchives.repositories.mavenDeployer, +, +    [installer, deployer]*.pom*.whenConfigured { pom ->, +        pom.dependencies.find { dep ->, +            dep.groupId == 'com.github.bumptech.glide' && dep.artifactId == 'glide-gif-decoder', +        }.type = "aar", +    }, +}, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java, +import com.bumptech.glide.disklrucache.DiskLruCache;, +++ b/.gitmodules, +[submodule "third_party/disklrucache"], +	path = third_party/disklrucache, +++ b/library/build.gradle, +apply plugin: 'maven', +    compile project(':third_party:disklrucache'), +, +// All dependencies are written to the pom file with the default type (.jar). Since we're uploading the gif decoder, +// as an aar we need to change the type in the pom file to match or maven/gradle wont' be able to find the transitive, +// dependency., +afterEvaluate {, +    def installer = install.repositories.mavenInstaller, +    def deployer = uploadArchives.repositories.mavenDeployer, +, +    [installer, deployer]*.pom*.whenConfigured { pom ->, +        pom.dependencies.find { dep ->, +            dep.groupId == 'com.github.bumptech.glide' && dep.artifactId == 'glide-gif-decoder', +        }.type = "aar", +    }, +}, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java, +import com.bumptech.glide.disklrucache.DiskLruCache;, +++ b/settings.gradle, +include ':third_party:disklrucache', +++ b/.gitmodules, +[submodule "third_party/disklrucache"], +	path = third_party/disklrucache, +++ b/library/build.gradle, +apply plugin: 'maven', +    compile project(':third_party:disklrucache'), +, +// All dependencies are written to the pom file with the default type (.jar). Since we're uploading the gif decoder, +// as an aar we need to change the type in the pom file to match or maven/gradle wont' be able to find the transitive, +// dependency., +afterEvaluate {, +    def installer = install.repositories.mavenInstaller, +    def deployer = uploadArchives.repositories.mavenDeployer, +, +    [installer, deployer]*.pom*.whenConfigured { pom ->, +        pom.dependencies.find { dep ->, +            dep.groupId == 'com.github.bumptech.glide' && dep.artifactId == 'glide-gif-decoder', +        }.type = "aar", +    }, +}, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java, +import com.bumptech.glide.disklrucache.DiskLruCache;, +++ b/settings.gradle, +include ':third_party:disklrucache', +++ /dev/null, +++ b/.gitmodules, +[submodule "third_party/disklrucache"], +	path = third_party/disklrucache, +++ b/library/build.gradle, +apply plugin: 'maven', +    compile project(':third_party:disklrucache')]
[+++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.6-all.zip]
[+++ b/library/src/main/java/com/bumptech/glide/Registry.java, +import android.support.v4.util.Pools.Pool;, +import com.bumptech.glide.util.pool.FactoryPools;, +  private final Pool<List<Exception>> exceptionListPool = FactoryPools.threadSafeList();, +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +import android.support.v4.util.Pools.Pool;, +import com.bumptech.glide.util.pool.FactoryPools;, +  private final Pool<List<Exception>> exceptionListPool = FactoryPools.threadSafeList();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +import com.bumptech.glide.util.pool.FactoryPools.Poolable;, +import com.bumptech.glide.util.pool.StateVerifier;, +    Comparable<DecodeJob<?>>,, +    Poolable {, +  private final StateVerifier stateVerifier = StateVerifier.newInstance();, +    isCallbackNotified = false;, +    if (isCallbackNotified) {, +      throw new IllegalStateException("Already notified");, +    }, +    isCallbackNotified = true;, +  @Override, +  public StateVerifier getVerifier() {, +    return stateVerifier;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +import android.support.v4.util.Pools.Pool;, +import com.bumptech.glide.util.pool.FactoryPools;, +  private final Pool<List<Exception>> exceptionListPool = FactoryPools.threadSafeList();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +import com.bumptech.glide.util.pool.FactoryPools.Poolable;, +import com.bumptech.glide.util.pool.StateVerifier;, +    Comparable<DecodeJob<?>>,, +    Poolable {, +  private final StateVerifier stateVerifier = StateVerifier.newInstance();, +    isCallbackNotified = false;, +    if (isCallbackNotified) {, +      throw new IllegalStateException("Already notified");, +    }, +    isCallbackNotified = true;, +  @Override, +  public StateVerifier getVerifier() {, +    return stateVerifier;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java, +import android.support.v4.util.Pools.Pool;, +  private final Pool<List<Exception>> listPool;, +      ResourceTranscoder<ResourceType, Transcode> transcoder, Pool<List<Exception>> listPool) {, +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +import android.support.v4.util.Pools.Pool;, +import com.bumptech.glide.util.pool.FactoryPools;, +  private final Pool<List<Exception>> exceptionListPool = FactoryPools.threadSafeList();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +import com.bumptech.glide.util.pool.FactoryPools.Poolable;, +import com.bumptech.glide.util.pool.StateVerifier;, +    Comparable<DecodeJob<?>>,, +    Poolable {, +  private final StateVerifier stateVerifier = StateVerifier.newInstance();, +    isCallbackNotified = false;, +    if (isCallbackNotified) {, +      throw new IllegalStateException("Already notified");, +    }, +    isCallbackNotified = true;, +  @Override, +  public StateVerifier getVerifier() {, +    return stateVerifier;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodePath.java, +import android.support.v4.util.Pools.Pool;, +  private final Pool<List<Exception>> listPool;, +      ResourceTranscoder<ResourceType, Transcode> transcoder, Pool<List<Exception>> listPool) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +import com.bumptech.glide.util.pool.FactoryPools;, +    private final Pools.Pool<DecodeJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,, +        new FactoryPools.Factory<DecodeJob<?>>() {, +          @Override, +          public DecodeJob<?> create() {, +            return new DecodeJob<Object>(diskCacheProvider, pool);, +          }, +        });, +    private final Pools.Pool<EngineJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,, +        new FactoryPools.Factory<EngineJob<?>>() {, +          @Override, +          public EngineJob<?> create() {, +            return new EngineJob<Object>(diskCacheExecutor, sourceExecutor, listener, pool);, +          }, +        });, +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +import android.support.v4.util.Pools.Pool;, +import com.bumptech.glide.util.pool.FactoryPools;, +  private final Pool<List<Exception>> exceptionListPool = FactoryPools.threadSafeList();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +import com.bumptech.glide.util.pool.FactoryPools.Poolable;, +import com.bumptech.glide.util.pool.StateVerifier;, +    Comparable<DecodeJob<?>>,, +    Poolable {, +  private final StateVerifier stateVerifier = StateVerifier.newInstance();, +    isCallbackNotified = false;, +    if (isCallbackNotified) {]
[+++ b/samples/flickr/AndroidManifest.xml, +, +  <uses-permission android:name="android.permission.INTERNET" />, +  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />, +  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="16" />, +, +, +++ b/samples/flickr/AndroidManifest.xml, +, +  <uses-permission android:name="android.permission.INTERNET" />, +  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />, +  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="16" />, +, +, +++ b/samples/flickr/res/values/strings.xml, +    <string name="app_name">Glide Demo</string>, +++ b/samples/flickr/AndroidManifest.xml, +, +  <uses-permission android:name="android.permission.INTERNET" />, +  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />, +  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="16" />, +, +, +++ b/samples/flickr/res/values/strings.xml, +    <string name="app_name">Glide Demo</string>, +++ b/samples/flickr/src/com/bumptech/flickr/FlickrPhotoGrid.java, +import com.bumptech.glide.loader.image.ImageManagerLoader;, +    public static FlickrPhotoGrid newInstance(int size) {, +, +                //this is an example of how one might use ImagePresenter directly, there is no particular reason, +                //why ImagePresenter is used here and not in FlickrPhotoList otherwise., +++ b/samples/flickr/AndroidManifest.xml, +, +  <uses-permission android:name="android.permission.INTERNET" />, +  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />, +  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="16" />, +, +, +++ b/samples/flickr/res/values/strings.xml, +    <string name="app_name">Glide Demo</string>, +++ b/samples/flickr/src/com/bumptech/flickr/FlickrPhotoGrid.java, +import com.bumptech.glide.loader.image.ImageManagerLoader;, +    public static FlickrPhotoGrid newInstance(int size) {, +, +                //this is an example of how one might use ImagePresenter directly, there is no particular reason, +                //why ImagePresenter is used here and not in FlickrPhotoList otherwise., +++ b/samples/flickr/src/com/bumptech/flickr/FlickrSearchActivity.java, +    private static final String CACHE_NAME = "flickr_cache";, +, +            if (!photoViewers.contains(photoViewer)) {, +    }, +, +, +        final Glide glide = Glide.get();, +        if (!glide.isImageManagerSet()) {, +            File cacheDir = ImageManager.getPhotoCacheDir(this, CACHE_NAME);, +                return FlickrPhotoGrid.newInstance(pageSize);, +                return FlickrPhotoGrid.newInstance(pageSize);]
[+++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +import android.content.Context;, +  private Context context;, +  public ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool) {, +    this(context, bitmapPool, FACTORY);, +  ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool, Factory factory) {, +    this.context = context;, +    Resource<Bitmap> transformedResource =, +        transformation.transform(, +            context, bitmapResource, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +import android.content.Context;, +  private Context context;, +  public ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool) {, +    this(context, bitmapPool, FACTORY);, +  ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool, Factory factory) {, +    this.context = context;, +    Resource<Bitmap> transformedResource =, +        transformation.transform(, +            context, bitmapResource, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import android.app.Application;, +import android.content.Context;, +    Application context = RuntimeEnvironment.application;, +, +    when(frameTransformation.transform(anyContext(), any(Resource.class), anyInt(), anyInt())), +    encoder = new ReEncodingGifResourceEncoder(context, mock(BitmapPool.class), factory);, +    file = new File(context.getCacheDir(), "test");, +    when(frameTransformation.transform(, +        anyContext(), eq(frameResource), eq(expectedWidth), eq(expectedHeight))), +    when(frameTransformation.transform(anyContext(), eq(frameResource), anyInt(), anyInt())), +    when(frameTransformation.transform(anyContext(), eq(frameResource), anyInt(), anyInt())), +    when(frameTransformation.transform(anyContext(), eq(frameResource), anyInt(), anyInt())), +, +  private static Context anyContext() {, +    return any(Context.class);, +  }, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +import android.content.Context;, +  private Context context;, +  public ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool) {, +    this(context, bitmapPool, FACTORY);, +  ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool, Factory factory) {, +    this.context = context;, +    Resource<Bitmap> transformedResource =, +        transformation.transform(, +            context, bitmapResource, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import android.app.Application;, +import android.content.Context;, +    Application context = RuntimeEnvironment.application;, +, +    when(frameTransformation.transform(anyContext(), any(Resource.class), anyInt(), anyInt())), +    encoder = new ReEncodingGifResourceEncoder(context, mock(BitmapPool.class), factory);, +    file = new File(context.getCacheDir(), "test");, +    when(frameTransformation.transform(, +        anyContext(), eq(frameResource), eq(expectedWidth), eq(expectedHeight))), +    when(frameTransformation.transform(anyContext(), eq(frameResource), anyInt(), anyInt())), +    when(frameTransformation.transform(anyContext(), eq(frameResource), anyInt(), anyInt())), +    when(frameTransformation.transform(anyContext(), eq(frameResource), anyInt(), anyInt())), +, +  private static Context anyContext() {, +    return any(Context.class);, +  }, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +  @VisibleForTesting, +  public static void init(Glide glide) {, +    Glide.glide = glide;, +  }, +, +  @VisibleForTesting, +  public static void tearDown() {, +    glide = null;, +  }, +, +    glide = builder.build(applicationContext);, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +import android.content.Context;, +  private Context context;, +  public ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool) {, +    this(context, bitmapPool, FACTORY);, +  ReEncodingGifResourceEncoder(Context context, BitmapPool bitmapPool, Factory factory) {, +    this.context = context;, +    Resource<Bitmap> transformedResource =, +        transformation.transform(, +            context, bitmapResource, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import android.app.Application;, +import android.content.Context;, +    Application context = RuntimeEnvironment.application;, +, +    when(frameTransformation.transform(anyContext(), any(Resource.class), anyInt(), anyInt())), +    encoder = new ReEncodingGifResourceEncoder(context, mock(BitmapPool.class), factory);, +    file = new File(context.getCacheDir(), "test");, +    when(frameTransformation.transform(, +        anyContext(), eq(frameResource), eq(expectedWidth), eq(expectedHeight))), +    when(frameTransformation.transform(anyContext(), eq(frameResource), anyInt(), anyInt())), +    when(frameTransformation.transform(anyContext(), eq(frameResource), anyInt(), anyInt())), +    when(frameTransformation.transform(anyContext(), eq(frameResource), anyInt(), anyInt())), +]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, +        requestBuilderGenerator.generate(, +            generatedCodePackageName, indexedClassNames.extensions, generatedRequestOptions);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, +        requestBuilderGenerator.generate(, +            generatedCodePackageName, indexedClassNames.extensions, generatedRequestOptions);, +++ /dev/null, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, +        requestBuilderGenerator.generate(, +            generatedCodePackageName, indexedClassNames.extensions, generatedRequestOptions);, +++ /dev/null, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +    validateGlideOptionAnnotations(executableElement);, +  private void validateGlideOptionAnnotations(ExecutableElement executableElement) {, +    validateGlideTypeAnnotations(executableElement);, +  private void validateGlideTypeAnnotations(ExecutableElement executableElement) {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, +        requestBuilderGenerator.generate(, +            generatedCodePackageName, indexedClassNames.extensions, generatedRequestOptions);, +++ /dev/null, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +    validateGlideOptionAnnotations(executableElement);, +  private void validateGlideOptionAnnotations(ExecutableElement executableElement) {, +    validateGlideTypeAnnotations(executableElement);, +  private void validateGlideTypeAnnotations(ExecutableElement executableElement) {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, +        requestBuilderGenerator.generate(, +            generatedCodePackageName, indexedClassNames.extensions, generatedRequestOptions);, +++ /dev/null, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +    validateGlideOptionAnnotations(executableElement);, +  private void validateGlideOptionAnnotations(ExecutableElement executableElement) {, +    validateGlideTypeAnnotations(executableElement);, +  private void validateGlideTypeAnnotations(ExecutableElement executableElement) {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +import com.google.common.base.Predicate;, +import java.util.ArrayList;, +import java.util.Collections;, +import java.util.HashSet;, +import javax.annotation.Nullable;, +  private ClassName requestOptionsClassName;, +  private ParameterizedTypeName generatedRequestBuilderOfTranscodeType;, +  TypeSpec generate(, +      String generatedCodePackageName,, +      Set<String> glideExtensionClassNames,, +      @Nullable TypeSpec generatedOptions) {, +    if (generatedOptions != null) {, +      requestOptionsClassName =, +          ClassName.get(generatedCodePackageName, generatedOptions.name);, +    } else {, +      requestOptionsClassName =, +          ClassName.get(, +              RequestOptionsGenerator.REQUEST_OPTIONS_PACKAGE_NAME,, +              RequestOptionsGenerator.BASE_REQUEST_OPTIONS_SIMPLE_NAME);, +    }, +, +    generatedRequestBuilderOfTranscodeType =, +            generateGeneratedRequestOptionsEquivalents(, +                requestOptionsExtensionMethods, generatedOptions)), +  /**, +   * Generates methods with equivalent names and arguments to methods annotated with, +   * {@link GlideOption} in, +   * {@link com.bumptech.glide.annotation.GlideExtension}s that return our generated, +   * {@code com.bumptech.glide.RequestBuilder} subclass., +   */, +  private List<MethodSpec> generateGeneratedRequestOptionsEquivalents(, +      final List<MethodSpec> requestOptionsExtensionMethods,, +      @Nullable final TypeSpec generatedOptions) {, +    if (generatedOptions == null) {, +      return Collections.emptyList();, +    }, +    return FluentIterable, +        .from(generatedOptions.methodSpecs), +        .filter(new Predicate<MethodSpec>() {, +          @Override, +          public boolean apply(MethodSpec input) {, +            return isUsefulGeneratedRequestOption(requestOptionsExtensionMethods, input);, +          }, +        }), +        .transform(new Function<MethodSpec, MethodSpec>() {, +          @Override, +          public MethodSpec apply(MethodSpec input) {, +            return generateGeneratedRequestOptionEquivalent(input);, +          }, +        }), +        .toList();, +  }, +, +, +  /**, +   * Returns {@code true} if the given {@link MethodSpec} is a useful method to have in our, +   * {@code com.bumptech.glide.RequestBuilder} subclass., +   *, +   * <p>Only newly generated methods will be included in the generated, +   * {@code com.bumptech.glide.request.BaseRequestBuilder} subclass, so we only have to filter out, +   * methods that override other methods to avoid duplicates., +   */, +  private boolean isUsefulGeneratedRequestOption(]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +   * @see RequestManager#clear(Target), +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +   * @see RequestManager#clear(Target), +++ b/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java, + * {@link com.bumptech.glide.RequestManager#clear(Target)}.</p>]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java]
[+++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MINOR=6, +VERSION_CODE=9, +++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MINOR=6, +VERSION_CODE=9, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.3.0-SNAPSHOT, +VERSION_MINOR=3, +VERSION_CODE=5, +++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MINOR=6, +VERSION_CODE=9, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.3.0-SNAPSHOT, +VERSION_MINOR=3, +VERSION_CODE=5, +++ b/integration/volley/gradle.properties, +VERSION_NAME=1.3.0-SNAPSHOT, +VERSION_MINOR=3, +VERSION_CODE=5]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineBuilder.java, +            HandlerThread handlerThread = new HandlerThread("EngineThread") {, +                @Override, +                public void run() {, +                    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);, +                    super.run();, +                }, +            };, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineBuilder.java, +            HandlerThread handlerThread = new HandlerThread("EngineThread") {, +                @Override, +                public void run() {, +                    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);, +                    super.run();, +                }, +            };, +++ b/library/src/main/java/com/bumptech/glide/load/engine/SourceResourceRunner.java, +        if (fetcher != null) {, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineBuilder.java, +            HandlerThread handlerThread = new HandlerThread("EngineThread") {, +                @Override, +                public void run() {, +                    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);, +                    super.run();, +                }, +            };, +++ b/library/src/main/java/com/bumptech/glide/load/engine/SourceResourceRunner.java, +        if (fetcher != null) {, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/FifoPriorityThreadPoolExecutor.java, +            final Thread result = new Thread(runnable, "image-manager-resize-" + threadNum) {, +                @Override, +                public void run() {, +                    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);, +                    super.run();, +                }, +            };, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineBuilder.java, +            HandlerThread handlerThread = new HandlerThread("EngineThread") {, +                @Override, +                public void run() {, +                    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);, +                    super.run();, +                }, +            };, +++ b/library/src/main/java/com/bumptech/glide/load/engine/SourceResourceRunner.java, +        if (fetcher != null) {, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/FifoPriorityThreadPoolExecutor.java, +            final Thread result = new Thread(runnable, "image-manager-resize-" + threadNum) {, +                @Override, +                public void run() {, +                    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);, +                    super.run();, +                }, +            };, +++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java, +import android.text.TextUtils;, +, +    private String stringUrl;, +    private URL url;, +        if (url == null) {, +            url = new URL(stringUrl);, +        }, +        return url;, +        if (TextUtils.isEmpty(stringUrl)) {, +            stringUrl = url.toString();, +        }, +        return stringUrl;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineBuilder.java, +            HandlerThread handlerThread = new HandlerThread("EngineThread") {, +                @Override, +                public void run() {, +                    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);, +                    super.run();, +                }, +            };, +++ b/library/src/main/java/com/bumptech/glide/load/engine/SourceResourceRunner.java, +        if (fetcher != null) {, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/FifoPriorityThreadPoolExecutor.java, +            final Thread result = new Thread(runnable, "image-manager-resize-" + threadNum) {, +                @Override, +                public void run() {, +                    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);, +                    super.run();, +                }, +            };, +++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java, +import android.text.TextUtils;, +, +    private String stringUrl;, +    private URL url;, +        if (url == null) {, +            url = new URL(stringUrl);, +        }, +        return url;, +        if (TextUtils.isEmpty(stringUrl)) {, +            stringUrl = url.toString();]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsOverrideGenerator.java, +    if (methodToOverride.getSimpleName().toString().contains("transform"), +        && methodToOverride.isVarArgs()) {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsOverrideGenerator.java, +    if (methodToOverride.getSimpleName().toString().contains("transform"), +        && methodToOverride.isVarArgs()) {, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java, +import java.lang.Deprecated;, +  public final GlideOptions transform(@NonNull Transformation<Bitmap>... transformations) {, +    return (GlideOptions) super.transform(transformations);, +  }, +, +  @Override, +  @SafeVarargs, +  @SuppressWarnings("varargs"), +  @Deprecated, +  @NonNull, +  @CheckResult, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsOverrideGenerator.java, +    if (methodToOverride.getSimpleName().toString().contains("transform"), +        && methodToOverride.isVarArgs()) {, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java, +import java.lang.Deprecated;, +  public final GlideOptions transform(@NonNull Transformation<Bitmap>... transformations) {, +    return (GlideOptions) super.transform(transformations);, +  }, +, +  @Override, +  @SafeVarargs, +  @SuppressWarnings("varargs"), +  @Deprecated, +  @NonNull, +  @CheckResult, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java, +   * @see GlideOptions#transform(Transformation<Bitmap>[]), +   */, +  @NonNull, +  @CheckResult, +  @SuppressWarnings({, +      "unchecked",, +      "varargs", +  }), +  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap>... transformations) {, +    return (GlideRequest<TranscodeType>) super.transform(transformations);, +  }, +, +  /**, +  @Deprecated, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsOverrideGenerator.java, +    if (methodToOverride.getSimpleName().toString().contains("transform"), +        && methodToOverride.isVarArgs()) {, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java, +import java.lang.Deprecated;, +  public final GlideOptions transform(@NonNull Transformation<Bitmap>... transformations) {, +    return (GlideOptions) super.transform(transformations);, +  }, +, +  @Override, +  @SafeVarargs, +  @SuppressWarnings("varargs"), +  @Deprecated, +  @NonNull, +  @CheckResult, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java, +   * @see GlideOptions#transform(Transformation<Bitmap>[]), +   */, +  @NonNull, +  @CheckResult, +  @SuppressWarnings({, +      "unchecked",, +      "varargs", +  }), +  public GlideRequest<TranscodeType> transform(@NonNull Transformation<Bitmap>... transformations) {, +    return (GlideRequest<TranscodeType>) super.transform(transformations);, +  }, +, +  /**, +  @Deprecated, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java, +import java.lang.Deprecated;, +  public final GlideOptions transform(@NonNull Transformation<Bitmap>... transformations) {, +    return (GlideOptions) super.transform(transformations);, +  }, +, +  @Override, +  @SafeVarargs, +  @SuppressWarnings("varargs"), +  @Deprecated, +  @NonNull, +  @CheckResult, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsOverrideGenerator.java, +    if (methodToOverride.getSimpleName().toString().contains("transform"), +        && methodToOverride.isVarArgs()) {, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java, +import java.lang.Deprecated;, +  public final GlideOptions transform(@NonNull Transformation<Bitmap>... transformations) {, +    return (GlideOptions) super.transform(transformations);, +  }, +, +  @Override]
[+++ b/library/findbugs-exclude.xml, +    <!-- We make a best effort attempt to acquire the cpu count from a fixed path -->, +    <Match>, +      <Class name="com.bumptech.glide.load.engine.executor.GlideExecutor" />, +      <Bug pattern="DMI_HARDCODED_ABSOLUTE_FILENAME" />, +    </Match>, +, +++ b/library/findbugs-exclude.xml, +    <!-- We make a best effort attempt to acquire the cpu count from a fixed path -->, +    <Match>, +      <Class name="com.bumptech.glide.load.engine.executor.GlideExecutor" />, +      <Bug pattern="DMI_HARDCODED_ABSOLUTE_FILENAME" />, +    </Match>, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java, +    File[] cpus = null;, +    try {, +      cpus = cpuInfo.listFiles(new FilenameFilter() {, +    } catch (Throwable t) {, +      if (Log.isLoggable(TAG, Log.ERROR)) {, +        Log.e(TAG, "Failed to calculate accurate cpu count", t);, +      }, +    }, +    private int threadNum;, +    public synchronized Thread newThread(@NonNull Runnable runnable) {]
[+++ b/library/libs/android-support-v4.jar, +++ b/library/libs/android-support-v4.jar, +++ b/library/pom.xml, +++ b/library/libs/android-support-v4.jar, +++ b/library/pom.xml, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.manager.RequestManager;, +            Class<TranscodeType> transcodeClass, Glide glide, RequestManager requestManager) {, +        super(context, model, streamLoadProvider, transcodeClass, glide, requestManager);, +++ b/library/libs/android-support-v4.jar, +++ b/library/pom.xml, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.manager.RequestManager;, +            Class<TranscodeType> transcodeClass, Glide glide, RequestManager requestManager) {, +        super(context, model, streamLoadProvider, transcodeClass, glide, requestManager);, +++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +import com.bumptech.glide.manager.RequestManager;, +    private RequestManager requestManager;, +            Glide glide, RequestManager requestManager) {, +                glide, requestManager);, +        this.requestManager = requestManager;, +                transcodeClass, glide, requestManager);, +++ b/library/libs/android-support-v4.jar, +++ b/library/pom.xml, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.manager.RequestManager;, +            Class<TranscodeType> transcodeClass, Glide glide, RequestManager requestManager) {, +        super(context, model, streamLoadProvider, transcodeClass, glide, requestManager);, +++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +import com.bumptech.glide.manager.RequestManager;, +    private RequestManager requestManager;, +            Glide glide, RequestManager requestManager) {, +                glide, requestManager);, +        this.requestManager = requestManager;, +                transcodeClass, glide, requestManager);, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.manager.RequestManager;, +            LoadProvider<ModelType, ImageVideoWrapper, GifBitmapWrapper, Drawable> loadProvider, Glide glide,, +            RequestManager requestManager) {, +        super(context, model, loadProvider, Drawable.class, glide, requestManager);, +++ b/library/libs/android-support-v4.jar, +++ b/library/pom.xml, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.manager.RequestManager;, +            Class<TranscodeType> transcodeClass, Glide glide, RequestManager requestManager) {, +        super(context, model, streamLoadProvider, transcodeClass, glide, requestManager);, +++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +import com.bumptech.glide.manager.RequestManager;, +    private RequestManager requestManager;, +            Glide glide, RequestManager requestManager) {, +                glide, requestManager);, +        this.requestManager = requestManager;, +                transcodeClass, glide, requestManager);, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.manager.RequestManager;, +            LoadProvider<ModelType, ImageVideoWrapper, GifBitmapWrapper, Drawable> loadProvider, Glide glide,, +            RequestManager requestManager) {, +        super(context, model, loadProvider, Drawable.class, glide, requestManager);, +++ b/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java, +import com.bumptech.glide.manager.RequestManager;, +    private RequestManager requestManager;, +            ModelLoader<A, ParcelFileDescriptor> fileDescriptorModelLoader, Context context, Glide glide,, +            RequestManager requestManager) {, +                buildProvider(glide, streamModelLoader, fileDescriptorModelLoader, GifBitmapWrapper.class,, +                        Drawable.class, null),, +                glide, requestManager);, +        this.requestManager = requestManager;, +        return new BitmapTypeRequest<A>(context, model, streamModelLoader, fileDescriptorModelLoader, glide,, +                requestManager);, +        return new GifTypeRequest<A>(context, model, streamModelLoader, glide, requestManager);, +++ b/library/libs/android-support-v4.jar, +++ b/library/pom.xml, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.manager.RequestManager;, +            Class<TranscodeType> transcodeClass, Glide glide, RequestManager requestManager) {, +        super(context, model, streamLoadProvider, transcodeClass, glide, requestManager);, +++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +import com.bumptech.glide.manager.RequestManager;, +    private RequestManager requestManager;, +            Glide glide, RequestManager requestManager) {, +                glide, requestManager);, +        this.requestManager = requestManager;, +                transcodeClass, glide, requestManager);, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.manager.RequestManager;, +            LoadProvider<ModelType, ImageVideoWrapper, GifBitmapWrapper, Drawable> loadProvider, Glide glide,, +            RequestManager requestManager) {, +        super(context, model, loadProvider, Drawable.class, glide, requestManager);, +++ b/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java, +import com.bumptech.glide.manager.RequestManager;, +    private RequestManager requestManager;, +            ModelLoader<A, ParcelFileDescriptor> fileDescriptorModelLoader, Context context, Glide glide,, +            RequestManager requestManager) {, +                buildProvider(glide, streamModelLoader, fileDescriptorModelLoader, GifBitmapWrapper.class,, +                        Drawable.class, null),, +                glide, requestManager);, +        this.requestManager = requestManager;, +        return new BitmapTypeRequest<A>(context, model, streamModelLoader, fileDescriptorModelLoader, glide,, +                requestManager);, +        return new GifTypeRequest<A>(context, model, streamModelLoader, glide, requestManager);]
[+++ b/.gitignore, +samples/flickr/gen, +samples/flickr/out, +samples/flickr/bin, +*.keystore, +, +++ b/.gitignore, +samples/flickr/gen, +samples/flickr/out, +samples/flickr/bin, +*.keystore, +, +++ b/samples/flickr/AndroidManifest.xml, +  package="com.bumptech.glide.samples.flickr", +  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="18" />, +++ b/.gitignore, +samples/flickr/gen, +samples/flickr/out, +samples/flickr/bin, +*.keystore, +, +++ b/samples/flickr/AndroidManifest.xml, +  package="com.bumptech.glide.samples.flickr", +  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="18" />, +++ b/samples/flickr/ant.properties, +key.store=glide-release-key.keystore, +key.alias=flickr, +++ b/.gitignore, +samples/flickr/gen, +samples/flickr/out, +samples/flickr/bin, +*.keystore, +, +++ b/samples/flickr/AndroidManifest.xml, +  package="com.bumptech.glide.samples.flickr", +  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="18" />, +++ b/samples/flickr/ant.properties, +key.store=glide-release-key.keystore, +key.alias=flickr, +++ b/samples/flickr/build.xml, +<project name="glide-flickr-demo" default="help">, +++ b/.gitignore, +samples/flickr/gen, +samples/flickr/out, +samples/flickr/bin, +*.keystore, +, +++ b/samples/flickr/AndroidManifest.xml, +  package="com.bumptech.glide.samples.flickr", +  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="18" />, +++ b/samples/flickr/ant.properties, +key.store=glide-release-key.keystore, +key.alias=flickr, +++ b/samples/flickr/build.xml, +<project name="glide-flickr-demo" default="help">, +++ /dev/null, +++ b/.gitignore, +samples/flickr/gen, +samples/flickr/out, +samples/flickr/bin, +*.keystore, +, +++ b/samples/flickr/AndroidManifest.xml, +  package="com.bumptech.glide.samples.flickr", +  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="18" />, +++ b/samples/flickr/ant.properties, +key.store=glide-release-key.keystore, +key.alias=flickr, +++ b/samples/flickr/build.xml, +<project name="glide-flickr-demo" default="help">, +++ /dev/null, +++ b/samples/flickr/project.properties, +target=android-18, +android.library.reference.1=ActionBarSherlock/library, +++ b/.gitignore, +samples/flickr/gen, +samples/flickr/out, +samples/flickr/bin, +*.keystore, +, +++ b/samples/flickr/AndroidManifest.xml, +  package="com.bumptech.glide.samples.flickr", +  <uses-sdk android:minSdkVersion="9" android:targetSdkVersion="18" />, +++ b/samples/flickr/ant.properties, +key.store=glide-release-key.keystore, +key.alias=flickr, +++ b/samples/flickr/build.xml, +<project name="glide-flickr-demo" default="help">, +++ /dev/null, +++ b/samples/flickr/project.properties, +target=android-18, +android.library.reference.1=ActionBarSherlock/library, +++ b/samples/flickr/res/values/strings.xml, +    <string name="app_name">Glide Flickr Demo</string>, +++ b/.gitignore, +samples/flickr/gen, +samples/flickr/out, +samples/flickr/bin, +*.keystore, +]
[+++ b/samples/flickr/res/layout/flickr_search_activity.xml, +++ b/samples/flickr/res/layout/flickr_search_activity.xml, +++ b/samples/flickr/res/values/strings.xml, +++ b/samples/flickr/res/layout/flickr_search_activity.xml, +++ b/samples/flickr/res/values/strings.xml, +++ b/samples/flickr/src/com/bumptech/flickr/FlickrSearchActivity.java, +++ b/samples/flickr/res/layout/flickr_search_activity.xml, +++ b/samples/flickr/res/values/strings.xml, +++ b/samples/flickr/src/com/bumptech/flickr/FlickrSearchActivity.java, +++ b/samples/flickr/src/com/bumptech/flickr/api/Api.java, +        Log.d("API: searching");, +                error.printStackTrace();]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +        Resource resource = mock(Resource.class);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +        Resource resource = mock(Resource.class);, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +    @SuppressWarnings("unchecked"), +    @SuppressWarnings("unchecked"), +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +        Resource resource = mock(Resource.class);, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +    @SuppressWarnings("unchecked"), +    @SuppressWarnings("unchecked"), +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +        return animate(new ViewAnimation.ViewAnimationFactory<TranscodeType>(context, animationId));, +        return animate(new ViewAnimation.ViewAnimationFactory<TranscodeType>(animation));, +        return animate(new ViewPropertyAnimation.ViewPropertyAnimationFactory<TranscodeType>(animator));, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +        Resource resource = mock(Resource.class);, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +    @SuppressWarnings("unchecked"), +    @SuppressWarnings("unchecked"), +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +        return animate(new ViewAnimation.ViewAnimationFactory<TranscodeType>(context, animationId));, +        return animate(new ViewAnimation.ViewAnimationFactory<TranscodeType>(animation));, +        return animate(new ViewPropertyAnimation.ViewPropertyAnimationFactory<TranscodeType>(animator));, +++ b/library/src/main/java/com/bumptech/glide/GenericTranscodeRequest.java, +            transcoder = (ResourceTranscoder<Z, R>) UnitTranscoder.get();, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +        Resource resource = mock(Resource.class);, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +    @SuppressWarnings("unchecked"), +    @SuppressWarnings("unchecked"), +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +        return animate(new ViewAnimation.ViewAnimationFactory<TranscodeType>(context, animationId));, +        return animate(new ViewAnimation.ViewAnimationFactory<TranscodeType>(animation));, +        return animate(new ViewPropertyAnimation.ViewPropertyAnimationFactory<TranscodeType>(animator));, +++ b/library/src/main/java/com/bumptech/glide/GenericTranscodeRequest.java, +            transcoder = (ResourceTranscoder<Z, R>) UnitTranscoder.get();, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    public static void clear(Target<?> target) {, +    public static void clear(FutureTarget<?> target) {, +        Target<?> viewTarget = new ClearTarget(view);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +        Resource resource = mock(Resource.class);, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +    @SuppressWarnings("unchecked"), +    @SuppressWarnings("unchecked"), +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +        return animate(new ViewAnimation.ViewAnimationFactory<TranscodeType>(context, animationId));, +        return animate(new ViewAnimation.ViewAnimationFactory<TranscodeType>(animation));, +        return animate(new ViewPropertyAnimation.ViewPropertyAnimationFactory<TranscodeType>(animator));, +++ b/library/src/main/java/com/bumptech/glide/GenericTranscodeRequest.java, +            transcoder = (ResourceTranscoder<Z, R>) UnitTranscoder.get();, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    public static void clear(Target<?> target) {, +    public static void clear(FutureTarget<?> target) {, +        Target<?> viewTarget = new ClearTarget(view);, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +    @SuppressWarnings("rawtypes"), +    @SuppressWarnings("unchecked"), +    private static class PreloadTarget extends BaseTarget<Object> {, +        public void onResourceReady(Object resource, GlideAnimation<? super Object> glideAnimation) {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +        Resource resource = mock(Resource.class);, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +    @SuppressWarnings("unchecked"), +    @SuppressWarnings("unchecked"), +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +        return animate(new ViewAnimation.ViewAnimationFactory<TranscodeType>(context, animationId));, +        return animate(new ViewAnimation.ViewAnimationFactory<TranscodeType>(animation));, +        return animate(new ViewPropertyAnimation.ViewPropertyAnimationFactory<TranscodeType>(animator));, +++ b/library/src/main/java/com/bumptech/glide/GenericTranscodeRequest.java, +            transcoder = (ResourceTranscoder<Z, R>) UnitTranscoder.get();, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    public static void clear(Target<?> target) {, +    public static void clear(FutureTarget<?> target) {, +        Target<?> viewTarget = new ClearTarget(view);, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +    @SuppressWarnings("rawtypes"), +    @SuppressWarnings("unchecked"), +    private static class PreloadTarget extends BaseTarget<Object> {, +        public void onResourceReady(Object resource, GlideAnimation<? super Object> glideAnimation) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +@SuppressWarnings("rawtypes"), +    @SuppressWarnings("unchecked"), +    public void onEngineJobComplete(Key key, Resource<?> resource) {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +        Resource resource = mock(Resource.class);, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +    @SuppressWarnings("unchecked"), +    @SuppressWarnings("unchecked"), +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +        return animate(new ViewAnimation.ViewAnimationFactory<TranscodeType>(context, animationId));, +        return animate(new ViewAnimation.ViewAnimationFactory<TranscodeType>(animation));, +        return animate(new ViewPropertyAnimation.ViewPropertyAnimationFactory<TranscodeType>(animator));, +++ b/library/src/main/java/com/bumptech/glide/GenericTranscodeRequest.java, +            transcoder = (ResourceTranscoder<Z, R>) UnitTranscoder.get();, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    public static void clear(Target<?> target) {, +    public static void clear(FutureTarget<?> target) {]
[+++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java, +  private int hashCode;, +, +    if (hashCode == 0) {, +      hashCode = getCacheKey().hashCode();, +    }]
[+++ b/gradle.properties, +VERSION_NAME=3.3.0-SNAPSHOT]
[+++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.6.1', +    <version>3.6.1</version>, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.6.1', +    <version>3.6.1</version>, +++ b/gradle.properties, +VERSION_CODE=12, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.6.1', +    <version>3.6.1</version>, +++ b/gradle.properties, +VERSION_CODE=12, +++ b/integration/gifencoder/build.gradle, +        versionCode = VERSION_CODE as int, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.6.1', +    <version>3.6.1</version>, +++ b/gradle.properties, +VERSION_CODE=12, +++ b/integration/gifencoder/build.gradle, +        versionCode = VERSION_CODE as int, +++ b/integration/gifencoder/gradle.properties, +VERSION_CODE=8, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.6.1', +    <version>3.6.1</version>, +++ b/gradle.properties, +VERSION_CODE=12, +++ b/integration/gifencoder/build.gradle, +        versionCode = VERSION_CODE as int, +++ b/integration/gifencoder/gradle.properties, +VERSION_CODE=8, +++ b/integration/okhttp/build.gradle, +        versionCode VERSION_CODE as int, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.6.1', +    <version>3.6.1</version>, +++ b/gradle.properties, +VERSION_CODE=12, +++ b/integration/gifencoder/build.gradle, +        versionCode = VERSION_CODE as int, +++ b/integration/gifencoder/gradle.properties, +VERSION_CODE=8, +++ b/integration/okhttp/build.gradle, +        versionCode VERSION_CODE as int, +++ b/integration/okhttp/gradle.properties, +VERSION_CODE=8, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.6.1', +    <version>3.6.1</version>, +++ b/gradle.properties, +VERSION_CODE=12, +++ b/integration/gifencoder/build.gradle, +        versionCode = VERSION_CODE as int, +++ b/integration/gifencoder/gradle.properties, +VERSION_CODE=8, +++ b/integration/okhttp/build.gradle, +        versionCode VERSION_CODE as int, +++ b/integration/okhttp/gradle.properties, +VERSION_CODE=8, +++ b/integration/okhttp3/build.gradle, +        versionCode VERSION_CODE as int, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.6.1', +    <version>3.6.1</version>, +++ b/gradle.properties, +VERSION_CODE=12, +++ b/integration/gifencoder/build.gradle, +        versionCode = VERSION_CODE as int, +++ b/integration/gifencoder/gradle.properties, +VERSION_CODE=8, +++ b/integration/okhttp/build.gradle, +        versionCode VERSION_CODE as int, +++ b/integration/okhttp/gradle.properties, +VERSION_CODE=8, +++ b/integration/okhttp3/build.gradle, +        versionCode VERSION_CODE as int, +++ b/integration/okhttp3/gradle.properties, +VERSION_CODE=8, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.6.1', +    <version>3.6.1</version>, +++ b/gradle.properties, +VERSION_CODE=12, +++ b/integration/gifencoder/build.gradle, +        versionCode = VERSION_CODE as int, +++ b/integration/gifencoder/gradle.properties, +VERSION_CODE=8, +++ b/integration/okhttp/build.gradle, +        versionCode VERSION_CODE as int, +++ b/integration/okhttp/gradle.properties, +VERSION_CODE=8, +++ b/integration/okhttp3/build.gradle, +        versionCode VERSION_CODE as int, +++ b/integration/okhttp3/gradle.properties, +VERSION_CODE=8, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +    client.newCall(request).enqueue(new okhttp3.Callback() {, +    // TODO: call cancel on the client when this method is called on a background thread. See #257]
[+++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java, + * {@link #updateDiskCacheKey(java.security.MessageDigest)}} correctly., +   * <p>If the original resource object is not returned, the original resource will be, +   * be copied into the transformed resource., +   *, +   * <p>If a Transformation is updated, {@link #equals(Object)}, {@link #hashCode()}, and, +   * {@link #updateDiskCacheKey(java.security.MessageDigest)} should all change. If you're using a, +   * simple String key an easy way to do this is to append a version number to your key. Failing to, +   * do so will mean users may see images loaded from cache that had the old version of the, +   * Transformation applied. Changing the return values of those methods will ensure that the cache, +   * key has changed and therefore that any cached resources will be re-generated using the updated, +   * Transformation., +   *, +   * <p>During development you may need to either using {@link, +   * com.bumptech.glide.load.engine.DiskCacheStrategy#NONE} or make sure {@link, +   * #updateDiskCacheKey(java.security.MessageDigest)} changes each time you make a change to the, +   * Transformation. Otherwise the resource you request may be loaded from disk cache and your, +   * Transformation may not be called.]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private final DeferredEncodeManager<?> deferredEncodeManager = new DeferredEncodeManager<>();, +  private final ReleaseManager releaseManager = new ReleaseManager(deferredEncodeManager);, +, +  private RunReason runReason;, +  private long startFetchTime;, +, +  private Key currentAttemptingKey;, +  private volatile DataFetcherGenerator currentGenerator;, +  private volatile boolean isCallbackNotified;, +    this.runReason = RunReason.INITIALIZE;, +  /**, +   * Called when this object is no longer in use externally., +   */, +    if (releaseManager.release()) {, +      releaseInternal();, +    }, +  }, +, +  private void onEncodeComplete() {, +    if (releaseManager.onEncodeComplete()) {, +      releaseInternal();, +    }, +  }, +, +  private void releaseInternal() {, +    releaseManager.reset();, +    deferredEncodeManager.clear();, +    currentGenerator = null;, +    DataFetcherGenerator local = currentGenerator;, +        Log.d(TAG, "DecodeJob threw unexpectedly", +            + ", isCancelled: " + isCancelled, +            + ", stage: " + stage, e);, +      // When we're encoding we've already notified our callback and it isn't safe to do so again., +      if (stage != Stage.ENCODE) {, +      }, +        currentGenerator = getNextGenerator();, +      case FINISHED:, +        return null;, +    while (!isCancelled && currentGenerator != null, +        && !(isStarted = currentGenerator.startNext())) {, +      currentGenerator = getNextGenerator();, +    if ((stage == Stage.FINISHED || isCancelled) && !isStarted) {, +      case SOURCE:, +      case FINISHED:, +        return Stage.FINISHED;, +        throw new IllegalArgumentException("Unrecognized stage: " + current);, +      notifyEncodeAndRelease(resource);, +  private void notifyEncodeAndRelease(Resource<R> resource) {, +    Resource<R> result = resource;, +    LockedResource<R> lockedResource = null;, +    if (deferredEncodeManager.hasResourceToEncode()) {, +      lockedResource = LockedResource.obtain(resource);, +      result = lockedResource;, +    }, +, +    notifyComplete(result);, +, +    stage = Stage.ENCODE;, +    try {, +      if (deferredEncodeManager.hasResourceToEncode()) {, +        deferredEncodeManager.encode(diskCacheProvider, options);, +      }, +    } finally {, +      if (lockedResource != null) {, +        lockedResource.unlock();, +      }, +      onEncodeComplete();, +    }, +      Resource<Z> result = transformed;, +        LockedResource<Z> lockedResult = LockedResource.obtain(transformed);, +        deferredEncodeManager.init(key, encoder, lockedResult);, +        result = lockedResult;, +      return result;, +  private static class ReleaseManager {, +    private final DeferredEncodeManager<?> encodeManager;, +    private boolean isReleased;, +    private boolean isEncodeComplete;, +, +    ReleaseManager(DeferredEncodeManager<?> encodeManager) {, +      this.encodeManager = encodeManager;, +    }, +, +    synchronized boolean release() {, +      isReleased = true;, +      return isComplete();, +    }, +, +    synchronized boolean onEncodeComplete() {, +      isEncodeComplete = true;, +      return isComplete();, +    }, +, +    synchronized void reset() {, +      isEncodeComplete = false;, +      isReleased = false;, +    }, +, +    private boolean isComplete() {, +      return (!encodeManager.hasResourceToEncode() || isEncodeComplete) && isReleased;]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +  private static final String FULLY_QUALIFIED_NON_NULL_CLASS_NAME =, +      "android.support.annotation.NonNull";, +    if (!annotationNames.contains(FULLY_QUALIFIED_NON_NULL_CLASS_NAME)) {, +              + " is missing the " + FULLY_QUALIFIED_NON_NULL_CLASS_NAME + " annotation,", +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +  private static final String FULLY_QUALIFIED_NON_NULL_CLASS_NAME =, +      "android.support.annotation.NonNull";, +    if (!annotationNames.contains(FULLY_QUALIFIED_NON_NULL_CLASS_NAME)) {, +              + " is missing the " + FULLY_QUALIFIED_NON_NULL_CLASS_NAME + " annotation,", +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java, +    assertThat(compilation).hadWarningContaining("android.support.annotation.NonNull");, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +  private static final String FULLY_QUALIFIED_NON_NULL_CLASS_NAME =, +      "android.support.annotation.NonNull";, +    if (!annotationNames.contains(FULLY_QUALIFIED_NON_NULL_CLASS_NAME)) {, +              + " is missing the " + FULLY_QUALIFIED_NON_NULL_CLASS_NAME + " annotation,", +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideOptionsExtensionTest.java, +    assertThat(compilation).hadWarningContaining("android.support.annotation.NonNull");, +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java, +    assertThat(compilation).hadWarningContaining("android.support.annotation.NonNull");]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +    Bitmap.CompressFormat format = getFormat(bitmap, options);, +    TraceCompat.beginSection(, +        "encode: [" + bitmap.getWidth() + "x" + bitmap.getHeight() + "] " + format);, +            + " in " + LogTime.getElapsedMillis(start), +            + ", options format: " + options.get(COMPRESSION_FORMAT), +            + ", hasAlpha: " + bitmap.hasAlpha());]
[+++ b/.gitignore, +**/.idea/runConfigurations.xml]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/.gitmodules, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ b/.gitignore, +++ b/.gitmodules, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ b/LICENSE, +Copyright 2013 Bump Technologies, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY BUMP TECHNOLOGIES, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BUMP TECHNOLOGIES, INC. OR, +or implied, of Bump Technologies, Inc., +++ b/.gitignore, +++ b/.gitmodules, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ b/LICENSE, +Copyright 2013 Bump Technologies, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY BUMP TECHNOLOGIES, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BUMP TECHNOLOGIES, INC. OR, +or implied, of Bump Technologies, Inc., +++ b/Makefile, +	cd library/volley && ant clean && ant jar, +	cp library/volley/bin/volley.jar library/libs, +, +glide-minus-volley:, +	cd library && ant clean && ant glide-minus-volley, +, +++ b/.gitignore, +++ b/.gitmodules, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ b/LICENSE, +Copyright 2013 Bump Technologies, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY BUMP TECHNOLOGIES, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BUMP TECHNOLOGIES, INC. OR, +or implied, of Bump Technologies, Inc., +++ b/Makefile, +	cd library/volley && ant clean && ant jar, +	cp library/volley/bin/volley.jar library/libs, +, +glide-minus-volley:, +	cd library && ant clean && ant glide-minus-volley, +, +++ b/library/.gitignore, +++ b/.gitignore, +++ b/.gitmodules, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ b/LICENSE, +Copyright 2013 Bump Technologies, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY BUMP TECHNOLOGIES, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BUMP TECHNOLOGIES, INC. OR, +or implied, of Bump Technologies, Inc., +++ b/Makefile, +	cd library/volley && ant clean && ant jar, +	cp library/volley/bin/volley.jar library/libs, +, +glide-minus-volley:, +	cd library && ant clean && ant glide-minus-volley, +, +++ b/library/.gitignore, +++ b/library/AndroidManifest.xml, +          android:versionCode="6", +          android:versionName="2.0.4" >, +  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" />, +++ b/.gitignore, +++ b/.gitmodules, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ b/LICENSE, +Copyright 2013 Bump Technologies, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY BUMP TECHNOLOGIES, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BUMP TECHNOLOGIES, INC. OR, +or implied, of Bump Technologies, Inc., +++ b/Makefile, +	cd library/volley && ant clean && ant jar, +	cp library/volley/bin/volley.jar library/libs, +, +glide-minus-volley:]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java, +import android.content.Context;, +import com.bumptech.glide.Glide;, +import com.bumptech.glide.load.DecodeFormat;, +    public StreamBitmapDecoder(Context context) {, +        this(Glide.get(context).getBitmapPool());, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java, +import android.content.Context;, +import com.bumptech.glide.Glide;, +import com.bumptech.glide.load.DecodeFormat;, +    public StreamBitmapDecoder(Context context) {, +        this(Glide.get(context).getBitmapPool());, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifData.java, +        GifFrameManager frameManager = new GifFrameManager(context, gifDecoder, getFrameTransformation());, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java, +import android.content.Context;, +import com.bumptech.glide.Glide;, +import com.bumptech.glide.load.DecodeFormat;, +    public StreamBitmapDecoder(Context context) {, +        this(Glide.get(context).getBitmapPool());, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifData.java, +        GifFrameManager frameManager = new GifFrameManager(context, gifDecoder, getFrameTransformation());, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDataResource.java, +package com.bumptech.glide.load.resource.gif;, +, +import com.bumptech.glide.Resource;, +, +public class GifDataResource extends Resource<GifData> {, +    private GifData gifData;, +, +    public GifDataResource(GifData gifData) {, +        this.gifData = gifData;, +    }, +, +    @Override, +    public GifData get() {, +        return gifData;, +    }, +, +    @Override, +    public int getSize() {, +        return gifData.getByteSize();, +    }, +, +    @Override, +    protected void recycleInternal() {, +        gifData.recycle();, +    }, +}, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java, +import android.content.Context;, +import com.bumptech.glide.Glide;, +import com.bumptech.glide.load.DecodeFormat;, +    public StreamBitmapDecoder(Context context) {, +        this(Glide.get(context).getBitmapPool());, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifData.java, +        GifFrameManager frameManager = new GifFrameManager(context, gifDecoder, getFrameTransformation());, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDataResource.java, +package com.bumptech.glide.load.resource.gif;, +, +import com.bumptech.glide.Resource;, +, +public class GifDataResource extends Resource<GifData> {, +    private GifData gifData;, +, +    public GifDataResource(GifData gifData) {, +        this.gifData = gifData;, +    }, +, +    @Override, +    public GifData get() {, +        return gifData;, +    }, +, +    @Override, +    public int getSize() {, +        return gifData.getByteSize();, +    }, +, +    @Override, +    protected void recycleInternal() {, +        gifData.recycle();, +    }, +}, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +            frameManager.getNextFrame(this);, +        frameManager.getNextFrame(this);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java, +import android.content.Context;, +import com.bumptech.glide.Glide;, +import com.bumptech.glide.load.DecodeFormat;, +    public StreamBitmapDecoder(Context context) {]
[+++ b/.gitignore, +!.idea/inspectionProfiles, +!.idea/inspectionProfiles/Project_Default.xml, +, +++ b/.gitignore, +!.idea/inspectionProfiles, +!.idea/inspectionProfiles/Project_Default.xml, +, +++ b/.idea/inspectionProfiles/Project_Default.xml, +<component name="InspectionProjectProfileManager">, +  <profile version="1.0">, +    <option name="myName" value="Project Default" />, +    <inspection_tool class="SerializableHasSerialVersionUIDField" enabled="true" level="WARNING" enabled_by_default="true">, +      <option name="ignoreAnonymousInnerClasses" value="false" />, +      <option name="superClassString" value="" />, +    </inspection_tool>, +  </profile>, +</component>]
[+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java, +  public synchronized GlideRequests applyDefaultRequestOptions(@NonNull RequestOptions options) {, +  public synchronized GlideRequests setDefaultRequestOptions(@NonNull RequestOptions options) {, +  public synchronized GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java, +  public synchronized GlideRequests applyDefaultRequestOptions(@NonNull RequestOptions options) {, +  public synchronized GlideRequests setDefaultRequestOptions(@NonNull RequestOptions options) {, +  public synchronized GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java, +  public synchronized GlideRequests applyDefaultRequestOptions(@NonNull RequestOptions options) {, +  public synchronized GlideRequests setDefaultRequestOptions(@NonNull RequestOptions options) {, +  public synchronized GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java, +  public synchronized GlideRequests applyDefaultRequestOptions(@NonNull RequestOptions options) {, +  public synchronized GlideRequests setDefaultRequestOptions(@NonNull RequestOptions options) {, +  public synchronized GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java, +  public synchronized GlideRequests applyDefaultRequestOptions(@NonNull RequestOptions options) {, +  public synchronized GlideRequests setDefaultRequestOptions(@NonNull RequestOptions options) {, +  public synchronized GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import com.bumptech.glide.load.engine.executor.GlideExecutor;, +import com.bumptech.glide.load.engine.executor.MockGlideExecutor;, +  public void setUp() {, +    Glide.init(context, new GlideBuilder().setMemoryCache(new LruResourceCache(CACHE_SIZE_BYTES)));, +  public void submit_withPreviousRequestClearedFromMemory_completesFromDataDiskCache() {, +    // Clearing the future here can race with clearing the EngineResource held on to by EngineJob, +    // while it's notifying callbacks. Forcing all executors to use the same thread avoids the race, +    // by making our clear and EngineJob's clear run on the same thread., +    GlideExecutor mainThreadExecutor = MockGlideExecutor.newMainThreadExecutor();, +    Glide.init(, +        context,, +        new GlideBuilder(), +            .setSourceExecutor(mainThreadExecutor), +            .setDiskCacheExecutor(mainThreadExecutor), +            .setAnimationExecutor(mainThreadExecutor));, +, +  public void submit_withPreviousButNoLongerReferencedIdenticalRequest_completesFromMemoryCache() {, +  public void submit_withPreviousButNoLongerReferencedIdenticalRequest_doesNotRecycleBitmap() {, +  public void clearDiskCache_doesNotPreventFutureLoads() {, +    // Clearing the future here can race with clearing the EngineResource held on to by EngineJob, +    // while it's notifying callbacks. Forcing all executors to use the same thread avoids the race, +    // by making our clear and EngineJob's clear run on the same thread., +    GlideExecutor mainThreadExecutor = MockGlideExecutor.newMainThreadExecutor();, +    Glide.init(, +        context,, +        new GlideBuilder(), +            .setSourceExecutor(mainThreadExecutor), +            .setDiskCacheExecutor(mainThreadExecutor), +            .setAnimationExecutor(mainThreadExecutor));, +, +    // Load the request once., +    FutureTarget<Drawable> future =, +        GlideApp.with(context), +    // Clear the result from all of our caches., +    // Load the request a second time into the disk cache., +    future =, +        GlideApp.with(context), +    // Clear the second request from everywhere but the disk cache., +    // Load the request a third time., +    // Assert that the third request comes from the disk cache (which was populated by the second, +    // request)., +    assertThrows(, +        RuntimeException.class,, +        new ThrowingRunnable() {, +          public void run() {, +  private void clearMemoryCacheOnMainThread() {, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java, +  public synchronized GlideRequests applyDefaultRequestOptions(@NonNull RequestOptions options) {, +  public synchronized GlideRequests setDefaultRequestOptions(@NonNull RequestOptions options) {, +  public synchronized GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java, +  public synchronized GlideRequests applyDefaultRequestOptions(@NonNull RequestOptions options) {, +  public synchronized GlideRequests setDefaultRequestOptions(@NonNull RequestOptions options) {, +  public synchronized GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import com.bumptech.glide.load.engine.executor.GlideExecutor;, +import com.bumptech.glide.load.engine.executor.MockGlideExecutor;, +  public void setUp() {, +    Glide.init(context, new GlideBuilder().setMemoryCache(new LruResourceCache(CACHE_SIZE_BYTES)));, +  public void submit_withPreviousRequestClearedFromMemory_completesFromDataDiskCache() {, +    // Clearing the future here can race with clearing the EngineResource held on to by EngineJob, +    // while it's notifying callbacks. Forcing all executors to use the same thread avoids the race, +    // by making our clear and EngineJob's clear run on the same thread., +    GlideExecutor mainThreadExecutor = MockGlideExecutor.newMainThreadExecutor();, +    Glide.init(, +        context,, +        new GlideBuilder(), +            .setSourceExecutor(mainThreadExecutor), +            .setDiskCacheExecutor(mainThreadExecutor), +            .setAnimationExecutor(mainThreadExecutor));, +, +  public void submit_withPreviousButNoLongerReferencedIdenticalRequest_completesFromMemoryCache() {, +  public void submit_withPreviousButNoLongerReferencedIdenticalRequest_doesNotRecycleBitmap() {, +  public void clearDiskCache_doesNotPreventFutureLoads() {, +    // Clearing the future here can race with clearing the EngineResource held on to by EngineJob, +    // while it's notifying callbacks. Forcing all executors to use the same thread avoids the race, +    // by making our clear and EngineJob's clear run on the same thread., +    GlideExecutor mainThreadExecutor = MockGlideExecutor.newMainThreadExecutor();, +    Glide.init(]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +import com.bumptech.glide.Registry;, +    public void registerComponents(Context context, Registry registry) {, +        registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +import com.bumptech.glide.Registry;, +    public void registerComponents(Context context, Registry registry) {, +        registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java, +import com.bumptech.glide.Registry;, +    public void registerComponents(Context context, Registry registry) {, +        registry.replace(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(context));, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +import com.bumptech.glide.Registry;, +    public void registerComponents(Context context, Registry registry) {, +        registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java, +import com.bumptech.glide.Registry;, +    public void registerComponents(Context context, Registry registry) {, +        registry.replace(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(context));, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        Glide.get(getContext()).getRegistry().prepend(failModel, failResource, failFactory);, +        Glide.get(Robolectric.application).getRegistry(), +                .prepend(modelClass, InputStream.class, modelLoaderFactory);, +        public void registerComponents(Context context, Registry registry) {, +            registry.prepend(GlideUrl.class, InputStream.class, mockUrlLoaderFactory);, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +import com.bumptech.glide.Registry;, +    public void registerComponents(Context context, Registry registry) {, +        registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java, +import com.bumptech.glide.Registry;, +    public void registerComponents(Context context, Registry registry) {, +        registry.replace(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(context));, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        Glide.get(getContext()).getRegistry().prepend(failModel, failResource, failFactory);, +        Glide.get(Robolectric.application).getRegistry(), +                .prepend(modelClass, InputStream.class, modelLoaderFactory);, +        public void registerComponents(Context context, Registry registry) {, +            registry.prepend(GlideUrl.class, InputStream.class, mockUrlLoaderFactory);, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestBuilderTest.java, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +import com.bumptech.glide.Registry;, +    public void registerComponents(Context context, Registry registry) {, +        registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java, +import com.bumptech.glide.Registry;, +    public void registerComponents(Context context, Registry registry) {, +        registry.replace(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(context));, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        Glide.get(getContext()).getRegistry().prepend(failModel, failResource, failFactory);, +        Glide.get(Robolectric.application).getRegistry(), +                .prepend(modelClass, InputStream.class, modelLoaderFactory);, +        public void registerComponents(Context context, Registry registry) {, +            registry.prepend(GlideUrl.class, InputStream.class, mockUrlLoaderFactory);, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestBuilderTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/module/ManifestParserTest.java, +import com.bumptech.glide.Registry;, +        public void registerComponents(Context context, Registry registry) { }, +        public void registerComponents(Context context, Registry registry) { }, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +import com.bumptech.glide.Registry;, +    public void registerComponents(Context context, Registry registry) {, +        registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java, +import com.bumptech.glide.Registry;, +    public void registerComponents(Context context, Registry registry) {, +        registry.replace(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(context));, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        Glide.get(getContext()).getRegistry().prepend(failModel, failResource, failFactory);, +        Glide.get(Robolectric.application).getRegistry(), +                .prepend(modelClass, InputStream.class, modelLoaderFactory);, +        public void registerComponents(Context context, Registry registry) {, +            registry.prepend(GlideUrl.class, InputStream.class, mockUrlLoaderFactory);, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestBuilderTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/module/ManifestParserTest.java, +import com.bumptech.glide.Registry;, +        public void registerComponents(Context context, Registry registry) { }, +        public void registerComponents(Context context, Registry registry) { }, +++ b/library/src/androidTest/java/com/bumptech/glide/request/SingleRequestTest.java, +import com.bumptech.glide.GlideContext;, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +import com.bumptech.glide.Registry;, +    public void registerComponents(Context context, Registry registry) {, +        registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java, +import com.bumptech.glide.Registry;, +    public void registerComponents(Context context, Registry registry) {, +        registry.replace(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(context));, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        Glide.get(getContext()).getRegistry().prepend(failModel, failResource, failFactory);, +        Glide.get(Robolectric.application).getRegistry(), +                .prepend(modelClass, InputStream.class, modelLoaderFactory);, +        public void registerComponents(Context context, Registry registry) {, +            registry.prepend(GlideUrl.class, InputStream.class, mockUrlLoaderFactory);, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestBuilderTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/module/ManifestParserTest.java, +import com.bumptech.glide.Registry;, +        public void registerComponents(Context context, Registry registry) { }, +        public void registerComponents(Context context, Registry registry) { }]
[+++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="19" />, +++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="19" />, +++ b/library/src/com/bumptech/glide/Glide.java, +import android.graphics.Bitmap;, +import android.graphics.drawable.Drawable;, +import android.os.ParcelFileDescriptor;, +import android.view.View;, +import com.bumptech.glide.loader.bitmap.ImageVideoBitmapLoadFactory;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorFileLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorModelLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorResourceLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorStringLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorUriLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamByteArrayLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamResourceLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamFileLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamModelLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamStringLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamUriLoader;, +import com.bumptech.glide.loader.bitmap.model.GenericLoaderFactory;, +import com.bumptech.glide.loader.bitmap.model.ModelLoader;, +import com.bumptech.glide.loader.bitmap.model.ModelLoaderFactory;, +import com.bumptech.glide.loader.bitmap.transformation.CenterCrop;, +import com.bumptech.glide.loader.bitmap.transformation.FitCenter;, +import com.bumptech.glide.loader.bitmap.transformation.MultiTransformationLoader;, +import com.bumptech.glide.loader.bitmap.transformation.None;, +import com.bumptech.glide.loader.bitmap.transformation.TransformationLoader;, +import com.bumptech.glide.presenter.target.ImageViewTarget;, +import com.bumptech.glide.presenter.target.ViewTarget;, +import com.bumptech.glide.resize.load.BitmapDecoder;, +import com.bumptech.glide.resize.load.VideoBitmapDecoder;, +import java.io.InputStream;, +import java.util.UUID;, + * A singleton to present a simple static interface for Glide {@link Request} and to create and manage an, +         *     public void onException(Exception e, ModelType model, Target target) {, +        register(File.class, ParcelFileDescriptor.class, new FileDescriptorFileLoader.Factory());, +        register(File.class, InputStream.class, new StreamFileLoader.Factory());, +        register(Integer.class, ParcelFileDescriptor.class, new FileDescriptorResourceLoader.Factory());, +        register(Integer.class, InputStream.class, new StreamResourceLoader.Factory());, +        register(String.class, ParcelFileDescriptor.class, new FileDescriptorStringLoader.Factory());, +        register(String.class, InputStream.class, new StreamStringLoader.Factory());, +        register(Uri.class, ParcelFileDescriptor.class, new FileDescriptorUriLoader.Factory());, +        register(Uri.class, InputStream.class, new StreamUriLoader.Factory());, +            register(URL.class, InputStream.class, new VolleyUrlLoader.Factory());, +     * {@link ImageManager} with custom options for use with {@link Request} and/or as an, +     * Set the {@link ImageManager} to use with {@link Request}., +     * Set the {@link ImageManager} to use with {@link Request} Replaces the current, +     * models. Typically the {@link ModelRequest#using(StreamModelLoader)} or, +     * {@link ModelRequest#using(FileDescriptorModelLoader)} syntax is preferred because it directly links the model, +     * with the ModelLoader being used to load it., +     *     used for any other model class, {@link ModelLoaderFactory#teardown()}, +     * @see ModelRequest#using(FileDescriptorModelLoader), +     * @see ModelRequest#using(StreamModelLoader), +     *, +     * @param modelClass The model class., +     * @param resourceClass The resource class the model loader will translate the model type into., +     * @param factory The factory to use., +     * @param <T> The type of the model., +     * @param <Y> the type of the resource., +    public <T, Y> void register(Class<T> modelClass, Class<Y> resourceClass, ModelLoaderFactory<T, Y> factory) {, +        ModelLoaderFactory<T, Y> removed = loaderFactory.register(modelClass, resourceClass, factory);, +    @SuppressWarnings("unchecked"), +    private <T, Y> ModelLoaderFactory<T, Y> getFactory(T model, Class<Y> resourceClass) {, +        return loaderFactory.getFactory((Class<T>) model.getClass(), resourceClass);, +    }, +, +     * @param modelClass The class to get a {@link ModelLoader} for, +    public static <T, Y> ModelLoader<T, Y> buildModelLoader(Class<T> modelClass, Class<Y> resourceClass, Context context) {, +        return GLIDE.loaderFactory.buildModelLoader(modelClass, resourceClass, context);, +     * A convenience method to build a {@link ModelLoader} for the given model that produces {@link InputStream}s using, +     * a registered factory., +     * @see #buildModelLoader(Class, Class, android.content.Context), +    public static <T> ModelLoader<T, InputStream> buildStreamModelLoader(Class<T> modelClass, Context context) {, +        return buildModelLoader(modelClass, InputStream.class, context);, +     * A convenience method to build a {@link ModelLoader} for the given model class that produces, +     * {@link ParcelFileDescriptor}s using a registered factory., +     * @see #buildModelLoader(Class, Class, android.content.Context), +    public static <T> ModelLoader<T, ParcelFileDescriptor> buildFileDescriptorModelLoader(Class<T> modelClass,, +            Context context) {, +        return buildModelLoader(modelClass, ParcelFileDescriptor.class, context);, +    /**, +     * Cancel any pending loads Glide may have for the target and free any resources (such as {@link Bitmap}s) that may, +     * have been loaded for the target so they may be reused., +     *, +     * @param target The Target to cancel loads for., +     */, +    public static void clear(Target target) {, +        ImagePresenter imagePresenter = target.getImagePresenter();, +        if (imagePresenter != null) {, +            imagePresenter.clear();, +        }, +    /**, +     * Cancel any pending loads Glide may have for the view and free any resources that may have been loaded for the, +     * view., +     *, +     * <p>, +     *     Note that this will only work if {@link View#setTag(Object)} is not called on this view outside of Glide., +     * </p>]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    return into(target, /*targetListener=*/ null, /*backgroundRequestOrigin=*/ null);, +      @Nullable RequestListener<TranscodeType> targetListener,, +      @Nullable Exception backgroundRequestOrigin) {, +    return into(target, targetListener, backgroundRequestOrigin, /*options=*/ this);, +      @Nullable Exception backgroundRequestOrigin,, +        /*backgroundRequestOrigin=*/ null,, +      final Exception backgroundRequestOrigin =, +          glideContext.isLoggingRequestOriginsEnabled(), +              ? new RuntimeException("Gldie request origin trace") : null;, +            into(target, target, backgroundRequestOrigin);, +      into(target, target, /*backgroundRequestOrigin=*/ null);, +        requestOptions,, +        /*backgroundRequestOrigin=*/ null);, +      BaseRequestOptions<?> requestOptions,, +      @Nullable Exception backgroundRequestOrigin) {, +            requestOptions,, +            backgroundRequestOrigin);, +        errorBuilder,, +        backgroundRequestOrigin);, +      BaseRequestOptions<?> requestOptions,, +      @Nullable Exception backgroundRequestOrigin) {, +              overrideHeight,, +              backgroundRequestOrigin);, +              thumbnailBuilder,, +              backgroundRequestOrigin);, +              overrideHeight,, +              backgroundRequestOrigin);, +              overrideHeight,, +              backgroundRequestOrigin);, +          overrideHeight,, +          backgroundRequestOrigin);, +      int overrideHeight,, +      Exception backgroundRequestOrigin) {, +        transitionOptions.getTransitionFactory(),, +        backgroundRequestOrigin);, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    return into(target, /*targetListener=*/ null, /*backgroundRequestOrigin=*/ null);, +      @Nullable RequestListener<TranscodeType> targetListener,, +      @Nullable Exception backgroundRequestOrigin) {, +    return into(target, targetListener, backgroundRequestOrigin, /*options=*/ this);, +      @Nullable Exception backgroundRequestOrigin,, +        /*backgroundRequestOrigin=*/ null,, +      final Exception backgroundRequestOrigin =, +          glideContext.isLoggingRequestOriginsEnabled(), +              ? new RuntimeException("Gldie request origin trace") : null;, +            into(target, target, backgroundRequestOrigin);, +      into(target, target, /*backgroundRequestOrigin=*/ null);, +        requestOptions,, +        /*backgroundRequestOrigin=*/ null);, +      BaseRequestOptions<?> requestOptions,, +      @Nullable Exception backgroundRequestOrigin) {, +            requestOptions,, +            backgroundRequestOrigin);, +        errorBuilder,, +        backgroundRequestOrigin);, +      BaseRequestOptions<?> requestOptions,, +      @Nullable Exception backgroundRequestOrigin) {, +              overrideHeight,, +              backgroundRequestOrigin);, +              thumbnailBuilder,, +              backgroundRequestOrigin);, +              overrideHeight,, +              backgroundRequestOrigin);, +              overrideHeight,, +              backgroundRequestOrigin);, +          overrideHeight,, +          backgroundRequestOrigin);, +      int overrideHeight,, +      Exception backgroundRequestOrigin) {, +        transitionOptions.getTransitionFactory(),, +        backgroundRequestOrigin);, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +      TransitionFactory<? super R> animationFactory,, +      @Nullable Exception requestOrigin) {, +        animationFactory,, +        requestOrigin);, +      TransitionFactory<? super R> animationFactory,, +      @Nullable Exception requestOrigin) {, +    if (requestOrigin == null && glideContext.isLoggingRequestOriginsEnabled()) {, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    return into(target, /*targetListener=*/ null, /*backgroundRequestOrigin=*/ null);, +      @Nullable RequestListener<TranscodeType> targetListener,, +      @Nullable Exception backgroundRequestOrigin) {, +    return into(target, targetListener, backgroundRequestOrigin, /*options=*/ this);, +      @Nullable Exception backgroundRequestOrigin,, +        /*backgroundRequestOrigin=*/ null,, +      final Exception backgroundRequestOrigin =, +          glideContext.isLoggingRequestOriginsEnabled(), +              ? new RuntimeException("Gldie request origin trace") : null;, +            into(target, target, backgroundRequestOrigin);, +      into(target, target, /*backgroundRequestOrigin=*/ null);, +        requestOptions,, +        /*backgroundRequestOrigin=*/ null);, +      BaseRequestOptions<?> requestOptions,, +      @Nullable Exception backgroundRequestOrigin) {, +            requestOptions,, +            backgroundRequestOrigin);, +        errorBuilder,, +        backgroundRequestOrigin);]
[+++ b/library/src/main/java/com/bumptech/glide/util/LruCache.java, +        if (result != item) {, +            currentSize += getSize(item);, +        }, +++ b/library/src/main/java/com/bumptech/glide/util/LruCache.java, +        if (result != item) {, +            currentSize += getSize(item);, +        }, +++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/LruCacheTest.java, +    public void testCanPutSameItemMultipleTimes() {, +        String key = getKey();, +        Object value = new Object();, +        for (int i = 0; i < SIZE * 2; i++) {, +            cache.put(key, value);, +        }, +, +        verify(listener, never()).onItemRemoved(anyObject());, +    }, +, +    @Test]
[+++ b/.travis.yml, +sudo: required, +dist: trusty, +, +  - tools, +  - android-22, +  - sys-img-armeabi-v7a-android-22, +env: , +  matrix:, +    - COMPONENT=unit, +    - COMPONENT=instrumentation, +    - COMPONENT=samples, +before_script:, +  - ./scripts/travis_before_script.sh, +, +script: , +  - ./scripts/travis_script.sh, +  - ./scripts/travis_after_success.sh, +++ b/.travis.yml, +sudo: required, +dist: trusty, +, +  - tools, +  - android-22, +  - sys-img-armeabi-v7a-android-22, +env: , +  matrix:, +    - COMPONENT=unit, +    - COMPONENT=instrumentation, +    - COMPONENT=samples, +before_script:, +  - ./scripts/travis_before_script.sh, +, +script: , +  - ./scripts/travis_script.sh, +  - ./scripts/travis_after_success.sh, +++ /dev/null, +++ b/.travis.yml, +sudo: required, +dist: trusty, +, +  - tools, +  - android-22, +  - sys-img-armeabi-v7a-android-22, +env: , +  matrix:, +    - COMPONENT=unit, +    - COMPONENT=instrumentation, +    - COMPONENT=samples, +before_script:, +  - ./scripts/travis_before_script.sh, +, +script: , +  - ./scripts/travis_script.sh, +  - ./scripts/travis_after_success.sh, +++ /dev/null, +++ b/scripts/travis_after_success.sh, +#!/usr/bin/env bash, +, +set -e, +, +if [ "$COMPONENT" == "unit" ]; then, +  ./scripts/travis_sonatype_publish.sh, +  ./gradlew jacocoTestReport coveralls, +fi, +++ b/.travis.yml, +sudo: required, +dist: trusty, +, +  - tools, +  - android-22, +  - sys-img-armeabi-v7a-android-22, +env: , +  matrix:, +    - COMPONENT=unit, +    - COMPONENT=instrumentation, +    - COMPONENT=samples, +before_script:, +  - ./scripts/travis_before_script.sh, +, +script: , +  - ./scripts/travis_script.sh, +  - ./scripts/travis_after_success.sh, +++ /dev/null, +++ b/scripts/travis_after_success.sh, +#!/usr/bin/env bash, +, +set -e, +, +if [ "$COMPONENT" == "unit" ]; then, +  ./scripts/travis_sonatype_publish.sh, +  ./gradlew jacocoTestReport coveralls, +fi, +++ b/scripts/travis_before_script.sh, +#!/usr/bin/env bash, +, +set -e, +, +if [ "$COMPONENT" == "instrumentation" ]; then, +  echo "Starting emulator for $COMPONENT tests"]
[+++ b/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java, +import static org.mockito.Matchers.eq;, +import android.content.ComponentCallbacks;, +    @Test, +    public void testCallsRequestManagerOnLowMemory() {, +        runTest(new TestCase() {, +            @Override, +            public void runTest(Harness harness) {, +                RequestManager requestManager = mock(RequestManager.class);, +                harness.setRequestManager(requestManager);, +                harness.getCallbacks().onLowMemory();, +                verify(requestManager).onLowMemory();, +            }, +        });, +    }, +, +    @Test, +    public void testNonSupportFragmentCallsRequestManagerOnTrimMemory() {, +        RequestManagerHarness requestManagerHarness = new RequestManagerHarness();, +        RequestManager requestManager = mock(RequestManager.class);, +        requestManagerHarness.setRequestManager(requestManager);, +        int level = 123;, +        requestManagerHarness.fragment.onTrimMemory(level);, +, +        verify(requestManager).onTrimMemory(eq(level));, +    }, +, +, +        public ComponentCallbacks getCallbacks();, +, +        @Override, +        public ComponentCallbacks getCallbacks() {, +            return fragment;, +        }, +, +        @Override, +        public ComponentCallbacks getCallbacks() {, +            return supportFragment;, +        }, +++ b/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java, +import static org.mockito.Matchers.eq;, +import android.content.ComponentCallbacks;, +    @Test, +    public void testCallsRequestManagerOnLowMemory() {, +        runTest(new TestCase() {, +            @Override, +            public void runTest(Harness harness) {, +                RequestManager requestManager = mock(RequestManager.class);, +                harness.setRequestManager(requestManager);, +                harness.getCallbacks().onLowMemory();, +                verify(requestManager).onLowMemory();, +            }, +        });, +    }, +, +    @Test, +    public void testNonSupportFragmentCallsRequestManagerOnTrimMemory() {, +        RequestManagerHarness requestManagerHarness = new RequestManagerHarness();, +        RequestManager requestManager = mock(RequestManager.class);, +        requestManagerHarness.setRequestManager(requestManager);, +        int level = 123;, +        requestManagerHarness.fragment.onTrimMemory(level);, +, +        verify(requestManager).onTrimMemory(eq(level));, +    }, +, +, +        public ComponentCallbacks getCallbacks();, +, +        @Override, +        public ComponentCallbacks getCallbacks() {, +            return fragment;, +        }, +, +        @Override, +        public ComponentCallbacks getCallbacks() {, +            return supportFragment;, +        }, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +     * @see android.content.ComponentCallbacks#onLowMemory(), +++ b/library/src/androidTest/java/com/bumptech/glide/manager/RequestManagerFragmentTest.java, +import static org.mockito.Matchers.eq;, +import android.content.ComponentCallbacks;, +    @Test, +    public void testCallsRequestManagerOnLowMemory() {, +        runTest(new TestCase() {, +            @Override, +            public void runTest(Harness harness) {, +                RequestManager requestManager = mock(RequestManager.class);, +                harness.setRequestManager(requestManager);, +                harness.getCallbacks().onLowMemory();, +                verify(requestManager).onLowMemory();, +            }, +        });, +    }, +, +    @Test, +    public void testNonSupportFragmentCallsRequestManagerOnTrimMemory() {, +        RequestManagerHarness requestManagerHarness = new RequestManagerHarness();, +        RequestManager requestManager = mock(RequestManager.class);]
[+++ b/README.md, +Then in your Activity or Application, register the Volley based model loader:, +```java, +public void onCreate() {, +  Glide.get(this).register(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(yourRequestQueue));, +  ..., +}, +```, +, +After the call to register any requests using http or https will go through Volley., +, +++ b/README.md, +Then in your Activity or Application, register the Volley based model loader:, +```java, +public void onCreate() {, +  Glide.get(this).register(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(yourRequestQueue));, +  ..., +}, +```, +, +After the call to register any requests using http or https will go through Volley., +, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +import com.bumptech.glide.util.Util;, +        Util.assertMainThread();, +        request.begin();, +        Util.assertMainThread();, +++ b/README.md, +Then in your Activity or Application, register the Volley based model loader:, +```java, +public void onCreate() {, +  Glide.get(this).register(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(yourRequestQueue));, +  ..., +}, +```, +, +After the call to register any requests using http or https will go through Volley., +, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +import com.bumptech.glide.util.Util;, +        Util.assertMainThread();, +        request.begin();, +        Util.assertMainThread();, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +import com.bumptech.glide.util.Util;, +        Util.assertMainThread();, +        Util.assertMainThread();, +        resumeRequests();, +        pauseRequests();, +++ b/README.md, +Then in your Activity or Application, register the Volley based model loader:, +```java, +public void onCreate() {, +  Glide.get(this).register(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(yourRequestQueue));, +  ..., +}, +```, +, +After the call to register any requests using http or https will go through Volley., +, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +import com.bumptech.glide.util.Util;, +        Util.assertMainThread();, +        request.begin();, +        Util.assertMainThread();, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +import com.bumptech.glide.util.Util;, +        Util.assertMainThread();, +        Util.assertMainThread();, +        resumeRequests();, +        pauseRequests();, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java, +                request.begin();, +                request.begin();, +                request.begin();, +++ b/README.md, +Then in your Activity or Application, register the Volley based model loader:, +```java, +public void onCreate() {, +  Glide.get(this).register(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(yourRequestQueue));, +  ..., +}, +```, +, +After the call to register any requests using http or https will go through Volley., +, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +import com.bumptech.glide.util.Util;, +        Util.assertMainThread();, +        request.begin();, +        Util.assertMainThread();, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +import com.bumptech.glide.util.Util;, +        Util.assertMainThread();, +        Util.assertMainThread();, +        resumeRequests();, +        pauseRequests();, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java, +                request.begin();, +                request.begin();]
[+++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java, +        request.clear();, +        request.clear();, +      // We don't need to check for cleared here. Any explicit clear by a user will remove the, +      // Request from the tracker, so the only way we'd find a cleared request here is if we cleared, +      // it. As a result it should be safe for us to resume cleared requests., +      if (!request.isComplete() && !request.isRunning()) {, +      if (!request.isComplete() && !request.isCleared()) {, +        request.clear();, +          // Ensure the request will be restarted in onResume., +++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java, +        request.clear();, +        request.clear();, +      // We don't need to check for cleared here. Any explicit clear by a user will remove the, +      // Request from the tracker, so the only way we'd find a cleared request here is if we cleared, +      // it. As a result it should be safe for us to resume cleared requests., +      if (!request.isComplete() && !request.isRunning()) {, +      if (!request.isComplete() && !request.isCleared()) {, +        request.clear();, +          // Ensure the request will be restarted in onResume., +++ b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java, +  public boolean isCleared() {, +    return primary.isFailed() ? error.isCleared() : primary.isCleared();, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java, +        request.clear();, +        request.clear();, +      // We don't need to check for cleared here. Any explicit clear by a user will remove the, +      // Request from the tracker, so the only way we'd find a cleared request here is if we cleared, +      // it. As a result it should be safe for us to resume cleared requests., +      if (!request.isComplete() && !request.isRunning()) {, +      if (!request.isComplete() && !request.isCleared()) {, +        request.clear();, +          // Ensure the request will be restarted in onResume., +++ b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java, +  public boolean isCleared() {, +    return primary.isFailed() ? error.isCleared() : primary.isCleared();, +++ b/library/src/main/java/com/bumptech/glide/request/Request.java, +   * Returns true if the request has been cleared., +  boolean isCleared();, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java, +        request.clear();, +        request.clear();, +      // We don't need to check for cleared here. Any explicit clear by a user will remove the, +      // Request from the tracker, so the only way we'd find a cleared request here is if we cleared, +      // it. As a result it should be safe for us to resume cleared requests., +      if (!request.isComplete() && !request.isRunning()) {, +      if (!request.isComplete() && !request.isCleared()) {, +        request.clear();, +          // Ensure the request will be restarted in onResume., +++ b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java, +  public boolean isCleared() {, +    return primary.isFailed() ? error.isCleared() : primary.isCleared();, +++ b/library/src/main/java/com/bumptech/glide/request/Request.java, +   * Returns true if the request has been cleared., +  boolean isCleared();, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +     * Cleared by the user with a placeholder set, may be restarted., +  private void cancel() {, +, +  public boolean isCleared() {, +    return status == Status.CLEARED;, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java, +        request.clear();, +        request.clear();, +      // We don't need to check for cleared here. Any explicit clear by a user will remove the, +      // Request from the tracker, so the only way we'd find a cleared request here is if we cleared, +      // it. As a result it should be safe for us to resume cleared requests., +      if (!request.isComplete() && !request.isRunning()) {, +      if (!request.isComplete() && !request.isCleared()) {, +        request.clear();, +          // Ensure the request will be restarted in onResume., +++ b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java, +  public boolean isCleared() {, +    return primary.isFailed() ? error.isCleared() : primary.isCleared();, +++ b/library/src/main/java/com/bumptech/glide/request/Request.java, +   * Returns true if the request has been cleared., +  boolean isCleared();, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +     * Cleared by the user with a placeholder set, may be restarted., +  private void cancel() {, +, +  public boolean isCleared() {, +    return status == Status.CLEARED;, +++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java, +  public boolean isCleared() {, +    return full.isCleared();, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java, +        request.clear();, +        request.clear();, +      // We don't need to check for cleared here. Any explicit clear by a user will remove the, +      // Request from the tracker, so the only way we'd find a cleared request here is if we cleared, +      // it. As a result it should be safe for us to resume cleared requests., +      if (!request.isComplete() && !request.isRunning()) {, +      if (!request.isComplete() && !request.isCleared()) {, +        request.clear();, +          // Ensure the request will be restarted in onResume., +++ b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java, +  public boolean isCleared() {, +    return primary.isFailed() ? error.isCleared() : primary.isCleared();, +++ b/library/src/main/java/com/bumptech/glide/request/Request.java]
[+++ b/build.gradle, +++ b/build.gradle, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=2.4, +++ b/build.gradle, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=2.4, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +    public void testActiveResourcesIsNotCheckedIfNotMemoryCacheable() {, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));, +, +        harness.isMemoryCacheable = false;, +        harness.doLoad();, +, +        verify(harness.resource, never()).acquire();, +        verify(harness.job).start(any(EngineRunnable.class));, +    }, +, +    @Test, +    public void testCacheIsCheckedIfMemoryCacheable() {, +    public void testCacheIsNotCheckedIfNotMemoryCacheable() {, +        when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);, +, +        harness.isMemoryCacheable = false;, +        harness.doLoad();, +, +        verify(harness.job).start(any(EngineRunnable.class));, +    }, +, +    @Test, +        when(harness.resource.isCacheable()).thenReturn(true);, +    public void testDoesNotPutResourceThatIsNotCacheableInActiveResourcesOnEngineComplete() {, +        when(harness.resource.isCacheable()).thenReturn(false);, +        harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);, +        assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);, +    }, +, +    @Test, +        boolean isMemoryCacheable = true;, +            when(engineJobFactory.build(eq(cacheKey), eq(isMemoryCacheable))).thenReturn(job);, +++ b/build.gradle, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=2.4, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +    public void testActiveResourcesIsNotCheckedIfNotMemoryCacheable() {, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));, +, +        harness.isMemoryCacheable = false;, +        harness.doLoad();, +, +        verify(harness.resource, never()).acquire();, +        verify(harness.job).start(any(EngineRunnable.class));, +    }, +, +    @Test, +    public void testCacheIsCheckedIfMemoryCacheable() {, +    public void testCacheIsNotCheckedIfNotMemoryCacheable() {, +        when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(harness.resource);, +, +        harness.isMemoryCacheable = false;, +        harness.doLoad();, +, +        verify(harness.job).start(any(EngineRunnable.class));, +    }, +, +    @Test, +        when(harness.resource.isCacheable()).thenReturn(true);, +    public void testDoesNotPutResourceThatIsNotCacheableInActiveResourcesOnEngineComplete() {, +        when(harness.resource.isCacheable()).thenReturn(false);, +        harness.engine.onEngineJobComplete(harness.cacheKey, harness.resource);, +        assertThat(harness.activeResources).doesNotContainKey(harness.cacheKey);, +    }, +, +    @Test, +        boolean isMemoryCacheable = true;, +            when(engineJobFactory.build(eq(cacheKey), eq(isMemoryCacheable))).thenReturn(job);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStreamTest.java, +package com.bumptech.glide.load.resource.bitmap;, +, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertTrue;, +import static org.mockito.Mockito.doThrow;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +, +import java.io.ByteArrayInputStream;, +import java.io.IOException;, +import java.io.InputStream;, +import java.util.Arrays;, +, +@RunWith(JUnit4.class), +public class RecyclableBufferedInputStreamTest {, +, +    private static final int DATA_SIZE = 30;]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java, +import static com.bumptech.glide.request.RequestOptions.bitmapTransform;, +import static com.bumptech.glide.request.RequestOptions.centerCropTransform;, +import com.bumptech.glide.load.resource.bitmap.RoundedCorners;, +    Glide.get(context).clearDiskCache();, +  public void load_withBitmapResourceId_asDrawable_withTransformation_producesNonNullBitmap(), +      throws ExecutionException, InterruptedException {, +    Drawable drawable = Glide.with(context), +        .load(android.R.drawable.star_big_off), +        .apply(centerCropTransform()), +        .submit(), +        .get();, +    assertThat(drawable).isNotNull();, +  }, +, +  @Test, +  public void load_withBitmapAliasResourceId_asDrawable_withTransformation_producesNonNullDrawable(), +      throws ExecutionException, InterruptedException {, +    Drawable drawable = Glide.with(context), +        .load(ResourceIds.drawable.bitmap_alias), +        .apply(centerCropTransform()), +        .submit(), +        .get();, +    assertThat(drawable).isNotNull();, +  }, +, +  @Test, +  public void load_withShapeDrawableResourceId_asDrawable_withTransformation_sizeOriginal_fails(), +      throws ExecutionException, InterruptedException {, +    expectedException.expect(ExecutionException.class);, +    Glide.with(context), +        .load(ResourceIds.drawable.shape_drawable), +        .apply(centerCropTransform()), +        .submit(), +        .get();, +  }, +, +  @Test, +  public void load_withShapeDrawableResourceId_asDrawable_withTransformation_validSize_succeeds(), +      throws ExecutionException, InterruptedException {, +    Drawable drawable = Glide.with(context), +        .load(ResourceIds.drawable.shape_drawable), +        .apply(bitmapTransform(new RoundedCorners(10))), +        .submit(100, 200), +        .get();, +    assertThat(drawable).isNotNull();, +    assertThat(drawable.getIntrinsicWidth()).isEqualTo(100);, +    assertThat(drawable.getIntrinsicHeight()).isEqualTo(200);, +  }, +, +  @Test, +  public void load_withShapeDrawableResourceId_asBitmap_withValidSizeAndTransform_nonNullBitmap(), +      throws ExecutionException, InterruptedException {, +    Bitmap bitmap = Glide.with(context), +        .asBitmap(), +        .load(ResourceIds.drawable.shape_drawable), +        .apply(centerCropTransform()), +        .submit(100, 200), +        .get();, +    assertThat(bitmap).isNotNull();, +    assertThat(bitmap.getWidth()).isEqualTo(100);, +    assertThat(bitmap.getHeight()).isEqualTo(200);, +  }, +, +  @Test, +  public void load_withStateListDrawableResourceId_asDrawable_withTransformation_nonNullDrawable(), +      throws ExecutionException, InterruptedException {, +    Drawable drawable = Glide.with(context), +        .load(ResourceIds.drawable.state_list_drawable), +        .apply(centerCropTransform()), +        .submit(), +        .get();, +    assertThat(drawable).isNotNull();, +  }, +, +  @Test, +  public void load_withStateListDrawableResourceId_asBitmap_withTransformation_nonNullBitmap(), +      throws ExecutionException, InterruptedException {, +    Bitmap bitmap = Glide.with(context), +        .asBitmap(), +        .load(ResourceIds.drawable.state_list_drawable), +        .apply(centerCropTransform()), +        .submit(), +        .get();, +    assertThat(bitmap).isNotNull();, +  }, +, +  @Test, +  public void load_withVectorDrawableResourceId_asDrawable_withTransformation_nonNullDrawable(), +      throws ExecutionException, InterruptedException {, +    Drawable drawable = Glide.with(context), +        .load(ResourceIds.drawable.vector_drawable), +        .apply(centerCropTransform()), +        .submit(), +        .get();, +    assertThat(drawable).isNotNull();, +  }, +, +  @Test, +  public void load_withVectorDrawableResourceId_asBitmap_withTransformation_producesNonNullBitmap()]
[+++ b/.gitignore, +**local.properties]
[+++ b/.idea/codeStyleSettings.xml, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MAJOR=3, +VERSION_MINOR=6, +VERSION_CODE=11, +SUPPORT_V4_VERSION=19.1.0, +SUPPORT_V7_VERSION=19.1.0, +# TODO: Upgrade to latest version of Volley when we compile with Java 7., +VOLLEY_VERSION=1.0.8, +ANDROID_GRADLE_VERSION=1.0.0, +ROBOLECTRIC_GRADLE_VERSION=0.14.0, +ROBOLECTRIC_VERSION=2.4, +MOCKWEBSERVER_VERSION=1.6.0, +COMPILE_SDK_VERSION=19, +BUILD_TOOLS_VERSION=19.1.0, +TARGET_SDK_VERSION=19, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }]
[+++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +        public void update(byte[] keyBytes, Boolean value, MessageDigest messageDigest) {, +            messageDigest.update(keyBytes);, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +        public void update(byte[] keyBytes, Boolean value, MessageDigest messageDigest) {, +            messageDigest.update(keyBytes);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +        public void update(byte[] keyBytes, Boolean value, MessageDigest messageDigest) {, +            messageDigest.update(keyBytes);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +        public void update(byte[] keyBytes, Boolean value, MessageDigest messageDigest) {, +            messageDigest.update(keyBytes);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/main/java/com/bumptech/glide/load/Option.java, +  private final T defaultValue;, +  private final CacheKeyUpdater<T> cacheKeyUpdater;, +  private final String key;, +  private volatile byte[] keyBytes;, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +        public void update(byte[] keyBytes, Boolean value, MessageDigest messageDigest) {, +            messageDigest.update(keyBytes);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/main/java/com/bumptech/glide/load/Option.java, +  private final T defaultValue;, +  private final CacheKeyUpdater<T> cacheKeyUpdater;, +  private final String key;, +  private volatile byte[] keyBytes;, +++ b/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java, +public final class ExifOrientationStream extends FilterInputStream {, +      /** motorola byte order (big endian). */, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +        public void update(byte[] keyBytes, Boolean value, MessageDigest messageDigest) {, +            messageDigest.update(keyBytes);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/main/java/com/bumptech/glide/load/Option.java, +  private final T defaultValue;, +  private final CacheKeyUpdater<T> cacheKeyUpdater;, +  private final String key;, +  private volatile byte[] keyBytes;, +++ b/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java, +public final class ExifOrientationStream extends FilterInputStream {, +      /** motorola byte order (big endian). */, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java, + *, + * <p> Uses a PorterDuff blend mode, , seehttp://ssp.impulsetrain.com/porterduff.html. </p>, +  // Bitmap doesn't implement equals, so == and .equals are equivalent here., +  @SuppressWarnings("PMD.CompareObjectsWithEquals"), +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +        public void update(byte[] keyBytes, Boolean value, MessageDigest messageDigest) {, +            messageDigest.update(keyBytes);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/main/java/com/bumptech/glide/load/Option.java, +  private final T defaultValue;, +  private final CacheKeyUpdater<T> cacheKeyUpdater;, +  private final String key;, +  private volatile byte[] keyBytes;, +++ b/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java, +public final class ExifOrientationStream extends FilterInputStream {, +      /** motorola byte order (big endian). */, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java, + *, + * <p> Uses a PorterDuff blend mode, , seehttp://ssp.impulsetrain.com/porterduff.html. </p>, +  // Bitmap doesn't implement equals, so == and .equals are equivalent here., +  @SuppressWarnings("PMD.CompareObjectsWithEquals"), +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +      // If we scaled, the Bitmap density will be our inTargetDensity. Here we correct it back to, +      // the expected density dpi., +      downsampled.setDensity(displayMetrics.densityDpi);, +, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +        public void update(byte[] keyBytes, Boolean value, MessageDigest messageDigest) {, +            messageDigest.update(keyBytes);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/CircleCropTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java, +import org.robolectric.RobolectricTestRunner;, +++ b/library/src/main/java/com/bumptech/glide/load/Option.java, +  private final T defaultValue;, +  private final CacheKeyUpdater<T> cacheKeyUpdater;, +  private final String key;, +  private volatile byte[] keyBytes;, +++ b/library/src/main/java/com/bumptech/glide/load/data/ExifOrientationStream.java]
[+++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java, +import java.net.URISyntaxException;, +        } else {, +            // Comparing the URLs using .equals performs additional network I/O and is generally broken., +            // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html., +            try {, +                if (lastUrl != null && url.toURI().equals(lastUrl.toURI())) {, +            } catch (URISyntaxException e) {, +                // Do nothing, this is best effort., +            }, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java, +import java.net.URISyntaxException;, +        } else {, +            // Comparing the URLs using .equals performs additional network I/O and is generally broken., +            // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html., +            try {, +                if (lastUrl != null && url.toURI().equals(lastUrl.toURI())) {, +            } catch (URISyntaxException e) {, +                // Do nothing, this is best effort., +            }, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java, +        StringBuilder sb = new StringBuilder("GroupedLinkedMap( ");, +            sb.append("{").append(current.key).append(":").append(current.size()).append("}, ");, +            sb.delete(sb.length() - 2, sb.length());, +        return sb.append(" )").toString();, +++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java, +import java.net.URISyntaxException;, +        } else {, +            // Comparing the URLs using .equals performs additional network I/O and is generally broken., +            // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html., +            try {, +                if (lastUrl != null && url.toURI().equals(lastUrl.toURI())) {, +            } catch (URISyntaxException e) {, +                // Do nothing, this is best effort., +            }, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java, +        StringBuilder sb = new StringBuilder("GroupedLinkedMap( ");, +            sb.append("{").append(current.key).append(":").append(current.size()).append("}, ");, +            sb.delete(sb.length() - 2, sb.length());, +        return sb.append(" )").toString();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    public synchronized void setSizeMultiplier(float sizeMultiplier) {, +    private synchronized void trimToSize(int size) {, +++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java, +import java.net.URISyntaxException;, +        } else {, +            // Comparing the URLs using .equals performs additional network I/O and is generally broken., +            // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html., +            try {, +                if (lastUrl != null && url.toURI().equals(lastUrl.toURI())) {, +            } catch (URISyntaxException e) {, +                // Do nothing, this is best effort., +            }, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java, +        StringBuilder sb = new StringBuilder("GroupedLinkedMap( ");, +            sb.append("{").append(current.key).append(":").append(current.size()).append("}, ");, +            sb.delete(sb.length() - 2, sb.length());, +        return sb.append(" )").toString();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    public synchronized void setSizeMultiplier(float sizeMultiplier) {, +    private synchronized void trimToSize(int size) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/FifoPriorityThreadPoolExecutor.java, +        public boolean equals(Object o) {, +            if (this == o) {, +                return true;, +            }, +            if (o == null || getClass() != o.getClass()) {, +                return false;, +            }, +, +            FifoPriorityLoadTask that = (FifoPriorityLoadTask) o;, +, +            if (order != that.order) {, +                return false;, +            }, +            if (priority != that.priority) {, +                return false;, +            }, +, +            return true;, +        }, +, +        @Override, +        public int hashCode() {, +            int result = priority;, +            result = 31 * result + order;, +            return result;, +        }, +, +        @Override, +            if (result == 0) {, +++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java, +import java.net.URISyntaxException;, +        } else {, +            // Comparing the URLs using .equals performs additional network I/O and is generally broken., +            // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html.]
[+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +  // Public API., +  @SuppressWarnings("WeakerAccess"), +  // Public API., +  @SuppressWarnings("unused"), +  // Public API., +  @SuppressWarnings("WeakerAccess"), +  // Public API., +  @SuppressWarnings("WeakerAccess"), +  // Public API., +  @SuppressWarnings("WeakerAccess"), +  // Public API., +  @SuppressWarnings("WeakerAccess"), +  // Public API., +  @SuppressWarnings("unused"), +  // Public API., +  @SuppressWarnings("unused"), +  // Public API., +  @SuppressWarnings("unused"), +  // Public API., +  @SuppressWarnings("WeakerAccess"), +  // Public API., +  @SuppressWarnings("unused"), +  // Public API., +  @SuppressWarnings("unused"), +  // Public API., +  @SuppressWarnings("unused"), +  Glide build(@NonNull Context context) {]
[+++ b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java, +            Collections.newSetFromMap(new WeakHashMap<LifecycleListener, Boolean>());]
[+++ b/gradle.properties, +VERSION_NAME=4.8.0]
[+++ b/.travis.yml, +    - COMPONENT=instrumentation ANDROID_TARGET=17, +    - COMPONENT=instrumentation ANDROID_TARGET=18, +    - COMPONENT=instrumentation ANDROID_TARGET=19, +    - COMPONENT=instrumentation ANDROID_TARGET=20, +    - COMPONENT=instrumentation ANDROID_TARGET=21, +++ b/.travis.yml, +    - COMPONENT=instrumentation ANDROID_TARGET=17, +    - COMPONENT=instrumentation ANDROID_TARGET=18, +    - COMPONENT=instrumentation ANDROID_TARGET=19, +    - COMPONENT=instrumentation ANDROID_TARGET=20, +    - COMPONENT=instrumentation ANDROID_TARGET=21, +++ /dev/null, +++ b/.travis.yml, +    - COMPONENT=instrumentation ANDROID_TARGET=17, +    - COMPONENT=instrumentation ANDROID_TARGET=18, +    - COMPONENT=instrumentation ANDROID_TARGET=19, +    - COMPONENT=instrumentation ANDROID_TARGET=20, +    - COMPONENT=instrumentation ANDROID_TARGET=21, +++ /dev/null, +++ b/scripts/travis_instrumentation.sh, +if [ "$TRAVIS_PULL_REQUEST" == "false" ] && [ $ANDROID_TARGET -gt 18 ]; then, +  echo "Emulator tests >= 19 are run on Firebase ignoring", +  exit 0, +fi, +, +echo "Starting emulator for $COMPONENT tests", +./scripts/travis_create_emulator.sh &, +]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +import com.google.common.collect.Lists;, +import com.squareup.javapoet.MethodSpec;, +import com.squareup.javapoet.ParameterSpec;, +    return generateSeeMethodJavadocInternal(nameOfClassContainingMethod,, +        methodSimpleName, Lists.transform(methodParameters,, +            new Function<VariableElement, Object>() {, +              @Override, +              public Object apply(VariableElement input) {, +                return getJavadocSafeName(input);, +              }, +            }));, +  }, +, +  CodeBlock generateSeeMethodJavadoc(, +      TypeName nameOfClassContainingMethod, MethodSpec methodSpec) {, +    return generateSeeMethodJavadocInternal(nameOfClassContainingMethod,, +        methodSpec.name, Lists.transform(methodSpec.parameters,, +            new Function<ParameterSpec, Object>() {, +              @Override, +              public Object apply(ParameterSpec input) {, +                return input.name;, +              }, +            }));, +  }, +, +  private CodeBlock generateSeeMethodJavadocInternal(, +      TypeName nameOfClassContainingMethod, String methodName,, +      List<Object> safeParameterNames) {, +    javadocArgs.add(methodName);, +    for (Object param : safeParameterNames) {, +      javadocArgs.add(param);, +, +  List<ExecutableElement> findInstanceMethodsReturning(TypeElement clazz, TypeMirror returnType) {, +    return FluentIterable.from(clazz.getEnclosedElements()), +        .filter(new FilterPublicMethods(returnType, MethodType.INSTANCE)), +        .transform(new ToMethod()), +        .toList();, +  }, +, +        .filter(new FilterPublicMethods((TypeMirror) null /*returnType*/, MethodType.STATIC)), +    @Nullable, +    private final TypeMirror returnType;, +    private final MethodType methodType;, +    FilterPublicMethods(@Nullable TypeMirror returnType, MethodType methodType)  {, +    FilterPublicMethods(@Nullable TypeElement returnType, MethodType methodType)  {, +      this(returnType != null ? returnType.asType() : null, methodType);, +    }, +, +    return isReturnValueTypeMatching(method, expectedReturnType.asType());, +  }, +, +  private boolean isReturnValueTypeMatching(, +      ExecutableElement method, TypeMirror expectedReturnType) {, +        method.getReturnType(), expectedReturnType);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +import com.google.common.collect.Lists;, +import com.squareup.javapoet.MethodSpec;, +import com.squareup.javapoet.ParameterSpec;, +    return generateSeeMethodJavadocInternal(nameOfClassContainingMethod,, +        methodSimpleName, Lists.transform(methodParameters,, +            new Function<VariableElement, Object>() {, +              @Override, +              public Object apply(VariableElement input) {, +                return getJavadocSafeName(input);, +              }, +            }));, +  }, +, +  CodeBlock generateSeeMethodJavadoc(, +      TypeName nameOfClassContainingMethod, MethodSpec methodSpec) {, +    return generateSeeMethodJavadocInternal(nameOfClassContainingMethod,, +        methodSpec.name, Lists.transform(methodSpec.parameters,, +            new Function<ParameterSpec, Object>() {, +              @Override, +              public Object apply(ParameterSpec input) {, +                return input.name;, +              }, +            }));, +  }, +, +  private CodeBlock generateSeeMethodJavadocInternal(, +      TypeName nameOfClassContainingMethod, String methodName,, +      List<Object> safeParameterNames) {, +    javadocArgs.add(methodName);, +    for (Object param : safeParameterNames) {, +      javadocArgs.add(param);, +, +  List<ExecutableElement> findInstanceMethodsReturning(TypeElement clazz, TypeMirror returnType) {, +    return FluentIterable.from(clazz.getEnclosedElements()), +        .filter(new FilterPublicMethods(returnType, MethodType.INSTANCE)), +        .transform(new ToMethod()), +        .toList();, +  }, +, +        .filter(new FilterPublicMethods((TypeMirror) null /*returnType*/, MethodType.STATIC)), +    @Nullable, +    private final TypeMirror returnType;, +    private final MethodType methodType;, +    FilterPublicMethods(@Nullable TypeMirror returnType, MethodType methodType)  {]
[+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +  private volatile Call call;, +    call = client.newCall(request);, +    call.enqueue(new okhttp3.Callback() {, +    Call local = call;, +    if (local != null) {, +      local.cancel();, +    }]
[+++ b/gradle.properties, +VOLLEY_VERSION=1.0.0]
[+++ /dev/null, +++ /dev/null, +++ b/integration/volley/build.gradle, +, +    defaultConfig {, +        applicationId "com.bumptech.glide.integration.volley", +        minSdkVersion 10, +        targetSdkVersion 19, +        versionCode 1, +        versionName "1.0.0", +++ /dev/null, +++ b/integration/volley/build.gradle, +, +    defaultConfig {, +        applicationId "com.bumptech.glide.integration.volley", +        minSdkVersion 10, +        targetSdkVersion 19, +        versionCode 1, +        versionName "1.0.0", +++ /dev/null, +++ /dev/null, +++ b/integration/volley/build.gradle, +, +    defaultConfig {, +        applicationId "com.bumptech.glide.integration.volley", +        minSdkVersion 10, +        targetSdkVersion 19, +        versionCode 1, +        versionName "1.0.0", +++ /dev/null, +++ b/integration/volley/src/main/AndroidManifest.xml, +          package="com.bumptech.glide.integration.volley">, +++ /dev/null, +++ b/integration/volley/build.gradle, +, +    defaultConfig {, +        applicationId "com.bumptech.glide.integration.volley", +        minSdkVersion 10, +        targetSdkVersion 19, +        versionCode 1, +        versionName "1.0.0", +++ /dev/null, +++ b/integration/volley/src/main/AndroidManifest.xml, +          package="com.bumptech.glide.integration.volley">, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFuture.java, +/*, + * Copyright (C) 2011 The Android Open Source Project, + *, + * Licensed under the Apache License, Version 2.0 (the "License");, + * you may not use this file except in compliance with the License., + * You may obtain a copy of the License at, + *, + *      http://www.apache.org/licenses/LICENSE-2.0, + *, + * Unless required by applicable law or agreed to in writing, software, + * distributed under the License is distributed on an "AS IS" BASIS,, + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + * See the License for the specific language governing permissions and, + * limitations under the License., + */, +, +package com.bumptech.glide.integration.volley;, +, +import com.android.volley.Request;, +import com.android.volley.Response;, +import com.android.volley.VolleyError;, +, +import java.util.concurrent.CancellationException;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.Future;, +import java.util.concurrent.TimeUnit;, +import java.util.concurrent.TimeoutException;, +, +/**, + * TODO: contribute cancel modifications to volley and remove this class., + *, + * A Future that represents a Volley request., + *, + * Used by providing as your response and error listeners. For example:, + * <pre>, + * RequestFuture&lt;JSONObject&gt; future = RequestFuture.newFuture();, + * MyRequest request = new MyRequest(URL, future, future);, + *, + * // If you want to be able to cancel the request:, + * future.setRequest(requestQueue.add(request));, + *, + * // Otherwise:, + * requestQueue.add(request);, + *, + * try {, + *   JSONObject response = future.get();, + *   // do something with response, + * } catch (InterruptedException e) {, + *   // handle the error, + * } catch (ExecutionException e) {, + *   // handle the error, + * }, + * </pre>, + *, + * @param <T> The type of parsed response this future expects.]
[+++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +import com.bumptech.glide.load.Key;, +import com.bumptech.glide.load.Option;, +import com.bumptech.glide.load.Options;, +import java.security.MessageDigest;, +, +  private static final String KEY_ENCODE_TRANSFORMATION =, +      "com.bumptech.glide.load.resource.gif.GifResourceEncoder.EncodeTransformation";, +   * A boolean option that, if set to <code>true</code>, causes the fully transformed, +  public static final Option<Boolean> ENCODE_TRANSFORMATION =, +      Option.disk(KEY_ENCODE_TRANSFORMATION, false, new Option.CacheKeyUpdater<Boolean>() {, +        @Override, +        public void update(Boolean value, MessageDigest messageDigest) {, +          if (value) {, +            messageDigest.update(KEY_ENCODE_TRANSFORMATION.getBytes(Key.CHARSET));, +          }, +        }, +      });, +  public EncodeStrategy getEncodeStrategy(Options options) {, +    return options.get(ENCODE_TRANSFORMATION) ? EncodeStrategy.TRANSFORMED : EncodeStrategy.SOURCE;, +  public boolean encode(Resource<GifDrawable> resource, OutputStream os, Options options) {, +    if (options.get(ENCODE_TRANSFORMATION)) {, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +import com.bumptech.glide.load.Key;, +import com.bumptech.glide.load.Option;, +import com.bumptech.glide.load.Options;, +import java.security.MessageDigest;, +, +  private static final String KEY_ENCODE_TRANSFORMATION =, +      "com.bumptech.glide.load.resource.gif.GifResourceEncoder.EncodeTransformation";, +   * A boolean option that, if set to <code>true</code>, causes the fully transformed, +  public static final Option<Boolean> ENCODE_TRANSFORMATION =, +      Option.disk(KEY_ENCODE_TRANSFORMATION, false, new Option.CacheKeyUpdater<Boolean>() {, +        @Override, +        public void update(Boolean value, MessageDigest messageDigest) {, +          if (value) {, +            messageDigest.update(KEY_ENCODE_TRANSFORMATION.getBytes(Key.CHARSET));, +          }, +        }, +      });, +  public EncodeStrategy getEncodeStrategy(Options options) {, +    return options.get(ENCODE_TRANSFORMATION) ? EncodeStrategy.TRANSFORMED : EncodeStrategy.SOURCE;, +  public boolean encode(Resource<GifDrawable> resource, OutputStream os, Options options) {, +    if (options.get(ENCODE_TRANSFORMATION)) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +import com.bumptech.glide.load.Options;, +      Options options) {, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +import com.bumptech.glide.load.Key;, +import com.bumptech.glide.load.Option;, +import com.bumptech.glide.load.Options;, +import java.security.MessageDigest;, +, +  private static final String KEY_ENCODE_TRANSFORMATION =, +      "com.bumptech.glide.load.resource.gif.GifResourceEncoder.EncodeTransformation";, +   * A boolean option that, if set to <code>true</code>, causes the fully transformed, +  public static final Option<Boolean> ENCODE_TRANSFORMATION =, +      Option.disk(KEY_ENCODE_TRANSFORMATION, false, new Option.CacheKeyUpdater<Boolean>() {, +        @Override, +        public void update(Boolean value, MessageDigest messageDigest) {, +          if (value) {, +            messageDigest.update(KEY_ENCODE_TRANSFORMATION.getBytes(Key.CHARSET));, +          }, +        }, +      });, +  public EncodeStrategy getEncodeStrategy(Options options) {, +    return options.get(ENCODE_TRANSFORMATION) ? EncodeStrategy.TRANSFORMED : EncodeStrategy.SOURCE;, +  public boolean encode(Resource<GifDrawable> resource, OutputStream os, Options options) {, +    if (options.get(ENCODE_TRANSFORMATION)) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +import com.bumptech.glide.load.Options;, +      Options options) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java, +import com.bumptech.glide.load.Options;, +      Options options) {, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +import com.bumptech.glide.load.Key;, +import com.bumptech.glide.load.Option;, +import com.bumptech.glide.load.Options;, +import java.security.MessageDigest;, +, +  private static final String KEY_ENCODE_TRANSFORMATION =, +      "com.bumptech.glide.load.resource.gif.GifResourceEncoder.EncodeTransformation";, +   * A boolean option that, if set to <code>true</code>, causes the fully transformed, +  public static final Option<Boolean> ENCODE_TRANSFORMATION =, +      Option.disk(KEY_ENCODE_TRANSFORMATION, false, new Option.CacheKeyUpdater<Boolean>() {, +        @Override, +        public void update(Boolean value, MessageDigest messageDigest) {, +          if (value) {, +            messageDigest.update(KEY_ENCODE_TRANSFORMATION.getBytes(Key.CHARSET));, +          }, +        }, +      });, +  public EncodeStrategy getEncodeStrategy(Options options) {, +    return options.get(ENCODE_TRANSFORMATION) ? EncodeStrategy.TRANSFORMED : EncodeStrategy.SOURCE;, +  public boolean encode(Resource<GifDrawable> resource, OutputStream os, Options options) {, +    if (options.get(ENCODE_TRANSFORMATION)) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +import com.bumptech.glide.load.Options;, +      Options options) {]
[+++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]src[/\\]androidTest[/\\].*[/\\]ResourceIds" checks=".*"/>, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]src[/\\]androidTest[/\\].*[/\\]ResourceIds" checks=".*"/>, +++ b/gradle.properties, +# Matches the version in Google., +MOCKITO_VERSION=1.9.5, +MOCKITO_ANDROID_VERSION=2.11.0, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]src[/\\]androidTest[/\\].*[/\\]ResourceIds" checks=".*"/>, +++ b/gradle.properties, +# Matches the version in Google., +MOCKITO_VERSION=1.9.5, +MOCKITO_ANDROID_VERSION=2.11.0, +++ b/integration/gifencoder/build.gradle, +    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}", +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]src[/\\]androidTest[/\\].*[/\\]ResourceIds" checks=".*"/>, +++ b/gradle.properties, +# Matches the version in Google., +MOCKITO_VERSION=1.9.5, +MOCKITO_ANDROID_VERSION=2.11.0, +++ b/integration/gifencoder/build.gradle, +    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}", +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +    when(decoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]src[/\\]androidTest[/\\].*[/\\]ResourceIds" checks=".*"/>, +++ b/gradle.properties, +# Matches the version in Google., +MOCKITO_VERSION=1.9.5, +MOCKITO_ANDROID_VERSION=2.11.0, +++ b/integration/gifencoder/build.gradle, +    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}", +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +    when(decoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));, +++ b/library/build.gradle, +    androidTestCompile "org.mockito:mockito-android:${MOCKITO_ANDROID_VERSION}", +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]src[/\\]androidTest[/\\].*[/\\]ResourceIds" checks=".*"/>, +++ b/gradle.properties, +# Matches the version in Google., +MOCKITO_VERSION=1.9.5, +MOCKITO_ANDROID_VERSION=2.11.0, +++ b/integration/gifencoder/build.gradle, +    testCompile "org.mockito:mockito-core:${MOCKITO_VERSION}", +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +    when(decoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));, +++ b/library/build.gradle, +    androidTestCompile "org.mockito:mockito-android:${MOCKITO_ANDROID_VERSION}", +++ b/library/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java, +package com.bumptech.glide;, +, +import static com.google.common.truth.Truth.assertThat;, +, +import android.content.ContentResolver;, +import android.content.Context;, +import android.content.Intent;, +import android.content.pm.PackageInfo;, +import android.content.pm.PackageManager;, +import android.content.pm.PackageManager.NameNotFoundException;, +import android.content.pm.ResolveInfo;, +import android.content.res.Resources;, +import android.graphics.Bitmap;, +import android.graphics.drawable.Drawable;, +import android.net.Uri;, +import android.support.test.InstrumentationRegistry;, +import android.support.test.runner.AndroidJUnit4;, +import com.bumptech.glide.test.ResourceIds;, +import java.util.HashSet;, +import java.util.List;, +import java.util.Set;, +import java.util.concurrent.ExecutionException;, +import org.junit.After;, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +, +@RunWith(AndroidJUnit4.class), +public class NonBitmapDrawableResourcesTest {, +  private Context context;, +, +  @Before, +  public void setUp() {, +    context = InstrumentationRegistry.getTargetContext();, +  }, +, +  @After, +  public void tearDown() {, +    Glide.tearDown();, +  }, +, +  @Test, +  public void load_withBitmapResourceId_asDrawable_producesNonNullDrawable(), +      throws ExecutionException, InterruptedException {, +    Drawable drawable = Glide.with(context), +        .load(android.R.drawable.star_big_off), +        .submit(), +        .get();, +    assertThat(drawable).isNotNull();]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +import java.util.ArrayList;, +    // Enforce ordering across compilers (Internal and External compilers end up disagreeing on the, +    // order produced by the Set additions above.), +    ArrayList<String> suppressionsList = new ArrayList<>(suppressions);, +    Collections.sort(suppressionsList);, +    for (String suppression : suppressionsList) {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +import java.util.ArrayList;, +    // Enforce ordering across compilers (Internal and External compilers end up disagreeing on the, +    // order produced by the Set additions above.), +    ArrayList<String> suppressionsList = new ArrayList<>(suppressions);, +    Collections.sort(suppressionsList);, +    for (String suppression : suppressionsList) {, +++ b/gradle.properties, +ANDROID_SUPPORT_VERSION=27.0.2, +JUNIT_VERSION=4.13-SNAPSHOT, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +import java.util.ArrayList;, +    // Enforce ordering across compilers (Internal and External compilers end up disagreeing on the, +    // order produced by the Set additions above.), +    ArrayList<String> suppressionsList = new ArrayList<>(suppressions);, +    Collections.sort(suppressionsList);, +    for (String suppression : suppressionsList) {, +++ b/gradle.properties, +ANDROID_SUPPORT_VERSION=27.0.2, +JUNIT_VERSION=4.13-SNAPSHOT, +++ b/instrumentation/build.gradle, +    androidTestImplementation "junit:junit:${JUNIT_VERSION}", +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +import java.util.ArrayList;, +    // Enforce ordering across compilers (Internal and External compilers end up disagreeing on the, +    // order produced by the Set additions above.), +    ArrayList<String> suppressionsList = new ArrayList<>(suppressions);, +    Collections.sort(suppressionsList);, +    for (String suppression : suppressionsList) {, +++ b/gradle.properties, +ANDROID_SUPPORT_VERSION=27.0.2, +JUNIT_VERSION=4.13-SNAPSHOT, +++ b/instrumentation/build.gradle, +    androidTestImplementation "junit:junit:${JUNIT_VERSION}", +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import static org.junit.Assert.assertThrows;, +import static org.junit.Assert.fail;, +import com.bumptech.glide.request.target.Target;, +import java.util.concurrent.Future;, +import org.junit.function.ThrowingRunnable;, +        Target<Drawable> target =, +    FutureTarget<Drawable> loadFromSourceFuture = GlideApp.with(context), +      fail("Expected only from cache Future to time out");, +, +    assertThat(concurrency.get(loadFromSourceFuture)).isNotNull();, +    final Future<Drawable> firstQueuedFuture = GlideApp.with(context), +    // The first request only from cache should fail because the item is not in cache., +    assertThrows(RuntimeException.class, new ThrowingRunnable() {, +      @Override, +      public void run() throws Throwable {, +        concurrency.get(firstQueuedFuture);, +      }, +    });, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +import java.util.ArrayList;, +    // Enforce ordering across compilers (Internal and External compilers end up disagreeing on the, +    // order produced by the Set additions above.), +    ArrayList<String> suppressionsList = new ArrayList<>(suppressions);, +    Collections.sort(suppressionsList);, +    for (String suppression : suppressionsList) {, +++ b/gradle.properties, +ANDROID_SUPPORT_VERSION=27.0.2, +JUNIT_VERSION=4.13-SNAPSHOT, +++ b/instrumentation/build.gradle, +    androidTestImplementation "junit:junit:${JUNIT_VERSION}", +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import static org.junit.Assert.assertThrows;, +import static org.junit.Assert.fail;, +import com.bumptech.glide.request.target.Target;, +import java.util.concurrent.Future;, +import org.junit.function.ThrowingRunnable;, +        Target<Drawable> target =, +    FutureTarget<Drawable> loadFromSourceFuture = GlideApp.with(context), +      fail("Expected only from cache Future to time out");, +, +    assertThat(concurrency.get(loadFromSourceFuture)).isNotNull();, +    final Future<Drawable> firstQueuedFuture = GlideApp.with(context), +    // The first request only from cache should fail because the item is not in cache., +    assertThrows(RuntimeException.class, new ThrowingRunnable() {, +      @Override, +      public void run() throws Throwable {, +        concurrency.get(firstQueuedFuture);, +      }, +    });, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ExternallyClearedDiskCacheTest.java, +package com.bumptech.glide;, +, +import static com.google.common.truth.Truth.assertThat;, +import static org.mockito.Mockito.mock;, +, +import android.content.Context;, +import android.graphics.drawable.Drawable;, +import android.support.test.InstrumentationRegistry;]
[+++ b/library/src/com/bumptech/glide/resize/ImageManager.java, +import com.bumptech.glide.resize.bitmap_recycle.LruBitmapPool;, +                    bitmapPool = new LruBitmapPool(getSafeMemoryCacheSize(context));, +++ b/library/src/com/bumptech/glide/resize/ImageManager.java, +import com.bumptech.glide.resize.bitmap_recycle.LruBitmapPool;, +                    bitmapPool = new LruBitmapPool(getSafeMemoryCacheSize(context));, +++ b/library/src/com/bumptech/glide/resize/bitmap_recycle/LruBitmapPool.java, +package com.bumptech.glide.resize.bitmap_recycle;, +, +import android.graphics.Bitmap;, +import com.bumptech.glide.util.Log;, +, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.LinkedList;, +import java.util.List;, +import java.util.Map;, +, +/**, + * Created with IntelliJ IDEA., + * User: sam, + * Date: 7/10/13, + * Time: 1:47 PM, + * To change this template use File | Settings | File Templates., + */, +public class LruBitmapPool implements BitmapPool {, +    private final Map<Integer, ArrayList<Bitmap>> pool = new HashMap<Integer, ArrayList<Bitmap>>();, +    //Typically there should only be a handful of keys (often 1 or 2) so, +    //iterating over this list should be fast, +    private final LinkedList<Integer> keys = new LinkedList<Integer>();, +, +    private final int maxSize;, +    private int currentSize = 0;, +, +    public LruBitmapPool(int maxSize) {, +        this.maxSize = maxSize;, +    }, +, +    @Override, +    public synchronized boolean put(Bitmap bitmap) {, +        final int key = getKey(bitmap);, +        final int size = getSize(bitmap);, +, +        ArrayList<Bitmap> bitmaps = pool.get(key);, +        if (bitmaps == null) {, +            bitmaps = new ArrayList<Bitmap>();, +            pool.put(key, bitmaps);, +        } else {, +            removeKey(key);, +        }, +        keys.addFirst(key);, +        currentSize += size;, +, +        bitmaps.add(bitmap);, +, +        maybeEvict();, +, +        return true;, +    }, +, +    private void maybeEvict() {, +        while (currentSize > maxSize) {, +            final Integer key = keys.getLast();, +            List<Bitmap> toRemove = pool.get(key);, +            while (toRemove.size() > 0 && currentSize > maxSize) {, +                Bitmap removed = toRemove.remove(toRemove.size()-1);, +                currentSize -= getSize(removed);, +            }, +            if (toRemove.size() == 0) {, +                removeKey(key);, +            }, +        }, +    }, +, +    @Override, +    public synchronized Bitmap get(int width, int height) {, +        final int key = getKey(width, height);, +        final ArrayList<Bitmap> list = pool.get(key);, +        final Bitmap result;, +        if (list != null && list.size() > 0) {, +            result = list.remove(list.size()-1); //most efficient to remove from the end of an ArrayList, +            currentSize -= getSize(result);, +            removeKey(key);, +            if (list.size() > 0) {, +                keys.addFirst(key);, +            }, +        } else {, +            Log.d("LBP: missing bitmap for width=" + width + " height=" + height);, +            result = null;, +        }, +        return result;, +    }, +, +    //keys.remove(int) -> remove index int, not object int :(, +    private void removeKey(int key) {, +        keys.remove(new Integer(key));, +    }, +, +    private int getKey(Bitmap bitmap) {, +        return getKey(bitmap.getWidth(), bitmap.getHeight());]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java]
[+++ b/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java, +    public void testDoesNotNotifyTargetTwiceIfClearedTwiceInARow() {, +        GenericRequest request = harness.getRequest();, +        request.clear();, +        request.clear();, +, +        verify(harness.target, times(1)).onLoadCleared(any(Drawable.class));, +    }, +, +    @Test, +++ b/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java, +    public void testDoesNotNotifyTargetTwiceIfClearedTwiceInARow() {, +        GenericRequest request = harness.getRequest();, +        request.clear();, +        request.clear();, +, +        verify(harness.target, times(1)).onLoadCleared(any(Drawable.class));, +    }, +, +    @Test, +++ b/library/src/androidTest/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java, +    public void testClearsThumbRequestOnFullRequestComplete_withNonNullParent() {, +        verify(thumb).clear();, +++ b/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java, +    public void testDoesNotNotifyTargetTwiceIfClearedTwiceInARow() {, +        GenericRequest request = harness.getRequest();, +        request.clear();, +        request.clear();, +, +        verify(harness.target, times(1)).onLoadCleared(any(Drawable.class));, +    }, +, +    @Test, +++ b/library/src/androidTest/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java, +    public void testClearsThumbRequestOnFullRequestComplete_withNonNullParent() {, +        verify(thumb).clear();, +++ b/library/src/main/java/com/bumptech/glide/request/GenericRequest.java, +        /** Failed to load media, may be restarted. */, +        /** Cleared by the user with a placeholder set, may not be restarted. */, +        CLEARED,, +        if (status == Status.CLEARED) {, +            return;, +        }, +        // Must be after cancel()., +        status = Status.CLEARED;, +        return status == Status.CANCELLED || status == Status.CLEARED;, +++ b/library/src/androidTest/java/com/bumptech/glide/request/GenericRequestTest.java, +    public void testDoesNotNotifyTargetTwiceIfClearedTwiceInARow() {, +        GenericRequest request = harness.getRequest();, +        request.clear();, +        request.clear();, +, +        verify(harness.target, times(1)).onLoadCleared(any(Drawable.class));, +    }, +, +    @Test, +++ b/library/src/androidTest/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java, +    public void testClearsThumbRequestOnFullRequestComplete_withNonNullParent() {, +        verify(thumb).clear();, +++ b/library/src/main/java/com/bumptech/glide/request/GenericRequest.java, +        /** Failed to load media, may be restarted. */, +        /** Cleared by the user with a placeholder set, may not be restarted. */, +        CLEARED,, +        if (status == Status.CLEARED) {, +            return;, +        }, +        // Must be after cancel()., +        status = Status.CLEARED;, +        return status == Status.CANCELLED || status == Status.CLEARED;, +++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java, +        if (coordinator != null) {, +        thumb.clear();]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import java.util.ArrayList;, +import java.util.List;, +  @Nullable private List<RequestListener<TranscodeType>> requestListeners;, +   * <p>Subsequent calls to this method will replace previously set listeners. To set multiple, +   * listeners, use {@link #addListener} instead., +   *, +    this.requestListeners = null;, +    return addListener(requestListener);, +  }, +  /**, +   * Adds a {@link RequestListener}. If called multiple times, all passed, +   * {@link RequestListener listeners} will be called in order., +   *, +   * @param requestListener The request listener to use. If {@code null}, this method is a noop., +   * @return This request builder., +   */, +  @NonNull, +  @CheckResult, +  public RequestBuilder<TranscodeType> addListener(, +      @Nullable RequestListener<TranscodeType> requestListener) {, +    if (requestListener != null) {, +      if (this.requestListeners == null) {, +        this.requestListeners = new ArrayList<>();, +      }, +      this.requestListeners.add(requestListener);, +    }, +        requestListeners,, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import java.util.ArrayList;, +import java.util.List;, +  @Nullable private List<RequestListener<TranscodeType>> requestListeners;, +   * <p>Subsequent calls to this method will replace previously set listeners. To set multiple, +   * listeners, use {@link #addListener} instead., +   *, +    this.requestListeners = null;, +    return addListener(requestListener);, +  }, +  /**, +   * Adds a {@link RequestListener}. If called multiple times, all passed, +   * {@link RequestListener listeners} will be called in order., +   *, +   * @param requestListener The request listener to use. If {@code null}, this method is a noop., +   * @return This request builder., +   */, +  @NonNull, +  @CheckResult, +  public RequestBuilder<TranscodeType> addListener(, +      @Nullable RequestListener<TranscodeType> requestListener) {, +    if (requestListener != null) {, +      if (this.requestListeners == null) {, +        this.requestListeners = new ArrayList<>();, +      }, +      this.requestListeners.add(requestListener);, +    }, +        requestListeners,, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +import java.util.List;, +  @Nullable private List<RequestListener<R>> requestListeners;, +      @Nullable List<RequestListener<R>> requestListeners,, +        requestListeners,, +      @Nullable List<RequestListener<R>> requestListeners,, +    this.requestListeners = requestListeners;, +    requestListeners = null;, +      boolean anyListenerHandledUpdatingTarget = false;, +      if (requestListeners != null) {, +        for (RequestListener<R> listener : requestListeners) {, +          anyListenerHandledUpdatingTarget |=, +              listener.onResourceReady(result, model, target, dataSource, isFirstResource);, +        }, +      }, +      anyListenerHandledUpdatingTarget |=, +          targetListener != null, +              && targetListener.onResourceReady(result, model, target, dataSource, isFirstResource);, +, +      if (!anyListenerHandledUpdatingTarget) {, +      boolean anyListenerHandledUpdatingTarget = false;, +      if (requestListeners != null) {, +        for (RequestListener<R> listener : requestListeners) {, +          anyListenerHandledUpdatingTarget |=, +              listener.onLoadFailed(e, model, target, isFirstReadyResource());, +        }, +      }, +      anyListenerHandledUpdatingTarget |=, +          targetListener != null, +              && targetListener.onLoadFailed(e, model, target, isFirstReadyResource());, +, +      if (!anyListenerHandledUpdatingTarget) {, +          // compare them using equals(). We can however, at least assert that the same amount of, +          // request listeners are present in both requests, +          && listenerCountEquals(this, that);, +  private static boolean listenerCountEquals(SingleRequest<?> first, SingleRequest<?> second) {, +    int firstListenerCount = first.requestListeners == null ? 0 : first.requestListeners.size();, +    int secondListenerCount = second.requestListeners == null ? 0 : second.requestListeners.size();, +    return firstListenerCount == secondListenerCount;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import java.util.ArrayList;, +import java.util.List;]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import java.util.Map;, +        Request.Builder requestBuilder = new Request.Builder(), +                .url(url.toStringUrl());, +        for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {, +          requestBuilder.addHeader(headerEntry.getKey(), headerEntry.getValue());, +        }, +        Request request = requestBuilder.build();, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import java.util.Map;, +        Request.Builder requestBuilder = new Request.Builder(), +                .url(url.toStringUrl());, +        for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {, +          requestBuilder.addHeader(headerEntry.getKey(), headerEntry.getValue());, +        }, +        Request request = requestBuilder.build();, +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.when;, +import com.bumptech.glide.load.model.Headers;, +import java.util.HashMap;, +import java.util.Map;, +    @Test, +    public void testAppliesHeadersInGlideUrl() throws Exception {, +      mockWebServer.enqueue(new MockResponse().setResponseCode(200));, +      String headerField = "field";, +      String headerValue = "value";, +      Map<String, String> headersMap = new HashMap<String, String>();, +      headersMap.put(headerField, headerValue);, +      Headers headers = mock(Headers.class);, +      when(headers.getHeaders()).thenReturn(headersMap);, +, +      getFetcher(headers).loadData(Priority.HIGH);, +, +      assertThat(mockWebServer.takeRequest().getHeader(headerField)).isEqualTo(headerValue);, +    }, +, +      return getFetcher(Headers.NONE);, +    }, +, +    private DataFetcher<InputStream> getFetcher(Headers headers) {, +        return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString(), headers), requestFuture);, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import java.util.Map;, +        Request.Builder requestBuilder = new Request.Builder(), +                .url(url.toStringUrl());, +        for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {, +          requestBuilder.addHeader(headerEntry.getKey(), headerEntry.getValue());, +        }, +        Request request = requestBuilder.build();, +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.when;, +import com.bumptech.glide.load.model.Headers;, +import java.util.HashMap;, +import java.util.Map;, +    @Test, +    public void testAppliesHeadersInGlideUrl() throws Exception {, +      mockWebServer.enqueue(new MockResponse().setResponseCode(200));, +      String headerField = "field";, +      String headerValue = "value";, +      Map<String, String> headersMap = new HashMap<String, String>();, +      headersMap.put(headerField, headerValue);, +      Headers headers = mock(Headers.class);, +      when(headers.getHeaders()).thenReturn(headersMap);, +, +      getFetcher(headers).loadData(Priority.HIGH);, +, +      assertThat(mockWebServer.takeRequest().getHeader(headerField)).isEqualTo(headerValue);, +    }, +, +      return getFetcher(Headers.NONE);, +    }, +, +    private DataFetcher<InputStream> getFetcher(Headers headers) {, +        return new VolleyStreamFetcher(requestQueue, new GlideUrl(url.toString(), headers), requestFuture);, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyRequestFactory.java, +import java.util.Map;, +    Request<byte[]> create(String url, VolleyRequestFuture<InputStream> future, Priority priority,, +        Map<String, String> headers);, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import java.util.Map;, +        Request.Builder requestBuilder = new Request.Builder(), +                .url(url.toStringUrl());, +        for (Map.Entry<String, String> headerEntry : url.getHeaders().entrySet()) {, +          requestBuilder.addHeader(headerEntry.getKey(), headerEntry.getValue());, +        }, +        Request request = requestBuilder.build();, +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.when;, +import com.bumptech.glide.load.model.Headers;, +import java.util.HashMap;, +import java.util.Map;, +    @Test, +    public void testAppliesHeadersInGlideUrl() throws Exception {, +      mockWebServer.enqueue(new MockResponse().setResponseCode(200));, +      String headerField = "field";, +      String headerValue = "value";, +      Map<String, String> headersMap = new HashMap<String, String>();]
[+++ b/glide/build.gradle, +        def classpathFiles = files(getAndroidLibraryVariantsForJar(variantName).collect {, +        classpathFiles += files(getAndroidLibraryVariantsForJavadoc(variantName).collect {, +        classpathFiles += (getInternalJavaProjectsForJavadoc().collect {, +            it.sourceSets.main.compileClasspath.files, +        }.flatten()), +        classpathFiles += (getInternalJavaProjectsForJar().collect {, +            it.sourceSets.main.compileClasspath.files, +        }.flatten()), +        classpathFiles += getInternalAndroidProjectsForJavadoc().collect {, +        classpath = files(classpathFiles), +++ b/glide/build.gradle, +        def classpathFiles = files(getAndroidLibraryVariantsForJar(variantName).collect {, +        classpathFiles += files(getAndroidLibraryVariantsForJavadoc(variantName).collect {, +        classpathFiles += (getInternalJavaProjectsForJavadoc().collect {, +            it.sourceSets.main.compileClasspath.files, +        }.flatten()), +        classpathFiles += (getInternalJavaProjectsForJar().collect {, +            it.sourceSets.main.compileClasspath.files, +        }.flatten()), +        classpathFiles += getInternalAndroidProjectsForJavadoc().collect {, +        classpath = files(classpathFiles), +++ b/gradle.properties, +SUPPORT_V4_VERSION=25.3.1, +SUPPORT_V7_VERSION=25.3.1, +ANDROID_GRADLE_VERSION=2.3.0, +++ b/glide/build.gradle, +        def classpathFiles = files(getAndroidLibraryVariantsForJar(variantName).collect {, +        classpathFiles += files(getAndroidLibraryVariantsForJavadoc(variantName).collect {, +        classpathFiles += (getInternalJavaProjectsForJavadoc().collect {, +            it.sourceSets.main.compileClasspath.files, +        }.flatten()), +        classpathFiles += (getInternalJavaProjectsForJar().collect {, +            it.sourceSets.main.compileClasspath.files, +        }.flatten()), +        classpathFiles += getInternalAndroidProjectsForJavadoc().collect {, +        classpath = files(classpathFiles), +++ b/gradle.properties, +SUPPORT_V4_VERSION=25.3.1, +SUPPORT_V7_VERSION=25.3.1, +ANDROID_GRADLE_VERSION=2.3.0, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Fri Mar 31 22:27:21 PDT 2017, +distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip, +++ b/glide/build.gradle, +        def classpathFiles = files(getAndroidLibraryVariantsForJar(variantName).collect {, +        classpathFiles += files(getAndroidLibraryVariantsForJavadoc(variantName).collect {, +        classpathFiles += (getInternalJavaProjectsForJavadoc().collect {, +            it.sourceSets.main.compileClasspath.files, +        }.flatten()), +        classpathFiles += (getInternalJavaProjectsForJar().collect {, +            it.sourceSets.main.compileClasspath.files, +        }.flatten()), +        classpathFiles += getInternalAndroidProjectsForJavadoc().collect {, +        classpath = files(classpathFiles), +++ b/gradle.properties, +SUPPORT_V4_VERSION=25.3.1, +SUPPORT_V7_VERSION=25.3.1, +ANDROID_GRADLE_VERSION=2.3.0, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Fri Mar 31 22:27:21 PDT 2017, +distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip, +++ b/library/lint.xml, +    <!-- TODO: Fix this after RequestManager#get(View) uses official APIs -->, +    <issue id="RestrictedApi" severity="ignore"/>, +++ b/glide/build.gradle, +        def classpathFiles = files(getAndroidLibraryVariantsForJar(variantName).collect {, +        classpathFiles += files(getAndroidLibraryVariantsForJavadoc(variantName).collect {, +        classpathFiles += (getInternalJavaProjectsForJavadoc().collect {, +            it.sourceSets.main.compileClasspath.files, +        }.flatten()), +        classpathFiles += (getInternalJavaProjectsForJar().collect {, +            it.sourceSets.main.compileClasspath.files, +        }.flatten()), +        classpathFiles += getInternalAndroidProjectsForJavadoc().collect {, +        classpath = files(classpathFiles), +++ b/gradle.properties, +SUPPORT_V4_VERSION=25.3.1, +SUPPORT_V7_VERSION=25.3.1, +ANDROID_GRADLE_VERSION=2.3.0, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Fri Mar 31 22:27:21 PDT 2017, +distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip, +++ b/library/lint.xml, +    <!-- TODO: Fix this after RequestManager#get(View) uses official APIs -->, +    <issue id="RestrictedApi" severity="ignore"/>, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +++ b/glide/build.gradle, +        def classpathFiles = files(getAndroidLibraryVariantsForJar(variantName).collect {, +        classpathFiles += files(getAndroidLibraryVariantsForJavadoc(variantName).collect {, +        classpathFiles += (getInternalJavaProjectsForJavadoc().collect {, +            it.sourceSets.main.compileClasspath.files, +        }.flatten()), +        classpathFiles += (getInternalJavaProjectsForJar().collect {, +            it.sourceSets.main.compileClasspath.files, +        }.flatten()), +        classpathFiles += getInternalAndroidProjectsForJavadoc().collect {, +        classpath = files(classpathFiles), +++ b/gradle.properties, +SUPPORT_V4_VERSION=25.3.1]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        RequestManager requestManager = RequestManagerRetriever.get(context);, +        return new ModelRequest(context, Glide.get(context), requestManager);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        RequestManager requestManager = RequestManagerRetriever.get(context);, +        return new ModelRequest(context, Glide.get(context), requestManager);, +++ b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitor.java, +package com.bumptech.glide.manager;, +, +interface ConnectivityMonitor {, +, +    public interface ConnectivityListener {, +        public void onConnectivityChanged(boolean isConnected);, +    }, +, +    public void register();, +, +    public void unregister();, +}, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        RequestManager requestManager = RequestManagerRetriever.get(context);, +        return new ModelRequest(context, Glide.get(context), requestManager);, +++ b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitor.java, +package com.bumptech.glide.manager;, +, +interface ConnectivityMonitor {, +, +    public interface ConnectivityListener {, +        public void onConnectivityChanged(boolean isConnected);, +    }, +, +    public void register();, +, +    public void unregister();, +}, +++ b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java, +package com.bumptech.glide.manager;, +, +import android.content.Context;, +import android.content.pm.PackageManager;, +, +class ConnectivityMonitorFactory {, +    public ConnectivityMonitor build(Context context, ConnectivityMonitor.ConnectivityListener listener) {, +        int res = context.checkCallingOrSelfPermission("android.permission.ACCESS_NETWORK_STATE");, +        boolean hasPermission = res == PackageManager.PERMISSION_GRANTED;, +        if (hasPermission) {, +            return new DefaultConnectivityMonitor(context, listener);, +        } else {, +            return new NullConnectivityMonitor();, +        }, +    }, +}, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        RequestManager requestManager = RequestManagerRetriever.get(context);, +        return new ModelRequest(context, Glide.get(context), requestManager);, +++ b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitor.java, +package com.bumptech.glide.manager;, +, +interface ConnectivityMonitor {, +, +    public interface ConnectivityListener {, +        public void onConnectivityChanged(boolean isConnected);, +    }, +, +    public void register();, +, +    public void unregister();, +}, +++ b/library/src/main/java/com/bumptech/glide/manager/ConnectivityMonitorFactory.java, +package com.bumptech.glide.manager;, +, +import android.content.Context;, +import android.content.pm.PackageManager;, +, +class ConnectivityMonitorFactory {, +    public ConnectivityMonitor build(Context context, ConnectivityMonitor.ConnectivityListener listener) {, +        int res = context.checkCallingOrSelfPermission("android.permission.ACCESS_NETWORK_STATE");, +        boolean hasPermission = res == PackageManager.PERMISSION_GRANTED;, +        if (hasPermission) {, +            return new DefaultConnectivityMonitor(context, listener);, +        } else {, +            return new NullConnectivityMonitor();, +        }, +    }, +}, +++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java, +package com.bumptech.glide.manager;, +, +import android.content.BroadcastReceiver;, +import android.content.Context;, +import android.content.Intent;, +import android.content.IntentFilter;, +import android.net.ConnectivityManager;, +import android.net.NetworkInfo;, +, +class DefaultConnectivityMonitor implements ConnectivityMonitor {, +    private final Context context;, +    private final ConnectivityListener listener;, +, +    private boolean isConnected;]
[+++ b/.gitignore, +**/.idea/*, +++ b/.gitignore, +**/.idea/*, +++ b/library/.gitignore, +tests/ant.properties, +tests/local.properties, +tests/gen/**/*, +, +++ b/.gitignore, +**/.idea/*, +++ b/library/.gitignore, +tests/ant.properties, +tests/local.properties, +tests/gen/**/*, +, +++ b/library/AndroidManifest.xml, +  <application />, +++ b/.gitignore, +**/.idea/*, +++ b/library/.gitignore, +tests/ant.properties, +tests/local.properties, +tests/gen/**/*, +, +++ b/library/AndroidManifest.xml, +  <application />, +++ b/library/tests/AndroidManifest.xml, +<?xml version="1.0" encoding="utf-8"?>, +<!-- package name must be unique so suffix with "tests" so package loader doesn't ignore us -->, +<manifest xmlns:android="http://schemas.android.com/apk/res/android", +          package="com.bumptech.glide.tests", +          android:versionCode="1", +          android:versionName="1.0">, +  <uses-sdk android:minSdkVersion="8" />, +  <!-- We add an application tag here just so that we can indicate that, +       this package needs to link against the android.test library,, +       which is needed when building test cases. -->, +  <application>, +    <uses-library android:name="android.test.runner"/>, +  </application>, +  <!--, +  This declares that this application uses the instrumentation test runner targeting, +  the package of com.bumptech.glide.  To run the tests use the command:, +  "adb shell am instrument -w com.bumptech.glide.tests/android.test.InstrumentationTestRunner", +  -->, +  <instrumentation android:name="android.test.InstrumentationTestRunner", +                   android:targetPackage="com.bumptech.glide", +                   android:label="Tests for com.bumptech.glide"/>, +</manifest>, +++ b/.gitignore, +**/.idea/*, +++ b/library/.gitignore, +tests/ant.properties, +tests/local.properties, +tests/gen/**/*, +, +++ b/library/AndroidManifest.xml, +  <application />, +++ b/library/tests/AndroidManifest.xml, +<?xml version="1.0" encoding="utf-8"?>, +<!-- package name must be unique so suffix with "tests" so package loader doesn't ignore us -->, +<manifest xmlns:android="http://schemas.android.com/apk/res/android", +          package="com.bumptech.glide.tests", +          android:versionCode="1", +          android:versionName="1.0">, +  <uses-sdk android:minSdkVersion="8" />, +  <!-- We add an application tag here just so that we can indicate that, +       this package needs to link against the android.test library,, +       which is needed when building test cases. -->, +  <application>, +    <uses-library android:name="android.test.runner"/>, +  </application>, +  <!--, +  This declares that this application uses the instrumentation test runner targeting, +  the package of com.bumptech.glide.  To run the tests use the command:, +  "adb shell am instrument -w com.bumptech.glide.tests/android.test.InstrumentationTestRunner", +  -->, +  <instrumentation android:name="android.test.InstrumentationTestRunner", +                   android:targetPackage="com.bumptech.glide", +                   android:label="Tests for com.bumptech.glide"/>, +</manifest>, +++ b/library/tests/build.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<project name="tests" default="help">, +, +  <!-- The local.properties file is created and updated by the 'android' tool., +       It contains the path to the SDK. It should *NOT* be checked into, +       Version Control Systems. -->, +  <property file="local.properties"/>, +, +  <!-- The ant.properties file can be created by you. It is only edited by the, +       'android' tool to add properties to it., +       This is the place to change some Ant specific build properties., +       Here are some properties you may want to change/update:, +, +       source.dir, +           The name of the source directory. Default is 'src'., +       out.dir, +           The name of the output directory. Default is 'bin'.]
[+++ b/library/src/androidTest/java/com/bumptech/glide/manager/RequestTrackerTest.java, +import static org.mockito.Mockito.doAnswer;, +import org.mockito.invocation.InvocationOnMock;, +import org.mockito.stubbing.Answer;, +    public void testAvoidsConcurrentModificationWhenResuming() {, +        Request first = mock(Request.class);, +        Request second = mock(Request.class);, +, +        doAnswer(new RemoveRequest(second)).when(first).begin();, +, +        tracker.addRequest(mock(Request.class));, +        tracker.addRequest(first);, +        tracker.addRequest(second);, +, +        tracker.resumeRequests();, +    }, +, +    @Test, +    public void testAvoidsConcurrentModificationWhenPausing() {, +        Request first = mock(Request.class);, +        Request second = mock(Request.class);, +, +        when(first.isRunning()).thenReturn(true);, +        doAnswer(new RemoveRequest(second)).when(first).pause();, +, +        tracker.addRequest(mock(Request.class));, +        tracker.addRequest(first);, +        tracker.addRequest(second);, +, +        tracker.pauseRequests();, +    }, +, +    @Test, +    public void testAvoidsConcurrentModificationWhenClearing() {, +        Request first = mock(Request.class);, +        Request second = mock(Request.class);, +, +        doAnswer(new RemoveRequest(second)).when(first).clear();, +, +        tracker.addRequest(mock(Request.class));, +        tracker.addRequest(first);, +        tracker.addRequest(second);, +, +        tracker.clearRequests();, +    }, +, +    @Test, +    public void testAvoidsConcurrentModificationWhenRestarting() {, +        Request first = mock(Request.class);, +        Request second = mock(Request.class);, +, +        doAnswer(new RemoveRequest(second)).when(first).pause();, +, +        tracker.addRequest(mock(Request.class));, +        tracker.addRequest(first);, +        tracker.addRequest(second);, +, +        tracker.restartRequests();, +    }, +, +    @Test, +, +    private class RemoveRequest implements Answer<Void> {, +, +        private Request toRemove;, +, +        public RemoveRequest(Request toRemove) {, +            this.toRemove = toRemove;, +        }, +, +        @Override, +        public Void answer(InvocationOnMock invocationOnMock) throws Throwable {, +            tracker.removeRequest(toRemove);, +            return null;, +        }, +    }, +++ b/library/src/androidTest/java/com/bumptech/glide/manager/RequestTrackerTest.java, +import static org.mockito.Mockito.doAnswer;, +import org.mockito.invocation.InvocationOnMock;, +import org.mockito.stubbing.Answer;, +    public void testAvoidsConcurrentModificationWhenResuming() {, +        Request first = mock(Request.class);, +        Request second = mock(Request.class);, +, +        doAnswer(new RemoveRequest(second)).when(first).begin();, +, +        tracker.addRequest(mock(Request.class));, +        tracker.addRequest(first);, +        tracker.addRequest(second);, +, +        tracker.resumeRequests();, +    }, +, +    @Test, +    public void testAvoidsConcurrentModificationWhenPausing() {, +        Request first = mock(Request.class);, +        Request second = mock(Request.class);, +, +        when(first.isRunning()).thenReturn(true);, +        doAnswer(new RemoveRequest(second)).when(first).pause();]
[+++ b/integration/okhttp/gradle.properties, +VERSION_MINOR=3]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java, +    @SuppressWarnings("deprecation"), +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java, +    @SuppressWarnings("deprecation"), +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +            //noinspection SuspiciousNameCombination, +    @SuppressWarnings("deprecation"), +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java, +    @SuppressWarnings("deprecation"), +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +            //noinspection SuspiciousNameCombination, +    @SuppressWarnings("deprecation"), +++ b/samples/flickr/src/main/AndroidManifest.xml, +               android:icon="@android:drawable/sym_def_app_icon", +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java, +    @SuppressWarnings("deprecation"), +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +            //noinspection SuspiciousNameCombination, +    @SuppressWarnings("deprecation"), +++ b/samples/flickr/src/main/AndroidManifest.xml, +               android:icon="@android:drawable/sym_def_app_icon", +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java, +    @SuppressWarnings("deprecation"), +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +            //noinspection SuspiciousNameCombination, +    @SuppressWarnings("deprecation"), +++ b/samples/flickr/src/main/AndroidManifest.xml, +               android:icon="@android:drawable/sym_def_app_icon", +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java, +    @SuppressWarnings("deprecation"), +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +            //noinspection SuspiciousNameCombination, +    @SuppressWarnings("deprecation"), +++ b/samples/flickr/src/main/AndroidManifest.xml, +               android:icon="@android:drawable/sym_def_app_icon", +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java, +    @SuppressWarnings("deprecation"), +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +            //noinspection SuspiciousNameCombination, +    @SuppressWarnings("deprecation"), +++ b/samples/flickr/src/main/AndroidManifest.xml, +               android:icon="@android:drawable/sym_def_app_icon", +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java, +    @SuppressWarnings("deprecation"), +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +            //noinspection SuspiciousNameCombination, +    @SuppressWarnings("deprecation"), +++ b/samples/flickr/src/main/AndroidManifest.xml, +               android:icon="@android:drawable/sym_def_app_icon", +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/samples/flickr/src/main/res/layout/flickr_search_activity.xml, +        android:layout_marginEnd="10dp", +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java, +    @SuppressWarnings("deprecation"), +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +            //noinspection SuspiciousNameCombination, +    @SuppressWarnings("deprecation")]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/samples/flickr/res/layout/flickr_photo_grid.xml, +<?xml version="1.0" encoding="utf-8"?>, +<GridView xmlns:android="http://schemas.android.com/apk/res/android", +  android:id="@+id/images", +  android:cacheColorHint="#00000000", +  android:fadingEdge="none", +  android:scrollingCache="false", +  android:numColumns="auto_fit", +  android:horizontalSpacing="10dp", +  android:verticalSpacing="10dp", +  android:gravity="center", +  android:layout_gravity="center", +  android:stretchMode="columnWidth", +  android:layout_width="fill_parent", +  android:layout_height="fill_parent" />, +++ /dev/null, +++ /dev/null, +++ b/samples/flickr/res/layout/flickr_photo_grid.xml, +<?xml version="1.0" encoding="utf-8"?>, +<GridView xmlns:android="http://schemas.android.com/apk/res/android", +  android:id="@+id/images", +  android:cacheColorHint="#00000000", +  android:fadingEdge="none", +  android:scrollingCache="false", +  android:numColumns="auto_fit", +  android:horizontalSpacing="10dp", +  android:verticalSpacing="10dp", +  android:gravity="center", +  android:layout_gravity="center", +  android:stretchMode="columnWidth", +  android:layout_width="fill_parent", +  android:layout_height="fill_parent" />, +++ b/samples/flickr/res/layout/flickr_photo_grid_item.xml, +<?xml version="1.0" encoding="utf-8"?>, +, +<ImageView xmlns:android="http://schemas.android.com/apk/res/android", +    android:scaleType="center", +    android:layout_width="fill_parent", +    android:layout_height="fill_parent"/>, +++ /dev/null, +++ /dev/null, +++ b/samples/flickr/res/layout/flickr_photo_grid.xml, +<?xml version="1.0" encoding="utf-8"?>, +<GridView xmlns:android="http://schemas.android.com/apk/res/android", +  android:id="@+id/images", +  android:cacheColorHint="#00000000", +  android:fadingEdge="none", +  android:scrollingCache="false", +  android:numColumns="auto_fit", +  android:horizontalSpacing="10dp", +  android:verticalSpacing="10dp", +  android:gravity="center", +  android:layout_gravity="center", +  android:stretchMode="columnWidth", +  android:layout_width="fill_parent", +  android:layout_height="fill_parent" />, +++ b/samples/flickr/res/layout/flickr_photo_grid_item.xml, +<?xml version="1.0" encoding="utf-8"?>, +, +<ImageView xmlns:android="http://schemas.android.com/apk/res/android", +    android:scaleType="center", +    android:layout_width="fill_parent", +    android:layout_height="fill_parent"/>, +++ b/samples/flickr/res/layout/flickr_photo_list.xml, +<?xml version="1.0" encoding="utf-8"?>, +, +<ListView xmlns:android="http://schemas.android.com/apk/res/android", +  android:id="@+id/flickr_photo_list", +  android:layout_width="fill_parent", +  android:layout_height="fill_parent", +  android:cacheColorHint="#00000000", +  android:scrollingCache="false">, +</ListView>, +, +++ /dev/null, +++ /dev/null, +++ b/samples/flickr/res/layout/flickr_photo_grid.xml, +<?xml version="1.0" encoding="utf-8"?>, +<GridView xmlns:android="http://schemas.android.com/apk/res/android", +  android:id="@+id/images", +  android:cacheColorHint="#00000000", +  android:fadingEdge="none", +  android:scrollingCache="false", +  android:numColumns="auto_fit", +  android:horizontalSpacing="10dp", +  android:verticalSpacing="10dp", +  android:gravity="center", +  android:layout_gravity="center", +  android:stretchMode="columnWidth", +  android:layout_width="fill_parent", +  android:layout_height="fill_parent" />, +++ b/samples/flickr/res/layout/flickr_photo_grid_item.xml, +<?xml version="1.0" encoding="utf-8"?>, +, +<ImageView xmlns:android="http://schemas.android.com/apk/res/android"]
[+++ b/gradle.properties, +ROBOLECTRIC_VERSION=3.1-SNAPSHOT, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=3.1-SNAPSHOT, +++ b/library/build.gradle, +    jvmArgs '-XX:MaxPermSize=2048m', +++ b/gradle.properties, +ROBOLECTRIC_VERSION=3.1-SNAPSHOT, +++ b/library/build.gradle, +    jvmArgs '-XX:MaxPermSize=2048m', +++ b/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java, +  public static class PreDrawShadowViewTreeObserver {]
[+++ /dev/null, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/LazyHeadersTest.java, +package com.bumptech.glide.load.model;, +, +import static com.google.common.truth.Truth.assertThat;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.when;, +, +import com.google.common.testing.EqualsTester;, +, +import com.bumptech.glide.load.model.LazyHeaders.Builder;, +, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +, +import java.util.Map;, +, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +public class LazyHeadersTest {, +, +    @Test, +    public void testIncludesEagerHeaders() {, +        Map<String, String> headers = new Builder(), +            .addHeader("key", "value"), +            .build(), +            .getHeaders();, +        assertThat(headers).containsEntry("key", "value");, +        assertThat(headers).hasSize(1);, +    }, +, +    @Test, +    public void testIncludesLazyHeaders() {, +        LazyHeaderFactory factory = mock(LazyHeaderFactory.class);, +        when(factory.buildHeader()).thenReturn("value");, +        Map<String, String> headers = new Builder(), +            .addHeader("key", factory), +            .build(), +            .getHeaders();, +, +        assertThat(headers).hasSize(1);, +        assertThat(headers).containsEntry("key", "value");, +    }, +, +    @Test, +    public void testMultipleEagerValuesAreSeparatedByCommas() {, +        Map<String, String> headers = new Builder(), +            .addHeader("key", "first"), +            .addHeader("key", "second"), +            .build(), +            .getHeaders();, +, +        assertThat(headers).hasSize(1);, +        assertThat(headers).containsEntry("key", "first,second");, +    }, +, +    @Test, +    public void testMultipleLazyValuesAreSeparatedByCommas() {, +        LazyHeaderFactory first = mock(LazyHeaderFactory.class);, +        when(first.buildHeader()).thenReturn("first");, +        LazyHeaderFactory second = mock(LazyHeaderFactory.class);, +        when(second.buildHeader()).thenReturn("second");, +, +        Map<String, String> headers = new Builder(), +            .addHeader("key", first), +            .addHeader("key", second), +            .build(), +            .getHeaders();, +        assertThat(headers).hasSize(1);, +        assertThat(headers).containsEntry("key", "first,second");, +    }, +, +    @Test, +    public void testMixedEagerAndLazyValuesAreIncluded() {, +        LazyHeaderFactory factory = mock(LazyHeaderFactory.class);, +        when(factory.buildHeader()).thenReturn("first");, +        Map<String, String> headers = new Builder(), +            .addHeader("key", factory), +            .addHeader("key", "second"), +            .build(), +            .getHeaders();, +, +        assertThat(headers).hasSize(1);, +        assertThat(headers).containsEntry("key", "first,second");, +, +        headers = new Builder(), +            .addHeader("key", "second"), +            .addHeader("key", factory), +            .build(), +            .getHeaders();, +, +        assertThat(headers).hasSize(1);, +        assertThat(headers).containsEntry("key", "second,first");, +    }, +, +    @Test, +    public void testCanAddMultipleKeys() {]
[+++ b/.gitmodules, +[submodule "library/test/src/test/resources/exif-orientation-examples"], +	path = library/test/src/test/resources/exif-orientation-examples, +++ b/.gitmodules, +[submodule "library/test/src/test/resources/exif-orientation-examples"], +	path = library/test/src/test/resources/exif-orientation-examples, +++ b/build.gradle, +++ b/.gitmodules, +[submodule "library/test/src/test/resources/exif-orientation-examples"], +	path = library/test/src/test/resources/exif-orientation-examples, +++ b/build.gradle, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]test[/\\]src[/\\]test[/\\].*" checks="Javadoc.*"/>, +++ b/.gitmodules, +[submodule "library/test/src/test/resources/exif-orientation-examples"], +	path = library/test/src/test/resources/exif-orientation-examples, +++ b/build.gradle, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]test[/\\]src[/\\]test[/\\].*" checks="Javadoc.*"/>, +++ b/library/build.gradle, +tasks.withType(JavaCompile) {, +    options.fork = true, +}, +, +check.dependsOn(':library:test:check'), +++ b/.gitmodules, +[submodule "library/test/src/test/resources/exif-orientation-examples"], +	path = library/test/src/test/resources/exif-orientation-examples, +++ b/build.gradle, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]test[/\\]src[/\\]test[/\\].*" checks="Javadoc.*"/>, +++ b/library/build.gradle, +tasks.withType(JavaCompile) {, +    options.fork = true, +}, +, +check.dependsOn(':library:test:check'), +++ /dev/null, +++ b/.gitmodules, +[submodule "library/test/src/test/resources/exif-orientation-examples"], +	path = library/test/src/test/resources/exif-orientation-examples, +++ b/build.gradle, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]test[/\\]src[/\\]test[/\\].*" checks="Javadoc.*"/>, +++ b/library/build.gradle, +tasks.withType(JavaCompile) {, +    options.fork = true, +}, +, +check.dependsOn(':library:test:check'), +++ /dev/null, +++ /dev/null, +++ b/.gitmodules, +[submodule "library/test/src/test/resources/exif-orientation-examples"], +	path = library/test/src/test/resources/exif-orientation-examples, +++ b/build.gradle, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]test[/\\]src[/\\]test[/\\].*" checks="Javadoc.*"/>, +++ b/library/build.gradle, +tasks.withType(JavaCompile) {, +    options.fork = true, +}, +, +check.dependsOn(':library:test:check'), +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitmodules, +[submodule "library/test/src/test/resources/exif-orientation-examples"], +	path = library/test/src/test/resources/exif-orientation-examples, +++ b/build.gradle, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]test[/\\]src[/\\]test[/\\].*" checks="Javadoc.*"/>, +++ b/library/build.gradle, +tasks.withType(JavaCompile) {, +    options.fork = true, +}, +, +check.dependsOn(':library:test:check'), +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/.gitmodules, +[submodule "library/test/src/test/resources/exif-orientation-examples"], +	path = library/test/src/test/resources/exif-orientation-examples, +++ b/build.gradle, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]test[/\\]src[/\\]test[/\\].*" checks="Javadoc.*"/>, +++ b/library/build.gradle, +tasks.withType(JavaCompile) {, +    options.fork = true, +}, +, +check.dependsOn(':library:test:check'), +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null]
[+++ b/library/robolectric/src/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.data.bytes.BytesResource;, +import com.bumptech.glide.load.data.transcode.ResourceTranscoder;, +import com.bumptech.glide.load.model.GenericLoaderFactory;, +import com.bumptech.glide.load.model.GlideUrl;, +import com.bumptech.glide.load.model.ModelLoader;, +import com.bumptech.glide.load.model.ModelLoaderFactory;, +import com.bumptech.glide.load.model.stream.StreamModelLoader;, +import com.bumptech.glide.load.resource.ResourceFetcher;, +import static org.mockito.Matchers.anyObject;, +        Glide.with(getContext()).loadFromImage(url).into(target);, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).setRequest((Request) notNull());, +, +    public void testAsBitmapOption() {, +        Uri uri = Uri.parse("content://something/else");, +        mockUri(uri);, +, +        Glide.with(getContext()).load(uri).asBitmap().into(target);, +, +        verify(target).onResourceReady(any(Bitmap.class));, +    }, +, +    @Test, +    public void testTranscodeOption() {, +        Uri uri = Uri.parse("content://something/else");, +        mockUri(uri);, +        final byte[] bytes = new byte[0];, +, +        Glide.with(getContext()).load(uri).transcode(byte[].class, new ResourceTranscoder<Bitmap, byte[]>() {, +            @Override, +            public Resource<byte[]> transcode(Resource<Bitmap> toTranscode) {, +                return new BytesResource(bytes);, +            }, +, +            @Override, +            public String getId() {, +                return "bytes";, +            }, +        }).into(target);, +, +        verify(target).onResourceReady(eq(bytes));, +    }, +, +    @Test, +    public void testToBytesOption() {, +        Uri uri = Uri.parse("content://something/else");, +        mockUri(uri);, +, +        Glide.with(getContext()).load(uri).toBytes().into(target);, +, +        verify(target).onResourceReady(any(byte[].class));, +    }, +, +    @Test, +        verify(target).onResourceReady(anyObject());, +++ b/library/robolectric/src/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.data.bytes.BytesResource;, +import com.bumptech.glide.load.data.transcode.ResourceTranscoder;, +import com.bumptech.glide.load.model.GenericLoaderFactory;, +import com.bumptech.glide.load.model.GlideUrl;, +import com.bumptech.glide.load.model.ModelLoader;, +import com.bumptech.glide.load.model.ModelLoaderFactory;, +import com.bumptech.glide.load.model.stream.StreamModelLoader;, +import com.bumptech.glide.load.resource.ResourceFetcher;, +import static org.mockito.Matchers.anyObject;, +        Glide.with(getContext()).loadFromImage(url).into(target);, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).setRequest((Request) notNull());, +, +    public void testAsBitmapOption() {, +        Uri uri = Uri.parse("content://something/else");, +        mockUri(uri);, +, +        Glide.with(getContext()).load(uri).asBitmap().into(target);, +, +        verify(target).onResourceReady(any(Bitmap.class));, +    }, +, +    @Test, +    public void testTranscodeOption() {, +        Uri uri = Uri.parse("content://something/else");, +        mockUri(uri);, +        final byte[] bytes = new byte[0];, +, +        Glide.with(getContext()).load(uri).transcode(byte[].class, new ResourceTranscoder<Bitmap, byte[]>() {, +            @Override, +            public Resource<byte[]> transcode(Resource<Bitmap> toTranscode) {, +                return new BytesResource(bytes);, +            }, +, +            @Override, +            public String getId() {, +                return "bytes";, +            }, +        }).into(target);, +, +        verify(target).onResourceReady(eq(bytes));, +    }, +]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +import com.bumptech.glide.load.DataSource;, +        this.sourceKey = sourceId;, +    cb.onDataFetcherReady(sourceKey, data, fetcher, DataSource.DATA_DISK_CACHE);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +import com.bumptech.glide.load.DataSource;, +        this.sourceKey = sourceId;, +    cb.onDataFetcherReady(sourceKey, data, fetcher, DataSource.DATA_DISK_CACHE);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java, +  public Key getSourceKey() {, +    return sourceKey;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +import com.bumptech.glide.load.DataSource;, +        this.sourceKey = sourceId;, +    cb.onDataFetcherReady(sourceKey, data, fetcher, DataSource.DATA_DISK_CACHE);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java, +  public Key getSourceKey() {, +    return sourceKey;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java, +import com.bumptech.glide.load.DataSource;, +    void onDataFetcherReady(Key sourceKey, Object data, DataFetcher fetcher, DataSource dataSource);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +import com.bumptech.glide.load.DataSource;, +        this.sourceKey = sourceId;, +    cb.onDataFetcherReady(sourceKey, data, fetcher, DataSource.DATA_DISK_CACHE);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java, +  public Key getSourceKey() {, +    return sourceKey;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java, +import com.bumptech.glide.load.DataSource;, +    void onDataFetcherReady(Key sourceKey, Object data, DataFetcher fetcher, DataSource dataSource);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private Key currentSourceKey;, +  private DataSource currentDataSource;, +  private long startFetchTime;, +  public synchronized void onDataFetcherReady(Key sourceKey, Object data, DataFetcher fetcher,, +      DataSource dataSource) {, +    this.currentSourceKey = sourceKey;, +    this.currentDataSource = dataSource;, +      logWithTimeAndKey("Retrieved data", startFetchTime,, +          "data: " + currentData, +          + ", cache key: " + currentSourceKey, +          + ", fetcher: " + currentFetcher);, +    Resource<R> resource = decodeFromData(currentFetcher, currentData, currentDataSource);, +  private <Data> Resource<R> decodeFromData(DataFetcher<?> fetcher, Data data,, +      DataSource dataSource) {, +  private void logWithTimeAndKey(String message, long startTime) {, +    logWithTimeAndKey(message, startTime, null /*extraArgs*/);, +  private void logWithTimeAndKey(String message, long startTime, String extraArgs) {, +    Logs.log(Log.VERBOSE, message + " in " + LogTime.getElapsedMillis(startTime), +        + ", load key: " + loadKey, +        + (extraArgs != null ? ", " + extraArgs : ""), +        + ", thread: " + Thread.currentThread().getName());, +      boolean isFromAlternateCacheKey = !requestContext.isSourceKey(currentSourceKey);, +          key = new DataCacheKey(currentSourceKey, requestContext.getSignature());, +          key = new ResourceCacheKey(currentSourceKey, requestContext.getSignature(), width, height,, +          logWithTimeAndKey("Encoded resource to cache", startEncodeTime,, +              "cache key: " + key, +              + ", encode strategy: " + encodeStrategy);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +import com.bumptech.glide.load.DataSource;, +        this.sourceKey = sourceId;, +    cb.onDataFetcherReady(sourceKey, data, fetcher, DataSource.DATA_DISK_CACHE);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java, +  public Key getSourceKey() {, +    return sourceKey;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java, +import com.bumptech.glide.load.DataSource;, +    void onDataFetcherReady(Key sourceKey, Object data, DataFetcher fetcher, DataSource dataSource);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private Key currentSourceKey;, +  private DataSource currentDataSource;, +  private long startFetchTime;, +  public synchronized void onDataFetcherReady(Key sourceKey, Object data, DataFetcher fetcher,, +      DataSource dataSource) {, +    this.currentSourceKey = sourceKey;, +    this.currentDataSource = dataSource;, +      logWithTimeAndKey("Retrieved data", startFetchTime,, +          "data: " + currentData, +          + ", cache key: " + currentSourceKey, +          + ", fetcher: " + currentFetcher);, +    Resource<R> resource = decodeFromData(currentFetcher, currentData, currentDataSource);, +  private <Data> Resource<R> decodeFromData(DataFetcher<?> fetcher, Data data,, +      DataSource dataSource) {, +  private void logWithTimeAndKey(String message, long startTime) {, +    logWithTimeAndKey(message, startTime, null /*extraArgs*/);, +  private void logWithTimeAndKey(String message, long startTime, String extraArgs) {, +    Logs.log(Log.VERBOSE, message + " in " + LogTime.getElapsedMillis(startTime), +        + ", load key: " + loadKey, +        + (extraArgs != null ? ", " + extraArgs : ""), +        + ", thread: " + Thread.currentThread().getName());, +      boolean isFromAlternateCacheKey = !requestContext.isSourceKey(currentSourceKey);]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +        // Use the previous request rather than the new one to allow for optimizations like skipping, +        // setting placeholders, tracking and untracking Targets, and obtaining View dimensions that, +        // are done in the individual Request., +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +        // Use the previous request rather than the new one to allow for optimizations like skipping, +        // setting placeholders, tracking and untracking Targets, and obtaining View dimensions that, +        // are done in the individual Request., +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +          && priority == that.priority, +          // We do not want to require that RequestListeners implement equals/hashcode, so we don't, +          // compare them using equals(). We can however, at least assert that the request listener, +          // is either present or not present in both requests., +          && requestListener != null ? that.requestListener != null : that.requestListener == null;]
[+++ b/.gitignore, +**/jacoco.exec, +++ b/.gitignore, +**/jacoco.exec, +++ b/.travis.yml, +  - build-tools-26.0.2, +++ b/.gitignore, +**/jacoco.exec, +++ b/.travis.yml, +  - build-tools-26.0.2, +++ b/annotation/compiler/test/build.gradle, +    testImplementation project(':glide'), +    testImplementation project(':annotation:compiler'), +    testImplementation 'com.squareup:javapoet:1.9.0', +    testImplementation 'com.google.auto.service:auto-service:1.0-rc3', +    testImplementation 'com.google.code.findbugs:jsr305:3.0.1', +    testImplementation 'com.google.testing.compile:compile-testing:0.10', +    testImplementation 'com.google.android:android:4.1.1.4', +    testImplementation 'com.google.android:support-v4:r6', +    testImplementation "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}", +++ b/.gitignore, +**/jacoco.exec, +++ b/.travis.yml, +  - build-tools-26.0.2, +++ b/annotation/compiler/test/build.gradle, +    testImplementation project(':glide'), +    testImplementation project(':annotation:compiler'), +    testImplementation 'com.squareup:javapoet:1.9.0', +    testImplementation 'com.google.auto.service:auto-service:1.0-rc3', +    testImplementation 'com.google.code.findbugs:jsr305:3.0.1', +    testImplementation 'com.google.testing.compile:compile-testing:0.10', +    testImplementation 'com.google.android:android:4.1.1.4', +    testImplementation 'com.google.android:support-v4:r6', +    testImplementation "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}", +++ b/build.gradle, +        google(), +++ b/.gitignore, +**/jacoco.exec, +++ b/.travis.yml, +  - build-tools-26.0.2, +++ b/annotation/compiler/test/build.gradle, +    testImplementation project(':glide'), +    testImplementation project(':annotation:compiler'), +    testImplementation 'com.squareup:javapoet:1.9.0', +    testImplementation 'com.google.auto.service:auto-service:1.0-rc3', +    testImplementation 'com.google.code.findbugs:jsr305:3.0.1', +    testImplementation 'com.google.testing.compile:compile-testing:0.10', +    testImplementation 'com.google.android:android:4.1.1.4', +    testImplementation 'com.google.android:support-v4:r6', +    testImplementation "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}", +++ b/build.gradle, +        google(), +++ b/glide/build.gradle, +    getAndroidLibraryVariantsForJar(variantName).collect {, +        it.getJavaCompiler().source.findAll {, +            return !it.getName().equals("R.java") && !it.getName().equals("BuildConfig.java"), +        }, +    } + getInternalJavaProjectsForJar().collect { it.sourceSets.main.allJava }, +    from files(getInternalJavaProjectsForJar().collect { it.sourceSets.main.output }), +    exclude "**/R\$*.class", +        releaseJavadoc.dependsOn(project.tasks.compileReleaseSources), +        jar.dependsOn(project.tasks.compileReleaseSources), +++ b/.gitignore, +**/jacoco.exec, +++ b/.travis.yml, +  - build-tools-26.0.2, +++ b/annotation/compiler/test/build.gradle, +    testImplementation project(':glide'), +    testImplementation project(':annotation:compiler'), +    testImplementation 'com.squareup:javapoet:1.9.0', +    testImplementation 'com.google.auto.service:auto-service:1.0-rc3', +    testImplementation 'com.google.code.findbugs:jsr305:3.0.1', +    testImplementation 'com.google.testing.compile:compile-testing:0.10', +    testImplementation 'com.google.android:android:4.1.1.4', +    testImplementation 'com.google.android:support-v4:r6', +    testImplementation "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}", +++ b/build.gradle, +        google(), +++ b/glide/build.gradle, +    getAndroidLibraryVariantsForJar(variantName).collect {, +        it.getJavaCompiler().source.findAll {, +            return !it.getName().equals("R.java") && !it.getName().equals("BuildConfig.java"), +        }, +    } + getInternalJavaProjectsForJar().collect { it.sourceSets.main.allJava }, +    from files(getInternalJavaProjectsForJar().collect { it.sourceSets.main.output }), +    exclude "**/R\$*.class", +        releaseJavadoc.dependsOn(project.tasks.compileReleaseSources), +        jar.dependsOn(project.tasks.compileReleaseSources), +++ b/gradle.properties, +ANDROID_SUPPORT_VERSION=27.0.1, +ANDROID_GRADLE_VERSION=3.0.0, +BUILD_TOOLS_VERSION=26.0.2, +++ b/.gitignore, +**/jacoco.exec, +++ b/.travis.yml, +  - build-tools-26.0.2, +++ b/annotation/compiler/test/build.gradle, +    testImplementation project(':glide'), +    testImplementation project(':annotation:compiler'), +    testImplementation 'com.squareup:javapoet:1.9.0']
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +      throw new IllegalArgumentException(, +          "RequestOptionsExtensions must be public, including: " + getName(typeElement));, +  private static String getQualifiedMethodName(ExecutableElement executableElement) {, +    return getEnclosingClassName(executableElement) + "#" + getName(executableElement);, +  }, +, +  private static String getEnclosingClassName(Element element) {, +    return element.getEnclosingElement().toString();, +  }, +, +  private static String getName(Element element) {, +    return element.toString();, +  }, +, +      throw new IllegalArgumentException(, +          "RequestOptionsExtensions must be public, with private constructors and only static", +              + " methods. Found a non-private constructor in: " + getEnclosingClassName(element));, +      throw new IllegalArgumentException(, +          "RequestOptionsExtensions must be public, with private constructors and only static", +              + " methods. Found parameters in the constructor of: ", +              + getEnclosingClassName(element));, +          + " object, but " + getQualifiedMethodName(executableElement) + " returns " + returnType, +          + ". If you're using old style @GlideOption methods, your method may have a void return", +          + " type, but doing so is deprecated and support will be removed in a future version");, +          + "RequestOptions object as their first parameter, but ", +          + getQualifiedMethodName(executableElement) + " has none");, +          + " RequestOptions object as their first parameter, but the first parameter in ", +          + getQualifiedMethodName(executableElement) + " is " + expected);, +          + getQualifiedMethodName(element));, +          + getQualifiedMethodName(element));, +          + expectedClassName + "> object, but " + getQualifiedMethodName(executableElement), +          + " returns: " + returnType + ". If you're using old style @GlideType methods, your", +          + " method may have a void return type, but doing so is deprecated and support will be", +          + " removed in a future version");, +          + getQualifiedMethodName(executableElement));, +          + " RequestBuilder object as their first and only parameter, but given: " + argumentType, +          + " for: " + getQualifiedMethodName(executableElement));, +          getQualifiedMethodName(executableElement), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +      throw new IllegalArgumentException(, +          "RequestOptionsExtensions must be public, including: " + getName(typeElement));, +  private static String getQualifiedMethodName(ExecutableElement executableElement) {, +    return getEnclosingClassName(executableElement) + "#" + getName(executableElement);, +  }, +, +  private static String getEnclosingClassName(Element element) {, +    return element.getEnclosingElement().toString();, +  }, +, +  private static String getName(Element element) {, +    return element.toString();, +  }, +, +      throw new IllegalArgumentException(, +          "RequestOptionsExtensions must be public, with private constructors and only static", +              + " methods. Found a non-private constructor in: " + getEnclosingClassName(element));, +      throw new IllegalArgumentException(, +          "RequestOptionsExtensions must be public, with private constructors and only static", +              + " methods. Found parameters in the constructor of: ", +              + getEnclosingClassName(element));, +          + " object, but " + getQualifiedMethodName(executableElement) + " returns " + returnType, +          + ". If you're using old style @GlideOption methods, your method may have a void return", +          + " type, but doing so is deprecated and support will be removed in a future version");, +          + "RequestOptions object as their first parameter, but ", +          + getQualifiedMethodName(executableElement) + " has none");, +          + " RequestOptions object as their first parameter, but the first parameter in ", +          + getQualifiedMethodName(executableElement) + " is " + expected);, +          + getQualifiedMethodName(element));, +          + getQualifiedMethodName(element));, +          + expectedClassName + "> object, but " + getQualifiedMethodName(executableElement), +          + " returns: " + returnType + ". If you're using old style @GlideType methods, your", +          + " method may have a void return type, but doing so is deprecated and support will be", +          + " removed in a future version");, +          + getQualifiedMethodName(executableElement));, +          + " RequestBuilder object as their first and only parameter, but given: " + argumentType, +          + " for: " + getQualifiedMethodName(executableElement));, +          getQualifiedMethodName(executableElement), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideExtensionTest.java, +import static org.junit.Assert.fail;, +import com.google.common.truth.Truth;, +    try {, +      fail("Failed to throw expected exception");, +    } catch (RuntimeException e) {, +      Throwable cause = e.getCause();, +      Truth.assertThat(cause.getMessage()).contains("non-private constructor");, +      Truth.assertThat(cause.getMessage()).contains("PublicConstructor");, +, +    }, +  public void compilation_withPackagePrivateExtension_fails() {, +    try {, +                  "PackagePrivateExtension",, +                  "class PackagePrivateExtension {",, +                  "  private PackagePrivateExtension() {}",, +      fail("Failed to throw expected exception");, +    } catch (RuntimeException e) {, +      Throwable cause = e.getCause();, +      Truth.assertThat(cause.getMessage()).contains("must be public");, +      Truth.assertThat(cause.getMessage()).contains("PackagePrivateExtension");, +    }]
[+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java, +      // openInputStream can throw NPEs., +    } catch (IOException | NullPointerException e) {, +      try {, +        // openInputStream can throw NPEs., +      } catch (NullPointerException e) {, +        throw new FileNotFoundException("NPE opening uri: " + thumbnailUri);, +      }]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineJobTest.java, +        EngineJob job = harness.getJob();, +        job.cancel();, +        verify(harness.listener).onEngineJobCancelled(eq(job), eq(harness.key));, +        verify(harness.listener, never()).onEngineJobCancelled(eq(job), eq(harness.key));, +        verify(harness.listener, times(1)).onEngineJobCancelled(eq(job), eq(harness.key));, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineJobTest.java, +        EngineJob job = harness.getJob();, +        job.cancel();, +        verify(harness.listener).onEngineJobCancelled(eq(job), eq(harness.key));, +        verify(harness.listener, never()).onEngineJobCancelled(eq(job), eq(harness.key));, +        verify(harness.listener, times(1)).onEngineJobCancelled(eq(job), eq(harness.key));, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +        harness.engine.onEngineJobCancelled(harness.job, harness.cacheKey);, +        harness.engine.onEngineJobCancelled(harness.job, harness.cacheKey);, +    public void testRunnerIsNotRemovedFromRunnersIfOldJobIsCancelled() {, +        harness.doLoad();, +, +        harness.engine.onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);, +, +        assertEquals(harness.runner, harness.runners.get(harness.cacheKey));, +    }, +, +    @Test, +    public void testRunnerIsNotCancelledIfOldJobIsCancelled() {, +        harness.doLoad();, +, +        harness.engine.onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);, +, +        verify(harness.runner, never()).cancel();, +    }, +, +    @Test, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineJobTest.java, +        EngineJob job = harness.getJob();, +        job.cancel();, +        verify(harness.listener).onEngineJobCancelled(eq(job), eq(harness.key));, +        verify(harness.listener, never()).onEngineJobCancelled(eq(job), eq(harness.key));, +        verify(harness.listener, times(1)).onEngineJobCancelled(eq(job), eq(harness.key));, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +        harness.engine.onEngineJobCancelled(harness.job, harness.cacheKey);, +        harness.engine.onEngineJobCancelled(harness.job, harness.cacheKey);, +    public void testRunnerIsNotRemovedFromRunnersIfOldJobIsCancelled() {, +        harness.doLoad();, +, +        harness.engine.onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);, +, +        assertEquals(harness.runner, harness.runners.get(harness.cacheKey));, +    }, +, +    @Test, +    public void testRunnerIsNotCancelledIfOldJobIsCancelled() {, +        harness.doLoad();, +, +        harness.engine.onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);, +, +        verify(harness.runner, never()).cancel();, +    }, +, +    @Test, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +    public void onEngineJobCancelled(EngineJob engineJob, Key key) {, +        ResourceRunner runner = runners.get(key);, +        if (runner.getJob() == engineJob) {, +            runners.remove(key);, +    }, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineJobTest.java, +        EngineJob job = harness.getJob();, +        job.cancel();, +        verify(harness.listener).onEngineJobCancelled(eq(job), eq(harness.key));, +        verify(harness.listener, never()).onEngineJobCancelled(eq(job), eq(harness.key));, +        verify(harness.listener, times(1)).onEngineJobCancelled(eq(job), eq(harness.key));, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +        harness.engine.onEngineJobCancelled(harness.job, harness.cacheKey);, +        harness.engine.onEngineJobCancelled(harness.job, harness.cacheKey);, +    public void testRunnerIsNotRemovedFromRunnersIfOldJobIsCancelled() {, +        harness.doLoad();, +, +        harness.engine.onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);, +, +        assertEquals(harness.runner, harness.runners.get(harness.cacheKey));, +    }, +, +    @Test, +    public void testRunnerIsNotCancelledIfOldJobIsCancelled() {, +        harness.doLoad();, +, +        harness.engine.onEngineJobCancelled(mock(EngineJob.class), harness.cacheKey);, +, +        verify(harness.runner, never()).cancel();, +    }, +, +    @Test, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +    public void onEngineJobCancelled(EngineJob engineJob, Key key) {, +        ResourceRunner runner = runners.get(key);, +        if (runner.getJob() == engineJob) {, +            runners.remove(key);, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import com.squareup.okhttp.ResponseBody;, +  private ResponseBody responseBody;, +        if (response.isSuccessful()) {, +          responseBody = response.body();, +          stream = responseBody.byteStream();, +        } else if (Logs.isEnabled(Log.DEBUG)) {, +          Logs.log(Log.DEBUG, "OkHttp got error response: " + response.code() + ", ", +              + response.message());, +        }, +      if (stream != null) {, +      }, +    if (responseBody != null) {, +      try {, +        responseBody.close();, +      } catch (IOException e) {, +        // Ignored., +      }, +    }]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DownsampleVideoTest.java, +package com.bumptech.glide;, +, +import static com.bumptech.glide.test.BitmapSubject.assertThat;, +import static org.junit.Assume.assumeTrue;, +, +import android.content.Context;, +import android.graphics.Bitmap;, +import android.os.Build;, +import android.support.test.InstrumentationRegistry;, +import android.support.test.runner.AndroidJUnit4;, +import com.bumptech.glide.load.resource.bitmap.DownsampleStrategy;, +import com.bumptech.glide.request.target.Target;, +import com.bumptech.glide.test.ConcurrencyHelper;, +import com.bumptech.glide.test.GlideApp;, +import com.bumptech.glide.test.ResourceIds;, +import com.bumptech.glide.test.TearDownGlide;, +import org.junit.Before;, +import org.junit.Rule;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +, +@RunWith(AndroidJUnit4.class), +public class DownsampleVideoTest {, +  // The dimensions of the test video., +  private static final int WIDTH = 1080;, +  private static final int HEIGHT = 1920;, +, +  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();, +  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();, +  private final Context context = InstrumentationRegistry.getTargetContext();, +, +  @Before, +  public void setUp() {, +    assumeTrue(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O_MR1);, +  }, +, +  @Test, +  public void loadVideo_downsampleStrategyNone_returnsOriginalVideoDimensions() {, +    Bitmap bitmap =, +        concurrency.get(, +            GlideApp.with(context), +                .asBitmap(), +                .load(ResourceIds.raw.video), +                .downsample(DownsampleStrategy.NONE), +                .submit(10, 10));, +, +    assertThat(bitmap).hasDimensions(WIDTH, HEIGHT);, +  }, +, +  @Test, +  public void loadVideo_downsampleStrategyNone_doesNotUpscale() {, +    Bitmap bitmap =, +        concurrency.get(, +            GlideApp.with(context), +                .asBitmap(), +                .load(ResourceIds.raw.video), +                .downsample(DownsampleStrategy.NONE), +                .submit(WIDTH * 2, HEIGHT * 2));, +, +    assertThat(bitmap).hasDimensions(WIDTH, HEIGHT);, +  }, +, +  @Test, +  public void loadVideo_downsampleDefault_downsamplesVideo() {, +     Bitmap bitmap =, +        concurrency.get(, +            GlideApp.with(context), +                .asBitmap(), +                .load(ResourceIds.raw.video), +                .submit(10, 10));, +, +    assertThat(bitmap).hasDimensions(10, 18);, +  }, +, +  @Test, +  public void loadVideo_downsampleAtMost_downsamplesToSmallerSize() {, +    Bitmap bitmap =, +        concurrency.get(, +            GlideApp.with(context), +                .asBitmap(), +                .downsample(DownsampleStrategy.AT_MOST), +                .load(ResourceIds.raw.video), +                .submit(540, 959));, +    assertThat(bitmap).hasDimensions(270, 480);, +  }, +, +  @Test, +  public void loadVideo_downsampleAtMost_doesNotUpscale() {, +    Bitmap bitmap =, +        concurrency.get(, +            GlideApp.with(context), +                .asBitmap(), +                .downsample(DownsampleStrategy.AT_MOST), +                .load(ResourceIds.raw.video), +                .submit(WIDTH * 2, HEIGHT * 2));, +    assertThat(bitmap).hasDimensions(WIDTH, HEIGHT);, +  }, +, +  @Test]
[+++ b/Makefile, +, +glide-minus-volley:, +	cd library && ant clean && ant glide-minus-volley, +, +++ b/Makefile, +, +glide-minus-volley:, +	cd library && ant clean && ant glide-minus-volley, +, +++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" />, +++ b/Makefile, +, +glide-minus-volley:, +	cd library && ant clean && ant glide-minus-volley, +, +++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" />, +++ b/library/custom_rules.xml, +    <target name="glide-minus-volley" depends="-compile">, +        <jar destfile="bin/glide-minus-volley-${mymanifest.manifest.android:versionName}.jar", +            basedir="bin/classes", +            excludes="com/bumptech/glide/volley/">, +            <zipgroupfileset dir="libs" includes="disklrucache*.jar" />, +        </jar>, +    </target>, +++ b/Makefile, +, +glide-minus-volley:, +	cd library && ant clean && ant glide-minus-volley, +, +++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" />, +++ b/library/custom_rules.xml, +    <target name="glide-minus-volley" depends="-compile">, +        <jar destfile="bin/glide-minus-volley-${mymanifest.manifest.android:versionName}.jar", +            basedir="bin/classes", +            excludes="com/bumptech/glide/volley/">, +            <zipgroupfileset dir="libs" includes="disklrucache*.jar" />, +        </jar>, +    </target>, +++ b/library/src/com/bumptech/glide/Glide.java, +import android.util.Log;, +import android.view.ViewGroup;, +import com.bumptech.glide.loader.model.FileLoader;, +import com.bumptech.glide.loader.model.GenericLoaderFactory;, +import com.bumptech.glide.loader.model.ModelLoader;, +import com.bumptech.glide.loader.model.ModelLoaderFactory;, +import com.bumptech.glide.loader.model.ResourceLoader;, +import com.bumptech.glide.loader.model.StringLoader;, +import com.bumptech.glide.loader.model.UriLoader;, +import com.bumptech.glide.loader.stream.StreamLoader;, +import com.bumptech.glide.loader.transformation.CenterCrop;, +import com.bumptech.glide.loader.transformation.FitCenter;, +import com.bumptech.glide.loader.transformation.MultiTransformationLoader;, +import com.bumptech.glide.loader.transformation.None;, +import com.bumptech.glide.loader.transformation.TransformationLoader;, +import com.bumptech.glide.presenter.target.Target;, +, +import java.util.Map;, +import java.util.WeakHashMap;, + * A singleton to present a simple static interface for Glide {@link Glide.Request} and to create and manage an, +    private static final String TAG = "Glide";, +    private static final Glide GLIDE = new Glide();, +    private final Map<Target, Metadata> metadataTracker = new WeakHashMap<Target, Metadata>();, +, +         *     public void onException(Exception e, T model, Target target) {, +    public static Glide get() {, +    protected Glide() {, +        loaderFactory.register(File.class, new FileLoader.Factory());, +        loaderFactory.register(Integer.class, new ResourceLoader.Factory());, +        loaderFactory.register(String.class, new StringLoader.Factory());, +        loaderFactory.register(Uri.class, new UriLoader.Factory());, +        try {, +            Class.forName("com.bumptech.glide.volley.VolleyUrlLoader$Factory");, +            loaderFactory.register(URL.class, new VolleyUrlLoader.Factory());, +        } catch (ClassNotFoundException e) {, +            if (Log.isLoggable(TAG, Log.DEBUG)) {, +                Log.d(TAG, "Volley not found, missing url loader");, +            }, +            loaderFactory.register(URL.class, new ModelLoaderFactory<URL>() {, +                ModelLoader<URL> errorUrlLoader = new ModelLoader<URL>() {, +                    @Override, +                    public StreamLoader getStreamLoader(URL model, int width, int height) {, +                        throw new IllegalArgumentException("No ModelLoaderFactory for urls registered with Glide");, +                    @Override, +                    public String getId(URL model) {, +                        throw new IllegalArgumentException("No ModelLoaderFactory for urls registered with Glide");, +                    }, +                };, +, +                @Override, +                public ModelLoader<URL> build(Context context, GenericLoaderFactory factories) {, +                    return errorUrlLoader;, +                @Override @SuppressWarnings("unchecked"), +                public Class<? extends ModelLoader<URL>> loaderClass() {, +                    return (Class<ModelLoader<URL>>) errorUrlLoader.getClass();, +                @Override, +                public void teardown() {]
[+++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        verify(target).onResourceReady(any(Resource.class), any(GlideAnimation.class));, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        verify(target).onResourceReady(any(Resource.class), any(GlideAnimation.class));, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +import org.mockito.invocation.InvocationOnMock;, +import org.mockito.stubbing.Answer;, +import static org.mockito.Mockito.doAnswer;, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(null));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(null));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(other));, +, +    @Test, +    public void testHandlesNonEngineResourcesFromCacheIfPresent() {, +        final Object expected = new Object();, +        Resource fromCache = mock(Resource.class);, +        when(fromCache.get()).thenReturn(expected);, +        when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(fromCache);, +, +        doAnswer(new Answer() {, +            @Override, +            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {, +                Resource resource = (Resource) invocationOnMock.getArguments()[0];, +                assertEquals(expected, resource.get());, +                return null;, +            }, +        }).when(harness.cb).onResourceReady(any(Resource.class));, +, +        harness.doLoad();, +, +        verify(harness.cb).onResourceReady(any(Resource.class));, +    }, +, +        WeakReference<EngineResource<?>> resourceRef = harness.activeResources.get(harness.cacheKey);, +        final Object expected = new Object();, +        when(harness.resource.isCacheable()).thenReturn(true);, +        when(harness.resource.get()).thenReturn(expected);, +        doAnswer(new Answer() {, +            @Override, +            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {, +                Resource<?> resource = (Resource<?>) invocationOnMock.getArguments()[1];, +                assertEquals(expected, resource.get());, +                return null;, +            }, +        }).when(harness.cache).put(eq(harness.cacheKey), any(Resource.class));, +, +, +        verify(harness.cache).put(eq(harness.cacheKey), any(Resource.class));, +        harness.resource.setCacheable(false);, +        harness.resource.setCacheable(true);, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));, +        Map<Key, WeakReference<EngineResource<?>>> activeResources =, +                new HashMap<Key, WeakReference<EngineResource<?>>>();, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        verify(target).onResourceReady(any(Resource.class), any(GlideAnimation.class));, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +import org.mockito.invocation.InvocationOnMock;, +import org.mockito.stubbing.Answer;, +import static org.mockito.Mockito.doAnswer;, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(null));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(null));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(harness.resource));, +        harness.activeResources.put(harness.cacheKey, new WeakReference<EngineResource<?>>(other));, +, +    @Test, +    public void testHandlesNonEngineResourcesFromCacheIfPresent() {, +        final Object expected = new Object();, +        Resource fromCache = mock(Resource.class);, +        when(fromCache.get()).thenReturn(expected);, +        when(harness.cache.remove(eq(harness.cacheKey))).thenReturn(fromCache);, +, +        doAnswer(new Answer() {, +            @Override, +            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {, +                Resource resource = (Resource) invocationOnMock.getArguments()[0];, +                assertEquals(expected, resource.get());, +                return null;, +            }, +        }).when(harness.cb).onResourceReady(any(Resource.class));, +, +        harness.doLoad();, +, +        verify(harness.cb).onResourceReady(any(Resource.class));, +    }, +, +        WeakReference<EngineResource<?>> resourceRef = harness.activeResources.get(harness.cacheKey);, +        final Object expected = new Object();, +        when(harness.resource.isCacheable()).thenReturn(true);, +        when(harness.resource.get()).thenReturn(expected);, +        doAnswer(new Answer() {, +            @Override, +            public Object answer(InvocationOnMock invocationOnMock) throws Throwable {, +                Resource<?> resource = (Resource<?>) invocationOnMock.getArguments()[1];]
[+++ b/gradle.properties, +VERSION_NAME=4.4.0-SNAPSHOT, +VERSION_MINOR=4]
[+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java, +final class DefaultConnectivityMonitor implements ConnectivityMonitor {, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +          Log.d(TAG, "connectivity changed, isConnected: " + isConnected);, +        }, +, +  DefaultConnectivityMonitor(Context context, ConnectivityListener listener) {, +++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java, +final class DefaultConnectivityMonitor implements ConnectivityMonitor {, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +          Log.d(TAG, "connectivity changed, isConnected: " + isConnected);, +        }, +, +  DefaultConnectivityMonitor(Context context, ConnectivityListener listener) {, +++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java, +import android.util.Log;, +  private static final String TAG = "ConnectivityMonitor";, +    if (Log.isLoggable(TAG, Log.DEBUG)) {, +      Log.d(, +          TAG,, +          hasPermission, +              ? "ACCESS_NETWORK_STATE permission granted, registering connectivity monitor", +              : "ACCESS_NETWORK_STATE permission missing, cannot register connectivity monitor");, +    }, +++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java, +final class DefaultConnectivityMonitor implements ConnectivityMonitor {, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +          Log.d(TAG, "connectivity changed, isConnected: " + isConnected);, +        }, +, +  DefaultConnectivityMonitor(Context context, ConnectivityListener listener) {, +++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java, +import android.util.Log;, +  private static final String TAG = "ConnectivityMonitor";, +    if (Log.isLoggable(TAG, Log.DEBUG)) {, +      Log.d(, +          TAG,, +          hasPermission, +              ? "ACCESS_NETWORK_STATE permission granted, registering connectivity monitor", +              : "ACCESS_NETWORK_STATE permission missing, cannot register connectivity monitor");, +    }, +++ b/samples/flickr/src/main/AndroidManifest.xml, +    <!--, +    Allows Glide to monitor connectivity status and restart failed requests if users go from a, +    a disconnected to a connected network state., +    -->, +++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java, +final class DefaultConnectivityMonitor implements ConnectivityMonitor {, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +          Log.d(TAG, "connectivity changed, isConnected: " + isConnected);, +        }, +, +  DefaultConnectivityMonitor(Context context, ConnectivityListener listener) {, +++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java, +import android.util.Log;, +  private static final String TAG = "ConnectivityMonitor";, +    if (Log.isLoggable(TAG, Log.DEBUG)) {, +      Log.d(, +          TAG,, +          hasPermission, +              ? "ACCESS_NETWORK_STATE permission granted, registering connectivity monitor", +              : "ACCESS_NETWORK_STATE permission missing, cannot register connectivity monitor");, +    }, +++ b/samples/flickr/src/main/AndroidManifest.xml, +    <!--, +    Allows Glide to monitor connectivity status and restart failed requests if users go from a, +    a disconnected to a connected network state., +    -->, +++ b/samples/giphy/src/main/AndroidManifest.xml, +    <!--, +    Allows Glide to monitor connectivity status and restart failed requests if users go from a, +    a disconnected to a connected network state., +    -->, +    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>, +++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java, +final class DefaultConnectivityMonitor implements ConnectivityMonitor {, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +          Log.d(TAG, "connectivity changed, isConnected: " + isConnected);, +        }, +, +  DefaultConnectivityMonitor(Context context, ConnectivityListener listener) {, +++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitorFactory.java, +import android.util.Log;, +  private static final String TAG = "ConnectivityMonitor";, +    if (Log.isLoggable(TAG, Log.DEBUG)) {, +      Log.d(, +          TAG,, +          hasPermission, +              ? "ACCESS_NETWORK_STATE permission granted, registering connectivity monitor", +              : "ACCESS_NETWORK_STATE permission missing, cannot register connectivity monitor");, +    }, +++ b/samples/flickr/src/main/AndroidManifest.xml, +    <!--, +    Allows Glide to monitor connectivity status and restart failed requests if users go from a, +    a disconnected to a connected network state., +    -->, +++ b/samples/giphy/src/main/AndroidManifest.xml, +    <!--, +    Allows Glide to monitor connectivity status and restart failed requests if users go from a, +    a disconnected to a connected network state.]
[+++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="19" />, +++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="19" />, +++ b/library/src/com/bumptech/glide/Glide.java, +import android.graphics.Bitmap;, +import android.graphics.drawable.Drawable;, +import android.os.ParcelFileDescriptor;, +import android.view.View;, +import com.bumptech.glide.loader.bitmap.ImageVideoBitmapLoadFactory;, +import com.bumptech.glide.loader.bitmap.ResourceBitmapLoadFactory;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorFileLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorModelLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorResourceLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorStringLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorUriLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamByteArrayLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamResourceLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamFileLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamModelLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamStringLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamUriLoader;, +import com.bumptech.glide.loader.bitmap.model.GenericLoaderFactory;, +import com.bumptech.glide.loader.bitmap.model.ModelLoader;, +import com.bumptech.glide.loader.bitmap.model.ModelLoaderFactory;, +import com.bumptech.glide.loader.bitmap.transformation.CenterCrop;, +import com.bumptech.glide.loader.bitmap.transformation.FitCenter;, +import com.bumptech.glide.loader.bitmap.transformation.MultiTransformationLoader;, +import com.bumptech.glide.loader.bitmap.transformation.None;, +import com.bumptech.glide.loader.bitmap.transformation.TransformationLoader;, +import com.bumptech.glide.presenter.target.ImageViewTarget;, +import com.bumptech.glide.presenter.target.ViewTarget;, +import com.bumptech.glide.resize.load.BitmapDecoder;, +import com.bumptech.glide.resize.load.VideoBitmapDecoder;, +import java.io.InputStream;, +import java.util.UUID;, + * A singleton to present a simple static interface for Glide {@link Request} and to create and manage an, +         *     public void onException(Exception e, ModelType model, Target target) {, +        register(File.class, ParcelFileDescriptor.class, new FileDescriptorFileLoader.Factory());, +        register(File.class, InputStream.class, new StreamFileLoader.Factory());, +        register(Integer.class, ParcelFileDescriptor.class, new FileDescriptorResourceLoader.Factory());, +        register(Integer.class, InputStream.class, new StreamResourceLoader.Factory());, +        register(String.class, ParcelFileDescriptor.class, new FileDescriptorStringLoader.Factory());, +        register(String.class, InputStream.class, new StreamStringLoader.Factory());, +        register(Uri.class, ParcelFileDescriptor.class, new FileDescriptorUriLoader.Factory());, +        register(Uri.class, InputStream.class, new StreamUriLoader.Factory());, +            register(URL.class, InputStream.class, new VolleyUrlLoader.Factory());, +     * {@link ImageManager} with custom options for use with {@link Request} and/or as an, +     * Set the {@link ImageManager} to use with {@link Request}., +     * Set the {@link ImageManager} to use with {@link Request} Replaces the current, +     * models. Typically the {@link ModelRequest#using(StreamModelLoader)} or, +     * {@link ModelRequest#using(FileDescriptorModelLoader)} syntax is preferred because it directly links the model, +     * with the ModelLoader being used to load it., +     *     used for any other model class, {@link ModelLoaderFactory#teardown()}, +     * @see ModelRequest#using(FileDescriptorModelLoader), +     * @see ModelRequest#using(StreamModelLoader), +     *, +     * @param modelClass The model class., +     * @param resourceClass The resource class the model loader will translate the model type into., +     * @param factory The factory to use., +     * @param <T> The type of the model., +     * @param <Y> the type of the resource., +    public <T, Y> void register(Class<T> modelClass, Class<Y> resourceClass, ModelLoaderFactory<T, Y> factory) {, +        ModelLoaderFactory<T, Y> removed = loaderFactory.register(modelClass, resourceClass, factory);, +    @SuppressWarnings("unchecked"), +    private <T, Y> ModelLoaderFactory<T, Y> getFactory(T model, Class<Y> resourceClass) {, +        return loaderFactory.getFactory((Class<T>) model.getClass(), resourceClass);, +    }, +, +     * @param modelClass The class to get a {@link ModelLoader} for, +    public static <T, Y> ModelLoader<T, Y> buildModelLoader(Class<T> modelClass, Class<Y> resourceClass, Context context) {, +        return GLIDE.loaderFactory.buildModelLoader(modelClass, resourceClass, context);, +     * A convenience method to build a {@link ModelLoader} for the given model that produces {@link InputStream}s using, +     * a registered factory., +     * @see #buildModelLoader(Class, Class, android.content.Context), +    public static <T> ModelLoader<T, InputStream> buildStreamModelLoader(Class<T> modelClass, Context context) {, +        return buildModelLoader(modelClass, InputStream.class, context);, +     * A convenience method to build a {@link ModelLoader} for the given model class that produces, +     * {@link ParcelFileDescriptor}s using a registered factory., +     * @see #buildModelLoader(Class, Class, android.content.Context), +    public static <T> ModelLoader<T, ParcelFileDescriptor> buildFileDescriptorModelLoader(Class<T> modelClass,, +            Context context) {, +        return buildModelLoader(modelClass, ParcelFileDescriptor.class, context);, +    /**, +     * Cancel any pending loads Glide may have for the target and free any resources (such as {@link Bitmap}s) that may, +     * have been loaded for the target so they may be reused., +     *, +     * @param target The Target to cancel loads for., +     */, +    public static void clear(Target target) {, +        ImagePresenter imagePresenter = target.getImagePresenter();, +        if (imagePresenter != null) {, +            imagePresenter.clear();, +        }, +    /**, +     * Cancel any pending loads Glide may have for the view and free any resources that may have been loaded for the, +     * view., +     *, +     * <p>, +     *     Note that this will only work if {@link View#setTag(Object)} is not called on this view outside of Glide.]
[+++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.image.ImageManagerLoader;, +import com.bumptech.glide.resize.load.Downsampler;, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.image.ImageManagerLoader;, +import com.bumptech.glide.resize.load.Downsampler;, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/image/ImageLoader.java, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.image.ImageManagerLoader;, +import com.bumptech.glide.resize.load.Downsampler;, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/image/ImageLoader.java, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/image/ImageManagerLoader.java, +import com.bumptech.glide.resize.load.Downsampler;, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.image.ImageManagerLoader;, +import com.bumptech.glide.resize.load.Downsampler;, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/image/ImageLoader.java, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/image/ImageManagerLoader.java, +import com.bumptech.glide.resize.load.Downsampler;, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/transformation/CenterCrop.java, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.image.ImageManagerLoader;, +import com.bumptech.glide.resize.load.Downsampler;, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/image/ImageLoader.java, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/image/ImageManagerLoader.java, +import com.bumptech.glide.resize.load.Downsampler;, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/transformation/CenterCrop.java, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/transformation/FitCenter.java, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.image.ImageManagerLoader;, +import com.bumptech.glide.resize.load.Downsampler;, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/image/ImageLoader.java, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/image/ImageManagerLoader.java, +import com.bumptech.glide.resize.load.Downsampler;, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/transformation/CenterCrop.java, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/transformation/FitCenter.java, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/transformation/None.java, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.image.ImageManagerLoader;, +import com.bumptech.glide.resize.load.Downsampler;, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/image/ImageLoader.java, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/image/ImageManagerLoader.java, +import com.bumptech.glide.resize.load.Downsampler;, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/transformation/CenterCrop.java, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/transformation/FitCenter.java, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/transformation/None.java, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/transformation/TransformationLoader.java, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.image.ImageManagerLoader;, +import com.bumptech.glide.resize.load.Downsampler;, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/image/ImageLoader.java, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/image/ImageManagerLoader.java, +import com.bumptech.glide.resize.load.Downsampler;, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/transformation/CenterCrop.java, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/transformation/FitCenter.java, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/transformation/None.java, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/transformation/TransformationLoader.java, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/presenter/ImagePresenter.java, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.image.ImageManagerLoader;, +import com.bumptech.glide.resize.load.Downsampler;, +import com.bumptech.glide.resize.load.Transformation;, +++ b/library/src/com/bumptech/glide/loader/image/ImageLoader.java, +import com.bumptech.glide.resize.load.Transformation;]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java, +  @SuppressWarnings("deprecation"), +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java, +  @SuppressWarnings("deprecation"), +++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java, +   * Helper constructor that accepts an {@link Fragment}., +  public RecyclerViewPreloader(@NonNull Fragment fragment,, +   * Helper constructor that accepts an {@link android.app.Fragment}., +   * @deprecated Use constructor <code>RecyclerViewPreloader(Fragment, PreloadModelProvider<T>,, +   * PreloadSizeProvider<T>)</code> instead., +  @Deprecated, +  public RecyclerViewPreloader(@NonNull android.app.Fragment fragment,, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java, +  @SuppressWarnings("deprecation"), +++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java, +   * Helper constructor that accepts an {@link Fragment}., +  public RecyclerViewPreloader(@NonNull Fragment fragment,, +   * Helper constructor that accepts an {@link android.app.Fragment}., +   * @deprecated Use constructor <code>RecyclerViewPreloader(Fragment, PreloadModelProvider<T>,, +   * PreloadSizeProvider<T>)</code> instead., +  @Deprecated, +  public RecyclerViewPreloader(@NonNull android.app.Fragment fragment,, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +   * @deprecated Prefer support Fragments and {@link #with(Fragment)} instead,, +   * {@link android.app.Fragment} will be deprecated. See, +   * https://github.com/android/android-ktx/pull/161#issuecomment-363270555., +  @SuppressWarnings("deprecation"), +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java, +  @SuppressWarnings("deprecation"), +++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java, +   * Helper constructor that accepts an {@link Fragment}., +  public RecyclerViewPreloader(@NonNull Fragment fragment,, +   * Helper constructor that accepts an {@link android.app.Fragment}., +   * @deprecated Use constructor <code>RecyclerViewPreloader(Fragment, PreloadModelProvider<T>,, +   * PreloadSizeProvider<T>)</code> instead., +  @Deprecated, +  public RecyclerViewPreloader(@NonNull android.app.Fragment fragment,, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +   * @deprecated Prefer support Fragments and {@link #with(Fragment)} instead,, +   * {@link android.app.Fragment} will be deprecated. See, +   * https://github.com/android/android-ktx/pull/161#issuecomment-363270555., +  @SuppressWarnings("deprecation"), +++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java, +@SuppressWarnings("DeprecatedIsStillUsed"), +  @SuppressWarnings("deprecation"), +  @SuppressWarnings("deprecation"), +  @Nullable, +  private RequestManagerFragment rootRequestManagerFragment;, +  @SuppressWarnings("deprecation"), +  @SuppressWarnings("deprecation"), +  @SuppressWarnings("deprecation"), +  @SuppressWarnings("deprecation"), +    @SuppressWarnings("deprecation"), +    @SuppressWarnings("deprecation"), +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java, +  @SuppressWarnings("deprecation"), +++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java, +   * Helper constructor that accepts an {@link Fragment}., +  public RecyclerViewPreloader(@NonNull Fragment fragment,, +   * Helper constructor that accepts an {@link android.app.Fragment}., +   * @deprecated Use constructor <code>RecyclerViewPreloader(Fragment, PreloadModelProvider<T>,, +   * PreloadSizeProvider<T>)</code> instead., +  @Deprecated, +  public RecyclerViewPreloader(@NonNull android.app.Fragment fragment,, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +   * @deprecated Prefer support Fragments and {@link #with(Fragment)} instead,, +   * {@link android.app.Fragment} will be deprecated. See, +   * https://github.com/android/android-ktx/pull/161#issuecomment-363270555., +  @SuppressWarnings("deprecation"), +++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java, +@SuppressWarnings("DeprecatedIsStillUsed"), +  @SuppressWarnings("deprecation"), +  @SuppressWarnings("deprecation"), +  @Nullable, +  private RequestManagerFragment rootRequestManagerFragment;, +  @SuppressWarnings("deprecation"), +  @SuppressWarnings("deprecation"), +  @SuppressWarnings("deprecation"), +  @SuppressWarnings("deprecation"), +    @SuppressWarnings("deprecation"), +    @SuppressWarnings("deprecation"), +++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java, +  @SuppressWarnings("deprecation"), +  @SuppressWarnings("deprecation"), +  @SuppressWarnings("deprecation"), +  @SuppressWarnings({"deprecation", "DeprecatedIsStillUsed"}), +  @SuppressWarnings("deprecation"), +  @SuppressWarnings("deprecation"), +  @SuppressWarnings("deprecation"), +  @SuppressWarnings("deprecation"), +  @SuppressWarnings({"deprecation", "DeprecatedIsStillUsed"}), +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java, +  @SuppressWarnings("deprecation"), +++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java, +   * Helper constructor that accepts an {@link Fragment}., +  public RecyclerViewPreloader(@NonNull Fragment fragment,, +   * Helper constructor that accepts an {@link android.app.Fragment}., +   * @deprecated Use constructor <code>RecyclerViewPreloader(Fragment, PreloadModelProvider<T>,, +   * PreloadSizeProvider<T>)</code> instead., +  @Deprecated]
[+++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java, +    private final ImageView view;, +, +        this.view = view;, +        view.setImageDrawable(resource);, +        view.setImageDrawable(placeholder);, +++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java, +    private final ImageView view;, +, +        this.view = view;, +        view.setImageDrawable(resource);, +        view.setImageDrawable(placeholder);, +++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java, +                    observer.removeOnPreDrawListener(layoutListener);, +                observer.addOnPreDrawListener(layoutListener);, +        private static class SizeDeterminerLayoutListener implements ViewTreeObserver.OnPreDrawListener {, +            public boolean onPreDraw() {, +                return true;, +++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java, +    private final ImageView view;, +, +        this.view = view;, +        view.setImageDrawable(resource);, +        view.setImageDrawable(placeholder);, +++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java, +                    observer.removeOnPreDrawListener(layoutListener);, +                observer.addOnPreDrawListener(layoutListener);, +        private static class SizeDeterminerLayoutListener implements ViewTreeObserver.OnPreDrawListener {, +            public boolean onPreDraw() {, +                return true;, +++ b/library/src/test/java/com/bumptech/glide/request/target/ViewTargetTest.java, +package com.bumptech.glide.request.target;, +, +import android.content.Context;, +import android.graphics.drawable.Drawable;, +import android.view.View;, +import android.view.ViewTreeObserver;, +import android.view.WindowManager;, +import android.view.animation.AlphaAnimation;, +import android.view.animation.Animation;, +import com.bumptech.glide.request.Request;, +import junit.framework.TestCase;, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.Robolectric;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +import org.robolectric.annotation.Implementation;, +import org.robolectric.annotation.Implements;, +import org.robolectric.shadows.ShadowDisplay;, +import org.robolectric.shadows.ShadowView;, +import org.robolectric.shadows.ShadowViewTreeObserver;, +, +import java.util.List;, +import java.util.concurrent.CopyOnWriteArrayList;, +, +import static android.view.ViewGroup.LayoutParams;, +import static android.view.ViewTreeObserver.OnPreDrawListener;, +import static com.bumptech.glide.request.target.Target.SizeReadyCallback;, +import static junit.framework.Assert.assertEquals;, +import static junit.framework.TestCase.assertNull;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.never;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +, +@RunWith(RobolectricTestRunner.class), +@Config(shadows = { ViewTargetTest.SizedShadowView.class, ViewTargetTest.PreDrawShadowViewTreeObserver.class }), +public class ViewTargetTest {, +    private View view;, +    private ViewTarget target;, +, +    @Before, +    public void setUp() {, +        view = new View(Robolectric.application);, +        target = new ViewTarget<View, Object>(view) {, +            @Override, +            public void onResourceReady(Object resource) {, +            }, +, +            @Override, +            public void setPlaceholder(Drawable placeholder) {, +            }, +        };, +    }, +, +    @Test, +    public void testReturnsWrappedView() {, +        assertEquals(view, target.getView());, +    }, +, +    @Test, +    public void testStartsAnimationOnView() {, +        Animation animation = new AlphaAnimation(0f, 1f);, +        target.startAnimation(animation);, +, +        assertEquals(animation, view.getAnimation());]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, +            "AppGlideModule excludes LibraryGlideModule from annotation: " + glideModule);, +            "Discovered LibraryGlideModule from annotation: " + glideModule);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, +            "AppGlideModule excludes LibraryGlideModule from annotation: " + glideModule);, +            "Discovered LibraryGlideModule from annotation: " + glideModule);, +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithLibraryInPackageTest.java, +package com.bumptech.glide.annotation.compiler;, +, +import static com.bumptech.glide.annotation.compiler.test.Util.appResource;, +import static com.bumptech.glide.annotation.compiler.test.Util.asUnixChars;, +import static com.bumptech.glide.annotation.compiler.test.Util.glide;, +import static com.bumptech.glide.annotation.compiler.test.Util.subpackage;, +import static com.google.testing.compile.CompilationSubject.assertThat;, +import static com.google.testing.compile.Compiler.javac;, +, +import com.bumptech.glide.annotation.compiler.test.ReferencedResource;, +import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;, +import com.bumptech.glide.annotation.compiler.test.Util;, +import com.google.testing.compile.Compilation;, +import java.io.IOException;, +import javax.tools.JavaFileObject;, +import org.junit.Before;, +import org.junit.Rule;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +, +/**, + * Tests AppGlideModules that use the @Excludes annotation, + * with a single excluded Module class in a strangely named subpackage., + */, +@RunWith(JUnit4.class), +public class AppGlideModuleWithLibraryInPackageTest {, +  @Rule public final RegenerateResourcesRule regenerateResourcesRule =, +      new RegenerateResourcesRule(getClass());, +  private Compilation compilation;, +, +  @Before, +  public void setUp() {, +    compilation =, +        javac(), +            .withProcessors(new GlideAnnotationProcessor()), +            .compile(, +                forResource("AppModuleWithLibraryInPackage.java"),, +                forResource("LibraryModuleInPackage.java"));, +    assertThat(compilation).succeededWithoutWarnings();, +  }, +, +  @Test, +  @ReferencedResource, +  public void compilation_generatesExpectedGlideOptionsClass() throws IOException {, +    assertThat(compilation), +        .generatedSourceFile(subpackage("GlideOptions")), +        .contentsAsUtf8String(), +        .isEqualTo(asUnixChars(appResource("GlideOptions.java").getCharContent(true)));, +  }, +, +  @Test, +  @ReferencedResource, +  public void compilation_generatesExpectedGlideRequestClass() throws IOException {, +    assertThat(compilation), +        .generatedSourceFile(subpackage("GlideRequest")), +        .contentsAsUtf8String(), +        .isEqualTo(asUnixChars(appResource("GlideRequest.java").getCharContent(true)));, +  }, +, +  @Test, +  @ReferencedResource, +  public void compilation_generatesExpectedGlideRequestsClass() throws IOException {, +    assertThat(compilation), +        .generatedSourceFile(subpackage("GlideRequests")), +        .contentsAsUtf8String(), +        .isEqualTo(asUnixChars(appResource("GlideRequests.java").getCharContent(true)));, +  }, +, +  @Test, +  @ReferencedResource, +  public void compilationGeneratesExpectedGlideAppClass() throws IOException {, +    assertThat(compilation), +        .generatedSourceFile(subpackage("GlideApp")), +        .contentsAsUtf8String(), +        .isEqualTo(asUnixChars(appResource("GlideApp.java").getCharContent(true)));, +  }, +, +  @Test, +  public void compilation_generatesExpectedGeneratedAppGlideModuleImpl() throws IOException {, +    assertThat(compilation), +        .generatedSourceFile(glide("GeneratedAppGlideModuleImpl")), +        .contentsAsUtf8String(), +        .isEqualTo(, +            asUnixChars(forResource("GeneratedAppGlideModuleImpl.java").getCharContent(true)));, +  }, +, +  @Test, +  @ReferencedResource, +  public void compilation_generatesExpectedGeneratedRequestManagerFactory() throws IOException {, +    assertThat(compilation), +        .generatedSourceFile(glide("GeneratedRequestManagerFactory")), +        .contentsAsUtf8String()]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +  Glide(Engine engine, MemoryCache memoryCache, BitmapPool bitmapPool, ByteArrayPool byteArrayPool,, +      Context context, int logLevel, RequestOptions defaultRequestOptions) {, +    this.byteArrayPool = byteArrayPool;, +    ByteBufferGifDecoder byteBufferGifDecoder = new ByteBufferGifDecoder(context, bitmapPool,, +        byteArrayPool);, +    byteArrayPool.clearMemory();, +    byteArrayPool.trimMemory(level);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +  Glide(Engine engine, MemoryCache memoryCache, BitmapPool bitmapPool, ByteArrayPool byteArrayPool,, +      Context context, int logLevel, RequestOptions defaultRequestOptions) {, +    this.byteArrayPool = byteArrayPool;, +    ByteBufferGifDecoder byteBufferGifDecoder = new ByteBufferGifDecoder(context, bitmapPool,, +        byteArrayPool);, +    byteArrayPool.clearMemory();, +    byteArrayPool.trimMemory(level);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;, +import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;, +  private ByteArrayPool byteArrayPool;, +   * Sets the {@link ByteArrayPool} implementation to allow variable sized byte arrays to be stored, +   * @param byteArrayPool The pool to use., +  public GlideBuilder setByteArrayPool(ByteArrayPool byteArrayPool) {, +    this.byteArrayPool = byteArrayPool;, +    if (byteArrayPool == null) {, +      byteArrayPool = new LruByteArrayPool(memorySizeCalculator.getByteArrayPoolSize());, +    return new Glide(engine, memoryCache, bitmapPool, byteArrayPool, context, logLevel,, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +  Glide(Engine engine, MemoryCache memoryCache, BitmapPool bitmapPool, ByteArrayPool byteArrayPool,, +      Context context, int logLevel, RequestOptions defaultRequestOptions) {, +    this.byteArrayPool = byteArrayPool;, +    ByteBufferGifDecoder byteBufferGifDecoder = new ByteBufferGifDecoder(context, bitmapPool,, +        byteArrayPool);, +    byteArrayPool.clearMemory();, +    byteArrayPool.trimMemory(level);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;, +import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;, +  private ByteArrayPool byteArrayPool;, +   * Sets the {@link ByteArrayPool} implementation to allow variable sized byte arrays to be stored, +   * @param byteArrayPool The pool to use., +  public GlideBuilder setByteArrayPool(ByteArrayPool byteArrayPool) {, +    this.byteArrayPool = byteArrayPool;, +    if (byteArrayPool == null) {, +      byteArrayPool = new LruByteArrayPool(memorySizeCalculator.getByteArrayPoolSize());, +    return new Glide(engine, memoryCache, bitmapPool, byteArrayPool, context, logLevel,, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +  Glide(Engine engine, MemoryCache memoryCache, BitmapPool bitmapPool, ByteArrayPool byteArrayPool,, +      Context context, int logLevel, RequestOptions defaultRequestOptions) {, +    this.byteArrayPool = byteArrayPool;, +    ByteBufferGifDecoder byteBufferGifDecoder = new ByteBufferGifDecoder(context, bitmapPool,, +        byteArrayPool);, +    byteArrayPool.clearMemory();, +    byteArrayPool.trimMemory(level);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;, +import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;, +  private ByteArrayPool byteArrayPool;, +   * Sets the {@link ByteArrayPool} implementation to allow variable sized byte arrays to be stored, +   * @param byteArrayPool The pool to use., +  public GlideBuilder setByteArrayPool(ByteArrayPool byteArrayPool) {, +    this.byteArrayPool = byteArrayPool;, +    if (byteArrayPool == null) {, +      byteArrayPool = new LruByteArrayPool(memorySizeCalculator.getByteArrayPoolSize());, +    return new Glide(engine, memoryCache, bitmapPool, byteArrayPool, context, logLevel,, +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +  Glide(Engine engine, MemoryCache memoryCache, BitmapPool bitmapPool, ByteArrayPool byteArrayPool,, +      Context context, int logLevel, RequestOptions defaultRequestOptions) {, +    this.byteArrayPool = byteArrayPool;, +    ByteBufferGifDecoder byteBufferGifDecoder = new ByteBufferGifDecoder(context, bitmapPool,, +        byteArrayPool);, +    byteArrayPool.clearMemory();, +    byteArrayPool.trimMemory(level);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;, +import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;, +  private ByteArrayPool byteArrayPool;, +   * Sets the {@link ByteArrayPool} implementation to allow variable sized byte arrays to be stored, +   * @param byteArrayPool The pool to use., +  public GlideBuilder setByteArrayPool(ByteArrayPool byteArrayPool) {, +    this.byteArrayPool = byteArrayPool;, +    if (byteArrayPool == null) {, +      byteArrayPool = new LruByteArrayPool(memorySizeCalculator.getByteArrayPoolSize());, +    return new Glide(engine, memoryCache, bitmapPool, byteArrayPool, context, logLevel,, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +  Glide(Engine engine, MemoryCache memoryCache, BitmapPool bitmapPool, ByteArrayPool byteArrayPool,, +      Context context, int logLevel, RequestOptions defaultRequestOptions) {, +    this.byteArrayPool = byteArrayPool;, +    ByteBufferGifDecoder byteBufferGifDecoder = new ByteBufferGifDecoder(context, bitmapPool,, +        byteArrayPool);, +    byteArrayPool.clearMemory();, +    byteArrayPool.trimMemory(level);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ByteArrayPool;]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, + *   <li>{@link com.bumptech.glide.annotation.GlideExtension}s -, + *   <ul>, + *     <li>A {@link com.bumptech.glide.request.BaseRequestOptions} implementation that contains, + *     static versions of all builder methods in the base class and both static and instance, + *     versions of methods in all {@link com.bumptech.glide.annotation.GlideExtension}s., + *     <li>If one or more methods in one or more, + *     {@link com.bumptech.glide.annotation.GlideExtension} annotated classes are annotated with, + *     {@link com.bumptech.glide.annotation.ExtendsRequestManager}:, + *     <ul>, + *       <li>A {@link com.bumptech.glide.RequestManager} implementation containing a generated, + *       method for each method annotated with, + *       {@link com.bumptech.glide.annotation.ExtendsRequestManager}., + *       <li>A {@link com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}, + *       implementation that produces the generated {@link com.bumptech.glide.RequestManager}s., + *       <li>A {@link com.bumptech.glide.Glide} look-alike that implements all static methods in, + *       the {@link com.bumptech.glide.Glide} singleton and returns the generated, + *       {@link com.bumptech.glide.RequestManager} implementation when appropriate., + *     </ul>, + *   </ul>, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, + *   <li>{@link com.bumptech.glide.annotation.GlideExtension}s -, + *   <ul>, + *     <li>A {@link com.bumptech.glide.request.BaseRequestOptions} implementation that contains, + *     static versions of all builder methods in the base class and both static and instance, + *     versions of methods in all {@link com.bumptech.glide.annotation.GlideExtension}s., + *     <li>If one or more methods in one or more, + *     {@link com.bumptech.glide.annotation.GlideExtension} annotated classes are annotated with, + *     {@link com.bumptech.glide.annotation.ExtendsRequestManager}:, + *     <ul>, + *       <li>A {@link com.bumptech.glide.RequestManager} implementation containing a generated, + *       method for each method annotated with, + *       {@link com.bumptech.glide.annotation.ExtendsRequestManager}., + *       <li>A {@link com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}, + *       implementation that produces the generated {@link com.bumptech.glide.RequestManager}s., + *       <li>A {@link com.bumptech.glide.Glide} look-alike that implements all static methods in, + *       the {@link com.bumptech.glide.Glide} singleton and returns the generated, + *       {@link com.bumptech.glide.RequestManager} implementation when appropriate., + *     </ul>, + *   </ul>, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +import com.bumptech.glide.annotation.ExtendsRequestManager;, +        } else if (executableElement.getAnnotation(ExtendsRequestManager.class) != null) {, +          validateExtendsRequestManager(executableElement);, +  private static void validateExtendsRequestManager(ExecutableElement executableElement) {, +    validateStaticVoid(executableElement, ExtendsRequestManager.class);, +    if (executableElement.getParameters().size() != 1) {, +      throw new IllegalArgumentException("@ExtendsRequestManager methods must take a", +          + " BaseRequestOptions object as their first and only parameter, found multiple for: ", +      + executableElement.getEnclosingElement() + "#" + executableElement);, +    }, +, +    VariableElement first = executableElement.getParameters().get(0);, +    TypeMirror expected = first.asType();, +    if (!expected.toString().startsWith("com.bumptech.glide.RequestBuilder")) {, +      throw new IllegalArgumentException("@ExtendsRequestManager methods must take a", +          + " RequestBuilder object as their first parameter, but given: " + expected);, +    }, +  }, +, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, + *   <li>{@link com.bumptech.glide.annotation.GlideExtension}s -, + *   <ul>, + *     <li>A {@link com.bumptech.glide.request.BaseRequestOptions} implementation that contains, + *     static versions of all builder methods in the base class and both static and instance, + *     versions of methods in all {@link com.bumptech.glide.annotation.GlideExtension}s., + *     <li>If one or more methods in one or more, + *     {@link com.bumptech.glide.annotation.GlideExtension} annotated classes are annotated with, + *     {@link com.bumptech.glide.annotation.ExtendsRequestManager}:, + *     <ul>, + *       <li>A {@link com.bumptech.glide.RequestManager} implementation containing a generated, + *       method for each method annotated with, + *       {@link com.bumptech.glide.annotation.ExtendsRequestManager}., + *       <li>A {@link com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}, + *       implementation that produces the generated {@link com.bumptech.glide.RequestManager}s., + *       <li>A {@link com.bumptech.glide.Glide} look-alike that implements all static methods in, + *       the {@link com.bumptech.glide.Glide} singleton and returns the generated, + *       {@link com.bumptech.glide.RequestManager} implementation when appropriate., + *     </ul>, + *   </ul>, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +import com.bumptech.glide.annotation.ExtendsRequestManager;, +        } else if (executableElement.getAnnotation(ExtendsRequestManager.class) != null) {, +          validateExtendsRequestManager(executableElement);, +  private static void validateExtendsRequestManager(ExecutableElement executableElement) {, +    validateStaticVoid(executableElement, ExtendsRequestManager.class);, +    if (executableElement.getParameters().size() != 1) {, +      throw new IllegalArgumentException("@ExtendsRequestManager methods must take a", +          + " BaseRequestOptions object as their first and only parameter, found multiple for: ", +      + executableElement.getEnclosingElement() + "#" + executableElement);, +    }, +, +    VariableElement first = executableElement.getParameters().get(0);, +    TypeMirror expected = first.asType();, +    if (!expected.toString().startsWith("com.bumptech.glide.RequestBuilder")) {, +      throw new IllegalArgumentException("@ExtendsRequestManager methods must take a", +          + " RequestBuilder object as their first parameter, but given: " + expected);, +    }, +  }, +]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java, +package com.bumptech.glide.load.resource.drawable;, +, +import android.graphics.Canvas;, +import android.graphics.ColorFilter;, +import android.graphics.drawable.Drawable;, +, +import com.bumptech.glide.load.resource.gif.GifDrawable;, +, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;, +, +import static junit.framework.Assert.assertEquals;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, +@RunWith(RobolectricTestRunner.class), +public class DrawableResourceTest {, +    private TestDrawable drawable;, +    private DrawableResource<TestDrawable> resource;, +, +    @Before, +    public void setUp() {, +        drawable = mock(TestDrawable.class);, +        resource = new DrawableResource<TestDrawable>(drawable) {, +            @Override, +            public int getSize() {, +                return 0;, +            }, +, +            @Override, +            public void recycle() { }, +        };, +    }, +, +    @Test, +    public void testReturnsDrawableOnFirstGet() {, +        assertEquals(drawable, resource.get());, +    }, +, +    @Test, +    public void testReturnsNewDrawableOnSecondGet() {, +        GifDrawable expected = mock(GifDrawable.class);, +        Drawable.ConstantState constantState = mock(Drawable.ConstantState.class);, +        when(constantState.newDrawable()).thenReturn(expected);, +        when(drawable.getConstantState()).thenReturn(constantState);, +, +        assertEquals(drawable, resource.get());, +        assertEquals(expected, resource.get());, +, +        verify(drawable).getConstantState();, +        verify(constantState).newDrawable();, +    }, +, +    /** Just to have a type to test with which is not directly Drawable */, +    private static class TestDrawable extends Drawable {, +        @Override, +        public void draw(Canvas canvas) {, +, +        }, +, +        @Override, +        public void setAlpha(int alpha) {, +, +        }, +, +        @Override, +        public void setColorFilter(ColorFilter cf) {, +, +        }, +, +        @Override, +        public int getOpacity() {, +            return 0;, +        }, +    }, +}, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/drawable/DrawableResourceTest.java, +package com.bumptech.glide.load.resource.drawable;, +, +import android.graphics.Canvas;, +import android.graphics.ColorFilter;, +import android.graphics.drawable.Drawable;, +, +import com.bumptech.glide.load.resource.gif.GifDrawable;, +, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;, +, +import static junit.framework.Assert.assertEquals;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, +@RunWith(RobolectricTestRunner.class)]
[+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java, +    Button search = (Button) findViewById(R.id.search);, +    Resources res = getResources();, +    ViewPager pager = (ViewPager) findViewById(R.id.view_pager);, +    pager.setPageMargin(res.getDimensionPixelOffset(R.dimen.page_margin));, +, +    @Override, +    public CharSequence getPageTitle(int position) {, +      Page page = Page.values()[position];, +      int titleId = PAGE_TO_TITLE.get(page);, +      return getString(titleId);, +    }, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java, +    Button search = (Button) findViewById(R.id.search);, +    Resources res = getResources();, +    ViewPager pager = (ViewPager) findViewById(R.id.view_pager);, +    pager.setPageMargin(res.getDimensionPixelOffset(R.dimen.page_margin));, +, +    @Override, +    public CharSequence getPageTitle(int position) {, +      Page page = Page.values()[position];, +      int titleId = PAGE_TO_TITLE.get(page);, +      return getString(titleId);, +    }, +++ b/samples/flickr/src/main/res/layout/flickr_photo_grid.xml, +          android:layout_height="fill_parent", +          android:paddingTop="10dp" />, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java, +    Button search = (Button) findViewById(R.id.search);, +    Resources res = getResources();, +    ViewPager pager = (ViewPager) findViewById(R.id.view_pager);, +    pager.setPageMargin(res.getDimensionPixelOffset(R.dimen.page_margin));, +, +    @Override, +    public CharSequence getPageTitle(int position) {, +      Page page = Page.values()[position];, +      int titleId = PAGE_TO_TITLE.get(page);, +      return getString(titleId);, +    }, +++ b/samples/flickr/src/main/res/layout/flickr_photo_grid.xml, +          android:layout_height="fill_parent", +          android:paddingTop="10dp" />, +++ b/samples/flickr/src/main/res/layout/flickr_search_activity.xml, +                android:layout_height="fill_parent">, +, +                <android.support.v4.view.PagerTabStrip, +                        android:id="@+id/pager_tab_strip", +                        android:layout_width="match_parent", +                        android:layout_height="wrap_content", +                        android:layout_gravity="top" />, +, +            </android.support.v4.view.ViewPager>, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java, +    Button search = (Button) findViewById(R.id.search);, +    Resources res = getResources();, +    ViewPager pager = (ViewPager) findViewById(R.id.view_pager);, +    pager.setPageMargin(res.getDimensionPixelOffset(R.dimen.page_margin));, +, +    @Override, +    public CharSequence getPageTitle(int position) {, +      Page page = Page.values()[position];, +      int titleId = PAGE_TO_TITLE.get(page);, +      return getString(titleId);, +    }, +++ b/samples/flickr/src/main/res/layout/flickr_photo_grid.xml, +          android:layout_height="fill_parent", +          android:paddingTop="10dp" />, +++ b/samples/flickr/src/main/res/layout/flickr_search_activity.xml, +                android:layout_height="fill_parent">, +, +                <android.support.v4.view.PagerTabStrip, +                        android:id="@+id/pager_tab_strip", +                        android:layout_width="match_parent", +                        android:layout_height="wrap_content", +                        android:layout_gravity="top" />, +, +            </android.support.v4.view.ViewPager>, +++ b/samples/flickr/src/main/res/values/dimens.xml, +    <dimen name="page_margin">8dp</dimen>]
[+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +          GlideExecutor.newUnlimitedSourceExecutor());, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +          GlideExecutor.newUnlimitedSourceExecutor());, +++ b/library/src/main/java/com/bumptech/glide/module/ManifestParser.java, +      if (appInfo.metaData == null) {, +        return modules;, +      }]
[+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +      sourceExecutor = GlideExecutor.newSourceExecutor();, +      diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +      sourceExecutor = GlideExecutor.newSourceExecutor();, +      diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java, +import android.os.StrictMode;, +import android.os.StrictMode.ThreadPolicy;, +  /**, +   * The default thread name prefix for executors used to load/decode/transform data not found in, +   * cache., +   */, +  public static final String DEFAULT_SOURCE_EXECUTOR_NAME = "source";, +  /**, +   * The default thread name prefix for executors used to load/decode/transform data found in, +   * Glide's cache., +   */, +  public static final String DEFAULT_DISK_CACHE_EXECUTOR_NAME = "disk-cache";, +  /**, +   * The default thread count for executors used to load/decode/transform data found in Glide's, +   * cache., +   */, +  public static final int DEFAULT_DISK_CACHE_EXECUTOR_THREADS = 1;, +, +   * Returns a new fixed thread pool with the default thread count returned from, +   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_DISK_CACHE_EXECUTOR_NAME} thread name, +   * prefix, and the, +   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}, +   * uncaught throwable strategy., +   * <p>Disk cache executors do not allow network operations on their threads., +  public static GlideExecutor newDiskCacheExecutor() {, +    return newDiskCacheExecutor(DEFAULT_DISK_CACHE_EXECUTOR_THREADS,, +        DEFAULT_DISK_CACHE_EXECUTOR_NAME, UncaughtThrowableStrategy.DEFAULT);, +   * Returns a new fixed thread pool with the given thread count, thread name prefix,, +   * and {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}., +   * <p>Disk cache executors do not allow network operations on their threads., +   * @param threadCount The number of threads., +  public static GlideExecutor newDiskCacheExecutor(int threadCount, String name,, +    return new GlideExecutor(threadCount, name, uncaughtThrowableStrategy,, +        true /*preventNetworkOperations*/);, +  /**, +   * Returns a new fixed thread pool with the default thread count returned from, +   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_SOURCE_EXECUTOR_NAME} thread name, +   * prefix, and the, +   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}, +   * uncaught throwable strategy., +   *, +   * <p>Source executors allow network operations on their threads., +   */, +  public static GlideExecutor newSourceExecutor() {, +    return newSourceExecutor(calculateBestThreadCount(), DEFAULT_SOURCE_EXECUTOR_NAME,, +        UncaughtThrowableStrategy.DEFAULT);, +  }, +, +  /**, +   * Returns a new fixed thread pool with the given thread count, thread name prefix,, +   * and {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}., +   *, +   * <p>Source executors allow network operations on their threads., +   *, +   * @param threadCount The number of threads., +   * @param name The prefix for each thread name., +   * @param uncaughtThrowableStrategy The {@link, +   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to, +   *                                  handle uncaught exceptions., +   */, +  public static GlideExecutor newSourceExecutor(int threadCount, String name,, +      UncaughtThrowableStrategy uncaughtThrowableStrategy) {, +    return new GlideExecutor(threadCount, name, uncaughtThrowableStrategy,, +        false /*preventNetworkOperations*/);, +  }, +, +  private GlideExecutor(int poolSize, String name,, +      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations) {, +        poolSize /*corePoolSize*/,, +        poolSize /*maximumPoolSize*/,, +        new DefaultThreadFactory(name, uncaughtThrowableStrategy, preventNetworkOperations));, +    /** The default strategy, currently {@link #LOG}. */, +    public static final UncaughtThrowableStrategy DEFAULT = LOG;, +, +    private final boolean preventNetworkOperations;, +    DefaultThreadFactory(String name, UncaughtThrowableStrategy uncaughtThrowableStrategy,, +        boolean preventNetworkOperations) {, +      this.preventNetworkOperations = preventNetworkOperations;, +          if (preventNetworkOperations) {, +            StrictMode.setThreadPolicy(, +                new ThreadPolicy.Builder(), +                    .detectNetwork(), +                    .penaltyDeathOnNetwork(), +                    .build());, +          }, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +      sourceExecutor = GlideExecutor.newSourceExecutor();, +      diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java, +import android.os.StrictMode;, +import android.os.StrictMode.ThreadPolicy;, +  /**, +   * The default thread name prefix for executors used to load/decode/transform data not found in]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/ResourceTranscoder.java, +   * Transcodes the given resource to the new resource type and returns the new resource.]
[+++ b/samples/flickr/src/main/res/values/dimens.xml, +]
[+++ b/library/pom.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">, +  <modelVersion>4.0.0</modelVersion>, +  <groupId>com.bumptech</groupId>, +  <artifactId>glide</artifactId>, +  <version>3.3.0</version>, +  <packaging>apk</packaging>, +  <name>glide</name>, +, +  <dependencies>, +    <dependency>, +      <groupId>com.google.android</groupId>, +      <artifactId>android</artifactId>, +      <version> 4.1.1.4  </version>, +      <scope>provided</scope>, +    </dependency>, +    <dependency>, +      <groupId>com.mcxiaoke.volley</groupId>, +      <artifactId>library</artifactId>, +      <version>1.0.4</version>, +    </dependency>, +    <dependency>, +      <groupId>com.jakewharton</groupId>, +      <artifactId>disklrucache</artifactId>, +      <version>2.0.2</version>, +    </dependency>, +  </dependencies>, +, +  <build>, +    <plugins>, +      <plugin>, +        <groupId>com.jayway.maven.plugins.android.generation2</groupId>, +        <artifactId>android-maven-plugin</artifactId>, +        <version>3.9.0-rc.2</version>, +        <configuration>, +          <sdk>, +            <platform>19</platform>, +          </sdk>, +          <deleteConflictingFiles>true</deleteConflictingFiles>, +          <undeployBeforeDeploy>true</undeployBeforeDeploy>, +        </configuration>, +        <extensions>true</extensions>, +      </plugin>, +      <plugin>, +        <artifactId>maven-compiler-plugin</artifactId>, +        <version>3.1</version>, +        <configuration>, +            <source>1.6</source>, +            <target>1.6</target>, +        </configuration>, +      </plugin>, +    </plugins>, +  </build>, +</project>]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java]
[+++ b/instrumentation/src/androidTest/java/android/support/test/InstrumentationRegistry.java, +package android.support.test;, +, +import android.content.Context;, +, +// Workaround for https://github.com/mockito/mockito/issues/1472., +public final class InstrumentationRegistry {, +  public static Context getTargetContext() {, +    return androidx.test.InstrumentationRegistry.getTargetContext();, +  }, +}]
[+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java, +    Cursor cursor = null;, +      cursor = query.query(uri);, +    } catch (SecurityException e) {, +      if (Log.isLoggable(TAG, Log.DEBUG)) {, +        Log.d(TAG, "Failed to query for thumbnail for Uri: " + uri, e);, +      }, +      return null;, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java, +    Cursor cursor = null;, +      cursor = query.query(uri);, +    } catch (SecurityException e) {, +      if (Log.isLoggable(TAG, Log.DEBUG)) {, +        Log.d(TAG, "Failed to query for thumbnail for Uri: " + uri, e);, +      }, +      return null;, +++ b/library/test/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java, +import static com.google.common.truth.Truth.assertThat;, +import static org.mockito.Matchers.any;, +  public void open_returnsNull_whenQueryThrowsSecurityException() throws FileNotFoundException {, +    when(harness.query.query(any(Uri.class))).thenThrow(new SecurityException());, +    assertThat(harness.get().open(harness.uri)).isNull();, +  }, +, +  @Test, +    Harness() {]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java, +import com.bumptech.glide.request.FutureTarget;, +import com.bumptech.glide.test.WaitModelLoader;, +import com.bumptech.glide.test.WaitModelLoader.WaitModel;, +  @Test, +  public void clearRequest_withError_afterPrimaryFails_clearsErrorRequest(), +      throws InterruptedException {, +    WaitModel<Integer> errorModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);, +, +    FutureTarget<Drawable> target =, +        Glide.with(context), +            .load((Object) null), +            .error(, +                Glide.with(context), +                    .load(errorModel), +                    .listener(requestListener)), +            .submit();, +, +    Glide.with(context).clear(target);, +    errorModel.countDown();, +, +    // Make sure any pending requests run., +    concurrency.pokeMainThread();, +    Glide.tearDown();, +    // Make sure that any callbacks posted back to the main thread run., +    concurrency.pokeMainThread();, +  }, +, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java, +import com.bumptech.glide.request.FutureTarget;, +import com.bumptech.glide.test.WaitModelLoader;, +import com.bumptech.glide.test.WaitModelLoader.WaitModel;, +  @Test, +  public void clearRequest_withError_afterPrimaryFails_clearsErrorRequest(), +      throws InterruptedException {, +    WaitModel<Integer> errorModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);, +, +    FutureTarget<Drawable> target =, +        Glide.with(context), +            .load((Object) null), +            .error(, +                Glide.with(context), +                    .load(errorModel), +                    .listener(requestListener)), +            .submit();, +, +    Glide.with(context).clear(target);, +    errorModel.countDown();, +, +    // Make sure any pending requests run., +    concurrency.pokeMainThread();, +    Glide.tearDown();, +    // Make sure that any callbacks posted back to the main thread run., +    concurrency.pokeMainThread();, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java, +    // Don't check primary.isFailed() here because it will have been reset by the clear call, +    // immediately before this., +    if (error.isRunning()) {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java, +import com.bumptech.glide.request.FutureTarget;, +import com.bumptech.glide.test.WaitModelLoader;, +import com.bumptech.glide.test.WaitModelLoader.WaitModel;, +  @Test, +  public void clearRequest_withError_afterPrimaryFails_clearsErrorRequest(), +      throws InterruptedException {, +    WaitModel<Integer> errorModel = WaitModelLoader.Factory.waitOn(ResourceIds.raw.canonical);, +, +    FutureTarget<Drawable> target =, +        Glide.with(context), +            .load((Object) null), +            .error(, +                Glide.with(context), +                    .load(errorModel), +                    .listener(requestListener)), +            .submit();, +, +    Glide.with(context).clear(target);, +    errorModel.countDown();, +, +    // Make sure any pending requests run., +    concurrency.pokeMainThread();, +    Glide.tearDown();, +    // Make sure that any callbacks posted back to the main thread run., +    concurrency.pokeMainThread();, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java, +    // Don't check primary.isFailed() here because it will have been reset by the clear call, +    // immediately before this., +    if (error.isRunning()) {, +++ b/library/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java, +  public void clear_whenPrimaryHasFailed_errorIsRunning_clearsError() {, +    when(error.isRunning()).thenReturn(true);, +  public void clear_whenErrorIsRunning_clearsError() {, +    when(error.isRunning()).thenReturn(true);, +    coordinator.clear();, +, +    verify(error).clear();]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import static com.bumptech.glide.test.Matchers.anyDrawable;, +import static com.bumptech.glide.test.Matchers.anyTarget;, +            anyDrawable(),, +            anyDrawable(),, +            anyDrawable(),, +    verify(requestListener), +        .onResourceReady(, +            anyDrawable(),, +            any(),, +            anyTarget(),, +            eq(DataSource.MEMORY_CACHE),, +            anyBoolean());, +    verify(requestListener), +        .onResourceReady(, +            anyDrawable(),, +            any(),, +            anyTarget(),, +            eq(DataSource.DATA_DISK_CACHE),, +            anyBoolean());, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import static com.bumptech.glide.test.Matchers.anyDrawable;, +import static com.bumptech.glide.test.Matchers.anyTarget;, +            anyDrawable(),, +            anyDrawable(),, +            anyDrawable(),, +    verify(requestListener), +        .onResourceReady(, +            anyDrawable(),, +            any(),, +            anyTarget(),, +            eq(DataSource.MEMORY_CACHE),, +            anyBoolean());, +    verify(requestListener), +        .onResourceReady(, +            anyDrawable(),, +            any(),, +            anyTarget(),, +            eq(DataSource.DATA_DISK_CACHE),, +            anyBoolean());, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java, +package com.bumptech.glide;, +, +import static com.bumptech.glide.test.Matchers.anyDrawable;, +import static com.bumptech.glide.test.Matchers.anyTarget;, +import static com.google.common.truth.Truth.assertThat;, +import static org.mockito.ArgumentMatchers.any;, +import static org.mockito.ArgumentMatchers.anyBoolean;, +import static org.mockito.ArgumentMatchers.eq;, +import static org.mockito.Mockito.never;, +import static org.mockito.Mockito.verify;, +, +import android.content.Context;, +import android.graphics.drawable.Drawable;, +import android.support.test.InstrumentationRegistry;, +import android.support.test.runner.AndroidJUnit4;, +import android.widget.ImageView;, +import com.bumptech.glide.load.DataSource;, +import com.bumptech.glide.load.engine.executor.GlideExecutor;, +import com.bumptech.glide.request.RequestListener;, +import com.bumptech.glide.test.ConcurrencyHelper;, +import com.bumptech.glide.test.GlideApp;, +import com.bumptech.glide.test.ResourceIds;, +import com.bumptech.glide.test.TearDownGlide;, +import com.bumptech.glide.test.WaitModelLoader;, +import com.bumptech.glide.test.WaitModelLoader.WaitModel;, +import org.junit.Before;, +import org.junit.Rule;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +, +/**, + * Tests the behaviors of Requests of all types., + */, +@RunWith(AndroidJUnit4.class), +public class RequestTest {, +  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();, +  @Mock private RequestListener<Drawable> requestListener;, +  private ConcurrencyHelper concurrency = new ConcurrencyHelper();, +  private Context context;, +  private ImageView imageView;, +, +  @Before, +  public void setUp() {, +    MockitoAnnotations.initMocks(this);, +    context = InstrumentationRegistry.getTargetContext();, +    imageView = new ImageView(context);, +    imageView.measure(100, 100);, +    imageView.layout(0, 0, 100, 100);, +, +    // Some emulators only have a single resize thread, so waiting on a latch will block them, +    // forever., +    Glide.init(context,, +        new GlideBuilder().setResizeExecutor(GlideExecutor.newUnlimitedSourceExecutor()));, +  }, +, +  @Test, +  public void clear_withSingleRequest_nullsOutDrawableInView() {]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +   * Multiplies the initial size of the pool by the given multiplier to dynamically and, +   * synchronously allow users to adjust the size of the pool., +   * Adds the given {@link android.graphics.Bitmap} if it is eligible to be re-used and the pool, +   * can fit it, or calls {@link Bitmap#recycle()} on the Bitmap and discards it., +   * <p> Callers most <em>not</em> continue to use the Bitmap after calling this method. </p>, +  void put(Bitmap bitmap);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +   * Multiplies the initial size of the pool by the given multiplier to dynamically and, +   * synchronously allow users to adjust the size of the pool., +   * Adds the given {@link android.graphics.Bitmap} if it is eligible to be re-used and the pool, +   * can fit it, or calls {@link Bitmap#recycle()} on the Bitmap and discards it., +   * <p> Callers most <em>not</em> continue to use the Bitmap after calling this method. </p>, +  void put(Bitmap bitmap);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java, +  public void put(Bitmap bitmap) {, +    bitmap.recycle();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +   * Multiplies the initial size of the pool by the given multiplier to dynamically and, +   * synchronously allow users to adjust the size of the pool., +   * Adds the given {@link android.graphics.Bitmap} if it is eligible to be re-used and the pool, +   * can fit it, or calls {@link Bitmap#recycle()} on the Bitmap and discards it., +   * <p> Callers most <em>not</em> continue to use the Bitmap after calling this method. </p>, +  void put(Bitmap bitmap);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java, +  public void put(Bitmap bitmap) {, +    bitmap.recycle();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +  public synchronized void put(Bitmap bitmap) {, +      bitmap.recycle();, +      return;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +   * Multiplies the initial size of the pool by the given multiplier to dynamically and, +   * synchronously allow users to adjust the size of the pool., +   * Adds the given {@link android.graphics.Bitmap} if it is eligible to be re-used and the pool, +   * can fit it, or calls {@link Bitmap#recycle()} on the Bitmap and discards it., +   * <p> Callers most <em>not</em> continue to use the Bitmap after calling this method. </p>, +  void put(Bitmap bitmap);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java, +  public void put(Bitmap bitmap) {, +    bitmap.recycle();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +  public synchronized void put(Bitmap bitmap) {, +      bitmap.recycle();, +      return;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java, +    bitmapPool.put(bitmap);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +   * Multiplies the initial size of the pool by the given multiplier to dynamically and, +   * synchronously allow users to adjust the size of the pool., +   * Adds the given {@link android.graphics.Bitmap} if it is eligible to be re-used and the pool, +   * can fit it, or calls {@link Bitmap#recycle()} on the Bitmap and discards it., +   * <p> Callers most <em>not</em> continue to use the Bitmap after calling this method. </p>, +  void put(Bitmap bitmap);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java, +  public void put(Bitmap bitmap) {, +    bitmap.recycle();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +  public synchronized void put(Bitmap bitmap) {, +      bitmap.recycle();, +      return;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java, +    bitmapPool.put(bitmap);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java, +    if (toReuse != null && toReuse != transformed) {, +      pool.put(toReuse);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +   * Multiplies the initial size of the pool by the given multiplier to dynamically and, +   * synchronously allow users to adjust the size of the pool., +   * Adds the given {@link android.graphics.Bitmap} if it is eligible to be re-used and the pool, +   * can fit it, or calls {@link Bitmap#recycle()} on the Bitmap and discards it., +   * <p> Callers most <em>not</em> continue to use the Bitmap after calling this method. </p>, +  void put(Bitmap bitmap);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java, +  public void put(Bitmap bitmap) {, +    bitmap.recycle();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +  public synchronized void put(Bitmap bitmap) {, +      bitmap.recycle();, +      return;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java, +    bitmapPool.put(bitmap);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java, +    if (toReuse != null && toReuse != transformed) {, +      pool.put(toReuse);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CircleCrop.java, +    if (toReuse != null && toReuse != transformed) {, +      pool.put(toReuse);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +   * Multiplies the initial size of the pool by the given multiplier to dynamically and, +   * synchronously allow users to adjust the size of the pool., +   * Adds the given {@link android.graphics.Bitmap} if it is eligible to be re-used and the pool, +   * can fit it, or calls {@link Bitmap#recycle()} on the Bitmap and discards it., +   * <p> Callers most <em>not</em> continue to use the Bitmap after calling this method. </p>, +  void put(Bitmap bitmap);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java, +  public void put(Bitmap bitmap) {, +    bitmap.recycle();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +  public synchronized void put(Bitmap bitmap) {]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    requestOptions.lock();, +    Request request = buildRequest(target);, +    Request previous = target.getRequest();, +      if (request.isEquivalentTo(previous)) {, +        request.recycle();, +        return target;, +      }, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    requestOptions.lock();, +    Request request = buildRequest(target);, +    Request previous = target.getRequest();, +      if (request.isEquivalentTo(previous)) {, +        request.recycle();, +        return target;, +      }, +++ b/library/src/main/java/com/bumptech/glide/request/Request.java, +, +  /**, +   * Returns {@code true} if this {@link Request} is equivalent to the given {@link Request} (has, +   * all of the same options and sizes)., +   *, +   * <p>This method is identical to {@link #equals(Object)} except that it's specific to, +   * {@link Request} subclasses. We do not use {@link #equals(Object)} directly because we track, +   * {@link Request}s in collections like {@link java.util.Set} and it's perfectly legitimate to, +   * have two different {@link Request} objects for two different, +   * {@link com.bumptech.glide.request.target.Target}s (for example). Using a similar but different, +   * method let's us selectively compare {@link Request} objects to each other when it's useful in, +   * specific scenarios., +   */, +  boolean isEquivalentTo(Request other);, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    requestOptions.lock();, +    Request request = buildRequest(target);, +    Request previous = target.getRequest();, +      if (request.isEquivalentTo(previous)) {, +        request.recycle();, +        return target;, +      }, +++ b/library/src/main/java/com/bumptech/glide/request/Request.java, +, +  /**, +   * Returns {@code true} if this {@link Request} is equivalent to the given {@link Request} (has, +   * all of the same options and sizes)., +   *, +   * <p>This method is identical to {@link #equals(Object)} except that it's specific to, +   * {@link Request} subclasses. We do not use {@link #equals(Object)} directly because we track, +   * {@link Request}s in collections like {@link java.util.Set} and it's perfectly legitimate to, +   * have two different {@link Request} objects for two different, +   * {@link com.bumptech.glide.request.target.Target}s (for example). Using a similar but different, +   * method let's us selectively compare {@link Request} objects to each other when it's useful in, +   * specific scenarios., +   */, +  boolean isEquivalentTo(Request other);, +++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +, +  @Override, +  public boolean equals(Object o) {, +    if (o instanceof RequestOptions) {, +      RequestOptions other = (RequestOptions) o;, +      return Float.compare(other.sizeMultiplier, sizeMultiplier) == 0, +          && errorId == other.errorId, +          && Util.bothNullOrEqual(errorPlaceholder, other.errorPlaceholder), +          && placeholderId == other.placeholderId, +          && Util.bothNullOrEqual(placeholderDrawable, other.placeholderDrawable), +          && fallbackId == other.fallbackId, +          && Util.bothNullOrEqual(fallbackDrawable, other.fallbackDrawable), +          && isCacheable == other.isCacheable, +          && overrideHeight == other.overrideHeight, +          && overrideWidth == other.overrideWidth, +          && isTransformationRequired == other.isTransformationRequired, +          && isTransformationAllowed == other.isTransformationAllowed, +          && useUnlimitedSourceGeneratorsPool == other.useUnlimitedSourceGeneratorsPool, +          && onlyRetrieveFromCache == other.onlyRetrieveFromCache, +          && diskCacheStrategy.equals(other.diskCacheStrategy), +          && priority == other.priority, +          && options.equals(other.options), +          && transformations.equals(other.transformations), +          && resourceClass.equals(other.resourceClass), +          && Util.bothNullOrEqual(signature, other.signature), +          && Util.bothNullOrEqual(theme, other.theme);, +    }, +    return false;, +  }, +, +  @Override, +  public int hashCode() {, +    int hashCode = Util.hashCode(sizeMultiplier);, +    hashCode = Util.hashCode(errorId, hashCode);, +    hashCode = Util.hashCode(errorPlaceholder, hashCode);, +    hashCode = Util.hashCode(placeholderId, hashCode);, +    hashCode = Util.hashCode(placeholderDrawable, hashCode);, +    hashCode = Util.hashCode(fallbackId, hashCode);, +    hashCode = Util.hashCode(fallbackDrawable, hashCode);, +    hashCode = Util.hashCode(isCacheable, hashCode);, +    hashCode = Util.hashCode(overrideHeight, hashCode);, +    hashCode = Util.hashCode(overrideWidth, hashCode);, +    hashCode = Util.hashCode(isTransformationRequired, hashCode);, +    hashCode = Util.hashCode(isTransformationAllowed, hashCode);, +    hashCode = Util.hashCode(useUnlimitedSourceGeneratorsPool, hashCode);]
[+++ b/library/src/androidTest/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java, +import static org.mockito.Mockito.doAnswer;, +import org.mockito.invocation.InvocationOnMock;, +import org.mockito.stubbing.Answer;, +  public void testDoesNotStartFullIfClearedByThumb() {, +    doAnswer(new Answer<Void>() {, +      @Override, +      public Void answer(InvocationOnMock invocation) throws Throwable {, +        coordinator.clear();, +        return null;, +      }, +    }).when(thumb).begin();, +, +    coordinator.begin();, +, +    verify(full, never()).begin();, +  }, +, +  @Test, +++ b/library/src/androidTest/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java, +import static org.mockito.Mockito.doAnswer;, +import org.mockito.invocation.InvocationOnMock;, +import org.mockito.stubbing.Answer;, +  public void testDoesNotStartFullIfClearedByThumb() {, +    doAnswer(new Answer<Void>() {, +      @Override, +      public Void answer(InvocationOnMock invocation) throws Throwable {, +        coordinator.clear();, +        return null;, +      }, +    }).when(thumb).begin();, +, +    coordinator.begin();, +, +    verify(full, never()).begin();, +  }, +, +  @Test, +++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java, +  private boolean isRunning;, +    isRunning = true;, +    if (isRunning && !full.isRunning()) {, +    isRunning = false;, +    isRunning = false;]
[+++ b/integration/recyclerview/build.gradle, +apply plugin: 'com.android.library', +, +repositories {, +    mavenCentral(), +}, +, +dependencies {, +    compile project(':glide'), +    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}", +    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}", +}, +, +android {, +    compileSdkVersion COMPILE_SDK_VERSION as int, +    buildToolsVersion BUILD_TOOLS_VERSION as String, +, +    defaultConfig {, +        minSdkVersion MIN_SDK_VERSION as int, +        targetSdkVersion TARGET_SDK_VERSION as int, +, +        versionCode VERSION_CODE as int, +        versionName VERSION_NAME as String, +    }, +, +    compileOptions {, +        sourceCompatibility JavaVersion.VERSION_1_7, +        targetCompatibility JavaVersion.VERSION_1_7, +    }, +}, +, +apply from: "$rootProject.projectDir/scripts/upload.gradle", +++ b/integration/recyclerview/build.gradle, +apply plugin: 'com.android.library', +, +repositories {, +    mavenCentral(), +}, +, +dependencies {, +    compile project(':glide'), +    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}", +    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}", +}, +, +android {, +    compileSdkVersion COMPILE_SDK_VERSION as int, +    buildToolsVersion BUILD_TOOLS_VERSION as String, +, +    defaultConfig {, +        minSdkVersion MIN_SDK_VERSION as int, +        targetSdkVersion TARGET_SDK_VERSION as int, +, +        versionCode VERSION_CODE as int, +        versionName VERSION_NAME as String, +    }, +, +    compileOptions {, +        sourceCompatibility JavaVersion.VERSION_1_7, +        targetCompatibility JavaVersion.VERSION_1_7, +    }, +}, +, +apply from: "$rootProject.projectDir/scripts/upload.gradle", +++ b/integration/recyclerview/gradle.properties, +POM_NAME=Glide RecyclerView Integration, +POM_ARTIFACT_ID=recyclerview-integration, +POM_PACKAGING=aar, +, +VERSION_NAME=2.0.0-SNAPSHOT, +VERSION_MAJOR=2, +VERSION_MINOR=0, +VERSION_PATCH=0, +VERSION_CODE=8, +, +POM_DESCRIPTION=An integration library to display images in RecyclerView., +, +# Prefix and postfix for source and javadoc jars., +JAR_PREFIX=glide-, +JAR_POSTFIX=-integration, +++ b/integration/recyclerview/build.gradle, +apply plugin: 'com.android.library', +, +repositories {, +    mavenCentral(), +}, +, +dependencies {, +    compile project(':glide'), +    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}", +    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}", +}, +, +android {, +    compileSdkVersion COMPILE_SDK_VERSION as int, +    buildToolsVersion BUILD_TOOLS_VERSION as String, +, +    defaultConfig {, +        minSdkVersion MIN_SDK_VERSION as int, +        targetSdkVersion TARGET_SDK_VERSION as int]
[+++ b/library/AndroidManifest.xml, +          android:versionCode="3", +          android:versionName="2.0.1" >]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +            if (!result.mkdirs() && (!result.exists() || !result.isDirectory())) {, +                throw new IllegalStateException("Cannot create cache directory structure for " + result);, +            }, +        register(int.class, ParcelFileDescriptor.class, new FileDescriptorResourceLoader.Factory());, +        register(int.class, InputStream.class, new StreamResourceLoader.Factory());, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +            if (!result.mkdirs() && (!result.exists() || !result.isDirectory())) {, +                throw new IllegalStateException("Cannot create cache directory structure for " + result);, +            }, +        register(int.class, ParcelFileDescriptor.class, new FileDescriptorResourceLoader.Factory());, +        register(int.class, InputStream.class, new StreamResourceLoader.Factory());, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +            return new GenericTypeRequest(model);, +            private GenericTypeRequest(A model) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +            if (!result.mkdirs() && (!result.exists() || !result.isDirectory())) {, +                throw new IllegalStateException("Cannot create cache directory structure for " + result);, +            }, +        register(int.class, ParcelFileDescriptor.class, new FileDescriptorResourceLoader.Factory());, +        register(int.class, InputStream.class, new StreamResourceLoader.Factory());, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +            return new GenericTypeRequest(model);, +            private GenericTypeRequest(A model) {, +++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java, +, +                @SuppressWarnings("deprecation") final int width = display.getWidth(), height = display.getHeight();, +                cb.onSizeReady(width, height);]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +      if (sourceWidth >= 0 && sourceHeight >= 0, +          && fixBitmapToRequestedDimensions && isKitKatOrGreater) {, +      if (Log.isLoggable(TAG, Log.DEBUG)) {, +        Log.d(TAG, "Unable to determine dimensions for: " + imageType, +            + " with target [" + targetWidth + "x" + targetHeight + "]");, +      }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +      if (sourceWidth >= 0 && sourceHeight >= 0, +          && fixBitmapToRequestedDimensions && isKitKatOrGreater) {, +      if (Log.isLoggable(TAG, Log.DEBUG)) {, +        Log.d(TAG, "Unable to determine dimensions for: " + imageType, +            + " with target [" + targetWidth + "x" + targetHeight + "]");, +      }, +++ b/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java, +      return 0;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +      if (sourceWidth >= 0 && sourceHeight >= 0, +          && fixBitmapToRequestedDimensions && isKitKatOrGreater) {, +      if (Log.isLoggable(TAG, Log.DEBUG)) {, +        Log.d(TAG, "Unable to determine dimensions for: " + imageType, +            + " with target [" + targetWidth + "x" + targetHeight + "]");, +      }, +++ b/library/src/main/java/com/bumptech/glide/util/MarkEnforcingInputStream.java, +      return 0;, +++ b/library/src/test/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java, +    assertEquals(0, is.skip(1));]
[+++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;, +import com.bumptech.glide.resize.cache.DiskCache;, +import com.bumptech.glide.resize.cache.MemoryCache;, +import com.bumptech.glide.resize.load.MultiTransformation;, +import com.bumptech.glide.resize.request.BitmapRequestBuilder;, +import com.bumptech.glide.resize.request.Request;, +import com.bumptech.glide.resize.request.ThumbnailRequestCoordinator;, +import com.bumptech.glide.resize.target.ImageViewTarget;, +import com.bumptech.glide.resize.target.Target;, +import com.bumptech.glide.resize.target.ViewTarget;, +import java.util.List;, + * A singleton to present a simple static interface for building requests with {@link RequestBuilder} and maintaining, + * an {@link ImageManager} and it's {@link BitmapPool}, {@link DiskCache} and {@link MemoryCache}., +    /**, +     * Returns false if the {@link Glide} singleton has not yet been created and can therefore be setup using, +     * {@link #setup(GlideBuilder)}., +     *, +     * @see #setup(GlideBuilder), +     */, +    /**, +     * Creates the {@link Glide} singleton using the given builder. Can be used to set options like cache sizes and, +     * locations., +     *, +     * @see #isSetup(), +     *, +     * @param builder The builder., +     * @throws IllegalArgumentException if the Glide singleton has already been created., +     */, +        Request request = target.getRequest();, +        if (request!= null) {, +            request.clear();, +        private final List<Transformation> transformations = new ArrayList<Transformation>();, +         * Transform images using {@link Transformation#CENTER_CROP}., +            return transform(Transformation.CENTER_CROP);, +         * Transform images using {@link Transformation#FIT_CENTER}., +            return transform(Transformation.FIT_CENTER);, +, +         * Transform images with the given {@link Transformation}. Appends this transformation onto any existing, +         * @param transformation the transformation to apply., +                Transformation transformation) {, +            transformations.add(transformation);, +            final Transformation transformation = getFinalTransformation();, +                                    transformation)), +        private Transformation getFinalTransformation() {, +            switch (transformations.size()) {, +                    return Transformation.NONE;, +                    return transformations.get(0);, +                    return new MultiTransformation(transformations);, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.resize.bitmap_recycle.BitmapPool;, +import com.bumptech.glide.resize.cache.DiskCache;, +import com.bumptech.glide.resize.cache.MemoryCache;, +import com.bumptech.glide.resize.load.MultiTransformation;, +import com.bumptech.glide.resize.request.BitmapRequestBuilder;, +import com.bumptech.glide.resize.request.Request;, +import com.bumptech.glide.resize.request.ThumbnailRequestCoordinator;, +import com.bumptech.glide.resize.target.ImageViewTarget;, +import com.bumptech.glide.resize.target.Target;, +import com.bumptech.glide.resize.target.ViewTarget;, +import java.util.List;, + * A singleton to present a simple static interface for building requests with {@link RequestBuilder} and maintaining, + * an {@link ImageManager} and it's {@link BitmapPool}, {@link DiskCache} and {@link MemoryCache}., +    /**, +     * Returns false if the {@link Glide} singleton has not yet been created and can therefore be setup using, +     * {@link #setup(GlideBuilder)}., +     *, +     * @see #setup(GlideBuilder), +     */, +    /**, +     * Creates the {@link Glide} singleton using the given builder. Can be used to set options like cache sizes and, +     * locations., +     *, +     * @see #isSetup(), +     *, +     * @param builder The builder., +     * @throws IllegalArgumentException if the Glide singleton has already been created., +     */, +        Request request = target.getRequest();, +        if (request!= null) {, +            request.clear();, +        private final List<Transformation> transformations = new ArrayList<Transformation>();, +         * Transform images using {@link Transformation#CENTER_CROP}., +            return transform(Transformation.CENTER_CROP);, +         * Transform images using {@link Transformation#FIT_CENTER}., +            return transform(Transformation.FIT_CENTER);, +, +         * Transform images with the given {@link Transformation}. Appends this transformation onto any existing, +         * @param transformation the transformation to apply., +                Transformation transformation) {, +            transformations.add(transformation);, +            final Transformation transformation = getFinalTransformation();, +                                    transformation)), +        private Transformation getFinalTransformation() {, +            switch (transformations.size()) {, +                    return Transformation.NONE;, +                    return transformations.get(0);, +                    return new MultiTransformation(transformations);, +++ b/library/src/com/bumptech/glide/ListPreloader.java, +import com.bumptech.glide.resize.target.BaseTarget;]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +  public RequestOptions override(int width, int height) {, +  public RequestOptions override(int size) {]
[+++ b/library/build.gradle, +apply plugin: 'findbugs', +findbugs {, +    toolVersion = "2.0.3", +}, +, +afterEvaluate {, +    findbugsTestDebug {, +        enabled = false, +    }, +, +    task findbugs(type: FindBugs, dependsOn: assembleDebug) {, +, +        description 'Run findbugs', +        group 'verification', +, +        classes = fileTree('build/intermediates/classes/debug/'), +        source = fileTree('src/main/java'), +        classpath = files(project.configurations.compile.asPath), +, +        effort = 'max', +, +        excludeFilter = file("findbugs-exclude.xml"), +, +        reports {, +            xml.enabled = false, +            html.enabled = true, +        }, +    }, +    check.doLast {, +        tasks.getByName("findbugs").execute(), +    }, +}, +++ b/library/build.gradle, +apply plugin: 'findbugs', +findbugs {, +    toolVersion = "2.0.3", +}, +, +afterEvaluate {, +    findbugsTestDebug {, +        enabled = false, +    }, +, +    task findbugs(type: FindBugs, dependsOn: assembleDebug) {, +, +        description 'Run findbugs', +        group 'verification', +, +        classes = fileTree('build/intermediates/classes/debug/'), +        source = fileTree('src/main/java'), +        classpath = files(project.configurations.compile.asPath), +, +        effort = 'max', +, +        excludeFilter = file("findbugs-exclude.xml"), +, +        reports {, +            xml.enabled = false, +            html.enabled = true, +        }, +    }, +    check.doLast {, +        tasks.getByName("findbugs").execute(), +    }, +}, +++ b/library/findbugs-exclude.xml, +<FindBugsFilter>, +, +    <Match>, +        <Class name="~.*R\$.*"/>, +    </Match>, +    <Match>, +        <Class name="~.*Manifest\$.*"/>, +    </Match>, +, +    <!-- BytesResource is the wrapper that is given control of the data. -->, +    <Match>, +      <Class name="com.bumptech.glide.load.resource.bytes.BytesResource" />, +      <Method name="get" />, +      <Bug pattern="EI_EXPOSE_REP" />, +    </Match>, +, +    <!-- We would rather expose the internal bytes than box or copy them. -->, +    <Match>, +      <Class name="com.bumptech.glide.load.resource.bytes.BytesResource" />, +      <Bug pattern="EI_EXPOSE_REP2" />, +    </Match>, +, +    <!-- Byte array fetcher just wraps a byte array to return an InputStream, data is not mutated. -->, +    <Match>, +      <Class name="com.bumptech.glide.load.data.ByteArrayFetcher" />, +      <Bug pattern="EI_EXPOSE_REP2" />, +    </Match>, +, +    <!-- RecyclableBufferedInputStream safely re-uses pooled byte arrays -->, +    <Match>, +      <Class name="com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream" />, +      <Bug pattern="EI_EXPOSE_REP2" />, +    </Match>]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/CacheLoader.java, +package com.bumptech.glide.load;, +, +import android.util.Log;, +import com.bumptech.glide.load.engine.Resource;, +import com.bumptech.glide.load.engine.cache.DiskCache;, +, +import java.io.IOException;, +import java.io.InputStream;, +, +public class CacheLoader {, +    private static final String TAG = "CacheLoader";, +    private DiskCache diskCache;, +, +    public CacheLoader(DiskCache diskCache) {, +        this.diskCache = diskCache;, +    }, +, +    public <Z> Resource<Z> load(Key key, ResourceDecoder<InputStream, Z> decoder, int width, int height) {, +        Resource<Z> result = null;, +        InputStream fromCache = diskCache.get(key);, +        if (fromCache != null) {, +            try {, +                result = decoder.decode(fromCache, width, height);, +            } catch (IOException e) {, +                if (Log.isLoggable(TAG, Log.DEBUG)) {, +                    Log.d(TAG, "Exception decoding image from cache", e);, +                }, +            }, +            if (result == null) {, +                if (Log.isLoggable(TAG, Log.DEBUG)) {, +                    Log.d(TAG, "Failed to decode image from cache or not present in cache");, +                }, +                diskCache.delete(key);, +            }, +        }, +        return result;, +    }, +}, +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/CacheLoader.java, +package com.bumptech.glide.load;, +, +import android.util.Log;, +import com.bumptech.glide.load.engine.Resource;, +import com.bumptech.glide.load.engine.cache.DiskCache;, +, +import java.io.IOException;, +import java.io.InputStream;, +, +public class CacheLoader {, +    private static final String TAG = "CacheLoader";, +    private DiskCache diskCache;, +, +    public CacheLoader(DiskCache diskCache) {, +        this.diskCache = diskCache;, +    }, +, +    public <Z> Resource<Z> load(Key key, ResourceDecoder<InputStream, Z> decoder, int width, int height) {, +        Resource<Z> result = null;, +        InputStream fromCache = diskCache.get(key);, +        if (fromCache != null) {, +            try {, +                result = decoder.decode(fromCache, width, height);, +            } catch (IOException e) {, +                if (Log.isLoggable(TAG, Log.DEBUG)) {, +                    Log.d(TAG, "Exception decoding image from cache", e);, +                }, +            }, +            if (result == null) {, +                if (Log.isLoggable(TAG, Log.DEBUG)) {, +                    Log.d(TAG, "Failed to decode image from cache or not present in cache");, +                }, +                diskCache.delete(key);, +            }, +        }, +        return result;, +    }, +}, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DefaultResourceRunnerFactory.java, +import com.bumptech.glide.load.CacheLoader;, +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/CacheLoader.java, +package com.bumptech.glide.load;, +, +import android.util.Log;, +import com.bumptech.glide.load.engine.Resource;, +import com.bumptech.glide.load.engine.cache.DiskCache;, +, +import java.io.IOException;, +import java.io.InputStream;, +, +public class CacheLoader {]
[+++ b/library/robolectric/src/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.resource.ResourceFetcher;, +import com.bumptech.glide.load.model.GlideUrl;, +import com.bumptech.glide.load.model.GenericLoaderFactory;, +import com.bumptech.glide.load.model.ModelLoader;, +import com.bumptech.glide.load.model.ModelLoaderFactory;, +import com.bumptech.glide.load.model.stream.StreamModelLoader;, +import com.bumptech.glide.load.engine.EngineBuilder;, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import com.bumptech.glide.load.engine.cache.DiskCache;, +import com.bumptech.glide.load.engine.cache.MemoryCache;, +import com.bumptech.glide.request.Request;, +import com.bumptech.glide.request.target.Target;, +++ b/library/robolectric/src/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.resource.ResourceFetcher;, +import com.bumptech.glide.load.model.GlideUrl;, +import com.bumptech.glide.load.model.GenericLoaderFactory;, +import com.bumptech.glide.load.model.ModelLoader;, +import com.bumptech.glide.load.model.ModelLoaderFactory;, +import com.bumptech.glide.load.model.stream.StreamModelLoader;, +import com.bumptech.glide.load.engine.EngineBuilder;, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import com.bumptech.glide.load.engine.cache.DiskCache;, +import com.bumptech.glide.load.engine.cache.MemoryCache;, +import com.bumptech.glide.request.Request;, +import com.bumptech.glide.request.target.Target;, +++ b/library/robolectric/src/com/bumptech/glide/MetadataTest.java, +package com.bumptech.glide;, +, +import com.bumptech.glide.Metadata;, +import com.bumptech.glide.Priority;, +import com.bumptech.glide.load.DecodeFormat;, +import org.junit.Test;, +, +import static org.junit.Assert.assertEquals;, +, +public class MetadataTest {, +, +    @Test(expected = NullPointerException.class), +    public void testNullPriorityThrows() {, +        new Metadata(null, DecodeFormat.ALWAYS_ARGB_8888);, +    }, +, +    @Test(expected = NullPointerException.class), +    public void testNullDecodeFormatThrows() {, +        new Metadata(Priority.IMMEDIATE, null);, +    }, +, +    @Test, +    public void testCanGetPriority() {, +        assertEquals(Priority.IMMEDIATE, new Metadata(Priority.IMMEDIATE, DecodeFormat.ALWAYS_ARGB_8888).getPriority());, +    }, +, +    @Test, +    public void testCanGetDecodeFormat() {, +        assertEquals(DecodeFormat.ALWAYS_ARGB_8888,, +                new Metadata(Priority.LOW, DecodeFormat.ALWAYS_ARGB_8888).getDecodeFormat());, +    }, +, +    @Test, +    public void testMetadataWithSameArgsAreEqual() {, +        assertEquals(new Metadata(Priority.LOW, DecodeFormat.PREFER_RGB_565),, +                new Metadata(Priority.LOW, DecodeFormat.PREFER_RGB_565));, +    }, +, +}, +++ b/library/robolectric/src/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.resource.ResourceFetcher;, +import com.bumptech.glide.load.model.GlideUrl;, +import com.bumptech.glide.load.model.GenericLoaderFactory;, +import com.bumptech.glide.load.model.ModelLoader;, +import com.bumptech.glide.load.model.ModelLoaderFactory;, +import com.bumptech.glide.load.model.stream.StreamModelLoader;, +import com.bumptech.glide.load.engine.EngineBuilder;, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import com.bumptech.glide.load.engine.cache.DiskCache;, +import com.bumptech.glide.load.engine.cache.MemoryCache;, +import com.bumptech.glide.request.Request;, +import com.bumptech.glide.request.target.Target;, +++ b/library/robolectric/src/com/bumptech/glide/MetadataTest.java, +package com.bumptech.glide;, +, +import com.bumptech.glide.Metadata;, +import com.bumptech.glide.Priority;, +import com.bumptech.glide.load.DecodeFormat;, +import org.junit.Test;, +, +import static org.junit.Assert.assertEquals;, +, +public class MetadataTest {, +, +    @Test(expected = NullPointerException.class), +    public void testNullPriorityThrows() {, +        new Metadata(null, DecodeFormat.ALWAYS_ARGB_8888);, +    }, +, +    @Test(expected = NullPointerException.class), +    public void testNullDecodeFormatThrows() {, +        new Metadata(Priority.IMMEDIATE, null);, +    }]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.os.Build;, +import com.bumptech.glide.load.resource.bitmap.ExifInterfaceImageHeaderParser;, +    // Right now we're only using this parser for HEIF images, which are only supported on OMR1+., +    // If we need this for other file types, we should consider removing this restriction., +    // Note that order here matters. We want to check the ExifInterface parser first for orientation, +    // and then fall back to DefaultImageHeaderParser for other fields., +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O_MR1) {, +      registry.register(new ExifInterfaceImageHeaderParser());, +    }, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.os.Build;, +import com.bumptech.glide.load.resource.bitmap.ExifInterfaceImageHeaderParser;, +    // Right now we're only using this parser for HEIF images, which are only supported on OMR1+., +    // If we need this for other file types, we should consider removing this restriction., +    // Note that order here matters. We want to check the ExifInterface parser first for orientation, +    // and then fall back to DefaultImageHeaderParser for other fields., +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O_MR1) {, +      registry.register(new ExifInterfaceImageHeaderParser());, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ExifInterfaceImageHeaderParser.java, +package com.bumptech.glide.load.resource.bitmap;, +, +import android.media.ExifInterface;, +import android.support.annotation.NonNull;, +import com.bumptech.glide.load.ImageHeaderParser;, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +import com.bumptech.glide.util.ByteBufferUtil;, +import java.io.IOException;, +import java.io.InputStream;, +import java.nio.ByteBuffer;, +, +/**, + * Uses {@link ExifInterface} to parse orientation data., + *, + * <p>ExifInterface supports the HEIF format on OMR1+. Glide's {@link DefaultImageHeaderParser}, + * doesn't currently support HEIF. In the future we should reconcile these two classes, but for, + * now this is a simple way to ensure that HEIF files are oriented correctly on platforms where, + * they're supported., + */, +public final class ExifInterfaceImageHeaderParser implements ImageHeaderParser {, +, +  @NonNull, +  @Override, +  public ImageType getType(@NonNull InputStream is) throws IOException {, +    return ImageType.UNKNOWN;, +  }, +, +  @NonNull, +  @Override, +  public ImageType getType(@NonNull ByteBuffer byteBuffer) throws IOException {, +    return ImageType.UNKNOWN;, +  }, +, +  @Override, +  public int getOrientation(@NonNull InputStream is, @NonNull ArrayPool byteArrayPool), +      throws IOException {, +    ExifInterface exifInterface = new ExifInterface(is);, +    int result = exifInterface.getAttributeInt(, +            ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);, +    if (result == ExifInterface.ORIENTATION_UNDEFINED) {, +      return ImageHeaderParser.UNKNOWN_ORIENTATION;, +    }, +    return result;, +  }, +, +  @Override, +  public int getOrientation(@NonNull ByteBuffer byteBuffer, @NonNull ArrayPool byteArrayPool), +      throws IOException {, +    return getOrientation(ByteBufferUtil.toStream(byteBuffer), byteArrayPool);, +  }, +}]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +    validateAnnotatedNonNull(executableElement);, +    validateNewGlideTypeAnnotations(executableElement);, +  private void validateNewGlideTypeAnnotations(ExecutableElement executableElement) {, +    validateAnnotatedNonNull(executableElement);, +  }, +, +  private void validateAnnotatedNonNull(ExecutableElement executableElement) {, +    Set<String> annotationNames =, +        FluentIterable.from(executableElement.getAnnotationMirrors()), +            .transform(new Function<AnnotationMirror, String>() {, +              @Override, +              public String apply(AnnotationMirror input) {, +                return input.getAnnotationType().asElement().toString();, +              }, +            }), +            .toSet();, +    if (!annotationNames.contains("android.support.annotation.NonNull")) {, +      processingEnvironment.getMessager().printMessage(, +          Kind.WARNING,, +          executableElement.getEnclosingElement() + "#" + executableElement.getSimpleName(), +              + " is missing the @NonNull annotation,", +              + " please add it to ensure that your extension methods are always returning non-null", +              + " values");, +    }, +  }, +, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +    validateAnnotatedNonNull(executableElement);, +    validateNewGlideTypeAnnotations(executableElement);, +  private void validateNewGlideTypeAnnotations(ExecutableElement executableElement) {, +    validateAnnotatedNonNull(executableElement);, +  }, +, +  private void validateAnnotatedNonNull(ExecutableElement executableElement) {, +    Set<String> annotationNames =, +        FluentIterable.from(executableElement.getAnnotationMirrors()), +            .transform(new Function<AnnotationMirror, String>() {, +              @Override, +              public String apply(AnnotationMirror input) {, +                return input.getAnnotationType().asElement().toString();, +              }, +            }), +            .toSet();, +    if (!annotationNames.contains("android.support.annotation.NonNull")) {, +      processingEnvironment.getMessager().printMessage(, +          Kind.WARNING,, +          executableElement.getEnclosingElement() + "#" + executableElement.getSimpleName(), +              + " is missing the @NonNull annotation,", +              + " please add it to ensure that your extension methods are always returning non-null", +              + " values");, +    }, +  }, +, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java, +  private static final ClassName NON_NULL_CLASS_NAME =, +      ClassName.get("android.support.annotation", "NonNull");, +        .addAnnotation(AnnotationSpec.builder(NON_NULL_CLASS_NAME).build()), +        .addAnnotation(AnnotationSpec.builder(NON_NULL_CLASS_NAME).build()), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +    validateAnnotatedNonNull(executableElement);, +    validateNewGlideTypeAnnotations(executableElement);, +  private void validateNewGlideTypeAnnotations(ExecutableElement executableElement) {, +    validateAnnotatedNonNull(executableElement);, +  }, +, +  private void validateAnnotatedNonNull(ExecutableElement executableElement) {, +    Set<String> annotationNames =, +        FluentIterable.from(executableElement.getAnnotationMirrors()), +            .transform(new Function<AnnotationMirror, String>() {, +              @Override, +              public String apply(AnnotationMirror input) {, +                return input.getAnnotationType().asElement().toString();, +              }, +            }), +            .toSet();, +    if (!annotationNames.contains("android.support.annotation.NonNull")) {, +      processingEnvironment.getMessager().printMessage(, +          Kind.WARNING,, +          executableElement.getEnclosingElement() + "#" + executableElement.getSimpleName(), +              + " is missing the @NonNull annotation,", +              + " please add it to ensure that your extension methods are always returning non-null", +              + " values");, +    }, +  }, +, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java, +  private static final ClassName NON_NULL_CLASS_NAME =, +      ClassName.get("android.support.annotation", "NonNull");, +        .addAnnotation(AnnotationSpec.builder(NON_NULL_CLASS_NAME).build()), +        .addAnnotation(AnnotationSpec.builder(NON_NULL_CLASS_NAME).build()), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/InvalidGlideTypeExtensionTest.java, +                    "import android.support.annotation.NonNull;",, +                    "  @NonNull",, +, +  @Test, +  public void compilation_withAnnotatedStaticMethod_returningRequestBuilder_missingNonNull_warns() {, +    Compilation compilation =, +        javac(), +            .withProcessors(new GlideAnnotationProcessor())]
[+++ b/samples/flickr/res/layout/main.xml, +<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android", +  android:layout_width="fill_parent", +  android:layout_height="fill_parent">, +  <LinearLayout, +    <LinearLayout, +      android:layout_margin="10dp", +      android:orientation="horizontal">, +      <EditText, +        android:id="@+id/search_text", +        android:layout_width="0dp", +        android:layout_height="wrap_content", +        android:layout_marginRight="10dp", +        android:layout_weight="1", +        android:cursorVisible="true", +        android:textCursorDrawable="@null", +        android:textSize="16sp", +        android:singleLine="true", +        android:inputType="text", +        android:imeOptions="actionSearch" />, +        <!-- android:background="@drawable/stretch_field_comments" /> -->, +      <Button, +        android:id="@+id/search", +        android:layout_width="wrap_content", +        android:minWidth="50dp", +        android:layout_height="40dp", +        android:text="@string/search" />, +    </LinearLayout>, +      android:layout_marginLeft="10dp", +      android:layout_marginRight="10dp", +  <LinearLayout, +    android:id="@+id/searching", +    android:layout_width="wrap_content", +    android:layout_height="wrap_content", +    android:visibility="invisible", +    android:layout_gravity="center", +    android:gravity="center", +    android:orientation="vertical">, +    <TextView, +      android:id="@+id/search_term", +      android:layout_width="wrap_content", +      android:layout_height="wrap_content", +      android:gravity="center", +      android:textSize="16sp", +      android:layout_marginBottom="10dp"/>, +    <ProgressBar, +      android:layout_width="wrap_content", +      android:layout_height="wrap_content", +      android:indeterminate="true" />, +    </LinearLayout>, +, +</FrameLayout>, +++ b/samples/flickr/res/layout/main.xml, +<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android", +  android:layout_width="fill_parent", +  android:layout_height="fill_parent">, +  <LinearLayout, +    <LinearLayout, +      android:layout_margin="10dp", +      android:orientation="horizontal">, +      <EditText, +        android:id="@+id/search_text", +        android:layout_width="0dp", +        android:layout_height="wrap_content", +        android:layout_marginRight="10dp", +        android:layout_weight="1", +        android:cursorVisible="true", +        android:textCursorDrawable="@null", +        android:textSize="16sp", +        android:singleLine="true", +        android:inputType="text", +        android:imeOptions="actionSearch" />, +        <!-- android:background="@drawable/stretch_field_comments" /> -->, +      <Button, +        android:id="@+id/search", +        android:layout_width="wrap_content", +        android:minWidth="50dp", +        android:layout_height="40dp", +        android:text="@string/search" />, +    </LinearLayout>, +      android:layout_marginLeft="10dp", +      android:layout_marginRight="10dp", +  <LinearLayout, +    android:id="@+id/searching", +    android:layout_width="wrap_content", +    android:layout_height="wrap_content", +    android:visibility="invisible", +    android:layout_gravity="center", +    android:gravity="center", +    android:orientation="vertical">, +    <TextView, +      android:id="@+id/search_term", +      android:layout_width="wrap_content", +      android:layout_height="wrap_content", +      android:gravity="center", +      android:textSize="16sp", +      android:layout_marginBottom="10dp"/>, +    <ProgressBar, +      android:layout_width="wrap_content", +      android:layout_height="wrap_content"]
[+++ b/build.gradle, +        // Imgur uses generated code from dagger that has warnings., +        if ("gifencoder" != project.getName() && "imgur" != project.getName()) {, +++ b/build.gradle, +        // Imgur uses generated code from dagger that has warnings., +        if ("gifencoder" != project.getName() && "imgur" != project.getName()) {, +++ b/gradle.properties, +VOLLEY_VERSION=1.1.0, +ANDROID_GRADLE_VERSION=3.2.1, +DAGGER_VERSION=2.15, +ROBOLECTRIC_VERSION=4.1, +COMPILE_SDK_VERSION=28, +++ b/build.gradle, +        // Imgur uses generated code from dagger that has warnings., +        if ("gifencoder" != project.getName() && "imgur" != project.getName()) {, +++ b/gradle.properties, +VOLLEY_VERSION=1.1.0, +ANDROID_GRADLE_VERSION=3.2.1, +DAGGER_VERSION=2.15, +ROBOLECTRIC_VERSION=4.1, +COMPILE_SDK_VERSION=28, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.request.BaseRequestOptions;, +   * RequestBuilder#apply(BaseRequestOptions)} will override defaults, +++ b/build.gradle, +        // Imgur uses generated code from dagger that has warnings., +        if ("gifencoder" != project.getName() && "imgur" != project.getName()) {, +++ b/gradle.properties, +VOLLEY_VERSION=1.1.0, +ANDROID_GRADLE_VERSION=3.2.1, +DAGGER_VERSION=2.15, +ROBOLECTRIC_VERSION=4.1, +COMPILE_SDK_VERSION=28, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.request.BaseRequestOptions;, +   * RequestBuilder#apply(BaseRequestOptions)} will override defaults, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +  @SuppressLint("CheckResult"), +    // This is safe because it will always mutate, no one else has access to the object., +++ b/build.gradle, +        // Imgur uses generated code from dagger that has warnings., +        if ("gifencoder" != project.getName() && "imgur" != project.getName()) {, +++ b/gradle.properties, +VOLLEY_VERSION=1.1.0, +ANDROID_GRADLE_VERSION=3.2.1, +DAGGER_VERSION=2.15, +ROBOLECTRIC_VERSION=4.1, +COMPILE_SDK_VERSION=28, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.request.BaseRequestOptions;, +   * RequestBuilder#apply(BaseRequestOptions)} will override defaults, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +  @SuppressLint("CheckResult"), +    // This is safe because it will always mutate, no one else has access to the object., +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +   * @see RequestBuilder#apply(com.bumptech.glide.request.BaseRequestOptions), +++ b/build.gradle, +        // Imgur uses generated code from dagger that has warnings., +        if ("gifencoder" != project.getName() && "imgur" != project.getName()) {, +++ b/gradle.properties, +VOLLEY_VERSION=1.1.0, +ANDROID_GRADLE_VERSION=3.2.1, +DAGGER_VERSION=2.15, +ROBOLECTRIC_VERSION=4.1, +COMPILE_SDK_VERSION=28, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.request.BaseRequestOptions;, +   * RequestBuilder#apply(BaseRequestOptions)} will override defaults, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +  @SuppressLint("CheckResult"), +    // This is safe because it will always mutate, no one else has access to the object., +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +   * @see RequestBuilder#apply(com.bumptech.glide.request.BaseRequestOptions), +++ b/library/src/main/java/com/bumptech/glide/request/target/CustomTarget.java, +   * Creates a new {@code CustomTarget} that will return the given {@code width} and {@code length}, +++ b/build.gradle, +        // Imgur uses generated code from dagger that has warnings., +        if ("gifencoder" != project.getName() && "imgur" != project.getName()) {, +++ b/gradle.properties, +VOLLEY_VERSION=1.1.0, +ANDROID_GRADLE_VERSION=3.2.1, +DAGGER_VERSION=2.15, +ROBOLECTRIC_VERSION=4.1, +COMPILE_SDK_VERSION=28, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.request.BaseRequestOptions;, +   * RequestBuilder#apply(BaseRequestOptions)} will override defaults, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +  @SuppressLint("CheckResult"), +    // This is safe because it will always mutate, no one else has access to the object., +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +   * @see RequestBuilder#apply(com.bumptech.glide.request.BaseRequestOptions), +++ b/library/src/main/java/com/bumptech/glide/request/target/CustomTarget.java, +   * Creates a new {@code CustomTarget} that will return the given {@code width} and {@code length}, +++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +@Config(manifest = Config.NONE, sdk = 28), +++ b/build.gradle, +        // Imgur uses generated code from dagger that has warnings., +        if ("gifencoder" != project.getName() && "imgur" != project.getName()) {, +++ b/gradle.properties]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        .append(Uri.class, Uri.class, new UnitModelLoader.Factory<Uri>()), +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        .append(Uri.class, Uri.class, new UnitModelLoader.Factory<Uri>()), +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java, +   * @see #getDrawable(Context, int, Theme), +   */, +  public static Drawable getDrawable(Context context, @DrawableRes int id) {, +    return getDrawable(context, id, /*theme=*/ null);, +  }, +, +  /**, +   *, +   * @param theme Used instead of the {@link Theme} returned from the given {@link Context} if, +   * non-null when loading the {@link Drawable}., +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        .append(Uri.class, Uri.class, new UnitModelLoader.Factory<Uri>()), +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java, +   * @see #getDrawable(Context, int, Theme), +   */, +  public static Drawable getDrawable(Context context, @DrawableRes int id) {, +    return getDrawable(context, id, /*theme=*/ null);, +  }, +, +  /**, +   *, +   * @param theme Used instead of the {@link Theme} returned from the given {@link Context} if, +   * non-null when loading the {@link Drawable}., +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java, +import android.content.pm.PackageManager.NameNotFoundException;, +import android.support.annotation.DrawableRes;, +import android.support.annotation.NonNull;, + * Decodes {@link Drawable}s given resource {@link Uri}s., + *, + * <p>This is typically used as a fallback for resource types that either aren't Bitmaps (see #350), + * or for resource types that we can't obtain an {@link java.io.InputStream} for using a standard, + * {@link ContentResolver}, including some types of application icons and resources loaded from, + * other packages., +  // android.resource://<package_name>/<type>/<name>., +  private static final int NAME_URI_PATH_SEGMENTS = 2;, +  // android.resource://<package_name>/<resource_id>, +  private static final int ID_PATH_SEGMENTS = 1;, +  private static final int RESOURCE_ID_SEGMENT_INDEX = 0;, +    @DrawableRes int resId = loadResourceIdFromUri(source);, +    String packageName = source.getAuthority();, +    Context toUse = packageName.equals(context.getPackageName()), +        ? context : getContextForPackage(source, packageName);, +    // We can't get a theme from another application., +    Drawable drawable = DrawableDecoderCompat.getDrawable(toUse, resId);, +    return new InternalDrawableResource(drawable);, +, +  @NonNull, +  private Context getContextForPackage(Uri source, String packageName) {, +    try {, +      return context.createPackageContext(packageName, /*flags=*/ 0);, +    } catch (NameNotFoundException e) {, +      throw new IllegalArgumentException(, +          "Failed to obtain context or unrecognized Uri format for: " + source, e);, +    }, +  }, +, +  @DrawableRes, +  private int loadResourceIdFromUri(Uri source) {, +    List<String> segments = source.getPathSegments();, +    @DrawableRes Integer result = null;, +    if (segments.size() == NAME_URI_PATH_SEGMENTS) {, +       result = context.getResources().getIdentifier(resourceName, typeName, packageName);, +    } else if (segments.size() == ID_PATH_SEGMENTS) {, +       try {, +         result = Integer.valueOf(segments.get(RESOURCE_ID_SEGMENT_INDEX));, +       } catch (NumberFormatException e) {, +         // Ignored., +     }, +, +     if (result == null) {, +       throw new IllegalArgumentException("Unrecognized Uri format: " + source);, +     } else if (result == 0) {, +       throw new IllegalArgumentException("Failed to obtain resource id for: " + source);, +     }, +     return result;, +  }, +, +  private static final class InternalDrawableResource extends DrawableResource<Drawable> {, +, +    InternalDrawableResource(Drawable drawable) {, +      super(drawable);, +    }, +, +      // 4 bytes per pixel for ARGB_8888 Bitmaps is something of a reasonable approximation. If, +      // there are no intrinsic bounds, we can fall back just to 1., +      return Math.max(1, drawable.getIntrinsicWidth() * drawable.getIntrinsicHeight() * 4);]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +          initGlide(context);, +  private static void initGlide(Context context) {, +    glide = builder.createGlide(applicationContext);]
[+++ b/.travis.yml, +script: 'travis_retry ./gradlew build', +before_cache:, +  - rm -f $HOME/.gradle/caches/modules-2/modules-2.lock, +    - $HOME/.gradle/caches/, +    - $HOME/.gradle/wrapper/, +++ b/.travis.yml, +script: 'travis_retry ./gradlew build', +before_cache:, +  - rm -f $HOME/.gradle/caches/modules-2/modules-2.lock, +    - $HOME/.gradle/caches/, +    - $HOME/.gradle/wrapper/, +++ b/gradle.properties]
[+++ b/build.gradle, +        maxViolations = 0, +        diffMaxViolations = 0, +++ b/build.gradle, +        maxViolations = 0, +        diffMaxViolations = 0, +++ b/gradle.properties, +VIOLATIONS_PLUGIN_VERSION=1.8]
[+++ b/library/src/main/java/com/bumptech/glide/load/data/BufferedOutputStream.java, +package com.bumptech.glide.load.data;, +, +import android.support.annotation.NonNull;, +import android.support.annotation.VisibleForTesting;, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +import java.io.IOException;, +import java.io.OutputStream;, +, +/**, + * An {@link OutputStream} implementation that recycles and re-uses {@code byte[]}s using the, + * provided {@link ArrayPool}., + */, +public final class BufferedOutputStream extends OutputStream {, +  @NonNull, +  private final OutputStream out;, +  private byte[] buffer;, +  private ArrayPool arrayPool;, +  private int index;, +, +  public BufferedOutputStream(@NonNull OutputStream out, @NonNull ArrayPool arrayPool) {, +    this(out, arrayPool, ArrayPool.STANDARD_BUFFER_SIZE_BYTES);, +  }, +, +  @VisibleForTesting, +  BufferedOutputStream(@NonNull OutputStream out, ArrayPool arrayPool, int bufferSize) {, +    this.out = out;, +    this.arrayPool = arrayPool;, +    buffer = arrayPool.get(bufferSize, byte[].class);, +  }, +, +  @Override, +  public void write(int b) throws IOException {, +    buffer[index++] = (byte) b;, +    maybeFlushBuffer();, +  }, +, +  @Override, +  public void write(@NonNull byte[] b) throws IOException {, +    write(b, 0, b.length);, +  }, +, +  @Override, +  public void write(@NonNull byte[] b, int initialOffset, int length) throws IOException {, +    int writtenSoFar = 0;, +    do {, +      int remainingToWrite = length - writtenSoFar;, +      int currentOffset = initialOffset + writtenSoFar;, +      // If we still need to write at least the buffer size worth of bytes, we might as well do so, +      // directly and avoid the overhead of copying to the buffer first., +      if (index == 0 && remainingToWrite >= buffer.length) {, +        out.write(b, currentOffset, remainingToWrite);, +        return;, +      }, +, +      int remainingSpaceInBuffer = buffer.length - index;, +      int totalBytesToWriteToBuffer = Math.min(remainingToWrite, remainingSpaceInBuffer);, +, +      System.arraycopy(b, currentOffset, buffer, index, totalBytesToWriteToBuffer);, +, +      index += totalBytesToWriteToBuffer;, +      writtenSoFar += totalBytesToWriteToBuffer;, +, +      maybeFlushBuffer();, +    } while (writtenSoFar < length);, +  }, +, +  @Override, +  public void flush() throws IOException {, +    flushBuffer();, +    out.flush();, +  }, +, +  private void flushBuffer() throws IOException {, +    if (index > 0) {, +      out.write(buffer, 0, index);, +      index = 0;, +    }, +  }, +, +  private void maybeFlushBuffer() throws IOException {, +    if (index == buffer.length) {, +      flushBuffer();, +    }, +  }, +, +  @Override, +  public void close() throws IOException {, +    try {, +      flush();, +    } finally {, +      out.close();, +    }, +    release();, +  }, +, +  private void release() {, +    if (buffer != null) {, +      arrayPool.put(buffer);, +      buffer = null;]
[+++ b/gradle.properties, +VERSION_NAME=4.7.0-SNAPSHOT, +VERSION_MINOR=7]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }, +    }, +}, +, +subprojects {, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = 1.7, +        targetCompatibility = 1.7, +    }, +}, +, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }]
[+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java, +        // The area used by the graphic must be restored to the background color., +        int downsampledIH = previousFrame.ih / sampleSize;, +        int downsampledIY = previousFrame.iy / sampleSize;, +        int downsampledIW = previousFrame.iw / sampleSize;, +        int downsampledIX = previousFrame.ix / sampleSize;, +        int topLeft = downsampledIY * downsampledWidth + downsampledIX;, +        int bottomLeft = topLeft + downsampledIH * downsampledWidth;, +        for (int left = topLeft; left < bottomLeft; left += downsampledWidth) {, +          int right = left + downsampledIW;, +          for (int pointer = left; pointer < right; pointer++) {, +            dest[pointer] = c;, +          }, +        }]
[+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java, +import android.annotation.SuppressLint;, +  // Permissions are checked in the factory instead., +  @SuppressLint("MissingPermission")]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java, +import android.graphics.Bitmap.Config;, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +    byte[] data = asPng(toCompress);, +    byte[] data = asJpeg(toCompress);, +    byte[] data = asWebp(toCompress);, +, +  @Test, +  public void load_withSmallerWideGamutInPool_decodesBitmap() {, +    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();, +    Bitmap toPut = Bitmap.createBitmap(300, 298, Config.RGBA_F16);, +    bitmapPool.put(toPut);, +    // Add a second Bitmap to account for the InputStream decode., +    bitmapPool.put(Bitmap.createBitmap(toPut));, +, +    Bitmap wideGamut = Bitmap.createBitmap(300, 300, Config.RGBA_F16);, +    byte[] data = asPng(wideGamut);, +    Bitmap bitmap =, +        concurrency.get(, +            Glide.with(context), +                .asBitmap(), +                .load(data), +                .submit());, +    assertThat(bitmap).isNotNull();, +  }, +, +  private static byte[] asJpeg(Bitmap bitmap) {, +    return toByteArray(bitmap, CompressFormat.JPEG);, +  }, +, +  private static byte[] asPng(Bitmap bitmap) {, +    return toByteArray(bitmap, CompressFormat.PNG);, +  }, +, +  private static byte[] asWebp(Bitmap bitmap) {, +    return toByteArray(bitmap, CompressFormat.WEBP);, +  }, +, +  private static byte[] toByteArray(Bitmap bitmap, CompressFormat format) {, +    ByteArrayOutputStream os = new ByteArrayOutputStream();, +    assertThat(bitmap.compress(format, 100, os)).isTrue();, +    return os.toByteArray();, +  }, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java, +import android.graphics.Bitmap.Config;, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +    byte[] data = asPng(toCompress);, +    byte[] data = asJpeg(toCompress);, +    byte[] data = asWebp(toCompress);, +, +  @Test, +  public void load_withSmallerWideGamutInPool_decodesBitmap() {, +    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();, +    Bitmap toPut = Bitmap.createBitmap(300, 298, Config.RGBA_F16);, +    bitmapPool.put(toPut);, +    // Add a second Bitmap to account for the InputStream decode., +    bitmapPool.put(Bitmap.createBitmap(toPut));, +, +    Bitmap wideGamut = Bitmap.createBitmap(300, 300, Config.RGBA_F16);, +    byte[] data = asPng(wideGamut);, +    Bitmap bitmap =, +        concurrency.get(, +            Glide.with(context), +                .asBitmap(), +                .load(data), +                .submit());, +    assertThat(bitmap).isNotNull();, +  }, +, +  private static byte[] asJpeg(Bitmap bitmap) {, +    return toByteArray(bitmap, CompressFormat.JPEG);, +  }, +, +  private static byte[] asPng(Bitmap bitmap) {, +    return toByteArray(bitmap, CompressFormat.PNG);, +  }, +, +  private static byte[] asWebp(Bitmap bitmap) {, +    return toByteArray(bitmap, CompressFormat.WEBP);, +  }, +, +  private static byte[] toByteArray(Bitmap bitmap, CompressFormat format) {, +    ByteArrayOutputStream os = new ByteArrayOutputStream();, +    assertThat(bitmap.compress(format, 100, os)).isTrue();, +    return os.toByteArray();, +  }, +++ b/library/src/main/java/com/bumptech/glide/util/Util.java, +      case RGBA_F16:, +        bytesPerPixel = 8;, +        break;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java, +import android.graphics.Bitmap.Config;, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +    byte[] data = asPng(toCompress);, +    byte[] data = asJpeg(toCompress);, +    byte[] data = asWebp(toCompress);, +, +  @Test, +  public void load_withSmallerWideGamutInPool_decodesBitmap() {, +    BitmapPool bitmapPool = Glide.get(context).getBitmapPool();]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +              thumbnailBuilder.requestOptions);]
[+++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java, +    // If the request has completed previously, there's no need to restart both the full and the, +    // thumb, we can just restart the full., +    if (!full.isComplete() && !thumb.isRunning()) {, +++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java, +    // If the request has completed previously, there's no need to restart both the full and the, +    // thumb, we can just restart the full., +    if (!full.isComplete() && !thumb.isRunning()) {, +++ b/library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java, +  public void begin_whenFullIsComplete_startsFull() {, +    when(full.isComplete()).thenReturn(true);, +, +    coordinator.begin();, +, +    verify(full).begin();, +  }, +, +  @Test, +  public void begin_whenFullIsComplete_doesNotBeginThumb() {, +    when(full.isComplete()).thenReturn(true);, +, +    coordinator.begin();, +, +    verify(thumb, never()).begin();, +  }, +, +  @Test, +  public void begin_whenFullIsComplete_doesNotSetRunning() {, +    when(full.isComplete()).thenReturn(true);, +, +    coordinator.begin();, +, +    assertThat(coordinator.isRunning()).isFalse();, +  }, +, +  @Test]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNulls;, +import com.squareup.javapoet.ClassName;, +    boolean noNonNull = true;, +    for (ClassName nonNull : nonNulls()) {, +      if (annotationNames.contains(nonNull.reflectionName())) {, +        noNonNull = false;, +        break;, +      }, +    }, +    if (noNonNull) {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +import static com.bumptech.glide.annotation.compiler.ProcessorUtil.nonNulls;, +import com.squareup.javapoet.ClassName;, +    boolean noNonNull = true;, +    for (ClassName nonNull : nonNulls()) {, +      if (annotationNames.contains(nonNull.reflectionName())) {, +        noNonNull = false;, +        break;, +      }, +    }, +    if (noNonNull) {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +import java.util.Arrays;, +  private static final ClassName JETBRAINS_NOTNULL_ANNOTATION =, +      ClassName.get("org.jetbrains.annotations", "NotNull");, +  static List<ClassName> nonNulls() {, +    return Arrays.asList(NONNULL_ANNOTATION, JETBRAINS_NOTNULL_ANNOTATION);, +  }, +]
[+++ b/library/src/main/java/com/bumptech/glide/util/LruCache.java, +   * Returns the number of entries stored in cache., +   */, +  protected int getCount() {, +    return cache.size();, +  }, +, +  /**]
[+++ b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java, +import com.bumptech.glide.gifdecoder.test.TestUtil;, +@Config(manifest = Config.NONE, emulateSdk = 18), +++ b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java, +import com.bumptech.glide.gifdecoder.test.TestUtil;, +@Config(manifest = Config.NONE, emulateSdk = 18), +++ b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java, +import com.bumptech.glide.gifdecoder.test.TestUtil;, +++ b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java, +import com.bumptech.glide.gifdecoder.test.TestUtil;, +@Config(manifest = Config.NONE, emulateSdk = 18), +++ b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java, +import com.bumptech.glide.gifdecoder.test.TestUtil;, +++ /dev/null, +++ b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java, +import com.bumptech.glide.gifdecoder.test.TestUtil;, +@Config(manifest = Config.NONE, emulateSdk = 18), +++ b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/GifHeaderParserTest.java, +import com.bumptech.glide.gifdecoder.test.TestUtil;, +++ /dev/null, +++ b/third_party/gif_decoder/src/androidTest/java/com/bumptech/glide/gifdecoder/test/TestUtil.java, +package com.bumptech.glide.gifdecoder.test;, +, +import java.io.ByteArrayOutputStream;, +import java.io.IOException;, +import java.io.InputStream;, +, +/**, + * Utility methods for GifDecoder tests., + */, +public final class TestUtil {, +, +    private TestUtil() {, +        // Utility class., +    }, +, +    private static InputStream openResource(String imageName) throws IOException {, +        return TestUtil.class.getResourceAsStream("/" + imageName);, +    }, +, +    public static byte[] readResourceData(String imageName) {, +        ByteArrayOutputStream os = new ByteArrayOutputStream();, +        byte[] buffer = new byte[1024];, +        InputStream is = null;, +        try {, +            is = openResource(imageName);, +            int read;, +            while ((read = is.read(buffer)) != -1) {, +                os.write(buffer, 0, read);, +            }, +        } catch (IOException e) {, +            throw new RuntimeException(e);, +        } finally {, +            if (is != null) {, +                try {, +                    is.close();, +                } catch (IOException e) {, +                    // Ignore., +                }, +            }, +        }, +        return os.toByteArray();, +    }, +}]
[+++ b/gradle.properties, +VERSION_NAME=3.4.0, +++ b/gradle.properties, +VERSION_NAME=3.4.0, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.1.0, +++ b/gradle.properties, +VERSION_NAME=3.4.0, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.1.0, +++ b/integration/volley/gradle.properties, +VERSION_NAME=1.1.0]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, + * Generates a new implementation of a AppGlideModule that calls all included LibraryGlideModules, + * and the original AppGlideModule., + * made or classes registered in LibraryGlideModules., + *        android.util.Log.d("Glide", "Discovered LibraryGlideModule from annotation:", + *            + "com.bumptech.glide.integration.okhttp3.OkHttpLibraryGlideModule");, + *      new com.bumptech.glide.integration.okhttp3.OkHttpLibraryGlideModule(), +  TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClassNames) {, +            appGlideModuleClassName, libraryGlideModuleClassNames, excludedGlideModuleClassNames);, +        generateRegisterComponents(libraryGlideModuleClassNames, excludedGlideModuleClassNames);, +  private MethodSpec generateRegisterComponents(Set<String> libraryGlideModuleClassNames,, +    for (String glideModule : libraryGlideModuleClassNames) {, +      Set<String> libraryGlideModuleClassNames, Set<String> excludedGlideModuleClassNames) {, +    for (String glideModule : libraryGlideModuleClassNames) {, +            "AppGlideModule excludes LibraryGlideModule from annotation: " + moduleClassName);, +            "Discovered LibraryGlideModule from annotation: " + moduleClassName);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, + * Generates a new implementation of a AppGlideModule that calls all included LibraryGlideModules, + * and the original AppGlideModule., + * made or classes registered in LibraryGlideModules., + *        android.util.Log.d("Glide", "Discovered LibraryGlideModule from annotation:", + *            + "com.bumptech.glide.integration.okhttp3.OkHttpLibraryGlideModule");, + *      new com.bumptech.glide.integration.okhttp3.OkHttpLibraryGlideModule(), +  TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClassNames) {, +            appGlideModuleClassName, libraryGlideModuleClassNames, excludedGlideModuleClassNames);, +        generateRegisterComponents(libraryGlideModuleClassNames, excludedGlideModuleClassNames);, +  private MethodSpec generateRegisterComponents(Set<String> libraryGlideModuleClassNames,, +    for (String glideModule : libraryGlideModuleClassNames) {, +      Set<String> libraryGlideModuleClassNames, Set<String> excludedGlideModuleClassNames) {, +    for (String glideModule : libraryGlideModuleClassNames) {, +            "AppGlideModule excludes LibraryGlideModule from annotation: " + moduleClassName);, +            "Discovered LibraryGlideModule from annotation: " + moduleClassName);, +++ /dev/null, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, + * Generates a new implementation of a AppGlideModule that calls all included LibraryGlideModules, + * and the original AppGlideModule., + * made or classes registered in LibraryGlideModules., + *        android.util.Log.d("Glide", "Discovered LibraryGlideModule from annotation:", + *            + "com.bumptech.glide.integration.okhttp3.OkHttpLibraryGlideModule");, + *      new com.bumptech.glide.integration.okhttp3.OkHttpLibraryGlideModule(), +  TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClassNames) {, +            appGlideModuleClassName, libraryGlideModuleClassNames, excludedGlideModuleClassNames);, +        generateRegisterComponents(libraryGlideModuleClassNames, excludedGlideModuleClassNames);, +  private MethodSpec generateRegisterComponents(Set<String> libraryGlideModuleClassNames,, +    for (String glideModule : libraryGlideModuleClassNames) {, +      Set<String> libraryGlideModuleClassNames, Set<String> excludedGlideModuleClassNames) {, +    for (String glideModule : libraryGlideModuleClassNames) {, +            "AppGlideModule excludes LibraryGlideModule from annotation: " + moduleClassName);, +            "Discovered LibraryGlideModule from annotation: " + moduleClassName);, +++ /dev/null, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, + * {@link LibraryGlideModule} implementations that are, + *   <li>For {@link LibraryGlideModule}s - A GlideIndexer class in a, + *      {@link LibraryGlideModule} classes., + *     {@link LibraryGlideModule}s and the, +  private LibraryModuleProcessor libraryModuleProcessor;, +    libraryModuleProcessor = new LibraryModuleProcessor(processorUtil, indexerGenerator);, +    result.addAll(libraryModuleProcessor.getSupportedAnnotationTypes());, +   *   <li>Find all LibraryGlideModules, +   *   <li>For each LibraryGlideModule, write an Indexer with an Annotation with the class name., +    boolean newModulesWritten = libraryModuleProcessor.processModules(set, env);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, + * Generates a new implementation of a AppGlideModule that calls all included LibraryGlideModules, + * and the original AppGlideModule., + * made or classes registered in LibraryGlideModules., + *        android.util.Log.d("Glide", "Discovered LibraryGlideModule from annotation:", + *            + "com.bumptech.glide.integration.okhttp3.OkHttpLibraryGlideModule");, + *      new com.bumptech.glide.integration.okhttp3.OkHttpLibraryGlideModule(), +  TypeSpec generate(TypeElement appGlideModule, Set<String> libraryGlideModuleClassNames) {, +            appGlideModuleClassName, libraryGlideModuleClassNames, excludedGlideModuleClassNames);, +        generateRegisterComponents(libraryGlideModuleClassNames, excludedGlideModuleClassNames);, +  private MethodSpec generateRegisterComponents(Set<String> libraryGlideModuleClassNames,, +    for (String glideModule : libraryGlideModuleClassNames) {, +      Set<String> libraryGlideModuleClassNames, Set<String> excludedGlideModuleClassNames) {, +    for (String glideModule : libraryGlideModuleClassNames) {, +            "AppGlideModule excludes LibraryGlideModule from annotation: " + moduleClassName);, +            "Discovered LibraryGlideModule from annotation: " + moduleClassName);, +++ /dev/null, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, + * {@link LibraryGlideModule} implementations that are, + *   <li>For {@link LibraryGlideModule}s - A GlideIndexer class in a, + *      {@link LibraryGlideModule} classes., + *     {@link LibraryGlideModule}s and the, +  private LibraryModuleProcessor libraryModuleProcessor;, +    libraryModuleProcessor = new LibraryModuleProcessor(processorUtil, indexerGenerator);, +    result.addAll(libraryModuleProcessor.getSupportedAnnotationTypes());, +   *   <li>Find all LibraryGlideModules, +   *   <li>For each LibraryGlideModule, write an Indexer with an Annotation with the class name., +    boolean newModulesWritten = libraryModuleProcessor.processModules(set, env);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/IndexerGenerator.java, + * LibraryGlideModules and/or one or more GlideExtensions., + * <p>We use a separate class so that LibraryGlideModules and GlideExtensions written in libraries, + * can be bundled into an AAR and later retrieved by the annotation processor when it processes the, + * <p>The output file generated by this class with a LibraryGlideModule looks like this:, + *      modules = "com.bumptech.glide.integration.okhttp3.OkHttpLibraryGlideModule", + *  public class Indexer_GlideModule_com_bumptech_glide_integration_okhttp3_OkHttpLibraryGlideModule, + *  {, +      } else if (processorUtil.isLibraryGlideModule(element)) {, +  private static TypeSpec generate(List<TypeElement> libraryModules,, +    for (TypeElement childModule : libraryModules) {]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java, +import com.squareup.javapoet.AnnotationSpec;, +import javax.lang.model.element.AnnotationMirror;, +, +    for (AnnotationMirror mirror : methodToOverride.getAnnotationMirrors()) {, +      builder.addAnnotation(AnnotationSpec.get(mirror));, +    }, +]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java, +  /**, +   * An integer indicating the frame option used to retrieve a target frame., +   *, +   * <p>This option will be ignored if {@link #TARGET_FRAME} is not set or is set to, +   * {@link #DEFAULT_FRAME}., +   *, +   * @see MediaMetadataRetriever#getFrameAtTime(long, int), +   */, +  public static final Option<Integer> FRAME_OPTION = Option.disk(, +      "com.bumptech.glide.load.resource.bitmap.VideoBitmapDecode.FrameOption",, +      null /*defaultValue*/,, +      new Option.CacheKeyUpdater<Integer>() {, +        private final ByteBuffer buffer = ByteBuffer.allocate(Integer.SIZE / Byte.SIZE);, +        @Override, +        public void update(byte[] keyBytes, Integer value, MessageDigest messageDigest) {, +          if (value == null) {, +            return;, +          }, +          messageDigest.update(keyBytes);, +          synchronized (buffer) {, +            buffer.position(0);, +            messageDigest.update(buffer.putInt(value).array());, +          }, +        }, +      }, +  );, +, +    long frameTimeMicros = options.get(TARGET_FRAME);, +    if (frameTimeMicros < 0 && frameTimeMicros != DEFAULT_FRAME) {, +          "Requested frame must be non-negative, or DEFAULT_FRAME, given: " + frameTimeMicros);, +    Integer frameOption = options.get(FRAME_OPTION);, +    if (frameTimeMicros == DEFAULT_FRAME) {, +    } else if (frameOption == null) {, +      result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros);, +      result = mediaMetadataRetriever.getFrameAtTime(frameTimeMicros, frameOption);]
[+++ b/README.md, +[![Build Status](https://travis-ci.org/bumptech/glide.svg?branch=master)](https://travis-ci.org/bumptech/glide), +Glide is a fast and efficient open source media management framework for Android that wraps media decoding, memory and, +disk caching, and resource pooling into a simple and easy to use interface. Glide supports fetching, decoding, and, +displaying video stills, images, and animated GIFs. Glide includes a flexible api that allows developers to plug in, +to almost any network stack. By default Glide uses a custom HttpUrlConnection based stack, but also includes utility, +libraries plug in to Google's Volley project or Square's OkHttp library instead., +You can download a jar from GitHub's [release page](https://github.com/bumptech/glide/releases)., +, +Or use Gradle:, +    compile 'com.github.bumptech.glide:glide:3.3.+', +Checkout the [GitHub wiki](https://github.com/bumptech/glide/wiki) for pages on a variety of topics and links to javadocs., +        .crossFade(), +    compile 'com.github.bumptech.glide:volley-integration:1.0.+', +    <version>1.0.0</version>, +  Glide.get(this).register(GlideUrl.class, InputStream.class,, +        new VolleyUrlLoader.Factory(yourRequestQueue));, +    compile 'com.github.bumptech.glide:okhttp-integration:1.0.+', +    <version>1.0.0</version>, +  Glide.get(this).register(GlideUrl.class, InputStream.class,, +        new OkHttpUrlLoader.Factory(yourOkHttpClient));, +Version 3.x is a stable public release used in multiple open source projects at Google including in the Android Camera app and in the 2014 Google IO app. Comments/bugs/questions/pull requests welcome!, +++ b/README.md, +[![Build Status](https://travis-ci.org/bumptech/glide.svg?branch=master)](https://travis-ci.org/bumptech/glide), +Glide is a fast and efficient open source media management framework for Android that wraps media decoding, memory and, +disk caching, and resource pooling into a simple and easy to use interface. Glide supports fetching, decoding, and, +displaying video stills, images, and animated GIFs. Glide includes a flexible api that allows developers to plug in, +to almost any network stack. By default Glide uses a custom HttpUrlConnection based stack, but also includes utility, +libraries plug in to Google's Volley project or Square's OkHttp library instead., +You can download a jar from GitHub's [release page](https://github.com/bumptech/glide/releases)., +, +Or use Gradle:, +    compile 'com.github.bumptech.glide:glide:3.3.+', +Checkout the [GitHub wiki](https://github.com/bumptech/glide/wiki) for pages on a variety of topics and links to javadocs., +        .crossFade(), +    compile 'com.github.bumptech.glide:volley-integration:1.0.+', +    <version>1.0.0</version>, +  Glide.get(this).register(GlideUrl.class, InputStream.class,, +        new VolleyUrlLoader.Factory(yourRequestQueue));, +    compile 'com.github.bumptech.glide:okhttp-integration:1.0.+', +    <version>1.0.0</version>, +  Glide.get(this).register(GlideUrl.class, InputStream.class,, +        new OkHttpUrlLoader.Factory(yourOkHttpClient));, +Version 3.x is a stable public release used in multiple open source projects at Google including in the Android Camera app and in the 2014 Google IO app. Comments/bugs/questions/pull requests welcome!, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.0.0-SNAPSHOT, +VERSION_MAJOR=1, +VERSION_MINOR=0, +VERSION_PATCH=0, +VERSION_CODE=1, +, +++ b/README.md, +[![Build Status](https://travis-ci.org/bumptech/glide.svg?branch=master)](https://travis-ci.org/bumptech/glide), +Glide is a fast and efficient open source media management framework for Android that wraps media decoding, memory and, +disk caching, and resource pooling into a simple and easy to use interface. Glide supports fetching, decoding, and, +displaying video stills, images, and animated GIFs. Glide includes a flexible api that allows developers to plug in, +to almost any network stack. By default Glide uses a custom HttpUrlConnection based stack, but also includes utility, +libraries plug in to Google's Volley project or Square's OkHttp library instead., +You can download a jar from GitHub's [release page](https://github.com/bumptech/glide/releases)., +, +Or use Gradle:, +    compile 'com.github.bumptech.glide:glide:3.3.+', +Checkout the [GitHub wiki](https://github.com/bumptech/glide/wiki) for pages on a variety of topics and links to javadocs., +        .crossFade(), +    compile 'com.github.bumptech.glide:volley-integration:1.0.+', +    <version>1.0.0</version>, +  Glide.get(this).register(GlideUrl.class, InputStream.class,, +        new VolleyUrlLoader.Factory(yourRequestQueue));, +    compile 'com.github.bumptech.glide:okhttp-integration:1.0.+', +    <version>1.0.0</version>, +  Glide.get(this).register(GlideUrl.class, InputStream.class,, +        new OkHttpUrlLoader.Factory(yourOkHttpClient));, +Version 3.x is a stable public release used in multiple open source projects at Google including in the Android Camera app and in the 2014 Google IO app. Comments/bugs/questions/pull requests welcome!, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.0.0-SNAPSHOT, +VERSION_MAJOR=1, +VERSION_MINOR=0, +VERSION_PATCH=0, +VERSION_CODE=1, +, +++ b/integration/volley/gradle.properties, +VERSION_NAME=1.0.0-SNAPSHOT, +VERSION_MAJOR=1, +VERSION_MINOR=0, +VERSION_PATCH=0, +VERSION_CODE=1, +]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.os.Build;, +import com.bumptech.glide.load.resource.bitmap.ExifInterfaceImageHeaderParser;, +    // Right now we're only using this parser for HEIF images, which are only supported on OMR1+., +    // If we need this for other file types, we should consider removing this restriction., +    // Note that order here matters. We want to check the ExifInterface parser first for orientation, +    // and then fall back to DefaultImageHeaderParser for other fields., +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O_MR1) {, +      registry.register(new ExifInterfaceImageHeaderParser());, +    }, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.os.Build;, +import com.bumptech.glide.load.resource.bitmap.ExifInterfaceImageHeaderParser;, +    // Right now we're only using this parser for HEIF images, which are only supported on OMR1+., +    // If we need this for other file types, we should consider removing this restriction., +    // Note that order here matters. We want to check the ExifInterface parser first for orientation, +    // and then fall back to DefaultImageHeaderParser for other fields., +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O_MR1) {, +      registry.register(new ExifInterfaceImageHeaderParser());, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ExifInterfaceImageHeaderParser.java, +package com.bumptech.glide.load.resource.bitmap;, +, +import android.media.ExifInterface;, +import android.support.annotation.NonNull;, +import com.bumptech.glide.load.ImageHeaderParser;, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +import com.bumptech.glide.util.ByteBufferUtil;, +import java.io.IOException;, +import java.io.InputStream;, +import java.nio.ByteBuffer;, +, +/**, + * Uses {@link ExifInterface} to parse orientation data., + *, + * <p>ExifInterface supports the HEIF format on OMR1+. Glide's {@link DefaultImageHeaderParser}, + * doesn't currently support HEIF. In the future we should reconcile these two classes, but for, + * now this is a simple way to ensure that HEIF files are oriented correctly on platforms where, + * they're supported., + */, +public final class ExifInterfaceImageHeaderParser implements ImageHeaderParser {, +, +  @NonNull, +  @Override, +  public ImageType getType(@NonNull InputStream is) throws IOException {, +    return ImageType.UNKNOWN;, +  }, +, +  @NonNull, +  @Override, +  public ImageType getType(@NonNull ByteBuffer byteBuffer) throws IOException {, +    return ImageType.UNKNOWN;, +  }, +, +  @Override, +  public int getOrientation(@NonNull InputStream is, @NonNull ArrayPool byteArrayPool), +      throws IOException {, +    ExifInterface exifInterface = new ExifInterface(is);, +    return exifInterface.getAttributeInt(, +            ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);, +  }, +, +  @Override, +  public int getOrientation(@NonNull ByteBuffer byteBuffer, @NonNull ArrayPool byteArrayPool), +      throws IOException {, +    return getOrientation(ByteBufferUtil.toStream(byteBuffer), byteArrayPool);, +  }, +}]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +import com.bumptech.glide.util.LogTime;, +    long startTime = LogTime.getLogTime();, +          requestedWidth, requestedHeight, startTime);, +      BitmapFactory.Options options, Bitmap result, int requestedWidth, int requestedHeight,, +      long startTime) {, +        + ", thread: " + Thread.currentThread().getName(), +        + ", duration: " + LogTime.getElapsedMillis(startTime));, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +import com.bumptech.glide.util.LogTime;, +    long startTime = LogTime.getLogTime();, +          requestedWidth, requestedHeight, startTime);, +      BitmapFactory.Options options, Bitmap result, int requestedWidth, int requestedHeight,, +      long startTime) {, +        + ", thread: " + Thread.currentThread().getName(), +        + ", duration: " + LogTime.getElapsedMillis(startTime));, +++ b/library/src/main/java/com/bumptech/glide/util/LogTime.java, +      return SystemClock.uptimeMillis();]
[+++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/DrawableTypeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/DrawableTypeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +import org.robolectric.annotation.Config;, +@Config(manifest = Config.NONE, emulateSdk = 18), +++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/DrawableTypeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +import org.robolectric.annotation.Config;, +@Config(manifest = Config.NONE, emulateSdk = 18), +++ b/library/src/androidTest/java/com/bumptech/glide/GenericTranscodeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/DrawableTypeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +import org.robolectric.annotation.Config;, +@Config(manifest = Config.NONE, emulateSdk = 18), +++ b/library/src/androidTest/java/com/bumptech/glide/GenericTranscodeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/GifTypeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/DrawableTypeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +import org.robolectric.annotation.Config;, +@Config(manifest = Config.NONE, emulateSdk = 18), +++ b/library/src/androidTest/java/com/bumptech/glide/GenericTranscodeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/GifTypeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = { GlideTest.ShadowFileDescriptorContentResolver.class,, +        GlideTest.ShadowMediaMetadataRetriever.class, GlideShadowLooper.class, GlideTest.MutableShadowBitmap.class }), +++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/DrawableTypeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +import org.robolectric.annotation.Config;, +@Config(manifest = Config.NONE, emulateSdk = 18), +++ b/library/src/androidTest/java/com/bumptech/glide/GenericTranscodeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/GifTypeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = { GlideTest.ShadowFileDescriptorContentResolver.class,, +        GlideTest.ShadowMediaMetadataRetriever.class, GlideShadowLooper.class, GlideTest.MutableShadowBitmap.class }), +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import org.robolectric.annotation.Config;, +@Config(manifest = Config.NONE, emulateSdk = 18), +++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/DrawableTypeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +import org.robolectric.annotation.Config;, +@Config(manifest = Config.NONE, emulateSdk = 18), +++ b/library/src/androidTest/java/com/bumptech/glide/GenericTranscodeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/GifTypeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = { GlideTest.ShadowFileDescriptorContentResolver.class,, +        GlideTest.ShadowMediaMetadataRetriever.class, GlideShadowLooper.class, GlideTest.MutableShadowBitmap.class }), +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import org.robolectric.annotation.Config;, +@Config(manifest = Config.NONE, emulateSdk = 18), +++ b/library/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/BitmapTypeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/DrawableTypeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +import org.robolectric.annotation.Config;, +@Config(manifest = Config.NONE, emulateSdk = 18), +++ b/library/src/androidTest/java/com/bumptech/glide/GenericTranscodeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/GifTypeRequestTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = GlideShadowLooper.class), +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +@Config(manifest = Config.NONE, emulateSdk = 18, shadows = { GlideTest.ShadowFileDescriptorContentResolver.class,, +        GlideTest.ShadowMediaMetadataRetriever.class, GlideShadowLooper.class, GlideTest.MutableShadowBitmap.class }), +++ b/library/src/androidTest/java/com/bumptech/glide/ListPreloaderTest.java, +import org.robolectric.annotation.Config;, +@Config(manifest = Config.NONE, emulateSdk = 18)]
[+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +import android.os.Build;, +public class OkHttpStreamFetcher implements DataFetcher<InputStream>,, + okhttp3.Callback {, +  private DataCallback<? super InputStream> callback;, +    this.callback = callback;, +    if (Build.VERSION.SDK_INT != Build.VERSION_CODES.O) {, +      call.enqueue(this);, +    } else {, +      try {, +        // Calling execute instead of enqueue is a workaround for #2355, where okhttp throws a, +        // ClassCastException on O., +        onResponse(call, call.execute());, +      } catch (IOException e) {, +        onFailure(call, e);, +      } catch (ClassCastException e) {, +        // It's not clear that this catch is necessary, the error may only occur even on O if, +        // enqueue is used., +        onFailure(call, new IOException("Workaround for framework bug on O", e));, +      }, +    }, +  }, +, +, +    callback = null;]
[+++ b/gradle.properties, +org.gradle.configureondemand=false, +ANDROID_GRADLE_VERSION=3.1.3, +MOCKITO_ANDROID_VERSION=2.21.0]
[+++ b/samples/gallery/build.gradle, +    compile(project(':integration:recyclerview')) {, +        transitive = false, +    }, +++ b/samples/gallery/build.gradle, +    compile(project(':integration:recyclerview')) {, +        transitive = false, +    }, +++ b/samples/gallery/lint.xml, +    <issue id="IconMissingDensityFolder" severity="ignore"/>, +++ b/samples/gallery/build.gradle, +    compile(project(':integration:recyclerview')) {, +        transitive = false, +    }, +++ b/samples/gallery/lint.xml, +    <issue id="IconMissingDensityFolder" severity="ignore"/>, +++ b/samples/gallery/src/main/AndroidManifest.xml, +, +  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />, +, +, +  <application, +          android:label="@string/app_name", +          android:icon="@android:drawable/sym_def_app_icon", +++ b/samples/gallery/build.gradle, +    compile(project(':integration:recyclerview')) {, +        transitive = false, +    }, +++ b/samples/gallery/lint.xml, +    <issue id="IconMissingDensityFolder" severity="ignore"/>, +++ b/samples/gallery/src/main/AndroidManifest.xml, +, +  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />, +, +, +  <application, +          android:label="@string/app_name", +          android:icon="@android:drawable/sym_def_app_icon", +++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/HorizontalGalleryFragment.java, +package com.bumptech.glide.samples.gallery;, +, +import android.os.Bundle;, +import android.support.v4.app.Fragment;, +import android.support.v4.app.LoaderManager;, +import android.support.v4.content.Loader;, +import android.support.v7.widget.GridLayoutManager;, +import android.support.v7.widget.RecyclerView;, +import android.view.LayoutInflater;, +import android.view.View;, +import android.view.ViewGroup;, +, +import com.bumptech.glide.Glide;, +import com.bumptech.glide.RequestManager;, +import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;, +, +import java.util.List;, +, +/**, + * Displays media store data in a recycler view., + */, +public class HorizontalGalleryFragment extends Fragment, +    implements LoaderManager.LoaderCallbacks<List<MediaStoreData>> {, +, +  private RecyclerView recyclerView;, +, +  @Override, +  public void onCreate(Bundle savedInstanceState) {, +    super.onCreate(savedInstanceState);, +    getLoaderManager().initLoader(R.id.loader_id_media_store_data, null, this);, +  }, +, +  @Override, +  public View onCreateView(LayoutInflater inflater, ViewGroup container,, +      Bundle savedInstanceState) {, +    View result = inflater.inflate(R.layout.recycler_view, container, false);, +    recyclerView = (RecyclerView) result.findViewById(R.id.recycler_view);, +    GridLayoutManager layoutManager = new GridLayoutManager(getActivity(), 1);, +    layoutManager.setOrientation(RecyclerView.HORIZONTAL);, +    recyclerView.setLayoutManager(layoutManager);, +    recyclerView.setHasFixedSize(true);, +, +    return result;, +  }, +, +  @Override, +  public Loader<List<MediaStoreData>> onCreateLoader(int i, Bundle bundle) {, +    return new MediaStoreDataLoader(getActivity());, +  }, +, +  @Override, +  public void onLoadFinished(Loader<List<MediaStoreData>> loader,, +      List<MediaStoreData> mediaStoreData) {, +    RequestManager requestManager = Glide.with(this);, +    RecyclerAdapter adapter =, +        new RecyclerAdapter(getActivity(), mediaStoreData, requestManager);, +    RecyclerViewPreloader<MediaStoreData> preloader =, +        new RecyclerViewPreloader<>(requestManager, adapter, adapter, 3);, +    recyclerView.addOnScrollListener(preloader);, +    recyclerView.setAdapter(adapter);, +  }]
[+++ b/gradle.properties, +OK_HTTP_VERSION=3.0.1, +++ b/gradle.properties, +OK_HTTP_VERSION=3.0.1, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +      public void onFailure(Call call, IOException e) {, +      public void onResponse(Call call, Response response) throws IOException {]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java, +package com.bumptech.glide;, +, +import static com.google.common.truth.Truth.assertThat;, +, +import android.content.Context;, +import android.content.res.Resources;, +import android.graphics.Bitmap;, +import android.graphics.BitmapFactory;, +import android.graphics.drawable.BitmapDrawable;, +import android.net.Uri;, +import android.support.test.InstrumentationRegistry;, +import android.support.test.runner.AndroidJUnit4;, +import com.bumptech.glide.test.ConcurrencyHelper;, +import com.bumptech.glide.test.GlideApp;, +import com.bumptech.glide.test.ResourceIds;, +import com.bumptech.glide.test.TearDownGlide;, +import com.google.common.io.ByteStreams;, +import java.io.BufferedOutputStream;, +import java.io.File;, +import java.io.FileOutputStream;, +import java.io.IOException;, +import java.io.InputStream;, +import java.io.OutputStream;, +import java.util.concurrent.TimeUnit;, +import org.junit.Before;, +import org.junit.Ignore;, +import org.junit.Rule;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.mockito.MockitoAnnotations;, +, +@RunWith(AndroidJUnit4.class), +public class AsBytesTest {, +  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();, +  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();, +, +  private Context context;, +, +  @Before, +  public void setUp() throws IOException {, +    MockitoAnnotations.initMocks(this);, +    context = InstrumentationRegistry.getTargetContext();, +  }, +, +  @Test, +  public void loadImageResourceId_asBytes_providesBytesOfBitmap() {, +    byte[] data =, +        concurrency.get(, +            Glide.with(context), +                .as(byte[].class), +                .load(ResourceIds.raw.canonical), +                .submit());, +    assertThat(data).isNotNull();, +    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();, +  }, +, +  @Test, +  public void loadBitmap_asBytes_providesBytesOfBitmap() {, +    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);, +    byte[] data =, +        concurrency.get(, +            Glide.with(context), +                .as(byte[].class), +                .load(bitmap), +                .submit());, +, +    assertThat(data).isNotNull();, +    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();, +  }, +, +  // TODO: Should this pass?, +  @Ignore, +  @Test, +  public void loadBitmapDrawable_asBytes_providesBytesOfBitmap() {, +    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);, +    byte[] data =, +        concurrency.get(, +            Glide.with(context), +                .as(byte[].class), +                .load(new BitmapDrawable(context.getResources(), bitmap)), +                .submit());, +, +    assertThat(data).isNotNull();, +    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();, +  }, +, +  // TODO: This should pass., +  @Ignore, +  @Test, +  public void loadVideoResourceId_asBytes_providesBytesOfFrame() {, +    byte[] data =, +        concurrency.get(, +            Glide.with(context), +                .as(byte[].class), +                .load(ResourceIds.raw.video), +                .submit());, +, +    assertThat(data).isNotNull();, +    assertThat(BitmapFactory.decodeByteArray(data, 0, data.length)).isNotNull();]
[+++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" />, +++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" />, +++ b/library/src/com/bumptech/glide/Glide.java, +import android.view.ViewGroup;, +import com.bumptech.glide.loader.model.FileLoader;, +import com.bumptech.glide.loader.model.GenericLoaderFactory;, +import com.bumptech.glide.loader.model.ModelLoader;, +import com.bumptech.glide.loader.model.ModelLoaderFactory;, +import com.bumptech.glide.loader.model.ResourceLoader;, +import com.bumptech.glide.loader.model.StringLoader;, +import com.bumptech.glide.loader.model.UriLoader;, +import com.bumptech.glide.loader.stream.StreamLoader;, +import com.bumptech.glide.loader.transformation.CenterCrop;, +import com.bumptech.glide.loader.transformation.FitCenter;, +import com.bumptech.glide.loader.transformation.MultiTransformationLoader;, +import com.bumptech.glide.loader.transformation.None;, +import com.bumptech.glide.loader.transformation.TransformationLoader;, +import com.bumptech.glide.presenter.target.Target;, +, +import java.util.Map;, +import java.util.WeakHashMap;, + * A singleton to present a simple static interface for Glide {@link Glide.Request} and to create and manage an, +    private final Map<Target, Metadata> metadataTracker = new WeakHashMap<Target, Metadata>();, +         *     public void onException(Exception e, T model, Target target) {, +        loaderFactory.register(File.class, new FileLoader.Factory());, +        loaderFactory.register(Integer.class, new ResourceLoader.Factory());, +        loaderFactory.register(String.class, new StringLoader.Factory());, +        loaderFactory.register(Uri.class, new UriLoader.Factory());, +            loaderFactory.register(URL.class, new VolleyUrlLoader.Factory());, +            loaderFactory.register(URL.class, new ModelLoaderFactory<URL>() {, +                ModelLoader<URL> errorUrlLoader = new ModelLoader<URL>() {, +                    @Override, +                    public StreamLoader getStreamLoader(URL model, int width, int height) {, +                        throw new IllegalArgumentException("No ModelLoaderFactory for urls registered with Glide");, +                    }, +, +                    @Override, +                    public String getId(URL model) {, +                        throw new IllegalArgumentException("No ModelLoaderFactory for urls registered with Glide");, +                    }, +                };, +, +                @Override, +                public ModelLoader<URL> build(Context context, GenericLoaderFactory factories) {, +                    return errorUrlLoader;, +                }, +, +                @Override @SuppressWarnings("unchecked"), +                public Class<? extends ModelLoader<URL>> loaderClass() {, +                    return (Class<ModelLoader<URL>>) errorUrlLoader.getClass();, +                }, +, +                @Override, +                public void teardown() {, +                }, +            });, +     * {@link ImageManager} with custom options for use with {@link com.bumptech.glide.Glide.Request} and/or as an, +     * Set the {@link ImageManager} to use with {@link Glide.Request}., +     * Set the {@link ImageManager} to use with {@link Glide.Request} Replaces the current, +     * models. Typically the {@link Glide#using(com.bumptech.glide.loader.model.ModelLoader)} syntax is preferred, +     * because it directly links the model with the ModelLoader being used to load it., +     *     used for any other model class, {@link com.bumptech.glide.loader.model.ModelLoaderFactory#teardown()}, +     * @param clazz The class, +     * @param factory The factory to use, +     * @param <T> The type of the model, +    public <T> void register(Class<T> clazz, ModelLoaderFactory<T> factory) {, +        ModelLoaderFactory<T> removed = loaderFactory.register(clazz, factory);, +     * @param clazz The class to get a {@link ModelLoader} for, +    public static <T> ModelLoader<T> buildModelLoader(Class<T> clazz, Context context) {, +        return GLIDE.loaderFactory.buildModelLoader(clazz, context);, +    }, +, +    @SuppressWarnings("unchecked"), +    private <T> ModelLoaderFactory<T> getFactory(T model) {, +        return loaderFactory.getFactory((Class<T>) model.getClass());, +    }, +, +    private ImageViewTarget getImageViewTarget(ImageView imageView) {, +        Object tag = imageView.getTag();, +        ImageViewTarget result = null;, +        if (tag instanceof ImageViewTarget) {, +            result = (ImageViewTarget) tag;, +        } else if (tag != null) {, +            throw new IllegalArgumentException("You cannot set a tag on an image view Glide is loading an image into");, +        }, +, +        return result;, +    }, +, +    private ImageViewTarget getImageViewTargetOrSet(ImageView imageView) {, +        ImageViewTarget result = getImageViewTarget(imageView);, +        if (result == null) {, +            result = new ImageViewTarget(imageView);, +            imageView.setTag(result);, +        }, +        return result;, +     * Set the {@link ModelLoaderFactory} and therefore the model type to use for a new load., +     *     Note - You can use this method to set a {@link ModelLoaderFactory} for models that don't have a default]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/PausedRequestsTest.java, +package com.bumptech.glide;, +, +import static com.google.common.truth.Truth.assertThat;, +, +import android.content.Context;, +import android.graphics.Color;, +import android.graphics.drawable.ColorDrawable;, +import android.support.test.InstrumentationRegistry;, +import android.widget.ImageView;, +import com.bumptech.glide.test.ConcurrencyHelper;, +import com.bumptech.glide.test.GlideApp;, +import com.bumptech.glide.test.GlideRequests;, +import com.bumptech.glide.test.ResourceIds;, +import com.bumptech.glide.test.TearDownGlide;, +import org.junit.Rule;, +import org.junit.Test;, +, +/**, + * Tests how {@link com.bumptech.glide.request.Request}s behave when the corresponding, + * {@link RequestManager} is paused., + */, +public final class PausedRequestsTest {, +  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();, +  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();, +  private final Context context = InstrumentationRegistry.getTargetContext();, +, +  @SuppressWarnings("unchecked"), +  @Test, +  public void load_withPlaceHolderSet_requestsPaused_displaysPlaceholder() {, +    final ImageView imageView = new ImageView(context);, +, +    final GlideRequests requests = GlideApp.with(context);, +    concurrency.runOnMainThread(new Runnable() {, +      @Override, +      public void run() {, +        requests.pauseAllRequests();, +      }, +    });, +, +    final ColorDrawable expected = new ColorDrawable(Color.RED);, +    concurrency.runOnMainThread(, +        new Runnable() {, +          @Override, +          public void run() {, +            requests, +                .load(ResourceIds.drawable.bitmap_alias), +                .placeholder(expected), +                .into(imageView);, +          }, +        });, +, +    assertThat(imageView.getDrawable()).isEqualTo(expected);, +  }, +}, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/PausedRequestsTest.java, +package com.bumptech.glide;, +, +import static com.google.common.truth.Truth.assertThat;, +, +import android.content.Context;, +import android.graphics.Color;, +import android.graphics.drawable.ColorDrawable;, +import android.support.test.InstrumentationRegistry;, +import android.widget.ImageView;, +import com.bumptech.glide.test.ConcurrencyHelper;, +import com.bumptech.glide.test.GlideApp;, +import com.bumptech.glide.test.GlideRequests;, +import com.bumptech.glide.test.ResourceIds;, +import com.bumptech.glide.test.TearDownGlide;, +import org.junit.Rule;, +import org.junit.Test;, +, +/**, + * Tests how {@link com.bumptech.glide.request.Request}s behave when the corresponding, + * {@link RequestManager} is paused., + */, +public final class PausedRequestsTest {, +  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();, +  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();, +  private final Context context = InstrumentationRegistry.getTargetContext();, +, +  @SuppressWarnings("unchecked"), +  @Test, +  public void load_withPlaceHolderSet_requestsPaused_displaysPlaceholder() {, +    final ImageView imageView = new ImageView(context);, +, +    final GlideRequests requests = GlideApp.with(context);, +    concurrency.runOnMainThread(new Runnable() {, +      @Override, +      public void run() {, +        requests.pauseAllRequests();, +      }, +    });, +, +    final ColorDrawable expected = new ColorDrawable(Color.RED);, +    concurrency.runOnMainThread(, +        new Runnable() {, +          @Override, +          public void run() {]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/src/test/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapResourceDecoderTest.java, +package com.bumptech.glide.load.resource.gifbitmap;, +, +import android.graphics.Bitmap;, +import android.os.ParcelFileDescriptor;, +import com.bumptech.glide.Resource;, +import com.bumptech.glide.load.ResourceDecoder;, +import com.bumptech.glide.load.model.ImageVideoWrapper;, +import com.bumptech.glide.load.resource.gif.GifData;, +import com.bumptech.glide.load.resource.gif.GifDrawable;, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;, +, +import java.io.ByteArrayInputStream;, +import java.io.IOException;, +import java.io.InputStream;, +, +import static junit.framework.Assert.assertEquals;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.when;, +, +@RunWith(RobolectricTestRunner.class), +public class GifBitmapResourceDecoderTest {, +    private ResourceDecoder<ImageVideoWrapper, Bitmap> bitmapDecoder;, +    private ResourceDecoder<InputStream, GifData> gifDecoder;, +    private GifBitmapWrapperResourceDecoder decoder;, +, +    @SuppressWarnings("unchecked"), +    @Before, +    public void setUp() {, +        bitmapDecoder = mock(ResourceDecoder.class);, +        gifDecoder = mock(ResourceDecoder.class);, +        decoder = new GifBitmapWrapperResourceDecoder(bitmapDecoder, gifDecoder);, +    }, +, +    @Test, +    public void testDecoderUsesGifDecoderResultIfGif() throws IOException {, +        GifDrawable expected = mock(GifDrawable.class);, +        GifData gifData = mock(GifData.class);, +        when(gifData.getDrawable()).thenReturn(expected);, +        Resource<GifData> gifDrawableResource = mock(Resource.class);, +        when(gifDrawableResource.get()).thenReturn(gifData);, +        when(gifDecoder.decode(any(InputStream.class), anyInt(), anyInt())).thenReturn(gifDrawableResource);, +, +        byte[] data = new byte[] { 'G', 'I', 'F'};, +        ImageVideoWrapper wrapper = new ImageVideoWrapper(new ByteArrayInputStream(data), null);, +, +        Resource<GifBitmapWrapper> result = decoder.decode(wrapper, 100, 100);, +, +        assertEquals(expected, result.get().getGifResource().get().getDrawable());, +    }, +, +    @Test, +    public void testDecoderUsesBitmapDecoderIfStreamIsNotGif() throws IOException {, +        Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +        Resource<Bitmap> bitmapResource = mock(Resource.class);, +        when(bitmapResource.get()).thenReturn(expected);, +        when(bitmapDecoder.decode(any(ImageVideoWrapper.class), anyInt(), anyInt())).thenReturn(bitmapResource);, +, +        byte[] data = new byte[] { 'A', 'I', 'F'};, +        ImageVideoWrapper wrapper = new ImageVideoWrapper(new ByteArrayInputStream(data), null);, +, +        Resource<GifBitmapWrapper> result = decoder.decode(wrapper, 100, 100);, +, +        Bitmap bitmap = result.get().getBitmapResource().get();, +, +        assertEquals(expected, bitmap);, +    }, +, +    @Test, +    public void testDecoderUsesBitmapDecoderIfIsFileDescriptor() throws IOException {, +        Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +        Resource<Bitmap> bitmapResource = mock(Resource.class);, +        when(bitmapResource.get()).thenReturn(expected);, +        when(bitmapDecoder.decode(any(ImageVideoWrapper.class), anyInt(), anyInt())).thenReturn(bitmapResource);, +, +        ImageVideoWrapper wrapper = new ImageVideoWrapper(null, mock(ParcelFileDescriptor.class));, +, +        Resource<GifBitmapWrapper> result = decoder.decode(wrapper, 100, 100);, +, +        Bitmap bitmap = result.get().getBitmapResource().get();, +, +        assertEquals(expected, bitmap);, +    }, +}, +++ /dev/null, +++ /dev/null]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +                .url(url.toStringUrl()), +        return url.getCacheKey();, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +                .url(url.toStringUrl()), +        return url.getCacheKey();, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +        String stringUrl = url.toStringUrl();, +        return url.getCacheKey();, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +                .url(url.toStringUrl()), +        return url.getCacheKey();, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +        String stringUrl = url.toStringUrl();, +        return url.getCacheKey();, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +        when(glideUrl.getCacheKey()).thenReturn(expected);, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +                .url(url.toStringUrl()), +        return url.getCacheKey();, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +        String stringUrl = url.toStringUrl();, +        return url.getCacheKey();, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +        when(glideUrl.getCacheKey()).thenReturn(expected);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/GlideUrlTest.java, +        assertEquals(expected, glideUrl.toStringUrl());, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +                .url(url.toStringUrl()), +        return url.getCacheKey();, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +        String stringUrl = url.toStringUrl();, +        return url.getCacheKey();, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +        when(glideUrl.getCacheKey()).thenReturn(expected);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/GlideUrlTest.java, +        assertEquals(expected, glideUrl.toStringUrl());, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java, +                        assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());, +                assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +                .url(url.toStringUrl()), +        return url.getCacheKey();, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +        String stringUrl = url.toStringUrl();, +        return url.getCacheKey();, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +        when(glideUrl.getCacheKey()).thenReturn(expected);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/GlideUrlTest.java, +        assertEquals(expected, glideUrl.toStringUrl());, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java, +                        assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());, +                assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());, +++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java, +        return glideUrl.getCacheKey();, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +                .url(url.toStringUrl()), +        return url.getCacheKey();, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +        String stringUrl = url.toStringUrl();, +        return url.getCacheKey();, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +        when(glideUrl.getCacheKey()).thenReturn(expected);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/GlideUrlTest.java, +        assertEquals(expected, glideUrl.toStringUrl());, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java, +                        assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());, +                assertEquals(urlLoader.resultUrl, glideUrl.toStringUrl());, +++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java, +        return glideUrl.getCacheKey();, +++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java, + * <p>  Users wishing to replace the class for handling URLs must register a factory using GlideUrl. </p>, + * <p> To obtain a properly escaped URL, call {@link #toURL()}. To obtain a properly escaped string URL, call, + * {@link #toStringUrl()}. To obtain a less safe, but less expensive to calculate cache key, call, + * {@link #getCacheKey()}. </p>, + *, + * <p> This class can also optionally wrap {@link com.bumptech.glide.load.model.Headers} for convenience. </p>, +    /**, +     * Returns a properly escaped {@link java.net.URL} that can be used to make http/https requests., +     *, +     * @see #toStringUrl(), +     * @see #getCacheKey(), +     * @throws MalformedURLException, +     */, +    /**, +     * Returns a properly escaped {@link String} url that can be used to make http/https requests., +     *, +     * @see #toURL(), +     * @see #getCacheKey(), +     */, +    /**, +     * Returns a non-null {@link Map} containing headers., +     */, +    /**, +     * Returns an inexpensive to calculate {@link String} suitable for use as a disk cache key., +     *, +     * <p> This method does not include headers. </p>, +     *, +     * <p> Unlike {@link #toStringUrl()}} and {@link #toURL()}, this method does not escape input. </p>, +     */]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import android.support.annotation.DrawableRes;, +   * Returns a request builder that uses the, +   * {@link com.bumptech.glide.load.model.ModelLoaderFactory} currently registered or, +   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESOURCE} for release builds., +   *, +   * <p>This method will load non-{@link android.graphics.Bitmap} resources like, +   * {@link android.graphics.drawable.VectorDrawable}s, but most common options including, +   * default {@link com.bumptech.glide.load.Transformation}s will not <em>NOT</em> work on, +   * non-{@link android.graphics.Bitmap} resources. As a result, functionality for, +   * non-{@link android.graphics.Bitmap} resources may be limited., +  public RequestBuilder<TranscodeType> load(@DrawableRes @Nullable Integer resourceId) {]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RoundedCorners.java]
[+++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="16" />]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +          responseBody = response.body();, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +          responseBody = response.body();, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +          responseBody = response.body();, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +          responseBody = response.body();, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +          responseBody = response.body();, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +  private MemoryCategory memoryCategory = MemoryCategory.NORMAL;, +   *, +   * @return the previous MemoryCategory used by Glide., +  public MemoryCategory setMemoryCategory(MemoryCategory memoryCategory) {, +    MemoryCategory oldCategory = this.memoryCategory;, +    this.memoryCategory = memoryCategory;, +    return oldCategory;]
[+++ b/.gitignore, +library/build/*, +++ b/.gitignore, +library/build/*, +++ b/.gitmodules, +[submodule "samples/flickr/ActionBarSherlock"], +	path = samples/flickr/ActionBarSherlock, +	url = https://github.com/JakeWharton/ActionBarSherlock.git, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +++ b/.gitignore, +library/build/*, +++ b/.gitmodules, +[submodule "samples/flickr/ActionBarSherlock"], +	path = samples/flickr/ActionBarSherlock, +	url = https://github.com/JakeWharton/ActionBarSherlock.git, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +++ /dev/null, +++ b/.gitignore, +library/build/*, +++ b/.gitmodules, +[submodule "samples/flickr/ActionBarSherlock"], +	path = samples/flickr/ActionBarSherlock, +	url = https://github.com/JakeWharton/ActionBarSherlock.git, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +++ /dev/null, +++ b/LICENSE, +Copyright 2013 Bump Technologies, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY BUMP TECHNOLOGIES, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BUMP TECHNOLOGIES, INC. OR, +or implied, of Bump Technologies, Inc., +++ b/.gitignore, +library/build/*, +++ b/.gitmodules, +[submodule "samples/flickr/ActionBarSherlock"], +	path = samples/flickr/ActionBarSherlock, +	url = https://github.com/JakeWharton/ActionBarSherlock.git, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +++ /dev/null, +++ b/LICENSE, +Copyright 2013 Bump Technologies, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY BUMP TECHNOLOGIES, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BUMP TECHNOLOGIES, INC. OR, +or implied, of Bump Technologies, Inc., +++ b/Makefile, +jar:, +	git submodule init, +	git submodule update, +	cd library/volley && ant clean && ant jar, +	cp library/volley/bin/volley.jar library/libs, +	cd library && ant clean && ant jar, +, +glide-minus-volley:, +	cd library && ant clean && ant glide-minus-volley, +, +++ b/.gitignore, +library/build/*, +++ b/.gitmodules, +[submodule "samples/flickr/ActionBarSherlock"], +	path = samples/flickr/ActionBarSherlock, +	url = https://github.com/JakeWharton/ActionBarSherlock.git, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +++ /dev/null, +++ b/LICENSE, +Copyright 2013 Bump Technologies, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY BUMP TECHNOLOGIES, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BUMP TECHNOLOGIES, INC. OR, +or implied, of Bump Technologies, Inc., +++ b/Makefile, +jar:, +	git submodule init, +	git submodule update, +	cd library/volley && ant clean && ant jar, +	cp library/volley/bin/volley.jar library/libs, +	cd library && ant clean && ant jar, +, +glide-minus-volley:, +	cd library && ant clean && ant glide-minus-volley, +, +++ b/README.md, +Glide is fast and efficient image loading library for Android that wraps image downloading, resizing, memory and disk caching, and bitmap recycling into one simple and easy to use interface. By default, Glide includes an implementation for fetching images over http based on Google's Volley project for fast, parallelized network operations on Android., +Glide's primary focus is on making scrolling any kind of a list of images as smooth and fast as possible, but Glide is also effective for almost any case where you need to fetch, resize, and display a remote image., +You can download a .jar from GitHub's release page for the Glide project. The wiki also has pages on a variety of topics and the javadocs for version 2.0+ will also be available via a link there as well., +    Glide.load("http://goo.gl/h8qOq7").into(imageView);, +    Glide.load(url), +Glide has been in use at Bump for about six months in two of our Android apps at version 1.0. Version 2.0 is the first public release with a stable api. Comments/bugs/questions/pull requests welcome!]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java, +    // Calling setDataSource is expensive so avoid doing so unless we're actually called., +    // For non-videos this isn't any cheaper, but for videos it safes the redundant call and, +    // 50-100ms., +    } catch (RuntimeException e) {, +      // MediaMetadataRetriever APIs throw generic runtime exceptions when given invalid data., +      throw new IOException(e);]
[+++ b/library/src/androidTest/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/util/ExceptionCatchingInputStreamTest.java, +++ b/library/src/androidTest/java/com/bumptech/glide/util/MarkEnforcingInputStreamTest.java, +package com.bumptech.glide.util;, +, +import static com.google.common.truth.Truth.assertThat;, +import static org.junit.Assert.assertEquals;, +, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +, +import java.io.ByteArrayInputStream;, +import java.io.IOException;, +, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE), +public class MarkEnforcingInputStreamTest {, +    // An arbitrary number > 0., +    private static final int MARK_LIMIT = 5;, +    // Another arbitrary number > MARK_LIMIT., +    private static final int DATA_SIZE = MARK_LIMIT + 1;, +, +    @Test, +    public void testReturnsByte_whenReadsUpToMarkLimit_withMoreBytesAvailable() throws IOException {, +        MarkEnforcingInputStream is = new MarkEnforcingInputStream(, +                new ByteArrayInputStream(new byte[DATA_SIZE]));, +        is.mark(MARK_LIMIT);, +, +         for (int i = 0; i < MARK_LIMIT; i++) {, +             assertThat(is.read()).isAtLeast(0);, +         }, +    }, +, +    @Test, +    public void testReturnsByte_whenReadsUpToMarkLimit_withNoMoreBytesAvailable() throws IOException {, +        MarkEnforcingInputStream is = new MarkEnforcingInputStream(, +                new ByteArrayInputStream(new byte[MARK_LIMIT]));, +, +        for (int i = 0; i < MARK_LIMIT; i++) {, +            assertThat(is.read()).isAtLeast(0);, +        }, +    }, +, +    @Test, +    public void testReturnsEndOfStream_whenReadsSingleBytePastMarkLimit() throws IOException {, +        MarkEnforcingInputStream is = new MarkEnforcingInputStream(, +                new ByteArrayInputStream(new byte[DATA_SIZE]));, +, +        is.mark(MARK_LIMIT);, +        for (int i = 0; i < MARK_LIMIT; i++) {, +            assertThat(is.read()).isAtLeast(0);, +        }, +, +        assertEquals(-1, is.read());, +    }, +, +    @Test, +    public void testOverridesByteCount_whenReadBufferLargerThanMarkLimit_withNonZeroBytesRemainingInMarkLimit(), +            throws IOException {, +        MarkEnforcingInputStream is = new MarkEnforcingInputStream(, +                new ByteArrayInputStream(new byte[DATA_SIZE]));, +, +        is.mark(MARK_LIMIT);, +        byte[] buffer = new byte[DATA_SIZE];, +        assertEquals(MARK_LIMIT, is.read(buffer));, +    }, +, +    @Test, +    public void testReturnsEndOfStream_whenReadBufferLargerThanMarkLimit_withZeroBytesRemainingInMarkLimit(), +            throws IOException {, +        MarkEnforcingInputStream is = new MarkEnforcingInputStream(, +                new ByteArrayInputStream(new byte[DATA_SIZE]));, +        is.mark(MARK_LIMIT);, +, +        byte[] buffer = new byte[MARK_LIMIT];, +        assertEquals(MARK_LIMIT, is.read(buffer));, +        assertEquals(-1, is.read(buffer));, +    }, +, +    @Test, +    public void testDoesNotReadIntoBuffer_withZeroBytesRemainingInMarkLimit() throws IOException {, +        byte[] expected = new byte[MARK_LIMIT];, +        for (int i = 0; i < MARK_LIMIT; i++) {, +            expected[i] = (byte) (i + 1);, +        }, +        byte[] buffer = new byte[MARK_LIMIT];, +        System.arraycopy(expected, 0, buffer, 0, MARK_LIMIT);, +, +        // All zeros., +        MarkEnforcingInputStream is = new MarkEnforcingInputStream(, +                new ByteArrayInputStream(new byte[DATA_SIZE]));, +        is.mark(MARK_LIMIT);, +        for (int i = 0; i < MARK_LIMIT; i++) {, +            assertThat(is.read()).isAtLeast(0);, +        }, +, +        assertEquals(-1, is.read(buffer));, +]
[+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +   * @see #centerInside()]
[+++ b/CONTRIBUTING.md, +Contributions of all types are welcome., +We use GitHub as our bug and feature tracker both for code and for other aspects of the library (documentation, the wiki, etc.)., +, +The best way to ask general questions is to send an email to our [mailing list][2], or join [#glide-library on freenode.org][3]., +, +When in doubt, file an issue. We'd rather close a few duplicate issues than let a problem go unnoticed., +Similarly if you support a particular feature request, feel free to let us know by commenting on the issue., +To file a new issue, please use our issue template and fill out the template as much as possible (remove irrelevant parts)., +, +<pre>**Glide Version/Integration library (if any)**:, +**Device/Android Version**:, +**Issue details/Repro steps/Use case background**:, +, +**Glide load line**:, +```java, +Glide.with(...).....load(...).....into(...);, +```, +, +**Layout XML**:, +```xml, +&lt;...Layout&gt;, +    &lt;ImageView android:scaleType="..." ... /&gt;, +&lt;/..Layout&gt;, +```, +, +**Stack trace / LogCat**:, +```ruby, +paste stack trace here, +```, +</pre>, +, +You can save [this as a bookmark or just click it][1] to create a new issue., +The more information you can provide, the more likely we are to be able help., +, +Pull requests are welcome for all parts of the codebase, especially the integration libraries., +You can find instructions on building the project in [README.md][5]., +Our code style is defined in Intellij project files in the repo and also by our Checkstyle config., +If you'd like to submit code, but can't get the style checks to pass, feel free to put up your pull request anyway and we can help you fix the style issues., +If you'd like to contribute code, you will need to sign [Google's individual contributor license agreement][4] which will be asked when you create the PR by [googlebot](https://github.com/googlebot) should you forget it., +, +[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20%28if%20any%29**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details/Repro%20steps/Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60, +[4]: https://developers.google.com/open-source/cla/individual, +[5]: /bumptech/glide, +++ b/CONTRIBUTING.md, +Contributions of all types are welcome., +We use GitHub as our bug and feature tracker both for code and for other aspects of the library (documentation, the wiki, etc.)., +, +The best way to ask general questions is to send an email to our [mailing list][2], or join [#glide-library on freenode.org][3]., +, +When in doubt, file an issue. We'd rather close a few duplicate issues than let a problem go unnoticed., +Similarly if you support a particular feature request, feel free to let us know by commenting on the issue., +To file a new issue, please use our issue template and fill out the template as much as possible (remove irrelevant parts)., +, +<pre>**Glide Version/Integration library (if any)**:, +**Device/Android Version**:, +**Issue details/Repro steps/Use case background**:, +, +**Glide load line**:, +```java, +Glide.with(...).....load(...).....into(...);, +```, +, +**Layout XML**:, +```xml, +&lt;...Layout&gt;, +    &lt;ImageView android:scaleType="..." ... /&gt;, +&lt;/..Layout&gt;, +```, +, +**Stack trace / LogCat**:, +```ruby, +paste stack trace here, +```, +</pre>, +, +You can save [this as a bookmark or just click it][1] to create a new issue., +The more information you can provide, the more likely we are to be able help., +, +Pull requests are welcome for all parts of the codebase, especially the integration libraries., +You can find instructions on building the project in [README.md][5]., +Our code style is defined in Intellij project files in the repo and also by our Checkstyle config., +If you'd like to submit code, but can't get the style checks to pass, feel free to put up your pull request anyway and we can help you fix the style issues., +If you'd like to contribute code, you will need to sign [Google's individual contributor license agreement][4] which will be asked when you create the PR by [googlebot](https://github.com/googlebot) should you forget it., +, +[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version/Integration%20library%20%28if%20any%29**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details/Repro%20steps/Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60, +[4]: https://developers.google.com/open-source/cla/individual, +[5]: /bumptech/glide, +++ b/README.md, +Glide supports fetching, decoding, and displaying video stills, images, and animated GIFs. Glide includes a flexible API, +that allows developers to plug in to almost any network stack. By default Glide uses a custom `HttpUrlConnection` based, +```gradle, +    compile 'com.github.bumptech.glide:glide:3.6.1', +    <version>3.6.1</version>, +, +```pro, +```java, +// For a simple image list:, +        myImageView = (ImageView) inflater.inflate(R.layout.my_image_view, container, false);, +Support for OkHttp and Volley is provided by integration libraries you can optionally include as dependencies.]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }, +    }, +}, +, +subprojects {, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = 1.7, +        targetCompatibility = 1.7, +    }, +}, +, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }]
[+++ b/.gitmodules, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/.gitmodules, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/Makefile, +	cd third_party/volley/volley && ant clean && ant jar, +	cp third_party/volley/volley/bin/volley.jar library/libs, +++ b/.gitmodules, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/Makefile, +	cd third_party/volley/volley && ant clean && ant jar, +	cp third_party/volley/volley/bin/volley.jar library/libs, +++ /dev/null, +++ b/.gitmodules, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/Makefile, +	cd third_party/volley/volley && ant clean && ant jar, +	cp third_party/volley/volley/bin/volley.jar library/libs, +++ /dev/null, +++ b/third_party/volley/LICENSE, +Copyright (C) 2014 The Android Open Source Project, +, +Licensed under the Apache License, Version 2.0 (the "License");, +you may not use this file except in compliance with the License., +You may obtain a copy of the License at, +, +     http://www.apache.org/licenses/LICENSE-2.0, +, +Unless required by applicable law or agreed to in writing, software, +distributed under the License is distributed on an "AS IS" BASIS,, +WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., +See the License for the specific language governing permissions and, +limitations under the License., +++ b/.gitmodules, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/Makefile, +	cd third_party/volley/volley && ant clean && ant jar, +	cp third_party/volley/volley/bin/volley.jar library/libs, +++ /dev/null, +++ b/third_party/volley/LICENSE, +Copyright (C) 2014 The Android Open Source Project, +, +Licensed under the Apache License, Version 2.0 (the "License");, +you may not use this file except in compliance with the License., +You may obtain a copy of the License at, +, +     http://www.apache.org/licenses/LICENSE-2.0, +, +Unless required by applicable law or agreed to in writing, software, +distributed under the License is distributed on an "AS IS" BASIS,, +WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., +See the License for the specific language governing permissions and, +limitations under the License., +++ b/third_party/volley/README.third_party, +URL: https://android.googlesource.com/platform/frameworks/volley/+archive/527f964cc7df8e807deb21469a537a6f6800e0fb.tar.gz, +Version: 527f964cc7df8e807deb21469a537a6f6800e0fb, +License: Apache 2.0, +License File: LICENSE, +, +Description:, +A networking library for Android., +, +Local Modifications:, +No local modifications., +++ b/.gitmodules, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/Makefile, +	cd third_party/volley/volley && ant clean && ant jar, +	cp third_party/volley/volley/bin/volley.jar library/libs, +++ /dev/null, +++ b/third_party/volley/LICENSE, +Copyright (C) 2014 The Android Open Source Project, +, +Licensed under the Apache License, Version 2.0 (the "License");, +you may not use this file except in compliance with the License., +You may obtain a copy of the License at, +, +     http://www.apache.org/licenses/LICENSE-2.0, +, +Unless required by applicable law or agreed to in writing, software, +distributed under the License is distributed on an "AS IS" BASIS,, +WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., +See the License for the specific language governing permissions and, +limitations under the License., +++ b/third_party/volley/README.third_party, +URL: https://android.googlesource.com/platform/frameworks/volley/+archive/527f964cc7df8e807deb21469a537a6f6800e0fb.tar.gz, +Version: 527f964cc7df8e807deb21469a537a6f6800e0fb, +License: Apache 2.0]
[+++ b/library/src/main/java/com/bumptech/glide/Registry.java, +import java.io.File;, +import java.util.HashMap;, +import java.util.Map;, +, +      Map<Class<?>, List<? extends Class<?>>> dataClassToResourceClasses = new HashMap<>();, +      Map<Class<?>, List<Class<Transcode>>> resourceClassToTranscodeClasses = new HashMap<>();, +, +, +        dataClassToResourceClasses.put(dataClass, registeredResourceClasses);, +, +, +          List<Class<Transcode>> registeredTranscodeClasses =, +              transcoderRegistry.getTranscodeClasses(registeredResourceClass, transcodeClass);, +, +          resourceClassToTranscodeClasses.put(registeredResourceClass, registeredTranscodeClasses);, +, +, +      // Throw the exception before populating the cache in the hopes that a subsequent attempt will, +      // succeed and only one request will randomly fail. This is really debugging logic that should, +      // go away when we find the actual cause for b/73882030., +      if (result.isEmpty() && !File.class.equals(transcodeClass)) {, +        if (dataClasses.isEmpty()) {, +          throw new IllegalStateException("Failed to find any data classes for: " + modelClass);, +        }, +, +        throw new IllegalStateException(, +            "Failed to find any resource or transcode classes for model: " + modelClass, +                + ", data to resource classes: " + dataClassToResourceClasses, +                + ", resource to transcode classes: " + resourceClassToTranscodeClasses);, +      }, +, +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +import java.io.File;, +import java.util.HashMap;, +import java.util.Map;, +, +      Map<Class<?>, List<? extends Class<?>>> dataClassToResourceClasses = new HashMap<>();, +      Map<Class<?>, List<Class<Transcode>>> resourceClassToTranscodeClasses = new HashMap<>();, +, +, +        dataClassToResourceClasses.put(dataClass, registeredResourceClasses);, +, +, +          List<Class<Transcode>> registeredTranscodeClasses =, +              transcoderRegistry.getTranscodeClasses(registeredResourceClass, transcodeClass);, +, +          resourceClassToTranscodeClasses.put(registeredResourceClass, registeredTranscodeClasses);, +, +, +      // Throw the exception before populating the cache in the hopes that a subsequent attempt will, +      // succeed and only one request will randomly fail. This is really debugging logic that should, +      // go away when we find the actual cause for b/73882030., +      if (result.isEmpty() && !File.class.equals(transcodeClass)) {, +        if (dataClasses.isEmpty()) {, +          throw new IllegalStateException("Failed to find any data classes for: " + modelClass);, +        }, +, +        throw new IllegalStateException(, +            "Failed to find any resource or transcode classes for model: " + modelClass, +                + ", data to resource classes: " + dataClassToResourceClasses, +                + ", resource to transcode classes: " + resourceClassToTranscodeClasses);, +      }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java, +      throw new IllegalStateException(, +         "Failed to find any load path from " + helper.getModelClass() + " to ", +             + helper.getTranscodeClass());]
[+++ b/library/src/androidTest/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java, +    public void testDoesNotClearThumbOnFullComplete_whenThumbIsComplete() {, +        when(thumb.isComplete()).thenReturn(true);, +        coordinator.onRequestSuccess(full);, +        verify(thumb, never()).clear();, +    }, +, +    @Test, +++ b/library/src/androidTest/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java, +    public void testDoesNotClearThumbOnFullComplete_whenThumbIsComplete() {, +        when(thumb.isComplete()).thenReturn(true);, +        coordinator.onRequestSuccess(full);, +        verify(thumb, never()).clear();, +    }, +, +    @Test, +++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java, +        // Clearing the thumb is not necessarily safe if the thumb is being displayed in the Target,, +        // as a layer in a cross fade for example. The only way we know the thumb is not being, +        // displayed and is therefore safe to clear is if the thumb request has not yet completed., +        if (!thumb.isComplete()) {, +    }]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +package com.bumptech.glide.load.resource.gif;, +, +import static android.support.test.InstrumentationRegistry.getTargetContext;, +import static com.google.common.truth.Truth.assertThat;, +import static org.junit.Assert.fail;, +import static org.junit.Assume.assumeTrue;, +, +import android.content.Context;, +import android.graphics.drawable.Drawable;, +import android.os.Build;, +import android.os.Handler;, +import android.os.Looper;, +import android.support.annotation.Nullable;, +import android.support.test.runner.AndroidJUnit4;, +import android.view.View;, +import android.view.WindowManager;, +import android.view.WindowManager.LayoutParams;, +import android.widget.ImageView;, +import com.bumptech.glide.load.DataSource;, +import com.bumptech.glide.load.engine.GlideException;, +import com.bumptech.glide.load.resource.gif.GifDrawable.GifState;, +import com.bumptech.glide.load.resource.gif.GifFrameLoader.OnEveryFrameListener;, +import com.bumptech.glide.request.RequestListener;, +import com.bumptech.glide.request.target.Target;, +import com.bumptech.glide.test.GlideApp;, +import com.bumptech.glide.test.ResourceIds;, +import com.bumptech.glide.test.TearDownGlide;, +import com.bumptech.glide.util.Preconditions;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.TimeUnit;, +import org.junit.Before;, +import org.junit.Rule;, +import org.junit.Test;, +import org.junit.rules.TestName;, +import org.junit.runner.RunWith;, +, +@RunWith(AndroidJUnit4.class), +public class GifDrawableTest {, +  @Rule public TestName testName = new TestName();, +  @Rule public TearDownGlide tearDownGlide = new TearDownGlide();, +  private Context context;, +  private Handler mainHandler;, +, +  @Before, +  public void setUp() {, +    // Required for us to add a View to a Window., +    assumeTrue(Build.VERSION.SDK_INT < Build.VERSION_CODES.M);, +, +    context = getTargetContext();, +    mainHandler = new Handler(Looper.getMainLooper());, +  }, +, +  @Test, +  public void loadGif_intoImageView_afterStop_restartsGif(), +      throws ExecutionException, InterruptedException {, +    // Mimic the state the Drawable can get into if it was loaded into a View previously and stopped, +    // so that it ended up with a pending frame that finished after the stop call., +    final GifDrawable gifDrawable = GlideApp.with(context), +        .asGif(), +        .load(ResourceIds.raw.dl_world_anim), +        .submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL), +        .get();, +    final CountDownLatch waitForGifFrame = new CountDownLatch(1);, +    // Starting/Stopping loads in GIFs must happen on the main thread., +    mainHandler.post(, +        new Runnable() {, +          @Override, +          public void run() {, +            // Make sure a frame is loaded while the drawable is stopped., +            GifState gifState =, +                (GifState) Preconditions.checkNotNull(gifDrawable.getConstantState());, +            gifState.frameLoader.setOnEveryFrameReadyListener(new OnEveryFrameListener() {, +              @Override, +              public void onFrameReady() {, +                waitForGifFrame.countDown();, +              }, +            });, +            gifDrawable.start();, +            gifDrawable.stop();, +          }, +        });, +    waitOrThrow(waitForGifFrame);, +, +    // Load the Drawable with the pending frame into a new View and make sure it ends up in the, +    // running state., +    final ImageView imageView = new ImageView(context);, +    final WaitForLoad<Drawable> waitForLoad = new WaitForLoad<>();, +    // Starting loads into Views must happen on the main thread., +    mainHandler, +        .post(new Runnable() {, +          @Override, +          public void run() {, +            addViewToWindow(imageView);, +            GlideApp.with(context), +                .load(gifDrawable), +                .listener(waitForLoad), +                .override(Target.SIZE_ORIGINAL), +                .into(imageView);]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java, +   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST} or, +   * {@link #CENTER_INSIDE}., +  public static final DownsampleStrategy FIT_CENTER = new FitCenter();, +   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST},, +   * or {@link #CENTER_INSIDE}., +   *, +   * <p>This method will not upscale.</p>, +  public static final DownsampleStrategy CENTER_INSIDE = new CenterInside();, +  private static class FitCenter extends DownsampleStrategy {, +  private static class CenterInside extends DownsampleStrategy {, +          FIT_CENTER.getScaleFactor(sourceWidth, sourceHeight, requestedWidth, requestedHeight));, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java, +   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST} or, +   * {@link #CENTER_INSIDE}., +  public static final DownsampleStrategy FIT_CENTER = new FitCenter();, +   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST},, +   * or {@link #CENTER_INSIDE}., +   *, +   * <p>This method will not upscale.</p>, +  public static final DownsampleStrategy CENTER_INSIDE = new CenterInside();, +  private static class FitCenter extends DownsampleStrategy {, +  private static class CenterInside extends DownsampleStrategy {, +          FIT_CENTER.getScaleFactor(sourceWidth, sourceHeight, requestedWidth, requestedHeight));, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +    return optionalTransform(context, DownsampleStrategy.FIT_CENTER, new FitCenter(context));, +    return transform(context, DownsampleStrategy.FIT_CENTER, new FitCenter(context));, +    return optionalTransform(context, DownsampleStrategy.CENTER_INSIDE, new CenterInside(context));, +    return transform(context, DownsampleStrategy.CENTER_INSIDE, new CenterInside(context));, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java, +   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST} or, +   * {@link #CENTER_INSIDE}., +  public static final DownsampleStrategy FIT_CENTER = new FitCenter();, +   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST},, +   * or {@link #CENTER_INSIDE}., +   *, +   * <p>This method will not upscale.</p>, +  public static final DownsampleStrategy CENTER_INSIDE = new CenterInside();, +  private static class FitCenter extends DownsampleStrategy {, +  private static class CenterInside extends DownsampleStrategy {, +          FIT_CENTER.getScaleFactor(sourceWidth, sourceHeight, requestedWidth, requestedHeight));, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +    return optionalTransform(context, DownsampleStrategy.FIT_CENTER, new FitCenter(context));, +    return transform(context, DownsampleStrategy.FIT_CENTER, new FitCenter(context));, +    return optionalTransform(context, DownsampleStrategy.CENTER_INSIDE, new CenterInside(context));, +    return transform(context, DownsampleStrategy.CENTER_INSIDE, new CenterInside(context));, +++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java, +    assertThat(DownsampleStrategy.FIT_CENTER.getScaleFactor(100, 200, 300, 300)), +    assertThat(DownsampleStrategy.FIT_CENTER.getScaleFactor(270, 480, 724, 440)), +    assertThat(DownsampleStrategy.FIT_CENTER.getScaleFactor(100, 100, 100, 100)).isEqualTo(1f);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java, +   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST} or, +   * {@link #CENTER_INSIDE}., +  public static final DownsampleStrategy FIT_CENTER = new FitCenter();, +   * and height. To avoid upscaling, use {@link #AT_LEAST}, {@link #AT_MOST},, +   * or {@link #CENTER_INSIDE}., +   *, +   * <p>This method will not upscale.</p>, +  public static final DownsampleStrategy CENTER_INSIDE = new CenterInside();, +  private static class FitCenter extends DownsampleStrategy {, +  private static class CenterInside extends DownsampleStrategy {, +          FIT_CENTER.getScaleFactor(sourceWidth, sourceHeight, requestedWidth, requestedHeight));, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +    return optionalTransform(context, DownsampleStrategy.FIT_CENTER, new FitCenter(context));, +    return transform(context, DownsampleStrategy.FIT_CENTER, new FitCenter(context));, +    return optionalTransform(context, DownsampleStrategy.CENTER_INSIDE, new CenterInside(context));, +    return transform(context, DownsampleStrategy.CENTER_INSIDE, new CenterInside(context));, +++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategyTest.java, +    assertThat(DownsampleStrategy.FIT_CENTER.getScaleFactor(100, 200, 300, 300)), +    assertThat(DownsampleStrategy.FIT_CENTER.getScaleFactor(270, 480, 724, 440)), +    assertThat(DownsampleStrategy.FIT_CENTER.getScaleFactor(100, 100, 100, 100)).isEqualTo(1f);, +++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/DownsamplerTest.java, +    DownsampleStrategy strategy = DownsampleStrategy.FIT_CENTER;]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java, +++ b/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java, +++ b/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java, +++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java, +++ b/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java, +++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java, +++ b/library/src/main/java/com/bumptech/glide/request/transition/BitmapContainerTransitionFactory.java, +++ b/samples/contacturi/src/main/java/com/bumptech/glide/samples/contacturi/MainActivity.java, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifFrame.java, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java]
[+++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +                //$CASES-OMITTED$, +                default:, +                    // silently ignore, +                    break;, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +                //$CASES-OMITTED$, +                default:, +                    // silently ignore, +                    break;, +++ b/library/src/main/java/com/bumptech/glide/load/Key.java, +    void updateDiskCacheKey(MessageDigest messageDigest) throws UnsupportedEncodingException;, +    /**, +     * {@inheritDoc}, +     */, +    boolean equals(Object o);, +, +    /**, +     * {@inheritDoc}, +     */, +    int hashCode();, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +                //$CASES-OMITTED$, +                default:, +                    // silently ignore, +                    break;, +++ b/library/src/main/java/com/bumptech/glide/load/Key.java, +    void updateDiskCacheKey(MessageDigest messageDigest) throws UnsupportedEncodingException;, +    /**, +     * {@inheritDoc}, +     */, +    boolean equals(Object o);, +, +    /**, +     * {@inheritDoc}, +     */, +    int hashCode();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    @SuppressWarnings("unused"), +    // Only used for debugging, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +                //$CASES-OMITTED$, +                default:, +                    // silently ignore, +                    break;, +++ b/library/src/main/java/com/bumptech/glide/load/Key.java, +    void updateDiskCacheKey(MessageDigest messageDigest) throws UnsupportedEncodingException;, +    /**, +     * {@inheritDoc}, +     */, +    boolean equals(Object o);, +, +    /**, +     * {@inheritDoc}, +     */, +    int hashCode();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    @SuppressWarnings("unused"), +    // Only used for debugging, +++ b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +                //$CASES-OMITTED$, +                default:, +                    // silently ignore, +                    break;, +++ b/library/src/main/java/com/bumptech/glide/load/Key.java, +    void updateDiskCacheKey(MessageDigest messageDigest) throws UnsupportedEncodingException;, +    /**, +     * {@inheritDoc}, +     */, +    boolean equals(Object o);, +, +    /**, +     * {@inheritDoc}, +     */, +    int hashCode();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    @SuppressWarnings("unused"), +    // Only used for debugging, +++ b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +                //$CASES-OMITTED$, +                default:, +                    // silently ignore, +                    break;, +++ b/library/src/main/java/com/bumptech/glide/load/Key.java, +    void updateDiskCacheKey(MessageDigest messageDigest) throws UnsupportedEncodingException;, +    /**, +     * {@inheritDoc}, +     */, +    boolean equals(Object o);, +]
[+++ b/README.md, +ProGuard, +Depending on your ProGuard (DexGuard) config and usage, you may need to include the following lines in your proguard.cfg (see [Configuration wiki](https://github.com/bumptech/glide/wiki/Configuration#keeping-a-glidemodule) for more details):, +-keepresourcexmlelements manifest/application/meta-data@value=GlideModule, +* **Dave Smith** for the [GIF decoder gist][9] Glide's GIF decoder is based on., +++ b/README.md, +ProGuard, +Depending on your ProGuard (DexGuard) config and usage, you may need to include the following lines in your proguard.cfg (see [Configuration wiki](https://github.com/bumptech/glide/wiki/Configuration#keeping-a-glidemodule) for more details):, +-keepresourcexmlelements manifest/application/meta-data@value=GlideModule, +* **Dave Smith** for the [GIF decoder gist][9] Glide's GIF decoder is based on., +++ b/build.gradle, +++ b/README.md, +ProGuard, +Depending on your ProGuard (DexGuard) config and usage, you may need to include the following lines in your proguard.cfg (see [Configuration wiki](https://github.com/bumptech/glide/wiki/Configuration#keeping-a-glidemodule) for more details):, +-keepresourcexmlelements manifest/application/meta-data@value=GlideModule, +* **Dave Smith** for the [GIF decoder gist][9] Glide's GIF decoder is based on., +++ b/build.gradle, +++ b/glide/build.gradle, +        classpath += getInternalJavaProjects().collect { files(it.configurations.compile) }.sum(), +++ b/README.md, +ProGuard, +Depending on your ProGuard (DexGuard) config and usage, you may need to include the following lines in your proguard.cfg (see [Configuration wiki](https://github.com/bumptech/glide/wiki/Configuration#keeping-a-glidemodule) for more details):, +-keepresourcexmlelements manifest/application/meta-data@value=GlideModule, +* **Dave Smith** for the [GIF decoder gist][9] Glide's GIF decoder is based on., +++ b/build.gradle, +++ b/glide/build.gradle, +        classpath += getInternalJavaProjects().collect { files(it.configurations.compile) }.sum(), +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +      Log.v(TAG, "Re-encoded GIF with " + drawable.getFrameCount() + " frames and ", +        Log.w(TAG, "Failed to write GIF data", e);, +++ b/README.md, +ProGuard, +Depending on your ProGuard (DexGuard) config and usage, you may need to include the following lines in your proguard.cfg (see [Configuration wiki](https://github.com/bumptech/glide/wiki/Configuration#keeping-a-glidemodule) for more details):, +-keepresourcexmlelements manifest/application/meta-data@value=GlideModule, +* **Dave Smith** for the [GIF decoder gist][9] Glide's GIF decoder is based on., +++ b/build.gradle, +++ b/glide/build.gradle, +        classpath += getInternalJavaProjects().collect { files(it.configurations.compile) }.sum(), +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +      Log.v(TAG, "Re-encoded GIF with " + drawable.getFrameCount() + " frames and ", +        Log.w(TAG, "Failed to write GIF data", e);, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +    // TODO Util.anyResource once Util is moved to testutil module (remove unchecked above!), +++ b/README.md, +ProGuard, +Depending on your ProGuard (DexGuard) config and usage, you may need to include the following lines in your proguard.cfg (see [Configuration wiki](https://github.com/bumptech/glide/wiki/Configuration#keeping-a-glidemodule) for more details):, +-keepresourcexmlelements manifest/application/meta-data@value=GlideModule, +* **Dave Smith** for the [GIF decoder gist][9] Glide's GIF decoder is based on., +++ b/build.gradle, +++ b/glide/build.gradle, +        classpath += getInternalJavaProjects().collect { files(it.configurations.compile) }.sum(), +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +      Log.v(TAG, "Re-encoded GIF with " + drawable.getFrameCount() + " frames and ", +        Log.w(TAG, "Failed to write GIF data", e);, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +    // TODO Util.anyResource once Util is moved to testutil module (remove unchecked above!), +++ b/library/build.gradle, +    if (JavaVersion.current() <= JavaVersion.VERSION_1_7) {, +        // Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=2048m; support was removed in 8.0, +}, +++ b/README.md, +ProGuard, +Depending on your ProGuard (DexGuard) config and usage, you may need to include the following lines in your proguard.cfg (see [Configuration wiki](https://github.com/bumptech/glide/wiki/Configuration#keeping-a-glidemodule) for more details):, +-keepresourcexmlelements manifest/application/meta-data@value=GlideModule, +* **Dave Smith** for the [GIF decoder gist][9] Glide's GIF decoder is based on., +++ b/build.gradle, +++ b/glide/build.gradle, +        classpath += getInternalJavaProjects().collect { files(it.configurations.compile) }.sum(), +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +      Log.v(TAG, "Re-encoded GIF with " + drawable.getFrameCount() + " frames and ", +        Log.w(TAG, "Failed to write GIF data", e);, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +    // TODO Util.anyResource once Util is moved to testutil module (remove unchecked above!), +++ b/library/build.gradle, +    if (JavaVersion.current() <= JavaVersion.VERSION_1_7) {, +        // Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=2048m; support was removed in 8.0, +}, +++ b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java, +++ b/README.md, +ProGuard, +Depending on your ProGuard (DexGuard) config and usage, you may need to include the following lines in your proguard.cfg (see [Configuration wiki](https://github.com/bumptech/glide/wiki/Configuration#keeping-a-glidemodule) for more details):, +-keepresourcexmlelements manifest/application/meta-data@value=GlideModule, +* **Dave Smith** for the [GIF decoder gist][9] Glide's GIF decoder is based on., +++ b/build.gradle, +++ b/glide/build.gradle, +        classpath += getInternalJavaProjects().collect { files(it.configurations.compile) }.sum(), +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +      Log.v(TAG, "Re-encoded GIF with " + drawable.getFrameCount() + " frames and ", +        Log.w(TAG, "Failed to write GIF data", e);, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +    // TODO Util.anyResource once Util is moved to testutil module (remove unchecked above!), +++ b/library/build.gradle, +    if (JavaVersion.current() <= JavaVersion.VERSION_1_7) {, +        // Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=2048m; support was removed in 8.0, +}, +++ b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        /* GIFs */, +        /* GIF Frames */, +++ b/README.md]
[+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +  public final CHILD onlyRetrieveFromCache(boolean flag) {, +      return clone().onlyRetrieveFromCache(flag);]
[+++ b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java, +import com.bumptech.glide.request.transition.TransitionFactory;, +import com.bumptech.glide.request.transition.ViewPropertyTransition;, +, +  /**, +   * Removes any existing animation put on the builder., +   *, +   * @see GenericTransitionOptions#dontTransition(), +   */, +, +  /**, +   * Returns a typed {@link GenericTransitionOptions} object that uses the given view animation., +   *, +   * @see GenericTransitionOptions#transition(int), +   */, +  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(, +      int viewAnimationId) {, +    return new GenericTransitionOptions<TranscodeType>().transition(viewAnimationId);, +  }, +, +  /**, +   * Returns a typed {@link GenericTransitionOptions} object that uses the given animator., +   *, +   * @see GenericTransitionOptions#transition(ViewPropertyTransition.Animator), +   */, +  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(, +      ViewPropertyTransition.Animator animator) {, +    return new GenericTransitionOptions<TranscodeType>().transition(animator);, +  }, +, +  /**, +   * Returns a typed {@link GenericTransitionOptions} object that uses the given transition factory., +   *, +   * @see GenericTransitionOptions#transition(TransitionFactory), +   */, +  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(, +      TransitionFactory<? super TranscodeType> transitionFactory) {, +    return new GenericTransitionOptions<TranscodeType>().transition(transitionFactory);, +  }, +++ b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java, +import com.bumptech.glide.request.transition.TransitionFactory;, +import com.bumptech.glide.request.transition.ViewPropertyTransition;, +, +  /**, +   * Removes any existing animation put on the builder., +   *, +   * @see GenericTransitionOptions#dontTransition(), +   */, +, +  /**, +   * Returns a typed {@link GenericTransitionOptions} object that uses the given view animation., +   *, +   * @see GenericTransitionOptions#transition(int), +   */, +  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(, +      int viewAnimationId) {, +    return new GenericTransitionOptions<TranscodeType>().transition(viewAnimationId);, +  }, +, +  /**, +   * Returns a typed {@link GenericTransitionOptions} object that uses the given animator., +   *, +   * @see GenericTransitionOptions#transition(ViewPropertyTransition.Animator), +   */, +  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(, +      ViewPropertyTransition.Animator animator) {, +    return new GenericTransitionOptions<TranscodeType>().transition(animator);, +  }, +, +  /**, +   * Returns a typed {@link GenericTransitionOptions} object that uses the given transition factory., +   *, +   * @see GenericTransitionOptions#transition(TransitionFactory), +   */, +  public static <TranscodeType> GenericTransitionOptions<TranscodeType> with(, +      TransitionFactory<? super TranscodeType> transitionFactory) {, +    return new GenericTransitionOptions<TranscodeType>().transition(transitionFactory);, +  }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.java, +package com.bumptech.glide.load.resource.bitmap;, +, +import android.graphics.Bitmap;, +import android.graphics.drawable.Drawable;, +, +import com.bumptech.glide.TransitionOptions;, +import com.bumptech.glide.request.transition.BitmapTransitionFactory;, +import com.bumptech.glide.request.transition.DrawableCrossFadeFactory;, +import com.bumptech.glide.request.transition.TransitionFactory;, +, +/**, + * Contains {@link Bitmap} specific animation options., + */, +public final class BitmapTransitionOptions extends, +    TransitionOptions<BitmapTransitionOptions, Bitmap> {, +, +  /**, +   * Returns a {@link BitmapTransitionOptions} object that enables a cross fade animation., +   *, +   * @see #crossFade(), +   */]
[+++ b/README.md, +  compile 'com.github.bumptech.glide:glide:4.0.0-RC0', +  compile 'com.android.support:support-v4:25.3.1', +  <version>4.0.0-RC0</version>, +++ b/README.md, +  compile 'com.github.bumptech.glide:glide:4.0.0-RC0', +  compile 'com.android.support:support-v4:25.3.1', +  <version>4.0.0-RC0</version>, +++ b/gradle.properties, +VERSION_NAME=4.0.0-RC0]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java, +   * Caches remote data with both {@link #DATA} and {@link #RESOURCE}, and local data with, +   * {@link #RESOURCE} only., +      return dataSource == DataSource.REMOTE;]
[+++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +++ b/library/libs/hamcrest-core-1.3.jar, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +++ b/library/libs/hamcrest-core-1.3.jar, +++ b/library/libs/junit-4.11.jar, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +++ b/library/libs/hamcrest-core-1.3.jar, +++ b/library/libs/junit-4.11.jar, +++ b/library/libs/mockito-all-1.9.5.jar, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +++ b/library/libs/hamcrest-core-1.3.jar, +++ b/library/libs/junit-4.11.jar, +++ b/library/libs/mockito-all-1.9.5.jar, +++ b/library/libs/robolectric-2.3-jar-with-dependencies.jar, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +++ b/library/libs/hamcrest-core-1.3.jar, +++ b/library/libs/junit-4.11.jar, +++ b/library/libs/mockito-all-1.9.5.jar, +++ b/library/libs/robolectric-2.3-jar-with-dependencies.jar, +++ b/library/pom.xml, +, +  <parent>, +    <groupId>org.sonatype.oss</groupId>, +    <artifactId>oss-parent</artifactId>, +    <version>7</version>, +  </parent>, +, +      <groupId>android.support</groupId>, +      <artifactId>compatibility-v4</artifactId>, +      <version>19.1.0</version>, +    </dependency>, +    <dependency>, +      <groupId>org.roboguice</groupId>, +      <artifactId>roboguice</artifactId>, +      <version>2.0</version>, +    </dependency>, +    <dependency>, +      <groupId>org.apache.httpcomponents</groupId>, +      <artifactId>httpclient</artifactId>, +      <version>4.0.1</version>, +    </dependency>, +    <dependency>, +      <groupId>junit</groupId>, +      <artifactId>junit</artifactId>, +      <version>4.11</version>, +      <scope>test</scope>, +    </dependency>, +    <dependency>, +      <groupId>android</groupId>, +      <version>4.4.2_r3</version>, +    <dependency>, +      <groupId>org.robolectric</groupId>, +      <artifactId>robolectric</artifactId>, +      <version>2.4-SNAPSHOT</version>, +      <scope>test</scope>, +    </dependency>, +    <dependency>, +      <groupId>org.hamcrest</groupId>, +      <artifactId>hamcrest-core</artifactId>, +      <version>1.2</version>, +      <scope>test</scope>, +    </dependency>, +    <dependency>, +      <groupId>org.mockito</groupId>, +      <artifactId>mockito-all</artifactId>, +      <version>1.9.5</version>, +    </dependency>, +        <version>3.9.0-rc.1</version>, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +++ b/library/libs/hamcrest-core-1.3.jar, +++ b/library/libs/junit-4.11.jar, +++ b/library/libs/mockito-all-1.9.5.jar, +++ b/library/libs/robolectric-2.3-jar-with-dependencies.jar, +++ b/library/pom.xml, +, +  <parent>, +    <groupId>org.sonatype.oss</groupId>, +    <artifactId>oss-parent</artifactId>, +    <version>7</version>, +  </parent>, +, +      <groupId>android.support</groupId>, +      <artifactId>compatibility-v4</artifactId>, +      <version>19.1.0</version>, +    </dependency>]
[+++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +import java.util.Arrays;, +import java.util.Collection;, + * A transformation that applies one or more transformations in iteration order to a resource., +    private Collection<? extends Transformation<T>> transformations;, +    @SafeVarargs, +        this.transformations = Arrays.asList(transformations);, +    public MultiTransformation(Collection<? extends Transformation<T>> transformationList) {, +        this.transformations = transformationList;, +            for (Transformation<T> transformation : transformations) {]
[+++ b/library/src/main/java/com/bumptech/glide/GeneratedAppGlideModule.java, + * Allows {@link AppGlideModule}s to exclude {@link com.bumptech.glide.annotation.GlideModule}s to, + * ease the migration from {@link com.bumptech.glide.annotation.GlideModule}s to Glide's annotation, + * processing system and optionally provides a, + * {@link com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory} impl.]
[+++ b/samples/gallery/build.gradle, +apply plugin: 'com.android.application', +, +dependencies {, +    compile project(':library'), +    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}", +    compile "com.android.support:recyclerview-v7:21.0.3", +}, +, +android {, +    compileSdkVersion 21, +    buildToolsVersion "21.1.2", +, +    defaultConfig {, +        applicationId 'com.bumptech.glide.samples.gallery', +        minSdkVersion 19, +        targetSdkVersion 21, +        versionCode 1, +        versionName "1.0", +    }, +, +    compileOptions {, +        sourceCompatibility JavaVersion.VERSION_1_7, +        targetCompatibility JavaVersion.VERSION_1_7, +    }, +}, +, +task run(type: Exec, dependsOn: 'installDebug') {, +    description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"', +    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.flickr/.FlickrSearchActivity', +}, +++ b/samples/gallery/build.gradle, +apply plugin: 'com.android.application', +, +dependencies {, +    compile project(':library'), +    compile "com.android.support:support-v4:${SUPPORT_V4_VERSION}", +    compile "com.android.support:recyclerview-v7:21.0.3", +}, +, +android {, +    compileSdkVersion 21, +    buildToolsVersion "21.1.2", +, +    defaultConfig {, +        applicationId 'com.bumptech.glide.samples.gallery', +        minSdkVersion 19, +        targetSdkVersion 21, +        versionCode 1, +        versionName "1.0", +    }, +, +    compileOptions {, +        sourceCompatibility JavaVersion.VERSION_1_7, +        targetCompatibility JavaVersion.VERSION_1_7, +    }, +}, +, +task run(type: Exec, dependsOn: 'installDebug') {, +    description 'Installs the APK and runs the main activity: "gradlew :samples:???:run"', +    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.flickr/.FlickrSearchActivity', +}, +++ b/samples/gallery/gallery.iml, +<?xml version="1.0" encoding="UTF-8"?>, +<module external.linked.project.id=":samples:gallery" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" external.system.module.group="glide-parent.samples" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +  <component name="FacetManager">, +    <facet type="android-gradle" name="Android-Gradle">, +      <configuration>, +        <option name="GRADLE_PROJECT_PATH" value=":samples:gallery" />, +      </configuration>, +    </facet>, +    <facet type="android" name="Android">, +      <configuration>, +        <option name="SELECTED_BUILD_VARIANT" value="debug" />, +        <option name="SELECTED_TEST_ARTIFACT" value="_android_test_" />, +        <option name="ASSEMBLE_TASK_NAME" value="assembleDebug" />, +        <option name="COMPILE_JAVA_TASK_NAME" value="compileDebugSources" />, +        <option name="ASSEMBLE_TEST_TASK_NAME" value="assembleDebugTest" />, +        <option name="SOURCE_GEN_TASK_NAME" value="generateDebugSources" />, +        <option name="TEST_SOURCE_GEN_TASK_NAME" value="generateDebugTestSources" />, +        <option name="ALLOW_USER_CONFIGURATION" value="false" />, +        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/src/main/AndroidManifest.xml" />, +        <option name="RES_FOLDER_RELATIVE_PATH" value="/src/main/res" />, +        <option name="RES_FOLDERS_RELATIVE_PATH" value="file://$MODULE_DIR$/src/main/res" />, +        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/src/main/assets" />, +      </configuration>, +    </facet>, +  </component>, +  <component name="NewModuleRootManager" inherit-compiler-output="false">, +    <output url="file://$MODULE_DIR$/build/intermediates/classes/debug" />, +    <output-test url="file://$MODULE_DIR$/build/intermediates/classes/test/debug" />, +    <exclude-output />, +    <content url="file://$MODULE_DIR$">, +      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/debug" isTestSource="false" generated="true" />, +      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/aidl/debug" isTestSource="false" generated="true" />, +      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/buildConfig/debug" isTestSource="false" generated="true" />, +      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/rs/debug" isTestSource="false" generated="true" />, +      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/rs/debug" type="java-resource" />, +      <sourceFolder url="file://$MODULE_DIR$/build/generated/res/generated/debug" type="java-resource" />, +      <sourceFolder url="file://$MODULE_DIR$/build/generated/source/r/test/debug" isTestSource="true" generated="true" />]
[+++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java, +        return request == full && !isAnyRequestComplete();, +++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java, +        return request == full && !isAnyRequestComplete();, +++ b/library/src/test/java/com/bumptech/glide/request/GenericRequestTest.java, +    public void testCallsEngineWithOverrideWidthAndHeightIfSet() {, +    @Test, +    public void testDoesNotSetErrorDrawableIfRequestCoordinatorDoesntAllowIt() {, +        harness.errorDrawable = new ColorDrawable(Color.RED);, +        GenericRequest<Object, Object, Object, Object> request = harness.getRequest();, +        when(harness.requestCoordinator.canSetPlaceholder(any(Request.class))).thenReturn(false);, +        request.onException(new IOException("Test"));, +, +        verify(harness.target, never()).setPlaceholder(any(Drawable.class));, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java, +        return request == full && !isAnyRequestComplete();, +++ b/library/src/test/java/com/bumptech/glide/request/GenericRequestTest.java, +    public void testCallsEngineWithOverrideWidthAndHeightIfSet() {, +    @Test, +    public void testDoesNotSetErrorDrawableIfRequestCoordinatorDoesntAllowIt() {, +        harness.errorDrawable = new ColorDrawable(Color.RED);, +        GenericRequest<Object, Object, Object, Object> request = harness.getRequest();, +        when(harness.requestCoordinator.canSetPlaceholder(any(Request.class))).thenReturn(false);, +        request.onException(new IOException("Test"));, +, +        verify(harness.target, never()).setPlaceholder(any(Drawable.class));, +    }, +, +++ b/library/src/test/java/com/bumptech/glide/request/ThumbnailRequestCoordinatorTest.java, +, +    @Test, +    public void testDoesNotAllowThumbToSetPlaceholder() {, +        assertFalse(coordinator.canSetPlaceholder(thumb));, +    }, +, +    @Test, +    public void testAllowsFullToSetPlaceholder() {, +        assertTrue(coordinator.canSetPlaceholder(full));, +    }, +, +    @Test, +    public void testDoesNotAllowFullToSetPlaceholderIfThumbComplete() {, +        when(thumb.isComplete()).thenReturn(true);, +        assertFalse(coordinator.canSetPlaceholder(full));, +    }]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +        case CENTER_INSIDE:, +          requestOptions.optionalCenterInside(context);, +          break;, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +        case CENTER_INSIDE:, +          requestOptions.optionalCenterInside(context);, +          break;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java, +package com.bumptech.glide.load.resource.bitmap;, +, +import android.content.Context;, +import android.graphics.Bitmap;, +import android.support.annotation.NonNull;, +, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +, +import java.security.MessageDigest;, +, +/**, + * Returns the image with its original size if its dimensions match or are smaller, + * than the target's, couple with {@link android.widget.ImageView.ScaleType#CENTER_INSIDE}, + * in order to center it in Target. If not, then it is scaled so that one of the dimensions of, + * the image will be equal to the given dimension and the other will be less than the given, + * dimension (maintaining the image's aspect ratio)., + */, +public class CenterInside extends BitmapTransformation {, +  private static final String ID = "com.bumptech.glide.load.resource.bitmap.CenterInside";, +  private static final byte[] ID_BYTES = ID.getBytes(CHARSET);, +, +  public CenterInside(Context context) {, +    super(context);, +  }, +, +  public CenterInside(BitmapPool bitmapPool) {, +    super(bitmapPool);, +  }, +, +  @Override, +  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,, +      int outHeight) {, +    return TransformationUtils.centerInside(pool, toTransform, outWidth, outHeight);, +  }, +, +  @Override, +  public boolean equals(Object o) {, +    return o instanceof CenterInside;, +  }, +, +  @Override, +  public int hashCode() {, +    return ID.hashCode();, +  }, +, +  @Override, +  public void updateDiskCacheKey(MessageDigest messageDigest) {, +    messageDigest.update(ID_BYTES);, +  }, +}, +, +, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +        case CENTER_INSIDE:, +          requestOptions.optionalCenterInside(context);, +          break;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterInside.java, +package com.bumptech.glide.load.resource.bitmap;, +, +import android.content.Context;, +import android.graphics.Bitmap;, +import android.support.annotation.NonNull;, +, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +, +import java.security.MessageDigest;, +, +/**, + * Returns the image with its original size if its dimensions match or are smaller, + * than the target's, couple with {@link android.widget.ImageView.ScaleType#CENTER_INSIDE}, + * in order to center it in Target. If not, then it is scaled so that one of the dimensions of, + * the image will be equal to the given dimension and the other will be less than the given, + * dimension (maintaining the image's aspect ratio)., + */, +public class CenterInside extends BitmapTransformation {, +  private static final String ID = "com.bumptech.glide.load.resource.bitmap.CenterInside";, +  private static final byte[] ID_BYTES = ID.getBytes(CHARSET);, +, +  public CenterInside(Context context) {, +    super(context);, +  }, +, +  public CenterInside(BitmapPool bitmapPool) {, +    super(bitmapPool);, +  }, +, +  @Override, +  protected Bitmap transform(@NonNull BitmapPool pool, @NonNull Bitmap toTransform, int outWidth,, +      int outHeight) {, +    return TransformationUtils.centerInside(pool, toTransform, outWidth, outHeight);, +  }]
[+++ b/.gitignore, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +samples/flickr/target, +++ b/.gitignore, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +samples/flickr/target, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/.gitignore, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +samples/flickr/target, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/LICENSE, +Copyright 2014 Google, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY GOOGLE, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE, INC. OR, +or implied, of Google, Inc., +++ b/.gitignore, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +samples/flickr/target, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/LICENSE, +Copyright 2014 Google, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY GOOGLE, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE, INC. OR, +or implied, of Google, Inc., +++ b/Makefile, +	cp -f third_party/disklrucache/disklrucache*.jar library/libs, +	cd third_party/gif_decoder && ant clean && ant jar, +	cp -f third_party/gif_decoder/bin/gifdecoder*.jar library/libs, +	cd third_party/volley/volley && ant clean && ant jar, +	cp -f third_party/volley/volley/bin/volley.jar library/libs, +++ b/.gitignore, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +samples/flickr/target, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/LICENSE, +Copyright 2014 Google, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY GOOGLE, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE, INC. OR, +or implied, of Google, Inc., +++ b/Makefile, +	cp -f third_party/disklrucache/disklrucache*.jar library/libs, +	cd third_party/gif_decoder && ant clean && ant jar, +	cp -f third_party/gif_decoder/bin/gifdecoder*.jar library/libs, +	cd third_party/volley/volley && ant clean && ant jar, +	cp -f third_party/volley/volley/bin/volley.jar library/libs, +++ b/library/.gitignore, +libs/gifdecoder*.jar, +libs/disklrucache*.jar, +++ b/.gitignore, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +samples/flickr/target, +++ b/.gitmodules, +[submodule "library/src/test/resources/exif-orientation-examples"], +	path = library/src/test/resources/exif-orientation-examples, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/LICENSE, +Copyright 2014 Google, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY GOOGLE, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE, INC. OR, +or implied, of Google, Inc., +++ b/Makefile, +	cp -f third_party/disklrucache/disklrucache*.jar library/libs, +	cd third_party/gif_decoder && ant clean && ant jar, +	cp -f third_party/gif_decoder/bin/gifdecoder*.jar library/libs, +	cd third_party/volley/volley && ant clean && ant jar, +	cp -f third_party/volley/volley/bin/volley.jar library/libs, +++ b/library/.gitignore, +libs/gifdecoder*.jar, +libs/disklrucache*.jar, +++ b/library/AndroidManifest.xml, +          android:versionCode="5"]
[+++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java, +      request.clear();, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java, +      request.clear();, +++ b/library/test/src/test/java/com/bumptech/glide/manager/RequestTrackerTest.java, +  public void runRequest_withAllRequestsPaused_doesNotStartRequest() {, +    FakeRequest request = new FakeRequest();, +    tracker.pauseAllRequests();, +    tracker.runRequest(request);, +, +    assertThat(request.isRunning()).isFalse();, +  }, +, +  @Test]
[+++ b/library/src/com/bumptech/glide/resize/ImageManager.java, +        final String key = task.getId();, +++ b/library/src/com/bumptech/glide/resize/ImageManager.java, +        final String key = task.getId();, +++ b/library/src/com/bumptech/glide/resize/SafeKeyGenerator.java, +++ b/library/src/com/bumptech/glide/resize/ImageManager.java, +        final String key = task.getId();, +++ b/library/src/com/bumptech/glide/resize/SafeKeyGenerator.java, +++ b/library/src/com/bumptech/glide/resize/cache/DiskLruCacheWrapper.java, +import com.bumptech.glide.resize.SafeKeyGenerator;, +    private final SafeKeyGenerator safeKeyGenerator;, +        this.safeKeyGenerator = new SafeKeyGenerator();, +        String safeKey = safeKeyGenerator.getSafeKey(key);, +            final DiskLruCache.Snapshot snapshot = diskLruCache.get(safeKey);, +        String safeKey = safeKeyGenerator.getSafeKey(key);, +            DiskLruCache.Editor editor = diskLruCache.edit(safeKey);, +        String safeKey = safeKeyGenerator.getSafeKey(key);, +            diskLruCache.remove(safeKey);, +++ b/library/src/com/bumptech/glide/resize/ImageManager.java, +        final String key = task.getId();, +++ b/library/src/com/bumptech/glide/resize/SafeKeyGenerator.java, +++ b/library/src/com/bumptech/glide/resize/cache/DiskLruCacheWrapper.java, +import com.bumptech.glide.resize.SafeKeyGenerator;, +    private final SafeKeyGenerator safeKeyGenerator;, +        this.safeKeyGenerator = new SafeKeyGenerator();, +        String safeKey = safeKeyGenerator.getSafeKey(key);, +            final DiskLruCache.Snapshot snapshot = diskLruCache.get(safeKey);, +        String safeKey = safeKeyGenerator.getSafeKey(key);, +            DiskLruCache.Editor editor = diskLruCache.edit(safeKey);, +        String safeKey = safeKeyGenerator.getSafeKey(key);, +            diskLruCache.remove(safeKey);, +++ /dev/null, +++ b/library/src/com/bumptech/glide/resize/ImageManager.java, +        final String key = task.getId();, +++ b/library/src/com/bumptech/glide/resize/SafeKeyGenerator.java, +++ b/library/src/com/bumptech/glide/resize/cache/DiskLruCacheWrapper.java, +import com.bumptech.glide.resize.SafeKeyGenerator;, +    private final SafeKeyGenerator safeKeyGenerator;, +        this.safeKeyGenerator = new SafeKeyGenerator();, +        String safeKey = safeKeyGenerator.getSafeKey(key);, +            final DiskLruCache.Snapshot snapshot = diskLruCache.get(safeKey);, +        String safeKey = safeKeyGenerator.getSafeKey(key);, +            DiskLruCache.Editor editor = diskLruCache.edit(safeKey);, +        String safeKey = safeKeyGenerator.getSafeKey(key);, +            diskLruCache.remove(safeKey);, +++ /dev/null, +++ b/library/src/com/bumptech/glide/volley/RequestQueueWrapper.java, +import com.bumptech.glide.resize.cache.DiskCache;, +        DiskCache diskCache = Glide.get().getImageManager(context).getDiskCache();, +        VolleyDiskCacheWrapper volleyCache = new VolleyDiskCacheWrapper(diskCache);, +, +        RequestQueue queue = new RequestQueue(volleyCache, network);, +++ b/library/src/com/bumptech/glide/resize/ImageManager.java, +        final String key = task.getId();, +++ b/library/src/com/bumptech/glide/resize/SafeKeyGenerator.java, +++ b/library/src/com/bumptech/glide/resize/cache/DiskLruCacheWrapper.java, +import com.bumptech.glide.resize.SafeKeyGenerator;, +    private final SafeKeyGenerator safeKeyGenerator;, +        this.safeKeyGenerator = new SafeKeyGenerator();, +        String safeKey = safeKeyGenerator.getSafeKey(key);, +            final DiskLruCache.Snapshot snapshot = diskLruCache.get(safeKey);, +        String safeKey = safeKeyGenerator.getSafeKey(key);, +            DiskLruCache.Editor editor = diskLruCache.edit(safeKey);, +        String safeKey = safeKeyGenerator.getSafeKey(key);, +            diskLruCache.remove(safeKey);, +++ /dev/null, +++ b/library/src/com/bumptech/glide/volley/RequestQueueWrapper.java, +import com.bumptech.glide.resize.cache.DiskCache;, +        DiskCache diskCache = Glide.get().getImageManager(context).getDiskCache();, +        VolleyDiskCacheWrapper volleyCache = new VolleyDiskCacheWrapper(diskCache);, +, +        RequestQueue queue = new RequestQueue(volleyCache, network);, +++ b/library/src/com/bumptech/glide/volley/VolleyDiskCacheWrapper.java, +package com.bumptech.glide.volley;, +, +import android.util.Log;, +import com.android.volley.Cache;, +import com.android.volley.toolbox.ByteArrayPool;, +import com.android.volley.toolbox.DiskBasedCache;, +import com.android.volley.toolbox.PoolingByteArrayOutputStream;, +import com.bumptech.glide.resize.cache.DiskCache;, +, +import java.io.EOFException;, +import java.io.IOException;, +import java.io.InputStream;, +import java.io.OutputStream;, +import java.util.Collections;, +import java.util.HashMap;, +import java.util.Map;, +, +/**, + * Closely based on {@link DiskBasedCache}., + */, +public class VolleyDiskCacheWrapper implements Cache {, +    private static final String TAG = "VolleyDiskCacheWrapper";, +    /** Magic number for current version of cache file format. */, +    private static final int CACHE_MAGIC = 0x20120504;, +    // 2 mb., +    private static final int BYTE_POOL_SIZE = 2 * 1024 * 1024;, +    // 8 kb.]
[+++ b/.idea/codeStyleSettings.xml, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +  <component name="NewModuleRootManager" inherit-compiler-output="false">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +  <component name="NewModuleRootManager" inherit-compiler-output="false">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +  <component name="NewModuleRootManager" inherit-compiler-output="false">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" isTestSource="false" />, +      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" isTestSource="true" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +  <component name="NewModuleRootManager" inherit-compiler-output="false">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" isTestSource="false" />, +      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" isTestSource="true" />, +++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MAJOR=3, +VERSION_MINOR=6, +SUPPORT_V4_VERSION=19.1.0, +SUPPORT_V7_VERSION=19.1.0, +# TODO: Upgrade to latest version of Volley when we compile with Java 7., +VOLLEY_VERSION=1.0.8, +ANDROID_GRADLE_VERSION=1.0.0, +ROBOLECTRIC_GRADLE_VERSION=0.14.0, +ROBOLECTRIC_VERSION=2.4, +MOCKWEBSERVER_VERSION=1.6.0, +COMPILE_SDK_VERSION=19, +BUILD_TOOLS_VERSION=19.1.0, +TARGET_SDK_VERSION=19, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java]
[+++ b/library/src/main/java/com/bumptech/glide/DrawableOptions.java, +     * Scheduled to be removed in Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/DrawableOptions.java, +     * Scheduled to be removed in Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +     * {@link #animate(com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator)}. Scheduled to be removed in, +     * Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/DrawableOptions.java, +     * Scheduled to be removed in Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +     * {@link #animate(com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator)}. Scheduled to be removed in, +     * Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +     * @deprecated Use {@link #loadFromMediaStore(android.net.Uri)},, +     * {@link com.bumptech.glide.signature.MediaStoreSignature}, and, +     * {@link com.bumptech.glide.DrawableRequestBuilder#signature(com.bumptech.glide.load.Key)} instead. Scheduled to be, +     * removed in Glide 4.0., +    @Deprecated, +     * {@link com.bumptech.glide.GenericRequestBuilder#signature(com.bumptech.glide.load.Key)} instead. Scheduled to be, +     * removed in Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/DrawableOptions.java, +     * Scheduled to be removed in Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +     * {@link #animate(com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator)}. Scheduled to be removed in, +     * Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +     * @deprecated Use {@link #loadFromMediaStore(android.net.Uri)},, +     * {@link com.bumptech.glide.signature.MediaStoreSignature}, and, +     * {@link com.bumptech.glide.DrawableRequestBuilder#signature(com.bumptech.glide.load.Key)} instead. Scheduled to be, +     * removed in Glide 4.0., +    @Deprecated, +     * {@link com.bumptech.glide.GenericRequestBuilder#signature(com.bumptech.glide.load.Key)} instead. Scheduled to be, +     * removed in Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/load/model/GenericLoaderFactory.java, +     * @deprecated Use {@link #buildModelLoader(Class, Class)} instead. Scheduled to be removed in Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/DrawableOptions.java, +     * Scheduled to be removed in Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +     * {@link #animate(com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator)}. Scheduled to be removed in, +     * Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +     * @deprecated Use {@link #loadFromMediaStore(android.net.Uri)},, +     * {@link com.bumptech.glide.signature.MediaStoreSignature}, and, +     * {@link com.bumptech.glide.DrawableRequestBuilder#signature(com.bumptech.glide.load.Key)} instead. Scheduled to be, +     * removed in Glide 4.0., +    @Deprecated, +     * {@link com.bumptech.glide.GenericRequestBuilder#signature(com.bumptech.glide.load.Key)} instead. Scheduled to be, +     * removed in Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/load/model/GenericLoaderFactory.java, +     * @deprecated Use {@link #buildModelLoader(Class, Class)} instead. Scheduled to be removed in Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/load/model/stream/StreamByteArrayLoader.java, +     * and the empty constructor instead. Scheduled to be removed in Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/DrawableOptions.java, +     * Scheduled to be removed in Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +     * {@link #animate(com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator)}. Scheduled to be removed in, +     * Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +     * @deprecated Use {@link #loadFromMediaStore(android.net.Uri)},, +     * {@link com.bumptech.glide.signature.MediaStoreSignature}, and, +     * {@link com.bumptech.glide.DrawableRequestBuilder#signature(com.bumptech.glide.load.Key)} instead. Scheduled to be, +     * removed in Glide 4.0., +    @Deprecated, +     * {@link com.bumptech.glide.GenericRequestBuilder#signature(com.bumptech.glide.load.Key)} instead. Scheduled to be, +     * removed in Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/load/model/GenericLoaderFactory.java, +     * @deprecated Use {@link #buildModelLoader(Class, Class)} instead. Scheduled to be removed in Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/load/model/stream/StreamByteArrayLoader.java, +     * and the empty constructor instead. Scheduled to be removed in Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java, +    /**, +     * Constructor for {@link com.bumptech.glide.signature.MediaStoreSignature}., +     *, +     * @param mimeType The mime type of the media store media. Ok to default to empty string "". See, +     *      {@link android.provider.MediaStore.Images.ImageColumns#MIME_TYPE} or, +     *      {@link android.provider.MediaStore.Video.VideoColumns#MIME_TYPE}., +     * @param dateModified The date modified time of the media store media. Ok to default to 0. See, +     *      {@link android.provider.MediaStore.Images.ImageColumns#DATE_MODIFIED} or, +     *      {@link android.provider.MediaStore.Video.VideoColumns#DATE_MODIFIED}., +     * @param orientation The orientation of the media store media. Ok to default to 0. See, +     *      {@link android.provider.MediaStore.Images.ImageColumns#ORIENTATION}., +     */, +++ b/library/src/main/java/com/bumptech/glide/DrawableOptions.java, +     * Scheduled to be removed in Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +     * {@link #animate(com.bumptech.glide.request.animation.ViewPropertyAnimation.Animator)}. Scheduled to be removed in, +     * Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +     * @deprecated Use {@link #loadFromMediaStore(android.net.Uri)},, +     * {@link com.bumptech.glide.signature.MediaStoreSignature}, and, +     * {@link com.bumptech.glide.DrawableRequestBuilder#signature(com.bumptech.glide.load.Key)} instead. Scheduled to be, +     * removed in Glide 4.0., +    @Deprecated, +     * {@link com.bumptech.glide.GenericRequestBuilder#signature(com.bumptech.glide.load.Key)} instead. Scheduled to be, +     * removed in Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/load/model/GenericLoaderFactory.java, +     * @deprecated Use {@link #buildModelLoader(Class, Class)} instead. Scheduled to be removed in Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/load/model/stream/StreamByteArrayLoader.java, +     * and the empty constructor instead. Scheduled to be removed in Glide 4.0., +++ b/library/src/main/java/com/bumptech/glide/signature/MediaStoreSignature.java]
[+++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java, +import android.util.Log;, +, +    private static final String TAG = "StreamEncoder";, +            int read;, +        } catch (IOException e) {, +            if (Log.isLoggable(TAG, Log.ERROR)) {, +                Log.v(TAG, "Failed to encode data onto the OutputStream", e);, +            }, +            return false;, +        } finally {, +            ByteArrayPool.get().releaseBytes(buffer);, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java, +import android.util.Log;, +, +    private static final String TAG = "StreamEncoder";, +            int read;, +        } catch (IOException e) {, +            if (Log.isLoggable(TAG, Log.ERROR)) {, +                Log.v(TAG, "Failed to encode data onto the OutputStream", e);, +            }, +            return false;, +        } finally {, +            ByteArrayPool.get().releaseBytes(buffer);, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +     * <p>, +     *     Note - this method will throw an exception of a Bitmap with dimensions not matching, +     *     those of the image for the given InputStream is provided., +     * </p>, +     * @param is An {@link InputStream} to the data for the image, +    @SuppressWarnings("resource"), +    // see BitmapDecoder.decode, +        final byte[] bytesForOptions = byteArrayPool.getBytes();, +        final byte[] bytesForStream = byteArrayPool.getBytes();, +        final BitmapFactory.Options options = getDefaultOptions();, +        final RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, bytesForStream);, +        try {, +                if (Log.isLoggable(TAG, Log.WARN)) {, +                    Log.w(TAG, "Cannot determine the image orientation from header", e);, +            } finally {, +                    if (Log.isLoggable(TAG, Log.WARN)) {, +                        Log.w(TAG, "Cannot reset the input stream", e);, +                    }, +                }, +            final Bitmap downsampled =, +                    downsampleWithSize(bis, options, pool, inWidth, inHeight, sampleSize, decodeFormat);, +            return rotated;, +        } finally {, +        }, +            if (Log.isLoggable(TAG, Log.WARN)) {, +                Log.w(TAG, "Cannot determine the image type from header", e);, +            }, +                if (Log.isLoggable(TAG, Log.WARN)) {, +                    Log.w(TAG, "Cannot reset the input stream", e);, +                }, +            if (Log.isLoggable(TAG, Log.WARN)) {, +                Log.w(TAG, "Cannot determine whether the image has alpha or not from header for format " + format, e);, +            }, +                if (Log.isLoggable(TAG, Log.WARN)) {, +                    Log.w(TAG, "Cannot reset the input stream", e);, +                }, +++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java, +import android.util.Log;, +, +    private static final String TAG = "StreamEncoder";, +            int read;, +        } catch (IOException e) {, +            if (Log.isLoggable(TAG, Log.ERROR)) {, +                Log.v(TAG, "Failed to encode data onto the OutputStream", e);, +            }, +            return false;, +        } finally {, +            ByteArrayPool.get().releaseBytes(buffer);, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +     * <p>, +     *     Note - this method will throw an exception of a Bitmap with dimensions not matching, +     *     those of the image for the given InputStream is provided., +     * </p>, +     * @param is An {@link InputStream} to the data for the image, +    @SuppressWarnings("resource"), +    // see BitmapDecoder.decode, +        final byte[] bytesForOptions = byteArrayPool.getBytes();, +        final byte[] bytesForStream = byteArrayPool.getBytes();, +        final BitmapFactory.Options options = getDefaultOptions();, +        final RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, bytesForStream);, +        try {, +                if (Log.isLoggable(TAG, Log.WARN)) {, +                    Log.w(TAG, "Cannot determine the image orientation from header", e);, +            } finally {, +                    if (Log.isLoggable(TAG, Log.WARN)) {, +                        Log.w(TAG, "Cannot reset the input stream", e);, +                    }, +                }, +            final Bitmap downsampled =, +                    downsampleWithSize(bis, options, pool, inWidth, inHeight, sampleSize, decodeFormat);, +            return rotated;, +        } finally {]
[+++ b/build.gradle, +                    // TODO(#2730): Remove this after updating to the latest support library., +                    disable "GradleDependency", +++ b/build.gradle, +                    // TODO(#2730): Remove this after updating to the latest support library., +                    disable "GradleDependency", +++ b/gradle.properties, +ANDROID_SUPPORT_VERSION=26.1.0]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }, +    }, +}, +, +subprojects {, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = 1.7, +        targetCompatibility = 1.7, +    }, +}, +, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableTransformation.java, +    if (result.equals(toTransform)) {, +      return resource;, +    } else {, +      return LazyBitmapDrawableResource.obtain(context, bitmap);]
[+++ b/.gitmodules, +[submodule "samples/flickr/ActionBarSherlock"], +	path = samples/flickr/ActionBarSherlock, +	url = https://github.com/JakeWharton/ActionBarSherlock.git, +++ b/.gitmodules, +[submodule "samples/flickr/ActionBarSherlock"], +	path = samples/flickr/ActionBarSherlock, +	url = https://github.com/JakeWharton/ActionBarSherlock.git, +++ b/samples/flickr/ActionBarSherlock, +Subproject commit 90939dc3925ffaaa0de269bbbe1b35e274968ea1, +++ b/.gitmodules, +[submodule "samples/flickr/ActionBarSherlock"], +	path = samples/flickr/ActionBarSherlock, +	url = https://github.com/JakeWharton/ActionBarSherlock.git, +++ b/samples/flickr/ActionBarSherlock, +Subproject commit 90939dc3925ffaaa0de269bbbe1b35e274968ea1, +++ b/samples/flickr/AndroidManifest.xml, +      android:hardwareAccelerated="true", +      android:theme="@style/Theme.Sherlock">, +++ b/.gitmodules, +[submodule "samples/flickr/ActionBarSherlock"], +	path = samples/flickr/ActionBarSherlock, +	url = https://github.com/JakeWharton/ActionBarSherlock.git, +++ b/samples/flickr/ActionBarSherlock, +Subproject commit 90939dc3925ffaaa0de269bbbe1b35e274968ea1, +++ b/samples/flickr/AndroidManifest.xml, +      android:hardwareAccelerated="true", +      android:theme="@style/Theme.Sherlock">, +++ b/samples/flickr/libs/android-support-v4.jar, +++ b/.gitmodules, +[submodule "samples/flickr/ActionBarSherlock"], +	path = samples/flickr/ActionBarSherlock, +	url = https://github.com/JakeWharton/ActionBarSherlock.git, +++ b/samples/flickr/ActionBarSherlock, +Subproject commit 90939dc3925ffaaa0de269bbbe1b35e274968ea1, +++ b/samples/flickr/AndroidManifest.xml, +      android:hardwareAccelerated="true", +      android:theme="@style/Theme.Sherlock">, +++ b/samples/flickr/libs/android-support-v4.jar, +++ b/samples/flickr/project.properties, +android.library.reference.2=ActionBarSherlock/library, +++ b/.gitmodules, +[submodule "samples/flickr/ActionBarSherlock"], +	path = samples/flickr/ActionBarSherlock, +	url = https://github.com/JakeWharton/ActionBarSherlock.git, +++ b/samples/flickr/ActionBarSherlock, +Subproject commit 90939dc3925ffaaa0de269bbbe1b35e274968ea1, +++ b/samples/flickr/AndroidManifest.xml, +      android:hardwareAccelerated="true", +      android:theme="@style/Theme.Sherlock">, +++ b/samples/flickr/libs/android-support-v4.jar, +++ b/samples/flickr/project.properties, +android.library.reference.2=ActionBarSherlock/library, +++ b/samples/flickr/res/layout/grid_fragment.xml, +<?xml version="1.0" encoding="utf-8"?>, +<GridView xmlns:android="http://schemas.android.com/apk/res/android", +  android:id="@+id/images", +  android:cacheColorHint="#00000000", +  android:fadingEdge="none", +  android:scrollingCache="false", +  android:numColumns="auto_fit", +  android:horizontalSpacing="15dp", +  android:verticalSpacing="15dp", +  android:layout_width="fill_parent", +  android:layout_height="fill_parent", +  android:layout_marginLeft="10dp", +  android:layout_marginRight="10dp"/>, +++ b/.gitmodules, +[submodule "samples/flickr/ActionBarSherlock"], +	path = samples/flickr/ActionBarSherlock, +	url = https://github.com/JakeWharton/ActionBarSherlock.git, +++ b/samples/flickr/ActionBarSherlock, +Subproject commit 90939dc3925ffaaa0de269bbbe1b35e274968ea1, +++ b/samples/flickr/AndroidManifest.xml, +      android:hardwareAccelerated="true", +      android:theme="@style/Theme.Sherlock">, +++ b/samples/flickr/libs/android-support-v4.jar, +++ b/samples/flickr/project.properties, +android.library.reference.2=ActionBarSherlock/library, +++ b/samples/flickr/res/layout/grid_fragment.xml, +<?xml version="1.0" encoding="utf-8"?>, +<GridView xmlns:android="http://schemas.android.com/apk/res/android", +  android:id="@+id/images", +  android:cacheColorHint="#00000000", +  android:fadingEdge="none", +  android:scrollingCache="false", +  android:numColumns="auto_fit", +  android:horizontalSpacing="15dp", +  android:verticalSpacing="15dp", +  android:layout_width="fill_parent", +  android:layout_height="fill_parent", +  android:layout_marginLeft="10dp", +  android:layout_marginRight="10dp"/>, +++ b/samples/flickr/res/layout/main.xml, +<merge xmlns:android="http://schemas.android.com/apk/res/android">, +    <FrameLayout, +      android:layout_weight="1">, +      <FrameLayout, +        android:id="@+id/fragment_container", +        android:layout_width="fill_parent"]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java, +import static com.google.common.truth.Truth.assertThat;, +import java.util.Map;, +  private static final byte[] GIF_HEADER = new byte[] { 0x47, 0x49, 0x46 };, +, +  public void testDoesNotHandleStreamIfEnabledButNotAGif() throws IOException {, +    Map<String, Object> options = new HashMap<>();, +    assertThat(decoder.handles(ByteBuffer.allocate(0), options)).isFalse();, +  }, +, +  @Test, +  public void testHandlesStreamIfContainsGifHeaderAndDisabledIsNotSet() throws IOException {, +    Map<String, Object> options = new HashMap<>();, +    assertThat(decoder.handles(ByteBuffer.wrap(GIF_HEADER), options)).isTrue();, +  }, +, +  @Test, +  public void testHandlesStreamIfContainsGifHeaderAndDisabledIsFalse() throws IOException {, +    Map<String, Object> options = new HashMap<>();, +    options.put(ByteBufferGifDecoder.KEY_DISABLE_ANIMATION, false);, +    assertThat(decoder.handles(ByteBuffer.wrap(GIF_HEADER), options)).isTrue();, +  }, +, +  @Test, +  public void testDoesNotHandleStreamIfDisabled() throws IOException {, +    Map<String, Object> options = new HashMap<>();, +    options.put(ByteBufferGifDecoder.KEY_DISABLE_ANIMATION, true);, +    assertThat(decoder.handles(ByteBuffer.wrap(GIF_HEADER), options)).isFalse();, +  }, +, +  @Test, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoderTest.java, +import static com.google.common.truth.Truth.assertThat;, +import java.util.Map;, +  private static final byte[] GIF_HEADER = new byte[] { 0x47, 0x49, 0x46 };, +, +  public void testDoesNotHandleStreamIfEnabledButNotAGif() throws IOException {, +    Map<String, Object> options = new HashMap<>();, +    assertThat(decoder.handles(ByteBuffer.allocate(0), options)).isFalse();, +  }, +, +  @Test, +  public void testHandlesStreamIfContainsGifHeaderAndDisabledIsNotSet() throws IOException {, +    Map<String, Object> options = new HashMap<>();, +    assertThat(decoder.handles(ByteBuffer.wrap(GIF_HEADER), options)).isTrue();, +  }, +, +  @Test, +  public void testHandlesStreamIfContainsGifHeaderAndDisabledIsFalse() throws IOException {, +    Map<String, Object> options = new HashMap<>();, +    options.put(ByteBufferGifDecoder.KEY_DISABLE_ANIMATION, false);, +    assertThat(decoder.handles(ByteBuffer.wrap(GIF_HEADER), options)).isTrue();, +  }, +, +  @Test, +  public void testDoesNotHandleStreamIfDisabled() throws IOException {, +    Map<String, Object> options = new HashMap<>();, +    options.put(ByteBufferGifDecoder.KEY_DISABLE_ANIMATION, true);, +    assertThat(decoder.handles(ByteBuffer.wrap(GIF_HEADER), options)).isFalse();, +  }, +, +  @Test, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/StreamGifDecoderTest.java, +package com.bumptech.glide.load.resource.gif;, +, +import static com.google.common.truth.Truth.assertThat;, +, +import com.bumptech.glide.load.ResourceDecoder;, +, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +, +import java.io.ByteArrayInputStream;, +import java.io.IOException;, +import java.nio.ByteBuffer;, +import java.util.HashMap;, +import java.util.Map;, +, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +public class StreamGifDecoderTest {, +  private static final byte[] GIF_HEADER = new byte[] { 0x47, 0x49, 0x46 };, +, +  @Mock, +  ResourceDecoder<ByteBuffer, GifDrawable> byteBufferDecoder;, +  private StreamGifDecoder decoder;, +, +  @Before, +  public void setUp() {, +    MockitoAnnotations.initMocks(this);, +, +    decoder = new StreamGifDecoder(byteBufferDecoder);, +  }, +, +  @Test]
[+++ b/samples/flickr/res/layout/flick_photo_list.xml, +<?xml version="1.0" encoding="utf-8"?>, +, +<ListView xmlns:android="http://schemas.android.com/apk/res/android", +  android:id="@+id/flickr_photo_list", +  android:layout_width="fill_parent", +  android:layout_height="fill_parent", +  android:cacheColorHint="#00000000", +  android:scrollingCache="false">, +</ListView>, +, +++ b/samples/flickr/res/layout/flick_photo_list.xml, +<?xml version="1.0" encoding="utf-8"?>, +, +<ListView xmlns:android="http://schemas.android.com/apk/res/android", +  android:id="@+id/flickr_photo_list", +  android:layout_width="fill_parent", +  android:layout_height="fill_parent", +  android:cacheColorHint="#00000000", +  android:scrollingCache="false">, +</ListView>, +, +++ b/samples/flickr/res/layout/flick_photo_list_item.xml, +<?xml version="1.0" encoding="utf-8"?>, +, +<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android", +  android:orientation="horizontal", +  android:layout_width="fill_parent", +  android:layout_height="@dimen/flickr_list_item_height", +  android:padding="10dp">, +  <ImageView, +    android:id="@+id/photo_view", +    android:layout_width="0dp", +    android:layout_height="fill_parent", +    android:layout_weight="1", +    android:scaleType="center" />, +  <TextView, +    android:id="@+id/title_view", +    android:layout_width="0dp", +    android:layout_height="fill_parent", +    android:layout_weight="1", +    android:layout_margin="10dp", +    android:gravity="center", +    android:textSize="16sp"/>, +</LinearLayout>, +++ b/samples/flickr/res/layout/flick_photo_list.xml, +<?xml version="1.0" encoding="utf-8"?>, +, +<ListView xmlns:android="http://schemas.android.com/apk/res/android", +  android:id="@+id/flickr_photo_list", +  android:layout_width="fill_parent", +  android:layout_height="fill_parent", +  android:cacheColorHint="#00000000", +  android:scrollingCache="false">, +</ListView>, +, +++ b/samples/flickr/res/layout/flick_photo_list_item.xml, +<?xml version="1.0" encoding="utf-8"?>, +, +<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android", +  android:orientation="horizontal", +  android:layout_width="fill_parent", +  android:layout_height="@dimen/flickr_list_item_height", +  android:padding="10dp">, +  <ImageView, +    android:id="@+id/photo_view", +    android:layout_width="0dp", +    android:layout_height="fill_parent", +    android:layout_weight="1", +    android:scaleType="center" />, +  <TextView, +    android:id="@+id/title_view", +    android:layout_width="0dp", +    android:layout_height="fill_parent", +    android:layout_weight="1", +    android:layout_margin="10dp", +    android:gravity="center", +    android:textSize="16sp"/>, +</LinearLayout>, +++ b/samples/flickr/res/values/dimens.xml, +  <dimen name="large_photo_side">150dp</dimen>, +  <dimen name="flickr_list_item_height">170dp</dimen>, +++ b/samples/flickr/res/layout/flick_photo_list.xml, +<?xml version="1.0" encoding="utf-8"?>, +, +<ListView xmlns:android="http://schemas.android.com/apk/res/android", +  android:id="@+id/flickr_photo_list", +  android:layout_width="fill_parent", +  android:layout_height="fill_parent", +  android:cacheColorHint="#00000000", +  android:scrollingCache="false">, +</ListView>, +, +++ b/samples/flickr/res/layout/flick_photo_list_item.xml, +<?xml version="1.0" encoding="utf-8"?>, +, +<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android", +  android:orientation="horizontal", +  android:layout_width="fill_parent", +  android:layout_height="@dimen/flickr_list_item_height"]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;, +    registry = new Registry();, +    registry.register(new DefaultImageHeaderParser());, +, +    Downsampler downsampler = new Downsampler(registry.getImageHeaderParsers(),, +        resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);, +, +    registry.register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;, +    registry = new Registry();, +    registry.register(new DefaultImageHeaderParser());, +, +    Downsampler downsampler = new Downsampler(registry.getImageHeaderParsers(),, +        resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);, +, +    registry.register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +import com.bumptech.glide.load.ImageHeaderParser;, +import com.bumptech.glide.provider.ImageHeaderParserRegistry;, +  private final ImageHeaderParserRegistry imageHeaderParserRegistry;, +    this.imageHeaderParserRegistry = new ImageHeaderParserRegistry();, +  public Registry register(ImageHeaderParser parser) {, +    imageHeaderParserRegistry.add(parser);, +    return this;, +  }, +, +  public List<ImageHeaderParser> getImageHeaderParsers() {, +    List<ImageHeaderParser> result = imageHeaderParserRegistry.getParsers();, +    if (result.isEmpty()) {, +      throw new NoImageHeaderParserException();, +    }, +    return result;, +  }, +, +, +  /**, +   * Thrown when no {@link ImageHeaderParser} is registered., +   */, +  public static final class NoImageHeaderParserException extends MissingComponentException {, +    public NoImageHeaderParserException() {, +      super("Failed to find image header parser.");, +    }, +  }, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;, +    registry = new Registry();, +    registry.register(new DefaultImageHeaderParser());, +, +    Downsampler downsampler = new Downsampler(registry.getImageHeaderParsers(),, +        resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);, +, +    registry.register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +import com.bumptech.glide.load.ImageHeaderParser;, +import com.bumptech.glide.provider.ImageHeaderParserRegistry;, +  private final ImageHeaderParserRegistry imageHeaderParserRegistry;, +    this.imageHeaderParserRegistry = new ImageHeaderParserRegistry();, +  public Registry register(ImageHeaderParser parser) {, +    imageHeaderParserRegistry.add(parser);, +    return this;, +  }, +, +  public List<ImageHeaderParser> getImageHeaderParsers() {, +    List<ImageHeaderParser> result = imageHeaderParserRegistry.getParsers();, +    if (result.isEmpty()) {, +      throw new NoImageHeaderParserException();, +    }, +    return result;, +  }, +, +, +  /**, +   * Thrown when no {@link ImageHeaderParser} is registered., +   */, +  public static final class NoImageHeaderParserException extends MissingComponentException {, +    public NoImageHeaderParserException() {, +      super("Failed to find image header parser.");, +    }, +  }, +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java, +package com.bumptech.glide.load;, +, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +import java.io.IOException;, +import java.io.InputStream;, +import java.nio.ByteBuffer;, +, +/**, + * Interface for the ImageHeaderParser., + */, +public interface ImageHeaderParser {, +  /**]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +          long contentLength = responseBody.contentLength();, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +          long contentLength = responseBody.contentLength();, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +          long contentLength = responseBody.contentLength();]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java, +package com.bumptech.glide.load.resource.transcode;, +, +import static org.junit.Assert.assertEquals;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.when;, +, +import android.graphics.Bitmap;, +import android.graphics.drawable.BitmapDrawable;, +, +import com.bumptech.glide.load.engine.Resource;, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import com.bumptech.glide.tests.Util;, +, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.Robolectric;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +public class BitmapDrawableTranscoderTest {, +    private BitmapDrawableTranscoder transcoder;, +, +    @Before, +    public void setUp() {, +        transcoder = new BitmapDrawableTranscoder(Robolectric.application.getResources(), mock(BitmapPool.class));, +    }, +, +    @Test, +    public void testHasValidId() {, +        Util.assertClassHasValidId(BitmapDrawableTranscoder.class, transcoder.getId());, +    }, +, +    @Test, +    public void testReturnsBitmapDrawableResourceContainingGivenBitmap() {, +        Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +        Resource<Bitmap> resource = mock(Resource.class);, +        when(resource.get()).thenReturn(expected);, +, +        Resource<BitmapDrawable> transcoded = transcoder.transcode(resource);, +, +        assertEquals(expected, transcoded.get().getBitmap());, +    }, +}, +++ /dev/null, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoderTest.java, +package com.bumptech.glide.load.resource.transcode;, +, +import static org.junit.Assert.assertEquals;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.when;, +, +import android.graphics.Bitmap;, +import android.graphics.drawable.BitmapDrawable;, +, +import com.bumptech.glide.load.engine.Resource;, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import com.bumptech.glide.tests.Util;, +, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.Robolectric;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +public class BitmapDrawableTranscoderTest {, +    private BitmapDrawableTranscoder transcoder;, +, +    @Before, +    public void setUp() {, +        transcoder = new BitmapDrawableTranscoder(Robolectric.application.getResources(), mock(BitmapPool.class));, +    }, +, +    @Test, +    public void testHasValidId() {, +        Util.assertClassHasValidId(BitmapDrawableTranscoder.class, transcoder.getId());, +    }, +, +    @Test, +    public void testReturnsBitmapDrawableResourceContainingGivenBitmap() {, +        Bitmap expected = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +        Resource<Bitmap> resource = mock(Resource.class);, +        when(resource.get()).thenReturn(expected);, +, +        Resource<BitmapDrawable> transcoded = transcoder.transcode(resource);, +, +        assertEquals(expected, transcoded.get().getBitmap());, +    }]
[+++ b/.gitignore, +library/install_dependencies/maven-android-sdk-deployer, +++ b/.gitignore, +library/install_dependencies/maven-android-sdk-deployer, +++ b/library/install_dependencies/install-android-deps.sh, +#!/bin/sh, +# This script installs the necessary Android dependencies to compile Glide and run, +# the test suite., +# , +# Pre-requisites: , +# Using the android sdk tool, under Android 4.4.2 (API 19), install:, +#   SDK Platform, +#   Glass Development Kit Preview, +#      , +, +git clone https://github.com/mosabua/maven-android-sdk-deployer.git, +cd maven-android-sdk-deployer , +mvn clean install -N && cd platforms && mvn clean install -N && cd android-19 && mvn clean install || { , +  echo 'Failed to install 4.4 SDK, install relevant packages in android SDK first'; , +  exit 1; , +}, +cd ../.., +mvn clean install -N && cd extras && mvn clean install -N && cd compatibility-v4 && mvn clean install || { echo 'Failed to install android-support-v4, install support library in android SDK first' ; exit 1; }]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java, +import org.junit.Before;, +  private static final String URL = "https://imgs.xkcd.com/comics/mc_hammer_age.png";, +  @Before, +  public void setUp() {, +    MockModelLoader.mock(URL, getData());, +  }, +, +                .load(URL), +                .load(URL), +              .load(URL), +              .load(URL)]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +   * Returns a {@link RequestOptions} object with {@link #diskCacheStrategy(DiskCacheStrategy)} set.]
[+++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +    this.width = maybeApplySizeMultiplier(width, sizeMultiplier);, +    this.height = maybeApplySizeMultiplier(height, sizeMultiplier);, +  private static int maybeApplySizeMultiplier(int size, float sizeMultiplier) {, +    return size == Target.SIZE_ORIGINAL ? size : Math.round(sizeMultiplier * size);, +  }, +]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import com.bumptech.glide.request.ErrorRequestCoordinator;, +  @Nullable private RequestBuilder<TranscodeType> errorBuilder;, +   * Sets a {@link RequestListener} to monitor the resource load. It's best to create a single, +   * Sets a {@link RequestBuilder} that is built and run iff the load started by this, +   * {@link RequestBuilder} fails., +   *, +   * <p>If this {@link RequestBuilder} uses a thumbnail that succeeds the given error, +   * {@link RequestBuilder} will be started anyway if the non-thumbnail request fails., +   *, +   * <p>Recursive calls to {@link #error(RequestBuilder)} as well as calls to, +   * {@link #thumbnail(float)} and {@link #thumbnail(RequestBuilder)} are supported for the given, +   * error {@link RequestBuilder}., +   *, +   * <p>Unlike {@link #thumbnail(RequestBuilder)} and {@link #thumbnail(float)}, no options from, +   * this primary {@link RequestBuilder} are propagated to the given error {@link RequestBuilder}., +   * Options like priority, override widths and heights and transitions must be applied, +   * independently to the error builder., +   *, +   * <p>The given {@link RequestBuilder} will start and potentially override a fallback drawable, +   * if it's set on this {@link RequestBuilder} via, +   * {@link RequestOptions#fallback(android.graphics.drawable.Drawable)} or, +   * {@link RequestOptions#fallback(int)}., +   *, +   * @return This {@link RequestBuilder}., +   */, +  public RequestBuilder<TranscodeType> error(@Nullable RequestBuilder<TranscodeType> errorBuilder) {, +    this.errorBuilder = errorBuilder;, +    return this;, +  }, +, +  /**, +      @Nullable RequestCoordinator parentCoordinator,, +      TransitionOptions<?, ? super TranscodeType> transitionOptions,, +      Priority priority, int overrideWidth, int overrideHeight, RequestOptions requestOptions) {, +, +    // Build the ErrorRequestCoordinator first if necessary so we can update parentCoordinator., +    ErrorRequestCoordinator errorRequestCoordinator = null;, +    if (errorBuilder != null) {, +      errorRequestCoordinator = new ErrorRequestCoordinator(parentCoordinator);, +      parentCoordinator = errorRequestCoordinator;, +    }, +, +    Request mainRequest =, +        buildThumbnailRequestRecursive(, +            target,, +            parentCoordinator,, +            transitionOptions,, +            priority,, +            overrideWidth,, +            overrideHeight,, +            requestOptions);, +, +    if (errorRequestCoordinator == null) {, +      return mainRequest;, +    }, +, +    int errorOverrideWidth = errorBuilder.requestOptions.getOverrideWidth();, +    int errorOverrideHeight = errorBuilder.requestOptions.getOverrideHeight();, +    if (Util.isValidDimensions(overrideWidth, overrideHeight), +        && !errorBuilder.requestOptions.isValidOverride()) {, +      errorOverrideWidth = requestOptions.getOverrideWidth();, +      errorOverrideHeight = requestOptions.getOverrideHeight();, +    }, +, +    Request errorRequest = errorBuilder.buildRequestRecursive(, +        target,, +        errorRequestCoordinator,, +        errorBuilder.transitionOptions,, +        errorBuilder.requestOptions.getPriority(),, +        errorOverrideWidth,, +        errorOverrideHeight,, +        errorBuilder.requestOptions);, +    errorRequestCoordinator.setRequests(mainRequest, errorRequest);, +    return errorRequestCoordinator;, +  }, +, +  private Request buildThumbnailRequestRecursive(Target<TranscodeType> target,, +        @Nullable RequestCoordinator parentCoordinator,, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import com.bumptech.glide.request.ErrorRequestCoordinator;, +  @Nullable private RequestBuilder<TranscodeType> errorBuilder;, +   * Sets a {@link RequestListener} to monitor the resource load. It's best to create a single, +   * Sets a {@link RequestBuilder} that is built and run iff the load started by this, +   * {@link RequestBuilder} fails., +   *, +   * <p>If this {@link RequestBuilder} uses a thumbnail that succeeds the given error, +   * {@link RequestBuilder} will be started anyway if the non-thumbnail request fails., +   *, +   * <p>Recursive calls to {@link #error(RequestBuilder)} as well as calls to, +   * {@link #thumbnail(float)} and {@link #thumbnail(RequestBuilder)} are supported for the given, +   * error {@link RequestBuilder}., +   *, +   * <p>Unlike {@link #thumbnail(RequestBuilder)} and {@link #thumbnail(float)}, no options from, +   * this primary {@link RequestBuilder} are propagated to the given error {@link RequestBuilder}., +   * Options like priority, override widths and heights and transitions must be applied, +   * independently to the error builder., +   *, +   * <p>The given {@link RequestBuilder} will start and potentially override a fallback drawable, +   * if it's set on this {@link RequestBuilder} via]
[+++ b/library/src/main/java/com/bumptech/glide/request/ThumbnailRequestCoordinator.java, +    if (!thumb.isComplete()) {, +  }]
[+++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, + *, + *, +         * Returns a non null list of all models that need to be loaded for the list to display adapter items in, +         * positions between {@code start} and {@code end}., +         *, +         * <p>, +         * </p>, +         *, +         * Returns a non null {@link com.bumptech.glide.GenericRequestBuilder} for a given item. Must exactly match, +         * the request used to load the resource in the list., +         *, +         * <p>, +         * </p>, +         *, +     *, +         * Returns the size of the view in the list where the resources will be displayed in pixels in the format, +         * [x, y], or {@code null} if no size is currently available., +         *, +         *, +    /**, +     * Constructor for {@link com.bumptech.glide.ListPreloader} that requires users to subclass and override, +     * the {@link #getItems(int, int)} and {@link #getRequestBuilder(Object)} methods., +     *, +     * @deprecated Use {@link #ListPreloader(com.bumptech.glide.ListPreloader.PreloadModelProvider,, +     * com.bumptech.glide.ListPreloader.PreloadSizeProvider, int)} instead. This constructor will be removed in Glide, +     * 4.0., +     * @param maxPreload Maximum number of items to preload., +     */, +    @Deprecated, +    public ListPreloader(int maxPreload) {, +        this(null, null, maxPreload);, +    }, +    /**, +     * Constructor for {@link com.bumptech.glide.ListPreloader} that accepts interfaces for providing the dimensions of, +     * images to preload, the list of models to preload for a given position, and the request to use to load images., +     *, +     * @param preloadModelProvider Provides models to load and requests capable of loading them., +     * @param preloadDimensionProvider Provides the dimensions of images to load., +     * @param maxPreload Maximum number of items to preload., +     */, +     *, +     *, +     * @deprecated Use {@link com.bumptech.glide.ListPreloader.PreloadSizeProvider} instead. This method will be removed, +     * in Glide 4.0., +    @Deprecated, +    protected int[] getDimensions(T item) {, +        if (preloadDimensionProvider == null) {, +            throw new IllegalStateException("You must either provide a PreloadDimensionProvider or override getSize9)");, +        }, +     * Returns a non null list of all models that need to be loaded for the list to display adapter items, +     * between {@code start} and {@code end}., +     *, +     * <p>, +     * </p>, +     *, +     * @deprecated Use {@link com.bumptech.glide.ListPreloader.PreloadModelProvider} instead. This method will be, +     * removed in Glide 4.0., +    @Deprecated, +        if (preloadModelProvider == null) {, +            throw new IllegalStateException("You must either provide a PreloadModelProvider or override getItems()");, +        }, +     * Returns a non null {@link com.bumptech.glide.GenericRequestBuilder} for a given item. Must exactly match the, +     * request used to load the resource in the list., +     *, +     * <p>, +     * </p>, +     *, +     * @deprecated Use {@link com.bumptech.glide.ListPreloader.PreloadModelProvider} instead. This method will be, +     * removed in Glide 4.0., +    @Deprecated, +        if (preloadModelProvider == null) {, +            throw new IllegalStateException("You must either provide a PreloadModelProvider, or override ", +                    + "getRequestBuilder()");, +        }, +        final int[] dimensions = getDimensions(item);, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, + *, + *, +         * Returns a non null list of all models that need to be loaded for the list to display adapter items in, +         * positions between {@code start} and {@code end}., +         *, +         * <p>, +         * </p>, +         *, +         * Returns a non null {@link com.bumptech.glide.GenericRequestBuilder} for a given item. Must exactly match, +         * the request used to load the resource in the list., +         *, +         * <p>, +         * </p>, +         *, +     *, +         * Returns the size of the view in the list where the resources will be displayed in pixels in the format, +         * [x, y], or {@code null} if no size is currently available., +         *, +         *, +    /**, +     * Constructor for {@link com.bumptech.glide.ListPreloader} that requires users to subclass and override, +     * the {@link #getItems(int, int)} and {@link #getRequestBuilder(Object)} methods., +     *]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +        .addModifiers(Modifier.PUBLIC)]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +import android.support.test.InstrumentationRegistry;, +import com.bumptech.glide.test.ConcurrencyHelper;, +  private final ConcurrencyHelper concurrencyHelper = new ConcurrencyHelper();, +    context = InstrumentationRegistry.getTargetContext();, +        concurrencyHelper.get(, +                .submit());, +        concurrencyHelper.get(, +                .submit(10, 10));, +        concurrencyHelper.get(, +                .submit());, +        concurrencyHelper.get(, +                .submit(10, 10));, +        concurrencyHelper.get(, +                .submit());, +        concurrencyHelper.get(, +                .submit(10, 10));, +        concurrencyHelper.get(, +              .submit());, +        concurrencyHelper.get(, +                .submit(10, 10));, +    final GifDrawable gifDrawable =, +        concurrencyHelper.get(, +            GlideApp.with(context), +                .submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL));, +, +    concurrencyHelper.runOnMainThread(, +    ConcurrencyHelper.waitOnLatch(waitForGifFrame);, +    concurrencyHelper.runOnMainThread(, +        new Runnable() {, +, +    concurrencyHelper.loadOnMainThread(, +        GlideApp.with(context), +            .load(gifDrawable), +            .override(Target.SIZE_ORIGINAL),, +        imageView);, +    WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams();, +    WindowManager windowManager =, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +import android.support.test.InstrumentationRegistry;, +import com.bumptech.glide.test.ConcurrencyHelper;, +  private final ConcurrencyHelper concurrencyHelper = new ConcurrencyHelper();, +    context = InstrumentationRegistry.getTargetContext();, +        concurrencyHelper.get(, +                .submit());, +        concurrencyHelper.get(, +                .submit(10, 10));, +        concurrencyHelper.get(, +                .submit());, +        concurrencyHelper.get(, +                .submit(10, 10));, +        concurrencyHelper.get(, +                .submit());, +        concurrencyHelper.get(, +                .submit(10, 10));, +        concurrencyHelper.get(, +              .submit());, +        concurrencyHelper.get(, +                .submit(10, 10));, +    final GifDrawable gifDrawable =, +        concurrencyHelper.get(, +            GlideApp.with(context), +                .submit(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL));, +, +    concurrencyHelper.runOnMainThread(, +    ConcurrencyHelper.waitOnLatch(waitForGifFrame);, +    concurrencyHelper.runOnMainThread(, +        new Runnable() {, +, +    concurrencyHelper.loadOnMainThread(, +        GlideApp.with(context), +            .load(gifDrawable), +            .override(Target.SIZE_ORIGINAL),, +        imageView);, +    WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams();, +    WindowManager windowManager =, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java, +  public static void waitOnLatch(final CountDownLatch latch) {]
[+++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java, +            if (Log.isLoggable(TAG, Log.DEBUG)) {, +                Log.d(TAG, "Failed to encode data onto the OutputStream", e);, +++ b/library/src/main/java/com/bumptech/glide/load/model/StreamEncoder.java, +            if (Log.isLoggable(TAG, Log.DEBUG)) {, +                Log.d(TAG, "Failed to encode data onto the OutputStream", e);, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java, +            if (Log.isLoggable(TAG, Log.DEBUG)) {, +                Log.d(TAG, "Format Error Reading Color Table", e);, +            }, +                if (Log.isLoggable(TAG, Log.DEBUG)) {, +                    Log.d(TAG, "Error Reading Block n: " + n + " count: " + count + " blockSize: " + blockSize, e);, +                }]
[+++ b/samples/contacturi/lint.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<lint>, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +</lint>, +++ b/samples/contacturi/lint.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<lint>, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +</lint>, +++ b/samples/contacturi/src/main/AndroidManifest.xml, +        android:allowBackup="false", +++ b/samples/contacturi/lint.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<lint>, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +</lint>, +++ b/samples/contacturi/src/main/AndroidManifest.xml, +        android:allowBackup="false", +++ b/samples/flickr/lint.xml, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +++ b/samples/contacturi/lint.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<lint>, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +</lint>, +++ b/samples/contacturi/src/main/AndroidManifest.xml, +        android:allowBackup="false", +++ b/samples/flickr/lint.xml, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +++ b/samples/gallery/lint.xml, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +++ b/samples/contacturi/lint.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<lint>, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +</lint>, +++ b/samples/contacturi/src/main/AndroidManifest.xml, +        android:allowBackup="false", +++ b/samples/flickr/lint.xml, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +++ b/samples/gallery/lint.xml, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +++ b/samples/giphy/lint.xml, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +++ b/samples/contacturi/lint.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<lint>, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +</lint>, +++ b/samples/contacturi/src/main/AndroidManifest.xml, +        android:allowBackup="false", +++ b/samples/flickr/lint.xml, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +++ b/samples/gallery/lint.xml, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +++ b/samples/giphy/lint.xml, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +++ b/samples/giphy/src/main/AndroidManifest.xml, +        android:allowBackup="false", +++ b/samples/contacturi/lint.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<lint>, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +</lint>, +++ b/samples/contacturi/src/main/AndroidManifest.xml, +        android:allowBackup="false", +++ b/samples/flickr/lint.xml, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +++ b/samples/gallery/lint.xml, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +++ b/samples/giphy/lint.xml, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +++ b/samples/giphy/src/main/AndroidManifest.xml, +        android:allowBackup="false", +++ b/samples/svg/lint.xml, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +++ b/samples/contacturi/lint.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<lint>, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +</lint>, +++ b/samples/contacturi/src/main/AndroidManifest.xml, +        android:allowBackup="false", +++ b/samples/flickr/lint.xml, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +++ b/samples/gallery/lint.xml, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +++ b/samples/giphy/lint.xml, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +++ b/samples/giphy/src/main/AndroidManifest.xml, +        android:allowBackup="false", +++ b/samples/svg/lint.xml, +    <issue id="GoogleAppIndexingWarning" severity="ignore"/>, +++ b/samples/svg/src/main/AndroidManifest.xml, +        android:allowBackup="false"]
[+++ b/library/res/values/ids.xml, +  <item type="id" name="glide_metadata" />, +++ b/library/res/values/ids.xml, +  <item type="id" name="glide_metadata" />, +++ b/library/src/com/bumptech/glide/Glide.java, +     * for use with {@link Glide.Request} and/or as an easily accessible singleton, +     * Set the {@link RequestQueue} to use with {@link Glide.Request}. Replaces the current, +     * {@link ImageManager} with custom options for use with {@link com.bumptech.glide.Glide.Request} and/or as an, +     * easily accessible singleton., +     * Set the {@link ImageManager} to use with {@link Glide.Request} Replaces the current, +     * Set the {@link ModelLoader} for this view., +     *     Note - You can use this method to set a {@link ModelLoader} for models that don't have a default, +     *     {@link ModelLoader}. You can also optionally use this method to override the default {@link ModelLoader}, +     *     for a model for which there is a default., +     *     Note - If you have the ability to fetch different sized images for a given model, it is most efficient to, +     *     supply a custom {@link ModelLoader} here to do so, even if a default exists. Fetching a smaller image, +     *     means less bandwidth, battery, and memory usage as well as faster image loads. To simply build a url to, +     *     download an image using the width and the height of the view, consider passing in a subclass of, +     *     {@link com.bumptech.glide.loader.model.VolleyModelLoader}., +     * @param modelLoader The {@link ModelRequest} to use to load an image from a given model, +     * @return A {@link ModelRequest} to set the specific model to load, +    public static <T> ModelRequest<T> using(ModelLoader<T> modelLoader) {, +        return new ModelRequest<T>(modelLoader);, +    /**, +     * Use {@link StringLoader} to load the given model, +     *, +     * @see #using(com.bumptech.glide.loader.model.ModelLoader), +     *, +     * @param string The string representing the image. Must be either a path, or a uri handled by {@link UriLoader}, +     * @return A {@link Request} to set options for the load and ultimately the view to load the model into, +     */, +    public static Request<String> load(String string) {, +        return new Request<String>(string);, +    /**, +     * Use {@link UriLoader} to load the given model, +     *, +     * @see #using(com.bumptech.glide.loader.model.ModelLoader), +     *, +     * @param uri The uri representing the image. Must be a uri handled by {@link UriLoader}, +     * @return A {@link Request} to set options for the load and ultimately the view to load the model into, +     */, +    public static Request<Uri> load(Uri uri) {, +        return new Request<Uri>(uri);, +    }, +, +    /**, +     * Use {@link UrlLoader} to load the given model, +     *, +     * @see #using(com.bumptech.glide.loader.model.ModelLoader), +     *, +     * @param url The URL representing the image., +     * @return A {@link Request} to set options for the load and ultimately the view to load the model into, +     */, +    public static Request<URL> load(URL url) {, +        return new Request<URL>(url);, +    }, +, +    /**, +     * Use {@link FileLoader} to load the given model, +     *, +     * @see #using(com.bumptech.glide.loader.model.ModelLoader), +     *, +     * @param file The File containing the image, +     * @return A {@link Request} to set options for the load and ultimately the view to load the model into, +     */, +    public static Request<File> load(File file) {, +        return new Request<File>(file);, +    }, +, +    /**, +     * Use {@link DrawableLoader} to load the given model, +     *, +     * @see #using(com.bumptech.glide.loader.model.ModelLoader), +     *, +     * @param resourceId the id of the resource containing the image, +     * @return A {@link Request} to set options for the load and ultimately the view to load the model into, +     */, +    public static Request<Integer> load(Integer resourceId) {, +        return new Request<Integer>(resourceId);, +    }, +, +    private interface ModelLoaderFactory<T> {, +        public ModelLoader<T> build(Context context);, +        public Class<? extends ModelLoader<T>> loaderClass();, +    }, +, +    private static final ModelLoaderFactory<String> stringLoaderFactory = new ModelLoaderFactory<String>() {, +, +        @Override, +        public ModelLoader<String> build(Context context) {, +            return new StringLoader(context);, +        }, +, +        @Override, +        public Class<? extends ModelLoader<String>> loaderClass() {, +            return StringLoader.class;, +        }, +    };, +, +    private static final ModelLoaderFactory<Uri> uriLoaderFactory = new ModelLoaderFactory<Uri>() {]
[+++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java, +import java.util.ArrayList;, +import java.util.List;, +    private List<Request> getSnapshot() {, +        // toArray creates a new ArrayList internally and this way we can guarantee entries will not be, +        // null. See #322., +        List<Request> result = new ArrayList<Request>(requests.size());, +        // We could also just call new ArrayList<Request>(requests) but that actually creates two new ArrayLists because, +        // that constructor in ArrayList calls toArray()., +        for (Request request : requests) {, +            result.add(request);, +        }, +        return result;]
[+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java, + *, + * @deprecated Prefer the okhttp3 version instead., +@Deprecated, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java, + *, + * @deprecated Prefer the okhttp3 version instead., +@Deprecated, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java, +public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java, + *, + * @deprecated Prefer the okhttp3 version instead., +@Deprecated, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java, +public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java, +@SuppressWarnings("deprecation"), +public class VolleyGlideModule implements com.bumptech.glide.module.GlideModule {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java, + *, + * @deprecated Prefer the okhttp3 version instead., +@Deprecated, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java, +public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java, +@SuppressWarnings("deprecation"), +public class VolleyGlideModule implements com.bumptech.glide.module.GlideModule {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    registry, +        .append(ByteBuffer.class, new ByteBufferEncoder()), +        .append(InputStream.class, new StreamEncoder(arrayPool)), +        .append(Bitmap.class, new BitmapEncoder()), +        .append(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, new BitmapEncoder())), +        .append(GifDrawable.class, new GifDrawableEncoder()), +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java, + *, + * @deprecated Prefer the okhttp3 version instead., +@Deprecated, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java, +public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java, +@SuppressWarnings("deprecation"), +public class VolleyGlideModule implements com.bumptech.glide.module.GlideModule {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    registry, +        .append(ByteBuffer.class, new ByteBufferEncoder()), +        .append(InputStream.class, new StreamEncoder(arrayPool)), +        .append(Bitmap.class, new BitmapEncoder()), +        .append(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, new BitmapEncoder())), +        .append(GifDrawable.class, new GifDrawableEncoder()), +++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java, +  @SuppressWarnings("deprecation"), +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java, + *, + * @deprecated Prefer the okhttp3 version instead., +@Deprecated, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java, +public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java, +@SuppressWarnings("deprecation"), +public class VolleyGlideModule implements com.bumptech.glide.module.GlideModule {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    registry, +        .append(ByteBuffer.class, new ByteBufferEncoder()), +        .append(InputStream.class, new StreamEncoder(arrayPool)), +        .append(Bitmap.class, new BitmapEncoder()), +        .append(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, new BitmapEncoder())), +        .append(GifDrawable.class, new GifDrawableEncoder()), +++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFiller.java, +  @SuppressWarnings("deprecation"), +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +  @SuppressWarnings({"resource", "deprecation"}), +  @SuppressWarnings("deprecation"), +  @SuppressWarnings("deprecation"), +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpLibraryGlideModule.java, + *, + * @deprecated Prefer the okhttp3 version instead., +@Deprecated, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpGlideModule.java, +public class OkHttpGlideModule implements com.bumptech.glide.module.GlideModule {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyGlideModule.java, +@SuppressWarnings("deprecation"), +public class VolleyGlideModule implements com.bumptech.glide.module.GlideModule {]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.manager.ConnectivityMonitorFactory;, +  private final ConnectivityMonitorFactory connectivityMonitorFactory;, +      Context context,, +      ConnectivityMonitorFactory connectivityMonitorFactory,, +    this.connectivityMonitorFactory = connectivityMonitorFactory;, +  ConnectivityMonitorFactory getConnectivityMonitorFactory() {, +    return connectivityMonitorFactory;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.manager.ConnectivityMonitorFactory;, +  private final ConnectivityMonitorFactory connectivityMonitorFactory;, +      Context context,, +      ConnectivityMonitorFactory connectivityMonitorFactory,, +    this.connectivityMonitorFactory = connectivityMonitorFactory;, +  ConnectivityMonitorFactory getConnectivityMonitorFactory() {, +    return connectivityMonitorFactory;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.manager.ConnectivityMonitorFactory;, +import com.bumptech.glide.manager.DefaultConnectivityMonitorFactory;, +  private ConnectivityMonitorFactory connectivityMonitorFactory;, +   * Sets the {@link com.bumptech.glide.manager.ConnectivityMonitorFactory}, +   * to use to notify {@link com.bumptech.glide.RequestManager} of connectivity events., +   * If not set {@link com.bumptech.glide.manager.DefaultConnectivityMonitorFactory} would be used., +   *, +   * @param factory The factory to use, +   * @return This builder., +   */, +  public GlideBuilder setConnectivityMonitorFactory(ConnectivityMonitorFactory factory) {, +    this.connectivityMonitorFactory = factory;, +    return this;, +  }, +, +  /**, +    if (connectivityMonitorFactory == null) {, +      connectivityMonitorFactory = new DefaultConnectivityMonitorFactory();, +    }, +, +        context,, +        connectivityMonitorFactory,, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.manager.ConnectivityMonitorFactory;, +  private final ConnectivityMonitorFactory connectivityMonitorFactory;, +      Context context,, +      ConnectivityMonitorFactory connectivityMonitorFactory,, +    this.connectivityMonitorFactory = connectivityMonitorFactory;, +  ConnectivityMonitorFactory getConnectivityMonitorFactory() {, +    return connectivityMonitorFactory;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.manager.ConnectivityMonitorFactory;, +import com.bumptech.glide.manager.DefaultConnectivityMonitorFactory;, +  private ConnectivityMonitorFactory connectivityMonitorFactory;, +   * Sets the {@link com.bumptech.glide.manager.ConnectivityMonitorFactory}, +   * to use to notify {@link com.bumptech.glide.RequestManager} of connectivity events., +   * If not set {@link com.bumptech.glide.manager.DefaultConnectivityMonitorFactory} would be used., +   *, +   * @param factory The factory to use, +   * @return This builder., +   */, +  public GlideBuilder setConnectivityMonitorFactory(ConnectivityMonitorFactory factory) {, +    this.connectivityMonitorFactory = factory;, +    return this;, +  }, +, +  /**, +    if (connectivityMonitorFactory == null) {, +      connectivityMonitorFactory = new DefaultConnectivityMonitorFactory();, +    }, +, +        context,, +        connectivityMonitorFactory,, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +    this(context, lifecycle, treeNode,, +        new RequestTracker(), Glide.get(context).getConnectivityMonitorFactory());, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.manager.ConnectivityMonitorFactory;, +  private final ConnectivityMonitorFactory connectivityMonitorFactory;, +      Context context,, +      ConnectivityMonitorFactory connectivityMonitorFactory,, +    this.connectivityMonitorFactory = connectivityMonitorFactory;, +  ConnectivityMonitorFactory getConnectivityMonitorFactory() {, +    return connectivityMonitorFactory;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.manager.ConnectivityMonitorFactory;, +import com.bumptech.glide.manager.DefaultConnectivityMonitorFactory;, +  private ConnectivityMonitorFactory connectivityMonitorFactory;, +   * Sets the {@link com.bumptech.glide.manager.ConnectivityMonitorFactory}, +   * to use to notify {@link com.bumptech.glide.RequestManager} of connectivity events., +   * If not set {@link com.bumptech.glide.manager.DefaultConnectivityMonitorFactory} would be used., +   *, +   * @param factory The factory to use, +   * @return This builder., +   */]
[+++ b/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java, +public abstract class BaseTarget<Z> implements Target<Z> {, +++ b/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java, +public abstract class BaseTarget<Z> implements Target<Z> {, +++ b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java, +public abstract class SimpleTarget<Z> extends BaseTarget<Z> {]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java, +    // Generates the String and list of arguments to pass in when calling this method or super., +    // IE centerCrop(context) creates methodLiterals="%L" and methodArgs=[centerCrop, context]., +    List<Object> methodArgs = new ArrayList<>();, +    methodArgs.add(element.getSimpleName().toString());, +    String methodLiterals = "";, +        methodLiterals += "$L, ";, +        methodArgs.add(variable.getSimpleName().toString());, +      methodLiterals = methodLiterals.substring(0, methodLiterals.length() - 2);, +    builder.beginControlFlow("if (isAutoCloneEnabled())"), +        .addStatement(, +            "return clone().$N(" + methodLiterals + ")", methodArgs.toArray(new Object[0])), +        .endControlFlow();, +, +    // Add the correct super() call., +    if (overrideType == OVERRIDE_EXTEND) {, +      String callSuper = "super.$L(" + methodLiterals + ")";, +      builder.addStatement(callSuper, methodArgs.toArray(new Object[0])), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java, +    // Generates the String and list of arguments to pass in when calling this method or super., +    // IE centerCrop(context) creates methodLiterals="%L" and methodArgs=[centerCrop, context]., +    List<Object> methodArgs = new ArrayList<>();, +    methodArgs.add(element.getSimpleName().toString());, +    String methodLiterals = "";, +        methodLiterals += "$L, ";, +        methodArgs.add(variable.getSimpleName().toString());, +      methodLiterals = methodLiterals.substring(0, methodLiterals.length() - 2);, +    builder.beginControlFlow("if (isAutoCloneEnabled())"), +        .addStatement(, +            "return clone().$N(" + methodLiterals + ")", methodArgs.toArray(new Object[0])), +        .endControlFlow();, +, +    // Add the correct super() call., +    if (overrideType == OVERRIDE_EXTEND) {, +      String callSuper = "super.$L(" + methodLiterals + ")";, +      builder.addStatement(callSuper, methodArgs.toArray(new Object[0])), +++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +  protected boolean isAutoCloneEnabled() {, +    return isAutoCloneEnabled;, +  }, +]
[+++ b/library/src/main/java/com/bumptech/glide/request/target/CustomTarget.java, +package com.bumptech.glide.request.target;, +, +import android.graphics.Bitmap;, +import android.graphics.drawable.Drawable;, +import android.support.annotation.NonNull;, +import android.support.annotation.Nullable;, +import android.view.View;, +import android.widget.ImageView;, +import com.bumptech.glide.request.Request;, +import com.bumptech.glide.request.transition.Transition;, +import com.bumptech.glide.util.Util;, +, +/**, + * A base {@link Target} for loading resources ({@link android.graphics.Bitmap}, {@link Drawable}, + * etc) that are used outside of {@link android.view.View}s., + *, + * <p>If you're loading a resource into a {@link View}, use, + * {@link com.bumptech.glide.RequestBuilder#into(ImageView)}, a subclass of {@link ImageViewTarget},, + * or {@link CustomViewTarget}. Using this class to load resources into {@link View}s can prevent, + * Glide from correctly cancelling any previous loads, which may result in incorrect images, + * appearing in the view, especially in scrolling views like, + * {@link android.support.v7.widget.RecyclerView}., + *, + * <p>You <em>MUST</em> implement {@link #onLoadCleared(Drawable)} and ensure that all references to, + * any resource passed into the target in {@link #onResourceReady(Object, Transition)} are removed, + * before {@link #onLoadCleared(Drawable)} completes. Failing to do so can result in graphical, + * corruption, crashes caused by recycled {@link Bitmap}s, and other undefined behavior. It is never, + * safe to leave {@link #onLoadCleared(Drawable)} unimplemented or empty. Even if you do not, + * manually clear this {@link Target}, Glide may do so automatically after certain lifecycle events, + * in {@link android.support.v4.app.Fragment}s and {@link android.app.Activity}s., + *, + * <p>This class can only be used with {@link Target#SIZE_ORIGINAL} or when the desired resource, + * dimensions are known when the {@link Target} is created. If you'd like to run some asynchronous, + * process and make full use of {@link #getSize(SizeReadyCallback)} and {@link SizeReadyCallback},, + * extend {@link Target} directly instead of using this class., + *, + * @param <T> The type of resource that will be loaded (e.g. {@link Bitmap})., + */, +public abstract class CustomTarget<T> implements Target<T> {, +, +  private final int width;, +  private final int height;, +, +  @Nullable, +  private Request request;, +, +  /**, +   * Creates a new {@link CustomTarget} that will attempt to load the resource in its original size., +   *, +   * <p>This constructor can cause very memory inefficient loads if the resource is large and can, +   * cause OOMs. It's provided as a convenience for when you'd like to specify dimensions with, +   * {@link com.bumptech.glide.request.RequestOptions#override(int)}. In all other cases, prefer, +   * {@link #CustomTarget(int, int)}., +   */, +  public CustomTarget() {, +    this(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);, +  }, +, +  /**, +   * Creates a new {@code CustomTarget} that will return the given {@code width} and {@link @code}, +   * as the requested size (unless overridden by, +   * {@link com.bumptech.glide.request.RequestOptions#override(int)} in the request)., +   *, +   * @param width The requested width (>= 0, or == Target.SIZE_ORIGINAL)., +   * @param height The requested height (>= 0, or == Target.SIZE_ORIGINAL)., +   */, +  public CustomTarget(int width, int height) {, +     if (!Util.isValidDimensions(width, height)) {, +      throw new IllegalArgumentException(, +          "Width and height must both be > 0 or Target#SIZE_ORIGINAL, but given" + " width: ", +              + width + " and height: " + height);, +    }, +, +    this.width = width;, +    this.height = height;, +  }, +, +  @Override, +  public void onStart() {, +    // Intentionally empty, this can be optionally implemented by subclasses., +  }, +, +  @Override, +  public void onStop() {, +    // Intentionally empty, this can be optionally implemented by subclasses., +  }, +, +  @Override, +  public void onDestroy() {, +    // Intentionally empty, this can be optionally implemented by subclasses., +  }, +, +  @Override, +  public void onLoadStarted(@Nullable Drawable placeholder) {, +    // Intentionally empty, this can be optionally implemented by subclasses., +  }, +, +  @Override, +  public void onLoadFailed(@Nullable Drawable errorDrawable) {]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableToBitmapConverter.java, +import com.bumptech.glide.load.engine.Resource;, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;, +  private static final BitmapPool NO_BITMAP_POOL = new BitmapPoolAdapter();, +  static Resource<Bitmap> convert(BitmapPool bitmapPool, Drawable drawable, int width, int height) {, +    boolean isRecycleable = false;, +      // We created and drew to the Bitmap, so it's safe for us to recycle or re-use., +      isRecycleable = true;, +    BitmapPool toUse = isRecycleable ? bitmapPool : NO_BITMAP_POOL;, +    return BitmapResource.obtain(result, toUse);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableToBitmapConverter.java, +import com.bumptech.glide.load.engine.Resource;, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;, +  private static final BitmapPool NO_BITMAP_POOL = new BitmapPoolAdapter();, +  static Resource<Bitmap> convert(BitmapPool bitmapPool, Drawable drawable, int width, int height) {, +    boolean isRecycleable = false;, +      // We created and drew to the Bitmap, so it's safe for us to recycle or re-use., +      isRecycleable = true;, +    BitmapPool toUse = isRecycleable ? bitmapPool : NO_BITMAP_POOL;, +    return BitmapResource.obtain(result, toUse);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java, +    Resource<Bitmap> bitmapResourceToTransform =, +        DrawableToBitmapConverter.convert(bitmapPool, drawable, outWidth, outHeight);, +    if (bitmapResourceToTransform == null) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableToBitmapConverter.java, +import com.bumptech.glide.load.engine.Resource;, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;, +  private static final BitmapPool NO_BITMAP_POOL = new BitmapPoolAdapter();, +  static Resource<Bitmap> convert(BitmapPool bitmapPool, Drawable drawable, int width, int height) {, +    boolean isRecycleable = false;, +      // We created and drew to the Bitmap, so it's safe for us to recycle or re-use., +      isRecycleable = true;, +    BitmapPool toUse = isRecycleable ? bitmapPool : NO_BITMAP_POOL;, +    return BitmapResource.obtain(result, toUse);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DrawableTransformation.java, +    Resource<Bitmap> bitmapResourceToTransform =, +        DrawableToBitmapConverter.convert(bitmapPool, drawable, outWidth, outHeight);, +    if (bitmapResourceToTransform == null) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java, +    Drawable drawable = drawableResource.get();, +    return DrawableToBitmapConverter.convert(bitmapPool, drawable, width, height);]
[+++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/AppModuleWithMultipleExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/AppModuleWithMultipleExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/AppModuleWithMultipleExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/AppModuleWithMultipleExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/AppModuleWithMultipleExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/AppModuleWithMultipleExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/AppModuleWithMultipleExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/AppModuleWithMultipleExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/AppModuleWithMultipleExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/AppModuleWithMultipleExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/AppModuleWithExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithLibraryInPackageTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/AppModuleWithMultipleExcludes.java, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppAndLibraryGlideModulesTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedAppGlideModuleImpl.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GeneratedRequestManagerFactory.java, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideApp.java]
[+++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +    private int overrideHeight = -1;, +    private int overrideWidth = -1;, +     * Overrides the {@link Target}'s width and height with the given values. This is useful almost exclusively for, +     * thumbnails, and should only be used when you both need a very specific sized image and when it is impossible or, +     * impractical to return that size from {@link Target#getSize(Target.SizeReadyCallback)}., +     *, +     * @param width The width to use to load the resource., +     * @param height The height to use to load the resource., +     * @return This RequestBuilder., +     */, +    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> override(int width, int height) {, +        if (width <= 0) {, +            throw new IllegalArgumentException("Width must be >= 0");, +        }, +        if (height <= 0) {, +            throw new IllegalArgumentException("Height must be >= 0");, +        }, +        this.overrideWidth = width;, +        this.overrideHeight = height;, +, +        return this;, +    }, +, +    /**, +                animationFactory,, +                overrideWidth,, +                overrideHeight);, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +    private int overrideHeight = -1;, +    private int overrideWidth = -1;, +     * Overrides the {@link Target}'s width and height with the given values. This is useful almost exclusively for, +     * thumbnails, and should only be used when you both need a very specific sized image and when it is impossible or, +     * impractical to return that size from {@link Target#getSize(Target.SizeReadyCallback)}., +     *, +     * @param width The width to use to load the resource., +     * @param height The height to use to load the resource., +     * @return This RequestBuilder., +     */, +    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> override(int width, int height) {, +        if (width <= 0) {, +            throw new IllegalArgumentException("Width must be >= 0");, +        }, +        if (height <= 0) {, +            throw new IllegalArgumentException("Height must be >= 0");, +        }, +        this.overrideWidth = width;, +        this.overrideHeight = height;, +, +        return this;, +    }, +, +    /**, +                animationFactory,, +                overrideWidth,, +                overrideHeight);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +    private final KeyFactory keyFactory;, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +    private int overrideHeight = -1;, +    private int overrideWidth = -1;, +     * Overrides the {@link Target}'s width and height with the given values. This is useful almost exclusively for, +     * thumbnails, and should only be used when you both need a very specific sized image and when it is impossible or, +     * impractical to return that size from {@link Target#getSize(Target.SizeReadyCallback)}., +     *, +     * @param width The width to use to load the resource., +     * @param height The height to use to load the resource., +     * @return This RequestBuilder., +     */, +    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> override(int width, int height) {, +        if (width <= 0) {, +            throw new IllegalArgumentException("Width must be >= 0");, +        }, +        if (height <= 0) {, +            throw new IllegalArgumentException("Height must be >= 0");, +        }, +        this.overrideWidth = width;, +        this.overrideHeight = height;, +, +        return this;, +    }, +, +    /**, +                animationFactory,, +                overrideWidth,, +                overrideHeight);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +    private final KeyFactory keyFactory;, +++ b/library/src/main/java/com/bumptech/glide/request/GenericRequest.java, +    private final int overrideWidth;, +    private final int overrideHeight;, +            GlideAnimationFactory<R> animationFactory,, +            int overrideWidth,, +            int overrideHeight) {, +        this.overrideWidth = overrideWidth;, +        this.overrideHeight = overrideHeight;, +        if (overrideWidth > 0 && overrideHeight > 0) {, +            onSizeReady(overrideWidth, overrideHeight);, +        } else {, +        }]
[+++ b/.travis.yml, +script: 'travis_retry ./gradlew build --parallel']
[+++ b/library/src/com/bumptech/photos/resize/BitmapTracker.java, +import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;, +    private final ConcurrentBitmapPool target;, +    public BitmapTracker(ConcurrentBitmapPool target, int bitmapsPerSize) {, +++ b/library/src/com/bumptech/photos/resize/BitmapTracker.java, +import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;, +    private final ConcurrentBitmapPool target;, +    public BitmapTracker(ConcurrentBitmapPool target, int bitmapsPerSize) {, +++ b/library/src/com/bumptech/photos/resize/ImageManager.java, +import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;, +    private final ConcurrentBitmapPool bitmapCache;, +            bitmapCache = new ConcurrentBitmapPool(options.maxPerSize);, +++ b/library/src/com/bumptech/photos/resize/BitmapTracker.java, +import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;, +    private final ConcurrentBitmapPool target;, +    public BitmapTracker(ConcurrentBitmapPool target, int bitmapsPerSize) {, +++ b/library/src/com/bumptech/photos/resize/ImageManager.java, +import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;, +    private final ConcurrentBitmapPool bitmapCache;, +            bitmapCache = new ConcurrentBitmapPool(options.maxPerSize);, +++ b/library/src/com/bumptech/photos/resize/ImageResizer.java, +import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;, +, +    private final ConcurrentBitmapPool bitmapPool;, +, +    public ImageResizer(ConcurrentBitmapPool bitmapPool) {, +    public ImageResizer(ConcurrentBitmapPool bitmapPool, BitmapFactory.Options defaultOptions){, +++ b/library/src/com/bumptech/photos/resize/BitmapTracker.java, +import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;, +    private final ConcurrentBitmapPool target;, +    public BitmapTracker(ConcurrentBitmapPool target, int bitmapsPerSize) {, +++ b/library/src/com/bumptech/photos/resize/ImageManager.java, +import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;, +    private final ConcurrentBitmapPool bitmapCache;, +            bitmapCache = new ConcurrentBitmapPool(options.maxPerSize);, +++ b/library/src/com/bumptech/photos/resize/ImageResizer.java, +import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapPool;, +, +    private final ConcurrentBitmapPool bitmapPool;, +, +    public ImageResizer(ConcurrentBitmapPool bitmapPool) {, +    public ImageResizer(ConcurrentBitmapPool bitmapPool, BitmapFactory.Options defaultOptions){, +++ b/library/src/com/bumptech/photos/resize/bitmap_recycle/ConcurrentBitmapPool.java, +/*, + * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved., + */, +, +package com.bumptech.photos.resize.bitmap_recycle;, +, +import android.graphics.Bitmap;, +import com.bumptech.photos.util.Log;, +, +import java.util.ArrayDeque;, +import java.util.HashMap;, +import java.util.Map;, +import java.util.Queue;, +, +/**, + * A cache of Bitmaps made available by size used to manage recycled bitmaps, + */, +public class ConcurrentBitmapPool {, +    private static final int DEFAULT_MAX_PER_SIZE = 20;, +    private Map<Integer, Queue<Bitmap>> availableBitmaps = new HashMap<Integer, Queue<Bitmap>>();, +    private final int maxPerSize;, +, +    public ConcurrentBitmapPool(int maxPerSize) {, +        this.maxPerSize = maxPerSize == 0 ? DEFAULT_MAX_PER_SIZE : maxPerSize;, +    }, +, +    public synchronized void put(Bitmap bitmap) {, +        final int sizeKey = getSizeKey(bitmap.getWidth(), bitmap.getHeight());, +        Queue<Bitmap> available = availableBitmaps.get(sizeKey);, +        if (available == null) {, +            available = new ArrayDeque<Bitmap>();, +            availableBitmaps.put(sizeKey, available);, +            available.offer(bitmap);, +        } else if (available.size() < maxPerSize) {, +            available.offer(bitmap);, +        }, +    }, +, +    public synchronized Bitmap get(int width, int height) {, +        final int sizeKey = getSizeKey(width, height);, +        final Queue<Bitmap> available = availableBitmaps.get(sizeKey);, +, +        if (available == null) {, +            Log.d("SBC: missing bitmap for key= " + sizeKey);, +            return null;, +        } else {, +            //Log.d("SBC:  get key=" + sizeKey + " available=" + (available.size() - 1));, +            return available.poll();, +        }, +    }, +, +    //see http://szudzik.com/ElegantPairing.pdf, +    //assumes width <= Short.MAX_VALUE && height <= SHORT.MAX_VALUE && width >= 0 && height >= 0, +    private static int getSizeKey(int width, int height) {, +        return width >= height ? width * width + width + height : width + height * height;, +    }, +}]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java, +   * Glide.with(fragment/activity).load()} to avoid object churn.]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +        drawable = new GifDrawable(Robolectric.application, provider, bitmapPool, transformation, 100, 100,  gifHeader,, +                new byte[0], firstFrame);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +        drawable = new GifDrawable(Robolectric.application, provider, bitmapPool, transformation, 100, 100,  gifHeader,, +                new byte[0], firstFrame);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameManagerTest.java, +        new GifFrameManager(Robolectric.application, mock(GifDecoder.class), null, 100, 100);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +        drawable = new GifDrawable(Robolectric.application, provider, bitmapPool, transformation, 100, 100,  gifHeader,, +                new byte[0], firstFrame);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameManagerTest.java, +        new GifFrameManager(Robolectric.application, mock(GifDecoder.class), null, 100, 100);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameModelLoaderTest.java, +    public void testFetcherIdIncludesFrameIndex() {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +        drawable = new GifDrawable(Robolectric.application, provider, bitmapPool, transformation, 100, 100,  gifHeader,, +                new byte[0], firstFrame);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameManagerTest.java, +        new GifFrameManager(Robolectric.application, mock(GifDecoder.class), null, 100, 100);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameModelLoaderTest.java, +    public void testFetcherIdIncludesFrameIndex() {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java, +        order.verify(gifDecoder).setData(eq(gifHeader), eq(data));, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +        drawable = new GifDrawable(Robolectric.application, provider, bitmapPool, transformation, 100, 100,  gifHeader,, +                new byte[0], firstFrame);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameManagerTest.java, +        new GifFrameManager(Robolectric.application, mock(GifDecoder.class), null, 100, 100);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameModelLoaderTest.java, +    public void testFetcherIdIncludesFrameIndex() {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java, +        order.verify(gifDecoder).setData(eq(gifHeader), eq(data));, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +                logWithTimeAndKey("Loaded resource from cache", startTime, key);, +                    logWithTimeAndKey("Loaded resource from active resources", startTime, key);, +                logWithTimeAndKey("Added to existing load", startTime, key);, +            logWithTimeAndKey("Started new load", startTime, key);, +    private static void logWithTimeAndKey(String log, long startTime, Key key) {, +        Log.v(TAG, log + " in " + LogTime.getElapsedMillis(startTime) + "ms, key: " + key);, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +        drawable = new GifDrawable(Robolectric.application, provider, bitmapPool, transformation, 100, 100,  gifHeader,, +                new byte[0], firstFrame);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameManagerTest.java, +        new GifFrameManager(Robolectric.application, mock(GifDecoder.class), null, 100, 100);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameModelLoaderTest.java, +    public void testFetcherIdIncludesFrameIndex() {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java, +        order.verify(gifDecoder).setData(eq(gifHeader), eq(data));, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +                logWithTimeAndKey("Loaded resource from cache", startTime, key);, +                    logWithTimeAndKey("Loaded resource from active resources", startTime, key);, +                logWithTimeAndKey("Added to existing load", startTime, key);, +            logWithTimeAndKey("Started new load", startTime, key);, +    private static void logWithTimeAndKey(String log, long startTime, Key key) {, +        Log.v(TAG, log + " in " + LogTime.getElapsedMillis(startTime) + "ms, key: " + key);, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java, +, +    @Override, +    public void release(Bitmap bitmap) {, +        if (!bitmapPool.put(bitmap)) {, +            bitmap.recycle();, +        }, +    }, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +        drawable = new GifDrawable(Robolectric.application, provider, bitmapPool, transformation, 100, 100,  gifHeader,, +                new byte[0], firstFrame);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameManagerTest.java, +        new GifFrameManager(Robolectric.application, mock(GifDecoder.class), null, 100, 100);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameModelLoaderTest.java, +    public void testFetcherIdIncludesFrameIndex() {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java, +        order.verify(gifDecoder).setData(eq(gifHeader), eq(data));, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +                logWithTimeAndKey("Loaded resource from cache", startTime, key);, +                    logWithTimeAndKey("Loaded resource from active resources", startTime, key);, +                logWithTimeAndKey("Added to existing load", startTime, key);, +            logWithTimeAndKey("Started new load", startTime, key);, +    private static void logWithTimeAndKey(String log, long startTime, Key key) {, +        Log.v(TAG, log + " in " + LogTime.getElapsedMillis(startTime) + "ms, key: " + key);, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java, +, +    @Override, +    public void release(Bitmap bitmap) {, +        if (!bitmapPool.put(bitmap)) {, +            bitmap.recycle();, +        }, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +            Transformation<Bitmap> frameTransformation, int targetFrameWidth, int targetFrameHeight,, +        this(new GifState(gifHeader, data, context, frameTransformation, targetFrameWidth, targetFrameHeight,, +        decoder.setData(state.gifHeader, state.data);, +                state.targetHeight);, +        public GifState(GifHeader header, byte[] data, Context context,]
[+++ b/library/findbugs-exclude.xml, +    <!-- Re-using the byte array saves allocations, there's no serious risk of mutations. -->, +    <Match>, +      <Class name="com.bumptech.glide.util.FixedPreloadSizeProvider" />, +      <Bug pattern="EI_EXPOSE_REP" />, +    </Match>, +, +++ b/library/findbugs-exclude.xml, +    <!-- Re-using the byte array saves allocations, there's no serious risk of mutations. -->, +    <Match>, +      <Class name="com.bumptech.glide.util.FixedPreloadSizeProvider" />, +      <Bug pattern="EI_EXPOSE_REP" />, +    </Match>, +, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +            context,, +            arrayPool,, +            registry,, +            imageViewTargetFactory,, +            defaultRequestOptions,, +            defaultTransitionOptions,, +            engine,, +            logLevel);, +++ b/library/findbugs-exclude.xml, +    <!-- Re-using the byte array saves allocations, there's no serious risk of mutations. -->, +    <Match>, +      <Class name="com.bumptech.glide.util.FixedPreloadSizeProvider" />, +      <Bug pattern="EI_EXPOSE_REP" />, +    </Match>, +, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +            context,, +            arrayPool,, +            registry,, +            imageViewTargetFactory,, +            defaultRequestOptions,, +            defaultTransitionOptions,, +            engine,, +            logLevel);, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +  private final ArrayPool arrayPool;, +  public GlideContext(, +      Context context,, +      ArrayPool arrayPool,, +      Registry registry,, +      ImageViewTargetFactory imageViewTargetFactory,, +      RequestOptions defaultRequestOptions,, +      Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions,, +      Engine engine,, +    this.arrayPool = arrayPool;, +, +  public ArrayPool getArrayPool() {, +    return arrayPool;, +  }, +++ b/library/findbugs-exclude.xml, +    <!-- Re-using the byte array saves allocations, there's no serious risk of mutations. -->, +    <Match>, +      <Class name="com.bumptech.glide.util.FixedPreloadSizeProvider" />, +      <Bug pattern="EI_EXPOSE_REP" />, +    </Match>, +, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +            context,, +            arrayPool,, +            registry,, +            imageViewTargetFactory,, +            defaultRequestOptions,, +            defaultTransitionOptions,, +            engine,, +            logLevel);, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +  private final ArrayPool arrayPool;, +  public GlideContext(, +      Context context,, +      ArrayPool arrayPool,, +      Registry registry,, +      ImageViewTargetFactory imageViewTargetFactory,, +      RequestOptions defaultRequestOptions,, +      Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions,, +      Engine engine,, +    this.arrayPool = arrayPool;, +, +  public ArrayPool getArrayPool() {, +    return arrayPool;, +  }, +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java, +    int size = parsers.size();, +    for (int i = 0; i < size; i++) {, +      ImageHeaderParser parser = parsers.get(i);, +    int size = parsers.size();, +    for (int i = 0; i < size; i++) {, +      ImageHeaderParser parser = parsers.get(i);, +    int size = parsers.size();, +    for (int i = 0; i < size; i++) {, +      ImageHeaderParser parser = parsers.get(i);, +++ b/library/findbugs-exclude.xml, +    <!-- Re-using the byte array saves allocations, there's no serious risk of mutations. -->, +    <Match>]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/UriLoaderTest.java, +    private DataFetcher<InputStream> assetUriFetcher;, +    @SuppressWarnings("uncecked"), +        assetUriFetcher = mock(DataFetcher.class);, +, +            @Override, +            protected DataFetcher<InputStream> getAssetPathFetcher(Context context, String path) {, +                return assetUriFetcher;, +            }, +    public void testHandlesAssetUris() {, +        Uri assetUri = Uri.parse("file:///android_asset/assetName");, +        DataFetcher fetcher = loader.getResourceFetcher(assetUri, IMAGE_SIDE, IMAGE_SIDE);, +        assertEquals(assetUriFetcher, fetcher);, +    }, +, +    @Test, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/UriLoaderTest.java, +    private DataFetcher<InputStream> assetUriFetcher;, +    @SuppressWarnings("uncecked"), +        assetUriFetcher = mock(DataFetcher.class);, +, +            @Override, +            protected DataFetcher<InputStream> getAssetPathFetcher(Context context, String path) {, +                return assetUriFetcher;, +            }, +    public void testHandlesAssetUris() {, +        Uri assetUri = Uri.parse("file:///android_asset/assetName");, +        DataFetcher fetcher = loader.getResourceFetcher(assetUri, IMAGE_SIDE, IMAGE_SIDE);, +        assertEquals(assetUriFetcher, fetcher);, +    }, +, +    @Test, +++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java, +package com.bumptech.glide.load.data;, +, +import android.content.res.AssetManager;, +import android.util.Log;, +import com.bumptech.glide.Priority;, +, +import java.io.IOException;, +, +/**, + * An abstract class for obtaining data for an asset path using an {@link android.content.res.AssetManager}., + *, + * @param <T> The type of data obtained from the asset path (InputStream, FileDescriptor etc)., + */, +public abstract class AssetPathFetcher<T> implements DataFetcher<T> {, +    private static final String TAG = "AssetUriFetcher";, +    private final String assetPath;, +    private final AssetManager assetManager;, +    private T data;, +, +    public AssetPathFetcher(AssetManager assetManager, String assetPath) {, +        this.assetManager = assetManager;, +        this.assetPath = assetPath;, +    }, +, +    @Override, +    public T loadData(Priority priority) throws Exception {, +        data = loadResource(assetManager, assetPath);, +        return data;, +    }, +, +    @Override, +    public void cleanup() {, +        if (data == null) {, +            return;, +        }, +        try {, +            close(data);, +        } catch (IOException e) {, +            if (Log.isLoggable(TAG, Log.VERBOSE)) {, +                Log.v(TAG, "Failed to close data", e);, +            }, +        }, +, +    }, +, +    @Override, +    public String getId() {, +        return assetPath;, +    }, +, +    @Override, +    public void cancel() {, +        // Do nothing., +    }, +, +    /**, +     * Opens the given asset path with the given {@link android.content.res.AssetManager} and returns the conrete data, +     * type returned by the AssetManager., +     *, +     * @param assetManager An AssetManager to use to open the given path., +     * @param path A string path pointing to a resource in assets to open., +     */, +    protected abstract T loadResource(AssetManager assetManager, String path) throws IOException;, +, +    /**, +     * Closes the concrete data type if necessary., +     *]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import com.bumptech.glide.load.HttpException;, +        } else {, +          callback.onLoadFailed(new HttpException(response.message(), response.code()));, +        }, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import com.bumptech.glide.load.HttpException;, +        } else {, +          callback.onLoadFailed(new HttpException(response.message(), response.code()));, +        }, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +import com.bumptech.glide.load.HttpException;, +        } else {, +          callback.onLoadFailed(new HttpException(response.message(), response.code()));, +        }]
[+++ b/.travis.yml, +  - build-tools-24.0.2, +  - android-24, +  - oraclejdk8, +++ b/.travis.yml, +  - build-tools-24.0.2, +  - android-24, +  - oraclejdk8, +++ b/build.gradle, +++ b/.travis.yml, +  - build-tools-24.0.2, +  - android-24, +  - oraclejdk8, +++ b/build.gradle, +++ b/gradle.properties, +SUPPORT_V4_VERSION=24.2.0, +SUPPORT_V7_VERSION=24.2.0, +ANDROID_GRADLE_VERSION=2.1.3, +ROBOLECTRIC_VERSION=3.1.2, +COMPILE_SDK_VERSION=24, +BUILD_TOOLS_VERSION=24.0.2, +TARGET_SDK_VERSION=24, +, +org.gradle.jvmargs=-Xmx2048M, +++ b/.travis.yml, +  - build-tools-24.0.2, +  - android-24, +  - oraclejdk8, +++ b/build.gradle, +++ b/gradle.properties, +SUPPORT_V4_VERSION=24.2.0, +SUPPORT_V7_VERSION=24.2.0, +ANDROID_GRADLE_VERSION=2.1.3, +ROBOLECTRIC_VERSION=3.1.2, +COMPILE_SDK_VERSION=24, +BUILD_TOOLS_VERSION=24.0.2, +TARGET_SDK_VERSION=24, +, +org.gradle.jvmargs=-Xmx2048M, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip, +++ b/.travis.yml, +  - build-tools-24.0.2, +  - android-24, +  - oraclejdk8, +++ b/build.gradle, +++ b/gradle.properties, +SUPPORT_V4_VERSION=24.2.0, +SUPPORT_V7_VERSION=24.2.0, +ANDROID_GRADLE_VERSION=2.1.3, +ROBOLECTRIC_VERSION=3.1.2, +COMPILE_SDK_VERSION=24, +BUILD_TOOLS_VERSION=24.0.2, +TARGET_SDK_VERSION=24, +, +org.gradle.jvmargs=-Xmx2048M, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip, +++ b/integration/gifencoder/build.gradle, +++ b/.travis.yml, +  - build-tools-24.0.2, +  - android-24, +  - oraclejdk8, +++ b/build.gradle, +++ b/gradle.properties, +SUPPORT_V4_VERSION=24.2.0, +SUPPORT_V7_VERSION=24.2.0, +ANDROID_GRADLE_VERSION=2.1.3, +ROBOLECTRIC_VERSION=3.1.2, +COMPILE_SDK_VERSION=24, +BUILD_TOOLS_VERSION=24.0.2, +TARGET_SDK_VERSION=24, +, +org.gradle.jvmargs=-Xmx2048M, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip, +++ b/integration/gifencoder/build.gradle, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +        responseBody = response.body();, +++ b/.travis.yml, +  - build-tools-24.0.2, +  - android-24, +  - oraclejdk8, +++ b/build.gradle, +++ b/gradle.properties, +SUPPORT_V4_VERSION=24.2.0, +SUPPORT_V7_VERSION=24.2.0, +ANDROID_GRADLE_VERSION=2.1.3, +ROBOLECTRIC_VERSION=3.1.2, +COMPILE_SDK_VERSION=24, +BUILD_TOOLS_VERSION=24.0.2, +TARGET_SDK_VERSION=24, +, +org.gradle.jvmargs=-Xmx2048M, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip, +++ b/integration/gifencoder/build.gradle, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +        responseBody = response.body();, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java]
[+++ b/checkstyle.xml, +    <module name="SuppressionFilter">, +        <property name="file" value="checkstyle_suppressions.xml" />, +    </module>, +, +        <module name="JavadocType">, +            <property name="scope" value="public"/>, +        </module>, +++ b/checkstyle.xml, +    <module name="SuppressionFilter">, +        <property name="file" value="checkstyle_suppressions.xml" />, +    </module>, +, +        <module name="JavadocType">, +            <property name="scope" value="public"/>, +        </module>, +++ b/checkstyle_suppressions.xml, +<?xml version="1.0"?>, +, +<!DOCTYPE suppressions PUBLIC, +    "-//Puppy Crawl//DTD Suppressions 1.1//EN", +    "http://www.puppycrawl.com/dtds/suppressions_1_1.dtd">, +, +<suppressions>, +    <suppress files=".*/library/src/test/.*" checks="[a-zA-Z0-9]*"/>, +</suppressions>, +, +++ b/checkstyle.xml, +    <module name="SuppressionFilter">, +        <property name="file" value="checkstyle_suppressions.xml" />, +    </module>, +, +        <module name="JavadocType">, +            <property name="scope" value="public"/>, +        </module>, +++ b/checkstyle_suppressions.xml, +<?xml version="1.0"?>, +, +<!DOCTYPE suppressions PUBLIC, +    "-//Puppy Crawl//DTD Suppressions 1.1//EN", +    "http://www.puppycrawl.com/dtds/suppressions_1_1.dtd">, +, +<suppressions>, +    <suppress files=".*/library/src/test/.*" checks="[a-zA-Z0-9]*"/>, +</suppressions>, +, +++ b/integration/volley/src/main/java/com/bumptech/glide/volley/VolleyUrlLoader.java, +    /**, +     * An interface for building {@link com.bumptech.glide.volley.VolleyRequestFuture}s., +     */, +    /**, +     * The default factory for {@link com.bumptech.glide.volley.VolleyUrlLoader}s., +     */, +++ b/checkstyle.xml, +    <module name="SuppressionFilter">, +        <property name="file" value="checkstyle_suppressions.xml" />, +    </module>, +, +        <module name="JavadocType">, +            <property name="scope" value="public"/>, +        </module>, +++ b/checkstyle_suppressions.xml, +<?xml version="1.0"?>, +, +<!DOCTYPE suppressions PUBLIC, +    "-//Puppy Crawl//DTD Suppressions 1.1//EN", +    "http://www.puppycrawl.com/dtds/suppressions_1_1.dtd">, +, +<suppressions>, +    <suppress files=".*/library/src/test/.*" checks="[a-zA-Z0-9]*"/>, +</suppressions>, +, +++ b/integration/volley/src/main/java/com/bumptech/glide/volley/VolleyUrlLoader.java, +    /**, +     * An interface for building {@link com.bumptech.glide.volley.VolleyRequestFuture}s., +     */, +    /**, +     * The default factory for {@link com.bumptech.glide.volley.VolleyUrlLoader}s., +     */, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, + *, + * @param <T> The type of {@link com.bumptech.glide.load.engine.Resource} that will be transformed., +++ b/checkstyle.xml, +    <module name="SuppressionFilter">, +        <property name="file" value="checkstyle_suppressions.xml" />, +    </module>, +, +        <module name="JavadocType">, +            <property name="scope" value="public"/>, +        </module>, +++ b/checkstyle_suppressions.xml, +<?xml version="1.0"?>, +, +<!DOCTYPE suppressions PUBLIC, +    "-//Puppy Crawl//DTD Suppressions 1.1//EN", +    "http://www.puppycrawl.com/dtds/suppressions_1_1.dtd">, +, +<suppressions>, +    <suppress files=".*/library/src/test/.*" checks="[a-zA-Z0-9]*"/>, +</suppressions>]
[+++ b/.travis.yml, +  - yes | $ANDROID_HOME/tools/bin/sdkmanager "build-tools;28.0.3" "platforms;android-28"]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java, +    Context targetContext = findContextForPackage(source, packageName);, +  private Context findContextForPackage(Uri source, String packageName) {, +    // Fast path, +    if (packageName.equals(context.getPackageName())) {, +      return context;, +    }, +, +      // The parent APK holds the correct context if the resource is located in a split, +      if (packageName.contains(context.getPackageName())) {, +        return context;, +      }, +]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +  public void loadGif_withInterlacedTransparentGif_sizeOriginal_succeeds(), +      throws ExecutionException, InterruptedException {, +    GifDrawable gifDrawable =, +        GlideApp.with(context), +            .asGif(), +            .load(ResourceIds.raw.interlaced_transparent_gif), +            .submit(), +            .get();, +    assertThat(gifDrawable).isNotNull();, +    gifDrawable.stop();, +  }, +, +  @Test, +  public void loadGif_withInterlacedTransparentGif_downsampled_succeeds(), +      throws ExecutionException, InterruptedException {, +    GifDrawable gifDrawable =, +        GlideApp.with(context), +            .asGif(), +            .load(ResourceIds.raw.interlaced_transparent_gif), +            .submit(10, 10), +            .get();, +    assertThat(gifDrawable).isNotNull();, +    gifDrawable.stop();, +  }, +, +  @Test, +  public void loadGif_withTransparentGif_sizeOriginal_succeeds(), +      throws ExecutionException, InterruptedException {, +    GifDrawable gifDrawable =, +        GlideApp.with(context), +            .asGif(), +            .load(ResourceIds.raw.transparent_gif), +            .submit(), +            .get();, +    assertThat(gifDrawable).isNotNull();, +    gifDrawable.stop();, +  }, +, +  @Test, +  public void loadGif_withTransparentGif_downsampled_succeeds(), +      throws ExecutionException, InterruptedException {, +    GifDrawable gifDrawable =, +        GlideApp.with(context), +            .asGif(), +            .load(ResourceIds.raw.transparent_gif), +            .submit(10, 10), +            .get();, +    assertThat(gifDrawable).isNotNull();, +    gifDrawable.stop();, +  }, +, +  @Test, +  public void loadGif_withOpaqueGif_sizeOriginal_succeeds(), +      throws ExecutionException, InterruptedException {, +    GifDrawable gifDrawable =, +        GlideApp.with(context), +            .asGif(), +            .load(ResourceIds.raw.opaque_gif), +            .submit(), +            .get();, +    assertThat(gifDrawable).isNotNull();, +    gifDrawable.stop();, +  }, +, +  @Test, +  public void loadGif_withOpaqueGif_downsampled_succeeds(), +      throws ExecutionException, InterruptedException {, +    GifDrawable gifDrawable =, +        GlideApp.with(context), +            .asGif(), +            .load(ResourceIds.raw.opaque_gif), +            .submit(10, 10), +            .get();, +    assertThat(gifDrawable).isNotNull();, +    gifDrawable.stop();, +  }, +, +  @Test, +  public void loadGif_withOpaqueInterlacedGif_sizeOriginal_succeeds(), +      throws ExecutionException, InterruptedException {, +    GifDrawable gifDrawable =, +        GlideApp.with(context), +            .asGif(), +            .load(ResourceIds.raw.opaque_interlaced_gif), +            .submit(), +            .get();, +    assertThat(gifDrawable).isNotNull();, +    gifDrawable.stop();, +  }, +, +  @Test, +  public void loadGif_withOpaqueInterlacedGif_downsampled_succeeds(), +      throws ExecutionException, InterruptedException {, +    GifDrawable gifDrawable =, +        GlideApp.with(context), +            .asGif(), +            .load(ResourceIds.raw.opaque_interlaced_gif), +            .submit(10, 10), +            .get();]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    if (request.isEquivalentTo(previous)) {, +      // triggering RequestListeners and Targets. If the request is failed, beginning again will, +      // restart the request, giving it another chance to complete. If the request is already, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    if (request.isEquivalentTo(previous)) {, +      // triggering RequestListeners and Targets. If the request is failed, beginning again will, +      // restart the request, giving it another chance to complete. If the request is already, +++ b/library/src/main/java/com/bumptech/glide/load/model/Model.java, +package com.bumptech.glide.load.model;, +, +/**, + * An optional interface that models can implement to enhance control over Glide behaviors., + */, +public interface Model {, +, +    /**, +     * Returns {@code true} if this model produces the same image using the same mechanism, +     * (server, authentication, source etc) as the given model., +     * <p>, +     * Models must also implement {@link #equals(Object other)} and {@link #hashCode()}, +     * to ensure that caching functions correctly., +     * If this object returns {@code true} from this method for a given Model,, +     * it must also be equal to and have the same hash code as the given model., +     * <p>, +     * However, this model may be equal to and have the same hash code as a given model, +     * but still return {@code false} from this method., +     * This method optionally allows you to differentiate between Models that load the same image, +     * via multiple different means., +     * For example one Model might load the image from server A and another model might load, +     * the same image from server B., +     * The models must be equal to each other with the same hash code because they load, +     * the same image. However two requests made with the different models are not exactly the, +     * same because the way the image is loaded will differ., +     */, +    boolean isEquivalentTo(Object other);, +}, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    if (request.isEquivalentTo(previous)) {, +      // triggering RequestListeners and Targets. If the request is failed, beginning again will, +      // restart the request, giving it another chance to complete. If the request is already, +++ b/library/src/main/java/com/bumptech/glide/load/model/Model.java, +package com.bumptech.glide.load.model;, +, +/**, + * An optional interface that models can implement to enhance control over Glide behaviors., + */, +public interface Model {, +, +    /**, +     * Returns {@code true} if this model produces the same image using the same mechanism, +     * (server, authentication, source etc) as the given model., +     * <p>, +     * Models must also implement {@link #equals(Object other)} and {@link #hashCode()}, +     * to ensure that caching functions correctly., +     * If this object returns {@code true} from this method for a given Model,, +     * it must also be equal to and have the same hash code as the given model., +     * <p>, +     * However, this model may be equal to and have the same hash code as a given model, +     * but still return {@code false} from this method., +     * This method optionally allows you to differentiate between Models that load the same image, +     * via multiple different means., +     * For example one Model might load the image from server A and another model might load, +     * the same image from server B., +     * The models must be equal to each other with the same hash code because they load, +     * the same image. However two requests made with the different models are not exactly the, +     * same because the way the image is loaded will differ., +     */, +    boolean isEquivalentTo(Object other);, +}, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +          && Util.bothModelsNullEquivalentOrEquals(model, that.model), +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    if (request.isEquivalentTo(previous)) {, +      // triggering RequestListeners and Targets. If the request is failed, beginning again will, +      // restart the request, giving it another chance to complete. If the request is already, +++ b/library/src/main/java/com/bumptech/glide/load/model/Model.java, +package com.bumptech.glide.load.model;, +, +/**, + * An optional interface that models can implement to enhance control over Glide behaviors., + */, +public interface Model {, +, +    /**, +     * Returns {@code true} if this model produces the same image using the same mechanism, +     * (server, authentication, source etc) as the given model., +     * <p>, +     * Models must also implement {@link #equals(Object other)} and {@link #hashCode()}, +     * to ensure that caching functions correctly., +     * If this object returns {@code true} from this method for a given Model,, +     * it must also be equal to and have the same hash code as the given model., +     * <p>, +     * However, this model may be equal to and have the same hash code as a given model, +     * but still return {@code false} from this method., +     * This method optionally allows you to differentiate between Models that load the same image, +     * via multiple different means., +     * For example one Model might load the image from server A and another model might load, +     * the same image from server B., +     * The models must be equal to each other with the same hash code because they load]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java, +        decoder = new GifResourceDecoder(Robolectric.application, bitmapPool, parserPool, decoderPool);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java, +        decoder = new GifResourceDecoder(Robolectric.application, bitmapPool, parserPool, decoderPool);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +                new GifDrawableLoadProvider(context, bitmapPool);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java, +        decoder = new GifResourceDecoder(Robolectric.application, bitmapPool, parserPool, decoderPool);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +                new GifDrawableLoadProvider(context, bitmapPool);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableLoadProvider.java, +    public GifDrawableLoadProvider(Context context, BitmapPool bitmapPool) {, +        decoder = new GifResourceDecoder(context, bitmapPool);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java, +        decoder = new GifResourceDecoder(Robolectric.application, bitmapPool, parserPool, decoderPool);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +                new GifDrawableLoadProvider(context, bitmapPool);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableLoadProvider.java, +    public GifDrawableLoadProvider(Context context, BitmapPool bitmapPool) {, +        decoder = new GifResourceDecoder(context, bitmapPool);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java, +        this(context, bitmapPool, PARSER_POOL, DECODER_POOL);, +    GifResourceDecoder(Context context, BitmapPool bitmapPool, GifHeaderParserPool parserPool,, +            GifDecoderPool decoderPool) {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java, +        decoder = new GifResourceDecoder(Robolectric.application, bitmapPool, parserPool, decoderPool);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +                new GifDrawableLoadProvider(context, bitmapPool);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableLoadProvider.java, +    public GifDrawableLoadProvider(Context context, BitmapPool bitmapPool) {, +        decoder = new GifResourceDecoder(context, bitmapPool);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java, +        this(context, bitmapPool, PARSER_POOL, DECODER_POOL);, +    GifResourceDecoder(Context context, BitmapPool bitmapPool, GifHeaderParserPool parserPool,, +            GifDecoderPool decoderPool) {, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, +    // We can't tell if a gif has transparency to decode a partial frame on top of a previous frame, or if the final, +    // frame will actually have transparent pixels, so we must always use a format that supports transparency. We can't, +    // use ARGB_4444 because of framework issues drawing onto ARGB_4444 Bitmaps using Canvas., +    private static final Bitmap.Config BITMAP_CONFIG = Bitmap.Config.ARGB_8888;, +, +        Bitmap result = bitmapProvider.obtain(header.width, header.height, BITMAP_CONFIG);, +            result = Bitmap.createBitmap(header.width, header.height, BITMAP_CONFIG);]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawableTransformation.java]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +    /** The initial stage. */, +    INITIALIZE,, +        stage = getNextStage(Stage.INITIALIZE);, +      stage = getNextStage(stage);, +  private Stage getNextStage(Stage current) {, +    if (current == null) {, +    DiskCacheStrategy strategy = requestContext.getDiskCacheStrategy();, +    switch (current) {, +      case INITIALIZE:, +        return strategy.decodeCachedResource(), +            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);, +        return strategy.decodeCachedData(), +            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +    /** The initial stage. */, +    INITIALIZE,, +        stage = getNextStage(Stage.INITIALIZE);, +      stage = getNextStage(stage);, +  private Stage getNextStage(Stage current) {, +    if (current == null) {, +    DiskCacheStrategy strategy = requestContext.getDiskCacheStrategy();, +    switch (current) {, +      case INITIALIZE:, +        return strategy.decodeCachedResource(), +            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);, +        return strategy.decodeCachedData(), +            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +   * A Key for an {@link Boolean} option that if set to {@code true}, disables this decoder, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +    /** The initial stage. */, +    INITIALIZE,, +        stage = getNextStage(Stage.INITIALIZE);, +      stage = getNextStage(stage);, +  private Stage getNextStage(Stage current) {, +    if (current == null) {, +    DiskCacheStrategy strategy = requestContext.getDiskCacheStrategy();, +    switch (current) {, +      case INITIALIZE:, +        return strategy.decodeCachedResource(), +            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);, +        return strategy.decodeCachedData(), +            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +   * A Key for an {@link Boolean} option that if set to {@code true}, disables this decoder, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java, +    requestBuilder.clone().apply(signatureOf(new FrameSignature())).load(gifDecoder).into(next);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +    /** The initial stage. */, +    INITIALIZE,, +        stage = getNextStage(Stage.INITIALIZE);, +      stage = getNextStage(stage);, +  private Stage getNextStage(Stage current) {, +    if (current == null) {, +    DiskCacheStrategy strategy = requestContext.getDiskCacheStrategy();, +    switch (current) {, +      case INITIALIZE:, +        return strategy.decodeCachedResource(), +            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);, +        return strategy.decodeCachedData(), +            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +   * A Key for an {@link Boolean} option that if set to {@code true}, disables this decoder, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java, +    requestBuilder.clone().apply(signatureOf(new FrameSignature())).load(gifDecoder).into(next);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java, +   * A Key for an {@link Boolean} option that if set to {@code true}, disables this decoder, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +    /** The initial stage. */, +    INITIALIZE,, +        stage = getNextStage(Stage.INITIALIZE);, +      stage = getNextStage(stage);, +  private Stage getNextStage(Stage current) {, +    if (current == null) {, +    DiskCacheStrategy strategy = requestContext.getDiskCacheStrategy();, +    switch (current) {, +      case INITIALIZE:, +        return strategy.decodeCachedResource(), +            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);, +        return strategy.decodeCachedData(), +            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/ByteBufferGifDecoder.java, +   * A Key for an {@link Boolean} option that if set to {@code true}, disables this decoder, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java, +    requestBuilder.clone().apply(signatureOf(new FrameSignature())).load(gifDecoder).into(next);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/StreamGifDecoder.java, +   * A Key for an {@link Boolean} option that if set to {@code true}, disables this decoder, +++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/Api.java, +  private static final String BASE_URL = "https://api.giphy.com/";, +    void onSearchComplete(SearchResult result);]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java, +import com.squareup.javapoet.AnnotationSpec;, +        .addAnnotation(, +            AnnotationSpec.builder(SuppressWarnings.class), +                .addMember("value", "$S", "deprecation"), +                .build()), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java, +import com.squareup.javapoet.AnnotationSpec;, +        .addAnnotation(, +            AnnotationSpec.builder(SuppressWarnings.class), +                .addMember("value", "$S", "deprecation"), +                .build()), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java, +import com.squareup.javapoet.AnnotationSpec;, +        .addAnnotation(, +            AnnotationSpec.builder(SuppressWarnings.class), +                .addMember("value", "$S", "deprecation"), +                .build())]
[+++ b/library/AndroidManifest.xml, +          package="com.bumptech.glide", +++ b/library/AndroidManifest.xml, +          package="com.bumptech.glide", +++ b/library/src/com/bumptech/glide/loader/image/BaseImageLoader.java, +package com.bumptech.glide.loader.image;, +, +import android.graphics.Bitmap;, +import com.bumptech.glide.loader.opener.StreamOpener;, +, +import java.lang.ref.WeakReference;, +, +, +/**, + * A base class for {@link ImageLoader} that provides some lifecycle methods and prevents memory leaks by only providing, + * subclasses with a weak reference to the calling {@link com.bumptech.glide.presenter.ImagePresenter}., + */, +public abstract class BaseImageLoader implements ImageLoader {, +    @Override, +    public final Object fetchImage(String id, StreamOpener streamOpener, int width, int height, ImageReadyCallback cb) {, +        doFetchImage(id, streamOpener, width, height, new InternalImageReadyCallback(cb, id));, +        return cb;, +    }, +, +    @Override, +    public void clear() { }, +, +    /**, +     * The method where subclasses should actually begin any long running load for the given path and model. It is, +     * safe to strongly reference the given callback since that callback only weakly references the object that created, +     * it. Once a load completes or fails the given callback should be called to signal to the calling object that the, +     * image is ready., +     *, +     * @see ImageLoader#fetchImage(String, com.bumptech.glide.loader.opener.StreamOpener, int, int, com.bumptech.glide.loader.image.ImageLoader.ImageReadyCallback), +     *, +     * @param id A unique id identifying this particular image that will be combined with the provided size info to use as a cache key., +     * @param streamOpener The {@link StreamOpener} that will be used to load the image if it is not cached, +     * @param width The width of the view where the image will be displayed, +     * @param height The height of the view where the image will be displayed, +     * @param cb The callback to call when the bitmap is loaded into memory, or when a load fails, +     */, +    protected abstract void doFetchImage(String id, StreamOpener streamOpener, int width, int height, ImageReadyCallback cb);, +, +    /**, +     * A lifecycle method called after the requesting object is notified that this loader has loaded a bitmap. Should be, +     * used to cleanup or update any data related to the completed load. Should not be used as a callback to change how, +     * an image is displayed. See {@link com.bumptech.glide.presenter.ImageSetCallback} instead to make a visual change, +     * when a load completes., +     *, +     * @param id The unique id of the image, +     * @param image The loaded image, +     * @param isUsed True iff the requesting object is going to display the image, +     */, +    protected void onImageReady(String id, Bitmap image, boolean isUsed) { }, +, +    /**, +     * A lifecycle method called after the requesting object is notified that this loader failed to load a Bitmap., +     * Should be used to cleanup or update any data related to the failed load., +     *, +     * @param e The exception that caused the failure, or null, +     * @param id The unique id of the image, +     * @return True iff this image loader has handled the exception and the cb should not be notified., +     */, +    protected boolean onImageLoadFailed(Exception e, String id) {, +        return false;, +    }, +, +    protected class InternalImageReadyCallback implements ImageReadyCallback {, +        private final WeakReference<ImageReadyCallback> cbRef;, +        private final String id;, +, +        public InternalImageReadyCallback(ImageReadyCallback cb, String id) {, +            this.cbRef = new WeakReference<ImageReadyCallback>(cb);, +            this.id = id;, +        }, +, +        @Override, +        public final boolean onImageReady(Bitmap image) {, +            final ImageReadyCallback cb = cbRef.get();, +            boolean result = false;, +            if (cb != null) {, +                result = cb.onImageReady(image);, +                BaseImageLoader.this.onImageReady(id, image, result);, +            }, +            return result;, +        }, +, +        @Override, +        public void onException(Exception e) {, +            final ImageReadyCallback cb = cbRef.get();, +            if (cb != null) {, +                if (!BaseImageLoader.this.onImageLoadFailed(e, id)) {, +                    cb.onException(e);, +                }, +            }, +        }, +    }, +}, +++ b/library/AndroidManifest.xml, +          package="com.bumptech.glide"]
[+++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +      if (Log.isLoggable(TAG, Log.WARN)) {, +        Log.w(TAG, "Failed to write gif data", e);, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +      if (Log.isLoggable(TAG, Log.WARN)) {, +        Log.w(TAG, "Failed to write gif data", e);, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +  private static final String TAG = "OkHttpFetcher";, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +          Log.d(TAG, "OkHttp failed to obtain result", e);, +        } else if (Log.isLoggable(TAG, Log.DEBUG)) {, +          Log.d(TAG, "OkHttp got error response: " + response.code() + ", " + response.message());, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +      if (Log.isLoggable(TAG, Log.WARN)) {, +        Log.w(TAG, "Failed to write gif data", e);, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +  private static final String TAG = "OkHttpFetcher";, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +          Log.d(TAG, "OkHttp failed to obtain result", e);, +        } else if (Log.isLoggable(TAG, Log.DEBUG)) {, +          Log.d(TAG, "OkHttp got error response: " + response.code() + ", " + response.message());, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +  private static final String TAG = "VolleyStreamFetcher";, +      if (Log.isLoggable(TAG, Log.DEBUG)) {, +        Log.d(TAG, "Volley failed to retrieve response", volleyError);, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +      if (Log.isLoggable(TAG, Log.WARN)) {, +        Log.w(TAG, "Failed to write gif data", e);, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +  private static final String TAG = "OkHttpFetcher";, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +          Log.d(TAG, "OkHttp failed to obtain result", e);, +        } else if (Log.isLoggable(TAG, Log.DEBUG)) {, +          Log.d(TAG, "OkHttp got error response: " + response.code() + ", " + response.message());, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +  private static final String TAG = "VolleyStreamFetcher";, +      if (Log.isLoggable(TAG, Log.DEBUG)) {, +        Log.d(TAG, "Volley failed to retrieve response", volleyError);, +++ /dev/null, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +      if (Log.isLoggable(TAG, Log.WARN)) {, +        Log.w(TAG, "Failed to write gif data", e);, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +  private static final String TAG = "OkHttpFetcher";, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +          Log.d(TAG, "OkHttp failed to obtain result", e);, +        } else if (Log.isLoggable(TAG, Log.DEBUG)) {, +          Log.d(TAG, "OkHttp got error response: " + response.code() + ", " + response.message());, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +  private static final String TAG = "VolleyStreamFetcher";, +      if (Log.isLoggable(TAG, Log.DEBUG)) {, +        Log.d(TAG, "Volley failed to retrieve response", volleyError);, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java, +  private static final String TAG = "AssetPathFetcher";, +      if (Log.isLoggable(TAG, Log.DEBUG)) {, +        Log.d(TAG, "Failed to load data from asset manager", e);, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +      if (Log.isLoggable(TAG, Log.WARN)) {, +        Log.w(TAG, "Failed to write gif data", e);, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +  private static final String TAG = "OkHttpFetcher";, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +          Log.d(TAG, "OkHttp failed to obtain result", e);, +        } else if (Log.isLoggable(TAG, Log.DEBUG)) {, +          Log.d(TAG, "OkHttp got error response: " + response.code() + ", " + response.message());, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +  private static final String TAG = "VolleyStreamFetcher";, +      if (Log.isLoggable(TAG, Log.DEBUG)) {, +        Log.d(TAG, "Volley failed to retrieve response", volleyError);, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java, +  private static final String TAG = "AssetPathFetcher";, +      if (Log.isLoggable(TAG, Log.DEBUG)) {, +        Log.d(TAG, "Failed to load data from asset manager", e);, +++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java, +      if (Log.isLoggable(TAG, Log.DEBUG)) {, +        Log.d(TAG, "Failed to load data for url", e);, +    if (Log.isLoggable(TAG, Log.VERBOSE)) {, +      Log.v(TAG, "Finished http url fetcher fetch in " + LogTime.getElapsedMillis(startTime), +          + " ms and loaded " + result);, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +      if (Log.isLoggable(TAG, Log.WARN)) {, +        Log.w(TAG, "Failed to write gif data", e);, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +  private static final String TAG = "OkHttpFetcher";, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +          Log.d(TAG, "OkHttp failed to obtain result", e);, +        } else if (Log.isLoggable(TAG, Log.DEBUG)) {, +          Log.d(TAG, "OkHttp got error response: " + response.code() + ", " + response.message());, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +  private static final String TAG = "VolleyStreamFetcher";, +      if (Log.isLoggable(TAG, Log.DEBUG)) {, +        Log.d(TAG, "Volley failed to retrieve response", volleyError);, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/data/AssetPathFetcher.java, +  private static final String TAG = "AssetPathFetcher";, +      if (Log.isLoggable(TAG, Log.DEBUG)) {, +        Log.d(TAG, "Failed to load data from asset manager", e);, +++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java, +        DecodeJob.DiskCacheProvider diskCacheProvider = mock(DecodeJob.DiskCacheProvider.class);, +            when(diskCacheProvider.getDiskCache()).thenReturn(diskCache);, +                    transcoder, diskCacheProvider, diskCacheStrategy, priority, fileOpener);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java, +        DecodeJob.DiskCacheProvider diskCacheProvider = mock(DecodeJob.DiskCacheProvider.class);, +            when(diskCacheProvider.getDiskCache()).thenReturn(diskCache);, +                    transcoder, diskCacheProvider, diskCacheStrategy, priority, fileOpener);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +            engine = new Engine(cache, mock(DiskCache.Factory.class), mock(ExecutorService.class),, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java, +        DecodeJob.DiskCacheProvider diskCacheProvider = mock(DecodeJob.DiskCacheProvider.class);, +            when(diskCacheProvider.getDiskCache()).thenReturn(diskCache);, +                    transcoder, diskCacheProvider, diskCacheStrategy, priority, fileOpener);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +            engine = new Engine(cache, mock(DiskCache.Factory.class), mock(ExecutorService.class),, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.load.engine.cache.InternalCacheDiskCacheFactory;, +    private DiskCache.Factory diskCacheFactory;, +     * @deprecated Creating a disk cache directory on the main thread causes strict mode violations, use, +     * {@link #setDiskCache(com.bumptech.glide.load.engine.cache.DiskCache.Factory)} instead. Scheduled to be removed, +     * in Glide 4.0., +    @Deprecated, +    public GlideBuilder setDiskCache(final DiskCache diskCache) {, +        return setDiskCache(new DiskCache.Factory() {, +            @Override, +            public DiskCache build() {, +                return diskCache;, +            }, +        });, +    }, +, +    /**, +     * Sets the {@link com.bumptech.glide.load.engine.cache.DiskCache.Factory} implementation to use to construct, +     * the {@link com.bumptech.glide.load.engine.cache.DiskCache} to use to store, +     * {@link com.bumptech.glide.load.engine.Resource} data on disk., +     *, +     * @param diskCacheFactory The disk cche factory to use., +     * @return This builder., +     */, +    public GlideBuilder setDiskCache(DiskCache.Factory diskCacheFactory) {, +        this.diskCacheFactory = diskCacheFactory;, +        if (diskCacheFactory == null) {, +            diskCacheFactory = new InternalCacheDiskCacheFactory(context, Glide.DEFAULT_DISK_CACHE_SIZE);, +            engine = new Engine(memoryCache, diskCacheFactory, diskCacheService, sourceService);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java, +        DecodeJob.DiskCacheProvider diskCacheProvider = mock(DecodeJob.DiskCacheProvider.class);, +            when(diskCacheProvider.getDiskCache()).thenReturn(diskCache);, +                    transcoder, diskCacheProvider, diskCacheStrategy, priority, fileOpener);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +            engine = new Engine(cache, mock(DiskCache.Factory.class), mock(ExecutorService.class),, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.load.engine.cache.InternalCacheDiskCacheFactory;, +    private DiskCache.Factory diskCacheFactory;, +     * @deprecated Creating a disk cache directory on the main thread causes strict mode violations, use, +     * {@link #setDiskCache(com.bumptech.glide.load.engine.cache.DiskCache.Factory)} instead. Scheduled to be removed, +     * in Glide 4.0., +    @Deprecated, +    public GlideBuilder setDiskCache(final DiskCache diskCache) {, +        return setDiskCache(new DiskCache.Factory() {, +            @Override, +            public DiskCache build() {, +                return diskCache;, +            }, +        });, +    }, +, +    /**, +     * Sets the {@link com.bumptech.glide.load.engine.cache.DiskCache.Factory} implementation to use to construct, +     * the {@link com.bumptech.glide.load.engine.cache.DiskCache} to use to store, +     * {@link com.bumptech.glide.load.engine.Resource} data on disk., +     *, +     * @param diskCacheFactory The disk cche factory to use., +     * @return This builder., +     */, +    public GlideBuilder setDiskCache(DiskCache.Factory diskCacheFactory) {, +        this.diskCacheFactory = diskCacheFactory;, +        if (diskCacheFactory == null) {, +            diskCacheFactory = new InternalCacheDiskCacheFactory(context, Glide.DEFAULT_DISK_CACHE_SIZE);, +            engine = new Engine(memoryCache, diskCacheFactory, diskCacheService, sourceService);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +    private final DiskCacheProvider diskCacheProvider;, +            DiskCacheProvider diskCacheProvider, DiskCacheStrategy diskCacheStrategy, Priority priority) {, +        this(resultKey, width, height, fetcher, loadProvider, transformation, transcoder, diskCacheProvider,, +                diskCacheStrategy, priority, DEFAULT_FILE_OPENER);, +            DiskCacheProvider diskCacheProvider, DiskCacheStrategy diskCacheStrategy, Priority priority, FileOpener, +            fileOpener) {, +        this.diskCacheProvider = diskCacheProvider;, +        diskCacheProvider.getDiskCache().put(resultKey, writer);, +        diskCacheProvider.getDiskCache().put(resultKey.getOriginalKey(), writer);, +        File cacheFile = diskCacheProvider.getDiskCache().get(key);, +                diskCacheProvider.getDiskCache().delete(key);, +    interface DiskCacheProvider {, +        DiskCache getDiskCache();, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java, +        DecodeJob.DiskCacheProvider diskCacheProvider = mock(DecodeJob.DiskCacheProvider.class);, +            when(diskCacheProvider.getDiskCache()).thenReturn(diskCache);, +                    transcoder, diskCacheProvider, diskCacheStrategy, priority, fileOpener);]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +   * potentially containing random image data.]
[+++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +import com.bumptech.glide.load.engine.Resource;, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +import com.bumptech.glide.load.engine.Resource;, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java, +import com.bumptech.glide.load.engine.Resource;, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/SkipCache.java, +import com.bumptech.glide.load.engine.Resource;, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/SkipCache.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java, +import com.bumptech.glide.load.engine.Resource;, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/SkipCache.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/SkipCache.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/SkipCache.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/SkipCache.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java, +import com.bumptech.glide.load.engine.Resource;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJobListener.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Resource.java, +package com.bumptech.glide.load.engine;, +, +import android.os.Looper;, +import com.bumptech.glide.load.Key;, +, +/**, + * A generic resource that handles reference counting so resources can safely be reused., + * <p>, + *     Public methods are non final only to allow for mocking, subclasses must only override abstract methods., + * </p>]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;, +  private final ArrayPool arrayPool;, +  Glide(, +      Engine engine,, +      MemoryCache memoryCache,, +      BitmapPool bitmapPool,, +      ArrayPool arrayPool,, +      Context context,, +      int logLevel,, +      RequestOptions defaultRequestOptions) {, +    this.arrayPool = arrayPool;, +    this.byteArrayPool = new LruByteArrayPool();, +    ByteBufferGifDecoder byteBufferGifDecoder =, +        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);, +  public ArrayPool getArrayPool() {, +    return arrayPool;, +  }, +, +    arrayPool.clearMemory();, +    arrayPool.trimMemory(level);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;, +  private final ArrayPool arrayPool;, +  Glide(, +      Engine engine,, +      MemoryCache memoryCache,, +      BitmapPool bitmapPool,, +      ArrayPool arrayPool,, +      Context context,, +      int logLevel,, +      RequestOptions defaultRequestOptions) {, +    this.arrayPool = arrayPool;, +    this.byteArrayPool = new LruByteArrayPool();, +    ByteBufferGifDecoder byteBufferGifDecoder =, +        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);, +  public ArrayPool getArrayPool() {, +    return arrayPool;, +  }, +, +    arrayPool.clearMemory();, +    arrayPool.trimMemory(level);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;, +  private ArrayPool arrayPool;, +   * Sets the {@link ArrayPool} implementation to allow variable sized arrays to be stored, +   * @param arrayPool The pool to use., +  public GlideBuilder setArrayPool(ArrayPool arrayPool) {, +    this.arrayPool = arrayPool;, +    if (arrayPool == null) {, +      arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());, +    return new Glide(, +        engine,, +        memoryCache,, +        bitmapPool,, +        arrayPool,, +        context,, +        logLevel,, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;, +  private final ArrayPool arrayPool;, +  Glide(, +      Engine engine,, +      MemoryCache memoryCache,, +      BitmapPool bitmapPool,, +      ArrayPool arrayPool,, +      Context context,, +      int logLevel,, +      RequestOptions defaultRequestOptions) {, +    this.arrayPool = arrayPool;, +    this.byteArrayPool = new LruByteArrayPool();, +    ByteBufferGifDecoder byteBufferGifDecoder =, +        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);, +  public ArrayPool getArrayPool() {, +    return arrayPool;, +  }, +, +    arrayPool.clearMemory();, +    arrayPool.trimMemory(level);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;, +  private ArrayPool arrayPool;, +   * Sets the {@link ArrayPool} implementation to allow variable sized arrays to be stored, +   * @param arrayPool The pool to use., +  public GlideBuilder setArrayPool(ArrayPool arrayPool) {, +    this.arrayPool = arrayPool;, +    if (arrayPool == null) {, +      arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());, +    return new Glide(, +        engine,, +        memoryCache,, +        bitmapPool,, +        arrayPool,, +        context,, +        logLevel,]
[+++ b/gradle.properties, +OK_HTTP_VERSION=3.9.0]
[+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java, +, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java, +, +++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java, +    this(url, Headers.DEFAULT);, +    this(url, Headers.DEFAULT);, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java, +, +++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java, +    this(url, Headers.DEFAULT);, +    this(url, Headers.DEFAULT);, +++ b/library/src/main/java/com/bumptech/glide/load/model/Headers.java, +  /**, +   * An empty Headers object that can be used if users don't want to provide headers., +   *, +   * @deprecated Use {@link #DEFAULT} instead., +   */, +  @Deprecated, +   * A Headers object containing reasonable defaults that should be used when users don't want, +   * to provide their own headers., +   */, +  Headers DEFAULT = new LazyHeaders.Builder().build();, +, +  /**, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java, +, +++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java, +    this(url, Headers.DEFAULT);, +    this(url, Headers.DEFAULT);, +++ b/library/src/main/java/com/bumptech/glide/load/model/Headers.java, +  /**, +   * An empty Headers object that can be used if users don't want to provide headers., +   *, +   * @deprecated Use {@link #DEFAULT} instead., +   */, +  @Deprecated, +   * A Headers object containing reasonable defaults that should be used when users don't want, +   * to provide their own headers., +   */, +  Headers DEFAULT = new LazyHeaders.Builder().build();, +, +  /**, +++ b/library/src/main/java/com/bumptech/glide/load/model/LazyHeaders.java, +import android.text.TextUtils;, +, +   * Adds an {@link LazyHeaderFactory} that will be used to construct a value for the given, +   * key* lazily on a background thread., +   *, +   * <p> This class may include default values for User-Agent and Accept-Encoding headers. These, +   * will be replaced by calls to either {@link #setHeader(String, LazyHeaderFactory)} or, +   * {@link #addHeader(String, String)}, even though {@link #addHeader(String, LazyHeaderFactory)}, +   * would usually append an additional value. </p>, +   // PMD doesn't like the necessary static block to initialize DEFAULT_HEADERS., +  @SuppressWarnings("PMD.FieldDeclarationsShouldBeAtStartOfClass"), +    private static final String USER_AGENT_HEADER = "User-Agent";, +    private static final String DEFAULT_USER_AGENT = System.getProperty("http.agent");, +    private static final String ENCODING_HEADER = "Accept-Encoding";, +    private static final String DEFAULT_ENCODING = "identity";, +    private static final Map<String, List<LazyHeaderFactory>> DEFAULT_HEADERS;, +, +    // Set Accept-Encoding header to do our best to avoid gzip since it's both inefficient for, +    // images and also makes it more difficult for us to detect and prevent partial content, +    // rendering. See #440., +    static {, +      Map<String, List<LazyHeaderFactory>> temp, +          = new HashMap<>(2);, +      if (!TextUtils.isEmpty(DEFAULT_USER_AGENT)) {, +        temp.put(USER_AGENT_HEADER,, +            Collections.<LazyHeaderFactory>singletonList(, +                new StringHeaderFactory(DEFAULT_USER_AGENT)));, +      }, +      temp.put(ENCODING_HEADER,, +          Collections.<LazyHeaderFactory>singletonList(, +              new StringHeaderFactory(DEFAULT_ENCODING)));, +      DEFAULT_HEADERS = Collections.unmodifiableMap(temp);, +    }, +, +    private boolean copyOnModify = true;, +    private boolean isEncodingDefault = true;, +    private Map<String, List<LazyHeaderFactory>> headers = DEFAULT_HEADERS;, +    private boolean isUserAgentDefault = headers.containsKey(DEFAULT_USER_AGENT);, +     * <p> Use {@link #addHeader(String, LazyHeaderFactory)} if obtaining the value requires I/O, +     * (ie an oauth token). </p>, +, +     * key lazily on a background thread., +     * <p> Headers may have multiple values whose order is defined by the order in which, +     * this method is called. </p>, +     * <p> This class does not prevent you from adding the same value to a given key multiple, +     * times </p>, +      if ((isEncodingDefault && ENCODING_HEADER.equalsIgnoreCase(key)), +          || (isUserAgentDefault && USER_AGENT_HEADER.equalsIgnoreCase(key))) {, +        return setHeader(key, factory);, +      copyIfNecessary();, +      getFactories(key).add(factory);]
[+++ b/.travis.yml, +script: 'travis_retry ./gradlew build']
[+++ b/library/src/main/java/com/bumptech/glide/request/target/BaseTarget.java, +import android.support.annotation.Nullable;, +  public void setRequest(@Nullable Request request) {, +  @Nullable, +  public void onLoadCleared(@Nullable Drawable placeholder) {, +  public void onLoadStarted(@Nullable Drawable placeholder) {, +  public void onLoadFailed(@Nullable Drawable errorDrawable) {]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +import java.lang.reflect.InvocationTargetException;, +import java.lang.reflect.Method;, +        result.add(getExcludedModuleClassFromAnnotationAttribute(clazz, current));, +  // We should be able to cast to Attribute.Class rather than use reflection, but there are some, +  // compilers that seem to break when we do so. See #2673 for an example., +  private static String getExcludedModuleClassFromAnnotationAttribute(, +      Element clazz, Object attribute) {, +    if (attribute.getClass().getSimpleName().equals("UnresolvedClass")) {, +      throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz, +          + ", one or more excluded Modules could not be found at compile time. Ensure that all", +          + "excluded Modules are included in your classpath.");, +    }, +    Method[] methods = attribute.getClass().getDeclaredMethods();, +    if (methods == null || methods.length == 0) {, +      throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz, +          + ", invalid exclude: " + attribute);, +    }, +    for (Method method : methods) {, +      if (method.getName().equals("getValue")) {, +        try {, +          return method.invoke(attribute).toString();, +        } catch (IllegalAccessException | InvocationTargetException e) {, +          throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz, e);, +        }, +      }, +    }, +    throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz);, +  }, +, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +import java.lang.reflect.InvocationTargetException;, +import java.lang.reflect.Method;, +        result.add(getExcludedModuleClassFromAnnotationAttribute(clazz, current));, +  // We should be able to cast to Attribute.Class rather than use reflection, but there are some, +  // compilers that seem to break when we do so. See #2673 for an example., +  private static String getExcludedModuleClassFromAnnotationAttribute(, +      Element clazz, Object attribute) {, +    if (attribute.getClass().getSimpleName().equals("UnresolvedClass")) {, +      throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz, +          + ", one or more excluded Modules could not be found at compile time. Ensure that all", +          + "excluded Modules are included in your classpath.");, +    }, +    Method[] methods = attribute.getClass().getDeclaredMethods();, +    if (methods == null || methods.length == 0) {, +      throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz, +          + ", invalid exclude: " + attribute);, +    }, +    for (Method method : methods) {, +      if (method.getName().equals("getValue")) {, +        try {, +          return method.invoke(attribute).toString();, +        } catch (IllegalAccessException | InvocationTargetException e) {, +          throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz, e);, +        }, +      }, +    }, +    throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz);, +  }, +, +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java, +/**, + * Tests AppGlideModules that use the @Excludes annotation with a single excluded Module class., + */, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +import java.lang.reflect.InvocationTargetException;, +import java.lang.reflect.Method;, +        result.add(getExcludedModuleClassFromAnnotationAttribute(clazz, current));, +  // We should be able to cast to Attribute.Class rather than use reflection, but there are some, +  // compilers that seem to break when we do so. See #2673 for an example., +  private static String getExcludedModuleClassFromAnnotationAttribute(, +      Element clazz, Object attribute) {, +    if (attribute.getClass().getSimpleName().equals("UnresolvedClass")) {, +      throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz, +          + ", one or more excluded Modules could not be found at compile time. Ensure that all", +          + "excluded Modules are included in your classpath.");, +    }, +    Method[] methods = attribute.getClass().getDeclaredMethods();, +    if (methods == null || methods.length == 0) {, +      throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz, +          + ", invalid exclude: " + attribute);, +    }, +    for (Method method : methods) {, +      if (method.getName().equals("getValue")) {, +        try {, +          return method.invoke(attribute).toString();, +        } catch (IllegalAccessException | InvocationTargetException e) {, +          throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz, e);, +        }, +      }, +    }, +    throw new IllegalArgumentException("Failed to parse @Excludes for: " + clazz);, +  }, +, +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java, +/**, + * Tests AppGlideModules that use the @Excludes annotation with a single excluded Module class., + */, +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithMultipleExcludesTest.java, +/**]
[+++ b/.idea/codeStyleSettings.xml, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +  <component name="NewModuleRootManager" inherit-compiler-output="false">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +  <component name="NewModuleRootManager" inherit-compiler-output="false">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +  <component name="NewModuleRootManager" inherit-compiler-output="false">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" isTestSource="false" />, +      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" isTestSource="true" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +  <component name="NewModuleRootManager" inherit-compiler-output="false">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +      <sourceFolder url="file://$MODULE_DIR$/src/main/resources" isTestSource="false" />, +      <sourceFolder url="file://$MODULE_DIR$/src/test/resources" isTestSource="true" />, +++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MAJOR=3, +VERSION_MINOR=6, +SUPPORT_V4_VERSION=19.1.0, +SUPPORT_V7_VERSION=19.1.0, +# TODO: Upgrade to latest version of Volley when we compile with Java 7., +VOLLEY_VERSION=1.0.8, +ANDROID_GRADLE_VERSION=1.0.0, +ROBOLECTRIC_GRADLE_VERSION=0.14.0, +ROBOLECTRIC_VERSION=2.4, +MOCKWEBSERVER_VERSION=1.6.0, +COMPILE_SDK_VERSION=19, +BUILD_TOOLS_VERSION=19.1.0, +TARGET_SDK_VERSION=19, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +            target.setRequest(null);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +            target.setRequest(null);, +++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java, +    private static boolean isTagUsedAtLeastOnce = false;, +    private static Integer tagId = null;, +    /**, +     * Sets the android resource id to use in conjunction with {@link View#setTag(int, Object)}, +     * to store temporary state allowing loads to be automatically cancelled and resources re-used, +     * in scrolling lists., +     *, +     * <p>, +     *   If no tag id is set, Glide will use {@link View#setTag(Object)}., +     * </p>, +     *, +     * <p>, +     *   Warning: prior to Android 4.0 tags were stored in a static map. Using this method prior, +     *   to Android 4.0 may cause memory leaks and isn't recommended. If you do use this method, +     *   on older versions, be sure to call {@link com.bumptech.glide.Glide#clear(View)} on any view, +     *   you start a load into to ensure that the static state is removed., +     * </p>, +     *, +     * @param tagId The android resource to use., +     */, +    public static void setTagId(int tagId) {, +        if (ViewTarget.tagId != null || isTagUsedAtLeastOnce) {, +            throw new IllegalArgumentException("You cannot set the tag id more than once or change", +                + " the tag id after the first request has been made");, +        }, +        ViewTarget.tagId = tagId;, +    }, +, +        setTag(request);, +        Object tag = getTag();, +    private void setTag(Object tag) {, +        if (tagId == null) {, +            isTagUsedAtLeastOnce = true;, +            view.setTag(tag);, +        } else {, +            view.setTag(tagId, tag);, +        }, +    }, +, +    private Object getTag() {, +        if (tagId == null) {, +            return view.getTag();, +        } else {, +            return view.getTag(tagId);, +        }, +    }, +]
[+++ b/build.gradle, +    gradleVersion = '2.2', +++ b/build.gradle, +    gradleVersion = '2.2', +++ b/gradle.properties, +ANDROID_GRADLE_VERSION=1.0.0, +ROBOLECTRIC_GRADLE_VERSION=0.14.0, +++ b/build.gradle, +    gradleVersion = '2.2', +++ b/gradle.properties, +ANDROID_GRADLE_VERSION=1.0.0, +ROBOLECTRIC_GRADLE_VERSION=0.14.0, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Sat Dec 20 22:55:19 PST 2014, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.2-bin.zip, +++ b/build.gradle, +    gradleVersion = '2.2', +++ b/gradle.properties, +ANDROID_GRADLE_VERSION=1.0.0, +ROBOLECTRIC_GRADLE_VERSION=0.14.0, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Sat Dec 20 22:55:19 PST 2014, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.2-bin.zip, +++ b/integration/okhttp/build.gradle, +++ b/build.gradle, +    gradleVersion = '2.2', +++ b/gradle.properties, +ANDROID_GRADLE_VERSION=1.0.0, +ROBOLECTRIC_GRADLE_VERSION=0.14.0, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Sat Dec 20 22:55:19 PST 2014, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.2-bin.zip, +++ b/integration/okhttp/build.gradle, +++ b/integration/volley/build.gradle, +++ b/build.gradle, +    gradleVersion = '2.2', +++ b/gradle.properties, +ANDROID_GRADLE_VERSION=1.0.0, +ROBOLECTRIC_GRADLE_VERSION=0.14.0, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Sat Dec 20 22:55:19 PST 2014, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.2-bin.zip, +++ b/integration/okhttp/build.gradle, +++ b/integration/volley/build.gradle, +++ b/library/build.gradle, +++ b/build.gradle, +    gradleVersion = '2.2', +++ b/gradle.properties, +ANDROID_GRADLE_VERSION=1.0.0, +ROBOLECTRIC_GRADLE_VERSION=0.14.0, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Sat Dec 20 22:55:19 PST 2014, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.2-bin.zip, +++ b/integration/okhttp/build.gradle, +++ b/integration/volley/build.gradle, +++ b/library/build.gradle, +++ b/third_party/gif_decoder/build.gradle, +++ b/build.gradle, +    gradleVersion = '2.2', +++ b/gradle.properties, +ANDROID_GRADLE_VERSION=1.0.0, +ROBOLECTRIC_GRADLE_VERSION=0.14.0, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Sat Dec 20 22:55:19 PST 2014, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.2-bin.zip, +++ b/integration/okhttp/build.gradle, +++ b/integration/volley/build.gradle, +++ b/library/build.gradle, +++ b/third_party/gif_decoder/build.gradle, +++ b/third_party/gif_encoder/build.gradle]
[+++ b/library/robolectric/src/com/bumptech/glide/GlideTest.java, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +++ b/library/robolectric/src/com/bumptech/glide/GlideTest.java, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +++ b/library/robolectric/src/com/bumptech/glide/request/BitmapRequestTest.java, +    private static class MockTarget implements Target<Object> {, +        public void onResourceReady(Resource<Object> resource) {, +++ b/library/robolectric/src/com/bumptech/glide/GlideTest.java, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +++ b/library/robolectric/src/com/bumptech/glide/request/BitmapRequestTest.java, +    private static class MockTarget implements Target<Object> {, +        public void onResourceReady(Resource<Object> resource) {, +++ b/library/src/com/bumptech/glide/GenericRequestBuilder.java, +import com.bumptech.glide.request.target.BitmapImageViewTarget;, +    public <Y extends Target<Bitmap>> Y into(Y target) {, +     * @return The {@link BitmapImageViewTarget} used to wrap the given {@link ImageView}., +    public BitmapImageViewTarget into(ImageView view) {, +        return into(new BitmapImageViewTarget(view));, +    private Request buildRequest(Target<Bitmap> target) {, +    private Request buildBitmapRequest(Target<Bitmap> target, float sizeMultiplier, Priority priority,, +    private <Z> Request buildBitmapRequestForType(Target<Bitmap> target,, +++ b/library/robolectric/src/com/bumptech/glide/GlideTest.java, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +++ b/library/robolectric/src/com/bumptech/glide/request/BitmapRequestTest.java, +    private static class MockTarget implements Target<Object> {, +        public void onResourceReady(Resource<Object> resource) {, +++ b/library/src/com/bumptech/glide/GenericRequestBuilder.java, +import com.bumptech.glide.request.target.BitmapImageViewTarget;, +    public <Y extends Target<Bitmap>> Y into(Y target) {, +     * @return The {@link BitmapImageViewTarget} used to wrap the given {@link ImageView}., +    public BitmapImageViewTarget into(ImageView view) {, +        return into(new BitmapImageViewTarget(view));, +    private Request buildRequest(Target<Bitmap> target) {, +    private Request buildBitmapRequest(Target<Bitmap> target, float sizeMultiplier, Priority priority,, +    private <Z> Request buildBitmapRequestForType(Target<Bitmap> target,, +++ b/library/src/com/bumptech/glide/Glide.java, +    private static class ClearTarget extends ViewTarget<View, Object> {, +        public void onResourceReady(Resource<Object> resource) { }, +++ b/library/robolectric/src/com/bumptech/glide/GlideTest.java, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +++ b/library/robolectric/src/com/bumptech/glide/request/BitmapRequestTest.java, +    private static class MockTarget implements Target<Object> {, +        public void onResourceReady(Resource<Object> resource) {, +++ b/library/src/com/bumptech/glide/GenericRequestBuilder.java, +import com.bumptech.glide.request.target.BitmapImageViewTarget;, +    public <Y extends Target<Bitmap>> Y into(Y target) {, +     * @return The {@link BitmapImageViewTarget} used to wrap the given {@link ImageView}., +    public BitmapImageViewTarget into(ImageView view) {, +        return into(new BitmapImageViewTarget(view));, +    private Request buildRequest(Target<Bitmap> target) {, +    private Request buildBitmapRequest(Target<Bitmap> target, float sizeMultiplier, Priority priority,, +    private <Z> Request buildBitmapRequestForType(Target<Bitmap> target,, +++ b/library/src/com/bumptech/glide/Glide.java, +    private static class ClearTarget extends ViewTarget<View, Object> {, +        public void onResourceReady(Resource<Object> resource) { }, +++ b/library/src/com/bumptech/glide/ListPreloader.java, +        public void onResourceReady(Resource resource) {, +        }, +++ b/library/robolectric/src/com/bumptech/glide/GlideTest.java, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +        verify(target).onResourceReady(any(Resource.class));, +++ b/library/robolectric/src/com/bumptech/glide/request/BitmapRequestTest.java, +    private static class MockTarget implements Target<Object> {, +        public void onResourceReady(Resource<Object> resource) {, +++ b/library/src/com/bumptech/glide/GenericRequestBuilder.java]
[+++ b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java, +  private final Set<LifecycleListener> lifecycleListeners =, +      Collections.newSetFromMap(new WeakHashMap<LifecycleListener, Boolean>());]
[+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java, +  private static final int BYTES_PER_INTEGER = Integer.SIZE / 8;, +    downsampledWidth = header.width / sampleSize;, +    downsampledHeight = header.height / sampleSize;, +    mainScratch = bitmapProvider.obtainIntArray(downsampledWidth * downsampledHeight);]
[+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;, +      if (size > 0) {, +      } else {, +        bitmapPool = new BitmapPoolAdapter();, +      }, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;, +      if (size > 0) {, +      } else {, +        bitmapPool = new BitmapPoolAdapter();, +      }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java, +, +    int targetBitmapPoolSize = Math.round(screenSize * builder.bitmapPoolScreens);, +, +    if (targetMemoryCacheSize + targetBitmapPoolSize <= availableSize) {, +      bitmapPoolSize = targetBitmapPoolSize;, +              + (targetMemoryCacheSize + targetBitmapPoolSize > maxSize), +, +    /**, +     * On Android O+, we use {@link android.graphics.Bitmap.Config#HARDWARE} for all reasonably, +     * sized images unless we're creating thumbnails for the first time. As a result, the Bitmap, +     * pool is much less important on O than it was on previous versions., +     */, +    static final int BITMAP_POOL_TARGET_SCREENS =, +        Build.VERSION.SDK_INT > Build.VERSION_CODES.O ? 4 : 1;, +, +, +      // On Android O+ Bitmaps are allocated natively, ART is much more efficient at managing, +      // garbage and we rely heavily on HARDWARE Bitmaps, making Bitmap re-use much less important., +      // We prefer to preserve RAM on these devices and take the small performance hit of not, +      // re-using Bitmaps and textures when loading very small images or generating thumbnails., +      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O && isLowMemoryDevice(activityManager)) {, +        bitmapPoolScreens = 0;, +      }]
[+++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +, +            Class<R> transcodedClass, ResourceTranscoder<Bitmap, R> transcoder) {, +        if (streamModelLoader == null && fileDescriptorModelLoader == null) {, +            return null;, +        }, +, +        if (transcoder == null) {, +            transcoder = glide.buildTranscoder(Bitmap.class, transcodedClass);, +        }, +        DataLoadProvider<ImageVideoWrapper, Bitmap> loadProvider = glide.buildDataProvider(ImageVideoWrapper.class,, +                Bitmap.class);, +        ImageVideoModelLoader<A> modelLoader = new ImageVideoModelLoader<A>(streamModelLoader,, +                fileDescriptorModelLoader);, +, +        return new FixedLoadProvider<A, ImageVideoWrapper, Bitmap, R>(modelLoader, transcoder, loadProvider);, +++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +, +            Class<R> transcodedClass, ResourceTranscoder<Bitmap, R> transcoder) {, +        if (streamModelLoader == null && fileDescriptorModelLoader == null) {, +            return null;, +        }, +, +        if (transcoder == null) {, +            transcoder = glide.buildTranscoder(Bitmap.class, transcodedClass);, +        }, +        DataLoadProvider<ImageVideoWrapper, Bitmap> loadProvider = glide.buildDataProvider(ImageVideoWrapper.class,, +                Bitmap.class);, +        ImageVideoModelLoader<A> modelLoader = new ImageVideoModelLoader<A>(streamModelLoader,, +                fileDescriptorModelLoader);, +, +        return new FixedLoadProvider<A, ImageVideoWrapper, Bitmap, R>(modelLoader, transcoder, loadProvider);, +++ b/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java, +, +import com.bumptech.glide.request.FutureTarget;, +import com.bumptech.glide.request.target.Target;, +import java.io.File;, +        if (streamModelLoader == null && fileDescriptorModelLoader == null) {, +            return null;, +        if (transcoder == null) {, +            transcoder = glide.buildTranscoder(resourceClass, transcodedClass);, +        }, +        DataLoadProvider<ImageVideoWrapper, Z> dataLoadProvider = glide.buildDataProvider(ImageVideoWrapper.class,, +                resourceClass);, +        ImageVideoModelLoader<A> modelLoader = new ImageVideoModelLoader<A>(streamModelLoader,, +                fileDescriptorModelLoader);, +        return new FixedLoadProvider<A, ImageVideoWrapper, Z, R>(modelLoader, transcoder, dataLoadProvider);, +    }, +, +    /**, +     * Loads the original unmodified data into the cache and calls the given Target with the cache File, +     * @param target The Target that will receive the cache File when the load completes, +     * @param <Y> The type of Target., +     * @return The given Target., +     */, +    public <Y extends Target<File>> Y downloadOnly(Y target) {, +        return getDownloadOnlyRequest().downloadOnly(target);, +    }, +, +    /**, +     * Loads the original unmodified data into the cache and returns a {@link java.util.concurrent.Future} that can be, +     * used to retrieve the cache File containing the data., +     * @param width The width to use to fetch the data., +     * @param height The height to use to fetch the data., +     * @return A {@link java.util.concurrent.Future} that can be used to retrieve the cache File containing the data., +     */, +    public FutureTarget<File> downloadOnly(int width, int height) {, +        return getDownloadOnlyRequest().downloadOnly(width, height);, +    }, +, +    private GenericTranscodeRequest<A, InputStream, File> getDownloadOnlyRequest() {, +        return optionsApplier.apply(model, new GenericTranscodeRequest<A, InputStream, File>(context, glide, model,, +                streamModelLoader, InputStream.class, File.class, requestTracker, optionsApplier));, +    }, +++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +, +            Class<R> transcodedClass, ResourceTranscoder<Bitmap, R> transcoder) {, +        if (streamModelLoader == null && fileDescriptorModelLoader == null) {, +            return null;, +        }, +, +        if (transcoder == null) {, +            transcoder = glide.buildTranscoder(Bitmap.class, transcodedClass);, +        }, +        DataLoadProvider<ImageVideoWrapper, Bitmap> loadProvider = glide.buildDataProvider(ImageVideoWrapper.class,, +                Bitmap.class);, +        ImageVideoModelLoader<A> modelLoader = new ImageVideoModelLoader<A>(streamModelLoader,, +                fileDescriptorModelLoader);, +, +        return new FixedLoadProvider<A, ImageVideoWrapper, Bitmap, R>(modelLoader, transcoder, loadProvider);, +++ b/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java, +, +import com.bumptech.glide.request.FutureTarget;, +import com.bumptech.glide.request.target.Target;, +import java.io.File;, +        if (streamModelLoader == null && fileDescriptorModelLoader == null) {, +            return null;, +        if (transcoder == null) {, +            transcoder = glide.buildTranscoder(resourceClass, transcodedClass);, +        }]
[+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequest.java, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull, +  @NonNull]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +    ClassName context = ClassName.get("android.content", "Context");, +            .addParameter(context, "context"), +            .addStatement(, +                "super($N, $N ,$N, $N)", "glide", "requestManager", "transcodeClass", "context"), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +    ClassName context = ClassName.get("android.content", "Context");, +            .addParameter(context, "context"), +            .addStatement(, +                "super($N, $N ,$N, $N)", "glide", "requestManager", "transcodeClass", "context"), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java, +  private static final ClassName CONTEXT_CLASS_NAME =, +      ClassName.get("android.content", "Context");, +                .addParameter(CONTEXT_CLASS_NAME, "context"), +                    "return new $T(glide, lifecycle, treeNode, context)",, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +    ClassName context = ClassName.get("android.content", "Context");, +            .addParameter(context, "context"), +            .addStatement(, +                "super($N, $N ,$N, $N)", "glide", "requestManager", "transcodeClass", "context"), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java, +  private static final ClassName CONTEXT_CLASS_NAME =, +      ClassName.get("android.content", "Context");, +                .addParameter(CONTEXT_CLASS_NAME, "context"), +                    "return new $T(glide, lifecycle, treeNode, context)",, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java, +  private static final ClassName CONTEXT_CLASS_NAME =, +      ClassName.get("android.content", "Context");, +        .addParameter(CONTEXT_CLASS_NAME, "context"), +        .addStatement("super(glide, lifecycle, treeNode, context)"), +        .addStatement("return new $T<>(glide, this, resourceClass, context)",, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +    ClassName context = ClassName.get("android.content", "Context");, +            .addParameter(context, "context"), +            .addStatement(, +                "super($N, $N ,$N, $N)", "glide", "requestManager", "transcodeClass", "context"), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java, +  private static final ClassName CONTEXT_CLASS_NAME =, +      ClassName.get("android.content", "Context");, +                .addParameter(CONTEXT_CLASS_NAME, "context"), +                    "return new $T(glide, lifecycle, treeNode, context)",, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java, +  private static final ClassName CONTEXT_CLASS_NAME =, +      ClassName.get("android.content", "Context");, +        .addParameter(CONTEXT_CLASS_NAME, "context"), +        .addStatement("super(glide, lifecycle, treeNode, context)"), +        .addStatement("return new $T<>(glide, this, resourceClass, context)",, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import android.content.Context;, +  private final Context context;, +  private final GlideContext glideContext;, +      Class<TranscodeType> transcodeClass, Context context) {, +    this.context = context;, +    this.glideContext = glide.getGlideContext();, +    this(other.glide, other.requestManager, transcodeClass, other.context);, +    return into(glideContext.buildImageViewTarget(view, transcodeClass), requestOptions);, +        new RequestFutureTarget<>(glideContext.getMainHandler(), width, height);, +      glideContext.getMainHandler().post(new Runnable() {, +        glideContext,, +        glideContext.getEngine(),, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +    ClassName context = ClassName.get("android.content", "Context");, +            .addParameter(context, "context"), +            .addStatement(, +                "super($N, $N ,$N, $N)", "glide", "requestManager", "transcodeClass", "context"), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerFactoryGenerator.java, +  private static final ClassName CONTEXT_CLASS_NAME =, +      ClassName.get("android.content", "Context");, +                .addParameter(CONTEXT_CLASS_NAME, "context"), +                    "return new $T(glide, lifecycle, treeNode, context)",, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java, +  private static final ClassName CONTEXT_CLASS_NAME =, +      ClassName.get("android.content", "Context");, +        .addParameter(CONTEXT_CLASS_NAME, "context"), +        .addStatement("super(glide, lifecycle, treeNode, context)"), +        .addStatement("return new $T<>(glide, this, resourceClass, context)",, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import android.content.Context;, +  private final Context context;, +  private final GlideContext glideContext;, +      Class<TranscodeType> transcodeClass, Context context) {, +    this.context = context;, +    this.glideContext = glide.getGlideContext();, +    this(other.glide, other.requestManager, transcodeClass, other.context);, +    return into(glideContext.buildImageViewTarget(view, transcodeClass), requestOptions);, +        new RequestFutureTarget<>(glideContext.getMainHandler(), width, height);, +      glideContext.getMainHandler().post(new Runnable() {, +        glideContext,, +        glideContext.getEngine(),, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +  protected final Context context;, +  public RequestManager(, +      Glide glide, Lifecycle lifecycle, RequestManagerTreeNode treeNode, Context context) {, +    this(, +        glide,, +        lifecycle,, +        treeNode,, +        new RequestTracker(),, +        glide.getConnectivityMonitorFactory(),, +        context);]
[+++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" />, +++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" />, +++ b/library/project.properties, +target=android-19, +++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="8" android:targetSdkVersion="19" />, +++ b/library/project.properties, +target=android-19, +++ b/library/tests/project.properties, +target=android-19]
[+++ b/.gitignore, +library/target, +samples/flickr/target, +++ b/.gitignore, +library/target, +samples/flickr/target, +++ b/.gitmodules, +[submodule "library/robolectric/src/com/bumptech/glide/resize/load/exif-orientation-examples"], +	path = library/robolectric/src/com/bumptech/glide/resize/load/exif-orientation-examples, +++ b/.gitignore, +library/target, +samples/flickr/target, +++ b/.gitmodules, +[submodule "library/robolectric/src/com/bumptech/glide/resize/load/exif-orientation-examples"], +	path = library/robolectric/src/com/bumptech/glide/resize/load/exif-orientation-examples, +++ b/library/robolectric/libs/hamcrest-core-1.3.jar, +++ b/.gitignore, +library/target, +samples/flickr/target, +++ b/.gitmodules, +[submodule "library/robolectric/src/com/bumptech/glide/resize/load/exif-orientation-examples"], +	path = library/robolectric/src/com/bumptech/glide/resize/load/exif-orientation-examples, +++ b/library/robolectric/libs/hamcrest-core-1.3.jar, +++ b/library/robolectric/libs/junit-4.11.jar, +++ b/.gitignore, +library/target, +samples/flickr/target, +++ b/.gitmodules, +[submodule "library/robolectric/src/com/bumptech/glide/resize/load/exif-orientation-examples"], +	path = library/robolectric/src/com/bumptech/glide/resize/load/exif-orientation-examples, +++ b/library/robolectric/libs/hamcrest-core-1.3.jar, +++ b/library/robolectric/libs/junit-4.11.jar, +++ b/library/robolectric/libs/mockito-all-1.9.5.jar, +++ b/.gitignore, +library/target, +samples/flickr/target, +++ b/.gitmodules, +[submodule "library/robolectric/src/com/bumptech/glide/resize/load/exif-orientation-examples"], +	path = library/robolectric/src/com/bumptech/glide/resize/load/exif-orientation-examples, +++ b/library/robolectric/libs/hamcrest-core-1.3.jar, +++ b/library/robolectric/libs/junit-4.11.jar, +++ b/library/robolectric/libs/mockito-all-1.9.5.jar, +++ b/library/robolectric/libs/robolectric-2.3-jar-with-dependencies.jar, +++ b/.gitignore, +library/target, +samples/flickr/target, +++ b/.gitmodules, +[submodule "library/robolectric/src/com/bumptech/glide/resize/load/exif-orientation-examples"], +	path = library/robolectric/src/com/bumptech/glide/resize/load/exif-orientation-examples, +++ b/library/robolectric/libs/hamcrest-core-1.3.jar, +++ b/library/robolectric/libs/junit-4.11.jar, +++ b/library/robolectric/libs/mockito-all-1.9.5.jar, +++ b/library/robolectric/libs/robolectric-2.3-jar-with-dependencies.jar, +++ b/library/robolectric/src/com/bumptech/glide/GlideTest.java, +package com.bumptech.glide;, +, +import android.content.Context;, +import android.net.Uri;, +import android.view.ViewGroup;, +import android.widget.ImageView;, +import com.bumptech.glide.loader.bitmap.model.GenericLoaderFactory;, +import com.bumptech.glide.loader.bitmap.model.ModelLoader;, +import com.bumptech.glide.loader.bitmap.model.ModelLoaderFactory;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamModelLoader;, +import com.bumptech.glide.resize.target.ImageViewTarget;, +import com.bumptech.glide.resize.target.Target;, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.Robolectric;, +import org.robolectric.RobolectricTestRunner;, +, +import java.io.File;, +import java.io.InputStream;, +import java.net.MalformedURLException;, +import java.net.URL;, +, +import static junit.framework.Assert.assertNotNull;, +import static org.mockito.Mockito.mock;, +, +/**, + * Tests for the {@link Glide} interface and singleton., + */, +@RunWith(RobolectricTestRunner.class), +public class GlideTest {, +    private ImageView imageView;, +    private ImageViewTarget imageViewTarget;, +, +    @Before, +    public void setUp() throws Exception {, +        imageView = new ImageView(getContext());, +        //this is a quick hack to get the SizeDeterminer in ImagePresenter to think the view has been measured, +        imageView.setLayoutParams(new ViewGroup.LayoutParams(100, 100));, +        imageViewTarget = new ImageViewTarget(imageView);, +    }, +, +    private Context getContext() {, +        return Robolectric.application;, +    }, +]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +      builder = builder.addAnnotation(AnnotationSpec.get(mirror));, +    }, +, +    if (methodToOverride.isVarArgs()) {, +      builder = builder, +          .addModifiers(Modifier.FINAL), +          .addAnnotation(SafeVarargs.class);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +      builder = builder.addAnnotation(AnnotationSpec.get(mirror));, +    }, +, +    if (methodToOverride.isVarArgs()) {, +      builder = builder, +          .addModifiers(Modifier.FINAL), +          .addAnnotation(SafeVarargs.class);, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +   * <p>Recursive calls to thumbnail are supported., +   *, +   * <p>Overrides any previous calls to {@link #thumbnail(RequestBuilder)},, +   * {@link #thumbnail(float)} and {@link #thumbnail(RequestBuilder[])}., +   *, +   * @see #thumbnail(float), +   * @see #thumbnail(RequestBuilder[]), +   *, +   * Recursively applies {@link #thumbnail(RequestBuilder)} so that the {@link RequestBuilder}s are, +   * loaded as thumbnails in the given priority order., +   *, +   * <p>{@link #thumbnail(RequestBuilder)} is applied in the order given so that the, +   * {@link RequestBuilder} at position 0 has the {@link RequestBuilder} at position 1 applied, +   * as using its thumbnail method, the {@link RequestBuilder} at position 1 has the, +   * {@link RequestBuilder} at position 2 applied using its thumbnail method and so on., +   *, +   * <p>Calling this method with an {@code null} array of {@link RequestBuilder} thumbnails or, +   * an empty array of {@link RequestBuilder} thumbnails is equivalent to calling, +   * {@link #thumbnail(RequestBuilder)} with {@code null}., +   *, +   * <p>Any individual {@link RequestBuilder} in the array of thumbnails provided here may be, +   * {@code null}. {@code null} {@link RequestBuilder}s are ignored and excluded from the recursive, +   * chain., +   *, +   * <p>The {@link RequestBuilder} objects provided here may be mutated and have any previous, +   * calls to their {@link #thumbnail(RequestBuilder[])} or {@link #thumbnail(RequestBuilder)}, +   * methods overridden., +   *, +   * <p>Overrides any previous calls to {@link #thumbnail(RequestBuilder)},, +   * {@link #thumbnail(float)} and {@link #thumbnail(RequestBuilder[])}., +   *, +   * @see #thumbnail(float), +   * @see #thumbnail(RequestBuilder), +   *, +   * @return This request builder., +   */, +  @SuppressWarnings({"CheckResult", "unchecked"}), +  @CheckResult, +  public RequestBuilder<TranscodeType> thumbnail(, +      @Nullable RequestBuilder<TranscodeType> /*@Nullable*/ ... thumbnails) {, +    if (thumbnails == null || thumbnails.length == 0) {, +      return thumbnail((RequestBuilder<TranscodeType>) null);, +    }, +, +    RequestBuilder<TranscodeType> previous = null;, +, +    // Start with the lowest priority thumbnail so that we can safely handle mutations if, +    // autoClone() is enabled by assigning the result of calling thumbnail() during the iteration., +    // Starting with the highest priority thumbnail would prevent us from assigning the result of, +    // thumbnail because the mutated request wouldn't be used in the next iteration., +    for (int i = thumbnails.length - 1; i >= 0; i--) {, +      RequestBuilder<TranscodeType> current = thumbnails[i];, +      // Ignore null thumbnails., +      if (current == null) {, +        continue;, +      }, +, +      if (previous == null) {, +        // If we don't yet have our first non-null request, set it and continue., +        previous = current;, +      } else {, +        // Otherwise make our next lowest priority request the thumbnail of our current request., +        previous = current.thumbnail(previous);, +      }, +    }, +    return thumbnail(previous);, +  }, +, +  /**, +   * {@link android.widget.ImageView.ScaleType}., +   * copied for the thumbnail load., +   * <p>Recursive calls to thumbnail are supported., +   *, +   * <p>Overrides any previous calls to {@link #thumbnail(RequestBuilder[])},, +   * {@link #thumbnail(float)} and {@link #thumbnail(RequestBuilder)}., +   *, +   * @see #thumbnail(RequestBuilder), +   * @see #thumbnail(RequestBuilder[])]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ /dev/null]
[+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java, +      try {, +      } catch (SecurityException e) {, +        // See #1405., +        if (Log.isLoggable(TAG, Log.WARN)) {, +          Log.w(TAG, "Failed to determine connectivity status when connectivity changed", e);, +        }, +        // Default to true;, +        isConnected = true;, +      }, +      // See #1405, +      isConnected = isConnected(context);, +++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java, +      try {, +      } catch (SecurityException e) {, +        // See #1405., +        if (Log.isLoggable(TAG, Log.WARN)) {, +          Log.w(TAG, "Failed to determine connectivity status when connectivity changed", e);, +        }, +        // Default to true;, +        isConnected = true;, +      }, +      // See #1405, +      isConnected = isConnected(context);, +++ b/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java, +import com.bumptech.glide.manager.DefaultConnectivityMonitorTest.PermissionConnectivityManager;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +import org.robolectric.annotation.Implementation;, +import org.robolectric.annotation.Implements;, +import org.robolectric.shadow.api.Shadow;, +@Config(manifest = Config.NONE, sdk = 18, shadows = PermissionConnectivityManager.class), +  @Mock private ConnectivityMonitor.ConnectivityListener listener;, +  private ConnectivityHarness harness;, +, +    MockitoAnnotations.initMocks(this);, +    harness = new ConnectivityHarness();, +  @Test, +  public void register_withMissingPermission_doesNotThrow() {, +    harness.shadowConnectivityManager.isNetworkPermissionGranted = false;, +, +    monitor.onStart();, +  }, +, +  @Test, +  public void register_withMissingPermission_doesNotRegisterReceiver() {, +    harness.shadowConnectivityManager.isNetworkPermissionGranted = false;, +, +    monitor.onStart();, +, +    assertThat(getConnectivityReceivers()).isEmpty();, +  }, +, +  @Test, +  public void onReceive_withMissingPermission_doesNotThrow() {, +    monitor.onStart();, +    harness.shadowConnectivityManager.isNetworkPermissionGranted = false;, +    harness.broadcast();, +  }, +, +  @Test, +  public void onReceive_withMissingPermission_previouslyDisconnected_notifiesListenersConnected() {, +    harness.disconnect();, +    monitor.onStart();, +    harness.shadowConnectivityManager.isNetworkPermissionGranted = false;, +    harness.broadcast();, +, +    verify(listener).onConnectivityChanged(true);, +  }, +, +  @Test, +  public void onReceive_withMissingPermission_previouslyConnected_doesNotNotifyListeners() {, +    harness.connect();, +    monitor.onStart();, +    harness.shadowConnectivityManager.isNetworkPermissionGranted = false;, +    harness.broadcast();, +, +    verify(listener, never()).onConnectivityChanged(anyBoolean());, +  }, +, +    private final PermissionConnectivityManager shadowConnectivityManager;, +      shadowConnectivityManager = Shadow.extract(connectivityManager);, +    void disconnect() {, +    void connect() {, +    void broadcast() {, +, +  @Implements(ConnectivityManager.class), +  public static final class PermissionConnectivityManager extends ShadowConnectivityManager {, +    private boolean isNetworkPermissionGranted = true;, +, +    @Implementation, +    public NetworkInfo getActiveNetworkInfo() {, +      if (!isNetworkPermissionGranted) {, +        throw new SecurityException();, +      }, +      return super.getActiveNetworkInfo();, +    }, +  }]
[+++ b/library/robolectric/src/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.resource.bytes.BytesResource;, +import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;, +import com.bumptech.glide.load.data.DataFetcher;, +import static junit.framework.Assert.fail;, +        doAnswer(new CallCallback()).when(target).getSize(any(Target.SizeReadyCallback.class));, +                    fail("Failed to get response from Volley in time");, +    @SuppressWarnings("unchecked"), +        Target<File> target = mock(Target.class);, +        doAnswer(new CallCallback()).when(target).getSize(any(Target.SizeReadyCallback.class));, +, +        DataFetcher<File> dataFetcher = mock(DataFetcher.class);, +        when(dataFetcher.loadData(any(Priority.class))).thenReturn(expected);, +                .thenReturn(dataFetcher);, +        DataFetcher<Z> failFetcher = mock(DataFetcher.class);, +        when(failFetcher.loadData(any(Priority.class))).thenThrow(new IOException("test"));, +        DataFetcher<InputStream> fetcher = mock(DataFetcher.class);, +            when(fetcher.loadData(any(Priority.class))).thenReturn(new ByteArrayInputStream(new byte[0]));, +    private static class CallCallback implements Answer<Void> {, +        private int width;, +        private int height;, +, +        public CallCallback() {, +            this(100, 100);, +        }, +, +        public CallCallback(int width, int height) {, +            this.width = width;, +            this.height = height;, +        }, +, +        @Override, +        public Void answer(InvocationOnMock invocation) throws Throwable {, +            Target.SizeReadyCallback cb = (Target.SizeReadyCallback) invocation.getArguments()[0];, +            cb.onSizeReady(width, height);, +            return null;, +        }, +    }, +, +++ b/library/robolectric/src/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.resource.bytes.BytesResource;, +import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;, +import com.bumptech.glide.load.data.DataFetcher;, +import static junit.framework.Assert.fail;, +        doAnswer(new CallCallback()).when(target).getSize(any(Target.SizeReadyCallback.class));, +                    fail("Failed to get response from Volley in time");, +    @SuppressWarnings("unchecked"), +        Target<File> target = mock(Target.class);, +        doAnswer(new CallCallback()).when(target).getSize(any(Target.SizeReadyCallback.class));, +, +        DataFetcher<File> dataFetcher = mock(DataFetcher.class);, +        when(dataFetcher.loadData(any(Priority.class))).thenReturn(expected);, +                .thenReturn(dataFetcher);, +        DataFetcher<Z> failFetcher = mock(DataFetcher.class);, +        when(failFetcher.loadData(any(Priority.class))).thenThrow(new IOException("test"));, +        DataFetcher<InputStream> fetcher = mock(DataFetcher.class);, +            when(fetcher.loadData(any(Priority.class))).thenReturn(new ByteArrayInputStream(new byte[0]));, +    private static class CallCallback implements Answer<Void> {, +        private int width;, +        private int height;, +, +        public CallCallback() {, +            this(100, 100);, +        }, +, +        public CallCallback(int width, int height) {, +            this.width = width;, +            this.height = height;, +        }, +, +        @Override, +        public Void answer(InvocationOnMock invocation) throws Throwable {, +            Target.SizeReadyCallback cb = (Target.SizeReadyCallback) invocation.getArguments()[0];, +            cb.onSizeReady(width, height);, +            return null;, +        }, +    }, +, +++ b/library/robolectric/src/com/bumptech/glide/load/data/LocalUriFetcherTest.java, +package com.bumptech.glide.load.data;, +, +import android.content.ContentResolver;, +import android.content.Context;, +import android.net.Uri;, +import com.bumptech.glide.Priority;, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.Robolectric;, +import org.robolectric.RobolectricTestRunner;, +, +import java.io.Closeable;, +import java.io.FileNotFoundException;, +import java.io.IOException;, +, +import static org.mockito.Mockito.doThrow;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.never;, +import static org.mockito.Mockito.verify;, +]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +        return "BitmapEncoder.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +        return "BitmapEncoder.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java, +        return "CenterCrop.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +        return "BitmapEncoder.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java, +        return "CenterCrop.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java, +        return "FitCenter.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +        return "BitmapEncoder.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java, +        return "CenterCrop.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java, +        return "FitCenter.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoder.java, +        return "ImageVideoBitmapDecoder.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +        return "BitmapEncoder.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java, +        return "CenterCrop.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java, +        return "FitCenter.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoder.java, +        return "ImageVideoBitmapDecoder.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java, +    private static final String ID = "StreamBitmapDecoder.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +        return "BitmapEncoder.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java, +        return "CenterCrop.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java, +        return "FitCenter.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoder.java, +        return "ImageVideoBitmapDecoder.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java, +    private static final String ID = "StreamBitmapDecoder.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java, +        return "GifResourceDecoder.com.bumptech.glide.load.resource.gif";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +        return "BitmapEncoder.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java, +        return "CenterCrop.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java, +        return "FitCenter.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoder.java, +        return "ImageVideoBitmapDecoder.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java, +    private static final String ID = "StreamBitmapDecoder.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java, +        return "GifResourceDecoder.com.bumptech.glide.load.resource.gif";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceEncoder.java, +, +        return "GifResourceEncoder.com.bumptech.glide.load.resource.gif";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +        return "BitmapEncoder.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java, +        return "CenterCrop.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java, +        return "FitCenter.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoder.java, +        return "ImageVideoBitmapDecoder.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java, +    private static final String ID = "StreamBitmapDecoder.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java, +        return "GifResourceDecoder.com.bumptech.glide.load.resource.gif";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceEncoder.java, +, +        return "GifResourceEncoder.com.bumptech.glide.load.resource.gif";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java, +        return "BitmapBytesTranscoder.com.bumptech.glide.load.resource.transcode";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +        return "BitmapEncoder.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java, +        return "CenterCrop.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java, +        return "FitCenter.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoder.java, +        return "ImageVideoBitmapDecoder.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/StreamBitmapDecoder.java, +    private static final String ID = "StreamBitmapDecoder.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java, +        return "GifResourceDecoder.com.bumptech.glide.load.resource.gif";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceEncoder.java, +, +        return "GifResourceEncoder.com.bumptech.glide.load.resource.gif";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapBytesTranscoder.java, +        return "BitmapBytesTranscoder.com.bumptech.glide.load.resource.transcode";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/transcode/BitmapDrawableTranscoder.java, +        return "BitmapDrawableTranscoder.com.bumptech.glide.load.resource.transcode";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +        return "BitmapEncoder.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java, +        return "CenterCrop.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java, +        return "FitCenter.com.bumptech.glide.load.resource.bitmap";, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageVideoBitmapDecoder.java]
[+++ b/.gitmodules, +[submodule "samples/flickr/volley"], +	path = samples/flickr/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/.gitmodules, +[submodule "samples/flickr/volley"], +	path = samples/flickr/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/samples/flickr/project.properties, +android.library.reference.3=volley/, +++ b/.gitmodules, +[submodule "samples/flickr/volley"], +	path = samples/flickr/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/samples/flickr/project.properties, +android.library.reference.3=volley/, +++ b/samples/flickr/src/com/bumptech/flickr/FlickrStreamLoader.java, +import com.android.volley.Request;, +    private Request current = null;, +            current.cancel();, +++ b/.gitmodules, +[submodule "samples/flickr/volley"], +	path = samples/flickr/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/samples/flickr/project.properties, +android.library.reference.3=volley/, +++ b/samples/flickr/src/com/bumptech/flickr/FlickrStreamLoader.java, +import com.android.volley.Request;, +    private Request current = null;, +            current.cancel();, +++ b/samples/flickr/src/com/bumptech/flickr/api/Api.java, +import com.android.volley.Request;, +    public static Api get(Context applicationContext) {, +            API = new Api(applicationContext, applicationContext.getResources().getDimensionPixelSize(R.dimen.large_photo_side));, +    protected Api(Context applicationContext, int maxPhotoSize) {, +        this.downloader = Downloader.get(applicationContext);, +        downloader.download(getSearchUrl(text), new Downloader.StringCallback() {, +            public void onDownloadReady(String result) {, +                    JSONObject searchResults = new JSONObject(result.substring(14, result.length()-1));, +    public Request downloadPhoto(Photo photo, File cacheDir, final PhotoCallback cb) {, +        Request result = null;, +++ b/.gitmodules, +[submodule "samples/flickr/volley"], +	path = samples/flickr/volley, +	url = https://android.googlesource.com/platform/frameworks/volley, +++ b/samples/flickr/project.properties, +android.library.reference.3=volley/, +++ b/samples/flickr/src/com/bumptech/flickr/FlickrStreamLoader.java, +import com.android.volley.Request;, +    private Request current = null;, +            current.cancel();, +++ b/samples/flickr/src/com/bumptech/flickr/api/Api.java, +import com.android.volley.Request;, +    public static Api get(Context applicationContext) {, +            API = new Api(applicationContext, applicationContext.getResources().getDimensionPixelSize(R.dimen.large_photo_side));, +    protected Api(Context applicationContext, int maxPhotoSize) {, +        this.downloader = Downloader.get(applicationContext);, +        downloader.download(getSearchUrl(text), new Downloader.StringCallback() {, +            public void onDownloadReady(String result) {, +                    JSONObject searchResults = new JSONObject(result.substring(14, result.length()-1));, +    public Request downloadPhoto(Photo photo, File cacheDir, final PhotoCallback cb) {, +        Request result = null;, +++ b/samples/flickr/src/com/bumptech/flickr/api/Downloader.java, +import android.content.Context;, +import com.android.volley.NetworkResponse;, +import com.android.volley.Request;, +import com.android.volley.RequestQueue;, +import com.android.volley.Response;, +import com.android.volley.VolleyError;, +import com.android.volley.toolbox.StringRequest;, +import com.android.volley.toolbox.Volley;, +import java.io.BufferedOutputStream;, +import java.io.FileNotFoundException;, +    private final RequestQueue queue;, +    static Downloader get(Context context) {, +            DOWNLOADER = new Downloader(context);, +    public Downloader(Context context) {, +        queue = Volley.newRequestQueue(context);, +    }, +, +    public interface StringCallback {, +        public void onDownloadReady(String result);, +    public void download(String url, final StringCallback cb) {, +        queue.add(new StringRequest(Request.Method.GET, url, new Response.Listener<String>() {, +            public void onResponse(String response) {, +                cb.onDownloadReady(response);, +            }, +        }, new Response.ErrorListener() {, +            public void onErrorResponse(VolleyError error) {, +                error.printStackTrace();, +        }));, +, +    public Request download(String url, final File out, final DiskCallback cb) {, +        return queue.add(new Request<String>(Request.Method.GET, url, new Response.ErrorListener() {, +            @Override, +            public void onErrorResponse(VolleyError error) {, +                error.printStackTrace();, +            }, +        }) {, +            @Override]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java, +import android.support.annotation.NonNull;, +      public Target<T> call() {, +          public void onResourceReady(@NonNull T resource,, +              @Nullable Transition<? super T> transition) {, +          public void getSize(@NonNull SizeReadyCallback cb) {, +          public void removeCallback(@NonNull SizeReadyCallback cb) {, +      public Target<T> call() {, +          public void onResourceReady(@NonNull T resource,, +              @Nullable Transition<? super T> transition) {, +          public void getSize(@NonNull SizeReadyCallback cb) {, +          public void removeCallback(@NonNull SizeReadyCallback cb) {, +      public Void call() {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java, +import android.support.annotation.NonNull;, +      public Target<T> call() {, +          public void onResourceReady(@NonNull T resource,, +              @Nullable Transition<? super T> transition) {, +          public void getSize(@NonNull SizeReadyCallback cb) {, +          public void removeCallback(@NonNull SizeReadyCallback cb) {, +      public Target<T> call() {, +          public void onResourceReady(@NonNull T resource,, +              @Nullable Transition<? super T> transition) {, +          public void getSize(@NonNull SizeReadyCallback cb) {, +          public void removeCallback(@NonNull SizeReadyCallback cb) {, +      public Void call() {, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +    public void onResourceReady(@NonNull Object resource,, +        @Nullable Transition<? super Object> transition) {, +    public void getSize(@NonNull SizeReadyCallback cb) {, +    public void removeCallback(@NonNull SizeReadyCallback cb) {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java, +import android.support.annotation.NonNull;, +      public Target<T> call() {, +          public void onResourceReady(@NonNull T resource,, +              @Nullable Transition<? super T> transition) {, +          public void getSize(@NonNull SizeReadyCallback cb) {, +          public void removeCallback(@NonNull SizeReadyCallback cb) {, +      public Target<T> call() {, +          public void onResourceReady(@NonNull T resource,, +              @Nullable Transition<? super T> transition) {, +          public void getSize(@NonNull SizeReadyCallback cb) {, +          public void removeCallback(@NonNull SizeReadyCallback cb) {, +      public Void call() {, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +    public void onResourceReady(@NonNull Object resource,, +        @Nullable Transition<? super Object> transition) {, +    public void getSize(@NonNull SizeReadyCallback cb) {, +    public void removeCallback(@NonNull SizeReadyCallback cb) {, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +    public void onResourceReady(@NonNull Object resource,, +        @Nullable Transition<? super Object> transition) {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java, +import android.support.annotation.NonNull;, +      public Target<T> call() {, +          public void onResourceReady(@NonNull T resource,, +              @Nullable Transition<? super T> transition) {, +          public void getSize(@NonNull SizeReadyCallback cb) {, +          public void removeCallback(@NonNull SizeReadyCallback cb) {, +      public Target<T> call() {, +          public void onResourceReady(@NonNull T resource,, +              @Nullable Transition<? super T> transition) {, +          public void getSize(@NonNull SizeReadyCallback cb) {, +          public void removeCallback(@NonNull SizeReadyCallback cb) {, +      public Void call() {, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +    public void onResourceReady(@NonNull Object resource,, +        @Nullable Transition<? super Object> transition) {, +    public void getSize(@NonNull SizeReadyCallback cb) {, +    public void removeCallback(@NonNull SizeReadyCallback cb) {, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +    public void onResourceReady(@NonNull Object resource,, +        @Nullable Transition<? super Object> transition) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java, +  public void setResourceRemovedListener(@NonNull ResourceRemovedListener listener) {, +  protected int getSize(@Nullable Resource<?> item) {, +    if (item == null) {, +      return super.getSize(null);, +    } else {, +  }, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java, +import android.support.annotation.NonNull;, +      public Target<T> call() {, +          public void onResourceReady(@NonNull T resource,, +              @Nullable Transition<? super T> transition) {, +          public void getSize(@NonNull SizeReadyCallback cb) {, +          public void removeCallback(@NonNull SizeReadyCallback cb) {, +      public Target<T> call() {, +          public void onResourceReady(@NonNull T resource,, +              @Nullable Transition<? super T> transition) {, +          public void getSize(@NonNull SizeReadyCallback cb) {, +          public void removeCallback(@NonNull SizeReadyCallback cb) {, +      public Void call() {, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +    public void onResourceReady(@NonNull Object resource,, +        @Nullable Transition<? super Object> transition) {, +    public void getSize(@NonNull SizeReadyCallback cb) {, +    public void removeCallback(@NonNull SizeReadyCallback cb) {, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +    public void onResourceReady(@NonNull Object resource,]
[+++ b/library/build.gradle, +    provided "com.android.support:appcompat-v7:${SUPPORT_V7_VERSION}", +++ b/library/build.gradle, +    provided "com.android.support:appcompat-v7:${SUPPORT_V7_VERSION}", +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +import android.support.annotation.DrawableRes;, +import android.support.v7.content.res.AppCompatResources;, +  private static boolean shouldCallAppCompatResources = true;, +  private Drawable loadDrawable(@DrawableRes int resourceId) {, +    if (shouldCallAppCompatResources) {, +      return loadDrawableV7(resourceId);, +    } else {, +      return loadDrawableBase(resourceId);, +    }, +  }, +, +  /**, +   * Tries to load the drawable thanks to AppCompatResources.<br>, +   * This allows to parse VectorDrawables on legacy devices if the appcompat v7 is in the classpath., +   */, +  private Drawable loadDrawableV7(@DrawableRes int resourceId) {, +    try {, +      return AppCompatResources.getDrawable(glideContext, resourceId);, +    } catch (NoClassDefFoundError error) {, +      shouldCallAppCompatResources = false;, +      return loadDrawableBase(resourceId);, +    }, +  }, +, +  private Drawable loadDrawableBase(@DrawableRes int resourceId) {]
[+++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +    private String id;, +        if (id == null) {, +            if (transformations != null) {, +            } else {, +                for (Transformation transformation : transformationList) {, +                    sb.append(transformation.getId());, +                }, +            }, +            id = sb.toString();, +        }, +        return id;, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +    private String id;, +        if (id == null) {, +            if (transformations != null) {, +            } else {, +                for (Transformation transformation : transformationList) {, +                    sb.append(transformation.getId());, +                }, +            }, +            id = sb.toString();, +        }, +        return id;, +++ b/library/src/test/java/com/bumptech/glide/load/MultiTransformationTest.java, +import java.util.ArrayList;, +, +        final String expected = firstId + secondId + thirdId;, +        assertEquals(expected, transformation.getId());, +, +        ArrayList<Transformation> transformations = new ArrayList<Transformation>();, +        transformations.add(first);, +        transformations.add(second);, +        transformations.add(third);, +, +        transformation = new MultiTransformation(transformations);, +, +        assertEquals(expected, transformation.getId());]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +        FactoryPools.threadSafe(JOB_POOL_SIZE,, +        FactoryPools.threadSafe(, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +        FactoryPools.threadSafe(JOB_POOL_SIZE,, +        FactoryPools.threadSafe(, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +import android.support.annotation.GuardedBy;, +  private static final Pools.Pool<SingleRequest<?>> POOL = FactoryPools.threadSafe(150,, +  @GuardedBy("this"), +  public synchronized void onSizeReady(int width, int height) {]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java, +  private static final String VISIBLE_FOR_TESTING_QUALIFIED_NAME =, +      "android.support.annotation.VisibleForTesting";, +, +  private static final String SUPPRESS_LINT_PACKAGE_NAME =, +      "android.annotation";, +  private static final String SUPPRESS_LINT_CLASS_NAME =, +      "SuppressLint";, +, +    TypeElement visibleForTestingType =, +        processingEnv, +            .getElementUtils(), +            .getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME);, +, +      // Suppress a lint warning if we're overriding a VisibleForTesting method., +      // See #1977., +      if (mirror.getAnnotationType().asElement().equals(visibleForTestingType)) {, +        builder.addAnnotation(, +            AnnotationSpec.builder(, +                ClassName.get(SUPPRESS_LINT_PACKAGE_NAME, SUPPRESS_LINT_CLASS_NAME)), +                .addMember("value", "$S", "VisibleForTests"), +                .build());, +      }]
[+++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +package com.bumptech.glide;, +, +import android.content.Context;, +import android.graphics.Bitmap;, +import android.graphics.drawable.Drawable;, +import android.view.animation.Animation;, +import com.bumptech.glide.load.ResourceDecoder;, +import com.bumptech.glide.load.ResourceEncoder;, +import com.bumptech.glide.load.Transformation;, +import com.bumptech.glide.load.model.ImageVideoWrapper;, +import com.bumptech.glide.load.resource.bitmap.CenterCrop;, +import com.bumptech.glide.load.resource.bitmap.FitCenter;, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmap;, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapTransformation;, +import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;, +import com.bumptech.glide.provider.LoadProvider;, +import com.bumptech.glide.request.bitmap.RequestListener;, +, +import java.io.InputStream;, +, +public class DrawableRequestBuilder<ModelType> extends, +        GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmap, Drawable> {, +    private final Context context;, +    private final Glide glide;, +, +    public DrawableRequestBuilder(Context context, ModelType model,, +            LoadProvider<ModelType, ImageVideoWrapper, GifBitmap, Drawable> loadProvider, Glide glide) {, +        super(context, model, loadProvider, Drawable.class, glide);, +        this.context = context;, +        this.glide = glide;, +    }, +, +    public DrawableRequestBuilder<ModelType> thumbnail(, +            DrawableRequestBuilder<ModelType> thumbnailRequest) {, +        super.thumbnail(thumbnailRequest);, +        return this;, +    }, +, +    @Override, +    public DrawableRequestBuilder<ModelType> thumbnail(, +            GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmap, Drawable> thumbnailRequest) {, +        super.thumbnail(thumbnailRequest);, +        return this;, +    }, +, +    @Override, +    public DrawableRequestBuilder<ModelType> thumbnail(float sizeMultiplier) {, +        super.thumbnail(sizeMultiplier);, +        return this;, +    }, +, +    @Override, +    public DrawableRequestBuilder<ModelType> sizeMultiplier(, +            float sizeMultiplier) {, +        super.sizeMultiplier(sizeMultiplier);, +        return this;, +    }, +, +    @Override, +    public DrawableRequestBuilder<ModelType> decoder(, +            ResourceDecoder<ImageVideoWrapper, GifBitmap> decoder) {, +        super.decoder(decoder);, +        return this;, +    }, +, +    @Override, +    public DrawableRequestBuilder<ModelType> cacheDecoder(, +            ResourceDecoder<InputStream, GifBitmap> cacheDecoder) {, +        super.cacheDecoder(cacheDecoder);, +        return this;, +    }, +, +    @Override, +    public DrawableRequestBuilder<ModelType> encoder(, +            ResourceEncoder<GifBitmap> encoder) {, +        super.encoder(encoder);, +        return this;, +    }, +, +    @Override, +    public DrawableRequestBuilder<ModelType> priority(Priority priority) {, +        super.priority(priority);, +        return this;, +    }, +, +    public DrawableRequestBuilder<ModelType> centerCrop() {, +        return bitmapTransform(new CenterCrop(glide.getBitmapPool()));, +    }, +, +    public DrawableRequestBuilder<ModelType> fitCenter() {, +        return bitmapTransform(new FitCenter(glide.getBitmapPool()));, +    }, +, +    public DrawableRequestBuilder<ModelType> bitmapTransform(Transformation<Bitmap> bitmapTransformation) {, +        return transform(new GifBitmapTransformation(context, bitmapTransformation));, +    }, +]
[+++ b/.gitignore, +.gradle, +build, +jacoco.exec, +.idea/**, +!.idea/codeStyleSettings.xml, +++ b/.gitignore, +.gradle, +build, +jacoco.exec, +.idea/**, +!.idea/codeStyleSettings.xml, +++ b/.travis.yml, +    # https://github.com/travis-ci/travis-ci/issues/6040#issuecomment-219367943, +++ b/.gitignore, +.gradle, +build, +jacoco.exec, +.idea/**, +!.idea/codeStyleSettings.xml, +++ b/.travis.yml, +    # https://github.com/travis-ci/travis-ci/issues/6040#issuecomment-219367943, +++ b/build.gradle, +        jcenter(), +        google(), +        toolVersion = '8.5', +++ b/.gitignore, +.gradle, +build, +jacoco.exec, +.idea/**, +!.idea/codeStyleSettings.xml, +++ b/.travis.yml, +    # https://github.com/travis-ci/travis-ci/issues/6040#issuecomment-219367943, +++ b/build.gradle, +        jcenter(), +        google(), +        toolVersion = '8.5', +++ b/gradle.properties, +++ b/.gitignore, +.gradle, +build, +jacoco.exec, +.idea/**, +!.idea/codeStyleSettings.xml, +++ b/.travis.yml, +    # https://github.com/travis-ci/travis-ci/issues/6040#issuecomment-219367943, +++ b/build.gradle, +        jcenter(), +        google(), +        toolVersion = '8.5', +++ b/gradle.properties, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/.gitignore, +.gradle, +build, +jacoco.exec, +.idea/**, +!.idea/codeStyleSettings.xml, +++ b/.travis.yml, +    # https://github.com/travis-ci/travis-ci/issues/6040#issuecomment-219367943, +++ b/build.gradle, +        jcenter(), +        google(), +        toolVersion = '8.5', +++ b/gradle.properties, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.3.1-all.zip, +++ b/.gitignore, +.gradle, +build, +jacoco.exec, +.idea/**, +!.idea/codeStyleSettings.xml, +++ b/.travis.yml, +    # https://github.com/travis-ci/travis-ci/issues/6040#issuecomment-219367943, +++ b/build.gradle, +        jcenter(), +        google(), +        toolVersion = '8.5', +++ b/gradle.properties, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.3.1-all.zip, +++ b/instrumentation/build.gradle, +++ b/.gitignore, +.gradle, +build, +jacoco.exec, +.idea/**, +!.idea/codeStyleSettings.xml, +++ b/.travis.yml, +    # https://github.com/travis-ci/travis-ci/issues/6040#issuecomment-219367943, +++ b/build.gradle, +        jcenter(), +        google(), +        toolVersion = '8.5', +++ b/gradle.properties, +++ b/gradle/wrapper/gradle-wrapper.jar]
[+++ b/gradle.properties, +VERSION_NAME=3.3.0, +++ b/gradle.properties, +VERSION_NAME=3.3.0, +++ b/integration/okhttp/build.gradle, +        versionCode = VERSION_CODE, +        versionName = VERSION_NAME, +++ b/gradle.properties, +VERSION_NAME=3.3.0, +++ b/integration/okhttp/build.gradle, +        versionCode = VERSION_CODE, +        versionName = VERSION_NAME, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.0.0, +++ b/gradle.properties, +VERSION_NAME=3.3.0, +++ b/integration/okhttp/build.gradle, +        versionCode = VERSION_CODE, +        versionName = VERSION_NAME, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.0.0, +++ b/integration/volley/build.gradle, +        versionCode = VERSION_CODE, +        versionName = VERSION_NAME, +++ b/gradle.properties, +VERSION_NAME=3.3.0, +++ b/integration/okhttp/build.gradle, +        versionCode = VERSION_CODE, +        versionName = VERSION_NAME, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.0.0, +++ b/integration/volley/build.gradle, +        versionCode = VERSION_CODE, +        versionName = VERSION_NAME, +++ b/integration/volley/gradle.properties, +VERSION_NAME=1.0.0]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, + * {@link com.bumptech.glide.request.RequestOptions} classes., +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, + * {@link com.bumptech.glide.request.RequestOptions} classes., +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, + *     <li>A {@link com.bumptech.glide.request.RequestOptions} implementation that contains, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, + * {@link com.bumptech.glide.request.RequestOptions} classes., +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, + *     <li>A {@link com.bumptech.glide.request.RequestOptions} implementation that contains, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +        "com.bumptech.glide.request.RequestOptions")) {, +          + " RequestOptions object as their first and only parameter, found multiple for: ", +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, + * {@link com.bumptech.glide.request.RequestOptions} classes., +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, + *     <li>A {@link com.bumptech.glide.request.RequestOptions} implementation that contains, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +        "com.bumptech.glide.request.RequestOptions")) {, +          + " RequestOptions object as their first and only parameter, found multiple for: ", +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +    // With this we get @see RequestOptions#methodName()., +    // @see RequestOptions<CHILD>#methodName()., +   * in {@literal RequestOptions<T>} for example)., +  List<ExecutableElement> findStaticMethodsReturning(TypeElement clazz, TypeElement returnType) {, +    return FluentIterable.from(clazz.getEnclosedElements()), +        .filter(new FilterPublicMethods(returnType, MethodType.STATIC)), +        .transform(new ToMethod()), +        .toList();, +  }, +, +  private static final class ToMethod implements Function<Element, ExecutableElement> {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, + * {@link com.bumptech.glide.request.RequestOptions} classes., +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, + *     <li>A {@link com.bumptech.glide.request.RequestOptions} implementation that contains, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +        "com.bumptech.glide.request.RequestOptions")) {, +          + " RequestOptions object as their first and only parameter, found multiple for: ", +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +    // With this we get @see RequestOptions#methodName()., +    // @see RequestOptions<CHILD>#methodName()., +   * in {@literal RequestOptions<T>} for example)., +  List<ExecutableElement> findStaticMethodsReturning(TypeElement clazz, TypeElement returnType) {, +    return FluentIterable.from(clazz.getEnclosedElements()), +        .filter(new FilterPublicMethods(returnType, MethodType.STATIC)), +        .transform(new ToMethod()), +        .toList();, +  }, +, +  private static final class ToMethod implements Function<Element, ExecutableElement> {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, + * the base class, all methods from {@link com.bumptech.glide.request.RequestOptions} and all, + *    * {@literal @see} RequestOptions#sizeMultiplier(float), +  private static final String REQUEST_OPTIONS_PACKAGE_NAME = "com.bumptech.glide.request";, +  private static final String REQUEST_OPTIONS_SIMPLE_NAME = "RequestOptions";, +  private static final String REQUEST_OPTIONS_QUALIFIED_NAME =, +      REQUEST_OPTIONS_PACKAGE_NAME + "." + REQUEST_OPTIONS_SIMPLE_NAME;, +  /** A set of method names to avoid overriding from RequestOptions. */, +  private final TypeElement requestOptionsType;, +    requestOptionsType = processingEnv.getElementUtils().getTypeElement(, +        REQUEST_OPTIONS_QUALIFIED_NAME);, +              RequestBuilderGenerator.REQUEST_OPTIONS_SIMPLE_NAME);, +        .addJavadoc("{@link $T} and all generated options from\n", requestOptionsType), +        .addJavadoc("@see $T\n", requestOptionsType), +    return, +        !EXCLUDED_METHODS_FROM_BASE_REQUEST_OPTIONS.contains(requestOptionMethod.name), +        && requestOptionMethod.hasModifier(Modifier.PUBLIC), +        .addTypeVariables(requestOptionMethod.typeVariables), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, + * {@link com.bumptech.glide.request.RequestOptions} classes., +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, + *     <li>A {@link com.bumptech.glide.request.RequestOptions} implementation that contains, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +        "com.bumptech.glide.request.RequestOptions")) {, +          + " RequestOptions object as their first and only parameter, found multiple for: ", +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +    // With this we get @see RequestOptions#methodName()., +    // @see RequestOptions<CHILD>#methodName()., +   * in {@literal RequestOptions<T>} for example)., +  List<ExecutableElement> findStaticMethodsReturning(TypeElement clazz, TypeElement returnType) {, +    return FluentIterable.from(clazz.getEnclosedElements()), +        .filter(new FilterPublicMethods(returnType, MethodType.STATIC)), +        .transform(new ToMethod()), +        .toList();, +  }, +, +  private static final class ToMethod implements Function<Element, ExecutableElement> {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, + * the base class, all methods from {@link com.bumptech.glide.request.RequestOptions} and all, + *    * {@literal @see} RequestOptions#sizeMultiplier(float), +  private static final String REQUEST_OPTIONS_PACKAGE_NAME = "com.bumptech.glide.request";, +  private static final String REQUEST_OPTIONS_SIMPLE_NAME = "RequestOptions";, +  private static final String REQUEST_OPTIONS_QUALIFIED_NAME =, +      REQUEST_OPTIONS_PACKAGE_NAME + "." + REQUEST_OPTIONS_SIMPLE_NAME;, +  /** A set of method names to avoid overriding from RequestOptions. */, +  private final TypeElement requestOptionsType;, +    requestOptionsType = processingEnv.getElementUtils().getTypeElement(, +        REQUEST_OPTIONS_QUALIFIED_NAME);, +              RequestBuilderGenerator.REQUEST_OPTIONS_SIMPLE_NAME);]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java, +    float memoryCacheSize = harness.getCalculator().getMemoryCacheSize();, +    assertThat(memoryCacheSize).isEqualTo(harness.getScreenSize() * harness.memoryCacheScreens);, +  }, +, +  @Test, +  public void testCanSetCustomMemoryCacheSize() {, +    harness.memoryCacheScreens = 9.5f;, +    Shadows.shadowOf(harness.activityManager).setMemoryClass(getLargeEnoughMemoryClass());, +, +    float memoryCacheSize = harness.getCalculator().getMemoryCacheSize();, +, +    assertThat(memoryCacheSize).isEqualTo(harness.getScreenSize() * harness.memoryCacheScreens);, +    float memoryCacheSize = harness.getCalculator().getMemoryCacheSize();, +    float bitmapPoolSize = harness.getCalculator().getBitmapPoolSize();, +    assertThat(bitmapPoolSize).isEqualTo(harness.getScreenSize() * harness.bitmapPoolScreens);, +  }, +, +  @Test, +  public void testCanSetCustomBitmapPoolSize() {, +    harness.bitmapPoolScreens = 2f;, +    Shadows.shadowOf(harness.activityManager).setMemoryClass(getLargeEnoughMemoryClass());, +, +    float bitmapPoolSize = harness.getCalculator().getBitmapPoolSize();, +, +    assertThat(bitmapPoolSize).isEqualTo(harness.getScreenSize() * harness.bitmapPoolScreens);, +    float memoryCacheScreens = MemorySizeCalculator.Builder.MEMORY_CACHE_TARGET_SCREENS;, +    float bitmapPoolScreens = MemorySizeCalculator.Builder.BITMAP_POOL_TARGET_SCREENS;, +    float sizeMultiplier = MemorySizeCalculator.Builder.MAX_SIZE_MULTIPLIER;, +      return new MemorySizeCalculator.Builder(RuntimeEnvironment.application), +          .setMemoryCacheScreens(memoryCacheScreens), +          .setBitmapPoolScreens(bitmapPoolScreens), +          .setMaxSizeMultiplier(sizeMultiplier), +          .setActivityManager(activityManager), +          .setScreenDimensions(screenDimensions), +          .build();, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java, +    float memoryCacheSize = harness.getCalculator().getMemoryCacheSize();, +    assertThat(memoryCacheSize).isEqualTo(harness.getScreenSize() * harness.memoryCacheScreens);, +  }, +, +  @Test, +  public void testCanSetCustomMemoryCacheSize() {, +    harness.memoryCacheScreens = 9.5f;, +    Shadows.shadowOf(harness.activityManager).setMemoryClass(getLargeEnoughMemoryClass());, +, +    float memoryCacheSize = harness.getCalculator().getMemoryCacheSize();, +, +    assertThat(memoryCacheSize).isEqualTo(harness.getScreenSize() * harness.memoryCacheScreens);, +    float memoryCacheSize = harness.getCalculator().getMemoryCacheSize();, +    float bitmapPoolSize = harness.getCalculator().getBitmapPoolSize();, +    assertThat(bitmapPoolSize).isEqualTo(harness.getScreenSize() * harness.bitmapPoolScreens);, +  }, +, +  @Test, +  public void testCanSetCustomBitmapPoolSize() {, +    harness.bitmapPoolScreens = 2f;, +    Shadows.shadowOf(harness.activityManager).setMemoryClass(getLargeEnoughMemoryClass());, +, +    float bitmapPoolSize = harness.getCalculator().getBitmapPoolSize();, +, +    assertThat(bitmapPoolSize).isEqualTo(harness.getScreenSize() * harness.bitmapPoolScreens);, +    float memoryCacheScreens = MemorySizeCalculator.Builder.MEMORY_CACHE_TARGET_SCREENS;, +    float bitmapPoolScreens = MemorySizeCalculator.Builder.BITMAP_POOL_TARGET_SCREENS;, +    float sizeMultiplier = MemorySizeCalculator.Builder.MAX_SIZE_MULTIPLIER;, +      return new MemorySizeCalculator.Builder(RuntimeEnvironment.application), +          .setMemoryCacheScreens(memoryCacheScreens), +          .setBitmapPoolScreens(bitmapPoolScreens), +          .setMaxSizeMultiplier(sizeMultiplier), +          .setActivityManager(activityManager), +          .setScreenDimensions(screenDimensions), +          .build();, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +  private MemorySizeCalculator memorySizeCalculator;, +  /**, +   * Sets the {@link MemorySizeCalculator} to use to calculate maximum sizes for default, +   * {@link MemoryCache MemoryCaches} and/or default {@link BitmapPool BitmapPools}., +   *, +   * @see #setMemorySizeCalculator(MemorySizeCalculator), +   *, +   * @param builder The builder to use (will not be modified)., +   * @return This builder., +   */, +  public GlideBuilder setMemorySizeCalculator(MemorySizeCalculator.Builder builder) {, +    return setMemorySizeCalculator(builder.build());, +  }, +, +  /**, +   * Sets the {@link MemorySizeCalculator} to use to calculate maximum sizes for default, +   * {@link MemoryCache MemoryCaches} and/or default {@link BitmapPool BitmapPools}., +   *, +   * <p>The given {@link MemorySizeCalculator} will not affect custom pools or caches provided, +   * via {@link #setBitmapPool(BitmapPool)} or {@link #setMemoryCache(MemoryCache)}., +   *, +   * @param calculator The calculator to use., +   * @return This builder., +   */, +  public GlideBuilder setMemorySizeCalculator(MemorySizeCalculator calculator) {, +    this.memorySizeCalculator = calculator;, +    return this;]
[+++ b/build.gradle, +        if (!hasProperty('DISABLE_ERROR_PRONE')) {, +}, +++ b/build.gradle, +        if (!hasProperty('DISABLE_ERROR_PRONE')) {, +}, +++ b/gradle.properties, +++ b/build.gradle, +        if (!hasProperty('DISABLE_ERROR_PRONE')) {, +}, +++ b/gradle.properties, +++ b/library/build.gradle, +++ b/build.gradle, +        if (!hasProperty('DISABLE_ERROR_PRONE')) {, +}, +++ b/gradle.properties, +++ b/library/build.gradle, +++ b/scripts/travis_after_success.sh]
[+++ b/checkstyle.xml, +    <!-- Ensure trailling newline for compatibility -->, +    <module name="NewlineAtEndOfFile" />, +, +++ b/checkstyle.xml, +    <!-- Ensure trailling newline for compatibility -->, +    <module name="NewlineAtEndOfFile" />, +, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +++ b/checkstyle.xml, +    <!-- Ensure trailling newline for compatibility -->, +    <module name="NewlineAtEndOfFile" />, +, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +++ b/library/src/test/java/com/bumptech/glide/load/OptionsTest.java, +++ b/checkstyle.xml, +    <!-- Ensure trailling newline for compatibility -->, +    <module name="NewlineAtEndOfFile" />, +, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +++ b/library/src/test/java/com/bumptech/glide/load/OptionsTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java, +++ b/checkstyle.xml, +    <!-- Ensure trailling newline for compatibility -->, +    <module name="NewlineAtEndOfFile" />, +, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +++ b/library/src/test/java/com/bumptech/glide/load/OptionsTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java, +++ b/checkstyle.xml, +    <!-- Ensure trailling newline for compatibility -->, +    <module name="NewlineAtEndOfFile" />, +, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +++ b/library/src/test/java/com/bumptech/glide/load/OptionsTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +++ b/checkstyle.xml, +    <!-- Ensure trailling newline for compatibility -->, +    <module name="NewlineAtEndOfFile" />, +, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +++ b/library/src/test/java/com/bumptech/glide/load/OptionsTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java, +++ b/checkstyle.xml, +    <!-- Ensure trailling newline for compatibility -->, +    <module name="NewlineAtEndOfFile" />, +, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +++ b/library/src/test/java/com/bumptech/glide/load/OptionsTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java, +++ b/checkstyle.xml, +    <!-- Ensure trailling newline for compatibility -->, +    <module name="NewlineAtEndOfFile" />, +, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +++ b/library/src/test/java/com/bumptech/glide/load/OptionsTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java, +++ b/checkstyle.xml, +    <!-- Ensure trailling newline for compatibility -->, +    <module name="NewlineAtEndOfFile" />, +, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +++ b/library/src/test/java/com/bumptech/glide/load/OptionsTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java, +++ b/checkstyle.xml, +    <!-- Ensure trailling newline for compatibility -->, +    <module name="NewlineAtEndOfFile" />, +, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +++ b/library/src/test/java/com/bumptech/glide/load/OptionsTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/StreamAssetPathFetcherTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpenerTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/engine/DataCacheKeyTest.java, +++ b/library/src/test/java/com/bumptech/glide/load/engine/ResourceCacheKeyTest.java, +++ b/checkstyle.xml]
[+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java, +    setResourceInternal(null);, +    setResourceInternal(null);, +    setResourceInternal(null);, +      setResourceInternal(resource);, +      maybeUpdateAnimatable(resource);, +  private void setResourceInternal(@Nullable Z resource) {, +    maybeUpdateAnimatable(resource);, +    setResource(resource);, +  }, +, +  private void maybeUpdateAnimatable(@Nullable Z resource) {, +    if (resource instanceof Animatable) {, +      animatable = (Animatable) resource;, +      animatable.start();, +    } else {, +      animatable = null;, +    }, +  }, +]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java, +import android.support.annotation.NonNull;, +      public void addListener(@NonNull LifecycleListener listener) {, +      public void removeListener(@NonNull LifecycleListener listener) {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java, +import android.support.annotation.NonNull;, +      public void addListener(@NonNull LifecycleListener listener) {, +      public void removeListener(@NonNull LifecycleListener listener) {, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +  void track(@NonNull Target<?> target, @NonNull Request request) {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java, +import android.support.annotation.NonNull;, +      public void addListener(@NonNull LifecycleListener listener) {, +      public void removeListener(@NonNull LifecycleListener listener) {, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +  void track(@NonNull Target<?> target, @NonNull Request request) {, +++ b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java, +import android.support.annotation.NonNull;, +  public void addListener(@NonNull LifecycleListener listener) {, +  public void removeListener(@NonNull LifecycleListener listener) {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java, +import android.support.annotation.NonNull;, +      public void addListener(@NonNull LifecycleListener listener) {, +      public void removeListener(@NonNull LifecycleListener listener) {, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +  void track(@NonNull Target<?> target, @NonNull Request request) {, +++ b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java, +import android.support.annotation.NonNull;, +  public void addListener(@NonNull LifecycleListener listener) {, +  public void removeListener(@NonNull LifecycleListener listener) {, +++ b/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java, +import android.support.annotation.NonNull;, +, +  public void addListener(@NonNull LifecycleListener listener) {, +  public void removeListener(@NonNull LifecycleListener listener) {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java, +import android.support.annotation.NonNull;, +      public void addListener(@NonNull LifecycleListener listener) {, +      public void removeListener(@NonNull LifecycleListener listener) {, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +  void track(@NonNull Target<?> target, @NonNull Request request) {, +++ b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java, +import android.support.annotation.NonNull;, +  public void addListener(@NonNull LifecycleListener listener) {, +  public void removeListener(@NonNull LifecycleListener listener) {, +++ b/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java, +import android.support.annotation.NonNull;, +, +  public void addListener(@NonNull LifecycleListener listener) {, +  public void removeListener(@NonNull LifecycleListener listener) {, +++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java, +import android.support.annotation.NonNull;, +    public void onReceive(@NonNull Context context, Intent intent) {, +  DefaultConnectivityMonitor(@NonNull Context context, @NonNull ConnectivityListener listener) {, +  boolean isConnected(@NonNull Context context) {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java, +import android.support.annotation.NonNull;, +      public void addListener(@NonNull LifecycleListener listener) {, +      public void removeListener(@NonNull LifecycleListener listener) {, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +  void track(@NonNull Target<?> target, @NonNull Request request) {, +++ b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java, +import android.support.annotation.NonNull;, +  public void addListener(@NonNull LifecycleListener listener) {, +  public void removeListener(@NonNull LifecycleListener listener) {, +++ b/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java, +import android.support.annotation.NonNull;, +, +  public void addListener(@NonNull LifecycleListener listener) {, +  public void removeListener(@NonNull LifecycleListener listener) {, +++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java, +import android.support.annotation.NonNull;, +    public void onReceive(@NonNull Context context, Intent intent) {, +  DefaultConnectivityMonitor(@NonNull Context context, @NonNull ConnectivityListener listener) {, +  boolean isConnected(@NonNull Context context) {, +++ b/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java, +import android.support.annotation.NonNull;, +    @NonNull, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestManagerTest.java, +import android.support.annotation.NonNull;, +      public void addListener(@NonNull LifecycleListener listener) {, +      public void removeListener(@NonNull LifecycleListener listener) {, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +  void track(@NonNull Target<?> target, @NonNull Request request) {, +++ b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java, +import android.support.annotation.NonNull;, +  public void addListener(@NonNull LifecycleListener listener) {, +  public void removeListener(@NonNull LifecycleListener listener) {, +++ b/library/src/main/java/com/bumptech/glide/manager/ApplicationLifecycle.java, +import android.support.annotation.NonNull;, +, +  public void addListener(@NonNull LifecycleListener listener) {, +  public void removeListener(@NonNull LifecycleListener listener) {, +++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java, +import android.support.annotation.NonNull;, +    public void onReceive(@NonNull Context context, Intent intent) {, +  DefaultConnectivityMonitor(@NonNull Context context, @NonNull ConnectivityListener listener) {, +  boolean isConnected(@NonNull Context context) {, +++ b/library/src/main/java/com/bumptech/glide/manager/EmptyRequestManagerTreeNode.java, +import android.support.annotation.NonNull;]
[+++ b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java, + *     e.addFrame(image3, 100, 100);    // set position of the frame, +    private int fixedWidth;   // set by setSize(), +, +    private int fixedHeight;, +, +     * <code>setSize</code> was invoked, the size is used for all subsequent frames., +     * Otherwise, the actual size of the image is used for each frames., +        return addFrame(im, 0, 0);, +    }, +, +    /**, +     * Adds next GIF frame to the specified position. The frame is not written immediately, but is actually, +     * deferred until the next frame is received so that timing data can be, +     * inserted. Invoking <code>finish()</code> flushes all frames. If, +     * <code>setSize</code> was invoked, the size is used for all subsequent frames., +     * Otherwise, the actual size of the image is used for each frames., +     *, +     * @param im, +     *          BufferedImage containing frame to write., +     * @param x, +     *          x position of this frame, +     * @param y, +     *          y position of this frame, +     * @return true if successful., +     */, +    public boolean addFrame(Bitmap im, int x, int y) {, +            if (sizeSet) {, +                setFrameSize(fixedWidth, fixedHeight);, +            }, +            else{, +                setFrameSize(im.getWidth(), im.getHeight());, +            writeImageDesc(x, y); // image descriptor, +     * Sets the fixed GIF frame size for all the frames., +     * This should be called before start., +        if (started), +, +        fixedWidth = w;, +        fixedHeight = h;, +        if (fixedWidth < 1), +            fixedWidth = 320;, +        if (fixedHeight < 1), +            fixedHeight = 240;, +, +        sizeSet = true;, +    }, +, +    /**, +     * Sets current GIF frame size., +     *, +     * @param w, +     *          int frame width., +     * @param h, +     *          int frame width., +     */, +    private void setFrameSize(int w, int h) {, +    private void writeImageDesc(int x, int y) throws IOException {, +        writeShort(x); // image position, +        writeShort(y);]
[+++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]src[/\\]main[/\\]java[/\\]com[/\\]bumptech[/\\]glide[/\\]util[/\\]CachedHashCodeArrayMap.java" checks="EqualsHashCodeCheck"/>, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]src[/\\]main[/\\]java[/\\]com[/\\]bumptech[/\\]glide[/\\]util[/\\]CachedHashCodeArrayMap.java" checks="EqualsHashCodeCheck"/>, +++ b/library/findbugs-exclude.xml, +    <!-- We just cache the value of hashcode, no need to also override equals. -->, +    <Match>, +      <Class name="com.bumptech.glide.util.CachedHashCodeArrayMap" />, +      <Bug pattern="EQ_DOESNT_OVERRIDE_EQUALS" />, +    </Match>, +, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]library[/\\]src[/\\]main[/\\]java[/\\]com[/\\]bumptech[/\\]glide[/\\]util[/\\]CachedHashCodeArrayMap.java" checks="EqualsHashCodeCheck"/>, +++ b/library/findbugs-exclude.xml, +    <!-- We just cache the value of hashcode, no need to also override equals. -->, +    <Match>, +      <Class name="com.bumptech.glide.util.CachedHashCodeArrayMap" />, +      <Bug pattern="EQ_DOESNT_OVERRIDE_EQUALS" />, +    </Match>, +, +++ b/library/src/main/java/com/bumptech/glide/util/CachedHashCodeArrayMap.java, +/**, + * An {@link ArrayMap} that caches its hashCode to support efficient lookup., + *, + * @param <K> the key type., + * @param <V> the value type., + */, +// We're overriding hashcode, but not in a way that changes the output, so we don't need to, +// override equals., +@SuppressWarnings("PMD.OverrideBothEqualsAndHashcode")]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +    while (!started && hasNextModelLoader()) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +    while (!started && hasNextModelLoader()) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +        return new SourceGenerator(decodeHelper, this);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +    while (!started && hasNextModelLoader()) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +        return new SourceGenerator(decodeHelper, this);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +    isCancelled = true;, +    decodeJob.cancel();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +    while (!started && hasNextModelLoader()) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +        return new SourceGenerator(decodeHelper, this);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +    isCancelled = true;, +    decodeJob.cancel();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java, +    while (!started && hasNextModelLoader()) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +    while (!started && hasNextModelLoader()) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +        return new SourceGenerator(decodeHelper, this);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +    isCancelled = true;, +    decodeJob.cancel();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java, +    while (!started && hasNextModelLoader()) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java, +class SourceGenerator implements DataFetcherGenerator,, +    while (!started && hasNextModelLoader()) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +    while (!started && hasNextModelLoader()) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +        return new SourceGenerator(decodeHelper, this);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +    isCancelled = true;, +    decodeJob.cancel();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java, +    while (!started && hasNextModelLoader()) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java, +class SourceGenerator implements DataFetcherGenerator,, +    while (!started && hasNextModelLoader()) {, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +                return input.type;, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +                return input.type;, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +            .equals(requestOptionsClassName.toString());]
[+++ b/library/AndroidManifest.xml, +          android:versionCode="6", +          android:versionName="2.0.4" >]
[+++ b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java, +import com.bumptech.glide.util.Util;, +, +    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {, +    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {, +    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {, +++ b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java, +import com.bumptech.glide.util.Util;, +, +    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {, +    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {, +    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java, +import com.bumptech.glide.util.Util;, +    for (Request request : Util.getSnapshot(requests)) {, +    for (Request request : Util.getSnapshot(requests)) {, +    for (Request request : Util.getSnapshot(requests)) {, +    for (Request request : Util.getSnapshot(requests)) {, +++ b/library/src/main/java/com/bumptech/glide/manager/ActivityFragmentLifecycle.java, +import com.bumptech.glide.util.Util;, +, +    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {, +    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {, +    for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) {, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestTracker.java, +import com.bumptech.glide.util.Util;, +    for (Request request : Util.getSnapshot(requests)) {, +    for (Request request : Util.getSnapshot(requests)) {, +    for (Request request : Util.getSnapshot(requests)) {, +    for (Request request : Util.getSnapshot(requests)) {, +++ b/library/src/main/java/com/bumptech/glide/util/Util.java, +import java.util.ArrayList;, +import java.util.Collection;, +import java.util.List;, +, +  /**, +   * Returns a copy of the given list that is safe to iterate over and perform actions that may, +   * modify the original list., +   *, +   * <p> See #303 and #375. </p>, +   */, +  public static <T> List<T> getSnapshot(Collection<T> other) {, +      // toArray creates a new ArrayList internally and this way we can guarantee entries will not, +      // be null. See #322., +      List<T> result = new ArrayList<T>(other.size());, +      for (T item : other) {, +          result.add(item);, +      }, +      return result;, +  }]
[+++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +  @Test @Config(sdk = 19), +    bitmap.setConfig(null);, +++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +  @Test @Config(sdk = 19), +    bitmap.setConfig(null);, +++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java, +  @Test @Config(sdk = 19), +    bitmap.setConfig(null);, +++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +  @Test @Config(sdk = 19), +    bitmap.setConfig(null);, +++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/CenterCropTest.java, +  @Test @Config(sdk = 19), +    bitmap.setConfig(null);, +++ b/library/test/src/test/java/com/bumptech/glide/load/resource/bitmap/TransformationUtilsTest.java, +  @Test @Config(sdk = 19), +    toFit.setConfig(null);, +  @Test @Config(sdk = 19), +    toTransform.setConfig(null);, +  @Test @Config(sdk = 19), +    toRotate.setConfig(null);]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private boolean onlyRetrieveFromCache;, +      boolean onlyRetrieveFromCache,, +    this.onlyRetrieveFromCache = onlyRetrieveFromCache;, +        // Skip loading from source if the user opted to only retrieve the resource from cache., +        return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private boolean onlyRetrieveFromCache;, +      boolean onlyRetrieveFromCache,, +    this.onlyRetrieveFromCache = onlyRetrieveFromCache;, +        // Skip loading from source if the user opted to only retrieve the resource from cache., +        return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +      boolean onlyRetrieveFromCache,, +        onlyRetrieveFromCache,, +        boolean onlyRetrieveFromCache,, +          onlyRetrieveFromCache,, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private boolean onlyRetrieveFromCache;, +      boolean onlyRetrieveFromCache,, +    this.onlyRetrieveFromCache = onlyRetrieveFromCache;, +        // Skip loading from source if the user opted to only retrieve the resource from cache., +        return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +      boolean onlyRetrieveFromCache,, +        onlyRetrieveFromCache,, +        boolean onlyRetrieveFromCache,, +          onlyRetrieveFromCache,, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +  private static final int ONLY_RETRIEVE_FROM_CACHE = 1 << 19;, +  private boolean onlyRetrieveFromCache;, +   * If set to true, will only load an item if found in the cache, and will not fetch from source., +   */, +  public final CHILD getOnlyRetrieveFromCache(boolean flag) {, +    if (isAutoCloneEnabled) {, +      return clone().getOnlyRetrieveFromCache(flag);, +    }, +, +    this.onlyRetrieveFromCache = flag;, +    fields |= ONLY_RETRIEVE_FROM_CACHE;, +, +    return selfOrThrowIfLocked();, +  }, +, +  /**, +    if (isSet(other.fields, ONLY_RETRIEVE_FROM_CACHE)) {, +      onlyRetrieveFromCache = other.onlyRetrieveFromCache;, +    }, +, +  public final boolean getOnlyRetrieveFromCache() {, +    return onlyRetrieveFromCache;, +  }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private boolean onlyRetrieveFromCache;, +      boolean onlyRetrieveFromCache,, +    this.onlyRetrieveFromCache = onlyRetrieveFromCache;, +        // Skip loading from source if the user opted to only retrieve the resource from cache., +        return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +      boolean onlyRetrieveFromCache,, +        onlyRetrieveFromCache,, +        boolean onlyRetrieveFromCache,, +          onlyRetrieveFromCache,, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +  private static final int ONLY_RETRIEVE_FROM_CACHE = 1 << 19;, +  private boolean onlyRetrieveFromCache;, +   * If set to true, will only load an item if found in the cache, and will not fetch from source., +   */, +  public final CHILD getOnlyRetrieveFromCache(boolean flag) {, +    if (isAutoCloneEnabled) {, +      return clone().getOnlyRetrieveFromCache(flag);, +    }, +, +    this.onlyRetrieveFromCache = flag;, +    fields |= ONLY_RETRIEVE_FROM_CACHE;, +, +    return selfOrThrowIfLocked();, +  }, +, +  /**, +    if (isSet(other.fields, ONLY_RETRIEVE_FROM_CACHE)) {, +      onlyRetrieveFromCache = other.onlyRetrieveFromCache;, +    }, +, +  public final boolean getOnlyRetrieveFromCache() {, +    return onlyRetrieveFromCache;, +  }, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +        requestOptions.getOnlyRetrieveFromCache(),, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private boolean onlyRetrieveFromCache;, +      boolean onlyRetrieveFromCache,, +    this.onlyRetrieveFromCache = onlyRetrieveFromCache;, +        // Skip loading from source if the user opted to only retrieve the resource from cache., +        return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +      boolean onlyRetrieveFromCache,, +        onlyRetrieveFromCache,, +        boolean onlyRetrieveFromCache,, +          onlyRetrieveFromCache,]
[+++ b/integration/okhttp/build.gradle, +apply plugin: 'com.android.library', +, +repositories {, +    mavenCentral(), +}, +, +dependencies {, +    compile project(':library'), +, +    compile 'com.squareup.okhttp:okhttp:2.0.+', +}, +, +android {, +    compileSdkVersion 19, +    buildToolsVersion "19.1.0", +, +    defaultConfig {, +        applicationId "com.bumptech.glide.integration.okhttp", +        minSdkVersion 10, +        targetSdkVersion 19, +        versionCode 1, +        versionName "1.0.0", +    }, +}, +, +++ b/integration/okhttp/build.gradle, +apply plugin: 'com.android.library', +, +repositories {, +    mavenCentral(), +}, +, +dependencies {, +    compile project(':library'), +, +    compile 'com.squareup.okhttp:okhttp:2.0.+', +}, +, +android {, +    compileSdkVersion 19, +    buildToolsVersion "19.1.0", +, +    defaultConfig {, +        applicationId "com.bumptech.glide.integration.okhttp", +        minSdkVersion 10, +        targetSdkVersion 19, +        versionCode 1, +        versionName "1.0.0", +    }, +}, +, +++ b/integration/okhttp/gradle.properties, +POM_NAME=Glide OkHttp Integration, +POM_ARTIFACT_ID=okhttp-integration, +++ b/integration/okhttp/build.gradle, +apply plugin: 'com.android.library', +, +repositories {, +    mavenCentral(), +}, +, +dependencies {, +    compile project(':library'), +, +    compile 'com.squareup.okhttp:okhttp:2.0.+', +}, +, +android {, +    compileSdkVersion 19, +    buildToolsVersion "19.1.0", +, +    defaultConfig {, +        applicationId "com.bumptech.glide.integration.okhttp", +        minSdkVersion 10, +        targetSdkVersion 19, +        versionCode 1, +        versionName "1.0.0", +    }, +}, +, +++ b/integration/okhttp/gradle.properties, +POM_NAME=Glide OkHttp Integration, +POM_ARTIFACT_ID=okhttp-integration, +++ b/integration/okhttp/lint.xml, +    <!-- See https://github.com/square/okio/issues/58 -->, +    <issue id="InvalidPackage" severity="ignore" >, +      <ignore regexp="okio-1.0.0.jar" />, +    </issue>, +++ b/integration/okhttp/build.gradle, +apply plugin: 'com.android.library', +, +repositories {, +    mavenCentral(), +}, +, +dependencies {, +    compile project(':library'), +, +    compile 'com.squareup.okhttp:okhttp:2.0.+']
[+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +   * @see #centerInside(Context) (android.content.Context), +   * @param context Any {@link android.content.Context}., +   * @see #transform(Class, com.bumptech.glide.load.Transformation), +   * @see #optionalCenterInside(Context) (android.content.Context), +   *, +   * @deprecated Use {@link #centerInside()}}, +   */, +  @Deprecated, +  @GlideOption(, +      staticMethodName = "centerInsideTransform",, +      memoizeStaticMethod = true, +  ), +  public CHILD centerInside(@SuppressWarnings("unused") Context context) {, +    return centerInside();, +  }, +, +  /**, +   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterInside} to all default types and, +   * throws an exception if asked to transform an unknown type., +   *, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *]
[+++ b/library/lint.xml, +++ b/library/lint.xml, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.presenter.ImageReadyCallback;, +        private ImagePresenter<T> buildImagePresenter(Target target) {, +                final Animation animation = AnimationUtils.loadAnimation(context, animationId);, +                builder.setImageReadyCallback(new ImageReadyCallback() {, +                    public void onImageReady(Target target, boolean fromCache) {, +                        if (!fromCache) {, +++ b/library/lint.xml, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.presenter.ImageReadyCallback;, +        private ImagePresenter<T> buildImagePresenter(Target target) {, +                final Animation animation = AnimationUtils.loadAnimation(context, animationId);, +                builder.setImageReadyCallback(new ImageReadyCallback() {, +                    public void onImageReady(Target target, boolean fromCache) {, +                        if (!fromCache) {, +++ b/library/src/com/bumptech/glide/loader/transformation/MultiTransformation.java, +            if (current != null && current != transformed) {, +                pool.put(current);, +++ b/library/lint.xml, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.presenter.ImageReadyCallback;, +        private ImagePresenter<T> buildImagePresenter(Target target) {, +                final Animation animation = AnimationUtils.loadAnimation(context, animationId);, +                builder.setImageReadyCallback(new ImageReadyCallback() {, +                    public void onImageReady(Target target, boolean fromCache) {, +                        if (!fromCache) {, +++ b/library/src/com/bumptech/glide/loader/transformation/MultiTransformation.java, +            if (current != null && current != transformed) {, +                pool.put(current);, +++ b/library/src/com/bumptech/glide/presenter/ImagePresenter.java, +        private ImageReadyCallback imageReadyCallback;, +        public Builder<T> setImageReadyCallback(ImageReadyCallback cb) {, +    private final ImageReadyCallback imageReadyCallback;, +                    imageReadyCallback.onImageReady(target, loadedFromCache);, +++ b/library/lint.xml, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.presenter.ImageReadyCallback;, +        private ImagePresenter<T> buildImagePresenter(Target target) {, +                final Animation animation = AnimationUtils.loadAnimation(context, animationId);, +                builder.setImageReadyCallback(new ImageReadyCallback() {, +                    public void onImageReady(Target target, boolean fromCache) {, +                        if (!fromCache) {, +++ b/library/src/com/bumptech/glide/loader/transformation/MultiTransformation.java, +            if (current != null && current != transformed) {, +                pool.put(current);, +++ b/library/src/com/bumptech/glide/presenter/ImagePresenter.java, +        private ImageReadyCallback imageReadyCallback;, +        public Builder<T> setImageReadyCallback(ImageReadyCallback cb) {, +    private final ImageReadyCallback imageReadyCallback;, +                    imageReadyCallback.onImageReady(target, loadedFromCache);, +++ b/library/src/com/bumptech/glide/presenter/ImageReadyCallback.java, +/*, + * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved., + */, +, +package com.bumptech.glide.presenter;, +, +import com.bumptech.glide.presenter.target.Target;, +, +/**, + * A callback interface used to perform some action when an {@link ImagePresenter} sets a new bitmap in an, + * {@link android.widget.ImageView}, + */, +public interface ImageReadyCallback {, +, +    /**, +     * The method called when a bitmap is set, +     *, +     * @param target The target that will display the bitmap, +     * @param fromCache True iff the load completed without a placeholder being shown., +     */, +    public void onImageReady(Target target, boolean fromCache);, +}, +++ b/library/lint.xml, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.presenter.ImageReadyCallback;, +        private ImagePresenter<T> buildImagePresenter(Target target) {, +                final Animation animation = AnimationUtils.loadAnimation(context, animationId);, +                builder.setImageReadyCallback(new ImageReadyCallback() {, +                    public void onImageReady(Target target, boolean fromCache) {, +                        if (!fromCache) {, +++ b/library/src/com/bumptech/glide/loader/transformation/MultiTransformation.java, +            if (current != null && current != transformed) {, +                pool.put(current);, +++ b/library/src/com/bumptech/glide/presenter/ImagePresenter.java, +        private ImageReadyCallback imageReadyCallback;, +        public Builder<T> setImageReadyCallback(ImageReadyCallback cb) {, +    private final ImageReadyCallback imageReadyCallback;, +                    imageReadyCallback.onImageReady(target, loadedFromCache);, +++ b/library/src/com/bumptech/glide/presenter/ImageReadyCallback.java, +/*, + * Copyright (c) 2012. Bump Technologies Inc. All Rights Reserved., + */, +, +package com.bumptech.glide.presenter;, +, +import com.bumptech.glide.presenter.target.Target;, +]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +   * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #submit(int, int)}.]
[+++ b/library/src/main/java/com/bumptech/glide/manager/LifecycleRequestManager.java, +import java.util.Collections;, +import java.util.WeakHashMap;, +    // Most requests will be for views and will therefore be held strongly (and safely) by the view via the tag., +    // However, a user can always pass in a different type of target which may end up not being strongly referenced even, +    // though the user still would like the request to finish. Weak references are therefore only really functional in, +    // this context for view targets. Despite the side affects, WeakReferences are still essentially required. A user, +    // can always make repeated requests into targets other than views, or use an activity manager in a fragment pager, +    // where holding strong references would steadily leak bitmaps and/or views., +    private final Set<Request> requests = Collections.newSetFromMap(new WeakHashMap<Request, Boolean>());, +++ b/library/src/main/java/com/bumptech/glide/manager/LifecycleRequestManager.java, +import java.util.Collections;, +import java.util.WeakHashMap;, +    // Most requests will be for views and will therefore be held strongly (and safely) by the view via the tag., +    // However, a user can always pass in a different type of target which may end up not being strongly referenced even, +    // though the user still would like the request to finish. Weak references are therefore only really functional in, +    // this context for view targets. Despite the side affects, WeakReferences are still essentially required. A user, +    // can always make repeated requests into targets other than views, or use an activity manager in a fragment pager, +    // where holding strong references would steadily leak bitmaps and/or views., +    private final Set<Request> requests = Collections.newSetFromMap(new WeakHashMap<Request, Boolean>());, +++ b/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java, +    public void testThrowsIfActivityDestroyed() {, +++ b/library/src/main/java/com/bumptech/glide/manager/LifecycleRequestManager.java, +import java.util.Collections;, +import java.util.WeakHashMap;, +    // Most requests will be for views and will therefore be held strongly (and safely) by the view via the tag., +    // However, a user can always pass in a different type of target which may end up not being strongly referenced even, +    // though the user still would like the request to finish. Weak references are therefore only really functional in, +    // this context for view targets. Despite the side affects, WeakReferences are still essentially required. A user, +    // can always make repeated requests into targets other than views, or use an activity manager in a fragment pager, +    // where holding strong references would steadily leak bitmaps and/or views., +    private final Set<Request> requests = Collections.newSetFromMap(new WeakHashMap<Request, Boolean>());, +++ b/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java, +    public void testThrowsIfActivityDestroyed() {, +++ b/samples/flickr/AndroidManifest.xml, +        android:windowSoftInputMode="stateHidden|adjustResize" >, +++ b/library/src/main/java/com/bumptech/glide/manager/LifecycleRequestManager.java, +import java.util.Collections;, +import java.util.WeakHashMap;, +    // Most requests will be for views and will therefore be held strongly (and safely) by the view via the tag., +    // However, a user can always pass in a different type of target which may end up not being strongly referenced even, +    // though the user still would like the request to finish. Weak references are therefore only really functional in, +    // this context for view targets. Despite the side affects, WeakReferences are still essentially required. A user, +    // can always make repeated requests into targets other than views, or use an activity manager in a fragment pager, +    // where holding strong references would steadily leak bitmaps and/or views., +    private final Set<Request> requests = Collections.newSetFromMap(new WeakHashMap<Request, Boolean>());, +++ b/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java, +    public void testThrowsIfActivityDestroyed() {, +++ b/samples/flickr/AndroidManifest.xml, +        android:windowSoftInputMode="stateHidden|adjustResize" >, +++ b/samples/flickr/res/layout/flickr_search_activity.xml, +++ b/library/src/main/java/com/bumptech/glide/manager/LifecycleRequestManager.java, +import java.util.Collections;, +import java.util.WeakHashMap;, +    // Most requests will be for views and will therefore be held strongly (and safely) by the view via the tag., +    // However, a user can always pass in a different type of target which may end up not being strongly referenced even, +    // though the user still would like the request to finish. Weak references are therefore only really functional in, +    // this context for view targets. Despite the side affects, WeakReferences are still essentially required. A user, +    // can always make repeated requests into targets other than views, or use an activity manager in a fragment pager, +    // where holding strong references would steadily leak bitmaps and/or views., +    private final Set<Request> requests = Collections.newSetFromMap(new WeakHashMap<Request, Boolean>());, +++ b/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java, +    public void testThrowsIfActivityDestroyed() {, +++ b/samples/flickr/AndroidManifest.xml, +        android:windowSoftInputMode="stateHidden|adjustResize" >, +++ b/samples/flickr/res/layout/flickr_search_activity.xml, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java, +    private static final String STATE_POSITION_INDEX = "state_position_index";, +, +    private GridView grid;, +        grid = (GridView) result.findViewById(R.id.images);, +        if (currentPhotos != null) {, +        }, +, +        if (savedInstanceState != null) {, +            int index = savedInstanceState.getInt(STATE_POSITION_INDEX);, +            grid.setSelection(index);, +        }, +    public void onSaveInstanceState(Bundle outState) {, +        super.onSaveInstanceState(outState);, +        if (grid != null) {, +            int index = grid.getFirstVisiblePosition();, +            outState.putInt(STATE_POSITION_INDEX, index);, +        }, +    }, +, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/manager/LifecycleRequestManager.java, +import java.util.Collections;, +import java.util.WeakHashMap;, +    // Most requests will be for views and will therefore be held strongly (and safely) by the view via the tag., +    // However, a user can always pass in a different type of target which may end up not being strongly referenced even, +    // though the user still would like the request to finish. Weak references are therefore only really functional in, +    // this context for view targets. Despite the side affects, WeakReferences are still essentially required. A user, +    // can always make repeated requests into targets other than views, or use an activity manager in a fragment pager, +    // where holding strong references would steadily leak bitmaps and/or views., +    private final Set<Request> requests = Collections.newSetFromMap(new WeakHashMap<Request, Boolean>());, +++ b/library/src/test/java/com/bumptech/glide/manager/RequestManagerRetrieverTest.java, +    public void testThrowsIfActivityDestroyed() {, +++ b/samples/flickr/AndroidManifest.xml]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +      if (transformations.isEmpty() && isTransformationRequired) {]
[+++ b/library/pom.xml, +      <scope>test</scope>, +      <scope>test</scope>, +      <scope>test</scope>, +++ b/library/pom.xml, +      <scope>test</scope>, +      <scope>test</scope>, +      <scope>test</scope>, +++ b/pom.xml, +  <dependencies>, +    <dependency>, +      <groupId>android</groupId>, +      <artifactId>android</artifactId>, +      <version>4.4.2_r3</version>, +      <scope>provided</scope>, +    </dependency>, +    <dependency>, +      <groupId>com.mcxiaoke.volley</groupId>, +      <artifactId>library</artifactId>, +      <version>1.0.4</version>, +    </dependency>, +  </dependencies>, +, +++ b/library/pom.xml, +      <scope>test</scope>, +      <scope>test</scope>, +      <scope>test</scope>, +++ b/pom.xml, +  <dependencies>, +    <dependency>, +      <groupId>android</groupId>, +      <artifactId>android</artifactId>, +      <version>4.4.2_r3</version>, +      <scope>provided</scope>, +    </dependency>, +    <dependency>, +      <groupId>com.mcxiaoke.volley</groupId>, +      <artifactId>library</artifactId>, +      <version>1.0.4</version>, +    </dependency>, +  </dependencies>, +, +++ b/samples/flickr/pom.xml]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java, +    protected String getUrl(Object model, int width, int height, Map<String, Object> options) {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java, +    protected String getUrl(Object model, int width, int height, Map<String, Object> options) {, +++ b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java, +      String stringURL = getUrl(model, width, height, options);, +      result = new GlideUrl(stringURL, getHeaders(model, width, height, options));, +    List<String> alternateUrls = getAlternateUrls(model, width, height, options);, +  protected abstract String getUrl(Model model, int width, int height, Map<String, Object> options);, +  protected List<String> getAlternateUrls(Model model, int width, int height,, +      Map<String, Object> options) {, +  protected Headers getHeaders(Model model, int width, int height, Map<String, Object> options) {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java, +    protected String getUrl(Object model, int width, int height, Map<String, Object> options) {, +++ b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java, +      String stringURL = getUrl(model, width, height, options);, +      result = new GlideUrl(stringURL, getHeaders(model, width, height, options));, +    List<String> alternateUrls = getAlternateUrls(model, width, height, options);, +  protected abstract String getUrl(Model model, int width, int height, Map<String, Object> options);, +  protected List<String> getAlternateUrls(Model model, int width, int height,, +      Map<String, Object> options) {, +  protected Headers getHeaders(Model model, int width, int height, Map<String, Object> options) {, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java, +import java.util.Map;, +  protected String getUrl(Photo model, int width, int height, Map<String, Object> options) {, +  protected List<String> getAlternateUrls(Photo photo, int width, int height,, +      Map<String, Object> options) {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoaderTest.java, +    protected String getUrl(Object model, int width, int height, Map<String, Object> options) {, +++ b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java, +      String stringURL = getUrl(model, width, height, options);, +      result = new GlideUrl(stringURL, getHeaders(model, width, height, options));, +    List<String> alternateUrls = getAlternateUrls(model, width, height, options);, +  protected abstract String getUrl(Model model, int width, int height, Map<String, Object> options);, +  protected List<String> getAlternateUrls(Model model, int width, int height,, +      Map<String, Object> options) {, +  protected Headers getHeaders(Model model, int width, int height, Map<String, Object> options) {, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrModelLoader.java, +import java.util.Map;, +  protected String getUrl(Photo model, int width, int height, Map<String, Object> options) {, +  protected List<String> getAlternateUrls(Photo photo, int width, int height,, +      Map<String, Object> options) {, +++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/GiphyModelLoader.java, +import java.util.Map;, +  protected String getUrl(Api.GifResult model, int width, int height, Map<String, Object> options) {]
[+++ b/library/src/main/java/com/bumptech/glide/load/Key.java, +import android.support.annotation.NonNull;, +  void updateDiskCacheKey(@NonNull MessageDigest messageDigest);, +++ b/library/src/main/java/com/bumptech/glide/load/Key.java, +import android.support.annotation.NonNull;, +  void updateDiskCacheKey(@NonNull MessageDigest messageDigest);, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/Key.java, +import android.support.annotation.NonNull;, +  void updateDiskCacheKey(@NonNull MessageDigest messageDigest);, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/Options.java, +import android.support.annotation.NonNull;, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/Key.java, +import android.support.annotation.NonNull;, +  void updateDiskCacheKey(@NonNull MessageDigest messageDigest);, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/Options.java, +import android.support.annotation.NonNull;, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java, +import android.support.annotation.NonNull;, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/Key.java, +import android.support.annotation.NonNull;, +  void updateDiskCacheKey(@NonNull MessageDigest messageDigest);, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/Options.java, +import android.support.annotation.NonNull;, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java, +import android.support.annotation.NonNull;, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java, +import android.support.annotation.NonNull;, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/Key.java, +import android.support.annotation.NonNull;, +  void updateDiskCacheKey(@NonNull MessageDigest messageDigest);, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/Options.java, +import android.support.annotation.NonNull;, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java, +import android.support.annotation.NonNull;, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java, +import android.support.annotation.NonNull;, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java, +import android.support.annotation.NonNull;, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/Key.java, +import android.support.annotation.NonNull;, +  void updateDiskCacheKey(@NonNull MessageDigest messageDigest);, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/Options.java, +import android.support.annotation.NonNull;, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java, +import android.support.annotation.NonNull;, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java, +import android.support.annotation.NonNull;, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java, +import android.support.annotation.NonNull;, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java, +import android.support.annotation.NonNull;, +    public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/Key.java, +import android.support.annotation.NonNull;, +  void updateDiskCacheKey(@NonNull MessageDigest messageDigest);, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/Options.java, +import android.support.annotation.NonNull;, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheKey.java, +import android.support.annotation.NonNull;, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java, +import android.support.annotation.NonNull;, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheKey.java, +import android.support.annotation.NonNull;, +  public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunner.java, +import android.support.annotation.NonNull;, +    public void updateDiskCacheKey(@NonNull MessageDigest messageDigest) {, +++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java, +import android.support.annotation.NonNull;]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java, +  private static final String VISIBLE_FOR_TESTING_QUALIFIED_NAME_ANDROIDX =, +      "androidx.annotation.VisibleForTesting";, +, +    Elements elements = processingEnv.getElementUtils();, +    TypeElement visibleForTestingTypeElement = elements, +        .getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME_ANDROIDX);, +    if (visibleForTestingTypeElement == null) {, +      // Fall back to looking for the Support library version., +      visibleForTestingTypeElement = elements.getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME);, +    }, +    String visibleForTestingTypeQualifiedName = visibleForTestingTypeElement.toString();, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java, +  private static final String VISIBLE_FOR_TESTING_QUALIFIED_NAME_ANDROIDX =, +      "androidx.annotation.VisibleForTesting";, +, +    Elements elements = processingEnv.getElementUtils();, +    TypeElement visibleForTestingTypeElement = elements, +        .getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME_ANDROIDX);, +    if (visibleForTestingTypeElement == null) {, +      // Fall back to looking for the Support library version., +      visibleForTestingTypeElement = elements.getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME);, +    }, +    String visibleForTestingTypeQualifiedName = visibleForTestingTypeElement.toString();, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +  private static final ClassName ANDROIDX_NONNULL_ANNOTATION =, +      ClassName.get("androidx.annotation", "NonNull");, +  private static final ClassName CHECK_RESULT_ANNOTATION =, +      ClassName.get("android.support.annotation", "CheckResult");, +  private static final ClassName ANDROIDX_CHECK_RESULT_ANNOTATION =, +      ClassName.get("androidx.annotation", "CheckResult");, +    try {, +      Class.forName(ANDROIDX_NONNULL_ANNOTATION.reflectionName());, +      return ANDROIDX_NONNULL_ANNOTATION;, +    } catch (ClassNotFoundException e) {, +  }, +, +  static ClassName checkResult() {, +    try {, +      Class.forName(ANDROIDX_CHECK_RESULT_ANNOTATION.reflectionName());, +      return ANDROIDX_CHECK_RESULT_ANNOTATION;, +    } catch (ClassNotFoundException e) {, +      return CHECK_RESULT_ANNOTATION;, +    }, +  }, +    return Arrays.asList(NONNULL_ANNOTATION, JETBRAINS_NOTNULL_ANNOTATION,, +        ANDROIDX_NONNULL_ANNOTATION);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java, +  private static final String VISIBLE_FOR_TESTING_QUALIFIED_NAME_ANDROIDX =, +      "androidx.annotation.VisibleForTesting";, +, +    Elements elements = processingEnv.getElementUtils();, +    TypeElement visibleForTestingTypeElement = elements, +        .getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME_ANDROIDX);, +    if (visibleForTestingTypeElement == null) {, +      // Fall back to looking for the Support library version., +      visibleForTestingTypeElement = elements.getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME);, +    }, +    String visibleForTestingTypeQualifiedName = visibleForTestingTypeElement.toString();, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +  private static final ClassName ANDROIDX_NONNULL_ANNOTATION =, +      ClassName.get("androidx.annotation", "NonNull");, +  private static final ClassName CHECK_RESULT_ANNOTATION =, +      ClassName.get("android.support.annotation", "CheckResult");, +  private static final ClassName ANDROIDX_CHECK_RESULT_ANNOTATION =, +      ClassName.get("androidx.annotation", "CheckResult");, +    try {, +      Class.forName(ANDROIDX_NONNULL_ANNOTATION.reflectionName());, +      return ANDROIDX_NONNULL_ANNOTATION;, +    } catch (ClassNotFoundException e) {, +  }, +, +  static ClassName checkResult() {, +    try {, +      Class.forName(ANDROIDX_CHECK_RESULT_ANNOTATION.reflectionName());, +      return ANDROIDX_CHECK_RESULT_ANNOTATION;, +    } catch (ClassNotFoundException e) {, +      return CHECK_RESULT_ANNOTATION;, +    }, +  }, +    return Arrays.asList(NONNULL_ANNOTATION, JETBRAINS_NOTNULL_ANNOTATION,, +        ANDROIDX_NONNULL_ANNOTATION);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +import static com.bumptech.glide.annotation.compiler.ProcessorUtil.checkResult;, +  private static final AnnotationSpec CHECK_RESULT = AnnotationSpec.builder(checkResult()).build();, +        .addAnnotation(CHECK_RESULT), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java, +  private static final String VISIBLE_FOR_TESTING_QUALIFIED_NAME_ANDROIDX =, +      "androidx.annotation.VisibleForTesting";, +, +    Elements elements = processingEnv.getElementUtils();, +    TypeElement visibleForTestingTypeElement = elements, +        .getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME_ANDROIDX);, +    if (visibleForTestingTypeElement == null) {, +      // Fall back to looking for the Support library version., +      visibleForTestingTypeElement = elements.getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME);, +    }, +    String visibleForTestingTypeQualifiedName = visibleForTestingTypeElement.toString();, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +  private static final ClassName ANDROIDX_NONNULL_ANNOTATION =]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +  @SuppressWarnings({"unchecked", "deprecation", "TryWithIdenticalCatches"}), +      // These exceptions can't be squashed across all versions of Android., +  @SuppressWarnings("unused") // Public API]
[+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java, +    // clear all pixels when meet first frame and drop prev image from last loop, +      if (previousImage != null) {, +        bitmapProvider.release(previousImage);, +      }, +      previousImage = null;, +      Arrays.fill(dest, COLOR_TRANSPARENT_BLACK);, +    }, +, +    // clear all pixels when dispose is 3 but previousImage is null., +    // When DISPOSAL_PREVIOUS and previousImage didn't be set, new frame should draw on, +    // a empty image, +    if (previousFrame != null && previousFrame.dispose == DISPOSAL_PREVIOUS, +            && previousImage == null) {]
[+++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java, +import android.support.annotation.NonNull;, +  public void registerComponents(@NonNull Context context, @NonNull Glide glide,, +      @NonNull Registry registry) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java, +import android.support.annotation.NonNull;, +  public void registerComponents(@NonNull Context context, @NonNull Glide glide,, +      @NonNull Registry registry) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +  public void onResponse(@NonNull Call call, @NonNull Response response) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java, +import android.support.annotation.NonNull;, +  public void registerComponents(@NonNull Context context, @NonNull Glide glide,, +      @NonNull Registry registry) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +  public void onResponse(@NonNull Call call, @NonNull Response response) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java, +import android.support.annotation.NonNull;, +  public OkHttpUrlLoader(@NonNull Call.Factory client) {, +  public boolean handles(@NonNull GlideUrl url) {, +  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl model, int width, int height,, +      @NonNull Options options) {, +    public Factory(@NonNull Call.Factory client) {, +    @NonNull, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java, +import android.support.annotation.NonNull;, +  public void registerComponents(@NonNull Context context, @NonNull Glide glide,, +      @NonNull Registry registry) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +  public void onResponse(@NonNull Call call, @NonNull Response response) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java, +import android.support.annotation.NonNull;, +  public OkHttpUrlLoader(@NonNull Call.Factory client) {, +  public boolean handles(@NonNull GlideUrl url) {, +  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl model, int width, int height,, +      @NonNull Options options) {, +    public Factory(@NonNull Call.Factory client) {, +    @NonNull, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java, +import android.support.annotation.NonNull;, +  public void registerComponents(@NonNull Context context, @NonNull Glide glide,, +      @NonNull Registry registry) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java, +import android.support.annotation.NonNull;, +  public void registerComponents(@NonNull Context context, @NonNull Glide glide,, +      @NonNull Registry registry) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +  public void onResponse(@NonNull Call call, @NonNull Response response) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java, +import android.support.annotation.NonNull;, +  public OkHttpUrlLoader(@NonNull Call.Factory client) {, +  public boolean handles(@NonNull GlideUrl url) {, +  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl model, int width, int height,, +      @NonNull Options options) {, +    public Factory(@NonNull Call.Factory client) {, +    @NonNull, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java, +import android.support.annotation.NonNull;, +  public void registerComponents(@NonNull Context context, @NonNull Glide glide,, +      @NonNull Registry registry) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java, +import android.support.annotation.NonNull;, +  public boolean handles(@NonNull GlideUrl url) {, +  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl url, int width, int height,, +      @NonNull Options options) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java, +import android.support.annotation.NonNull;, +  public void registerComponents(@NonNull Context context, @NonNull Glide glide,, +      @NonNull Registry registry) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +  public void onResponse(@NonNull Call call, @NonNull Response response) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java, +import android.support.annotation.NonNull;, +  public OkHttpUrlLoader(@NonNull Call.Factory client) {, +  public boolean handles(@NonNull GlideUrl url) {, +  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl model, int width, int height,, +      @NonNull Options options) {, +    public Factory(@NonNull Call.Factory client) {, +    @NonNull, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyLibraryGlideModule.java, +import android.support.annotation.NonNull;, +  public void registerComponents(@NonNull Context context, @NonNull Glide glide,, +      @NonNull Registry registry) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java, +import android.support.annotation.NonNull;, +  public boolean handles(@NonNull GlideUrl url) {, +  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl url, int width, int height,, +      @NonNull Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/model/AssetUriLoader.java, +import android.support.annotation.NonNull;, +  public LoadData<Data> buildLoadData(@NonNull Uri model, int width, int height,, +      @NonNull Options options) {, +  public boolean handles(@NonNull Uri model) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpLibraryGlideModule.java, +import android.support.annotation.NonNull;, +  public void registerComponents(@NonNull Context context, @NonNull Glide glide,, +      @NonNull Registry registry) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +  public void onResponse(@NonNull Call call, @NonNull Response response) {, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpUrlLoader.java]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.engine.cache.DiskLruCacheFactory;, +        return getPhotoCacheDir(context, DiskLruCacheFactory.DEFAULT_DISK_CACHE_DIR);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.engine.cache.DiskLruCacheFactory;, +        return getPhotoCacheDir(context, DiskLruCacheFactory.DEFAULT_DISK_CACHE_DIR);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +            diskCacheFactory = new InternalCacheDiskCacheFactory(context);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.engine.cache.DiskLruCacheFactory;, +        return getPhotoCacheDir(context, DiskLruCacheFactory.DEFAULT_DISK_CACHE_DIR);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +            diskCacheFactory = new InternalCacheDiskCacheFactory(context);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java, +, +        /** 250 MB of cache. */, +        int DEFAULT_DISK_CACHE_SIZE = 250 * 1024 * 1024;, +        String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";, +, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.engine.cache.DiskLruCacheFactory;, +        return getPhotoCacheDir(context, DiskLruCacheFactory.DEFAULT_DISK_CACHE_DIR);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +            diskCacheFactory = new InternalCacheDiskCacheFactory(context);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java, +, +        /** 250 MB of cache. */, +        int DEFAULT_DISK_CACHE_SIZE = 250 * 1024 * 1024;, +        String DEFAULT_DISK_CACHE_DIR = "image_manager_disk_cache";, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java, +package com.bumptech.glide.load.engine.cache;, +, +import java.io.File;, +, +/**, + * Creates an {@link com.bumptech.glide.disklrucache.DiskLruCache} based disk cache in the specified disk cache, + * directory., + * <p/>, + * If you need to make I/O access before returning the cache directory use, + * the {@link DiskLruCacheFactory#DiskLruCacheFactory(CacheDirectoryGetter, int)} constructor variant., + */, +public class DiskLruCacheFactory implements DiskCache.Factory {, +, +    private final int diskCacheSize;, +    private final CacheDirectoryGetter cacheDirectoryGetter;, +, +    /**, +     * Interface called out of UI thread to get the cache folder., +     */, +    public interface CacheDirectoryGetter {, +        File getCacheDirectory();, +    }, +, +    public DiskLruCacheFactory(final String diskCacheFolder, int diskCacheSize) {, +        this(new CacheDirectoryGetter() {, +            @Override, +            public File getCacheDirectory() {, +                return new File(diskCacheFolder);, +            }, +        }, diskCacheSize);, +    }, +, +    public DiskLruCacheFactory(final String diskCacheFolder, final String diskCacheName, int diskCacheSize) {, +        this(new CacheDirectoryGetter() {, +            @Override, +            public File getCacheDirectory() {, +                return new File(diskCacheFolder, diskCacheName);, +            }, +        }, diskCacheSize);, +    }, +, +    /**, +     * When using this constructor {@link CacheDirectoryGetter#getCacheDirectory()} will be called out of UI thread,, +     * allowing to do I/O access without performance impacts., +     *, +     * @param cacheDirectoryGetter Interface called out of UI thread to get the cache folder., +     * @param diskCacheSize        Desired max bytes size for the LRU disk cache., +     */, +    public DiskLruCacheFactory(CacheDirectoryGetter cacheDirectoryGetter, int diskCacheSize) {, +        this.diskCacheSize = diskCacheSize;, +        this.cacheDirectoryGetter = cacheDirectoryGetter;, +    }, +, +    @Override, +    public DiskCache build() {, +        File cacheDir = cacheDirectoryGetter.getCacheDirectory();, +, +        if (cacheDir == null) {, +            return null;, +        }, +, +        if (!cacheDir.mkdirs() && (!cacheDir.exists() || !cacheDir.isDirectory())) {, +            return null;, +        }, +, +        return DiskLruCacheWrapper.get(cacheDir, diskCacheSize);, +    }, +}, +++ b/library/src/main/java/com/bumptech/glide/Glide.java]
[+++ b/.idea/codeStyleSettings.xml, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MAJOR=3, +VERSION_MINOR=6, +SUPPORT_V4_VERSION=19.1.0, +SUPPORT_V7_VERSION=19.1.0, +# TODO: Upgrade to latest version of Volley when we compile with Java 7., +VOLLEY_VERSION=1.0.8, +ANDROID_GRADLE_VERSION=1.0.0, +ROBOLECTRIC_GRADLE_VERSION=0.14.0, +ROBOLECTRIC_VERSION=2.4, +MOCKWEBSERVER_VERSION=1.6.0, +COMPILE_SDK_VERSION=19, +BUILD_TOOLS_VERSION=19.1.0, +TARGET_SDK_VERSION=19, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java, +import com.bumptech.glide.load.resource.bitmap.Downsampler;, +  // TODO: Even with hardware allowed, we get a wide F16. Attempting to decode the resource with, +  // preferred config set to hardware fails with:, +  // "D/skia    (10312): --- Failed to allocate a hardware bitmap", +  public void load_withWideGamutImage_hardwareAllowed_returnsDecodedBitmap() {, +                .set(Downsampler.ALLOW_HARDWARE_CONFIG, true), +    assertThat(bitmap).isNotNull();]
[+++ b/gradle.properties, +ROBOLECTRIC_VERSION=3.3.2]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CircleCropRegressionTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CircleCropRegressionTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DataUriTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsBytesTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/AsFileTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterCropRegressionTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CenterInsideRegressionTest.java, +import androidx.test.InstrumentationRegistry;, +import androidx.test.runner.AndroidJUnit4;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CircleCropRegressionTest.java]
[+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +      engine =, +          new Engine(, +              memoryCache,, +              diskCacheFactory,, +              diskCacheExecutor,, +              sourceExecutor,, +              GlideExecutor.newUnlimitedSourceExecutor(),, +              GlideExecutor.newAnimationExecutor());, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +      engine =, +          new Engine(, +              memoryCache,, +              diskCacheFactory,, +              diskCacheExecutor,, +              sourceExecutor,, +              GlideExecutor.newUnlimitedSourceExecutor(),, +              GlideExecutor.newAnimationExecutor());, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +      GlideExecutor sourceUnlimitedExecutor,, +      GlideExecutor animationExecutor) {, +    this(, +        memoryCache,, +        diskCacheFactory,, +        diskCacheExecutor,, +        sourceExecutor,, +        sourceUnlimitedExecutor,, +        animationExecutor,, +        /*jobs=*/ null,, +        /*keyFactory=*/ null,, +        /*activeResources=*/ null,, +        /*engineJobFactory=*/ null,, +        /*decodeJobFactory=*/ null,, +        /*resourceRecycler=*/ null);, +      GlideExecutor animationExecutor,, +      engineJobFactory =, +          new EngineJobFactory(, +              diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor, animationExecutor, this);, +      boolean useAnimationPool,, +        useUnlimitedSourceExecutorPool, useAnimationPool);, +    @Synthetic final GlideExecutor animationExecutor;, +            return new EngineJob<Object>(, +                diskCacheExecutor,, +                sourceExecutor,, +                sourceUnlimitedExecutor,, +                animationExecutor,, +                listener,, +                pool);, +    EngineJobFactory(, +        GlideExecutor diskCacheExecutor,, +        GlideExecutor sourceExecutor,, +        GlideExecutor sourceUnlimitedExecutor,, +        GlideExecutor animationExecutor,, +        EngineJobListener listener) {, +      this.animationExecutor = animationExecutor;, +        boolean useUnlimitedSourceGeneratorPool, boolean isAnimation) {, +      return result.init(key, isMemoryCacheable, useUnlimitedSourceGeneratorPool, isAnimation);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +      engine =, +          new Engine(, +              memoryCache,, +              diskCacheFactory,, +              diskCacheExecutor,, +              sourceExecutor,, +              GlideExecutor.newUnlimitedSourceExecutor(),, +              GlideExecutor.newAnimationExecutor());, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +      GlideExecutor sourceUnlimitedExecutor,, +      GlideExecutor animationExecutor) {, +    this(, +        memoryCache,, +        diskCacheFactory,, +        diskCacheExecutor,, +        sourceExecutor,, +        sourceUnlimitedExecutor,, +        animationExecutor,, +        /*jobs=*/ null,, +        /*keyFactory=*/ null,, +        /*activeResources=*/ null,, +        /*engineJobFactory=*/ null,, +        /*decodeJobFactory=*/ null,, +        /*resourceRecycler=*/ null);, +      GlideExecutor animationExecutor,, +      engineJobFactory =, +          new EngineJobFactory(, +              diskCacheExecutor, sourceExecutor, sourceUnlimitedExecutor, animationExecutor, this);, +      boolean useAnimationPool,, +        useUnlimitedSourceExecutorPool, useAnimationPool);, +    @Synthetic final GlideExecutor animationExecutor;, +            return new EngineJob<Object>(, +                diskCacheExecutor,, +                sourceExecutor,, +                sourceUnlimitedExecutor,, +                animationExecutor,, +                listener,, +                pool);, +    EngineJobFactory(, +        GlideExecutor diskCacheExecutor,, +        GlideExecutor sourceExecutor,, +        GlideExecutor sourceUnlimitedExecutor,]
[+++ b/.travis.yml, +, +after_success:, +- ./gradlew uploadGlideArchives -PNEXUS_USERNAME="${NEXUS_USERNAME}" -PNEXUS_PASSWORD="${NEXUS_PASSWORD}", +, +env:, +  global:, +  - secure: m/sb1iqIHzL/xCANDf0PHBRtX4ihiccFFWsMWby5PiGDh5ncItjI+kU+Yrgdy/PwmSwwTfB5nXzCdcJe8nLADSLF5PPccuKKO63mGH/Vsai0SJt94+wr+JnBS+T1LmTrlvtlRFEcKjFhOQsnAeJL30iNtQWsoqNSgVrYqUaBdAM=, +  - secure: dMBw5H/o1VsmFX9vama8KWpS3ZbwSgVeNdwByfBgZz82ad1AkYPFN2QNt02qZsopeHCs3w91J1+2ULkEcGpi/eCjRNV449uQyx1DXB0pGkiGq9OAgeZhO/HiRAPqqzJRC4gxgOHBvfxaKm6ZD8THfExWJKTQfXrwFrh+9R4cL3g=]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        .register(InputStream.class, new StreamEncoder(arrayPool)), +            new StreamBitmapDecoder(downsampler, arrayPool)), +                new StreamBitmapDecoder(downsampler, arrayPool))), +            new StreamGifDecoder(byteBufferGifDecoder, arrayPool)), +        .register(new InputStreamRewinder.Factory(arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        .register(InputStream.class, new StreamEncoder(arrayPool)), +            new StreamBitmapDecoder(downsampler, arrayPool)), +                new StreamBitmapDecoder(downsampler, arrayPool))), +            new StreamGifDecoder(byteBufferGifDecoder, arrayPool)), +        .register(new InputStreamRewinder.Factory(arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +  InputStreamRewinder(InputStream is, ArrayPool byteArrayPool) {, +    private final ArrayPool byteArrayPool;, +    public Factory(ArrayPool byteArrayPool) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        .register(InputStream.class, new StreamEncoder(arrayPool)), +            new StreamBitmapDecoder(downsampler, arrayPool)), +                new StreamBitmapDecoder(downsampler, arrayPool))), +            new StreamGifDecoder(byteBufferGifDecoder, arrayPool)), +        .register(new InputStreamRewinder.Factory(arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +  InputStreamRewinder(InputStream is, ArrayPool byteArrayPool) {, +    private final ArrayPool byteArrayPool;, +    public Factory(ArrayPool byteArrayPool) {, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +    ArrayPool byteArrayPool = Glide.get(context).getArrayPool();, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        .register(InputStream.class, new StreamEncoder(arrayPool)), +            new StreamBitmapDecoder(downsampler, arrayPool)), +                new StreamBitmapDecoder(downsampler, arrayPool))), +            new StreamGifDecoder(byteBufferGifDecoder, arrayPool)), +        .register(new InputStreamRewinder.Factory(arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +  InputStreamRewinder(InputStream is, ArrayPool byteArrayPool) {, +    private final ArrayPool byteArrayPool;, +    public Factory(ArrayPool byteArrayPool) {, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +    ArrayPool byteArrayPool = Glide.get(context).getArrayPool();, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +  private final ArrayPool byteArrayPool;, +  public ThumbnailStreamOpener(ThumbnailQuery query, ArrayPool byteArrayPool) {, +      ArrayPool byteArrayPool) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        .register(InputStream.class, new StreamEncoder(arrayPool)), +            new StreamBitmapDecoder(downsampler, arrayPool)), +                new StreamBitmapDecoder(downsampler, arrayPool))), +            new StreamGifDecoder(byteBufferGifDecoder, arrayPool)), +        .register(new InputStreamRewinder.Factory(arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +  InputStreamRewinder(InputStream is, ArrayPool byteArrayPool) {, +    private final ArrayPool byteArrayPool;, +    public Factory(ArrayPool byteArrayPool) {, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +    ArrayPool byteArrayPool = Glide.get(context).getArrayPool();, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +  private final ArrayPool byteArrayPool;, +  public ThumbnailStreamOpener(ThumbnailQuery query, ArrayPool byteArrayPool) {, +      ArrayPool byteArrayPool) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/ArrayPool.java, +   * A standard size to use to increase hit rates when the required size isn't defined., +   * Currently 64KB., +   */, +  int STANDARD_BUFFER_SIZE_BYTES = 64 * 1024;, +, +  /**, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        .register(InputStream.class, new StreamEncoder(arrayPool)), +            new StreamBitmapDecoder(downsampler, arrayPool)), +                new StreamBitmapDecoder(downsampler, arrayPool))), +            new StreamGifDecoder(byteBufferGifDecoder, arrayPool)), +        .register(new InputStreamRewinder.Factory(arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/load/data/InputStreamRewinder.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +  InputStreamRewinder(InputStream is, ArrayPool byteArrayPool) {, +    private final ArrayPool byteArrayPool;, +    public Factory(ArrayPool byteArrayPool) {, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +    ArrayPool byteArrayPool = Glide.get(context).getArrayPool();, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +  private final ArrayPool byteArrayPool;, +  public ThumbnailStreamOpener(ThumbnailQuery query, ArrayPool byteArrayPool) {]
[+++ b/.idea/codeStyleSettings.xml, +          <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />, +++ b/.idea/codeStyleSettings.xml, +          <option name="ALIGN_MULTILINE_PARAMETERS" value="false" />, +++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java, +      throw new HttpException("Too many (> " + MAXIMUM_REDIRECTS + ") redirects!");, +          throw new HttpException("In re-direct loop");, +        throw new HttpException("Received empty or null redirect url");, +    } else if (statusCode == -1) {, +      throw new HttpException(statusCode);, +      throw new HttpException(urlConnection.getResponseMessage(), statusCode);, +  /**, +   * Thrown when an http request fails., +   *, +   * <p>Exposes the specific status code or {@link #UNKNOWN} via {@link #getStatusCode()} so, +   * users may attempt to retry certain types of errors., +   */, +  public static final class HttpException extends IOException {, +    public static final int UNKNOWN = -1;, +    private int statusCode;, +, +    HttpException(int statusCode) {, +      this("Http request failed with status code: " + statusCode, statusCode);, +    }, +, +    HttpException(String message) {, +      this(message, UNKNOWN);, +    }, +, +    HttpException(String message, int statusCode) {, +      super(message);, +      this.statusCode = statusCode;, +    }, +, +    public int getStatusCode() {, +      return statusCode;, +    }, +  }, +]
[+++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.GlideUrl;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamUrlLoader;, +        register(URL.class, InputStream.class, new StreamUrlLoader.Factory());, +        register(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(requestQueue));, +, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.GlideUrl;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamUrlLoader;, +        register(URL.class, InputStream.class, new StreamUrlLoader.Factory());, +        register(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(requestQueue));, +, +++ b/library/src/com/bumptech/glide/loader/GlideUrl.java, +package com.bumptech.glide.loader;, +, +import java.net.MalformedURLException;, +import java.net.URL;, +, +/**, + * This is a simple wrapper for strings representing http/https urls. new URL() is an excessively expensive operation, + * that may be unnecessary if the class loading the image from the url doesn't actually require a URL object., + *, + * Users wishing to replace the class for handling urls must register a factory using GlideUrl., + */, +public class GlideUrl {, +    private final String stringUrl;, +    private final URL url;, +, +    public GlideUrl(URL url) {, +        this.url = url;, +        stringUrl = null;, +    }, +, +    public GlideUrl(String url) {, +        this.stringUrl = url;, +        this.url = null;, +    }, +, +    public URL toURL() throws MalformedURLException {, +        return url != null ? url : new URL(stringUrl);, +    }, +, +    @Override, +    public String toString() {, +        return url != null ? url.toString() : stringUrl;, +    }, +, +    @Override, +    public boolean equals(Object o) {, +        if (this == o) {, +            return true;, +        }, +        if (o == null || getClass() != o.getClass()) {, +            return false;, +        }, +, +        GlideUrl glideUrl = (GlideUrl) o;, +        if (stringUrl != null) {, +            if (glideUrl.stringUrl != null) {, +                return stringUrl.equals(glideUrl.stringUrl);, +            } else {, +                return stringUrl.equals(glideUrl.url.toString());, +            }, +        } else {, +            if (glideUrl.stringUrl != null) {, +                return url.toString().equals(glideUrl.stringUrl);, +            } else {, +                return url.equals(glideUrl.url);, +            }, +        }, +    }, +, +    @Override, +    public int hashCode() {, +        if (stringUrl != null) {, +            return stringUrl.hashCode();, +        } else {, +            return url.toString().hashCode();, +        }, +    }, +}, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.GlideUrl;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamUrlLoader;, +        register(URL.class, InputStream.class, new StreamUrlLoader.Factory());, +        register(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(requestQueue));, +, +++ b/library/src/com/bumptech/glide/loader/GlideUrl.java, +package com.bumptech.glide.loader;, +, +import java.net.MalformedURLException;, +import java.net.URL;, +, +/**, + * This is a simple wrapper for strings representing http/https urls. new URL() is an excessively expensive operation, + * that may be unnecessary if the class loading the image from the url doesn't actually require a URL object., + *, + * Users wishing to replace the class for handling urls must register a factory using GlideUrl., + */, +public class GlideUrl {]
[+++ /dev/null, +++ /dev/null, +++ /dev/null]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/ResourceRunnerTest.java, +import java.util.concurrent.RejectedExecutionException;, +import static org.junit.Assert.assertEquals;, +        when(harness.cacheLoader.load(any(Key.class), any(ResourceDecoder.class), anyInt(), anyInt())), +                .thenThrow(new RuntimeException("Test"));, +, +        when(harness.tranformation.transform(any(Resource.class), anyInt(), anyInt())), +                .thenThrow(new RuntimeException("test"));, +        when(harness.transcoder.transcode(any(Resource.class))).thenThrow(new RuntimeException("test"));, +        Exception exception = new RejectedExecutionException("test");, +        when(harness.resizeService.submit(any(Runnable.class))).thenThrow(exception);, +, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/ResourceRunnerTest.java, +import java.util.concurrent.RejectedExecutionException;, +import static org.junit.Assert.assertEquals;, +        when(harness.cacheLoader.load(any(Key.class), any(ResourceDecoder.class), anyInt(), anyInt())), +                .thenThrow(new RuntimeException("Test"));, +, +        when(harness.tranformation.transform(any(Resource.class), anyInt(), anyInt())), +                .thenThrow(new RuntimeException("test"));, +        when(harness.transcoder.transcode(any(Resource.class))).thenThrow(new RuntimeException("test"));, +        Exception exception = new RejectedExecutionException("test");, +        when(harness.resizeService.submit(any(Runnable.class))).thenThrow(exception);, +, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java, +import static org.junit.Assert.fail;, +        when(parser.parseHeader()).thenThrow(new RuntimeException("Test"));, +            fail("Expected exception is not thrown.");, +        } catch (RuntimeException e) {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/ResourceRunnerTest.java, +import java.util.concurrent.RejectedExecutionException;, +import static org.junit.Assert.assertEquals;, +        when(harness.cacheLoader.load(any(Key.class), any(ResourceDecoder.class), anyInt(), anyInt())), +                .thenThrow(new RuntimeException("Test"));, +, +        when(harness.tranformation.transform(any(Resource.class), anyInt(), anyInt())), +                .thenThrow(new RuntimeException("test"));, +        when(harness.transcoder.transcode(any(Resource.class))).thenThrow(new RuntimeException("test"));, +        Exception exception = new RejectedExecutionException("test");, +        when(harness.resizeService.submit(any(Runnable.class))).thenThrow(exception);, +, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java, +import static org.junit.Assert.fail;, +        when(parser.parseHeader()).thenThrow(new RuntimeException("Test"));, +            fail("Expected exception is not thrown.");, +        } catch (RuntimeException e) {, +++ b/library/src/main/java/com/bumptech/glide/load/data/ByteArrayFetcher.java, +    public InputStream loadData(Priority priority) {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/ResourceRunnerTest.java, +import java.util.concurrent.RejectedExecutionException;, +import static org.junit.Assert.assertEquals;, +        when(harness.cacheLoader.load(any(Key.class), any(ResourceDecoder.class), anyInt(), anyInt())), +                .thenThrow(new RuntimeException("Test"));, +, +        when(harness.tranformation.transform(any(Resource.class), anyInt(), anyInt())), +                .thenThrow(new RuntimeException("test"));, +        when(harness.transcoder.transcode(any(Resource.class))).thenThrow(new RuntimeException("test"));, +        Exception exception = new RejectedExecutionException("test");, +        when(harness.resizeService.submit(any(Runnable.class))).thenThrow(exception);, +, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java, +import static org.junit.Assert.fail;, +        when(parser.parseHeader()).thenThrow(new RuntimeException("Test"));, +            fail("Expected exception is not thrown.");, +        } catch (RuntimeException e) {, +++ b/library/src/main/java/com/bumptech/glide/load/data/ByteArrayFetcher.java, +    public InputStream loadData(Priority priority) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRunner.java, +    private Resource<R> runWrapped() {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/ResourceRunnerTest.java, +import java.util.concurrent.RejectedExecutionException;, +import static org.junit.Assert.assertEquals;, +        when(harness.cacheLoader.load(any(Key.class), any(ResourceDecoder.class), anyInt(), anyInt())), +                .thenThrow(new RuntimeException("Test"));, +, +        when(harness.tranformation.transform(any(Resource.class), anyInt(), anyInt())), +                .thenThrow(new RuntimeException("test"));, +        when(harness.transcoder.transcode(any(Resource.class))).thenThrow(new RuntimeException("test"));, +        Exception exception = new RejectedExecutionException("test");, +        when(harness.resizeService.submit(any(Runnable.class))).thenThrow(exception);, +, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java, +import static org.junit.Assert.fail;, +        when(parser.parseHeader()).thenThrow(new RuntimeException("Test"));, +            fail("Expected exception is not thrown.");, +        } catch (RuntimeException e) {, +++ b/library/src/main/java/com/bumptech/glide/load/data/ByteArrayFetcher.java, +    public InputStream loadData(Priority priority) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRunner.java, +    private Resource<R> runWrapped() {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/NullDecoder.java, +    public Resource<Z> decode(T source, int width, int height) {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/ResourceRunnerTest.java, +import java.util.concurrent.RejectedExecutionException;, +import static org.junit.Assert.assertEquals;]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java, +    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory factory) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java, +    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory factory) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    final Resources resources = context.getResources();, +        .append(int.class, InputStream.class, new ResourceLoader.StreamFactory(resources)), +        .append(, +                int.class,, +                ParcelFileDescriptor.class,, +                new ResourceLoader.FileDescriptorFactory(resources)), +        .append(Integer.class, InputStream.class, new ResourceLoader.StreamFactory(resources)), +        .append(, +                Integer.class,, +                ParcelFileDescriptor.class,, +                new ResourceLoader.FileDescriptorFactory(resources)), +        .append(Uri.class, InputStream.class, new AssetUriLoader.StreamFactory(context.getAssets())), +        .append(, +                Uri.class,, +                ParcelFileDescriptor.class,, +                new AssetUriLoader.FileDescriptorFactory(context.getAssets())), +        .append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory(context)), +        .append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory(context)), +        .append(, +            Uri.class,, +             InputStream.class,, +             new UriLoader.StreamFactory(context.getContentResolver())), +        .append(Uri.class, ParcelFileDescriptor.class,, +             new UriLoader.FileDescriptorFactory(context.getContentResolver())), +        .append(Uri.class, File.class, new MediaStoreFileLoader.Factory(context)), +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java, +    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory factory) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    final Resources resources = context.getResources();, +        .append(int.class, InputStream.class, new ResourceLoader.StreamFactory(resources)), +        .append(, +                int.class,, +                ParcelFileDescriptor.class,, +                new ResourceLoader.FileDescriptorFactory(resources)), +        .append(Integer.class, InputStream.class, new ResourceLoader.StreamFactory(resources)), +        .append(, +                Integer.class,, +                ParcelFileDescriptor.class,, +                new ResourceLoader.FileDescriptorFactory(resources)), +        .append(Uri.class, InputStream.class, new AssetUriLoader.StreamFactory(context.getAssets())), +        .append(, +                Uri.class,, +                ParcelFileDescriptor.class,, +                new AssetUriLoader.FileDescriptorFactory(context.getAssets())), +        .append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory(context)), +        .append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory(context)), +        .append(, +            Uri.class,, +             InputStream.class,, +             new UriLoader.StreamFactory(context.getContentResolver())), +        .append(Uri.class, ParcelFileDescriptor.class,, +             new UriLoader.FileDescriptorFactory(context.getContentResolver())), +        .append(Uri.class, File.class, new MediaStoreFileLoader.Factory(context)), +++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java, +  public FileDescriptorLocalUriFetcher(ContentResolver contentResolver, Uri uri) {, +    super(contentResolver, uri);, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory multiFactory) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java, +    public ModelLoader<GlideUrl, InputStream> build(MultiModelLoaderFactory factory) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    final Resources resources = context.getResources();, +        .append(int.class, InputStream.class, new ResourceLoader.StreamFactory(resources)), +        .append(, +                int.class,, +                ParcelFileDescriptor.class,, +                new ResourceLoader.FileDescriptorFactory(resources)), +        .append(Integer.class, InputStream.class, new ResourceLoader.StreamFactory(resources)), +        .append(, +                Integer.class,, +                ParcelFileDescriptor.class,, +                new ResourceLoader.FileDescriptorFactory(resources)), +        .append(Uri.class, InputStream.class, new AssetUriLoader.StreamFactory(context.getAssets())), +        .append(, +                Uri.class,, +                ParcelFileDescriptor.class,, +                new AssetUriLoader.FileDescriptorFactory(context.getAssets())), +        .append(Uri.class, InputStream.class, new MediaStoreImageThumbLoader.Factory(context)), +        .append(Uri.class, InputStream.class, new MediaStoreVideoThumbLoader.Factory(context)), +        .append(, +            Uri.class,, +             InputStream.class,, +             new UriLoader.StreamFactory(context.getContentResolver())), +        .append(Uri.class, ParcelFileDescriptor.class,, +             new UriLoader.FileDescriptorFactory(context.getContentResolver())), +        .append(Uri.class, File.class, new MediaStoreFileLoader.Factory(context)), +++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java, +import android.support.annotation.Nullable;, +, +  @Nullable, +  @Nullable, +    @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java, +import android.support.annotation.Nullable;, +, +  @Nullable, +  @Nullable, +    @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java, +import android.support.annotation.Nullable;, +, +  @Nullable, +  @Nullable, +    @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruPoolStrategy.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/GroupedLinkedMap.java, +import android.support.annotation.Nullable;, +, +  @Nullable, +  @Nullable, +    @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruPoolStrategy.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeConfigStrategy.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java, +import android.support.annotation.Nullable;, +  @Nullable, +  @Nullable]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +      maxLoopCount = state.frameLoader.getLoopCount();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +      maxLoopCount = state.frameLoader.getLoopCount();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java, +    return gifDecoder.getLoopCount();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +      maxLoopCount = state.frameLoader.getLoopCount();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java, +    return gifDecoder.getLoopCount();, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +      maxLoopCount = state.frameLoader.getLoopCount();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java, +    return gifDecoder.getLoopCount();, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +    assertFalse(drawable.isRunning());, +    assertFalse(drawable.isRunning());, +    assertFalse(drawable.isRunning());, +    assertFalse(drawable.isRunning());, +  public void testUsesDecoderNetscapeLoopCountIfLoopCountIsLoopIntrinsic() {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +      maxLoopCount = state.frameLoader.getLoopCount();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java, +    return gifDecoder.getLoopCount();, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +    assertFalse(drawable.isRunning());, +    assertFalse(drawable.isRunning());, +    assertFalse(drawable.isRunning());, +    assertFalse(drawable.isRunning());, +  public void testUsesDecoderNetscapeLoopCountIfLoopCountIsLoopIntrinsic() {, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, +   * Gets the "Netscape" iteration count, if any. A count of 0 means repeat indefinitely., +   * @return iteration count if one was specified, else 1., +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +      maxLoopCount = state.frameLoader.getLoopCount();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java, +    return gifDecoder.getLoopCount();, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +    assertFalse(drawable.isRunning());, +    assertFalse(drawable.isRunning());, +    assertFalse(drawable.isRunning());, +    assertFalse(drawable.isRunning());, +  public void testUsesDecoderNetscapeLoopCountIfLoopCountIsLoopIntrinsic() {, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, +   * Gets the "Netscape" iteration count, if any. A count of 0 means repeat indefinitely., +   * @return iteration count if one was specified, else 1., +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java, +  int loopCount;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +      maxLoopCount = state.frameLoader.getLoopCount();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java, +    return gifDecoder.getLoopCount();, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +    assertFalse(drawable.isRunning());, +    assertFalse(drawable.isRunning());, +    assertFalse(drawable.isRunning());, +    assertFalse(drawable.isRunning());, +  public void testUsesDecoderNetscapeLoopCountIfLoopCountIsLoopIntrinsic() {, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, +   * Gets the "Netscape" iteration count, if any. A count of 0 means repeat indefinitely., +   * @return iteration count if one was specified, else 1., +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java, +  int loopCount;, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +      maxLoopCount = state.frameLoader.getLoopCount();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java, +    return gifDecoder.getLoopCount();, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +    assertFalse(drawable.isRunning());, +    assertFalse(drawable.isRunning());, +    assertFalse(drawable.isRunning());, +    assertFalse(drawable.isRunning());, +  public void testUsesDecoderNetscapeLoopCountIfLoopCountIsLoopIntrinsic() {, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, +   * Gets the "Netscape" iteration count, if any. A count of 0 means repeat indefinitely., +   * @return iteration count if one was specified, else 1., +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeader.java, +  int loopCount;, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java, +++ b/third_party/gif_decoder/src/test/java/com/bumptech/glide/gifdecoder/GifDecoderTest.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +      maxLoopCount = state.frameLoader.getLoopCount();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameLoader.java, +    return gifDecoder.getLoopCount();, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +++ b/library/src/test/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +    assertFalse(drawable.isRunning());, +    assertFalse(drawable.isRunning());, +    assertFalse(drawable.isRunning());, +    assertFalse(drawable.isRunning());, +  public void testUsesDecoderNetscapeLoopCountIfLoopCountIsLoopIntrinsic() {, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifDecoder.java, +   * Gets the "Netscape" iteration count, if any. A count of 0 means repeat indefinitely.]
[+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java, +  public static GlideOptions overrideOf(int width, int height) {, +    return new GlideOptions().override(width, height);, +  public static GlideOptions overrideOf(int size) {, +    return new GlideOptions().override(size);, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java, +  public static GlideOptions overrideOf(int width, int height) {, +    return new GlideOptions().override(width, height);, +  public static GlideOptions overrideOf(int size) {, +    return new GlideOptions().override(size);, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java, +  public static GlideOptions overrideOf(int width, int height) {, +    return new GlideOptions().override(width, height);, +  public static GlideOptions overrideOf(int size) {, +    return new GlideOptions().override(size);, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java, +  public static GlideOptions overrideOf(int width, int height) {, +    return new GlideOptions().override(width, height);, +  public static GlideOptions overrideOf(int size) {, +    return new GlideOptions().override(size);, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java, +  public static GlideOptions overrideOf(int width, int height) {, +    return new GlideOptions().override(width, height);, +  public static GlideOptions overrideOf(int size) {, +    return new GlideOptions().override(size);, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java, +  public static GlideOptions overrideOf(int width, int height) {, +    return new GlideOptions().override(width, height);, +  public static GlideOptions overrideOf(int size) {, +    return new GlideOptions().override(size);, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java, +  public static GlideOptions overrideOf(int width, int height) {, +    return new GlideOptions().override(width, height);, +  public static GlideOptions overrideOf(int size) {, +    return new GlideOptions().override(size);, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java, +  public static GlideOptions overrideOf(int width, int height) {, +    return new GlideOptions().override(width, height);, +  public static GlideOptions overrideOf(int size) {, +    return new GlideOptions().override(size);, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java, +  public static GlideOptions overrideOf(int width, int height) {, +    return new GlideOptions().override(width, height);, +  public static GlideOptions overrideOf(int size) {, +    return new GlideOptions().override(size);, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java, +  public static GlideOptions overrideOf(int size) {, +    return new GlideOptions().override(size);, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java, +  public static GlideOptions overrideOf(int width, int height) {, +    return new GlideOptions().override(width, height);, +  public static GlideOptions overrideOf(int size) {, +    return new GlideOptions().override(size);, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java, +  public static GlideOptions overrideOf(int width, int height) {, +    return new GlideOptions().override(width, height);, +  public static GlideOptions overrideOf(int size) {, +    return new GlideOptions().override(size);, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java, +  public static GlideOptions overrideOf(int width, int height) {, +    return new GlideOptions().override(width, height);, +  public static GlideOptions overrideOf(int size) {, +    return new GlideOptions().override(size);, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java, +  public static GlideOptions overrideOf(int size) {, +    return new GlideOptions().override(size);, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java, +  public static GlideOptions overrideOf(int width, int height) {, +    return new GlideOptions().override(width, height);, +  public static GlideOptions overrideOf(int size) {, +    return new GlideOptions().override(size);, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java, +  public static GlideOptions overrideOf(int width, int height) {, +    return new GlideOptions().override(width, height);, +  public static GlideOptions overrideOf(int size) {, +    return new GlideOptions().override(size);, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/MemoizeStaticMethod/GlideOptions.java, +  public static GlideOptions overrideOf(int width, int height) {, +    return new GlideOptions().override(width, height);, +  public static GlideOptions overrideOf(int size) {, +    return new GlideOptions().override(size);, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtend/GlideOptions.java, +  public static GlideOptions overrideOf(int width, int height) {, +    return new GlideOptions().override(width, height);, +  public static GlideOptions overrideOf(int size) {, +    return new GlideOptions().override(size);, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideExtendMultipleArguments/GlideOptions.java, +  public static GlideOptions overrideOf(int size) {, +    return new GlideOptions().override(size);, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/OverrideReplace/GlideOptions.java, +  public static GlideOptions overrideOf(int width, int height) {, +    return new GlideOptions().override(width, height);, +  public static GlideOptions overrideOf(int size) {, +    return new GlideOptions().override(size);, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionOptionsTest/SkipStaticMethod/GlideOptions.java, +  public static GlideOptions overrideOf(int width, int height) {, +    return new GlideOptions().override(width, height);, +  public static GlideOptions overrideOf(int size) {, +    return new GlideOptions().override(size);, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideOptions.java]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java, +  @Test, +  public void loadFromBuilder_withDiskCacheStrategySetBeforeLoad_doesNotOverrideDiskCacheStrategy(), +      throws IOException {, +    byte[] data = getCanonicalBytes();, +    concurrency.wait(, +        GlideApp.with(context), +            .asDrawable(), +            .diskCacheStrategy(DiskCacheStrategy.RESOURCE), +            .load(data), +            .submit());, +, +    concurrency.runOnMainThread(new Runnable() {, +      @Override, +      public void run() {, +        GlideApp.get(context).clearMemory();, +      }, +    });, +, +    concurrency.wait(, +        GlideApp.with(context), +            .asDrawable(), +            .diskCacheStrategy(DiskCacheStrategy.RESOURCE), +            .listener(requestListener), +            .load(data), +            .submit());, +, +    verify(requestListener).onResourceReady(, +        anyDrawable(), any(), anyTarget(), eq(DataSource.RESOURCE_DISK_CACHE), anyBoolean());, +  }, +, +  @Test, +  public void loadFromBuilder_withSkipMemoryCacheSetBeforeLoad_doesNotOverrideSkipMemoryCache(), +      throws IOException {, +    byte[] data = getCanonicalBytes();, +    concurrency.wait(, +        GlideApp.with(context), +            .asDrawable(), +            .skipMemoryCache(false), +            .load(data), +            .submit());, +, +    concurrency.runOnMainThread(new Runnable() {, +      @Override, +      public void run() {, +        GlideApp.get(context).clearMemory();, +      }, +    });, +, +    concurrency.wait(, +        GlideApp.with(context), +            .asDrawable(), +            .skipMemoryCache(false), +            .listener(requestListener), +            .load(data), +            .submit());, +, +    verify(requestListener).onResourceReady(, +        anyDrawable(), any(), anyTarget(), eq(DataSource.MEMORY_CACHE), anyBoolean());, +  }, +, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java, +  @Test, +  public void loadFromBuilder_withDiskCacheStrategySetBeforeLoad_doesNotOverrideDiskCacheStrategy(), +      throws IOException {, +    byte[] data = getCanonicalBytes();, +    concurrency.wait(, +        GlideApp.with(context), +            .asDrawable(), +            .diskCacheStrategy(DiskCacheStrategy.RESOURCE), +            .load(data), +            .submit());, +, +    concurrency.runOnMainThread(new Runnable() {, +      @Override, +      public void run() {, +        GlideApp.get(context).clearMemory();, +      }, +    });, +, +    concurrency.wait(, +        GlideApp.with(context), +            .asDrawable(), +            .diskCacheStrategy(DiskCacheStrategy.RESOURCE), +            .listener(requestListener), +            .load(data), +            .submit());, +, +    verify(requestListener).onResourceReady(, +        anyDrawable(), any(), anyTarget(), eq(DataSource.RESOURCE_DISK_CACHE), anyBoolean());, +  }, +, +  @Test, +  public void loadFromBuilder_withSkipMemoryCacheSetBeforeLoad_doesNotOverrideSkipMemoryCache(), +      throws IOException {, +    byte[] data = getCanonicalBytes();, +    concurrency.wait(, +        GlideApp.with(context), +            .asDrawable(), +            .skipMemoryCache(false)]
[+++ b/glide/build.gradle, +project.archivesBaseName = "${POM_ARTIFACT_ID}-${VERSION_NAME}", +, +++ b/glide/build.gradle, +project.archivesBaseName = "${POM_ARTIFACT_ID}-${VERSION_NAME}", +, +++ b/glide/gradle.properties, +POM_NAME=Glide Full, +POM_ARTIFACT_ID=glide-full, +++ b/glide/build.gradle, +project.archivesBaseName = "${POM_ARTIFACT_ID}-${VERSION_NAME}", +, +++ b/glide/gradle.properties, +POM_NAME=Glide Full, +POM_ARTIFACT_ID=glide-full, +++ b/integration/build.gradle, +// keep an empty file to make sure Gradle recognizes the properties, +++ b/glide/build.gradle, +project.archivesBaseName = "${POM_ARTIFACT_ID}-${VERSION_NAME}", +, +++ b/glide/gradle.properties, +POM_NAME=Glide Full, +POM_ARTIFACT_ID=glide-full, +++ b/integration/build.gradle, +// keep an empty file to make sure Gradle recognizes the properties, +++ b/integration/gifencoder/build.gradle, +    compile project(':library'), +apply from: "${rootProject.projectDir}/scripts/upload.gradle", +++ b/glide/build.gradle, +project.archivesBaseName = "${POM_ARTIFACT_ID}-${VERSION_NAME}", +, +++ b/glide/gradle.properties, +POM_NAME=Glide Full, +POM_ARTIFACT_ID=glide-full, +++ b/integration/build.gradle, +// keep an empty file to make sure Gradle recognizes the properties, +++ b/integration/gifencoder/build.gradle, +    compile project(':library'), +apply from: "${rootProject.projectDir}/scripts/upload.gradle", +++ b/integration/gifencoder/gradle.properties, +++ b/glide/build.gradle, +project.archivesBaseName = "${POM_ARTIFACT_ID}-${VERSION_NAME}", +, +++ b/glide/gradle.properties, +POM_NAME=Glide Full, +POM_ARTIFACT_ID=glide-full, +++ b/integration/build.gradle, +// keep an empty file to make sure Gradle recognizes the properties, +++ b/integration/gifencoder/build.gradle, +    compile project(':library'), +apply from: "${rootProject.projectDir}/scripts/upload.gradle", +++ b/integration/gifencoder/gradle.properties, +++ b/integration/gradle.properties, +# Prefix and postfix for source and javadoc jars., +JAR_PREFIX=glide-, +JAR_POSTFIX=-integration, +++ b/glide/build.gradle, +project.archivesBaseName = "${POM_ARTIFACT_ID}-${VERSION_NAME}", +, +++ b/glide/gradle.properties, +POM_NAME=Glide Full, +POM_ARTIFACT_ID=glide-full, +++ b/integration/build.gradle, +// keep an empty file to make sure Gradle recognizes the properties, +++ b/integration/gifencoder/build.gradle, +    compile project(':library'), +apply from: "${rootProject.projectDir}/scripts/upload.gradle", +++ b/integration/gifencoder/gradle.properties, +++ b/integration/gradle.properties, +# Prefix and postfix for source and javadoc jars., +JAR_PREFIX=glide-, +JAR_POSTFIX=-integration, +++ b/integration/okhttp/build.gradle, +    compile project(':library'), +apply from: "${rootProject.projectDir}/scripts/upload.gradle", +++ b/glide/build.gradle, +project.archivesBaseName = "${POM_ARTIFACT_ID}-${VERSION_NAME}", +, +++ b/glide/gradle.properties, +POM_NAME=Glide Full, +POM_ARTIFACT_ID=glide-full, +++ b/integration/build.gradle, +// keep an empty file to make sure Gradle recognizes the properties, +++ b/integration/gifencoder/build.gradle, +    compile project(':library'), +apply from: "${rootProject.projectDir}/scripts/upload.gradle", +++ b/integration/gifencoder/gradle.properties, +++ b/integration/gradle.properties, +# Prefix and postfix for source and javadoc jars., +JAR_PREFIX=glide-, +JAR_POSTFIX=-integration, +++ b/integration/okhttp/build.gradle, +    compile project(':library'), +apply from: "${rootProject.projectDir}/scripts/upload.gradle", +++ b/integration/okhttp/gradle.properties, +++ b/glide/build.gradle, +project.archivesBaseName = "${POM_ARTIFACT_ID}-${VERSION_NAME}", +, +++ b/glide/gradle.properties, +POM_NAME=Glide Full]
[+++ b/samples/imgur/src/main/java/com/bumptech/glide/samples/imgur/api/ApiModule.java, +/** Provides classes related to the Imgur API via Dagger. */]
[+++ b/gradle.properties, +VERSION_NAME=4.1.0]
[+++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java, +    // Initialize isConnected., +    isConnected = isConnected(context);, +      // See #1417, registering the receiver can throw SecurityException., +        Preconditions.checkNotNull(, +            (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE));, +    NetworkInfo networkInfo;, +    try {, +      networkInfo = connectivityManager.getActiveNetworkInfo();, +    } catch (RuntimeException e) {, +      // #1405 shows that this throws a SecurityException., +      // b/70869360 shows that this throws NullPointerException on APIs 22, 23, and 24., +      // b/70869360 also shows that this throws RuntimeException on API 24 and 25., +      if (Log.isLoggable(TAG, Log.WARN)) {, +        Log.w(TAG, "Failed to determine connectivity status when connectivity changed", e);, +      }, +      // Default to true;, +      return true;, +    }, +++ b/library/src/main/java/com/bumptech/glide/manager/DefaultConnectivityMonitor.java, +    // Initialize isConnected., +    isConnected = isConnected(context);, +      // See #1417, registering the receiver can throw SecurityException., +        Preconditions.checkNotNull(, +            (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE));, +    NetworkInfo networkInfo;, +    try {, +      networkInfo = connectivityManager.getActiveNetworkInfo();, +    } catch (RuntimeException e) {, +      // #1405 shows that this throws a SecurityException., +      // b/70869360 shows that this throws NullPointerException on APIs 22, 23, and 24., +      // b/70869360 also shows that this throws RuntimeException on API 24 and 25., +      if (Log.isLoggable(TAG, Log.WARN)) {, +        Log.w(TAG, "Failed to determine connectivity status when connectivity changed", e);, +      }, +      // Default to true;, +      return true;, +    }, +++ b/library/src/test/java/com/bumptech/glide/manager/DefaultConnectivityMonitorTest.java]
[+++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java, +        if (url == null) {, +            throw new IllegalArgumentException("URL must not be null!");, +        }, +        if (TextUtils.isEmpty(url)) {, +            throw new IllegalArgumentException("String url must not be empty or null: " + url);, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java, +        if (url == null) {, +            throw new IllegalArgumentException("URL must not be null!");, +        }, +        if (TextUtils.isEmpty(url)) {, +            throw new IllegalArgumentException("String url must not be empty or null: " + url);, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoModelLoader.java, +, +        if (streamFetcher != null || fileDescriptorFetcher != null) {, +        } else {, +            return null;, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java, +        if (url == null) {, +            throw new IllegalArgumentException("URL must not be null!");, +        }, +        if (TextUtils.isEmpty(url)) {, +            throw new IllegalArgumentException("String url must not be empty or null: " + url);, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoModelLoader.java, +, +        if (streamFetcher != null || fileDescriptorFetcher != null) {, +        } else {, +            return null;, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java, +     * <p>, +     *     Note - If no valid data fetcher can be returned (for example if a model has a null URL), then it is, +     *     acceptable to return a null data fetcher from this method. Doing so will be treated any other failure or, +     *     exception during the load process., +     * </p>, +     *, +     * @param model The model representing the resource., +     * cached, or null if no valid {@link com.bumptech.glide.load.data.DataFetcher} could be constructed., +++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java, +        if (url == null) {, +            throw new IllegalArgumentException("URL must not be null!");, +        }, +        if (TextUtils.isEmpty(url)) {, +            throw new IllegalArgumentException("String url must not be empty or null: " + url);, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoModelLoader.java, +, +        if (streamFetcher != null || fileDescriptorFetcher != null) {, +        } else {, +            return null;, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java, +     * <p>, +     *     Note - If no valid data fetcher can be returned (for example if a model has a null URL), then it is, +     *     acceptable to return a null data fetcher from this method. Doing so will be treated any other failure or, +     *     exception during the load process., +     * </p>, +     *, +     * @param model The model representing the resource., +     * cached, or null if no valid {@link com.bumptech.glide.load.data.DataFetcher} could be constructed., +++ b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java, +import android.text.TextUtils;, +, +            if (TextUtils.isEmpty(stringURL)) {, +               return null;, +            }, +, +++ b/library/src/main/java/com/bumptech/glide/load/model/GlideUrl.java, +        if (url == null) {, +            throw new IllegalArgumentException("URL must not be null!");, +        }, +        if (TextUtils.isEmpty(url)) {, +            throw new IllegalArgumentException("String url must not be empty or null: " + url);, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/model/ImageVideoModelLoader.java, +, +        if (streamFetcher != null || fileDescriptorFetcher != null) {, +        } else {, +            return null;, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoader.java, +     * <p>, +     *     Note - If no valid data fetcher can be returned (for example if a model has a null URL), then it is, +     *     acceptable to return a null data fetcher from this method. Doing so will be treated any other failure or, +     *     exception during the load process., +     * </p>, +     *, +     * @param model The model representing the resource., +     * cached, or null if no valid {@link com.bumptech.glide.load.data.DataFetcher} could be constructed., +++ b/library/src/main/java/com/bumptech/glide/load/model/stream/BaseGlideUrlLoader.java, +import android.text.TextUtils;, +, +            if (TextUtils.isEmpty(stringURL)) {, +               return null;, +            }, +]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/README.md, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/README.md, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }, +    }, +}, +, +subprojects {, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = 1.7, +        targetCompatibility = 1.7, +    }, +}, +, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml]
[+++ b/library/src/main/java/com/bumptech/glide/load/Option.java, +public final class Option<T> {, +++ b/library/src/main/java/com/bumptech/glide/load/Option.java, +public final class Option<T> {, +++ b/library/src/main/java/com/bumptech/glide/load/Options.java, +import android.support.v4.util.ArrayMap;, +import android.support.v4.util.SimpleArrayMap;, +, +  private final ArrayMap<Option<?>, Object> values = new ArrayMap<>();, +    values.putAll((SimpleArrayMap<Option<?>, Object>) other.values);]
[+++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import org.robolectric.RobolectricTestRunner;, +, +@Config(manifest = Config.NONE, sdk = 18), +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import org.robolectric.RobolectricTestRunner;, +, +@Config(manifest = Config.NONE, sdk = 18), +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.google.common.truth.Truth.assertThat;, +import org.robolectric.RobolectricTestRunner;, +, +@Config(manifest = Config.NONE, sdk = 18,, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import org.robolectric.RobolectricTestRunner;, +, +@Config(manifest = Config.NONE, sdk = 18), +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.google.common.truth.Truth.assertThat;, +import org.robolectric.RobolectricTestRunner;, +, +@Config(manifest = Config.NONE, sdk = 18,, +++ b/library/src/test/java/com/bumptech/glide/GlideTest.java, +import org.robolectric.RobolectricTestRunner;, +, +@Config(manifest = Config.NONE, sdk = 18, shadows = {, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import org.robolectric.RobolectricTestRunner;, +, +@Config(manifest = Config.NONE, sdk = 18), +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.google.common.truth.Truth.assertThat;, +import org.robolectric.RobolectricTestRunner;, +, +@Config(manifest = Config.NONE, sdk = 18,, +++ b/library/src/test/java/com/bumptech/glide/GlideTest.java, +import org.robolectric.RobolectricTestRunner;, +, +@Config(manifest = Config.NONE, sdk = 18, shadows = {, +++ b/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java, +import org.robolectric.RobolectricTestRunner;, +, +@Config(manifest = Config.NONE, sdk = 18), +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import org.robolectric.RobolectricTestRunner;, +, +@Config(manifest = Config.NONE, sdk = 18), +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.google.common.truth.Truth.assertThat;, +import org.robolectric.RobolectricTestRunner;, +, +@Config(manifest = Config.NONE, sdk = 18,, +++ b/library/src/test/java/com/bumptech/glide/GlideTest.java, +import org.robolectric.RobolectricTestRunner;, +, +@Config(manifest = Config.NONE, sdk = 18, shadows = {, +++ b/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java, +import org.robolectric.RobolectricTestRunner;, +, +@Config(manifest = Config.NONE, sdk = 18), +++ b/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java, +import org.robolectric.RobolectricTestRunner;, +, +@Config(manifest = Config.NONE, sdk = 18), +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import org.robolectric.RobolectricTestRunner;, +, +@Config(manifest = Config.NONE, sdk = 18), +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.google.common.truth.Truth.assertThat;, +import org.robolectric.RobolectricTestRunner;, +, +@Config(manifest = Config.NONE, sdk = 18,, +++ b/library/src/test/java/com/bumptech/glide/GlideTest.java, +import org.robolectric.RobolectricTestRunner;, +, +@Config(manifest = Config.NONE, sdk = 18, shadows = {, +++ b/library/src/test/java/com/bumptech/glide/ListPreloaderTest.java, +import org.robolectric.RobolectricTestRunner;, +, +@Config(manifest = Config.NONE, sdk = 18), +++ b/library/src/test/java/com/bumptech/glide/RequestBuilderTest.java, +import org.robolectric.RobolectricTestRunner;, +, +@Config(manifest = Config.NONE, sdk = 18), +++ b/library/src/test/java/com/bumptech/glide/RequestManagerTest.java, +import org.robolectric.RobolectricTestRunner;, +, +@Config(manifest = Config.NONE, sdk = 18, shadows = GlideShadowLooper.class), +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +import org.robolectric.RobolectricTestRunner;, +, +@Config(manifest = Config.NONE, sdk = 18), +++ b/integration/volley/src/test/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.google.common.truth.Truth.assertThat;, +import org.robolectric.RobolectricTestRunner;, +, +@Config(manifest = Config.NONE, sdk = 18,, +++ b/library/src/test/java/com/bumptech/glide/GlideTest.java, +import org.robolectric.RobolectricTestRunner;]
[+++ b/.idea/codeStyleSettings.xml, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MAJOR=3, +VERSION_MINOR=6, +VERSION_CODE=11, +SUPPORT_V4_VERSION=19.1.0, +SUPPORT_V7_VERSION=19.1.0, +# TODO: Upgrade to latest version of Volley when we compile with Java 7., +VOLLEY_VERSION=1.0.8, +ANDROID_GRADLE_VERSION=1.0.0, +ROBOLECTRIC_GRADLE_VERSION=0.14.0, +ROBOLECTRIC_VERSION=2.4, +MOCKWEBSERVER_VERSION=1.6.0, +COMPILE_SDK_VERSION=19, +BUILD_TOOLS_VERSION=19.1.0, +TARGET_SDK_VERSION=19, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MAJOR=3, +VERSION_MINOR=6, +VERSION_CODE=11, +SUPPORT_V4_VERSION=19.1.0, +SUPPORT_V7_VERSION=19.1.0, +# TODO: Upgrade to latest version of Volley when we compile with Java 7., +VOLLEY_VERSION=1.0.8, +ANDROID_GRADLE_VERSION=1.0.0, +ROBOLECTRIC_GRADLE_VERSION=0.14.0, +ROBOLECTRIC_VERSION=2.4, +MOCKWEBSERVER_VERSION=1.6.0, +COMPILE_SDK_VERSION=19, +BUILD_TOOLS_VERSION=19.1.0, +TARGET_SDK_VERSION=19, +++ b/integration/integration.iml, +<module external.linked.project.id=":integration" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="glide-parent" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MAJOR=3]
[+++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java, +        throw (FileNotFoundException), +          new FileNotFoundException("NPE opening uri: " + thumbnailUri).initCause(e);]
[+++ b/library/src/main/java/com/bumptech/glide/Registry.java, +      @NonNull Class<Model> modelClass,, +      @NonNull Class<TResource> resourceClass,, +    List<Class<?>> result =, +        modelToResourceClassCache.get(modelClass, resourceClass, transcodeClass);, +      modelToResourceClassCache.put(, +          modelClass, resourceClass, transcodeClass, Collections.unmodifiableList(result));, +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +      @NonNull Class<Model> modelClass,, +      @NonNull Class<TResource> resourceClass,, +    List<Class<?>> result =, +        modelToResourceClassCache.get(modelClass, resourceClass, transcodeClass);, +      modelToResourceClassCache.put(, +          modelClass, resourceClass, transcodeClass, Collections.unmodifiableList(result));, +++ b/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java, +  public List<Class<?>> get(, +      @NonNull Class<?> modelClass,, +      @NonNull Class<?> resourceClass,, +      @NonNull Class<?> transcodeClass) {, +      key = new MultiClassKey(modelClass, resourceClass, transcodeClass);, +      key.set(modelClass, resourceClass, transcodeClass);, +  public void put(, +      @NonNull Class<?> modelClass,, +      @NonNull Class<?> resourceClass,, +      @NonNull Class<?> transcodeClass,, +          .put(new MultiClassKey(modelClass, resourceClass, transcodeClass), resourceClasses);, +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +      @NonNull Class<Model> modelClass,, +      @NonNull Class<TResource> resourceClass,, +    List<Class<?>> result =, +        modelToResourceClassCache.get(modelClass, resourceClass, transcodeClass);, +      modelToResourceClassCache.put(, +          modelClass, resourceClass, transcodeClass, Collections.unmodifiableList(result));, +++ b/library/src/main/java/com/bumptech/glide/provider/ModelToResourceClassCache.java, +  public List<Class<?>> get(, +      @NonNull Class<?> modelClass,, +      @NonNull Class<?> resourceClass,, +      @NonNull Class<?> transcodeClass) {, +      key = new MultiClassKey(modelClass, resourceClass, transcodeClass);, +      key.set(modelClass, resourceClass, transcodeClass);, +  public void put(, +      @NonNull Class<?> modelClass,, +      @NonNull Class<?> resourceClass,, +      @NonNull Class<?> transcodeClass,, +          .put(new MultiClassKey(modelClass, resourceClass, transcodeClass), resourceClasses);, +++ b/library/test/src/test/java/com/bumptech/glide/RegistryTest.java, +package com.bumptech.glide;, +, +import static com.google.common.truth.Truth.assertThat;, +, +import com.bumptech.glide.load.ResourceDecoder;, +import com.bumptech.glide.load.model.ModelLoaderFactory;, +import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;, +import java.util.List;, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE), +public class RegistryTest {, +, +  @Mock private ModelLoaderFactory<Model, Data> modelLoaderFactory;, +  @Mock private ResourceDecoder<Data, ResourceOne> resourceOneDecoder;, +  @Mock private ResourceDecoder<Data, ResourceTwo> resourceTwoDecoder;, +  @Mock private ResourceTranscoder<ResourceOne, TranscodeOne> resourceOneTranscodeOneTranscoder;, +  private Registry registry;, +, +  @Before, +  public void setUp() {, +    MockitoAnnotations.initMocks(this);, +    registry = new Registry();, +  }, +, +  @Test, +  public void getRegisteredResourceClasses_withNoResources_isEmpty() {, +    assertThat(getRegisteredResourceClasses()).isEmpty();, +  }, +, +  @Test, +  public void getRegisteredResourceClasses_withOneDataClass_noResourceClasses_isEmpty() {, +    registry.append(Model.class, Data.class, modelLoaderFactory);, +    assertThat(getRegisteredResourceClasses()).isEmpty();, +  }, +, +  @Test, +  public void getRegisteredResourceClasses_withOneDataAndResourceClass_noTranscodeClass_isEmpty() {, +    registry.append(Model.class, Data.class, modelLoaderFactory);, +    registry.append(Data.class, ResourceOne.class, resourceOneDecoder);, +    assertThat(getRegisteredResourceClasses()).isEmpty();, +  }, +, +  @Test, +  public void getRegisteredResourceClasses_withOneDataAndResourceAndTranscodeClass_isNotEmpty() {, +    registry.append(Model.class, Data.class, modelLoaderFactory);, +    registry.append(Data.class, ResourceOne.class, resourceOneDecoder);]
[+++ b/.travis.yml, +++ b/.travis.yml, +++ b/scripts/travis_create_emulator.sh, +echo y | android --silent update sdk --no-ui --all --filter android-$ANDROID_TARGET, +echo y | android --silent update sdk --no-ui --all --filter sys-img-armeabi-v7a-android-$ANDROID_TARGET]
[+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +   * reference has to be cleared and processed before the hard reference is removed. As a result,, +   * setting this method to {@code true} may transiently increase the memory usage of an, +   * application., +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +   * reference has to be cleared and processed before the hard reference is removed. As a result,, +   * setting this method to {@code true} may transiently increase the memory usage of an, +   * application., +++ b/library/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java, +    resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ true);, +    resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ false);, +    resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ false);, +    resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ false);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +   * reference has to be cleared and processed before the hard reference is removed. As a result,, +   * setting this method to {@code true} may transiently increase the memory usage of an, +   * application., +++ b/library/src/test/java/com/bumptech/glide/load/engine/ActiveResourcesTest.java, +    resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ true);, +    resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ false);, +    resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ false);, +    resources = new ActiveResources(/*isActiveResourceRetentionAllowed=*/ false);, +++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java, +        new ActiveResources(/*isActiveResourceRetentionAllowed=*/ true);]
[+++ b/library/src/main/java/com/bumptech/glide/TransitionOptions.java, +  /**, +   * Uses the given {@link TransitionFactory} to build a, +   * {@link com.bumptech.glide.request.transition.Transition} for each request started with these, +   * {@code TransitionOptions}., +   *, +   * @return This request builder., +   */]
[+++ b/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java, +, +    public GifTypeRequest<A> asGif() {, +        return new GifTypeRequest<A>(context, model, streamModelLoader, glide);, +    }, +++ b/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java, +, +    public GifTypeRequest<A> asGif() {, +        return new GifTypeRequest<A>(context, model, streamModelLoader, glide);, +    }, +++ b/library/src/main/java/com/bumptech/glide/GifRequestBuilder.java, +package com.bumptech.glide;, +, +import android.content.Context;, +import android.graphics.Bitmap;, +import android.graphics.drawable.Drawable;, +import android.view.animation.Animation;, +import com.bumptech.glide.load.ResourceDecoder;, +import com.bumptech.glide.load.ResourceEncoder;, +import com.bumptech.glide.load.Transformation;, +import com.bumptech.glide.load.resource.bitmap.CenterCrop;, +import com.bumptech.glide.load.resource.bitmap.FitCenter;, +import com.bumptech.glide.load.resource.gif.GifData;, +import com.bumptech.glide.load.resource.gif.GifDataTransformation;, +import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;, +import com.bumptech.glide.provider.LoadProvider;, +import com.bumptech.glide.request.RequestListener;, +, +import java.io.InputStream;, +, +public class GifRequestBuilder<ModelType, TranscodeType>, +        extends GenericRequestBuilder<ModelType, InputStream, GifData, TranscodeType> {, +    private Glide glide;, +, +    GifRequestBuilder(Context context, ModelType model,, +            LoadProvider<ModelType, InputStream, GifData, TranscodeType> loadProvider,, +            Class<TranscodeType> transcodeClass, Glide glide) {, +        super(context, model, loadProvider, transcodeClass, glide);, +        this.glide = glide;, +    }, +, +    @Override, +    public GifRequestBuilder<ModelType, TranscodeType> thumbnail(, +            GenericRequestBuilder<ModelType, InputStream, GifData, TranscodeType> thumbnailRequest) {, +        super.thumbnail(thumbnailRequest);, +        return this;, +    }, +, +    public GifRequestBuilder<ModelType, TranscodeType> thumbnail(, +            GifRequestBuilder<ModelType, TranscodeType> thumbnailRequest) {, +        super.thumbnail(thumbnailRequest);, +        return this;, +    }, +, +    @Override, +    public GifRequestBuilder<ModelType, TranscodeType> thumbnail(float sizeMultiplier) {, +        super.thumbnail(sizeMultiplier);, +        return this;, +    }, +, +    @Override, +    public GifRequestBuilder<ModelType, TranscodeType> sizeMultiplier(float sizeMultiplier) {, +        super.sizeMultiplier(sizeMultiplier);, +        return this;, +    }, +, +    @Override, +    public GifRequestBuilder<ModelType, TranscodeType> decoder(, +            ResourceDecoder<InputStream, GifData> decoder) {, +        super.decoder(decoder);, +        return this;, +    }, +, +    @Override, +    public GifRequestBuilder<ModelType, TranscodeType> cacheDecoder(, +            ResourceDecoder<InputStream, GifData> cacheDecoder) {, +        super.cacheDecoder(cacheDecoder);, +        return this;, +    }, +, +    @Override, +    public GifRequestBuilder<ModelType, TranscodeType> encoder(, +            ResourceEncoder<GifData> encoder) {, +        super.encoder(encoder);, +        return this;, +    }, +, +    @Override, +    public GifRequestBuilder<ModelType, TranscodeType> priority(Priority priority) {, +        super.priority(priority);, +        return this;, +    }, +, +    public GifRequestBuilder<ModelType, TranscodeType> fitCenter() {, +        return transformBitmap(new FitCenter(glide.getBitmapPool()));, +    }, +, +    public GifRequestBuilder<ModelType, TranscodeType> centerCrop() {, +        return transformBitmap(new CenterCrop(glide.getBitmapPool()));, +    }]
[+++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java, +  public BitmapImageViewTarget(ImageView view, boolean waitForLayout) {, +    super(view, waitForLayout);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java, +  public BitmapImageViewTarget(ImageView view, boolean waitForLayout) {, +    super(view, waitForLayout);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java, +  public BitmapThumbnailImageViewTarget(ImageView view, boolean waitForLayout) {, +    super(view, waitForLayout);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java, +  public BitmapImageViewTarget(ImageView view, boolean waitForLayout) {, +    super(view, waitForLayout);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java, +  public BitmapThumbnailImageViewTarget(ImageView view, boolean waitForLayout) {, +    super(view, waitForLayout);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java, +  public DrawableImageViewTarget(ImageView view, boolean waitForLayout) {, +    super(view, waitForLayout);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java, +  public BitmapImageViewTarget(ImageView view, boolean waitForLayout) {, +    super(view, waitForLayout);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java, +  public BitmapThumbnailImageViewTarget(ImageView view, boolean waitForLayout) {, +    super(view, waitForLayout);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java, +  public DrawableImageViewTarget(ImageView view, boolean waitForLayout) {, +    super(view, waitForLayout);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java, +  public DrawableThumbnailImageViewTarget(ImageView view, boolean waitForLayout) {, +    super(view, waitForLayout);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java, +  public BitmapImageViewTarget(ImageView view, boolean waitForLayout) {, +    super(view, waitForLayout);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java, +  public BitmapThumbnailImageViewTarget(ImageView view, boolean waitForLayout) {, +    super(view, waitForLayout);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java, +  public DrawableImageViewTarget(ImageView view, boolean waitForLayout) {, +    super(view, waitForLayout);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java, +  public DrawableThumbnailImageViewTarget(ImageView view, boolean waitForLayout) {, +    super(view, waitForLayout);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java, +  public ImageViewTarget(ImageView view, boolean waitForLayout) {, +    super(view, waitForLayout);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapImageViewTarget.java, +  public BitmapImageViewTarget(ImageView view, boolean waitForLayout) {, +    super(view, waitForLayout);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java, +  public BitmapThumbnailImageViewTarget(ImageView view, boolean waitForLayout) {, +    super(view, waitForLayout);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java, +  public DrawableImageViewTarget(ImageView view, boolean waitForLayout) {, +    super(view, waitForLayout);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java, +  public DrawableThumbnailImageViewTarget(ImageView view, boolean waitForLayout) {, +    super(view, waitForLayout);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java, +  public ImageViewTarget(ImageView view, boolean waitForLayout) {, +    super(view, waitForLayout);, +  }, +]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/WideGamutTest.java, +package com.bumptech.glide;, +, +import static com.google.common.truth.Truth.assertThat;, +import static org.junit.Assume.assumeTrue;, +, +import android.content.Context;, +import android.graphics.Bitmap;, +import android.graphics.Bitmap.CompressFormat;, +import android.graphics.ColorSpace;, +import android.graphics.ColorSpace.Named;, +import android.os.Build;, +import android.support.test.InstrumentationRegistry;, +import android.support.test.runner.AndroidJUnit4;, +import com.bumptech.glide.load.DecodeFormat;, +import com.bumptech.glide.load.engine.bitmap_recycle.LruBitmapPool;, +import com.bumptech.glide.test.ConcurrencyHelper;, +import com.bumptech.glide.test.GlideApp;, +import com.bumptech.glide.test.ResourceIds;, +import com.bumptech.glide.test.TearDownGlide;, +import java.io.ByteArrayOutputStream;, +import org.junit.Before;, +import org.junit.Rule;, +import org.junit.Test;, +import org.junit.rules.TestRule;, +import org.junit.runner.RunWith;, +, +@RunWith(AndroidJUnit4.class), +public class WideGamutTest {, +  @Rule public final TestRule tearDownGlide = new TearDownGlide();, +  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();, +  private final Context context = InstrumentationRegistry.getTargetContext();, +, +  @Before, +  public void setUp() {, +    assumeTrue(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O);, +  }, +, +  @Test, +  public void load_withWideGamutImage_returnsWideGamutBitmap() {, +    Bitmap bitmap =, +        concurrency.get(, +            Glide.with(context), +                .asBitmap(), +                .load(ResourceIds.raw.webkit_logo_p3), +                .submit());, +    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.RGBA_F16);, +  }, +, +  @Test, +  public void load_withWideGamutImage_bitmapInPoolWithSizeAndConfig_usesBitmapFromPool() {, +    int bitmapDimension = 1000;, +    Glide.init(, +        context,, +        new GlideBuilder(), +            .setBitmapPool(new LruBitmapPool(bitmapDimension * bitmapDimension * 8 * 4)));, +    Bitmap expected = Bitmap.createBitmap(bitmapDimension, bitmapDimension, Bitmap.Config.RGBA_F16);, +, +    Glide.get(context), +        .getBitmapPool(), +        .put(expected);, +, +    Bitmap bitmap =, +        concurrency.get(, +            Glide.with(context), +                .asBitmap(), +                .load(ResourceIds.raw.webkit_logo_p3), +                .submit());, +    assertThat(bitmap).isSameAs(expected);, +  }, +, +  @Test, +  public void load_withWideGamutImage_hardwareAllowed_returnsHardwareBitmap() {, +    Bitmap bitmap =, +        concurrency.get(, +            GlideApp.with(context), +                .asBitmap(), +                .format(DecodeFormat.PREFER_ARGB_8888), +                .load(ResourceIds.raw.webkit_logo_p3), +                .submit());, +    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.HARDWARE);, +  }, +, +  @Test, +  public void load_withEncodedPngWideGamutImage_decodesWideGamut() {, +    Bitmap toCompress =, +        Bitmap.createBitmap(, +            100, 100, Bitmap.Config.RGBA_F16, /*hasAlpha=*/ true, ColorSpace.get(Named.DCI_P3));, +, +    ByteArrayOutputStream os = new ByteArrayOutputStream();, +    toCompress.compress(CompressFormat.PNG, 100, os);, +    byte[] data = os.toByteArray();, +, +      Bitmap bitmap =, +        concurrency.get(, +            Glide.with(context), +                .asBitmap(), +                .load(data), +                .submit());, +    assertThat(bitmap.getConfig()).isEqualTo(Bitmap.Config.RGBA_F16);]
[+++ b/library/src/main/java/com/bumptech/glide/Registry.java, +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +++ b/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java, +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +++ b/library/src/main/java/com/bumptech/glide/provider/ResourceEncoderRegistry.java, +++ b/library/src/main/java/com/bumptech/glide/util/Util.java]
[+++ b/.gitignore, +library/build/*, +++ b/.gitignore, +library/build/*, +++ b/.gitmodules, +[submodule "samples/flickr/ActionBarSherlock"], +	path = samples/flickr/ActionBarSherlock, +	url = https://github.com/JakeWharton/ActionBarSherlock.git, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ b/.gitignore, +library/build/*, +++ b/.gitmodules, +[submodule "samples/flickr/ActionBarSherlock"], +	path = samples/flickr/ActionBarSherlock, +	url = https://github.com/JakeWharton/ActionBarSherlock.git, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ /dev/null, +++ b/.gitignore, +library/build/*, +++ b/.gitmodules, +[submodule "samples/flickr/ActionBarSherlock"], +	path = samples/flickr/ActionBarSherlock, +	url = https://github.com/JakeWharton/ActionBarSherlock.git, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ /dev/null, +++ b/LICENSE, +Copyright 2013 Bump Technologies, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY BUMP TECHNOLOGIES, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BUMP TECHNOLOGIES, INC. OR, +or implied, of Bump Technologies, Inc., +++ b/.gitignore, +library/build/*, +++ b/.gitmodules, +[submodule "samples/flickr/ActionBarSherlock"], +	path = samples/flickr/ActionBarSherlock, +	url = https://github.com/JakeWharton/ActionBarSherlock.git, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ /dev/null, +++ b/LICENSE, +Copyright 2013 Bump Technologies, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY BUMP TECHNOLOGIES, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BUMP TECHNOLOGIES, INC. OR, +or implied, of Bump Technologies, Inc., +++ b/Makefile, +	cd library/volley && ant clean && ant jar, +	cp library/volley/bin/volley.jar library/libs, +, +glide-minus-volley:, +	cd library && ant clean && ant glide-minus-volley, +, +++ b/.gitignore, +library/build/*, +++ b/.gitmodules, +[submodule "samples/flickr/ActionBarSherlock"], +	path = samples/flickr/ActionBarSherlock, +	url = https://github.com/JakeWharton/ActionBarSherlock.git, +[submodule "library/volley"], +	path = library/volley, +[submodule "library/tests/assets/exif-orientation-examples"], +	path = library/tests/assets/exif-orientation-examples, +	url = https://github.com/recurser/exif-orientation-examples.git, +++ /dev/null, +++ b/LICENSE, +Copyright 2013 Bump Technologies, Inc. All rights reserved., +THIS SOFTWARE IS PROVIDED BY BUMP TECHNOLOGIES, INC. ``AS IS'' AND ANY EXPRESS OR IMPLIED, +FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL BUMP TECHNOLOGIES, INC. OR, +or implied, of Bump Technologies, Inc., +++ b/Makefile, +	cd library/volley && ant clean && ant jar, +	cp library/volley/bin/volley.jar library/libs, +, +glide-minus-volley:, +	cd library && ant clean && ant glide-minus-volley, +, +++ b/README.md, +Glide is fast and efficient image loading library for Android that wraps image downloading, resizing, memory and disk caching, and bitmap recycling into one simple and easy to use interface. By default, Glide includes an implementation for fetching images over http based on Google's Volley project for fast, parallelized network operations on Android., +Glide's primary focus is on making scrolling any kind of a list of images as smooth and fast as possible, but Glide is also effective for almost any case where you need to fetch, resize, and display a remote image., +You can download a .jar from GitHub's release page for the Glide project. The wiki also has pages on a variety of topics and the javadocs for version 2.0+ will also be available via a link there as well., +    Glide.load("http://goo.gl/h8qOq7").into(imageView);, +    Glide.load(url), +Glide has been in use at Bump for about six months in two of our Android apps at version 1.0. Version 2.0 is the first public release with a stable api. Comments/bugs/questions/pull requests welcome!, +Thanks to the Android project and Jake Wharton for the [disk cache implementation](https://github.com/JakeWharton/DiskLruCache) included with Glide. Thanks also to the Android team for [Volley](https://android.googlesource.com/platform/frameworks/volley/)., +++ b/.gitignore, +library/build/*]
[+++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +  @Mock Transformation<Bitmap> frameTransformation;, +  @Mock Resource<Bitmap> transformedResource;, +    when(frameTransformation.transform(eq(frameResource), eq(expectedWidth), eq(expectedHeight))), +    when(gifDrawable.getFrameTransformation()).thenReturn(frameTransformation);]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import android.support.annotation.RawRes;, +  public RequestBuilder<TranscodeType> load(@RawRes @DrawableRes @Nullable Integer resourceId) {]
[+++ b/samples/svg/build.gradle, +        applicationId 'com.bumptech.glide.samples.svg', +    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.svg/.MainActivity', +++ b/samples/svg/build.gradle, +        applicationId 'com.bumptech.glide.samples.svg', +    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.svg/.MainActivity', +++ b/samples/svg/src/main/AndroidManifest.xml, +    package="com.bumptech.glide.samples.svg" >, +++ b/samples/svg/build.gradle, +        applicationId 'com.bumptech.glide.samples.svg', +    commandLine "${android.sdkDirectory}/platform-tools/adb", 'shell', 'am', 'start', '-n', 'com.bumptech.glide.samples.svg/.MainActivity', +++ b/samples/svg/src/main/AndroidManifest.xml, +    package="com.bumptech.glide.samples.svg" >, +++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/MainActivity.java, +package com.bumptech.glide.samples.svg;, +, +import android.app.Activity;, +import android.content.ContentResolver;, +import android.graphics.drawable.PictureDrawable;, +import android.net.Uri;, +import android.os.Bundle;, +import android.util.Log;, +import android.view.View;, +import android.widget.ImageView;, +import android.widget.TextView;, +, +import com.bumptech.glide.GenericRequestBuilder;, +import com.bumptech.glide.Glide;, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +import com.bumptech.glide.load.model.StreamEncoder;, +import com.bumptech.glide.load.resource.file.FileToStreamDecoder;, +import com.caverock.androidsvg.SVG;, +, +import java.io.File;, +import java.io.InputStream;, +, +/**, + * Displays an SVG image loaded from an android raw resource., + */, +public class MainActivity extends Activity {, +    private static final String TAG = "SVGActivity";, +, +    private ImageView imageViewRes;, +    private ImageView imageViewNet;, +    private GenericRequestBuilder<Uri, InputStream, SVG, PictureDrawable> requestBuilder;, +, +    @Override, +    protected void onCreate(Bundle savedInstanceState) {, +        super.onCreate(savedInstanceState);, +        setContentView(R.layout.activity_main);, +, +        imageViewRes = (ImageView) findViewById(R.id.svg_image_view1);, +        imageViewNet = (ImageView) findViewById(R.id.svg_image_view2);, +, +        requestBuilder = Glide.with(this), +                .using(Glide.buildStreamModelLoader(Uri.class, this), InputStream.class), +                .from(Uri.class), +                .as(SVG.class), +                .transcode(new SvgDrawableTranscoder(), PictureDrawable.class), +                .sourceEncoder(new StreamEncoder()), +                .cacheDecoder(new FileToStreamDecoder<SVG>(new SvgDecoder())), +                .decoder(new SvgDecoder()), +                .placeholder(R.drawable.image_loading), +                .error(R.drawable.image_error), +                .animate(android.R.anim.fade_in), +                .listener(new SvgSoftwareLayerSetter<Uri>());, +    }, +, +    @Override, +    protected void onStart() {, +        super.onStart();, +        reload();, +    }, +, +    public void clearCache(View v) {, +        Log.w(TAG, "clearing cache");, +        Glide.clear(imageViewRes);, +        Glide.clear(imageViewNet);, +        Glide.get(this).clearMemory();, +        File cacheDir = Glide.getPhotoCacheDir(this);, +        if (cacheDir.isDirectory()) {, +            for (File child : cacheDir.listFiles()) {, +                if (!child.delete()) {, +                    Log.w(TAG, "cannot delete: " + child);, +                }, +            }, +        }, +        reload();, +    }, +, +    public void cycleScaleType(View v) {, +        ImageView.ScaleType curr = imageViewRes.getScaleType();, +        Log.w(TAG, "cycle: current=" + curr);, +        ImageView.ScaleType[] all = ImageView.ScaleType.values();, +        int nextOrdinal = (curr.ordinal() + 1) % all.length;, +        ImageView.ScaleType next = all[nextOrdinal];, +        Log.w(TAG, "cycle: next=" + next);, +        imageViewRes.setScaleType(next);, +        imageViewNet.setScaleType(next);, +        reload();]
[+++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.7.0', +    <version>3.7.0</version>, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.7.0', +    <version>3.7.0</version>, +++ b/gradle.properties, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.7.0', +    <version>3.7.0</version>, +++ b/gradle.properties, +++ b/integration/gifencoder/build.gradle, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.7.0', +    <version>3.7.0</version>, +++ b/gradle.properties, +++ b/integration/gifencoder/build.gradle, +++ b/integration/okhttp/build.gradle, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.7.0', +    <version>3.7.0</version>, +++ b/gradle.properties, +++ b/integration/gifencoder/build.gradle, +++ b/integration/okhttp/build.gradle, +++ b/integration/okhttp3/build.gradle, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.7.0', +    <version>3.7.0</version>, +++ b/gradle.properties, +++ b/integration/gifencoder/build.gradle, +++ b/integration/okhttp/build.gradle, +++ b/integration/okhttp3/build.gradle, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +  private volatile Call call;, +    call = client.newCall(request);, +    call.enqueue(new okhttp3.Callback() {, +    Call local = call;, +    if (local != null) {, +      local.cancel();, +    }, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.7.0', +    <version>3.7.0</version>, +++ b/gradle.properties, +++ b/integration/gifencoder/build.gradle, +++ b/integration/okhttp/build.gradle, +++ b/integration/okhttp3/build.gradle, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +  private volatile Call call;, +    call = client.newCall(request);, +    call.enqueue(new okhttp3.Callback() {, +    Call local = call;, +    if (local != null) {, +      local.cancel();, +    }, +++ b/integration/recyclerview/build.gradle, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.7.0', +    <version>3.7.0</version>, +++ b/gradle.properties, +++ b/integration/gifencoder/build.gradle, +++ b/integration/okhttp/build.gradle, +++ b/integration/okhttp3/build.gradle, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +  private volatile Call call;, +    call = client.newCall(request);, +    call.enqueue(new okhttp3.Callback() {, +    Call local = call;, +    if (local != null) {, +      local.cancel();, +    }, +++ b/integration/recyclerview/build.gradle, +++ b/integration/volley/build.gradle, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.7.0', +    <version>3.7.0</version>, +++ b/gradle.properties, +++ b/integration/gifencoder/build.gradle, +++ b/integration/okhttp/build.gradle, +++ b/integration/okhttp3/build.gradle, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +  private volatile Call call;, +    call = client.newCall(request);, +    call.enqueue(new okhttp3.Callback() {, +    Call local = call;, +    if (local != null) {, +      local.cancel();, +    }, +++ b/integration/recyclerview/build.gradle, +++ b/integration/volley/build.gradle, +++ b/library/build.gradle, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.7.0', +    <version>3.7.0</version>, +++ b/gradle.properties, +++ b/integration/gifencoder/build.gradle, +++ b/integration/okhttp/build.gradle, +++ b/integration/okhttp3/build.gradle, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +  private volatile Call call;]
[+++ b/.travis.yml, +  - build-tools-26.0.1, +  - android-26, +  - rm -fr $HOME/.gradle/caches/*/plugin-resolution/, +    - $HOME/.android/build-cache, +, +++ b/.travis.yml, +  - build-tools-26.0.1, +  - android-26, +  - rm -fr $HOME/.gradle/caches/*/plugin-resolution/, +    - $HOME/.android/build-cache, +, +++ b/build.gradle, +        maven {, +            url "https://maven.google.com", +        }, +++ b/.travis.yml, +  - build-tools-26.0.1, +  - android-26, +  - rm -fr $HOME/.gradle/caches/*/plugin-resolution/, +    - $HOME/.android/build-cache, +, +++ b/build.gradle, +        maven {, +            url "https://maven.google.com", +        }, +++ b/gradle.properties, +ANDROID_SUPPORT_VERSION=26.0.1, +COMPILE_SDK_VERSION=26, +BUILD_TOOLS_VERSION=26.0.1, +TARGET_SDK_VERSION=26, +++ b/.travis.yml, +  - build-tools-26.0.1, +  - android-26, +  - rm -fr $HOME/.gradle/caches/*/plugin-resolution/, +    - $HOME/.android/build-cache, +, +++ b/build.gradle, +        maven {, +            url "https://maven.google.com", +        }, +++ b/gradle.properties, +ANDROID_SUPPORT_VERSION=26.0.1, +COMPILE_SDK_VERSION=26, +BUILD_TOOLS_VERSION=26.0.1, +TARGET_SDK_VERSION=26, +++ b/integration/gifencoder/build.gradle, +    testCompile "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}", +++ b/.travis.yml, +  - build-tools-26.0.1, +  - android-26, +  - rm -fr $HOME/.gradle/caches/*/plugin-resolution/, +    - $HOME/.android/build-cache, +, +++ b/build.gradle, +        maven {, +            url "https://maven.google.com", +        }, +++ b/gradle.properties, +ANDROID_SUPPORT_VERSION=26.0.1, +COMPILE_SDK_VERSION=26, +BUILD_TOOLS_VERSION=26.0.1, +TARGET_SDK_VERSION=26, +++ b/integration/gifencoder/build.gradle, +    testCompile "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}", +++ b/integration/okhttp/build.gradle, +    compile "com.android.support:support-annotations:{$ANDROID_SUPPORT_VERSION}", +++ b/.travis.yml, +  - build-tools-26.0.1, +  - android-26, +  - rm -fr $HOME/.gradle/caches/*/plugin-resolution/, +    - $HOME/.android/build-cache, +, +++ b/build.gradle, +        maven {, +            url "https://maven.google.com", +        }, +++ b/gradle.properties, +ANDROID_SUPPORT_VERSION=26.0.1, +COMPILE_SDK_VERSION=26, +BUILD_TOOLS_VERSION=26.0.1, +TARGET_SDK_VERSION=26, +++ b/integration/gifencoder/build.gradle, +    testCompile "com.android.support:support-v4:${ANDROID_SUPPORT_VERSION}", +++ b/integration/okhttp/build.gradle, +    compile "com.android.support:support-annotations:{$ANDROID_SUPPORT_VERSION}", +++ b/integration/okhttp3/build.gradle, +    compile "com.android.support:support-annotations:${ANDROID_SUPPORT_VERSION}", +++ b/.travis.yml, +  - build-tools-26.0.1, +  - android-26, +  - rm -fr $HOME/.gradle/caches/*/plugin-resolution/, +    - $HOME/.android/build-cache, +, +++ b/build.gradle, +        maven {, +            url "https://maven.google.com", +        }, +++ b/gradle.properties, +ANDROID_SUPPORT_VERSION=26.0.1]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DefaultResourceRunnerFactory.java, +    private ExecutorService diskCacheService;, +            ExecutorService diskCacheService, ExecutorService resizeService) {, +        this.diskCacheService = diskCacheService;, +        this.service = resizeService;, +                sourceRunner, diskCacheService, service, engineJob, priority);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DefaultResourceRunnerFactory.java, +    private ExecutorService diskCacheService;, +            ExecutorService diskCacheService, ExecutorService resizeService) {, +        this.diskCacheService = diskCacheService;, +        this.service = resizeService;, +                sourceRunner, diskCacheService, service, engineJob, priority);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineBuilder.java, +import android.os.Message;, +    private ExecutorService diskCacheService;, +    private ExecutorService resizeService;, +    public EngineBuilder setResizeService(ExecutorService service) {, +        resizeService = service;, +        return this;, +    }, +, +    public EngineBuilder setDiskCacheService(ExecutorService service) {, +        diskCacheService = service;, +        if (resizeService == null) {, +            resizeService = new FifoPriorityThreadPoolExecutor(cores);, +        }, +        if (diskCacheService == null) {, +            diskCacheService = new FifoPriorityThreadPoolExecutor(1);, +            bgHandler = new Handler(handlerThread.getLooper(), new Handler.Callback() {, +                @Override, +                public boolean handleMessage(Message message) {, +                    if (message.what == 0) {, +                        ((Runnable) message.obj).run();, +                        return true;, +                    }, +                    return false;, +                }, +            });, +        factory = new DefaultResourceRunnerFactory(memoryCache, diskCache, new Handler(Looper.getMainLooper()),, +                diskCacheService, resizeService);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DefaultResourceRunnerFactory.java, +    private ExecutorService diskCacheService;, +            ExecutorService diskCacheService, ExecutorService resizeService) {, +        this.diskCacheService = diskCacheService;, +        this.service = resizeService;, +                sourceRunner, diskCacheService, service, engineJob, priority);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineBuilder.java, +import android.os.Message;, +    private ExecutorService diskCacheService;, +    private ExecutorService resizeService;, +    public EngineBuilder setResizeService(ExecutorService service) {, +        resizeService = service;, +        return this;, +    }, +, +    public EngineBuilder setDiskCacheService(ExecutorService service) {, +        diskCacheService = service;, +        if (resizeService == null) {, +            resizeService = new FifoPriorityThreadPoolExecutor(cores);, +        }, +        if (diskCacheService == null) {, +            diskCacheService = new FifoPriorityThreadPoolExecutor(1);, +            bgHandler = new Handler(handlerThread.getLooper(), new Handler.Callback() {, +                @Override, +                public boolean handleMessage(Message message) {, +                    if (message.what == 0) {, +                        ((Runnable) message.obj).run();, +                        return true;, +                    }, +                    return false;, +                }, +            });, +        factory = new DefaultResourceRunnerFactory(memoryCache, diskCache, new Handler(Looper.getMainLooper()),, +                diskCacheService, resizeService);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceRunner.java, +import com.bumptech.glide.Priority;, +import com.bumptech.glide.load.engine.executor.Prioritized;, +public class ResourceRunner<Z, R> implements Runnable, Prioritized {, +    private final Transformation<Z> transformation;, +    private final ResourceTranscoder<Z, R> transcoder;, +    private final Priority priority;, +    private final ExecutorService diskCacheService;, +    private final ExecutorService resizeService;, +            ResourceTranscoder<Z, R> transcoder, SourceResourceRunner sourceRunner, ExecutorService diskCacheService,, +            ExecutorService resizeService, EngineJob job, Priority priority) {, +        this.diskCacheService = diskCacheService;, +        this.resizeService = resizeService;, +        this.priority = priority;, +        future = diskCacheService.submit(this);, +            future = resizeService.submit(sourceRunner);, +, +    @Override, +    public int getPriority() {, +        return priority.ordinal();, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DefaultResourceRunnerFactory.java, +    private ExecutorService diskCacheService;, +            ExecutorService diskCacheService, ExecutorService resizeService) {, +        this.diskCacheService = diskCacheService;, +        this.service = resizeService;]
[+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java, +import org.robolectric.RobolectricTestRunner;, +  public void testReturnsSizeFromDrawable() {, +    when(drawable.getSize()).thenReturn(size);, +    assertEquals(size, resource.getSize());, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java, +import org.robolectric.RobolectricTestRunner;, +  public void testReturnsSizeFromDrawable() {, +    when(drawable.getSize()).thenReturn(size);, +    assertEquals(size, resource.getSize());, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +import static com.google.common.truth.Truth.assertThat;, +import org.robolectric.RobolectricTestRunner;, +, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +, +  @Mock private Drawable.Callback cb;, +  @Mock private BitmapPool bitmapPool;, +  @Mock private GifFrameLoader frameLoader;, +  @Mock private Paint paint;, +  @Mock private Transformation<Bitmap> transformation;, +    MockitoAnnotations.initMocks(this);, +    drawable = new GifDrawable(RuntimeEnvironment.application, frameLoader, bitmapPool, paint);, +    when(frameLoader.getWidth()).thenReturn(frameWidth);, +    when(frameLoader.getHeight()).thenReturn(frameHeight);, +    when(frameLoader.getCurrentFrame()).thenReturn(firstFrame);, +    drawable = new GifDrawable(RuntimeEnvironment.application, frameLoader, bitmapPool, paint);, +    verify(frameLoader).subscribe(eq(drawable));, +    verify(frameLoader).subscribe(eq(drawable));, +    verify(frameLoader, never()).subscribe(eq(drawable));, +    when(frameLoader.getFrameCount()).thenReturn(1);, +    verify(frameLoader, never()).subscribe(eq(drawable));, +    when(frameLoader.getFrameCount()).thenReturn(1);, +    verify(frameLoader, times(1)).subscribe(eq(drawable));, +    verify(frameLoader).unsubscribe(eq(drawable));, +  public void testUnsubscribesWhenCurrentFinishesIfHasNoCallbackAndIsAtLeastAtHoneycomb() {, +    verify(frameLoader).unsubscribe(eq(drawable));, +    when(frameLoader.getFrameCount()).thenReturn(expected);, +  public void testReturnsSizeFromFrameLoader() {, +    int size = 1243;, +    when(frameLoader.getSize()).thenReturn(size);, +, +    assertThat(drawable.getSize()).isEqualTo(size);, +  }, +, +  @Test, +        new GifDrawable(RuntimeEnvironment.application, provider, bitmapPool,, +            ByteBuffer.allocate(10), transformation, 100, 100, gifHeader, firstFrame);, +  public void testReturnsFrameWidthAndHeightForIntrinsicDimensions() {, +    when(frameLoader.getFrameCount()).thenReturn(frameCount);, +    when(frameLoader.getFrameCount()).thenReturn(frameCount);, +    when(frameLoader.getFrameCount()).thenReturn(frameCount);, +    when(frameLoader.getFrameCount()).thenReturn(frameCount);, +    when(frameLoader.getFrameCount()).thenReturn(2);, +    when(frameLoader.getFrameCount()).thenReturn(frameCount);, +    when(frameLoader.getLoopCount()).thenReturn(loopCount);, +    when(frameLoader.getFrameCount()).thenReturn(frameCount);, +    verify(frameLoader).setFrameTransformation(eq(transformation), eq(bitmap));, +  public void testThrowsIfConstructedWithNullFirstFrame() {, +        bitmapPool, ByteBuffer.allocate(10), transformation, 100, 100,, +        mock(GifHeader.class), null);, +    Bitmap bitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +    drawable.setFrameTransformation(newTransformation, bitmap);, +    verify(frameLoader).setFrameTransformation(eq(newTransformation), eq(bitmap));, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableResourceTest.java, +import org.robolectric.RobolectricTestRunner;, +  public void testReturnsSizeFromDrawable() {, +    when(drawable.getSize()).thenReturn(size);, +    assertEquals(size, resource.getSize());, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +import static com.google.common.truth.Truth.assertThat;, +import org.robolectric.RobolectricTestRunner;, +, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +, +  @Mock private Drawable.Callback cb;, +  @Mock private BitmapPool bitmapPool;, +  @Mock private GifFrameLoader frameLoader;, +  @Mock private Paint paint;, +  @Mock private Transformation<Bitmap> transformation;, +    MockitoAnnotations.initMocks(this);, +    drawable = new GifDrawable(RuntimeEnvironment.application, frameLoader, bitmapPool, paint);, +    when(frameLoader.getWidth()).thenReturn(frameWidth);, +    when(frameLoader.getHeight()).thenReturn(frameHeight);, +    when(frameLoader.getCurrentFrame()).thenReturn(firstFrame);, +    drawable = new GifDrawable(RuntimeEnvironment.application, frameLoader, bitmapPool, paint);, +    verify(frameLoader).subscribe(eq(drawable));, +    verify(frameLoader).subscribe(eq(drawable));, +    verify(frameLoader, never()).subscribe(eq(drawable));, +    when(frameLoader.getFrameCount()).thenReturn(1);, +    verify(frameLoader, never()).subscribe(eq(drawable));, +    when(frameLoader.getFrameCount()).thenReturn(1);, +    verify(frameLoader, times(1)).subscribe(eq(drawable));, +    verify(frameLoader).unsubscribe(eq(drawable));, +  public void testUnsubscribesWhenCurrentFinishesIfHasNoCallbackAndIsAtLeastAtHoneycomb() {, +    verify(frameLoader).unsubscribe(eq(drawable));, +    when(frameLoader.getFrameCount()).thenReturn(expected);, +  public void testReturnsSizeFromFrameLoader() {]
[+++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.load.Encoder;, +, +    @Override, +    public BitmapRequestBuilder<ModelType, TranscodeType> thumbnail(, +            GenericRequestBuilder<ModelType, ImageVideoWrapper, Bitmap, TranscodeType> thumbnailRequest) {, +        super.thumbnail(thumbnailRequest);, +        return this;, +    }, +, +    @Override, +    public BitmapRequestBuilder<ModelType, TranscodeType> sourceEncoder(Encoder<ImageVideoWrapper> sourceEncoder) {, +        super.sourceEncoder(sourceEncoder);, +        return this;, +    }, +, +    @Override, +    public BitmapRequestBuilder<ModelType, TranscodeType> cacheSource(boolean cacheSource) {, +        super.cacheSource(cacheSource);, +        return this;, +    }, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.load.Encoder;, +, +    @Override, +    public BitmapRequestBuilder<ModelType, TranscodeType> thumbnail(, +            GenericRequestBuilder<ModelType, ImageVideoWrapper, Bitmap, TranscodeType> thumbnailRequest) {, +        super.thumbnail(thumbnailRequest);, +        return this;, +    }, +, +    @Override, +    public BitmapRequestBuilder<ModelType, TranscodeType> sourceEncoder(Encoder<ImageVideoWrapper> sourceEncoder) {, +        super.sourceEncoder(sourceEncoder);, +        return this;, +    }, +, +    @Override, +    public BitmapRequestBuilder<ModelType, TranscodeType> cacheSource(boolean cacheSource) {, +        super.cacheSource(cacheSource);, +        return this;, +    }, +++ b/library/src/main/java/com/bumptech/glide/DataLoadProvider.java, +import com.bumptech.glide.load.Encoder;, +    public Encoder<T> getSourceEncoder();, +, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.load.Encoder;, +, +    @Override, +    public BitmapRequestBuilder<ModelType, TranscodeType> thumbnail(, +            GenericRequestBuilder<ModelType, ImageVideoWrapper, Bitmap, TranscodeType> thumbnailRequest) {, +        super.thumbnail(thumbnailRequest);, +        return this;, +    }, +, +    @Override, +    public BitmapRequestBuilder<ModelType, TranscodeType> sourceEncoder(Encoder<ImageVideoWrapper> sourceEncoder) {, +        super.sourceEncoder(sourceEncoder);, +        return this;, +    }, +, +    @Override, +    public BitmapRequestBuilder<ModelType, TranscodeType> cacheSource(boolean cacheSource) {, +        super.cacheSource(cacheSource);, +        return this;, +    }, +++ b/library/src/main/java/com/bumptech/glide/DataLoadProvider.java, +import com.bumptech.glide.load.Encoder;, +    public Encoder<T> getSourceEncoder();, +, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.load.Encoder;, +, +    @Override, +    public DrawableRequestBuilder<ModelType> cacheSource(boolean cacheSource) {, +        super.cacheSource(cacheSource);, +        return this;, +    }, +, +    @Override, +    public DrawableRequestBuilder<ModelType> sourceEncoder(Encoder<ImageVideoWrapper> sourceEncoder) {, +        super.sourceEncoder(sourceEncoder);, +        return this;, +    }, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.load.Encoder;, +, +    @Override, +    public BitmapRequestBuilder<ModelType, TranscodeType> thumbnail(, +            GenericRequestBuilder<ModelType, ImageVideoWrapper, Bitmap, TranscodeType> thumbnailRequest) {, +        super.thumbnail(thumbnailRequest);, +        return this;, +    }, +, +    @Override, +    public BitmapRequestBuilder<ModelType, TranscodeType> sourceEncoder(Encoder<ImageVideoWrapper> sourceEncoder) {, +        super.sourceEncoder(sourceEncoder);, +        return this;, +    }]
[+++ b/library/src/androidTest/java/com/bumptech/glide/resize/load/ExifTest.java, +      assertEquals(new ImageHeaderParser(is, byteArrayPool).getOrientation(),, +, +  @Test, +  public void testHandlesInexactSizesInByteArrayPools() {, +    for (int i = 1; i <= 8; i++) {, +      byteArrayPool.put(new byte[LruByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);, +      assertOrientation("Portrait", i);, +    }, +    for (int i = 1; i <= 8; i++) {, +      byteArrayPool.put(new byte[LruByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);, +      assertOrientation("Landscape", i);, +    }, +  }, +++ b/library/src/androidTest/java/com/bumptech/glide/resize/load/ExifTest.java, +      assertEquals(new ImageHeaderParser(is, byteArrayPool).getOrientation(),, +, +  @Test, +  public void testHandlesInexactSizesInByteArrayPools() {, +    for (int i = 1; i <= 8; i++) {, +      byteArrayPool.put(new byte[LruByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);, +      assertOrientation("Portrait", i);, +    }, +    for (int i = 1; i <= 8; i++) {, +      byteArrayPool.put(new byte[LruByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);, +      assertOrientation("Landscape", i);, +    }, +  }, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java, +    int orientation = ImageHeaderParser.UNKNOWN_ORIENTATION;, +++ b/library/src/androidTest/java/com/bumptech/glide/resize/load/ExifTest.java, +      assertEquals(new ImageHeaderParser(is, byteArrayPool).getOrientation(),, +, +  @Test, +  public void testHandlesInexactSizesInByteArrayPools() {, +    for (int i = 1; i <= 8; i++) {, +      byteArrayPool.put(new byte[LruByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);, +      assertOrientation("Portrait", i);, +    }, +    for (int i = 1; i <= 8; i++) {, +      byteArrayPool.put(new byte[LruByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);, +      assertOrientation("Landscape", i);, +    }, +  }, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java, +    int orientation = ImageHeaderParser.UNKNOWN_ORIENTATION;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +    int orientation = ImageHeaderParser.UNKNOWN_ORIENTATION;, +++ b/library/src/androidTest/java/com/bumptech/glide/resize/load/ExifTest.java, +      assertEquals(new ImageHeaderParser(is, byteArrayPool).getOrientation(),, +, +  @Test, +  public void testHandlesInexactSizesInByteArrayPools() {, +    for (int i = 1; i <= 8; i++) {, +      byteArrayPool.put(new byte[LruByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);, +      assertOrientation("Portrait", i);, +    }, +    for (int i = 1; i <= 8; i++) {, +      byteArrayPool.put(new byte[LruByteArrayPool.STANDARD_BUFFER_SIZE_BYTES]);, +      assertOrientation("Landscape", i);, +    }, +  }, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java, +    int orientation = ImageHeaderParser.UNKNOWN_ORIENTATION;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +    int orientation = ImageHeaderParser.UNKNOWN_ORIENTATION;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java, +  /**, +   * A constant indicating we were unable to parse the orientation from the image either because, +   * no exif segment containing orientation data existed, or because of an I/O error attempting to, +   * read the exif segment., +   */, +  public static final int UNKNOWN_ORIENTATION = -1;, +      if (Log.isLoggable(TAG, Log.DEBUG)) {, +        Log.d(TAG, "Parser doesn't handle magic number: " + magicNumber);, +      }, +      return UNKNOWN_ORIENTATION;, +      int exifSegmentLength = moveToExifSegmentAndGetLength();, +      if (exifSegmentLength == -1) {, +        if (Log.isLoggable(TAG, Log.DEBUG)) {, +          Log.d(TAG, "Failed to parse exif segment length, or exif segment not found");, +        }, +        return UNKNOWN_ORIENTATION;, +      }, +      byte[] exifData = byteArrayPool.get(exifSegmentLength);, +      try {, +        return parseExifSegment(exifData, exifSegmentLength);, +      } finally {, +        byteArrayPool.put(exifData);, +      }, +    }, +  }, +, +  private int parseExifSegment(byte[] tempArray, int exifSegmentLength) throws IOException {, +    int read = reader.read(tempArray, exifSegmentLength);, +    if (read != exifSegmentLength) {, +      if (Log.isLoggable(TAG, Log.DEBUG)) {, +        Log.d(TAG, "Unable to read exif segment data", +            + ", length: " + exifSegmentLength, +            + ", actually read: " + read);]
[+++ b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java, +import android.support.annotation.Nullable;, +, +  @Nullable, +  public ErrorRequestCoordinator(@Nullable RequestCoordinator coordinator) {, +    primary.clear();, +      coordinator.onRequestFailed(this);, +++ b/library/src/main/java/com/bumptech/glide/request/ErrorRequestCoordinator.java, +import android.support.annotation.Nullable;, +, +  @Nullable, +  public ErrorRequestCoordinator(@Nullable RequestCoordinator coordinator) {, +    primary.clear();, +      coordinator.onRequestFailed(this);, +++ b/library/src/test/java/com/bumptech/glide/request/ErrorRequestCoordinatorTest.java, +package com.bumptech.glide.request;, +, +import static com.google.common.truth.Truth.assertThat;, +import static org.mockito.Matchers.any;, +import static org.mockito.Mockito.never;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +, +@RunWith(JUnit4.class), +public class ErrorRequestCoordinatorTest {, +, +  @Mock private Request primary;, +  @Mock private Request error;, +  @Mock private RequestCoordinator parent;, +  private ErrorRequestCoordinator coordinator;, +, +  @Before, +  public void setUp() {, +    MockitoAnnotations.initMocks(this);, +    coordinator = new ErrorRequestCoordinator(/*coordinator=*/ null);, +    coordinator.setRequests(primary, error);, +  }, +, +  @Test, +  public void begin_startsPrimary() {, +    coordinator.begin();, +    verify(primary).begin();, +  }, +, +  @Test, +  public void begin_whenPrimaryIsAlreadyRunning_doesNotStartPrimaryAgain() {, +    when(primary.isRunning()).thenReturn(true);, +    coordinator.begin();, +    verify(primary, never()).begin();, +  }, +, +  @Test, +  public void pause_whenPrimaryHasNotFailed_pausesPrimary() {, +    coordinator.pause();, +    verify(primary).pause();, +  }, +, +  @Test, +  public void pause_whenPrimaryHasFailed_doesNotPausePrimary() {, +    when(primary.isFailed()).thenReturn(true);, +    coordinator.pause();, +    verify(primary, never()).pause();, +  }, +, +  @Test, +  public void pause_whenErrorIsRunning_pausesError() {, +    when(error.isRunning()).thenReturn(true);, +    coordinator.pause();, +    verify(error).pause();, +  }, +, +  @Test, +  public void pause_whenErrorIsNotRunning_doesNotPauseError() {, +    coordinator.pause();, +    verify(error, never()).pause();, +  }, +, +  @Test, +  public void clear_whenPrimaryHasNotFailed_clearsPrimary() {, +    coordinator.clear();, +    verify(primary).clear();, +  }, +, +  @Test, +  public void clear_whenPrimaryHasNotFailed_doesNotClearError() {, +    coordinator.clear();, +    verify(error, never()).clear();, +  }, +, +  @Test, +  public void clear_whenPrimaryHasFailed_clearsError() {, +    when(primary.isFailed()).thenReturn(true);, +    coordinator.clear();]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +   *, +   * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(Target)}., +  @Deprecated, +   *, +   * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(int, int)}., +  @Deprecated, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +   *, +   * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(Target)}., +  @Deprecated, +   *, +   * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(int, int)}., +  @Deprecated, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;, +import static com.bumptech.glide.request.RequestOptions.skipMemoryCacheOf;, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +import java.io.File;, +, +  private static final RequestOptions DOWNLOAD_ONLY_OPTIONS =, +      diskCacheStrategyOf(DiskCacheStrategy.DATA).priority(Priority.LOW), +          .skipMemoryCache(true);, +, +   * Attempts always load the resource into the cache and return the {@link File} containing the, +   * cached source data., +   *, +   * <p>This method is designed to work for remote data that is or will be cached using {@link, +   * com.bumptech.glide.load.engine.DiskCacheStrategy#DATA}. As a result, specifying a, +   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy} on this request is generally not, +   * recommended., +   *, +   * @return A new request builder for downloading content to cache and returning the cache File., +   */, +  public RequestBuilder<File> downloadOnly() {, +    return as(File.class).apply(DOWNLOAD_ONLY_OPTIONS);, +  }, +, +  /**, +   * Attempts to always load a {@link File} containing the resource, either using a file path, +   * obtained from the media store (for local images/videos), or using Glide's disk cache, +   * (for remote images/videos)., +   *, +   * <p>For remote content, prefer {@link #downloadOnly()}., +   *, +   * @return A new request builder for obtaining File paths to content., +   */, +  public RequestBuilder<File> asFile() {, +    return as(File.class).apply(skipMemoryCacheOf(true));, +  }, +, +  /**, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +   *, +   * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(Target)}., +  @Deprecated, +   *, +   * @deprecated Use {@link RequestManager#downloadOnly()} and {@link #into(int, int)}., +  @Deprecated, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +import static com.bumptech.glide.request.RequestOptions.diskCacheStrategyOf;, +import static com.bumptech.glide.request.RequestOptions.skipMemoryCacheOf;, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +import java.io.File;, +, +  private static final RequestOptions DOWNLOAD_ONLY_OPTIONS =, +      diskCacheStrategyOf(DiskCacheStrategy.DATA).priority(Priority.LOW), +          .skipMemoryCache(true);, +, +   * Attempts always load the resource into the cache and return the {@link File} containing the, +   * cached source data., +   *, +   * <p>This method is designed to work for remote data that is or will be cached using {@link, +   * com.bumptech.glide.load.engine.DiskCacheStrategy#DATA}. As a result, specifying a, +   * {@link com.bumptech.glide.load.engine.DiskCacheStrategy} on this request is generally not, +   * recommended., +   *, +   * @return A new request builder for downloading content to cache and returning the cache File., +   */, +  public RequestBuilder<File> downloadOnly() {, +    return as(File.class).apply(DOWNLOAD_ONLY_OPTIONS);, +  }, +, +  /**, +   * Attempts to always load a {@link File} containing the resource, either using a file path, +   * obtained from the media store (for local images/videos), or using Glide's disk cache, +   * (for remote images/videos)., +   *, +   * <p>For remote content, prefer {@link #downloadOnly()}., +   *, +   * @return A new request builder for obtaining File paths to content., +   */, +  public RequestBuilder<File> asFile() {, +    return as(File.class).apply(skipMemoryCacheOf(true));, +  }, +, +  /**, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java, +            .downloadOnly(), +            .into(Api.SQUARE_THUMB_SIZE, Api.SQUARE_THUMB_SIZE);]
[+++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +import android.support.annotation.NonNull;, +  public ReEncodingGifResourceEncoder(@NonNull Context context, @NonNull BitmapPool bitmapPool) {, +  public EncodeStrategy getEncodeStrategy(@NonNull Options options) {, +  public boolean encode(@NonNull Resource<GifDrawable> resource, @NonNull File file,, +      @NonNull Options options) {, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +import android.support.annotation.NonNull;, +  public ReEncodingGifResourceEncoder(@NonNull Context context, @NonNull BitmapPool bitmapPool) {, +  public EncodeStrategy getEncodeStrategy(@NonNull Options options) {, +  public boolean encode(@NonNull Resource<GifDrawable> resource, @NonNull File file,, +      @NonNull Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java, +import android.support.annotation.NonNull;, +  boolean encode(@NonNull T data, @NonNull File file, @NonNull Options options);, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +import android.support.annotation.NonNull;, +  public ReEncodingGifResourceEncoder(@NonNull Context context, @NonNull BitmapPool bitmapPool) {, +  public EncodeStrategy getEncodeStrategy(@NonNull Options options) {, +  public boolean encode(@NonNull Resource<GifDrawable> resource, @NonNull File file,, +      @NonNull Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java, +import android.support.annotation.NonNull;, +  boolean encode(@NonNull T data, @NonNull File file, @NonNull Options options);, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +import android.support.annotation.NonNull;, +  @NonNull, +      @NonNull Context context, @NonNull Resource<T> resource, int outWidth, int outHeight) {, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +import android.support.annotation.NonNull;, +  public ReEncodingGifResourceEncoder(@NonNull Context context, @NonNull BitmapPool bitmapPool) {, +  public EncodeStrategy getEncodeStrategy(@NonNull Options options) {, +  public boolean encode(@NonNull Resource<GifDrawable> resource, @NonNull File file,, +      @NonNull Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java, +import android.support.annotation.NonNull;, +  boolean encode(@NonNull T data, @NonNull File file, @NonNull Options options);, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +import android.support.annotation.NonNull;, +  @NonNull, +      @NonNull Context context, @NonNull Resource<T> resource, int outWidth, int outHeight) {, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java, +import android.support.annotation.NonNull;, +  EncodeStrategy getEncodeStrategy(@NonNull Options options);, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +import android.support.annotation.NonNull;, +  public ReEncodingGifResourceEncoder(@NonNull Context context, @NonNull BitmapPool bitmapPool) {, +  public EncodeStrategy getEncodeStrategy(@NonNull Options options) {, +  public boolean encode(@NonNull Resource<GifDrawable> resource, @NonNull File file,, +      @NonNull Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java, +import android.support.annotation.NonNull;, +  boolean encode(@NonNull T data, @NonNull File file, @NonNull Options options);, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +import android.support.annotation.NonNull;, +  @NonNull, +      @NonNull Context context, @NonNull Resource<T> resource, int outWidth, int outHeight) {, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java, +import android.support.annotation.NonNull;, +  EncodeStrategy getEncodeStrategy(@NonNull Options options);, +++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java, +import android.support.annotation.NonNull;, +  @NonNull, +  Resource<T> transform(@NonNull Context context, @NonNull Resource<T> resource,, +      int outWidth, int outHeight);, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +import android.support.annotation.NonNull;, +  public ReEncodingGifResourceEncoder(@NonNull Context context, @NonNull BitmapPool bitmapPool) {, +  public EncodeStrategy getEncodeStrategy(@NonNull Options options) {, +  public boolean encode(@NonNull Resource<GifDrawable> resource, @NonNull File file,, +      @NonNull Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java, +import android.support.annotation.NonNull;, +  boolean encode(@NonNull T data, @NonNull File file, @NonNull Options options);, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +import android.support.annotation.NonNull;, +  @NonNull, +      @NonNull Context context, @NonNull Resource<T> resource, int outWidth, int outHeight) {, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java, +import android.support.annotation.NonNull;, +  EncodeStrategy getEncodeStrategy(@NonNull Options options);, +++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java, +import android.support.annotation.NonNull;, +  @NonNull, +  Resource<T> transform(@NonNull Context context, @NonNull Resource<T> resource,, +      int outWidth, int outHeight);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheWriter.java, +import android.support.annotation.NonNull;, +  public boolean write(@NonNull File file) {, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +import android.support.annotation.NonNull;, +  public ReEncodingGifResourceEncoder(@NonNull Context context, @NonNull BitmapPool bitmapPool) {, +  public EncodeStrategy getEncodeStrategy(@NonNull Options options) {, +  public boolean encode(@NonNull Resource<GifDrawable> resource, @NonNull File file,, +      @NonNull Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java, +import android.support.annotation.NonNull;, +  boolean encode(@NonNull T data, @NonNull File file, @NonNull Options options);, +++ b/library/src/main/java/com/bumptech/glide/load/MultiTransformation.java, +import android.support.annotation.NonNull;]
[+++ b/.travis.yml, +sudo: false]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBitmapTest.java, +package com.bumptech.glide;, +, +, +import static com.google.common.truth.Truth.assertThat;, +, +import android.content.Context;, +import android.graphics.Bitmap;, +import android.graphics.BitmapFactory;, +import android.graphics.drawable.Drawable;, +import android.support.test.InstrumentationRegistry;, +import android.support.test.runner.AndroidJUnit4;, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPoolAdapter;, +import com.bumptech.glide.load.engine.cache.MemoryCacheAdapter;, +import com.bumptech.glide.request.FutureTarget;, +import com.bumptech.glide.test.ConcurrencyHelper;, +import com.bumptech.glide.test.GlideApp;, +import com.bumptech.glide.test.ResourceIds;, +import com.bumptech.glide.test.TearDownGlide;, +import org.junit.Before;, +import org.junit.Rule;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +, +@RunWith(AndroidJUnit4.class), +public class LoadBitmapTest {, +  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();, +  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();, +  private Context context;, +, +  @Before, +  public void setUp() {, +    context = InstrumentationRegistry.getTargetContext();, +  }, +, +  @Test, +  public void clearFromRequestBuilder_asDrawable_withLoadedBitmap_doesNotRecycleBitmap() {, +    Glide.init(context, new GlideBuilder(), +        .setMemoryCache(new MemoryCacheAdapter()), +        .setBitmapPool(new BitmapPoolAdapter()));, +    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);, +    FutureTarget<Drawable> target =, +        concurrency.wait(, +            GlideApp.with(context), +                .asDrawable(), +                .load(bitmap), +                .submit(100, 100));, +    Glide.with(context).clear(target);, +, +    // Allow Glide's resource recycler to run on the main thread., +    concurrency.pokeMainThread();, +, +    assertThat(bitmap.isRecycled()).isFalse();, +  }, +, +  @Test, +  public void transformFromRequestBuilder_asDrawable_withLoadedBitmap_doesNotRecycleBitmap() {, +    Glide.init(context, new GlideBuilder(), +        .setMemoryCache(new MemoryCacheAdapter()), +        .setBitmapPool(new BitmapPoolAdapter()));, +    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);, +    concurrency.wait(, +        GlideApp.with(context), +            .asDrawable(), +            .load(bitmap), +            .centerCrop(), +            .submit(100, 100));, +, +    assertThat(bitmap.isRecycled()).isFalse();, +  }, +, +  @Test, +  public void clearFromRequestManager_withLoadedBitmap_doesNotRecycleBitmap() {, +    Glide.init(context, new GlideBuilder(), +        .setMemoryCache(new MemoryCacheAdapter()), +        .setBitmapPool(new BitmapPoolAdapter()));, +    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);, +    FutureTarget<Drawable> target =, +        concurrency.wait(, +            GlideApp.with(context), +                .load(bitmap), +                .submit(100, 100));, +    Glide.with(context).clear(target);, +, +    // Allow Glide's resource recycler to run on the main thread., +    concurrency.pokeMainThread();, +, +    assertThat(bitmap.isRecycled()).isFalse();, +  }, +, +  @Test, +  public void transformFromRequestManager_withLoadedBitmap_doesNotRecycleBitmap() {, +    Glide.init(context, new GlideBuilder(), +        .setMemoryCache(new MemoryCacheAdapter()), +        .setBitmapPool(new BitmapPoolAdapter()));, +    Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), ResourceIds.raw.canonical);, +    concurrency.wait(, +        GlideApp.with(context), +            .load(bitmap), +            .centerCrop()]
[+++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +            previous.recycle();, +        return GenericRequest.obtain(, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +            previous.recycle();, +        return GenericRequest.obtain(, +++ b/library/src/main/java/com/bumptech/glide/request/GenericRequest.java, +import java.util.ArrayDeque;, +import java.util.Queue;, +    private static final String TAG = "GenericRequest";, +    private int placeholderResourceId;, +    private int errorResourceId;, +    private Context context;, +    private Transformation<Z> transformation;, +    private LoadProvider<A, T, Z, R> loadProvider;, +    private RequestCoordinator requestCoordinator;, +    private A model;, +    private Class<R> transcodeClass;, +    private boolean isMemoryCacheable;, +    private Priority priority;, +    private Target<R> target;, +    private RequestListener<A, R> requestListener;, +    private float sizeMultiplier;, +    private Engine engine;, +    private GlideAnimationFactory<R> animationFactory;, +    private int overrideWidth;, +    private int overrideHeight;, +    private String tag = String.valueOf(hashCode());, +    private static final Queue<GenericRequest> queue = new ArrayDeque<GenericRequest>();, +, +    @SuppressWarnings("unchecked"), +    public static <A, T, Z, R> GenericRequest<A, T, Z, R> obtain(, +            LoadProvider<A, T, Z, R> loadProvider,, +            A model,, +            Context context,, +            Priority priority,, +            Target<R> target,, +            float sizeMultiplier,, +            Drawable placeholderDrawable,, +            int placeholderResourceId,, +            Drawable errorDrawable,, +            int errorResourceId,, +            RequestListener<A, R> requestListener,, +            RequestCoordinator requestCoordinator,, +            Engine engine,, +            Transformation<Z> transformation,, +            Class<R> transcodeClass,, +            boolean isMemoryCacheable,, +            GlideAnimationFactory<R> animationFactory,, +            int overrideWidth,, +            int overrideHeight) {, +        GenericRequest request = queue.poll();, +        if (request == null) {, +            request = new GenericRequest();, +        }, +        request.init(loadProvider,, +                model,, +                context,, +                priority,, +                target,, +                sizeMultiplier,, +                placeholderDrawable,, +                placeholderResourceId,, +                errorDrawable,, +                errorResourceId,, +                requestListener,, +                requestCoordinator,, +                engine,, +                transformation,, +                transcodeClass,, +                isMemoryCacheable,, +                animationFactory,, +                overrideWidth,, +                overrideHeight);, +        return request;, +    }, +, +    private GenericRequest() {, +, +    }, +, +    @Override, +    public void recycle() {, +        loadProvider = null;, +        model = null;, +        context = null;, +        target = null;, +        placeholderDrawable = null;, +        errorDrawable = null;, +        requestListener = null;, +        requestCoordinator = null;, +        engine = null;, +        transformation = null;, +        animationFactory = null;, +        isCancelled = false;, +        isError = false;, +        loadedFromMemoryCache = false;, +        loadStatus = null;, +        isRunning = false;, +        queue.offer(this);]
[+++ b/gradle.properties, +VOLLEY_VERSION=1.0.0, +++ b/gradle.properties, +VOLLEY_VERSION=1.0.0, +++ b/integration/volley/build.gradle, +    compile "com.android.volley:volley:${VOLLEY_VERSION}"]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java, +  // See https://bit.ly/2IW5AmI, +  private static boolean isSamsungGalaxyS7Edge() {, +    return Build.MODEL.startsWith("SM-G935") || Build.MODEL.startsWith("SM-G930");, +  }, +, +   *, +   * <p>Reduced on S7 Edge devices due to  https://github.com/bumptech/glide/issues/3275., +  private static final int MAXIMUM_FDS_FOR_HARDWARE_CONFIGS = isSamsungGalaxyS7Edge() ? 350 : 700;]
[+++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +import com.bumptech.glide.request.target.ViewTarget;, +  public <X> ViewTarget<ImageView, X> buildImageViewTarget(, +      ImageView imageView, Class<X> transcodeClass) {, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +import com.bumptech.glide.request.target.ViewTarget;, +  public <X> ViewTarget<ImageView, X> buildImageViewTarget(, +      ImageView imageView, Class<X> transcodeClass) {, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import com.bumptech.glide.request.target.ViewTarget;, +  public ViewTarget<ImageView, TranscodeType> into(ImageView view) {, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +import com.bumptech.glide.request.target.ViewTarget;, +  public <X> ViewTarget<ImageView, X> buildImageViewTarget(, +      ImageView imageView, Class<X> transcodeClass) {, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import com.bumptech.glide.request.target.ViewTarget;, +  public ViewTarget<ImageView, TranscodeType> into(ImageView view) {, +++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java, +  public <Z> ViewTarget<ImageView, Z> buildTarget(ImageView view, Class<Z> clazz) {, +      return (ViewTarget<ImageView, Z>) new BitmapImageViewTarget(view);, +      return (ViewTarget<ImageView, Z>) new DrawableImageViewTarget(view);, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +import com.bumptech.glide.request.target.ViewTarget;, +  public <X> ViewTarget<ImageView, X> buildImageViewTarget(, +      ImageView imageView, Class<X> transcodeClass) {, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +import com.bumptech.glide.request.target.ViewTarget;, +  public ViewTarget<ImageView, TranscodeType> into(ImageView view) {, +++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTargetFactory.java, +  public <Z> ViewTarget<ImageView, Z> buildTarget(ImageView view, Class<Z> clazz) {, +      return (ViewTarget<ImageView, Z>) new BitmapImageViewTarget(view);, +      return (ViewTarget<ImageView, Z>) new DrawableImageViewTarget(view);, +++ b/library/src/main/java/com/bumptech/glide/request/target/ViewTarget.java, +import android.support.annotation.CallSuper;, +import android.view.View.OnAttachStateChangeListener;, +  @Nullable, +  private OnAttachStateChangeListener attachStateListener;, +  private boolean isClearedByUs;, +  private boolean isAttachStateListenerAdded;, +, +   * Clears the {@link View}'s {@link Request} when the {@link View} is detached from its, +   * {@link android.view.Window} and restarts the {@link Request} when the {@link View} is, +   * re-attached from its {@link android.view.Window}., +   *, +   * <p>This is an experimental API that may be removed in a future version., +   *, +   * <p>Using this method can save memory by allowing Glide to more eagerly clear resources when, +   * transitioning screens or swapping adapters in scrolling views. However it also substantially, +   * increases the odds that images will not be in memory if users subsequently return to a screen, +   * where images were previously loaded. Whether or not this happens will depend on the number, +   * of images loaded in the new screen and the size of the memory cache. Increasing the size of, +   * the memory cache can improve this behavior but it largely negates the memory benefits of using, +   * this method., +   *, +   * <p>Use this method with caution and measure your memory usage to ensure that it's actually, +   * improving your memory usage in the cases you care about., +   */, +  // Public API., +  @SuppressWarnings({"UnusedReturnValue", "WeakerAccess"}), +  public final ViewTarget<T, Z> clearOnDetach() {, +    if (attachStateListener != null) {, +      return this;, +    }, +    attachStateListener = new OnAttachStateChangeListener() {, +      @Override, +      public void onViewAttachedToWindow(View v) {, +        Request request = getRequest();, +        if (request != null && request.isPaused()) {, +          request.begin();, +        }, +      }, +, +      @Override, +      public void onViewDetachedFromWindow(View v) {, +        Request request = getRequest();, +        if (request != null && !request.isCancelled() && !request.isPaused()) {, +          isClearedByUs = true;, +          request.pause();, +          isClearedByUs = false;, +        }, +      }, +    };, +    maybeAddAttachStateListener();, +    return this;, +  }, +, +  @CallSuper, +  @Override, +  public void onLoadStarted(@Nullable Drawable placeholder) {, +    super.onLoadStarted(placeholder);, +    maybeAddAttachStateListener();, +  }, +, +  private void maybeAddAttachStateListener() {, +    if (attachStateListener == null || isAttachStateListenerAdded) {, +      return;, +    }, +, +    view.addOnAttachStateChangeListener(attachStateListener);]
[+++ b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java, +++ b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +import android.annotation.TargetApi;, +import android.content.UriMatcher;, +import android.os.Build;, +import android.provider.ContactsContract;, +  /**, +   * A lookup uri (e.g. content://com.android.contacts/contacts/lookup/3570i61d948d30808e537), +   */, +  private static final int ID_CONTACTS_LOOKUP = 1;, +  /**, +   * A contact thumbnail uri (e.g. content://com.android.contacts/contacts/38/photo), +   */, +  private static final int ID_CONTACTS_THUMBNAIL = 2;, +  /**, +   * A contact uri (e.g. content://com.android.contacts/contacts/38), +   */, +  private static final int ID_CONTACTS_CONTACT = 3;, +  /**, +   * A contact display photo (high resolution) uri, +   * (e.g. content://com.android.contacts/5/display_photo), +   */, +  private static final int ID_CONTACTS_PHOTO = 4;, +  /**, +   * Match the incoming Uri for special cases which we can handle nicely., +   */, +  private static final UriMatcher URI_MATCHER;, +, +  static {, +    URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);, +    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/lookup/*/#", ID_CONTACTS_LOOKUP);, +    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/lookup/*", ID_CONTACTS_LOOKUP);, +    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/#/photo", ID_CONTACTS_THUMBNAIL);, +    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/#", ID_CONTACTS_CONTACT);, +    URI_MATCHER.addURI(ContactsContract.AUTHORITY, "contacts/#/display_photo", ID_CONTACTS_PHOTO);, +  }, +, +    InputStream inputStream = loadResourceFromUri(uri, contentResolver);, +      throw new FileNotFoundException("InputStream is null for " + uri);, +, +  private InputStream loadResourceFromUri(Uri uri, ContentResolver contentResolver), +      throws FileNotFoundException {, +    switch (URI_MATCHER.match(uri)) {, +      case ID_CONTACTS_CONTACT:, +        return openContactPhotoInputStream(contentResolver, uri);, +      case ID_CONTACTS_LOOKUP:, +        // If it was a Lookup uri then resolve it first, then continue loading the contact uri., +        uri = ContactsContract.Contacts.lookupContact(contentResolver, uri);, +        if (uri == null) {, +          throw new FileNotFoundException("Contact cannot be found");, +        }, +        return openContactPhotoInputStream(contentResolver, uri);, +      case ID_CONTACTS_THUMBNAIL:, +      case ID_CONTACTS_PHOTO:, +      case UriMatcher.NO_MATCH:, +      default:, +        return contentResolver.openInputStream(uri);, +    }, +  }, +, +  @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH), +  private InputStream openContactPhotoInputStream(ContentResolver contentResolver, Uri contactUri) {, +    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {, +      return ContactsContract.Contacts.openContactPhotoInputStream(contentResolver, contactUri);, +    } else {, +      return ContactsContract.Contacts.openContactPhotoInputStream(contentResolver, contactUri,, +          true /*preferHighres*/);, +    }, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/GenericTransitionOptions.java, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +import android.annotation.TargetApi;, +import android.content.UriMatcher;, +import android.os.Build;, +import android.provider.ContactsContract;, +  /**, +   * A lookup uri (e.g. content://com.android.contacts/contacts/lookup/3570i61d948d30808e537), +   */, +  private static final int ID_CONTACTS_LOOKUP = 1;, +  /**, +   * A contact thumbnail uri (e.g. content://com.android.contacts/contacts/38/photo), +   */, +  private static final int ID_CONTACTS_THUMBNAIL = 2;, +  /**, +   * A contact uri (e.g. content://com.android.contacts/contacts/38), +   */, +  private static final int ID_CONTACTS_CONTACT = 3;, +  /**, +   * A contact display photo (high resolution) uri, +   * (e.g. content://com.android.contacts/5/display_photo), +   */, +  private static final int ID_CONTACTS_PHOTO = 4;, +  /**, +   * Match the incoming Uri for special cases which we can handle nicely., +   */, +  private static final UriMatcher URI_MATCHER;, +, +  static {]
[+++ b/library/src/main/java/com/bumptech/glide/Registry.java, +          List<Class<Transcode>> registeredTranscodeClasses = transcoderRegistry, +              .getTranscodeClasses(registeredResourceClass, transcodeClass);, +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +          List<Class<Transcode>> registeredTranscodeClasses = transcoderRegistry, +              .getTranscodeClasses(registeredResourceClass, transcodeClass);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java, +      // throw new IllegalStateException(, +      //    "Failed to find any load path from " + helper.getModelClass() + " to ", +      //        + helper.getTranscodeClass());]
[+++ b/.gitignore, +docs/**/*, +++ b/.gitignore, +docs/**/*, +++ b/README.md, +Sam Judd - @samajudd, +++ b/.gitignore, +docs/**/*, +++ b/README.md, +Sam Judd - @samajudd, +++ b/library/src/com/bumptech/glide/Glide.java, +        if (tag instanceof ImageViewTarget) {, +            if (tag != null) {, +                Log.d("Replacing existing tag=" + tag + " on view=" + imageView + " with an ImageViewTarge");, +            }, +            ImagePresenter<T> result = target.getImagePresenter();, +, +            if (previous != null && result == null) {, +                previous = null;, +            }, +++ b/.gitignore, +docs/**/*, +++ b/README.md, +Sam Judd - @samajudd, +++ b/library/src/com/bumptech/glide/Glide.java, +        if (tag instanceof ImageViewTarget) {, +            if (tag != null) {, +                Log.d("Replacing existing tag=" + tag + " on view=" + imageView + " with an ImageViewTarge");, +            }, +            ImagePresenter<T> result = target.getImagePresenter();, +, +            if (previous != null && result == null) {, +                previous = null;, +            }, +++ b/library/src/com/bumptech/glide/presenter/target/ImageViewTarget.java, + * A target wrapping an ImageView. Obtains the runtime dimensions of the ImageView., +++ b/.gitignore, +docs/**/*, +++ b/README.md, +Sam Judd - @samajudd, +++ b/library/src/com/bumptech/glide/Glide.java, +        if (tag instanceof ImageViewTarget) {, +            if (tag != null) {, +                Log.d("Replacing existing tag=" + tag + " on view=" + imageView + " with an ImageViewTarge");, +            }, +            ImagePresenter<T> result = target.getImagePresenter();, +, +            if (previous != null && result == null) {, +                previous = null;, +            }, +++ b/library/src/com/bumptech/glide/presenter/target/ImageViewTarget.java, + * A target wrapping an ImageView. Obtains the runtime dimensions of the ImageView., +++ b/library/tests/src/com/bumptech/glide/GlideTest.java, +    public void testClearingTagReplacesPresenter() {, +        Glide.load("a").into(imageView);, +        assertNotNull(imageView.getTag());, +        imageView.setTag(null);, +        Glide.load("b").into(imageView);, +    }, +]
[+++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MINOR=6, +VERSION_PATCH=0, +VERSION_CODE=11, +++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MINOR=6, +VERSION_PATCH=0, +VERSION_CODE=11, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.3.0-SNAPSHOT, +VERSION_MINOR=3, +VERSION_PATCH=0, +VERSION_CODE=7, +++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MINOR=6, +VERSION_PATCH=0, +VERSION_CODE=11, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.3.0-SNAPSHOT, +VERSION_MINOR=3, +VERSION_PATCH=0, +VERSION_CODE=7, +++ b/integration/volley/gradle.properties, +VERSION_NAME=1.3.0-SNAPSHOT, +VERSION_MINOR=3, +VERSION_PATCH=0, +VERSION_CODE=7]
[+++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, + * @param <ModelType> The type of model to load the {@link Bitmap} or transcoded class from., +public class BitmapTypeRequest<ModelType> extends BitmapRequestBuilder<ModelType, Bitmap> {, +    private final ModelType model;, +    private final ModelLoader<ModelType, InputStream> streamModelLoader;, +    private ModelLoader<ModelType, ParcelFileDescriptor> fileDescriptorModelLoader;, +    BitmapTypeRequest(Context context, ModelType model,, +            ModelLoader<ModelType, InputStream> streamModelLoader,, +            ModelLoader<ModelType, ParcelFileDescriptor> fileDescriptorModelLoader,, +    public <R> BitmapRequestBuilder<ModelType, R> transcode(ResourceTranscoder<Bitmap, R> transcoder,, +            Class<R> transcodeClass) {, +        return optionsApplier.apply(model, new BitmapRequestBuilder<ModelType, R>(context, model,, +    public BitmapRequestBuilder<ModelType, byte[]> toBytes() {, +    public BitmapRequestBuilder<ModelType, byte[]> toBytes(Bitmap.CompressFormat compressFormat, int quality) {, +++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, + * @param <ModelType> The type of model to load the {@link Bitmap} or transcoded class from., +public class BitmapTypeRequest<ModelType> extends BitmapRequestBuilder<ModelType, Bitmap> {, +    private final ModelType model;, +    private final ModelLoader<ModelType, InputStream> streamModelLoader;, +    private ModelLoader<ModelType, ParcelFileDescriptor> fileDescriptorModelLoader;, +    BitmapTypeRequest(Context context, ModelType model,, +            ModelLoader<ModelType, InputStream> streamModelLoader,, +            ModelLoader<ModelType, ParcelFileDescriptor> fileDescriptorModelLoader,, +    public <R> BitmapRequestBuilder<ModelType, R> transcode(ResourceTranscoder<Bitmap, R> transcoder,, +            Class<R> transcodeClass) {, +        return optionsApplier.apply(model, new BitmapRequestBuilder<ModelType, R>(context, model,, +    public BitmapRequestBuilder<ModelType, byte[]> toBytes() {, +    public BitmapRequestBuilder<ModelType, byte[]> toBytes(Bitmap.CompressFormat compressFormat, int quality) {, +++ b/library/src/main/java/com/bumptech/glide/DrawableOptions.java, +package com.bumptech.glide;, +, +import android.view.animation.Animation;, +, +public interface DrawableOptions {, +, +    /**, +     * Applies a cross fade transformation that fades from the placeholder to the loaded, +     * {@link android.graphics.drawable.Drawable}. If no placeholder is set, the Drawable will instead simply fade in., +     *, +     * <p>, +     *     Note - this only works by default for {@link android.view.View}s and, +     *     {@link com.bumptech.glide.request.target.ViewTarget}s., +     * </p>, +     *, +     * @see #crossFade(int), +     * @see #crossFade(int, int), +     * @see #crossFade(android.view.animation.Animation, int), +     *, +     * @return This request builder., +     */, +     public GenericRequestBuilder<?, ?, ?, ?> crossFade();, +, +    /**, +     * Applies a cross fade transformation that fades from the placeholder to the loaded, +     * {@link android.graphics.drawable.Drawable}. If no placeholder is set the Drawable will instead simply fade in., +     *, +     * <p>, +     *     Note - this only works by default for {@link android.view.View}s and, +     *     {@link com.bumptech.glide.request.target.ViewTarget}s., +     * </p>, +     *, +     * @see #crossFade(), +     * @see #crossFade(int, int), +     * @see #crossFade(android.view.animation.Animation, int), +     *, +     * @param duration The duration of the cross fade and initial fade in., +     * @return This request builder., +     */, +    public GenericRequestBuilder<?, ?, ?, ?> crossFade(int duration);, +, +, +    /**, +     * Applies a cross fade transformation that des from the placeholder to the loaded, +     * {@link android.graphics.drawable.Drawable}. If no placeholder is set, the Drawable will instead be animated in, +     * using the given {@link android.view.animation.Animation}., +     *, +     * <p>, +     *     Note - this only works by default for {@link android.view.View}s and, +     *     {@link com.bumptech.glide.request.target.ViewTarget}s., +     * </p>, +     *, +     * @see #crossFade(), +     * @see #crossFade(int), +     * @see #crossFade(int, int), +     *, +     * @param animation The Animation to use if no placeholder is set., +     * @param duration The duration of the cross fade animation., +     * @return This request builder., +     */, +    public GenericRequestBuilder<?, ?, ?, ?> crossFade(Animation animation, int duration);, +, +, +    /**, +     * Applies a cross fade transformation that des from the placeholder to the loaded, +     * {@link android.graphics.drawable.Drawable}. If no placeholder is set, the Drawable will instead be animated in, +     * using the {@link android.view.animation.Animation} loaded from the given animation id., +     *, +     * <p>, +     *     Note - this only works by default for {@link android.view.View}s and, +     *     {@link com.bumptech.glide.request.target.ViewTarget}s.]
[+++ b/.gitignore, +# Android, +local.properties, +*.keystore, +*.DS_Store, +proguard-project.txt, +, +# Gradle, +**/.gradle, +**/.settings, +**/build, +, +# gh-pages, +docs/**/*, +, +# Vim, +, +# Intellij , +*.ipr, +*.iml, +*.iws, +**/.idea/.name, +**/.idea/compiler.xml, +**/.idea/copyright/profiles_settings.xml, +**/.idea/encodings.xml, +**/.idea/misc.xml, +**/.idea/modules.xml, +**/.idea/scopes/scope_settings.xml, +**/.idea/vcs.xml, +**/.idea/libraries, +**/.idea/workspace.xml, +**/.idea/tasks.xml, +**/.idea/gradle.xml, +**/.idea/dictionaries, +**/.idea/dataSources.ids, +**/.idea/datasources.xml, +**/.idea/uiDesigner.xml, +, +++ b/.gitignore, +# Android, +local.properties, +*.keystore, +*.DS_Store, +proguard-project.txt, +, +# Gradle, +**/.gradle, +**/.settings, +**/build, +, +# gh-pages, +docs/**/*, +, +# Vim, +, +# Intellij , +*.ipr, +*.iml, +*.iws, +**/.idea/.name, +**/.idea/compiler.xml, +**/.idea/copyright/profiles_settings.xml, +**/.idea/encodings.xml, +**/.idea/misc.xml, +**/.idea/modules.xml, +**/.idea/scopes/scope_settings.xml, +**/.idea/vcs.xml, +**/.idea/libraries, +**/.idea/workspace.xml, +**/.idea/tasks.xml, +**/.idea/gradle.xml, +**/.idea/dictionaries, +**/.idea/dataSources.ids, +**/.idea/datasources.xml, +**/.idea/uiDesigner.xml, +, +++ /dev/null, +++ b/.gitignore, +# Android, +local.properties, +*.keystore, +*.DS_Store, +proguard-project.txt, +, +# Gradle, +**/.gradle, +**/.settings, +**/build, +, +# gh-pages, +docs/**/*, +, +# Vim, +, +# Intellij , +*.ipr, +*.iml, +*.iws, +**/.idea/.name, +**/.idea/compiler.xml]
[+++ b/library/src/main/java/com/bumptech/glide/load/model/ModelLoaderFactory.java, +import com.bumptech.glide.Glide;, +import com.bumptech.glide.Registry;, + * An interface for creating a {@link ModelLoader} for a given model type., + *, + * <p>The application {@link android.content.Context} can be passed in to the constructor of the, + * factory when necessary. It's unsafe to retain {@link android.app.Activity}, + * {@link android.content.Context}s in factories. The {@link android.content.Context} can be, + * obtained from, + * {@link com.bumptech.glide.module.LibraryGlideModule#registerComponents(Context, Glide, Registry)}, + * in most cases.]
[+++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }, +    }, +}, +, +subprojects {, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = 1.7, +        targetCompatibility = 1.7, +    }, +}, +, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }, +    }, +}, +, +subprojects {, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = 1.7, +        targetCompatibility = 1.7, +    }, +}, +, +++ b/gradle.properties, +ANDROID_GRADLE_VERSION=1.0.1, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }, +    }, +}, +, +subprojects {, +    tasks.withType(JavaCompile) {]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +    return set(GifOptions.DISABLE_ANIMATION, true);]
[+++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppGlideModuleTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppGlideModuleTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyLibraryGlideModuleTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppGlideModuleTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyLibraryGlideModuleTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionOptionsTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppGlideModuleTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyLibraryGlideModuleTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionOptionsTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithOptionTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppGlideModuleTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyLibraryGlideModuleTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionOptionsTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithOptionTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionWithTypeTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppAndLibraryGlideModulesTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyAppGlideModuleTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/EmptyLibraryGlideModuleTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/GlideExtensionOptionsTest.java, +import org.junit.runner.RunWith;, +import org.junit.runners.JUnit4;, +@RunWith(JUnit4.class)]
[+++ b/library/robolectric/src/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.ResourceDecoder;, +import com.bumptech.glide.load.ResourceEncoder;, +    public void testGenericLoader() throws Exception {, +        File expected = new File("test");, +, +        GlideUrl glideUrl =  mock(GlideUrl.class);, +        ResourceFetcher<File> resourceFetcher = mock(ResourceFetcher.class);, +        when(resourceFetcher.loadResource(any(Priority.class))).thenReturn(expected);, +        ModelLoader<GlideUrl, File> modelLoader = mock(ModelLoader.class);, +        when(modelLoader.getId(eq(glideUrl))).thenReturn("id");, +        when(modelLoader.getResourceFetcher(eq(glideUrl), anyInt(), anyInt())), +                .thenReturn(resourceFetcher);, +, +        Resource<File> expectedResource = mock(Resource.class);, +        when(expectedResource.get()).thenReturn(expected);, +        ResourceDecoder<File, File> sourceDecoder = mock(ResourceDecoder.class);, +        when(sourceDecoder.decode(eq(expected), anyInt(), anyInt())).thenReturn(expectedResource);, +        when(sourceDecoder.getId()).thenReturn("sourceDecoderId");, +        ResourceDecoder<InputStream, File> cacheDecoder = mock(ResourceDecoder.class);, +        when(cacheDecoder.getId()).thenReturn("cacheDecoderId");, +        ResourceEncoder<File> encoder = mock(ResourceEncoder.class);, +        when(encoder.getId()).thenReturn("encoderId");, +, +        Glide.with(getContext()), +                .using(modelLoader, File.class), +                .load(glideUrl), +                .as(File.class), +                .imageDecoder(sourceDecoder), +                .cacheDecoder(cacheDecoder), +                .encoder(encoder), +                .into(target);, +, +        verify(target).onResourceReady(eq(expected));, +    }, +, +    @Test, +        ResourceTranscoder<Bitmap, byte[]> transcoder = mock(ResourceTranscoder.class);, +        when(transcoder.getId()).thenReturn("bytes");, +        when(transcoder.transcode(any(Resource.class))).thenReturn(new BytesResource(bytes));, +        Glide.with(getContext()), +                .load(uri), +                .transcode(transcoder, byte[].class), +                .into(target);, +++ b/library/robolectric/src/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.ResourceDecoder;, +import com.bumptech.glide.load.ResourceEncoder;, +    public void testGenericLoader() throws Exception {, +        File expected = new File("test");, +, +        GlideUrl glideUrl =  mock(GlideUrl.class);, +        ResourceFetcher<File> resourceFetcher = mock(ResourceFetcher.class);, +        when(resourceFetcher.loadResource(any(Priority.class))).thenReturn(expected);, +        ModelLoader<GlideUrl, File> modelLoader = mock(ModelLoader.class);, +        when(modelLoader.getId(eq(glideUrl))).thenReturn("id");, +        when(modelLoader.getResourceFetcher(eq(glideUrl), anyInt(), anyInt())), +                .thenReturn(resourceFetcher);, +, +        Resource<File> expectedResource = mock(Resource.class);, +        when(expectedResource.get()).thenReturn(expected);, +        ResourceDecoder<File, File> sourceDecoder = mock(ResourceDecoder.class);, +        when(sourceDecoder.decode(eq(expected), anyInt(), anyInt())).thenReturn(expectedResource);, +        when(sourceDecoder.getId()).thenReturn("sourceDecoderId");, +        ResourceDecoder<InputStream, File> cacheDecoder = mock(ResourceDecoder.class);, +        when(cacheDecoder.getId()).thenReturn("cacheDecoderId");, +        ResourceEncoder<File> encoder = mock(ResourceEncoder.class);, +        when(encoder.getId()).thenReturn("encoderId");, +, +        Glide.with(getContext()), +                .using(modelLoader, File.class), +                .load(glideUrl), +                .as(File.class), +                .imageDecoder(sourceDecoder), +                .cacheDecoder(cacheDecoder), +                .encoder(encoder), +                .into(target);, +, +        verify(target).onResourceReady(eq(expected));, +    }, +, +    @Test, +        ResourceTranscoder<Bitmap, byte[]> transcoder = mock(ResourceTranscoder.class);, +        when(transcoder.getId()).thenReturn("bytes");, +        when(transcoder.transcode(any(Resource.class))).thenReturn(new BytesResource(bytes));, +        Glide.with(getContext()), +                .load(uri), +                .transcode(transcoder, byte[].class), +                .into(target);, +++ b/library/robolectric/src/com/bumptech/glide/provider/ChildLoadProviderTest.java, +    public void testReturnsParentTranscoderIfNoneIsSet() {, +    @Test, +    public void testReturnsChildTranscoderIfSet() {, +        harness.provider.setTranscoder(harness.transcoder);, +, +        assertEquals(harness.transcoder, harness.provider.getTranscoder());, +    }, +, +++ b/library/robolectric/src/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.ResourceDecoder;, +import com.bumptech.glide.load.ResourceEncoder;]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +  long getMaxSize();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +  long getMaxSize();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java, +  public long getMaxSize() {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +  long getMaxSize();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java, +  public long getMaxSize() {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +  private final long initialMaxSize;, +  private long maxSize;, +  private long currentSize;, +  LruBitmapPool(long maxSize, LruPoolStrategy strategy, Set<Bitmap.Config> allowedConfigs) {, +  public LruBitmapPool(long maxSize) {, +  public LruBitmapPool(long maxSize, Set<Bitmap.Config> allowedConfigs) {, +  public long getMaxSize() {, +  private synchronized void trimToSize(long size) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +  long getMaxSize();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java, +  public long getMaxSize() {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +  private final long initialMaxSize;, +  private long maxSize;, +  private long currentSize;, +  LruBitmapPool(long maxSize, LruPoolStrategy strategy, Set<Bitmap.Config> allowedConfigs) {, +  public LruBitmapPool(long maxSize) {, +  public LruBitmapPool(long maxSize, Set<Bitmap.Config> allowedConfigs) {, +  public long getMaxSize() {, +  private synchronized void trimToSize(long size) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java, + * DiskLruCacheFactory#DiskLruCacheFactory(CacheDirectoryGetter, long)} constructor variant., +  private final long diskCacheSize;, +  public DiskLruCacheFactory(final String diskCacheFolder, long diskCacheSize) {, +                             long diskCacheSize) {, +  public DiskLruCacheFactory(CacheDirectoryGetter cacheDirectoryGetter, long diskCacheSize) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +  long getMaxSize();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java, +  public long getMaxSize() {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +  private final long initialMaxSize;, +  private long maxSize;, +  private long currentSize;, +  LruBitmapPool(long maxSize, LruPoolStrategy strategy, Set<Bitmap.Config> allowedConfigs) {, +  public LruBitmapPool(long maxSize) {, +  public LruBitmapPool(long maxSize, Set<Bitmap.Config> allowedConfigs) {, +  public long getMaxSize() {, +  private synchronized void trimToSize(long size) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java, + * DiskLruCacheFactory#DiskLruCacheFactory(CacheDirectoryGetter, long)} constructor variant., +  private final long diskCacheSize;, +  public DiskLruCacheFactory(final String diskCacheFolder, long diskCacheSize) {, +                             long diskCacheSize) {, +  public DiskLruCacheFactory(CacheDirectoryGetter cacheDirectoryGetter, long diskCacheSize) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java, + * @see #get(java.io.File, long), +  private final long maxSize;, +  public static synchronized DiskCache get(File directory, long maxSize) {, +  protected DiskLruCacheWrapper(File directory, long maxSize) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +  long getMaxSize();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java, +  public long getMaxSize() {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +  private final long initialMaxSize;, +  private long maxSize;, +  private long currentSize;, +  LruBitmapPool(long maxSize, LruPoolStrategy strategy, Set<Bitmap.Config> allowedConfigs) {, +  public LruBitmapPool(long maxSize) {, +  public LruBitmapPool(long maxSize, Set<Bitmap.Config> allowedConfigs) {, +  public long getMaxSize() {, +  private synchronized void trimToSize(long size) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheFactory.java, + * DiskLruCacheFactory#DiskLruCacheFactory(CacheDirectoryGetter, long)} constructor variant., +  private final long diskCacheSize;, +  public DiskLruCacheFactory(final String diskCacheFolder, long diskCacheSize) {, +                             long diskCacheSize) {, +  public DiskLruCacheFactory(CacheDirectoryGetter cacheDirectoryGetter, long diskCacheSize) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java, + * @see #get(java.io.File, long), +  private final long maxSize;, +  public static synchronized DiskCache get(File directory, long maxSize) {, +  protected DiskLruCacheWrapper(File directory, long maxSize) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/ExternalPreferredCacheDiskCacheFactory.java, +  public ExternalPreferredCacheDiskCacheFactory(Context context, long diskCacheSize) {, +                                                final long diskCacheSize) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPool.java, +  long getMaxSize();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BitmapPoolAdapter.java, +  public long getMaxSize() {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +  private final long initialMaxSize;, +  private long maxSize;, +  private long currentSize;, +  LruBitmapPool(long maxSize, LruPoolStrategy strategy, Set<Bitmap.Config> allowedConfigs) {, +  public LruBitmapPool(long maxSize) {, +  public LruBitmapPool(long maxSize, Set<Bitmap.Config> allowedConfigs) {]
[+++ b/library/src/main/java/com/bumptech/glide/Registry.java, +import android.support.annotation.Nullable;, +  @Nullable, +    if (loadPathCache.isEmptyLoadPath(result)) {, +      return null;, +    } else if (result == null) {, +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +import android.support.annotation.Nullable;, +  @Nullable, +    if (loadPathCache.isEmptyLoadPath(result)) {, +      return null;, +    } else if (result == null) {, +++ b/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java, +import com.bumptech.glide.load.engine.DecodePath;, +import com.bumptech.glide.load.resource.transcode.UnitTranscoder;, +import java.util.Collections;, +  private static final LoadPath<?, ?, ?> NO_PATHS_SIGNAL =, +      new LoadPath<>(, +          Object.class,, +          Object.class,, +          Object.class,, +          Collections.singletonList(, +              new DecodePath<>(, +                  Object.class,, +                  Object.class,, +                  Object.class,, +                  Collections.emptyList(),, +                  new UnitTranscoder<>(),, +                  /*listPool=*/ null)),, +          /*listPool=*/ null);, +, +  /**, +   * Returns {@code} true if the given {@link LoadPath} is the signal object returned from, +   * {@link #get(Class, Class, Class)} that indicates that we've previously found that there are, +   * no available paths to load the requested resources and {@code false} otherwise., +   */, +  public boolean isEmptyLoadPath(@Nullable LoadPath<?, ?, ?> path) {, +    return NO_PATHS_SIGNAL.equals(path);, +  /**, +   * May return {@link #NO_PATHS_SIGNAL} to indicate that we've previously found that there are 0, +   * available load paths for the requested types. Callers must check using, +   * {@link #isEmptyLoadPath(LoadPath)} before using any load path returned by this method., +   */, +  public void put(, +      Class<?> dataClass, Class<?> resourceClass,, +      Class<?> transcodeClass,, +      @Nullable LoadPath<?, ?, ?> loadPath) {, +      cache.put(, +          new MultiClassKey(dataClass, resourceClass, transcodeClass),, +          loadPath != null ? loadPath : NO_PATHS_SIGNAL);]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java, +package com.bumptech.glide;, +, +import static com.google.common.truth.Truth.assertThat;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.when;, +, +import android.content.Context;, +import android.graphics.Bitmap;, +import android.graphics.Bitmap.Config;, +import android.graphics.Canvas;, +import android.graphics.Color;, +import android.graphics.drawable.BitmapDrawable;, +import android.graphics.drawable.ColorDrawable;, +import android.graphics.drawable.Drawable;, +import android.support.test.InstrumentationRegistry;, +import android.support.test.runner.AndroidJUnit4;, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import com.bumptech.glide.load.resource.bitmap.TransformationUtils;, +import com.bumptech.glide.request.RequestOptions;, +import java.util.concurrent.ExecutionException;, +import org.junit.After;, +import org.junit.Before;, +import org.junit.Rule;, +import org.junit.Test;, +import org.junit.rules.ExpectedException;, +import org.junit.runner.RunWith;, +, +@RunWith(AndroidJUnit4.class), +public class DrawableTransformationTest {, +  @Rule public ExpectedException expectedException = ExpectedException.none();, +, +  private Context context;, +, +  @Before, +  public void setUp() {, +    context = InstrumentationRegistry.getTargetContext();, +  }, +, +  @After, +  public void tearDown() {, +    Glide.get(context).clearDiskCache();, +    Glide.tearDown();, +  }, +, +  @Test, +  public void load_withColorDrawable_sizeOriginal_optionalTransform_returnsColorDrawable(), +      throws ExecutionException, InterruptedException {, +    Drawable colorDrawable = new ColorDrawable(Color.RED);, +    Drawable result = Glide.with(context), +        .load(colorDrawable), +        .apply(new RequestOptions(), +            .optionalCenterCrop()), +        .submit(), +        .get();, +, +    assertThat(result).isInstanceOf(ColorDrawable.class);, +    assertThat(((ColorDrawable) result).getColor()).isEqualTo(Color.RED);, +  }, +, +  /**, +   * Transformations that do nothing can simply return the original Bitmap., +   */, +  @Test, +  public void load_withColorDrawable_fixedSize_requiredUnitTransform_returnsOriginalDrawable(), +      throws ExecutionException, InterruptedException {, +    Drawable colorDrawable = new ColorDrawable(Color.RED);, +, +    Drawable result = Glide.with(context), +        .load(colorDrawable), +        .apply(new RequestOptions(), +            .centerCrop()), +        .submit(100, 100), +        .get();, +, +    assertThat(result).isInstanceOf(ColorDrawable.class);, +    assertThat(((ColorDrawable) result).getColor()).isEqualTo(Color.RED);, +  }, +, +  /**, +   * Transformations that produce a different output color/shape/image etc will end up returning, +   * a {@link Bitmap} based on the original {@link Drawable} but with the transformation applied., +   */, +  @Test, +  public void load_withColorDrawable_fixedSize_nonUnitRequiredTransform_returnsBitmapDrawable(), +      throws ExecutionException, InterruptedException {, +    Drawable colorDrawable = new ColorDrawable(Color.RED);, +, +    Drawable result = Glide.with(context), +        .load(colorDrawable), +        .apply(new RequestOptions(), +            .circleCrop()), +        .submit(100, 100), +        .get();, +, +    Bitmap redSquare = Bitmap.createBitmap(100, 100, Config.ARGB_8888);, +    Canvas canvas = new Canvas(redSquare);, +    canvas.drawColor(Color.RED);, +, +    BitmapPool bitmapPool = mock(BitmapPool.class);]
[+++ b/gradle.properties, +VERSION_NAME=4.0.0-SNAPSHOT]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +            + " annotationProcessor compile dependency on com.github.bumptech.glide:compiler"]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java, +    if (drawableResource == null) {, +      return null;, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java, +    if (drawableResource == null) {, +      return null;, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java, +import android.support.annotation.Nullable;, +  @Nullable, +  static Resource<Drawable> newInstance(@Nullable Drawable drawable) {, +    return drawable != null ? new NonOwnedDrawableResource(drawable) : null;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ResourceBitmapDecoder.java, +    if (drawableResource == null) {, +      return null;, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/NonOwnedDrawableResource.java, +import android.support.annotation.Nullable;, +  @Nullable, +  static Resource<Drawable> newInstance(@Nullable Drawable drawable) {, +    return drawable != null ? new NonOwnedDrawableResource(drawable) : null;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java, +import android.support.annotation.Nullable;, +  @Nullable]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java, +public enum DiskCacheStrategy {, +  ALL(true /*decodeCachedData*/, true /*decodeCachedResource*/) {, +  },, +  NONE(false /*decodeCachedData*/, false /*decodeCachedResource*/) {, +  },, +  DATA(true /*decodeCachedData*/, false /*decodeCachedResource*/) {, +  },, +  RESOURCE(false /*decodeCachedData*/, true /*decodeCachedResource*/) {, +      return false;, +  },, +  AUTOMATIC(true /*decodeCachedData*/, true /*decodeCachedResource*/) {, +  private final boolean decodeCachedData;, +  private final boolean decodeCachedResource;, +, +  DiskCacheStrategy(boolean decodeCachedData,, +      boolean decodeCachedResource) {, +    this.decodeCachedData = decodeCachedData;, +    this.decodeCachedResource = decodeCachedResource;, +  }, +, +  public boolean decodeCachedResource() {, +    return decodeCachedResource;, +  }, +  public boolean decodeCachedData() {, +    return decodeCachedData;, +  }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java, +public enum DiskCacheStrategy {, +  ALL(true /*decodeCachedData*/, true /*decodeCachedResource*/) {, +  },, +  NONE(false /*decodeCachedData*/, false /*decodeCachedResource*/) {, +  },, +  DATA(true /*decodeCachedData*/, false /*decodeCachedResource*/) {, +  },, +  RESOURCE(false /*decodeCachedData*/, true /*decodeCachedResource*/) {, +      return false;, +  },, +  AUTOMATIC(true /*decodeCachedData*/, true /*decodeCachedResource*/) {, +  private final boolean decodeCachedData;, +  private final boolean decodeCachedResource;, +, +  DiskCacheStrategy(boolean decodeCachedData,, +      boolean decodeCachedResource) {, +    this.decodeCachedData = decodeCachedData;, +    this.decodeCachedResource = decodeCachedResource;, +  }, +, +  public boolean decodeCachedResource() {, +    return decodeCachedResource;, +  }, +  public boolean decodeCachedData() {, +    return decodeCachedData;, +  }, +++ b/library/src/main/java/com/bumptech/glide/util/Util.java, +      throw new IllegalArgumentException("You must call this method on a background thread");]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +  private final RequestManagerRetriever requestManagerRetriever;, +      RequestManagerRetriever requestManagerRetriever,, +    this.requestManagerRetriever = requestManagerRetriever;, +, +  /**, +   * Internal method., +   */, +  public RequestManagerRetriever getRequestManagerRetriever() {, +    return requestManagerRetriever;, +  }, +, +  private static RequestManagerRetriever getRetriever(@Nullable Context context) {, +    // Context could be null for other reasons (ie the user passes in null), but in practice it will, +    // only occur due to errors with the Fragment lifecycle., +    if (context == null) {, +      throw new IllegalArgumentException(, +          "You cannot start a load on a Fragment where getActivity() returns null (which usually", +              + " occurs when getActivity() is called before the Fragment is attached or after the", +              + " Fragment is destroyed).");, +    }, +    return Glide.get(context).getRequestManagerRetriever();, +  }, +, +    return getRetriever(context).get(context);, +    return getRetriever(activity).get(activity);, +    return getRetriever(activity).get(activity);, +    return getRetriever(fragment.getActivity()).get(fragment);, +    return getRetriever(fragment.getActivity()).get(fragment);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +  private final RequestManagerRetriever requestManagerRetriever;, +      RequestManagerRetriever requestManagerRetriever,, +    this.requestManagerRetriever = requestManagerRetriever;, +, +  /**, +   * Internal method., +   */, +  public RequestManagerRetriever getRequestManagerRetriever() {, +    return requestManagerRetriever;, +  }, +, +  private static RequestManagerRetriever getRetriever(@Nullable Context context) {, +    // Context could be null for other reasons (ie the user passes in null), but in practice it will, +    // only occur due to errors with the Fragment lifecycle., +    if (context == null) {, +      throw new IllegalArgumentException(, +          "You cannot start a load on a Fragment where getActivity() returns null (which usually", +              + " occurs when getActivity() is called before the Fragment is attached or after the", +              + " Fragment is destroyed).");, +    }, +    return Glide.get(context).getRequestManagerRetriever();, +  }, +, +    return getRetriever(context).get(context);, +    return getRetriever(activity).get(activity);, +    return getRetriever(activity).get(activity);, +    return getRetriever(fragment.getActivity()).get(fragment);, +    return getRetriever(fragment.getActivity()).get(fragment);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import android.support.annotation.Nullable;, +import com.bumptech.glide.manager.RequestManagerRetriever;, +import com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory;, +  @Nullable, +  private RequestManagerFactory requestManagerFactory;, +  GlideBuilder setRequestManagerFactory(, +      @Nullable RequestManagerRetriever.RequestManagerFactory factory) {, +    this.requestManagerFactory = factory;, +    return this;, +  }, +, +    RequestManagerRetriever requestManagerRetriever = new RequestManagerRetriever(, +        requestManagerFactory);, +, +        requestManagerRetriever,, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +  private final RequestManagerRetriever requestManagerRetriever;, +      RequestManagerRetriever requestManagerRetriever,, +    this.requestManagerRetriever = requestManagerRetriever;, +, +  /**, +   * Internal method., +   */, +  public RequestManagerRetriever getRequestManagerRetriever() {, +    return requestManagerRetriever;, +  }, +, +  private static RequestManagerRetriever getRetriever(@Nullable Context context) {, +    // Context could be null for other reasons (ie the user passes in null), but in practice it will, +    // only occur due to errors with the Fragment lifecycle., +    if (context == null) {, +      throw new IllegalArgumentException(, +          "You cannot start a load on a Fragment where getActivity() returns null (which usually", +              + " occurs when getActivity() is called before the Fragment is attached or after the", +              + " Fragment is destroyed).");, +    }, +    return Glide.get(context).getRequestManagerRetriever();, +  }, +, +    return getRetriever(context).get(context);, +    return getRetriever(activity).get(activity);]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    return into(target, getMutableOptions());, +  }, +, +  private <Y extends Target<TranscodeType>> Y into(@NonNull Y target, RequestOptions options) {, +    options = options.autoClone();, +    Request request = buildRequest(target, options);, +, +    RequestOptions requestOptions = this.requestOptions;, +      // Clone in this method so that if we use this RequestBuilder to load into a View and then, +      // into a different target, we don't retain the transformation applied based on the previous, +      // View's scale type., +          requestOptions.clone().optionalCenterCrop();, +          requestOptions.clone().optionalCenterInside();, +          requestOptions.clone().optionalFitCenter();, +          requestOptions.clone().optionalCenterInside();, +    return into(context.buildImageViewTarget(view, transcodeClass), requestOptions);, +  private Request buildRequest(Target<TranscodeType> target, RequestOptions requestOptions) {, +        requestOptions.getOverrideWidth(), requestOptions.getOverrideHeight(), requestOptions);, +      Priority priority, int overrideWidth, int overrideHeight, RequestOptions requestOptions) {, +      Request thumbRequest =, +          thumbnailBuilder.buildRequestRecursive(, +              target,, +              coordinator,, +              thumbTransitionOptions,, +              thumbPriority,, +              thumbOverrideWidth,, +              thumbOverrideHeight,, +              requestOptions);]
[+++ b/.gitignore, +# sed, +*.bak, +, +++ b/.gitignore, +# sed, +*.bak, +, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]instrumentation[/\\]src[/\\].*" checks="Javadoc.*"/>, +++ b/.gitignore, +# sed, +*.bak, +, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]instrumentation[/\\]src[/\\].*" checks="Javadoc.*"/>, +++ b/instrumentation/build.gradle, +tasks.whenTaskAdded { task ->, +    if (task.name.equals("lint")) {, +        task.enabled = false, +    }, +}, +    androidTestCompile project(":annotation:compiler"), +++ b/.gitignore, +# sed, +*.bak, +, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]instrumentation[/\\]src[/\\].*" checks="Javadoc.*"/>, +++ b/instrumentation/build.gradle, +tasks.whenTaskAdded { task ->, +    if (task.name.equals("lint")) {, +        task.enabled = false, +    }, +}, +    androidTestCompile project(":annotation:compiler"), +++ b/instrumentation/src/androidTest/AndroidManifest.xml, +<manifest xmlns:android="http://schemas.android.com/apk/res/android", +  package="com.bumptech.glide.instrumentation.test">, +  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />, +  <application>, +  </application>, +</manifest>, +++ b/.gitignore, +# sed, +*.bak, +, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]instrumentation[/\\]src[/\\].*" checks="Javadoc.*"/>, +++ b/instrumentation/build.gradle, +tasks.whenTaskAdded { task ->, +    if (task.name.equals("lint")) {, +        task.enabled = false, +    }, +}, +    androidTestCompile project(":annotation:compiler"), +++ b/instrumentation/src/androidTest/AndroidManifest.xml, +<manifest xmlns:android="http://schemas.android.com/apk/res/android", +  package="com.bumptech.glide.instrumentation.test">, +  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />, +  <application>, +  </application>, +</manifest>, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/FitCenterRegressionTest.java, +package com.bumptech.glide;, +, +import static com.google.common.truth.Truth.assertThat;, +, +import android.content.Context;, +import android.graphics.Bitmap;, +import android.support.test.InstrumentationRegistry;, +import android.support.test.runner.AndroidJUnit4;, +import com.bumptech.glide.test.BitmapRegressionTester;, +import com.bumptech.glide.test.CanonicalBitmap;, +import com.bumptech.glide.test.GlideApp;, +import com.bumptech.glide.test.RegressionTest;, +import com.bumptech.glide.test.SplitByCpu;, +import com.bumptech.glide.test.SplitBySdk;, +import java.util.concurrent.ExecutionException;, +import org.junit.Before;, +import org.junit.Rule;, +import org.junit.Test;, +import org.junit.rules.ExpectedException;, +import org.junit.rules.TestName;, +import org.junit.runner.RunWith;, +, +@RunWith(AndroidJUnit4.class), +@SplitByCpu, +@SplitBySdk({24, 23, 21, 19, 18, 16}), +@RegressionTest, +public class FitCenterRegressionTest {, +  @Rule public TestName testName = new TestName();, +  @Rule public ExpectedException expectedException = ExpectedException.none();, +  private BitmapRegressionTester bitmapRegressionTester;, +  private Context context;, +  private CanonicalBitmap canonical;, +, +  @Before, +  public void setUp() {, +    context = InstrumentationRegistry.getTargetContext();]
[+++ b/build.gradle, +        classpath "se.bjurr.violations:violations-gradle-plugin:${VIOLATIONS_PLUGIN_VERSION}", +++ b/build.gradle, +        classpath "se.bjurr.violations:violations-gradle-plugin:${VIOLATIONS_PLUGIN_VERSION}", +++ b/gradle.properties, +VIOLATIONS_PLUGIN_VERSION=1.3, +++ b/build.gradle, +        classpath "se.bjurr.violations:violations-gradle-plugin:${VIOLATIONS_PLUGIN_VERSION}", +++ b/gradle.properties, +VIOLATIONS_PLUGIN_VERSION=1.3, +++ b/library/build.gradle, +import se.bjurr.violations.gradle.plugin.ViolationsTask, +, +apply plugin: "se.bjurr.violations.violations-gradle-plugin", +        // Failures are caught and printed by the violations plugin below., +        ignoreFailures = true, +, +            xml.enabled = true, +            html.enabled = false, +        // Failures are caught and printed by the violations plugin below., +        ignoreFailures = true, +, +            xml.enabled = true, +            html.enabled = false, +, +    task violations(type: ViolationsTask) {, +        minSeverity = 'INFO', +        detailLevel = 'VERBOSE', +        maxViolations = 0, +, +        // Many more formats available, see: https://github.com/tomasbjerre/violations-lib, +        violations = [, +                ["FINDBUGS", ".", ".*/findbugs/.*\\.xml\$", "Findbugs"],, +                ["PMD",      ".", ".*/pmd/.*\\.xml\$",      "PMD"], +        ], +    }, +, +    check.finalizedBy violations]
[+++ b/library/.gitignore, +tests/bin, +libs/volley.jar, +++ b/library/.gitignore, +tests/bin, +libs/volley.jar, +++ b/library/lint.xml, +        <ignore path="src/com/bumptech/glide/resize/bitmap_recycle/LruBitmapPool.java" />, +++ b/library/.gitignore, +tests/bin, +libs/volley.jar, +++ b/library/lint.xml, +        <ignore path="src/com/bumptech/glide/resize/bitmap_recycle/LruBitmapPool.java" />, +++ b/library/src/com/bumptech/glide/resize/bitmap_recycle/AttributeStrategy.java, +package com.bumptech.glide.resize.bitmap_recycle;, +, +import android.graphics.Bitmap;, +, +class AttributeStrategy implements LruPoolStrategy {, +    private final KeyPool keyPool = new KeyPool();, +    private final GroupedLinkedMap<Key, Bitmap> groupedMap = new GroupedLinkedMap<Key, Bitmap>();, +, +    public void put(Bitmap bitmap) {, +        final Key key = keyPool.get(bitmap.getWidth(), bitmap.getHeight(), bitmap.getConfig());, +, +        groupedMap.put(key, bitmap);, +    }, +, +    @Override, +    public Bitmap get(int width, int height, Bitmap.Config config) {, +        final Key key = keyPool.get(width, height, config);, +, +        return groupedMap.get(key);, +    }, +, +    @Override, +    public Bitmap removeLast() {, +        return groupedMap.removeLast();, +    }, +, +    @Override, +    public String logBitmap(Bitmap bitmap) {, +        return getBitmapString(bitmap);, +    }, +, +    @Override, +    public String logBitmap(int width, int height, Bitmap.Config config) {, +        return getBitmapString(width, height, config);, +    }, +, +    @Override, +    public int getSize(Bitmap bitmap) {, +        return bitmap.getHeight() * bitmap.getRowBytes();, +    }, +, +    @Override, +    public String toString() {, +        return "AttributeStrategy:\n  " + groupedMap;, +    }, +, +    private static String getBitmapString(Bitmap bitmap) {, +        return getBitmapString(bitmap.getWidth(), bitmap.getHeight(), bitmap.getConfig());, +    }, +, +    private static String getBitmapString(int width, int height, Bitmap.Config config) {, +        return "[" + width + "x" + height + "], " + config;, +    }, +, +    private static class KeyPool extends BaseKeyPool<Key> {, +        public Key get(int width, int height, Bitmap.Config config) {, +            Key result = get();, +            result.init(width, height, config);, +            return result;, +        }, +, +        @Override, +        protected Key create() {, +            return new Key(this);, +        }, +    }, +, +    private static class Key implements Poolable {, +        private final KeyPool pool;, +        private int width;, +        private int height;, +        // Config can be null :(, +        private Bitmap.Config config;, +, +        public Key(KeyPool pool) {, +            this.pool = pool;, +        }, +, +        public void init(int width, int height, Bitmap.Config config) {, +            this.width = width;, +            this.height = height;, +            this.config = config;, +        }, +, +        @Override, +        public boolean equals(Object o) {]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java, +        try {, +        } finally {, +          Glide.tearDown();, +        }, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java, +        try {, +        } finally {, +          Glide.tearDown();, +        }, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +      glide.engine.shutdown();, +      glide.engine.clearDiskCache();, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java, +        try {, +        } finally {, +          Glide.tearDown();, +        }, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +      glide.engine.shutdown();, +      glide.engine.clearDiskCache();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.TimeUnit;, +  public void shutdown() {, +    engineJobFactory.shutdown();, +    void shutdown() {, +      shutdownAndAwaitTermination(diskCacheExecutor);, +      shutdownAndAwaitTermination(sourceExecutor);, +      shutdownAndAwaitTermination(sourceUnlimitedExecutor);, +      shutdownAndAwaitTermination(animationExecutor);, +, +    private static void shutdownAndAwaitTermination(ExecutorService pool) {, +      long shutdownSeconds = 5;, +      pool.shutdown();, +      try {, +        if (!pool.awaitTermination(shutdownSeconds, TimeUnit.SECONDS)) {, +          pool.shutdownNow();, +          if (!pool.awaitTermination(shutdownSeconds, TimeUnit.SECONDS)) {, +            throw new RuntimeException("Failed to shutdown");, +          }, +        }, +      } catch (InterruptedException ie) {, +        throw new RuntimeException(ie);, +      }, +    }, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/TearDownGlide.java, +        try {, +        } finally {, +          Glide.tearDown();, +        }, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +      glide.engine.shutdown();, +      glide.engine.clearDiskCache();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +import java.util.concurrent.ExecutorService;, +import java.util.concurrent.TimeUnit;, +  public void shutdown() {, +    engineJobFactory.shutdown();, +    void shutdown() {, +      shutdownAndAwaitTermination(diskCacheExecutor);, +      shutdownAndAwaitTermination(sourceExecutor);, +      shutdownAndAwaitTermination(sourceUnlimitedExecutor);, +      shutdownAndAwaitTermination(animationExecutor);, +, +    private static void shutdownAndAwaitTermination(ExecutorService pool) {, +      long shutdownSeconds = 5;, +      pool.shutdown();, +      try {, +        if (!pool.awaitTermination(shutdownSeconds, TimeUnit.SECONDS)) {, +          pool.shutdownNow();, +          if (!pool.awaitTermination(shutdownSeconds, TimeUnit.SECONDS)) {, +            throw new RuntimeException("Failed to shutdown");, +          }, +        }, +      } catch (InterruptedException ie) {, +        throw new RuntimeException(ie);, +      }, +    }, +++ b/library/src/test/java/com/bumptech/glide/tests/TearDownGlide.java, +        try {, +        } finally {, +          Glide.tearDown();, +, +        }]
[+++ b/library/res/values/ids.xml, +<?xml version="1.0" encoding="utf-8"?>, +<resources>, +  <item type="id" name="image_presenter_id" />, +</resources>, +++ b/library/res/values/ids.xml, +<?xml version="1.0" encoding="utf-8"?>, +<resources>, +  <item type="id" name="image_presenter_id" />, +</resources>, +++ b/library/src/com/bumptech/glide/Glide.java, +package com.bumptech.glide;, +, +import android.content.Context;, +import android.view.animation.Animation;, +import android.view.animation.AnimationUtils;, +import android.widget.ImageView;, +import com.bumptech.glide.loader.image.ImageLoader;, +import com.bumptech.glide.loader.model.FileStreamLoader;, +import com.bumptech.glide.loader.model.ModelStreamLoader;, +import com.bumptech.glide.loader.model.UrlStreamLoader;, +import com.bumptech.glide.presenter.ImagePresenter;, +import com.bumptech.glide.presenter.ImageSetCallback;, +import com.bumptech.glide.resize.ImageManager;, +import com.bumptech.glide.resize.loader.Approximate;, +import com.bumptech.glide.resize.loader.CenterCrop;, +import com.bumptech.glide.resize.loader.FitCenter;, +, +import java.io.File;, +import java.net.URL;, +import java.util.HashMap;, +import java.util.Map;, +, +/**, + * Static helper methods/classes to present a simple unified interface for using glide. Allows 90%, + * of the functionality of the library. The trade off is some extra unused object allocation, and a few unavailable, + * methods. For many users this should be enough to make effective use of the library. For others it can serve as a, + * starting point and example. This class is not thread safe., + */, +public class Glide {, +    private static final Glide GLIDE = new Glide();, +    private static final Map<Class, ModelStreamLoader> classToModelStream = new HashMap<Class, ModelStreamLoader>() {{, +        put(File.class, new FileStreamLoader());, +        put(URL.class, new UrlStreamLoader());, +    }};, +, +    private ImageManager imageManager;, +, +    public static Glide get() {, +        return GLIDE;, +    }, +, +    protected Glide() { }, +, +    /**, +     * Return the current {@link ImageManager} or create and return a new one if one is not currently set., +     *, +     * @see #setImageManager(com.bumptech.glide.resize.ImageManager.Builder), +     * @see #isImageManagerSet(), +     *, +     * @param context Any {@link Context}. This will not be retained passed this call, +     * @return The current ImageManager, +     */, +    public ImageManager getImageManager(Context context) {, +        if (!isImageManagerSet()) {, +            setImageManager(new ImageManager.Builder(context));, +        }, +        return imageManager;, +    }, +, +    /**, +     * Use to check whether or not an {@link ImageManager} has been set yet. Can be used in, +     * {@link android.app.Activity#onCreate(android.os.Bundle)} along with, +     * {@link #setImageManager(com.bumptech.glide.resize.ImageManager.Builder)} to set an {@link ImageManager} with, +     * custom options for use with {@link Glide#load(Object)} and/or as an easily accessible singleton., +     *, +     * @return true iff an {@link ImageManager} is currently set, +     */, +    public boolean isImageManagerSet() {, +        return imageManager != null;, +    }, +, +    /**, +     * @see #setImageManager(com.bumptech.glide.resize.ImageManager), +     *, +     * @param builder The builder that will be used to construct a new ImageManager, +     */, +    public void setImageManager(ImageManager.Builder builder) {, +        setImageManager(builder.build());, +    }, +, +    /**, +     * Set the {@link ImageManager} to use with {@link Glide#load(Object)}. Replaces the current {@link ImageManager}, +     * if one has already been set., +     *, +     * @see #isImageManagerSet(), +     *, +     * @param imageManager The ImageManager to use, +     */, +    public void setImageManager(ImageManager imageManager) {]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/DrawableTransformationTest.java, +import android.os.Handler;, +import android.os.Looper;, +import java.util.concurrent.CountDownLatch;, +import java.util.concurrent.TimeUnit;, +    // The following section is a hack to workaround a weird behavior where a post in RequestManager, +    // can cause a failed request to be started twice in a row if the first attempt happens before., +    // the post. This seems rather unlikely to happen in real applications and it only occurs when, +    // the request fails unexpectedly, so we're working around this weird behavior in this test., +    // See #3551., +, +    // Trigger the Glide application RequestManager to be created., +    Glide.get(context).getRequestManagerRetriever().get(context);, +    // Wait until it's added as a lifecycle observer., +    final CountDownLatch latch = new CountDownLatch(1);, +    new Handler(Looper.getMainLooper()).post(new Runnable() {, +      @Override, +      public void run() {, +        latch.countDown();, +      }, +    });, +    latch.await(5, TimeUnit.SECONDS);, +, +    // End hacks., +]
[+++ b/annotation/compiler/build.gradle, +// Make sure running `gradlew :annotation:compiler:check` actually does full quality control., +test.dependsOn ':annotation:compiler:test:test', +, +    inputs.files compiledJar, +++ b/annotation/compiler/build.gradle, +// Make sure running `gradlew :annotation:compiler:check` actually does full quality control., +test.dependsOn ':annotation:compiler:test:test', +, +    inputs.files compiledJar, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, + *    {@literal @android.support.annotation.NonNull}, + *    public java.util.Set&lt;java.lang.Class&lt;?>> getExcludedModuleClasses() {, +        .addAnnotation(ClassName.get("android.support.annotation", "NonNull")), +++ b/annotation/compiler/build.gradle, +// Make sure running `gradlew :annotation:compiler:check` actually does full quality control., +test.dependsOn ':annotation:compiler:test:test', +, +    inputs.files compiledJar, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, + *    {@literal @android.support.annotation.NonNull}, + *    public java.util.Set&lt;java.lang.Class&lt;?>> getExcludedModuleClasses() {, +        .addAnnotation(ClassName.get("android.support.annotation", "NonNull")), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +  private static final AnnotationSpec NON_NULL = AnnotationSpec, +      .builder(ClassName.get("android.support.annotation", "NonNull")), +      .build();, +        .addAnnotation(NON_NULL), +++ b/annotation/compiler/build.gradle, +// Make sure running `gradlew :annotation:compiler:check` actually does full quality control., +test.dependsOn ':annotation:compiler:test:test', +, +    inputs.files compiledJar, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, + *    {@literal @android.support.annotation.NonNull}, + *    public java.util.Set&lt;java.lang.Class&lt;?>> getExcludedModuleClasses() {, +        .addAnnotation(ClassName.get("android.support.annotation", "NonNull")), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +  private static final AnnotationSpec NON_NULL = AnnotationSpec, +      .builder(ClassName.get("android.support.annotation", "NonNull")), +      .build();, +        .addAnnotation(NON_NULL), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java, +  private static final AnnotationSpec NON_NULL = AnnotationSpec, +      .builder(ClassName.get("android.support.annotation", "NonNull")), +      .build();, +        .addAnnotation(NON_NULL), +        .addTypeVariable(TypeVariableName.get("ResourceType")), +        .addParameter(classOfResouceType.annotated(NON_NULL), "resourceClass"), +++ b/annotation/compiler/build.gradle, +// Make sure running `gradlew :annotation:compiler:check` actually does full quality control., +test.dependsOn ':annotation:compiler:test:test', +, +    inputs.files compiledJar, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, + *    {@literal @android.support.annotation.NonNull}, + *    public java.util.Set&lt;java.lang.Class&lt;?>> getExcludedModuleClasses() {, +        .addAnnotation(ClassName.get("android.support.annotation", "NonNull")), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +  private static final AnnotationSpec NON_NULL = AnnotationSpec, +      .builder(ClassName.get("android.support.annotation", "NonNull")), +      .build();, +        .addAnnotation(NON_NULL), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java, +  private static final AnnotationSpec NON_NULL = AnnotationSpec, +      .builder(ClassName.get("android.support.annotation", "NonNull")), +      .build();, +        .addAnnotation(NON_NULL), +        .addTypeVariable(TypeVariableName.get("ResourceType")), +        .addParameter(classOfResouceType.annotated(NON_NULL), "resourceClass"), +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java, +import android.support.annotation.NonNull;, +  @NonNull, +++ b/annotation/compiler/build.gradle, +// Make sure running `gradlew :annotation:compiler:check` actually does full quality control., +test.dependsOn ':annotation:compiler:test:test', +, +    inputs.files compiledJar, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, + *    {@literal @android.support.annotation.NonNull}, + *    public java.util.Set&lt;java.lang.Class&lt;?>> getExcludedModuleClasses() {, +        .addAnnotation(ClassName.get("android.support.annotation", "NonNull")), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +  private static final AnnotationSpec NON_NULL = AnnotationSpec, +      .builder(ClassName.get("android.support.annotation", "NonNull")), +      .build();, +        .addAnnotation(NON_NULL), +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java, +  private static final AnnotationSpec NON_NULL = AnnotationSpec, +      .builder(ClassName.get("android.support.annotation", "NonNull")), +      .build();, +        .addAnnotation(NON_NULL), +        .addTypeVariable(TypeVariableName.get("ResourceType")), +        .addParameter(classOfResouceType.annotated(NON_NULL), "resourceClass"), +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithExcludesTest/GeneratedAppGlideModuleImpl.java, +import android.support.annotation.NonNull;, +  @NonNull, +++ b/annotation/compiler/test/src/test/resources/AppGlideModuleWithMultipleExcludesTest/GeneratedAppGlideModuleImpl.java, +import android.support.annotation.NonNull;, +  @NonNull]
[+++ b/gradle.properties, +VERSION_NAME=3.5.0, +++ b/gradle.properties, +VERSION_NAME=3.5.0, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.2.0, +++ b/gradle.properties, +VERSION_NAME=3.5.0, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.2.0, +++ b/integration/volley/gradle.properties, +VERSION_NAME=1.2.0]
[+++ b/gradle.properties, +VERSION_NAME=3.4.0-SNAPSHOT, +VERSION_MINOR=4, +VERSION_CODE=6, +++ b/gradle.properties, +VERSION_NAME=3.4.0-SNAPSHOT, +VERSION_MINOR=4, +VERSION_CODE=6, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.1.0-SNAPSHOT, +VERSION_MINOR=1, +VERSION_CODE=2, +++ b/gradle.properties, +VERSION_NAME=3.4.0-SNAPSHOT, +VERSION_MINOR=4, +VERSION_CODE=6, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.1.0-SNAPSHOT, +VERSION_MINOR=1, +VERSION_CODE=2, +++ b/integration/volley/gradle.properties, +VERSION_NAME=1.1.0-SNAPSHOT, +VERSION_MINOR=1, +VERSION_CODE=2]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +    boolean isExifOrientationRequired = TransformationUtils.isExifOrientationRequired(orientation);, +    calculateConfig(, +        is,, +        decodeFormat,, +        isHardwareConfigAllowed,, +        isExifOrientationRequired,, +        options,, +        targetWidth,, +        targetHeight);, +  static void calculateScaling(DownsampleStrategy downsampleStrategy,, +      int degreesToRotate,, +      boolean isExifOrientationRequired,, +        targetWidth,, +        targetHeight,, +        optionsWithScaling,, +        format,, +        isHardwareConfigAllowed,, +        isExifOrientationRequired)) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +    boolean isExifOrientationRequired = TransformationUtils.isExifOrientationRequired(orientation);, +    calculateConfig(, +        is,, +        decodeFormat,, +        isHardwareConfigAllowed,, +        isExifOrientationRequired,, +        options,, +        targetWidth,, +        targetHeight);, +  static void calculateScaling(DownsampleStrategy downsampleStrategy,, +      int degreesToRotate,, +      boolean isExifOrientationRequired,, +        targetWidth,, +        targetHeight,, +        optionsWithScaling,, +        format,, +        isHardwareConfigAllowed,, +        isExifOrientationRequired)) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java, +      boolean isHardwareConfigAllowed,, +      boolean isExifOrientationRequired) {, +        || decodeFormat == DecodeFormat.PREFER_ARGB_8888_DISALLOW_HARDWARE, +        || isExifOrientationRequired) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +    boolean isExifOrientationRequired = TransformationUtils.isExifOrientationRequired(orientation);, +    calculateConfig(, +        is,, +        decodeFormat,, +        isHardwareConfigAllowed,, +        isExifOrientationRequired,, +        options,, +        targetWidth,, +        targetHeight);, +  static void calculateScaling(DownsampleStrategy downsampleStrategy,, +      int degreesToRotate,, +      boolean isExifOrientationRequired,, +        targetWidth,, +        targetHeight,, +        optionsWithScaling,, +        format,, +        isHardwareConfigAllowed,, +        isExifOrientationRequired)) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java, +      boolean isHardwareConfigAllowed,, +      boolean isExifOrientationRequired) {, +        || decodeFormat == DecodeFormat.PREFER_ARGB_8888_DISALLOW_HARDWARE, +        || isExifOrientationRequired) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/TransformationUtils.java, +    if (!isExifOrientationRequired(exifOrientation)) {, +    final Matrix matrix = new Matrix();, +    initializeMatrixForRotation(exifOrientation, matrix);, +, +   * Returns {@code true} if the given exif orientation indicates that a transformation is necessary, +   * and {@code false} otherwise., +   */, +  public static boolean isExifOrientationRequired(int exifOrientation) {, +    switch (exifOrientation) {, +      case ExifInterface.ORIENTATION_FLIP_HORIZONTAL:, +      case ExifInterface.ORIENTATION_ROTATE_180:, +      case ExifInterface.ORIENTATION_FLIP_VERTICAL:, +      case ExifInterface.ORIENTATION_TRANSPOSE:, +      case ExifInterface.ORIENTATION_ROTATE_90:, +      case ExifInterface.ORIENTATION_TRANSVERSE:, +      case ExifInterface.ORIENTATION_ROTATE_270:, +        return true;, +      default:, +        return false;, +    }, +  }, +, +  /**]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {, +      // GIFs, among other types, end up with a native Bitmap config that doesn't map to a java, +      // config and is treated as null in java code. On KitKat+ these Bitmaps can be reconfigured, +      // and are suitable for re-use., +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {, +      configs.remove(Bitmap.Config.HARDWARE);, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {, +      // GIFs, among other types, end up with a native Bitmap config that doesn't map to a java, +      // config and is treated as null in java code. On KitKat+ these Bitmaps can be reconfigured, +      // and are suitable for re-use., +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {, +      configs.remove(Bitmap.Config.HARDWARE);, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +import android.graphics.Bitmap.Config;, +  static final String TAG = "Downsampler";, +  private final HardwareConfigState hardwareConfigState = HardwareConfigState.getInstance();, +    calculateConfig(is, decodeFormat, options, targetWidth, targetHeight);, +  private void calculateConfig(, +      InputStream is,, +      DecodeFormat format,, +      BitmapFactory.Options optionsWithScaling,, +      int targetWidth,, +      int targetHeight), +      throws IOException {, +, +    if (hardwareConfigState.setHardwareConfigIfAllowed(, +        targetWidth, targetHeight, optionsWithScaling)) {, +      return;, +    }, +, +      optionsWithScaling.inPreferredConfig = Bitmap.Config.ARGB_8888;, +      return;, +    optionsWithScaling.inPreferredConfig =, +        hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;, +    if (optionsWithScaling.inPreferredConfig == Config.RGB_565, +        || optionsWithScaling.inPreferredConfig == Config.ARGB_4444, +        || optionsWithScaling.inPreferredConfig == Config.ALPHA_8) {, +      optionsWithScaling.inDither = true;, +    }, +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O, +        && options.inPreferredConfig == Config.HARDWARE) {, +      return;, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {, +      // GIFs, among other types, end up with a native Bitmap config that doesn't map to a java, +      // config and is treated as null in java code. On KitKat+ these Bitmaps can be reconfigured, +      // and are suitable for re-use., +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {, +      configs.remove(Bitmap.Config.HARDWARE);, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +import android.graphics.Bitmap.Config;, +  static final String TAG = "Downsampler";, +  private final HardwareConfigState hardwareConfigState = HardwareConfigState.getInstance();, +    calculateConfig(is, decodeFormat, options, targetWidth, targetHeight);, +  private void calculateConfig(, +      InputStream is,, +      DecodeFormat format,, +      BitmapFactory.Options optionsWithScaling,, +      int targetWidth,, +      int targetHeight), +      throws IOException {, +, +    if (hardwareConfigState.setHardwareConfigIfAllowed(, +        targetWidth, targetHeight, optionsWithScaling)) {, +      return;, +    }, +, +      optionsWithScaling.inPreferredConfig = Bitmap.Config.ARGB_8888;, +      return;, +    optionsWithScaling.inPreferredConfig =, +        hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;, +    if (optionsWithScaling.inPreferredConfig == Config.RGB_565, +        || optionsWithScaling.inPreferredConfig == Config.ARGB_4444, +        || optionsWithScaling.inPreferredConfig == Config.ALPHA_8) {, +      optionsWithScaling.inDither = true;, +    }, +    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O, +        && options.inPreferredConfig == Config.HARDWARE) {, +      return;, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/HardwareConfigState.java, +package com.bumptech.glide.load.resource.bitmap;, +, +import android.graphics.Bitmap;, +import android.graphics.BitmapFactory;, +import android.os.Build;, +import android.util.Log;, +import java.io.File;, +, +/**, + * State and constants for interacting with {@link android.graphics.Bitmap.Config#HARDWARE} on, + * Android O+., + */, +final class HardwareConfigState {]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +            any(),, +            any(),, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +            any(),, +            any(),, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java, +        any(),, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +            any(),, +            any(),, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/LoadBytesTest.java, +        any(),, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java, +    private final BitmapDrawable drawable;, +    private final BitmapPool bitmapPool;, +, +    private BitmapDrawable next;, +, +        this.next = drawable;, +        // We usually just have one consumer, so return the given drawable (created on a bg thread) to the first, +        // consumer and then create a new drawable for each subsequent consumer., +        if (next == null) {, +            next = (BitmapDrawable) drawable.getConstantState().newDrawable();, +        }, +        BitmapDrawable result = next;, +        next = null;, +        return result;, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java, +    private final BitmapDrawable drawable;, +    private final BitmapPool bitmapPool;, +, +    private BitmapDrawable next;, +, +        this.next = drawable;, +        // We usually just have one consumer, so return the given drawable (created on a bg thread) to the first, +        // consumer and then create a new drawable for each subsequent consumer., +        if (next == null) {, +            next = (BitmapDrawable) drawable.getConstantState().newDrawable();, +        }, +        BitmapDrawable result = next;, +        next = null;, +        return result;, +++ b/library/src/test/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResourceTest.java, +import static org.junit.Assert.assertFalse;, +, +    @Test, +    public void testReturnsDifferentDrawableEachTime() {, +        BitmapDrawableResource resource = harness.create();, +        BitmapDrawable first = resource.get();, +        BitmapDrawable second = resource.get();, +, +        assertFalse(first == second);, +    }, +]
[+++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java, +import android.content.res.AssetFileDescriptor;, +    AssetFileDescriptor assetFileDescriptor = contentResolver.openAssetFileDescriptor(uri, "r");, +    if (assetFileDescriptor == null) {, +      throw new FileNotFoundException("FileDescriptor is null for: " + uri);, +    }, +    return assetFileDescriptor.getParcelFileDescriptor();, +++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java, +import android.content.res.AssetFileDescriptor;, +    AssetFileDescriptor assetFileDescriptor = contentResolver.openAssetFileDescriptor(uri, "r");, +    if (assetFileDescriptor == null) {, +      throw new FileNotFoundException("FileDescriptor is null for: " + uri);, +    }, +    return assetFileDescriptor.getParcelFileDescriptor();, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +    InputStream inputStream = contentResolver.openInputStream(uri);, +    if (inputStream == null) {, +      throw new FileNotFoundException("InputStream is null for :" + uri);, +    }, +    return inputStream;, +++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java, +import android.content.res.AssetFileDescriptor;, +    AssetFileDescriptor assetFileDescriptor = contentResolver.openAssetFileDescriptor(uri, "r");, +    if (assetFileDescriptor == null) {, +      throw new FileNotFoundException("FileDescriptor is null for: " + uri);, +    }, +    return assetFileDescriptor.getParcelFileDescriptor();, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +    InputStream inputStream = contentResolver.openInputStream(uri);, +    if (inputStream == null) {, +      throw new FileNotFoundException("InputStream is null for :" + uri);, +    }, +    return inputStream;, +++ b/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java, +import static org.mockito.Matchers.isA;, +import java.io.FileNotFoundException;, +, +  public void testLoadResource_returnsFileDescriptor() throws Exception {, +    Context context = RuntimeEnvironment.application;, +    Uri uri = Uri.parse("file://nothing");, +  @Test, +  public void testLoadResource_withNullFileDescriptor_callsLoadFailed() {, +    Context context = RuntimeEnvironment.application;, +    Uri uri = Uri.parse("file://nothing");, +, +    ContentResolver contentResolver = context.getContentResolver();, +    ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);, +    shadow.registerFileDescriptor(uri, null /*fileDescriptor*/);, +, +    FileDescriptorLocalUriFetcher fetcher = new FileDescriptorLocalUriFetcher(context, uri);, +    fetcher.loadData(Priority.NORMAL, callback);, +    verify(callback).onLoadFailed(isA(FileNotFoundException.class));, +  }, +++ b/library/src/main/java/com/bumptech/glide/load/data/FileDescriptorLocalUriFetcher.java, +import android.content.res.AssetFileDescriptor;, +    AssetFileDescriptor assetFileDescriptor = contentResolver.openAssetFileDescriptor(uri, "r");, +    if (assetFileDescriptor == null) {, +      throw new FileNotFoundException("FileDescriptor is null for: " + uri);, +    }, +    return assetFileDescriptor.getParcelFileDescriptor();, +++ b/library/src/main/java/com/bumptech/glide/load/data/StreamLocalUriFetcher.java, +    InputStream inputStream = contentResolver.openInputStream(uri);, +    if (inputStream == null) {, +      throw new FileNotFoundException("InputStream is null for :" + uri);, +    }, +    return inputStream;, +++ b/library/src/test/java/com/bumptech/glide/load/data/resource/FileDescriptorLocalUriFetcherTest.java, +import static org.mockito.Matchers.isA;, +import java.io.FileNotFoundException;, +, +  public void testLoadResource_returnsFileDescriptor() throws Exception {, +    Context context = RuntimeEnvironment.application;, +    Uri uri = Uri.parse("file://nothing");, +  @Test, +  public void testLoadResource_withNullFileDescriptor_callsLoadFailed() {, +    Context context = RuntimeEnvironment.application;, +    Uri uri = Uri.parse("file://nothing");, +, +    ContentResolver contentResolver = context.getContentResolver();, +    ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);, +    shadow.registerFileDescriptor(uri, null /*fileDescriptor*/);, +, +    FileDescriptorLocalUriFetcher fetcher = new FileDescriptorLocalUriFetcher(context, uri);, +    fetcher.loadData(Priority.NORMAL, callback);, +    verify(callback).onLoadFailed(isA(FileNotFoundException.class));, +  }, +++ b/library/src/test/java/com/bumptech/glide/load/data/resource/StreamLocalUriFetcherTest.java, +import static org.mockito.Matchers.isA;, +import android.content.ContentResolver;, +import com.bumptech.glide.tests.ContentResolverShadow;, +import org.robolectric.internal.ShadowExtractor;, +import java.io.ByteArrayInputStream;, +import java.io.FileNotFoundException;, +@Config(manifest = Config.NONE, sdk = 18, shadows = { ContentResolverShadow.class }), +  public void testLoadResource_returnsInputStream() throws Exception {, +    Context context = RuntimeEnvironment.application;, +    Uri uri = Uri.parse("file://nothing");, +, +    ContentResolver contentResolver = context.getContentResolver();, +    ContentResolverShadow shadow = (ContentResolverShadow) ShadowExtractor.extract(contentResolver);]
[+++ b/library/test/src/test/java/com/bumptech/glide/GlideTest.java, +    ArgumentCaptor<Drawable> drawableCaptor = ArgumentCaptor.forClass(Drawable.class);, +    verify(target).onResourceReady(drawableCaptor.capture(), any(Transition.class));, +    assertThat(((ColorDrawable) drawableCaptor.getValue()).getColor()).isEqualTo(Color.RED);, +++ b/library/test/src/test/java/com/bumptech/glide/GlideTest.java, +    ArgumentCaptor<Drawable> drawableCaptor = ArgumentCaptor.forClass(Drawable.class);, +    verify(target).onResourceReady(drawableCaptor.capture(), any(Transition.class));, +    assertThat(((ColorDrawable) drawableCaptor.getValue()).getColor()).isEqualTo(Color.RED);, +++ b/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java, +    RequestOptions apply = options.fallback(new ColorDrawable(Color.RED)).apply(toApply);, +    assertThat(((ColorDrawable) apply.getFallbackDrawable()).getColor()).isEqualTo(Color.RED);, +++ b/library/test/src/test/java/com/bumptech/glide/GlideTest.java, +    ArgumentCaptor<Drawable> drawableCaptor = ArgumentCaptor.forClass(Drawable.class);, +    verify(target).onResourceReady(drawableCaptor.capture(), any(Transition.class));, +    assertThat(((ColorDrawable) drawableCaptor.getValue()).getColor()).isEqualTo(Color.RED);, +++ b/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java, +    RequestOptions apply = options.fallback(new ColorDrawable(Color.RED)).apply(toApply);, +    assertThat(((ColorDrawable) apply.getFallbackDrawable()).getColor()).isEqualTo(Color.RED);, +++ b/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java, +++ b/library/test/src/test/java/com/bumptech/glide/GlideTest.java, +    ArgumentCaptor<Drawable> drawableCaptor = ArgumentCaptor.forClass(Drawable.class);, +    verify(target).onResourceReady(drawableCaptor.capture(), any(Transition.class));, +    assertThat(((ColorDrawable) drawableCaptor.getValue()).getColor()).isEqualTo(Color.RED);, +++ b/library/test/src/test/java/com/bumptech/glide/request/RequestOptionsTest.java, +    RequestOptions apply = options.fallback(new ColorDrawable(Color.RED)).apply(toApply);, +    assertThat(((ColorDrawable) apply.getFallbackDrawable()).getColor()).isEqualTo(Color.RED);, +++ b/library/test/src/test/java/com/bumptech/glide/request/SingleRequestTest.java, +++ b/library/test/src/test/java/com/bumptech/glide/request/target/ImageViewTargetTest.java, +import static com.google.common.truth.Truth.assertThat;, +import org.mockito.ArgumentCaptor;, +    ArgumentCaptor<Drawable> drawableCaptor = ArgumentCaptor.forClass(Drawable.class);, +    verify(animation).transition(drawableCaptor.capture(), eq(target));, +    assertThat(((ColorDrawable) drawableCaptor.getValue()).getColor()).isEqualTo(Color.GREEN);]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceDecoderTest.java, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import static org.mockito.Mockito.never;, +        decoder = new GifBitmapWrapperResourceDecoder(bitmapDecoder, gifDecoder, mock(BitmapPool.class), parser,, +                streamFactory);, +        Bitmap firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +        when(gifResource.get().getFirstFrame()).thenReturn(firstFrame);, +        assertEquals(firstFrame, result.get().getBitmapResource().get());, +    public void testDoesNotCallBitmapDecoderWhenGifTypeButGifHasSingleFrame() throws IOException {, +        Bitmap firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +        Resource<GifDrawable> gifResource = mockGifResource();, +        when(gifResource.get().getFrameCount()).thenReturn(1);, +        when(gifResource.get().getFirstFrame()).thenReturn(firstFrame);, +, +        when(parser.parse(eq(bis))).thenReturn(ImageHeaderParser.ImageType.GIF);, +        when(gifDecoder.decode(any(InputStream.class), anyInt(), anyInt())).thenReturn(gifResource);, +, +        decoder.decode(source, 100, 100);, +, +        verify(bitmapDecoder, never()).decode(any(ImageVideoWrapper.class), anyInt(), anyInt());, +    }, +, +    @Test, +    public void testDoesNotRecycleGifResourceWhenGifTypeButGifHasSingleFrame() throws IOException {, +        verify(gifResource, never()).recycle();, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceDecoderTest.java, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import static org.mockito.Mockito.never;, +        decoder = new GifBitmapWrapperResourceDecoder(bitmapDecoder, gifDecoder, mock(BitmapPool.class), parser,, +                streamFactory);, +        Bitmap firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +        when(gifResource.get().getFirstFrame()).thenReturn(firstFrame);, +        assertEquals(firstFrame, result.get().getBitmapResource().get());, +    public void testDoesNotCallBitmapDecoderWhenGifTypeButGifHasSingleFrame() throws IOException {, +        Bitmap firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +        Resource<GifDrawable> gifResource = mockGifResource();, +        when(gifResource.get().getFrameCount()).thenReturn(1);, +        when(gifResource.get().getFirstFrame()).thenReturn(firstFrame);, +, +        when(parser.parse(eq(bis))).thenReturn(ImageHeaderParser.ImageType.GIF);, +        when(gifDecoder.decode(any(InputStream.class), anyInt(), anyInt())).thenReturn(gifResource);, +, +        decoder.decode(source, 100, 100);, +, +        verify(bitmapDecoder, never()).decode(any(ImageVideoWrapper.class), anyInt(), anyInt());, +    }, +, +    @Test, +    public void testDoesNotRecycleGifResourceWhenGifTypeButGifHasSingleFrame() throws IOException {, +        verify(gifResource, never()).recycle();, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +                new ImageVideoGifDrawableLoadProvider(imageVideoDataLoadProvider, gifDrawableLoadProvider, bitmapPool));, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceDecoderTest.java, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import static org.mockito.Mockito.never;, +        decoder = new GifBitmapWrapperResourceDecoder(bitmapDecoder, gifDecoder, mock(BitmapPool.class), parser,, +                streamFactory);, +        Bitmap firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +        when(gifResource.get().getFirstFrame()).thenReturn(firstFrame);, +        assertEquals(firstFrame, result.get().getBitmapResource().get());, +    public void testDoesNotCallBitmapDecoderWhenGifTypeButGifHasSingleFrame() throws IOException {, +        Bitmap firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +        Resource<GifDrawable> gifResource = mockGifResource();, +        when(gifResource.get().getFrameCount()).thenReturn(1);, +        when(gifResource.get().getFirstFrame()).thenReturn(firstFrame);, +, +        when(parser.parse(eq(bis))).thenReturn(ImageHeaderParser.ImageType.GIF);, +        when(gifDecoder.decode(any(InputStream.class), anyInt(), anyInt())).thenReturn(gifResource);, +, +        decoder.decode(source, 100, 100);, +, +        verify(bitmapDecoder, never()).decode(any(ImageVideoWrapper.class), anyInt(), anyInt());, +    }, +, +    @Test, +    public void testDoesNotRecycleGifResourceWhenGifTypeButGifHasSingleFrame() throws IOException {, +        verify(gifResource, never()).recycle();, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +                new ImageVideoGifDrawableLoadProvider(imageVideoDataLoadProvider, gifDrawableLoadProvider, bitmapPool));, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java, + *         if (toTransform.getWidth() == outWidth && toTransform.getHeight() == outHeight) {, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gifbitmap/GifBitmapWrapperResourceDecoderTest.java, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import static org.mockito.Mockito.never;, +        decoder = new GifBitmapWrapperResourceDecoder(bitmapDecoder, gifDecoder, mock(BitmapPool.class), parser,, +                streamFactory);, +        Bitmap firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +        when(gifResource.get().getFirstFrame()).thenReturn(firstFrame);, +        assertEquals(firstFrame, result.get().getBitmapResource().get());, +    public void testDoesNotCallBitmapDecoderWhenGifTypeButGifHasSingleFrame() throws IOException {, +        Bitmap firstFrame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);, +        Resource<GifDrawable> gifResource = mockGifResource();, +        when(gifResource.get().getFrameCount()).thenReturn(1);, +        when(gifResource.get().getFirstFrame()).thenReturn(firstFrame);, +, +        when(parser.parse(eq(bis))).thenReturn(ImageHeaderParser.ImageType.GIF);, +        when(gifDecoder.decode(any(InputStream.class), anyInt(), anyInt())).thenReturn(gifResource);, +, +        decoder.decode(source, 100, 100);, +]
[+++ b/library/findbugs-exclude.xml, +    <!-- Inconsistent synchronization is due to synchronizing on Engine/listener to avoid deadlock only. -->, +    <Match>, +      <Class name="com.bumptech.glide.load.engine.EngineResource" />, +      <Bug pattern="IS2_INCONSISTENT_SYNC" />, +    </Match>, +]
[+++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.manager.Lifecycle;, +            Class<TranscodeType> transcodeClass, Glide glide, RequestTracker requestTracker, Lifecycle lifecycle) {, +        super(context, model, streamLoadProvider, transcodeClass, glide, requestTracker, lifecycle);, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.manager.Lifecycle;, +            Class<TranscodeType> transcodeClass, Glide glide, RequestTracker requestTracker, Lifecycle lifecycle) {, +        super(context, model, streamLoadProvider, transcodeClass, glide, requestTracker, lifecycle);, +++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +import com.bumptech.glide.manager.Lifecycle;, +    private final ModelLoader<ModelType, ParcelFileDescriptor> fileDescriptorModelLoader;, +    private final RequestTracker requestTracker;, +    private final RequestManager.OptionsApplier optionsApplier;, +    private final Lifecycle lifecycle;, +            Glide glide, RequestTracker requestTracker, Lifecycle lifecycle,, +            RequestManager.OptionsApplier optionsApplier) {, +                glide, requestTracker, lifecycle);, +        this.lifecycle = lifecycle;, +                transcodeClass, glide, requestTracker, lifecycle));, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.manager.Lifecycle;, +            Class<TranscodeType> transcodeClass, Glide glide, RequestTracker requestTracker, Lifecycle lifecycle) {, +        super(context, model, streamLoadProvider, transcodeClass, glide, requestTracker, lifecycle);, +++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +import com.bumptech.glide.manager.Lifecycle;, +    private final ModelLoader<ModelType, ParcelFileDescriptor> fileDescriptorModelLoader;, +    private final RequestTracker requestTracker;, +    private final RequestManager.OptionsApplier optionsApplier;, +    private final Lifecycle lifecycle;, +            Glide glide, RequestTracker requestTracker, Lifecycle lifecycle,, +            RequestManager.OptionsApplier optionsApplier) {, +                glide, requestTracker, lifecycle);, +        this.lifecycle = lifecycle;, +                transcodeClass, glide, requestTracker, lifecycle));, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.manager.Lifecycle;, +            RequestTracker requestTracker, Lifecycle lifecycle) {, +        super(context, model, loadProvider, Drawable.class, glide, requestTracker, lifecycle);, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.manager.Lifecycle;, +            Class<TranscodeType> transcodeClass, Glide glide, RequestTracker requestTracker, Lifecycle lifecycle) {, +        super(context, model, streamLoadProvider, transcodeClass, glide, requestTracker, lifecycle);, +++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +import com.bumptech.glide.manager.Lifecycle;, +    private final ModelLoader<ModelType, ParcelFileDescriptor> fileDescriptorModelLoader;, +    private final RequestTracker requestTracker;, +    private final RequestManager.OptionsApplier optionsApplier;, +    private final Lifecycle lifecycle;, +            Glide glide, RequestTracker requestTracker, Lifecycle lifecycle,, +            RequestManager.OptionsApplier optionsApplier) {, +                glide, requestTracker, lifecycle);, +        this.lifecycle = lifecycle;, +                transcodeClass, glide, requestTracker, lifecycle));, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.manager.Lifecycle;, +            RequestTracker requestTracker, Lifecycle lifecycle) {, +        super(context, model, loadProvider, Drawable.class, glide, requestTracker, lifecycle);, +++ b/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java, +import com.bumptech.glide.manager.Lifecycle;, +    private Lifecycle lifecycle;, +            RequestTracker requestTracker, Lifecycle lifecycle, RequestManager.OptionsApplier optionsApplier) {, +                glide, requestTracker, lifecycle);, +        this.lifecycle = lifecycle;, +                fileDescriptorModelLoader, glide, requestTracker, lifecycle, optionsApplier));, +                requestTracker, lifecycle, optionsApplier));, +                model, streamModelLoader, InputStream.class, File.class, requestTracker, lifecycle, optionsApplier));, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.manager.Lifecycle;, +            Class<TranscodeType> transcodeClass, Glide glide, RequestTracker requestTracker, Lifecycle lifecycle) {, +        super(context, model, streamLoadProvider, transcodeClass, glide, requestTracker, lifecycle);, +++ b/library/src/main/java/com/bumptech/glide/BitmapTypeRequest.java, +import com.bumptech.glide.manager.Lifecycle;, +    private final ModelLoader<ModelType, ParcelFileDescriptor> fileDescriptorModelLoader;, +    private final RequestTracker requestTracker;, +    private final RequestManager.OptionsApplier optionsApplier;, +    private final Lifecycle lifecycle;, +            Glide glide, RequestTracker requestTracker, Lifecycle lifecycle,, +            RequestManager.OptionsApplier optionsApplier) {, +                glide, requestTracker, lifecycle);, +        this.lifecycle = lifecycle;, +                transcodeClass, glide, requestTracker, lifecycle));, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.manager.Lifecycle;, +            RequestTracker requestTracker, Lifecycle lifecycle) {, +        super(context, model, loadProvider, Drawable.class, glide, requestTracker, lifecycle);, +++ b/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java, +import com.bumptech.glide.manager.Lifecycle;, +    private Lifecycle lifecycle;, +            RequestTracker requestTracker, Lifecycle lifecycle, RequestManager.OptionsApplier optionsApplier) {, +                glide, requestTracker, lifecycle);, +        this.lifecycle = lifecycle;, +                fileDescriptorModelLoader, glide, requestTracker, lifecycle, optionsApplier));, +                requestTracker, lifecycle, optionsApplier));, +                model, streamModelLoader, InputStream.class, File.class, requestTracker, lifecycle, optionsApplier));, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +import com.bumptech.glide.manager.Lifecycle;, +    private Lifecycle lifecycle;, +            Class<TranscodeType> transcodeClass, Glide glide, RequestTracker requestTracker, Lifecycle lifecycle) {, +        this.lifecycle = lifecycle;, +        lifecycle.addListener(target);]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/FitCenter.java]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN, +        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN, +        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN, +        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {, +      trimToSize(getMaxSize() / 2);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN, +        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN, +        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {, +      trimToSize(getMaxSize() / 2);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java, +      // Entering list of cached background apps, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN, +        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {, +      // The app's UI is no longer visible, or app is in the foreground but system is running, +      // critically low on memory, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN, +        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN, +        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {, +      trimToSize(getMaxSize() / 2);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java, +      // Entering list of cached background apps, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN, +        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {, +      // The app's UI is no longer visible, or app is in the foreground but system is running, +      // critically low on memory, +++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java, +import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;, +  public void testTrimMemoryRunningCriticalRemovesHalfOfBitmaps() {, +    testTrimMemory(MAX_SIZE, TRIM_MEMORY_RUNNING_CRITICAL, MAX_SIZE / 2);, +  }, +, +  @Test, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN, +        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN, +        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {, +      trimToSize(getMaxSize() / 2);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java, +      // Entering list of cached background apps, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN, +        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {, +      // The app's UI is no longer visible, or app is in the foreground but system is running, +      // critically low on memory, +++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java, +import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;, +  public void testTrimMemoryRunningCriticalRemovesHalfOfBitmaps() {, +    testTrimMemory(MAX_SIZE, TRIM_MEMORY_RUNNING_CRITICAL, MAX_SIZE / 2);, +  }, +, +  @Test, +++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;, +  public void testTrimMemoryRunningCriticalRemovesHalfOfBitmaps() {, +    testTrimMemory(MAX_SIZE, TRIM_MEMORY_RUNNING_CRITICAL, MAX_SIZE / 2);, +  }, +, +  @Test, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPool.java, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN, +        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN, +        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {, +      trimToSize(getMaxSize() / 2);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java, +      // Entering list of cached background apps, +    } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN, +        || level == android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) {, +      // The app's UI is no longer visible, or app is in the foreground but system is running, +      // critically low on memory, +++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruArrayPoolTest.java, +import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;, +  public void testTrimMemoryRunningCriticalRemovesHalfOfBitmaps() {, +    testTrimMemory(MAX_SIZE, TRIM_MEMORY_RUNNING_CRITICAL, MAX_SIZE / 2);, +  }, +, +  @Test, +++ b/library/test/src/test/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPoolTest.java, +import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;, +  public void testTrimMemoryRunningCriticalRemovesHalfOfBitmaps() {, +    testTrimMemory(MAX_SIZE, TRIM_MEMORY_RUNNING_CRITICAL, MAX_SIZE / 2);, +  }, +, +  @Test, +++ b/library/test/src/test/java/com/bumptech/glide/load/engine/cache/LruResourceCacheTest.java, +  public void testTrimMemoryRunningCritical() {, +    TrimClearMemoryCacheHarness harness = new TrimClearMemoryCacheHarness();]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java, +            return !input.getSimpleName().toString().equals("as");]
[+++ b/annotation/compiler/build.gradle, +def packagingFolder = file("${buildDir}/intermediates"), +def repackagedJar = file("${packagingFolder}/repackaged.jar"), +def proguardedJar = file("${packagingFolder}/proguarded.jar"), +    destinationDir = packagingFolder, +    archiveName = 'compiled.jar', +                zipfileset(src: tasks.compiledJar.archivePath), +// Create the standard jar artifact based on our compiled, repackaged and proguarded jar., +++ b/annotation/compiler/build.gradle, +def packagingFolder = file("${buildDir}/intermediates"), +def repackagedJar = file("${packagingFolder}/repackaged.jar"), +def proguardedJar = file("${packagingFolder}/proguarded.jar"), +    destinationDir = packagingFolder, +    archiveName = 'compiled.jar', +                zipfileset(src: tasks.compiledJar.archivePath), +// Create the standard jar artifact based on our compiled, repackaged and proguarded jar., +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, + * {@code AppGlideModule}, {@code com.bumptech.glide.Glide},, + * {@code com.bumptech.glide.RequestManager}, and, + * {@code com.bumptech.glide.request.RequestOptions} classes., +++ b/annotation/compiler/build.gradle, +def packagingFolder = file("${buildDir}/intermediates"), +def repackagedJar = file("${packagingFolder}/repackaged.jar"), +def proguardedJar = file("${packagingFolder}/proguarded.jar"), +    destinationDir = packagingFolder, +    archiveName = 'compiled.jar', +                zipfileset(src: tasks.compiledJar.archivePath), +// Create the standard jar artifact based on our compiled, repackaged and proguarded jar., +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, + * {@code AppGlideModule}, {@code com.bumptech.glide.Glide},, + * {@code com.bumptech.glide.RequestManager}, and, + * {@code com.bumptech.glide.request.RequestOptions} classes., +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, + * <p>This processor discovers all {@code AppGlideModule} and, + * {@code LibraryGlideModule} implementations that are, + *   <li>For {@code LibraryGlideModule}s - A GlideIndexer class in a, + *      {@code LibraryGlideModule} classes., + *   <li>For {@code AppGlideModule}s - A single, + *      {@code AppGlideModule} implementation, + *     ({@code com.bumptech.glide.GeneratedAppGlideModule}) that calls all, + *     {@code LibraryGlideModule}s and the, + *     original {@code AppGlideModule} in the correct order when Glide is, + *     <li>A {@code com.bumptech.glide.request.RequestOptions} implementation that contains, + *       <li>A {@code com.bumptech.glide.RequestManager} implementation containing a generated, + *       <li>A {@code com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}, + *       implementation that produces the generated {@code com.bumptech.glide.RequestManager}s., + *       <li>A {@code com.bumptech.glide.Glide} look-alike that implements all static methods in, + *       the {@code com.bumptech.glide.Glide} singleton and returns the generated, + *       {@code com.bumptech.glide.RequestManager} implementation when appropriate., + * <p>{@code AppGlideModule} implementations must only be included in, + * {@code AppGlideModule} implementation per, + * Application. The {@code AppGlideModule} class is, + * {@code com.bumptech.glide.GeneratedAppGlideModule} impl can be created., +    *   <li>Find all {@code AppGlideModule}s and save them to an instance variable (throw if > 1)., +    *   <li>Find all {@code LibraryGlideModule}s, +    *   <li>For each {@code LibraryGlideModule},, +    *       write an {@code Indexer} with an Annotation with the class name., +    *   <li>If we wrote any {@code Indexer}s, return and wait for the next round., +    *   <li>If we didn't write any {@code Indexer}s and there is a {@code AppGlideModule},, +    *       write the {@code GeneratedAppGlideModule}., +    *       Once the {@code GeneratedAppGlideModule} is written, we expect to be finished., +    *       Any further generation of related classes will result in errors., +++ b/annotation/compiler/build.gradle, +def packagingFolder = file("${buildDir}/intermediates"), +def repackagedJar = file("${packagingFolder}/repackaged.jar"), +def proguardedJar = file("${packagingFolder}/proguarded.jar"), +    destinationDir = packagingFolder, +    archiveName = 'compiled.jar', +                zipfileset(src: tasks.compiledJar.archivePath), +// Create the standard jar artifact based on our compiled, repackaged and proguarded jar., +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, + * {@code AppGlideModule}, {@code com.bumptech.glide.Glide},, + * {@code com.bumptech.glide.RequestManager}, and, + * {@code com.bumptech.glide.request.RequestOptions} classes., +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, + * <p>This processor discovers all {@code AppGlideModule} and, + * {@code LibraryGlideModule} implementations that are, + *   <li>For {@code LibraryGlideModule}s - A GlideIndexer class in a, + *      {@code LibraryGlideModule} classes., + *   <li>For {@code AppGlideModule}s - A single, + *      {@code AppGlideModule} implementation, + *     ({@code com.bumptech.glide.GeneratedAppGlideModule}) that calls all, + *     {@code LibraryGlideModule}s and the, + *     original {@code AppGlideModule} in the correct order when Glide is, + *     <li>A {@code com.bumptech.glide.request.RequestOptions} implementation that contains, + *       <li>A {@code com.bumptech.glide.RequestManager} implementation containing a generated, + *       <li>A {@code com.bumptech.glide.manager.RequestManagerRetriever.RequestManagerFactory}, + *       implementation that produces the generated {@code com.bumptech.glide.RequestManager}s., + *       <li>A {@code com.bumptech.glide.Glide} look-alike that implements all static methods in, + *       the {@code com.bumptech.glide.Glide} singleton and returns the generated, + *       {@code com.bumptech.glide.RequestManager} implementation when appropriate., + * <p>{@code AppGlideModule} implementations must only be included in, + * {@code AppGlideModule} implementation per, + * Application. The {@code AppGlideModule} class is, + * {@code com.bumptech.glide.GeneratedAppGlideModule} impl can be created., +    *   <li>Find all {@code AppGlideModule}s and save them to an instance variable (throw if > 1)., +    *   <li>Find all {@code LibraryGlideModule}s, +    *   <li>For each {@code LibraryGlideModule},, +    *       write an {@code Indexer} with an Annotation with the class name., +    *   <li>If we wrote any {@code Indexer}s, return and wait for the next round.]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +    private final GifFrameManager frameManager;, +    private final GifState state;, +    private final GifDecoder decoder;, +, +    /** The current frame to draw, or null if no frame has been loaded yet */, +    /** True if the drawable is currently animating */, +    private boolean isRunning;, +    /** True if the drawable should animate while visible */, +    private boolean isStarted;, +    /** True if the drawable's resources have been recycled */, +    /** True if the drawable is currently visible. */, +    private boolean isVisible;, +        isStarted = true;, +        if (isVisible) {, +            startRunning();, +        }, +    }, +, +    @Override, +    public void stop() {, +        isStarted = false;, +        stopRunning();, +    }, +, +    private void startRunning() {, +    private void stopRunning() {, +        isRunning = false;, +    }, +, +        isVisible = visible;, +            stopRunning();, +        } else if (isStarted) {, +            startRunning();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +    private final GifFrameManager frameManager;, +    private final GifState state;, +    private final GifDecoder decoder;, +, +    /** The current frame to draw, or null if no frame has been loaded yet */, +    /** True if the drawable is currently animating */, +    private boolean isRunning;, +    /** True if the drawable should animate while visible */, +    private boolean isStarted;, +    /** True if the drawable's resources have been recycled */, +    /** True if the drawable is currently visible. */, +    private boolean isVisible;, +        isStarted = true;, +        if (isVisible) {, +            startRunning();, +        }, +    }, +, +    @Override, +    public void stop() {, +        isStarted = false;, +        stopRunning();, +    }, +, +    private void startRunning() {, +    private void stopRunning() {, +        isRunning = false;, +    }, +, +        isVisible = visible;, +            stopRunning();, +        } else if (isStarted) {, +            startRunning();, +++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java, +        if (resource instanceof Animatable) {, +            ((Animatable) resource).start();, +        }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +    private final GifFrameManager frameManager;, +    private final GifState state;, +    private final GifDecoder decoder;, +, +    /** The current frame to draw, or null if no frame has been loaded yet */, +    /** True if the drawable is currently animating */, +    private boolean isRunning;, +    /** True if the drawable should animate while visible */, +    private boolean isStarted;, +    /** True if the drawable's resources have been recycled */, +    /** True if the drawable is currently visible. */, +    private boolean isVisible;, +        isStarted = true;, +        if (isVisible) {, +            startRunning();, +        }, +    }, +, +    @Override, +    public void stop() {, +        isStarted = false;, +        stopRunning();, +    }, +, +    private void startRunning() {, +    private void stopRunning() {, +        isRunning = false;]
[+++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java, +    private static final float SQUARE_RATIO_MARGIN = 0.05f;, +, +        //TODO: Try to generalize this to other sizes/shapes., +        // This is a dirty hack that tries to make loading square thumbnails and then square full images less costly by, +        // forcing both the smaller thumb and the larger version to have exactly the same intrinsic dimensions. If a, +        // drawable is replaced in an ImageView by another drawable with different intrinsic dimensions, the ImageView, +        // requests a layout. Scrolling rapidly while replacing thumbs with larger images triggers lots of these calls, +        // and causes significant amounts of jank., +        float viewRatio = view.getWidth() / (float) view.getHeight();, +        float drawableRatio = resource.getIntrinsicWidth() / (float) resource.getIntrinsicHeight();, +        if (Math.abs(viewRatio - 1f) <= SQUARE_RATIO_MARGIN && Math.abs(drawableRatio - 1f) <= SQUARE_RATIO_MARGIN) {, +            resource = new SquaringDrawable(resource, view.getWidth());, +        }, +, +++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java, +    private static final float SQUARE_RATIO_MARGIN = 0.05f;, +, +        //TODO: Try to generalize this to other sizes/shapes., +        // This is a dirty hack that tries to make loading square thumbnails and then square full images less costly by, +        // forcing both the smaller thumb and the larger version to have exactly the same intrinsic dimensions. If a, +        // drawable is replaced in an ImageView by another drawable with different intrinsic dimensions, the ImageView, +        // requests a layout. Scrolling rapidly while replacing thumbs with larger images triggers lots of these calls, +        // and causes significant amounts of jank., +        float viewRatio = view.getWidth() / (float) view.getHeight();, +        float drawableRatio = resource.getIntrinsicWidth() / (float) resource.getIntrinsicHeight();, +        if (Math.abs(viewRatio - 1f) <= SQUARE_RATIO_MARGIN && Math.abs(drawableRatio - 1f) <= SQUARE_RATIO_MARGIN) {, +            resource = new SquaringDrawable(resource, view.getWidth());, +        }, +, +++ b/library/src/main/java/com/bumptech/glide/request/target/SquaringDrawable.java, +package com.bumptech.glide.request.target;, +, +import android.annotation.TargetApi;, +import android.graphics.Canvas;, +import android.graphics.ColorFilter;, +import android.graphics.PorterDuff;, +import android.graphics.Rect;, +import android.graphics.drawable.Drawable;, +, +/**, + * A wrapper drawable to square the wrapped drawable so that it expands to fill a square with exactly the given side, + * length. The goal of this drawable is to ensure that square thumbnail drawables always match the size of the view, + * they will be displayed in to avoid a costly requestLayout call. This class should not be used with views or drawables, + * that are not square., + */, +public class SquaringDrawable extends Drawable {, +    private final Drawable wrapped;, +    private int side;, +, +    public SquaringDrawable(Drawable wrapped, int side) {, +        this.wrapped = wrapped;, +        this.side = side;, +    }, +, +    @Override, +    public void setBounds(int left, int top, int right, int bottom) {, +        super.setBounds(left, top, right, bottom);, +        wrapped.setBounds(left, top, right, bottom);, +    }, +, +    @Override, +    public void setBounds(Rect bounds) {, +        super.setBounds(bounds);, +        wrapped.setBounds(bounds);, +    }, +    public void setChangingConfigurations(int configs) {, +        wrapped.setChangingConfigurations(configs);, +    }, +, +    @Override, +    public int getChangingConfigurations() {, +        return wrapped.getChangingConfigurations();, +    }, +, +    @Override, +    public void setDither(boolean dither) {, +        wrapped.setDither(dither);, +    }, +, +    @Override, +    public void setFilterBitmap(boolean filter) {, +        wrapped.setFilterBitmap(filter);, +    }, +, +    @TargetApi(11), +    @Override, +    public Callback getCallback() {, +        return wrapped.getCallback();, +    }, +, +    @TargetApi(19), +    @Override, +    public int getAlpha() {, +        return wrapped.getAlpha();, +    }, +, +    @Override, +    public void setColorFilter(int color, PorterDuff.Mode mode) {, +        wrapped.setColorFilter(color, mode);]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +import com.google.common.base.Joiner;, +  static CodeBlock generateCastingSuperCall(TypeName toReturn, ExecutableElement method) {, +    return CodeBlock.builder(), +        .add("return ($T) super.$N(", toReturn, method.getSimpleName()), +        .add(, +            FluentIterable.from(method.getParameters()), +                .transform(new Function<VariableElement, String>() {, +                  @Nullable, +                  @Override, +                  public String apply(VariableElement input) {, +                    return input.getSimpleName().toString();, +                  }, +                }), +                .join(Joiner.on(","))), +        .add(");\n"), +        .build();, +  }, +, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +import com.google.common.base.Joiner;, +  static CodeBlock generateCastingSuperCall(TypeName toReturn, ExecutableElement method) {, +    return CodeBlock.builder(), +        .add("return ($T) super.$N(", toReturn, method.getSimpleName()), +        .add(, +            FluentIterable.from(method.getParameters()), +                .transform(new Function<VariableElement, String>() {, +                  @Nullable, +                  @Override, +                  public String apply(VariableElement input) {, +                    return input.getSimpleName().toString();, +                  }, +                }), +                .join(Joiner.on(","))), +        .add(");\n"), +        .build();, +  }, +, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java, +         .addMethods(generateExtensionRequestManagerMethods(glideExtensions)), +         .addMethods(generateRequestManagerRequestManagerMethodOverrides(generatedCodePackageName)), +         .addMethods(generateRequestManagerRequestBuilderMethodOverrides()), +  /** Generates the list of overrides of methods that return {@code RequestManager}. */, +  private List<MethodSpec> generateRequestManagerRequestManagerMethodOverrides(, +      final String generatedPackageName) {, +    return FluentIterable.from(, +        processorUtil.findInstanceMethodsReturning(requestManagerType, requestManagerType)), +        .transform(new Function<ExecutableElement, MethodSpec>() {, +          @Nullable, +          @Override, +          public MethodSpec apply(@Nullable ExecutableElement input) {, +            return generateRequestManagerRequestManagerMethodOverride(generatedPackageName, input);, +          }, +        }), +        .toList();, +  }, +, +  private MethodSpec generateRequestManagerRequestManagerMethodOverride(, +      String generatedPackageName, ExecutableElement method) {, +    ClassName generatedRequestManagerName =, +        ClassName.get(generatedPackageName, GENERATED_REQUEST_MANAGER_SIMPLE_NAME);, +    return ProcessorUtil.overriding(method), +        .returns(generatedRequestManagerName), +        .addCode(ProcessorUtil.generateCastingSuperCall(generatedRequestManagerName, method)), +        .build();, +  }, +, +  /** Generates the list of overrides of methods that return {@code RequestBuilder}. */, +  private List<MethodSpec> generateRequestManagerRequestBuilderMethodOverrides() {, +            return generateRequestManagerRequestBuilderMethodOverride(input);, +  private MethodSpec generateRequestManagerRequestBuilderMethodOverride(, +      ExecutableElement methodToOverride) {, +        .addCode(, +            ProcessorUtil.generateCastingSuperCall(, +                generatedRequestBuilderOfType, methodToOverride));, +  private List<MethodSpec> generateExtensionRequestManagerMethods(, +   * The {@code RequestOptions} subclass should always be our]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        .append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class,, +        .append(Registry.BUCKET_BITMAP, InputStream.class, Bitmap.class,, +        .append(Registry.BUCKET_BITMAP, ParcelFileDescriptor.class, Bitmap.class,, +            new VideoBitmapDecoder(bitmapPool)), +        .append(Registry.BUCKET_BITMAP_DRAWABLE, ByteBuffer.class, BitmapDrawable.class,, +        .append(Registry.BUCKET_BITMAP_DRAWABLE, InputStream.class, BitmapDrawable.class,, +        .append(Registry.BUCKET_BITMAP_DRAWABLE, ParcelFileDescriptor.class, BitmapDrawable.class,, +        .append(Registry.BUCKET_GIF, InputStream.class, GifDrawable.class,, +        .append(Registry.BUCKET_GIF, ByteBuffer.class, GifDrawable.class, byteBufferGifDecoder), +        .append(GifDecoder.class, GifDecoder.class, new UnitModelLoader.Factory<>()), +        .append(Registry.BUCKET_BITMAP, GifDecoder.class, Bitmap.class,, +            new GifFrameResourceDecoder(bitmapPool)), +        .append(File.class, File.class, new UnitModelLoader.Factory<>()), +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        .append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class,, +        .append(Registry.BUCKET_BITMAP, InputStream.class, Bitmap.class,, +        .append(Registry.BUCKET_BITMAP, ParcelFileDescriptor.class, Bitmap.class,, +            new VideoBitmapDecoder(bitmapPool)), +        .append(Registry.BUCKET_BITMAP_DRAWABLE, ByteBuffer.class, BitmapDrawable.class,, +        .append(Registry.BUCKET_BITMAP_DRAWABLE, InputStream.class, BitmapDrawable.class,, +        .append(Registry.BUCKET_BITMAP_DRAWABLE, ParcelFileDescriptor.class, BitmapDrawable.class,, +        .append(Registry.BUCKET_GIF, InputStream.class, GifDrawable.class,, +        .append(Registry.BUCKET_GIF, ByteBuffer.class, GifDrawable.class, byteBufferGifDecoder), +        .append(GifDecoder.class, GifDecoder.class, new UnitModelLoader.Factory<>()), +        .append(Registry.BUCKET_BITMAP, GifDecoder.class, Bitmap.class,, +            new GifFrameResourceDecoder(bitmapPool)), +        .append(File.class, File.class, new UnitModelLoader.Factory<>()), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +import java.util.Arrays;, +  public static final String BUCKET_GIF = "Gif";, +  public static final String BUCKET_BITMAP = "Bitmap";, +  public static final String BUCKET_BITMAP_DRAWABLE = "BitmapDrawable";, +  private static final String BUCKET_PREPEND_ALL = "legacy_prepend_all";, +  private static final String BUCKET_APPEND_ALL = "legacy_append";, +, +    setResourceDecoderBucketPriorityList(, +        Arrays.asList(BUCKET_GIF, BUCKET_BITMAP, BUCKET_BITMAP_DRAWABLE));, +   * Appends the given {@link ResourceDecoder} onto the list of all available, +   * {@link ResourceDecoder}s allowing it to be used if all earlier and default, +   * {@link ResourceDecoder}s for the given types fail (or there are none)., +   * @see #append(String, Class, Class, ResourceDecoder), +    append(BUCKET_APPEND_ALL, dataClass, resourceClass, decoder);, +   * Appends the given {@link ResourceDecoder} onto the list of available {@link ResourceDecoder}s, +   * in this bucket, allowing it to be used if all earlier and default {@link ResourceDecoder}s for, +   * the given types in this bucket fail (or there are none)., +   *, +   * <p>If you're attempting to replace an existing {@link ResourceDecoder} or would like to ensure, +   * that your {@link ResourceDecoder} gets the chance to run before an existing, +   * {@link ResourceDecoder}, use {@link #prepend(Class, Class, ResourceDecoder)}. This method is, +   * best for new types of resources and data or as a way to add an additional fallback decoder, +   * for an existing type of data., +   *, +   * @see #prepend(String, Class, Class, ResourceDecoder), +   * @see #setResourceDecoderBucketPriorityList(List), +   *, +   * @param bucket The bucket identifier to add this decoder to., +   * @param dataClass The data that will be decoded from, +   * ({@link java.io.InputStream}, {@link java.io.FileDescriptor} etc)., +   * @param resourceClass The resource that will be decoded to ({@link android.graphics.Bitmap},, +   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc)., +   * @param decoder The {@link ResourceDecoder} to register., +   */, +  public <Data, TResource> Registry append(, +      String bucket,, +      Class<Data> dataClass,, +      Class<TResource> resourceClass,, +      ResourceDecoder<Data, TResource> decoder) {, +    decoderRegistry.append(bucket, decoder, dataClass, resourceClass);, +    return this;, +  }, +, +  /**, +   * Prepends the given {@link ResourceDecoder} into the list of all available, +   * {@link ResourceDecoder}s so that it is attempted before all later and default, +   * {@link ResourceDecoder}s for the given types., +   * @see #prepend(String, Class, Class, ResourceDecoder), +    prepend(BUCKET_PREPEND_ALL, dataClass, resourceClass, decoder);, +    return this;, +  }, +, +  /**, +   * Prepends the given {@link ResourceDecoder} into the list of available {@link ResourceDecoder}s, +   * in the same bucket so that it is attempted before all later and default, +   * {@link ResourceDecoder}s for the given types in that bucket., +   *, +   * <p>This method allows you to replace the default {@link ResourceDecoder} for this bucket, +   * because it ensures the registered {@link ResourceDecoder} will run first. You can use the, +   * {@link ResourceDecoder#handles(Object, Options)} to fall back to the default, +   * {@link ResourceDecoder}s if you only want to change the default functionality for certain, +   * types of data., +   *, +   * @see #append(String, Class, Class, ResourceDecoder), +   * @see #setResourceDecoderBucketPriorityList(List), +   *, +   * @param bucket The bucket identifier to add this decoder to., +   * @param dataClass The data that will be decoded from, +   * ({@link java.io.InputStream}, {@link java.io.FileDescriptor} etc)., +   * @param resourceClass The resource that will be decoded to ({@link android.graphics.Bitmap},, +   * {@link com.bumptech.glide.load.resource.gif.GifDrawable} etc).]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;, +  private final ArrayPool arrayPool;, +  Glide(, +      Engine engine,, +      MemoryCache memoryCache,, +      BitmapPool bitmapPool,, +      ArrayPool arrayPool,, +      Context context,, +      int logLevel,, +      RequestOptions defaultRequestOptions) {, +    this.arrayPool = arrayPool;, +    this.byteArrayPool = new LruByteArrayPool();, +    ByteBufferGifDecoder byteBufferGifDecoder =, +        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);, +  public ArrayPool getArrayPool() {, +    return arrayPool;, +  }, +, +    arrayPool.clearMemory();, +    arrayPool.trimMemory(level);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;, +  private final ArrayPool arrayPool;, +  Glide(, +      Engine engine,, +      MemoryCache memoryCache,, +      BitmapPool bitmapPool,, +      ArrayPool arrayPool,, +      Context context,, +      int logLevel,, +      RequestOptions defaultRequestOptions) {, +    this.arrayPool = arrayPool;, +    this.byteArrayPool = new LruByteArrayPool();, +    ByteBufferGifDecoder byteBufferGifDecoder =, +        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);, +  public ArrayPool getArrayPool() {, +    return arrayPool;, +  }, +, +    arrayPool.clearMemory();, +    arrayPool.trimMemory(level);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;, +  private ArrayPool arrayPool;, +   * Sets the {@link ArrayPool} implementation to allow variable sized arrays to be stored, +   * @param arrayPool The pool to use., +  public GlideBuilder setArrayPool(ArrayPool arrayPool) {, +    this.arrayPool = arrayPool;, +    if (arrayPool == null) {, +      arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());, +    return new Glide(, +        engine,, +        memoryCache,, +        bitmapPool,, +        arrayPool,, +        context,, +        logLevel,, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +import com.bumptech.glide.load.engine.bitmap_recycle.LruByteArrayPool;, +  private final ArrayPool arrayPool;, +  Glide(, +      Engine engine,, +      MemoryCache memoryCache,, +      BitmapPool bitmapPool,, +      ArrayPool arrayPool,, +      Context context,, +      int logLevel,, +      RequestOptions defaultRequestOptions) {, +    this.arrayPool = arrayPool;, +    this.byteArrayPool = new LruByteArrayPool();, +    ByteBufferGifDecoder byteBufferGifDecoder =, +        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);, +  public ArrayPool getArrayPool() {, +    return arrayPool;, +  }, +, +    arrayPool.clearMemory();, +    arrayPool.trimMemory(level);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +import com.bumptech.glide.load.engine.bitmap_recycle.LruArrayPool;, +  private ArrayPool arrayPool;, +   * Sets the {@link ArrayPool} implementation to allow variable sized arrays to be stored, +   * @param arrayPool The pool to use., +  public GlideBuilder setArrayPool(ArrayPool arrayPool) {, +    this.arrayPool = arrayPool;, +    if (arrayPool == null) {, +      arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes());, +    return new Glide(, +        engine,, +        memoryCache,, +        bitmapPool,, +        arrayPool,, +        context,, +        logLevel,]
[+++ /dev/null, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/request/target/GlideDrawableImageViewTargetTest.java, +package com.bumptech.glide.request.target;, +, +import android.graphics.Canvas;, +import android.graphics.ColorFilter;, +import android.graphics.drawable.BitmapDrawable;, +import android.graphics.drawable.Drawable;, +import android.widget.ImageView;, +, +import com.bumptech.glide.load.resource.drawable.GlideDrawable;, +, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.mockito.invocation.InvocationOnMock;, +import org.mockito.stubbing.Answer;, +import org.robolectric.Robolectric;, +import org.robolectric.RobolectricTestRunner;, +, +import static junit.framework.Assert.assertEquals;, +import static junit.framework.Assert.assertFalse;, +import static junit.framework.Assert.assertTrue;, +import static org.mockito.Matchers.any;, +import static org.mockito.Mockito.doAnswer;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, +@RunWith(RobolectricTestRunner.class), +public class GlideDrawableImageViewTargetTest {, +, +    @Test, +    public void testSetsDrawableOnViewInSetResource() {, +        ImageView view = new ImageView(Robolectric.application);, +        GlideDrawableImageViewTarget target = new GlideDrawableImageViewTarget(view);, +        GlideDrawable expected = new MockAnimatedDrawable();, +, +        target.setResource(expected);, +, +        assertEquals(expected, view.getDrawable());, +    }, +, +    @Test, +    public void testWrapsDrawableInSquaringDrawableIfDrawableAndViewAreSquare() {, +        ImageView mockView = mock(ImageView.class);, +        when(mockView.getWidth()).thenReturn(100);, +        when(mockView.getHeight()).thenReturn(100);, +        GlideDrawableImageViewTarget target = new GlideDrawableImageViewTarget(mockView);, +        GlideDrawable drawable = new MockAnimatedDrawable() {, +            @Override, +            public int getIntrinsicHeight() {, +                return 100;, +            }, +, +            @Override, +            public int getIntrinsicWidth() {, +                return 100;, +            }, +        };, +, +, +        target.onResourceReady(drawable, null);, +, +        doAnswer(new Answer() {, +            @Override, +            public Object answer(InvocationOnMock invocation) throws Throwable {, +                Drawable drawable = (Drawable) invocation.getArguments()[0];, +                assertTrue(drawable instanceof SquaringDrawable);, +                return null;, +            }, +        }).when(mockView).setImageDrawable(any(Drawable.class));, +        verify(mockView).setImageDrawable(any(BitmapDrawable.class));, +    }, +, +    @Test, +    public void testDoesNotWrapInSquaringDrawableIfDrawableIsAnimated() {, +        ImageView mockView = mock(ImageView.class);, +        when(mockView.getWidth()).thenReturn(100);, +        when(mockView.getHeight()).thenReturn(100);, +        GlideDrawableImageViewTarget target = new GlideDrawableImageViewTarget(mockView);, +        GlideDrawable drawable = new MockAnimatedDrawable() {, +            @Override, +            public int getIntrinsicHeight() {, +                return 100;, +            }, +, +            @Override, +            public int getIntrinsicWidth() {, +                return 100;, +            }, +        };, +         target.onResourceReady(drawable, null);, +, +        doAnswer(new Answer() {, +            @Override, +            public Object answer(InvocationOnMock invocation) throws Throwable {, +                Drawable drawable = (Drawable) invocation.getArguments()[0];, +                assertFalse(drawable instanceof SquaringDrawable);, +                return null;]
[+++ b/CONTRIBUTING.md, +Similarly if you support a particular feature request, feel free to let us know by commenting on the issue or [subscribing][6] to the issue., +## Labels, +Labels on issues are managed by contributors, you don't have to worry about them. Here's a list of what they mean:, + * **bug**: feature that should work, but doesn't, + * **enhancement**: minor tweak/addition to existing behavior, + * **feature**: new behavior, bigger than enhancement, it gives more bang to Glide, + * **question**: no need to modify Glide to fix the issue, usually a usage problem, + * **reproducible**: has enough information to very easily reproduce, mostly in form of a small project in a GitHub repo, + * **repro-needed**: we need some code to be able to reproduce and debug locally, otherwise there's not much we can do, + * **duplicate**: there's another issue which already covers/tracks this, + * **wontfix**: working as intended, or won't be fixed due to compatibility or other reasons, + * **invalid**: there isn't enough information to make a verdict, or unrelated to Glide, + * **non-library**: issue is not in the core library code, but rather in documentation, samples, build process, releases, + * **v4**: problem originated in v4, or question about v4 (while v3 is in wide use), +, +*bug + enhancement: feature that doesn't work, but it's an edge case that either has a workaround or doesn't affect many users*, +, +, +[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version**%3A%0A**Integration%20libraries**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details%20/%20Repro%20steps%20/%20Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60, +[5]: https://github.com/bumptech/glide, +[6]: https://help.github.com/articles/subscribing-to-conversations/, +++ b/CONTRIBUTING.md, +Similarly if you support a particular feature request, feel free to let us know by commenting on the issue or [subscribing][6] to the issue., +## Labels, +Labels on issues are managed by contributors, you don't have to worry about them. Here's a list of what they mean:, + * **bug**: feature that should work, but doesn't, + * **enhancement**: minor tweak/addition to existing behavior, + * **feature**: new behavior, bigger than enhancement, it gives more bang to Glide, + * **question**: no need to modify Glide to fix the issue, usually a usage problem, + * **reproducible**: has enough information to very easily reproduce, mostly in form of a small project in a GitHub repo, + * **repro-needed**: we need some code to be able to reproduce and debug locally, otherwise there's not much we can do, + * **duplicate**: there's another issue which already covers/tracks this, + * **wontfix**: working as intended, or won't be fixed due to compatibility or other reasons, + * **invalid**: there isn't enough information to make a verdict, or unrelated to Glide, + * **non-library**: issue is not in the core library code, but rather in documentation, samples, build process, releases, + * **v4**: problem originated in v4, or question about v4 (while v3 is in wide use), +, +*bug + enhancement: feature that doesn't work, but it's an edge case that either has a workaround or doesn't affect many users*, +, +, +[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version**%3A%0A**Integration%20libraries**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details%20/%20Repro%20steps%20/%20Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60, +[5]: https://github.com/bumptech/glide, +[6]: https://help.github.com/articles/subscribing-to-conversations/, +++ b/README.md, +[Report an issue with Glide][5], +  mavenCentral() // jcenter() works as well because it pulls from Maven Central, +  compile 'com.github.bumptech.glide:glide:3.7.0', +  <version>3.7.0</version>, +For info on using the bleeding edge, see the [Snapshots][17] wiki page., +, +@Override public void onCreate(Bundle savedInstanceState) {, +@Override public View getView(int position, View recycled, ViewGroup container) {, +  Glide, +    .with(myFragment), +[*Version 3* on the `3.0` branch][14] is a stable public release used in multiple open source projects at Google including in the Android Camera, +, +Comments/bugs/questions/pull requests are always welcome! Please read [CONTRIBUTING.md][5] on how to report issues., +, +Compatibility, +-------------, +, + * **Android SDK**: Glide requires a minimum API level of 10., + * **OkHttp 2.x**: there are optional dependencies available called `okhttp-integration`, see [Integration Libraries][12] wiki page., + * **OkHttp 3.x**: there are optional dependencies available called `okhttp3-integration`, see [Integration Libraries][12] wiki page., + * **Volley**: there are optional dependencies available called `volley-integration`, see [Integration Libraries][12] wiki page., + * **Round Pictures**: `CircleImageView`/`CircularImageView`/`RoundedImageView` are known to have [issues][18] with `TransitionDrawable` (`.crossFade()` with `.thumbnail()` or `.placeholder()`) and animated GIFs, use a [`BitmapTransformation`][19] (`.circleCrop()` will be available in v4) or `.dontAnimate()` to fix the issue., + * **Huge Images** (maps, comic strips): Glide can load huge images by downsampling them, but does not support zooming and panning `ImageView`s as they require special resource optimizations (such as tiling) to work without `OutOfMemoryError`s., +To open the project in IntelliJ IDEA:, +Sam Judd - @sjudd on GitHub, @samajudd on Twitter, +, +License, +-------, +BSD, part MIT and Apache 2.0. See the [LICENSE][16] file for details., +[5]: https://github.com/bumptech/glide/blob/master/CONTRIBUTING.md, +[17]: https://github.com/bumptech/glide/wiki/Snapshots, +[18]: https://github.com/bumptech/glide/issues?q=is%3Aissue+CircleImageView+OR+CircularImageView+OR+RoundedImageView, +[19]: https://github.com/wasabeef/glide-transformations, +++ b/CONTRIBUTING.md, +Similarly if you support a particular feature request, feel free to let us know by commenting on the issue or [subscribing][6] to the issue., +## Labels, +Labels on issues are managed by contributors, you don't have to worry about them. Here's a list of what they mean:, + * **bug**: feature that should work, but doesn't, + * **enhancement**: minor tweak/addition to existing behavior, + * **feature**: new behavior, bigger than enhancement, it gives more bang to Glide, + * **question**: no need to modify Glide to fix the issue, usually a usage problem, + * **reproducible**: has enough information to very easily reproduce, mostly in form of a small project in a GitHub repo, + * **repro-needed**: we need some code to be able to reproduce and debug locally, otherwise there's not much we can do, + * **duplicate**: there's another issue which already covers/tracks this, + * **wontfix**: working as intended, or won't be fixed due to compatibility or other reasons, + * **invalid**: there isn't enough information to make a verdict, or unrelated to Glide, + * **non-library**: issue is not in the core library code, but rather in documentation, samples, build process, releases, + * **v4**: problem originated in v4, or question about v4 (while v3 is in wide use), +, +*bug + enhancement: feature that doesn't work, but it's an edge case that either has a workaround or doesn't affect many users*, +, +, +[1]: https://github.com/bumptech/glide/issues/new?body=**Glide%20Version**%3A%0A**Integration%20libraries**%3A%0A**Device/Android%20Version**%3A%0A**Issue%20details%20/%20Repro%20steps%20/%20Use%20case%20background**%3A%0A%0A**Glide%20load%20line**%3A%0A%60%60%60java%0AGlide.with%28...%29.....load%28...%29.....into%28...%29%3B%0A%60%60%60%0A%0A**Layout%20XML**%3A%0A%60%60%60xml%0A%3C...Layout%3E%0A%20%20%20%20%3CImageView%20android%3AscaleType%3D%22...%22%20...%20/%3E%0A%3C/..Layout%3E%0A%60%60%60%0A%0A**Stack%20trace%20/%20LogCat**%3A%0A%60%60%60ruby%0Apaste%20stack%20trace%20here%0A%60%60%60, +[5]: https://github.com/bumptech/glide, +[6]: https://help.github.com/articles/subscribing-to-conversations/]
[+++ b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java, +   * @param viewId      The id of the ImageView view that will load the image., +   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap., +  public AppWidgetTarget(Context context, int width, int height,, +      int viewId, RemoteViews remoteViews, int... widgetIds) {, +   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap., +  public AppWidgetTarget(Context context,, +      int viewId, RemoteViews remoteViews, int... widgetIds) {, +    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, widgetIds);, +   * @param viewId        The id of the ImageView view that will load the image., +   * @param remoteViews   RemoteViews object which contains the ImageView that will load the, +   *                      bitmap., +  public AppWidgetTarget(Context context, int width, int height,, +      int viewId, RemoteViews remoteViews, ComponentName componentName) {, +   * @param viewId        The id of the ImageView view that will load the image., +  public AppWidgetTarget(Context context,, +      int viewId, RemoteViews remoteViews, ComponentName componentName) {, +    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, componentName);, +++ b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java, +   * @param viewId      The id of the ImageView view that will load the image., +   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap., +  public AppWidgetTarget(Context context, int width, int height,, +      int viewId, RemoteViews remoteViews, int... widgetIds) {, +   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap., +  public AppWidgetTarget(Context context,, +      int viewId, RemoteViews remoteViews, int... widgetIds) {, +    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, widgetIds);, +   * @param viewId        The id of the ImageView view that will load the image., +   * @param remoteViews   RemoteViews object which contains the ImageView that will load the, +   *                      bitmap., +  public AppWidgetTarget(Context context, int width, int height,, +      int viewId, RemoteViews remoteViews, ComponentName componentName) {, +   * @param viewId        The id of the ImageView view that will load the image., +  public AppWidgetTarget(Context context,, +      int viewId, RemoteViews remoteViews, ComponentName componentName) {, +    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, componentName);, +++ b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java, +   * @param viewId         The id of the ImageView view that will load the image., +  public NotificationTarget(Context context,, +      int viewId, RemoteViews remoteViews, Notification notification, int notificationId) {, +    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, notification, notificationId);, +   * @param viewId         The id of the ImageView view that will load the image., +   * @param remoteViews    RemoteViews object which contains the ImageView that will load the, +   *                       bitmap., +  public NotificationTarget(Context context, int width, int height,, +      int viewId, RemoteViews remoteViews, Notification notification, int notificationId) {, +++ b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java, +   * @param viewId      The id of the ImageView view that will load the image., +   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap., +  public AppWidgetTarget(Context context, int width, int height,, +      int viewId, RemoteViews remoteViews, int... widgetIds) {, +   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap., +  public AppWidgetTarget(Context context,, +      int viewId, RemoteViews remoteViews, int... widgetIds) {, +    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, widgetIds);, +   * @param viewId        The id of the ImageView view that will load the image., +   * @param remoteViews   RemoteViews object which contains the ImageView that will load the, +   *                      bitmap., +  public AppWidgetTarget(Context context, int width, int height,, +      int viewId, RemoteViews remoteViews, ComponentName componentName) {, +   * @param viewId        The id of the ImageView view that will load the image., +  public AppWidgetTarget(Context context,, +      int viewId, RemoteViews remoteViews, ComponentName componentName) {, +    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, componentName);, +++ b/library/src/main/java/com/bumptech/glide/request/target/NotificationTarget.java, +   * @param viewId         The id of the ImageView view that will load the image., +  public NotificationTarget(Context context,, +      int viewId, RemoteViews remoteViews, Notification notification, int notificationId) {, +    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, notification, notificationId);, +   * @param viewId         The id of the ImageView view that will load the image., +   * @param remoteViews    RemoteViews object which contains the ImageView that will load the, +   *                       bitmap., +  public NotificationTarget(Context context, int width, int height,, +      int viewId, RemoteViews remoteViews, Notification notification, int notificationId) {, +++ b/library/src/test/java/com/bumptech/glide/request/target/AppWidgetTargetTest.java, +        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, componentName);, +        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, componentName);, +        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, widgetIds);, +        new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, widgetIds);, +    new AppWidgetTarget(null /*context*/, 1234 /*viewId*/, views, 1 /*widgetIds*/);, +    new AppWidgetTarget(null /*context*/, 1234 /*viewId*/, views, mock(ComponentName.class));, +    new AppWidgetTarget(RuntimeEnvironment.application,, +        viewId, null /*remoteViews*/, 1 /*widgetIds*/);, +    new AppWidgetTarget(RuntimeEnvironment.application,, +        viewId, null /*remoteViews*/, mock(ComponentName.class));, +    new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, (int[]) null /*widgetIds*/);, +    new AppWidgetTarget(RuntimeEnvironment.application, viewId, views);, +    new AppWidgetTarget(RuntimeEnvironment.application, viewId, views, (ComponentName) null);, +++ b/library/src/main/java/com/bumptech/glide/request/target/AppWidgetTarget.java, +   * @param viewId      The id of the ImageView view that will load the image., +   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap., +  public AppWidgetTarget(Context context, int width, int height,, +      int viewId, RemoteViews remoteViews, int... widgetIds) {, +   * @param remoteViews RemoteViews object which contains the ImageView that will load the bitmap., +  public AppWidgetTarget(Context context,, +      int viewId, RemoteViews remoteViews, int... widgetIds) {, +    this(context, SIZE_ORIGINAL, SIZE_ORIGINAL, viewId, remoteViews, widgetIds);, +   * @param viewId        The id of the ImageView view that will load the image., +   * @param remoteViews   RemoteViews object which contains the ImageView that will load the, +   *                      bitmap.]
[+++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java, +import android.support.annotation.NonNull;, +  public RecyclerToListViewScrollListener(@NonNull AbsListView.OnScrollListener scrollListener) {, +++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java, +import android.support.annotation.NonNull;, +  public RecyclerToListViewScrollListener(@NonNull AbsListView.OnScrollListener scrollListener) {, +++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java, +import android.support.annotation.NonNull;, +  public RecyclerViewPreloader(@NonNull Activity activity,, +      @NonNull PreloadModelProvider<T> preloadModelProvider,, +      @NonNull PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {, +  public RecyclerViewPreloader(@NonNull FragmentActivity fragmentActivity,, +      @NonNull PreloadModelProvider<T> preloadModelProvider,, +      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,, +  public RecyclerViewPreloader(@NonNull Fragment fragment,, +      @NonNull PreloadModelProvider<T> preloadModelProvider,, +      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,, +  public RecyclerViewPreloader(@NonNull android.support.v4.app.Fragment fragment,, +      @NonNull PreloadModelProvider<T> preloadModelProvider,, +      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,, +, +  public RecyclerViewPreloader(@NonNull RequestManager requestManager,, +      @NonNull PreloadModelProvider<T> preloadModelProvider,, +      @NonNull PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {, +++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java, +import android.support.annotation.NonNull;, +  public RecyclerToListViewScrollListener(@NonNull AbsListView.OnScrollListener scrollListener) {, +++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java, +import android.support.annotation.NonNull;, +  public RecyclerViewPreloader(@NonNull Activity activity,, +      @NonNull PreloadModelProvider<T> preloadModelProvider,, +      @NonNull PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {, +  public RecyclerViewPreloader(@NonNull FragmentActivity fragmentActivity,, +      @NonNull PreloadModelProvider<T> preloadModelProvider,, +      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,, +  public RecyclerViewPreloader(@NonNull Fragment fragment,, +      @NonNull PreloadModelProvider<T> preloadModelProvider,, +      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,, +  public RecyclerViewPreloader(@NonNull android.support.v4.app.Fragment fragment,, +      @NonNull PreloadModelProvider<T> preloadModelProvider,, +      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,, +, +  public RecyclerViewPreloader(@NonNull RequestManager requestManager,, +      @NonNull PreloadModelProvider<T> preloadModelProvider,, +      @NonNull PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java, +import android.support.annotation.NonNull;, +  public RecyclerToListViewScrollListener(@NonNull AbsListView.OnScrollListener scrollListener) {, +++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java, +import android.support.annotation.NonNull;, +  public RecyclerViewPreloader(@NonNull Activity activity,, +      @NonNull PreloadModelProvider<T> preloadModelProvider,, +      @NonNull PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {, +  public RecyclerViewPreloader(@NonNull FragmentActivity fragmentActivity,, +      @NonNull PreloadModelProvider<T> preloadModelProvider,, +      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,, +  public RecyclerViewPreloader(@NonNull Fragment fragment,, +      @NonNull PreloadModelProvider<T> preloadModelProvider,, +      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,, +  public RecyclerViewPreloader(@NonNull android.support.v4.app.Fragment fragment,, +      @NonNull PreloadModelProvider<T> preloadModelProvider,, +      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,, +, +  public RecyclerViewPreloader(@NonNull RequestManager requestManager,, +      @NonNull PreloadModelProvider<T> preloadModelProvider,, +      @NonNull PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +    RequestBuilder<?> getPreloadRequestBuilder(@NonNull U item);, +    int[] getPreloadSize(@NonNull T item, int adapterPosition, int perItemPosition);, +  public ListPreloader(@NonNull RequestManager requestManager,, +      @NonNull PreloadModelProvider<T> preloadModelProvider,, +      @NonNull PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {, +        preloadAdapterPosition(preloadModelProvider.getPreloadItems(i), i, true);, +        preloadAdapterPosition(preloadModelProvider.getPreloadItems(i), i, false);, +++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerToListViewScrollListener.java, +import android.support.annotation.NonNull;, +  public RecyclerToListViewScrollListener(@NonNull AbsListView.OnScrollListener scrollListener) {, +++ b/integration/recyclerview/src/main/java/com/bumptech/glide/integration/recyclerview/RecyclerViewPreloader.java, +import android.support.annotation.NonNull;, +  public RecyclerViewPreloader(@NonNull Activity activity,, +      @NonNull PreloadModelProvider<T> preloadModelProvider,, +      @NonNull PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {, +  public RecyclerViewPreloader(@NonNull FragmentActivity fragmentActivity,, +      @NonNull PreloadModelProvider<T> preloadModelProvider,, +      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,, +  public RecyclerViewPreloader(@NonNull Fragment fragment,, +      @NonNull PreloadModelProvider<T> preloadModelProvider,, +      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,, +  public RecyclerViewPreloader(@NonNull android.support.v4.app.Fragment fragment,, +      @NonNull PreloadModelProvider<T> preloadModelProvider,, +      @NonNull PreloadSizeProvider<T> preloadDimensionProvider,, +, +  public RecyclerViewPreloader(@NonNull RequestManager requestManager,, +      @NonNull PreloadModelProvider<T> preloadModelProvider,, +      @NonNull PreloadSizeProvider<T> preloadDimensionProvider, int maxPreload) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +    RequestBuilder<?> getPreloadRequestBuilder(@NonNull U item);]
[+++ b/README.md, +    compile 'com.android.support:support-v4:19.1.0', +++ b/README.md, +    compile 'com.android.support:support-v4:19.1.0', +++ b/build.gradle, +        classpath "org.robolectric:robolectric-gradle-plugin:${ROBOLECTRIC_GRADLE_VERSION}", +        classpath "com.android.tools.build:gradle:${ANDROID_GRADLE_VERSION}", +++ b/README.md, +    compile 'com.android.support:support-v4:19.1.0', +++ b/build.gradle, +        classpath "org.robolectric:robolectric-gradle-plugin:${ROBOLECTRIC_GRADLE_VERSION}", +        classpath "com.android.tools.build:gradle:${ANDROID_GRADLE_VERSION}", +++ b/gradle.properties, +, +SUPPORT_V4_VERSION=19.1.0, +SUPPORT_V7_VERSION=19.1.0, +VOLLEY_VERSION=1.0.7, +OK_HTTP_VERSION=2.0.0, +ANDROID_GRADLE_VERSION=0.13.3, +, +ROBOLECTRIC_GRADLE_VERSION=0.12.0, +JUNIT_VERSION=4.11, +MOCKITO_VERSION=1.9.5, +ROBOLECTRIC_VERSION=2.4-SNAPSHOT, +MOCKWEBSERVER_VERSION=1.6.0, +HAMCREST_VERSION=1.3, +, +COMPILE_SDK_VERSION=19, +BUILD_TOOLS_VERSION=19.1.0, +TARGET_SDK_VERSION=19, +MIN_SDK_VERSION=10, +, +, +++ b/README.md, +    compile 'com.android.support:support-v4:19.1.0', +++ b/build.gradle, +        classpath "org.robolectric:robolectric-gradle-plugin:${ROBOLECTRIC_GRADLE_VERSION}", +        classpath "com.android.tools.build:gradle:${ANDROID_GRADLE_VERSION}", +++ b/gradle.properties, +, +SUPPORT_V4_VERSION=19.1.0, +SUPPORT_V7_VERSION=19.1.0, +VOLLEY_VERSION=1.0.7, +OK_HTTP_VERSION=2.0.0, +ANDROID_GRADLE_VERSION=0.13.3, +, +ROBOLECTRIC_GRADLE_VERSION=0.12.0, +JUNIT_VERSION=4.11, +MOCKITO_VERSION=1.9.5, +ROBOLECTRIC_VERSION=2.4-SNAPSHOT, +MOCKWEBSERVER_VERSION=1.6.0, +HAMCREST_VERSION=1.3, +, +COMPILE_SDK_VERSION=19, +BUILD_TOOLS_VERSION=19.1.0, +TARGET_SDK_VERSION=19, +MIN_SDK_VERSION=10, +, +, +++ b/integration/okhttp/build.gradle, +    compile "com.squareup.okhttp:okhttp:${OK_HTTP_VERSION}", +    compileSdkVersion COMPILE_SDK_VERSION as int, +    buildToolsVersion BUILD_TOOLS_VERSION, +        minSdkVersion MIN_SDK_VERSION as int, +        targetSdkVersion TARGET_SDK_VERSION as int, +, +++ b/README.md, +    compile 'com.android.support:support-v4:19.1.0', +++ b/build.gradle, +        classpath "org.robolectric:robolectric-gradle-plugin:${ROBOLECTRIC_GRADLE_VERSION}", +        classpath "com.android.tools.build:gradle:${ANDROID_GRADLE_VERSION}", +++ b/gradle.properties, +, +SUPPORT_V4_VERSION=19.1.0, +SUPPORT_V7_VERSION=19.1.0, +VOLLEY_VERSION=1.0.7, +OK_HTTP_VERSION=2.0.0, +ANDROID_GRADLE_VERSION=0.13.3, +, +ROBOLECTRIC_GRADLE_VERSION=0.12.0, +JUNIT_VERSION=4.11, +MOCKITO_VERSION=1.9.5, +ROBOLECTRIC_VERSION=2.4-SNAPSHOT, +MOCKWEBSERVER_VERSION=1.6.0, +HAMCREST_VERSION=1.3, +, +COMPILE_SDK_VERSION=19, +BUILD_TOOLS_VERSION=19.1.0, +TARGET_SDK_VERSION=19, +MIN_SDK_VERSION=10, +, +, +++ b/integration/okhttp/build.gradle, +    compile "com.squareup.okhttp:okhttp:${OK_HTTP_VERSION}", +    compileSdkVersion COMPILE_SDK_VERSION as int, +    buildToolsVersion BUILD_TOOLS_VERSION, +        minSdkVersion MIN_SDK_VERSION as int, +        targetSdkVersion TARGET_SDK_VERSION as int, +, +++ b/integration/volley/build.gradle]
[+++ b/library/src/main/java/com/bumptech/glide/load/data/LocalUriFetcher.java, +    private final Context context;, +        this.context = context.getApplicationContext();]
[+++ b/.idea/codeStyleSettings.xml, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +Proguard, +--------, +Depending on your proguard config and usage, you may need to include the following lines in your proguard.cfg:, +```, +-keep public class * implements com.bumptech.glide.module.GlideModule, +-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {, +    **[] $VALUES;, +    public *;, +}, +```, +, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +Proguard, +--------, +Depending on your proguard config and usage, you may need to include the following lines in your proguard.cfg:, +```, +-keep public class * implements com.bumptech.glide.module.GlideModule, +-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {, +    **[] $VALUES;, +    public *;, +}, +```, +, +++ b/build.gradle, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +Proguard, +--------, +Depending on your proguard config and usage, you may need to include the following lines in your proguard.cfg:, +```, +-keep public class * implements com.bumptech.glide.module.GlideModule, +-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {, +    **[] $VALUES;, +    public *;, +}, +```, +, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +Proguard, +--------, +Depending on your proguard config and usage, you may need to include the following lines in your proguard.cfg:, +```, +-keep public class * implements com.bumptech.glide.module.GlideModule, +-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {, +    **[] $VALUES;, +    public *;, +}, +```, +, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +Proguard, +--------, +Depending on your proguard config and usage, you may need to include the following lines in your proguard.cfg:, +```, +-keep public class * implements com.bumptech.glide.module.GlideModule, +-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {, +    **[] $VALUES;, +    public *;, +}, +```, +, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +  <component name="NewModuleRootManager" inherit-compiler-output="false">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +Proguard]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +    if (resource instanceof Initializable) {, +      ((Initializable) resource).initialize();, +    }, +, +  private class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {, +    private DecodeCallback(DataSource dataSource) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +    if (resource instanceof Initializable) {, +      ((Initializable) resource).initialize();, +    }, +, +  private class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {, +    private DecodeCallback(DataSource dataSource) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java, +package com.bumptech.glide.load.engine;, +, +/**, + * A callback allowing a resource to do some optimization on a background thread before being, + * returned to the ui., + */, +public interface Initializable {, +, +  /**, +   * Called on a background thread so the {@link Resource} can do some eager initialization, +   */, +  void initialize();, +, +}, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +    if (resource instanceof Initializable) {, +      ((Initializable) resource).initialize();, +    }, +, +  private class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {, +    private DecodeCallback(DataSource dataSource) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java, +package com.bumptech.glide.load.engine;, +, +/**, + * A callback allowing a resource to do some optimization on a background thread before being, + * returned to the ui., + */, +public interface Initializable {, +, +  /**, +   * Called on a background thread so the {@link Resource} can do some eager initialization, +   */, +  void initialize();, +, +}, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java, +import com.bumptech.glide.load.engine.Initializable;, +public class BitmapDrawableResource extends DrawableResource<BitmapDrawable>, +    implements Initializable {, +, +  @Override, +  public void initialize() {, +    drawable.getBitmap().prepareToDraw();, +  }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +    if (resource instanceof Initializable) {, +      ((Initializable) resource).initialize();, +    }, +, +  private class DecodeCallback<Z> implements DecodePath.DecodeCallback<Z> {, +    private DecodeCallback(DataSource dataSource) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Initializable.java, +package com.bumptech.glide.load.engine;, +, +/**, + * A callback allowing a resource to do some optimization on a background thread before being, + * returned to the ui., + */, +public interface Initializable {, +, +  /**, +   * Called on a background thread so the {@link Resource} can do some eager initialization, +   */, +  void initialize();, +, +}, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableResource.java, +import com.bumptech.glide.load.engine.Initializable;, +public class BitmapDrawableResource extends DrawableResource<BitmapDrawable>, +    implements Initializable {, +, +  @Override, +  public void initialize() {, +    drawable.getBitmap().prepareToDraw();, +  }, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapResource.java, +import com.bumptech.glide.load.engine.Initializable;, +public class BitmapResource implements Resource<Bitmap>,, +    Initializable {, +, +  @Override, +  public void initialize() {, +    bitmap.prepareToDraw();, +  }]
[+++ b/library/src/androidTest/java/com/bumptech/glide/request/target/PreloadTargetTest.java, +package com.bumptech.glide.request.target;, +, +import com.bumptech.glide.request.Request;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;, +, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.verify;, +, +@RunWith(RobolectricTestRunner.class), +public class PreloadTargetTest {, +, +    @Test, +    public void testCallsSizeReadyWithGivenDimensions() {, +        int width = 1234;, +        int height = 456;, +        PreloadTarget<Object> target = PreloadTarget.obtain(width, height);, +        SizeReadyCallback cb = mock(SizeReadyCallback.class);, +        target.getSize(cb);, +, +        verify(cb).onSizeReady(eq(width), eq(height));, +    }, +, +    @Test, +    public void testClearsTargetInOnResourceReady() {, +        Request request = mock(Request.class);, +        PreloadTarget<Object> target = PreloadTarget.obtain(100, 100);, +        target.setRequest(request);, +        target.onResourceReady(new Object(), null);, +, +        verify(request).clear();, +    }, +}, +++ b/library/src/androidTest/java/com/bumptech/glide/request/target/PreloadTargetTest.java, +package com.bumptech.glide.request.target;, +, +import com.bumptech.glide.request.Request;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;, +, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.verify;, +, +@RunWith(RobolectricTestRunner.class), +public class PreloadTargetTest {, +, +    @Test, +    public void testCallsSizeReadyWithGivenDimensions() {, +        int width = 1234;, +        int height = 456;, +        PreloadTarget<Object> target = PreloadTarget.obtain(width, height);, +        SizeReadyCallback cb = mock(SizeReadyCallback.class);, +        target.getSize(cb);, +, +        verify(cb).onSizeReady(eq(width), eq(height));, +    }, +, +    @Test, +    public void testClearsTargetInOnResourceReady() {, +        Request request = mock(Request.class);, +        PreloadTarget<Object> target = PreloadTarget.obtain(100, 100);, +        target.setRequest(request);, +        target.onResourceReady(new Object(), null);, +, +        verify(request).clear();, +    }, +}, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +import com.bumptech.glide.request.target.PreloadTarget;, +    /**, +     * Preloads the resource into the cache using the given width and height., +     *, +     * <p>, +     *     Pre-loading is useful for making sure that resources you are going to to want in the near future are, +     *     available quickly., +     * </p>, +     *, +     * @see com.bumptech.glide.ListPreloader, +     */, +    public Target<TranscodeType> preload(int width, int height) {, +        final PreloadTarget<TranscodeType> target = PreloadTarget.obtain(width, height);, +        return into(target);, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/request/target/PreloadTargetTest.java, +package com.bumptech.glide.request.target;, +, +import com.bumptech.glide.request.Request;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;, +, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.verify;]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    if (bitmap.isRecycled()) {, +      throw new IllegalStateException("Cannot pool recycled bitmap");, +    }, +      removed.recycle();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +    if (bitmap.isRecycled()) {, +      throw new IllegalStateException("Cannot pool recycled bitmap");, +    }, +      removed.recycle();, +++ b/library/src/main/java/com/bumptech/glide/util/Util.java, +    // The return value of getAllocationByteCount silently changes for recycled bitmaps from the, +    // internal buffer size to row bytes * height. To avoid random inconsistencies in caches, we, +    // instead assert here., +    if (bitmap.isRecycled()) {, +      throw new IllegalStateException("Cannot obtain size for recycled Bitmap: " + bitmap, +          + "[" + bitmap.getWidth() + "x" + bitmap.getHeight() + "] " + bitmap.getConfig());, +    }]
[+++ /dev/null, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/prefill/BitmapPreFillRunnerTest.java, +package com.bumptech.glide.load.engine.prefill;, +, +import android.graphics.Bitmap;, +import android.os.Handler;, +import com.bumptech.glide.load.Key;, +import com.bumptech.glide.load.engine.Resource;, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import com.bumptech.glide.load.engine.cache.MemoryCache;, +import com.bumptech.glide.load.resource.bitmap.BitmapResource;, +import com.bumptech.glide.util.Util;, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.mockito.InOrder;, +import org.mockito.invocation.InvocationOnMock;, +import org.mockito.stubbing.Answer;, +import org.robolectric.RobolectricTestRunner;, +, +import java.util.ArrayList;, +import java.util.HashMap;, +import java.util.List;, +import java.util.Map;, +, +import static org.hamcrest.MatcherAssert.assertThat;, +import static org.hamcrest.Matchers.contains;, +import static org.hamcrest.Matchers.hasSize;, +import static org.junit.Assert.assertNotEquals;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.anyLong;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.atLeastOnce;, +import static org.mockito.Mockito.inOrder;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.never;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, +@RunWith(RobolectricTestRunner.class), +public class BitmapPreFillRunnerTest {, +    private BitmapPreFillRunner.Clock clock;, +    private BitmapPool pool;, +    private MemoryCache cache;, +    private List<Bitmap> addedBitmaps = new ArrayList<Bitmap>();, +    private Handler mainHandler;, +, +    @Before, +    public void setUp() {, +        clock = mock(BitmapPreFillRunner.Clock.class);, +, +        pool = mock(BitmapPool.class);, +        when(pool.put(any(Bitmap.class))).thenAnswer(new AddBitmapPoolAnswer(addedBitmaps));, +        cache = mock(MemoryCache.class);, +        when(cache.put(any(Key.class), any(Resource.class))).thenAnswer(new AddBitmapCacheAnswer(addedBitmaps));, +        mainHandler = mock(Handler.class);, +    }, +, +    private BitmapPreFillRunner getHandler(Map<PreFillType, Integer> allocationOrder) {, +        return new BitmapPreFillRunner(pool, cache, new PreFillQueue(allocationOrder), clock, mainHandler);, +    }, +, +    @Test, +    public void testAllocatesABitmapPerSizeInAllocationOrder() {, +        PreFillType size = new PreFillType.Builder(100), +                .setConfig(Bitmap.Config.ARGB_8888), +                .build();, +        final int toAdd = 3;, +        Map<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();, +        allocationOrder.put(size, toAdd);, +        BitmapPreFillRunner handler = getHandler(allocationOrder);, +        handler.run();, +, +        Bitmap expected = Bitmap.createBitmap(size.getWidth(), size.getHeight(), size.getConfig());, +        assertThat(addedBitmaps, contains(expected, expected, expected));, +    }, +, +    @Test, +    public void testAllocatesBitmapsInOrderGivenByAllocationOrder() {, +        PreFillType smallWidth = new PreFillType.Builder(50, 100), +                .setConfig(Bitmap.Config.ARGB_8888), +                .build();, +        PreFillType smallHeight = new PreFillType.Builder(100, 50), +                .setConfig(Bitmap.Config.RGB_565), +                .build();, +, +        PreFillType[] expectedOrder = new PreFillType[] {, +                smallWidth,, +                smallHeight,, +                smallWidth,, +                smallHeight,, +        };, +, +        HashMap<PreFillType, Integer> allocationOrder = new HashMap<PreFillType, Integer>();, +        allocationOrder.put(smallWidth, 2);, +        allocationOrder.put(smallHeight, 2);, +        BitmapPreFillRunner handler = getHandler(allocationOrder);]
[+++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +//    @SuppressWarnings("unchecked"), +//    @Test, +//    public void testGenericLoader() throws Exception {, +//        File expected = new File("test");, +//, +//        Target<File> target = mock(Target.class);, +//        doAnswer(new CallCallback()).when(target).getSize(any(SizeReadyCallback.class));, +//, +//        GlideUrl glideUrl =  mock(GlideUrl.class);, +//        DataFetcher<File> dataFetcher = mock(DataFetcher.class);, +//        when(dataFetcher.loadData(any(Priority.class))).thenReturn(expected);, +//        when(dataFetcher.getId()).thenReturn("id");, +//        ModelLoader<GlideUrl, File> modelLoader = mock(ModelLoader.class);, +//        when(modelLoader.getDataFetcher(eq(glideUrl), anyInt(), anyInt())), +//                .thenReturn(dataFetcher);, +//, +//        Resource<File> expectedResource = mock(Resource.class);, +//        when(expectedResource.get()).thenReturn(expected);, +//        ResourceDecoder<File, File> sourceDecoder = mock(ResourceDecoder.class);, +//        when(sourceDecoder.decode(eq(expected), anyInt(), anyInt())).thenReturn(expectedResource);, +//        ResourceDecoder<File, File> cacheDecoder = mock(ResourceDecoder.class);, +//        ResourceEncoder<File> encoder = mock(ResourceEncoder.class);, +//        Encoder<File> sourceEncoder = mock(Encoder.class);, +//, +//, +//        verify(target).onResourceReady(eq(expected), any(GlideAnimation.class));, +//    }, +                .asDrawable(), +                .listener(new RequestListener<Drawable>() {, +                    public boolean onResourceReady(Drawable resource, Object model, Target target,, +                .thumbnail(requestManager.asDrawable(), +                .apply(placeholderOf(placeholder).error(error)), +//    @Test, +//    public void testNullModelWithModelLoaderDoesNotThrow() {, +//        String nullString = null;, +//        Drawable drawable = new ColorDrawable(Color.RED);, +//        StreamModelLoader<String> modelLoader = mock(StreamModelLoader.class);, +//, +//        verify(target).onLoadFailed(any(Exception.class), eq(drawable));, +//    }, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +//    @SuppressWarnings("unchecked"), +//    @Test, +//    public void testGenericLoader() throws Exception {, +//        File expected = new File("test");, +//, +//        Target<File> target = mock(Target.class);, +//        doAnswer(new CallCallback()).when(target).getSize(any(SizeReadyCallback.class));, +//, +//        GlideUrl glideUrl =  mock(GlideUrl.class);, +//        DataFetcher<File> dataFetcher = mock(DataFetcher.class);, +//        when(dataFetcher.loadData(any(Priority.class))).thenReturn(expected);, +//        when(dataFetcher.getId()).thenReturn("id");, +//        ModelLoader<GlideUrl, File> modelLoader = mock(ModelLoader.class);, +//        when(modelLoader.getDataFetcher(eq(glideUrl), anyInt(), anyInt())), +//                .thenReturn(dataFetcher);, +//, +//        Resource<File> expectedResource = mock(Resource.class);, +//        when(expectedResource.get()).thenReturn(expected);, +//        ResourceDecoder<File, File> sourceDecoder = mock(ResourceDecoder.class);, +//        when(sourceDecoder.decode(eq(expected), anyInt(), anyInt())).thenReturn(expectedResource);, +//        ResourceDecoder<File, File> cacheDecoder = mock(ResourceDecoder.class);, +//        ResourceEncoder<File> encoder = mock(ResourceEncoder.class);, +//        Encoder<File> sourceEncoder = mock(Encoder.class);, +//, +//, +//        verify(target).onResourceReady(eq(expected), any(GlideAnimation.class));, +//    }, +                .asDrawable(), +                .listener(new RequestListener<Drawable>() {, +                    public boolean onResourceReady(Drawable resource, Object model, Target target,, +                .thumbnail(requestManager.asDrawable(), +                .apply(placeholderOf(placeholder).error(error)), +//    @Test, +//    public void testNullModelWithModelLoaderDoesNotThrow() {, +//        String nullString = null;, +//        Drawable drawable = new ColorDrawable(Color.RED);, +//        StreamModelLoader<String> modelLoader = mock(StreamModelLoader.class);, +//, +//        verify(target).onLoadFailed(any(Exception.class), eq(drawable));, +//    }, +++ b/library/src/androidTest/java/com/bumptech/glide/RequestBuilderTest.java, +import com.bumptech.glide.request.GlideContext;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +    @Mock GlideContext glideContext;, +    @Mock RequestTracker requestTracker;, +    @Mock Lifecycle lifecycle;, +        MockitoAnnotations.initMocks(this);, +        new RequestBuilder(null, Object.class, Object.class, requestTracker, lifecycle);, +        when(glideContext.buildImageViewTarget(any(ImageView.class), any(Class.class))).thenReturn(mock(Target.class));, +        return new RequestBuilder(glideContext, Object.class, Object.class, requestTracker, lifecycle), +                .load((Object) null);, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +//    @SuppressWarnings("unchecked"), +//    @Test, +//    public void testGenericLoader() throws Exception {, +//        File expected = new File("test");, +//]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }, +    }, +}, +, +subprojects {, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = 1.7, +        targetCompatibility = 1.7, +    }, +}, +, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    /** 250 MB of cache. */, +        dataLoadProviderRegistry.register(InputStream.class, File.class, new StreamFileDataLoadProvider());, +            // Do nothing., +            // Do nothing., +        public void onResourceReady(Object resource, GlideAnimation<Object> glideAnimation) {, +            // Do nothing., +        }, +            // Do nothing., +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    /** 250 MB of cache. */, +        dataLoadProviderRegistry.register(InputStream.class, File.class, new StreamFileDataLoadProvider());, +            // Do nothing., +            // Do nothing., +        public void onResourceReady(Object resource, GlideAnimation<Object> glideAnimation) {, +            // Do nothing., +        }, +            // Do nothing., +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +    public void onScrollStateChanged(AbsListView absListView, int scrollState) {, +        // Do nothing., +    }, +     * Returns a list of all models that need to be loaded for the list to display adapter items {@code start - end}., +     * A list of any size can be returned so there can be multiple models per adapter position., +     * @param start The smallest adapter position. Will be {@code >= 0 && < adapter.getCount() && <= end}, +     * @param end The largest adapter position. Will be {@code >= 0 && < adapter.getCount && >= start}, +     * @return A non null list of all models for adapter positions between {@code start} and {@code end}., +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    /** 250 MB of cache. */, +        dataLoadProviderRegistry.register(InputStream.class, File.class, new StreamFileDataLoadProvider());, +            // Do nothing., +            // Do nothing., +        public void onResourceReady(Object resource, GlideAnimation<Object> glideAnimation) {, +            // Do nothing., +        }, +            // Do nothing., +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +    public void onScrollStateChanged(AbsListView absListView, int scrollState) {, +        // Do nothing., +    }, +     * Returns a list of all models that need to be loaded for the list to display adapter items {@code start - end}., +     * A list of any size can be returned so there can be multiple models per adapter position., +     * @param start The smallest adapter position. Will be {@code >= 0 && < adapter.getCount() && <= end}, +     * @param end The largest adapter position. Will be {@code >= 0 && < adapter.getCount && >= start}, +     * @return A non null list of all models for adapter positions between {@code start} and {@code end}., +++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java, + * An interface for writing data to some persistent data store (i.e. a local File cache)., +    /**, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    /** 250 MB of cache. */, +        dataLoadProviderRegistry.register(InputStream.class, File.class, new StreamFileDataLoadProvider());, +            // Do nothing., +            // Do nothing., +        public void onResourceReady(Object resource, GlideAnimation<Object> glideAnimation) {, +            // Do nothing., +        }, +            // Do nothing., +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +    public void onScrollStateChanged(AbsListView absListView, int scrollState) {, +        // Do nothing., +    }, +     * Returns a list of all models that need to be loaded for the list to display adapter items {@code start - end}., +     * A list of any size can be returned so there can be multiple models per adapter position., +     * @param start The smallest adapter position. Will be {@code >= 0 && < adapter.getCount() && <= end}, +     * @param end The largest adapter position. Will be {@code >= 0 && < adapter.getCount && >= start}, +     * @return A non null list of all models for adapter positions between {@code start} and {@code end}., +++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java, + * An interface for writing data to some persistent data store (i.e. a local File cache)., +    /**, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java, + * An interface for writing data from a resource to some persistent data store (i.e. a local File cache)., +    // specializing the generic arguments, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    /** 250 MB of cache. */, +        dataLoadProviderRegistry.register(InputStream.class, File.class, new StreamFileDataLoadProvider());, +            // Do nothing., +            // Do nothing., +        public void onResourceReady(Object resource, GlideAnimation<Object> glideAnimation) {, +            // Do nothing., +        }, +            // Do nothing., +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +    public void onScrollStateChanged(AbsListView absListView, int scrollState) {, +        // Do nothing., +    }, +     * Returns a list of all models that need to be loaded for the list to display adapter items {@code start - end}., +     * A list of any size can be returned so there can be multiple models per adapter position., +     * @param start The smallest adapter position. Will be {@code >= 0 && < adapter.getCount() && <= end}, +     * @param end The largest adapter position. Will be {@code >= 0 && < adapter.getCount && >= start}, +     * @return A non null list of all models for adapter positions between {@code start} and {@code end}., +++ b/library/src/main/java/com/bumptech/glide/load/Encoder.java, + * An interface for writing data to some persistent data store (i.e. a local File cache)., +    /**, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceEncoder.java, + * An interface for writing data from a resource to some persistent data store (i.e. a local File cache)., +    // specializing the generic arguments, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Resource.java, +     *     appropriate to return a new instance for each call. For example,, +     *     {@link android.graphics.drawable.Drawable Drawable}s should only be used by a single, +     *     {@link android.view.View View} at a time so each call to this method for Resources that wrap]
[+++ b/gradle.properties, +ROBOLECTRIC_VERSION=3.6.1, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=3.6.1, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java, +import android.annotation.TargetApi;, +import android.os.Build;, +import android.os.Build.VERSION_CODES;, +import android.support.annotation.NonNull;, +import android.support.annotation.Nullable;, +  /** Matches the behavior of {@link MediaMetadataRetriever#getFrameAtTime(long)}. */, +  @VisibleForTesting, +  static final int DEFAULT_FRAME_OPTION = MediaMetadataRetriever.OPTION_CLOSEST_SYNC;, +, +      /*defaultValue=*/ MediaMetadataRetriever.OPTION_CLOSEST_SYNC,, +  public boolean handles(@NonNull T data, @NonNull Options options) {, +  public Resource<Bitmap> decode(, +      @NonNull T resource, int outWidth, int outHeight, @NonNull Options options), +      throws IOException {, +    if (frameOption == null) {, +      frameOption = DEFAULT_FRAME_OPTION;, +    }, +      result =, +          decodeFrame(mediaMetadataRetriever, frameTimeMicros, frameOption, outWidth, outHeight);, +, +  @TargetApi(Build.VERSION_CODES.O_MR1), +  @Nullable, +  private static Bitmap decodeFrame(, +      MediaMetadataRetriever mediaMetadataRetriever,, +      long frameTimeMicros,, +      int frameOption,, +      int outWidth,, +      int outHeight) {, +     if (Build.VERSION.SDK_INT >= VERSION_CODES.O_MR1) {, +       return mediaMetadataRetriever.getScaledFrameAtTime(, +           frameTimeMicros, frameOption, outWidth, outHeight);, +    } else {, +      return mediaMetadataRetriever.getFrameAtTime(frameTimeMicros, frameOption);, +    }, +  }, +, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=3.6.1, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java, +import android.annotation.TargetApi;, +import android.os.Build;, +import android.os.Build.VERSION_CODES;, +import android.support.annotation.NonNull;, +import android.support.annotation.Nullable;, +  /** Matches the behavior of {@link MediaMetadataRetriever#getFrameAtTime(long)}. */, +  @VisibleForTesting, +  static final int DEFAULT_FRAME_OPTION = MediaMetadataRetriever.OPTION_CLOSEST_SYNC;, +, +      /*defaultValue=*/ MediaMetadataRetriever.OPTION_CLOSEST_SYNC,, +  public boolean handles(@NonNull T data, @NonNull Options options) {, +  public Resource<Bitmap> decode(, +      @NonNull T resource, int outWidth, int outHeight, @NonNull Options options), +      throws IOException {, +    if (frameOption == null) {, +      frameOption = DEFAULT_FRAME_OPTION;, +    }, +      result =, +          decodeFrame(mediaMetadataRetriever, frameTimeMicros, frameOption, outWidth, outHeight);, +, +  @TargetApi(Build.VERSION_CODES.O_MR1), +  @Nullable, +  private static Bitmap decodeFrame(, +      MediaMetadataRetriever mediaMetadataRetriever,, +      long frameTimeMicros,, +      int frameOption,, +      int outWidth,, +      int outHeight) {, +     if (Build.VERSION.SDK_INT >= VERSION_CODES.O_MR1) {, +       return mediaMetadataRetriever.getScaledFrameAtTime(, +           frameTimeMicros, frameOption, outWidth, outHeight);, +    } else {, +      return mediaMetadataRetriever.getFrameAtTime(frameTimeMicros, frameOption);, +    }, +  }, +, +++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculatorTest.java, +    @Override, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=3.6.1, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoDecoder.java, +import android.annotation.TargetApi;, +import android.os.Build;, +import android.os.Build.VERSION_CODES;, +import android.support.annotation.NonNull;, +import android.support.annotation.Nullable;, +  /** Matches the behavior of {@link MediaMetadataRetriever#getFrameAtTime(long)}. */, +  @VisibleForTesting, +  static final int DEFAULT_FRAME_OPTION = MediaMetadataRetriever.OPTION_CLOSEST_SYNC;, +, +      /*defaultValue=*/ MediaMetadataRetriever.OPTION_CLOSEST_SYNC,, +  public boolean handles(@NonNull T data, @NonNull Options options) {, +  public Resource<Bitmap> decode(, +      @NonNull T resource, int outWidth, int outHeight, @NonNull Options options), +      throws IOException {, +    if (frameOption == null) {]
[+++ b/library/src/main/java/com/bumptech/glide/util/Util.java, +   * Returns {@code true} if called on a background thread, {@code false} otherwise.]
[+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +import android.support.annotation.NonNull;, +import android.support.annotation.Nullable;, +  private static final int TRANSFORMATION = 1 << 11;, +  private static final int RESOURCE_CLASS = 1 << 12;, +  private static final int FALLBACK = 1 << 13;, +  private static final int FALLBACK_ID = 1 << 14;, +  private static final int THEME = 1 << 15;, +  public final CHILD diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {, +  public final CHILD priority(@NonNull Priority priority) {, +  public final CHILD placeholder(@Nullable Drawable drawable) {, +  public final CHILD error(@Nullable Drawable drawable) {, +  public final CHILD signature(@NonNull Key signature) {, +  public final <T> CHILD set(@NonNull Option<T> option, @NonNull T value) {, +    Preconditions.checkNotNull(option);, +    Preconditions.checkNotNull(value);, +  public final CHILD decode(@NonNull Class<?> resourceClass) {, +  public CHILD encodeFormat(@NonNull Bitmap.CompressFormat format) {, +    return set(BitmapEncoder.COMPRESSION_FORMAT, Preconditions.checkNotNull(format));, +  public CHILD encodeQuality(int quality) {, +  /**, +   * Sets the {@link DecodeFormat} to use when decoding {@link Bitmap} objects using, +   * {@link Downsampler}., +   *, +   * <p>{@link DecodeFormat} is a request, not a requirement. It's possible the resource will be, +   * decoded using a decoder that cannot control the format, +   * ({@link android.media.MediaMetadataRetriever} for example), or that the decoder may choose to, +   * ignore the requested format if it can't display the image (ie RGB_565 is requested, but the, +   * image has alpha)., +   */, +  public CHILD format(@NonNull DecodeFormat format) {, +   *, +   * @param frameTimeMicros The time position in microseconds of the desired frame. If negative, the, +   *                        Android framework implementation return a representative frame., +  public CHILD frame(long frameTimeMicros) {, +    return set(VideoBitmapDecoder.TARGET_FRAME, frameTimeMicros);, +  /**, +   * Sets the {@link DownsampleStrategy} to use when decoding {@link Bitmap Bitmaps} using, +   * {@link Downsampler}., +   */, +  public CHILD downsample(@NonNull DownsampleStrategy strategy) {, +    return set(Downsampler.DOWNSAMPLE_STRATEGY, Preconditions.checkNotNull(strategy));, +  public CHILD transform(Context context, @NonNull Transformation<Bitmap> transformation) {, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +import android.support.annotation.NonNull;, +import android.support.annotation.Nullable;, +  private static final int TRANSFORMATION = 1 << 11;, +  private static final int RESOURCE_CLASS = 1 << 12;, +  private static final int FALLBACK = 1 << 13;, +  private static final int FALLBACK_ID = 1 << 14;, +  private static final int THEME = 1 << 15;, +  public final CHILD diskCacheStrategy(@NonNull DiskCacheStrategy strategy) {, +  public final CHILD priority(@NonNull Priority priority) {, +  public final CHILD placeholder(@Nullable Drawable drawable) {, +  public final CHILD error(@Nullable Drawable drawable) {, +  public final CHILD signature(@NonNull Key signature) {, +  public final <T> CHILD set(@NonNull Option<T> option, @NonNull T value) {, +    Preconditions.checkNotNull(option);, +    Preconditions.checkNotNull(value);, +  public final CHILD decode(@NonNull Class<?> resourceClass) {, +  public CHILD encodeFormat(@NonNull Bitmap.CompressFormat format) {, +    return set(BitmapEncoder.COMPRESSION_FORMAT, Preconditions.checkNotNull(format));, +  public CHILD encodeQuality(int quality) {, +  /**, +   * Sets the {@link DecodeFormat} to use when decoding {@link Bitmap} objects using, +   * {@link Downsampler}., +   *, +   * <p>{@link DecodeFormat} is a request, not a requirement. It's possible the resource will be, +   * decoded using a decoder that cannot control the format, +   * ({@link android.media.MediaMetadataRetriever} for example), or that the decoder may choose to, +   * ignore the requested format if it can't display the image (ie RGB_565 is requested, but the, +   * image has alpha)., +   */, +  public CHILD format(@NonNull DecodeFormat format) {, +   *, +   * @param frameTimeMicros The time position in microseconds of the desired frame. If negative, the, +   *                        Android framework implementation return a representative frame., +  public CHILD frame(long frameTimeMicros) {, +    return set(VideoBitmapDecoder.TARGET_FRAME, frameTimeMicros);, +  /**, +   * Sets the {@link DownsampleStrategy} to use when decoding {@link Bitmap Bitmaps} using, +   * {@link Downsampler}., +   */, +  public CHILD downsample(@NonNull DownsampleStrategy strategy) {, +    return set(Downsampler.DOWNSAMPLE_STRATEGY, Preconditions.checkNotNull(strategy));, +  public CHILD transform(Context context, @NonNull Transformation<Bitmap> transformation) {, +++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +import android.support.annotation.NonNull;, +import android.support.annotation.Nullable;, +@SuppressWarnings({"PMD.UseUtilityClass", "unused"}), +  /**, +   * Returns a {@link RequestOptions} object with {@link #sizeMultiplier(float)} set., +   */, +  /**, +   * Returns a {@link RequestOptions} object with {@link #sizeMultiplier(float)} set., +   */, +  public static RequestOptions diskCacheStrategyOf(@NonNull DiskCacheStrategy diskCacheStrategy) {, +  /**, +   * Returns a {@link RequestOptions} object with {@link #priority(Priority)}} set., +   */]
[+++ b/library/AndroidManifest.xml]
[+++ b/build.gradle, +        configProperties.checkStyleConfigDir = rootProject.rootDir, +++ b/build.gradle, +        configProperties.checkStyleConfigDir = rootProject.rootDir, +++ b/checkstyle.xml, +        <property name="file" value="${checkStyleConfigDir}/checkstyle_suppressions.xml" />]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +  public RequestBuilder<TranscodeType> load(@Nullable String string) {, +  public RequestBuilder<TranscodeType> load(@Nullable Uri uri) {, +  public RequestBuilder<TranscodeType> load(@Nullable File file) {, +  public RequestBuilder<TranscodeType> load(@Nullable Integer resourceId) {, +  public RequestBuilder<TranscodeType> load(@Nullable URL url) {, +  public RequestBuilder<TranscodeType> load(@Nullable byte[] model) {]
[+++ b/.gitignore, +*.ipr, +*.iws, +++ b/.gitignore, +*.ipr, +*.iws, +++ b/build.gradle, +            classpath "net.ltgt.gradle:gradle-errorprone-plugin:${ERROR_PRONE_PLUGIN_VERSION}", +++ b/.gitignore, +*.ipr, +*.iws, +++ b/build.gradle, +            classpath "net.ltgt.gradle:gradle-errorprone-plugin:${ERROR_PRONE_PLUGIN_VERSION}", +++ b/checkstyle.xml, +          <property name="legalComment" value="^Public API.?$|^NOPMD .*$" />, +++ b/.gitignore, +*.ipr, +*.iws, +++ b/build.gradle, +            classpath "net.ltgt.gradle:gradle-errorprone-plugin:${ERROR_PRONE_PLUGIN_VERSION}", +++ b/checkstyle.xml, +          <property name="legalComment" value="^Public API.?$|^NOPMD .*$" />, +++ b/gradle.properties, +PMD_VERSION=5.8.1, +ERROR_PRONE_VERSION=2.1.4-SNAPSHOT, +ERROR_PRONE_PLUGIN_VERSION=0.0.13, +++ b/.gitignore, +*.ipr, +*.iws, +++ b/build.gradle, +            classpath "net.ltgt.gradle:gradle-errorprone-plugin:${ERROR_PRONE_PLUGIN_VERSION}", +++ b/checkstyle.xml, +          <property name="legalComment" value="^Public API.?$|^NOPMD .*$" />, +++ b/gradle.properties, +PMD_VERSION=5.8.1, +ERROR_PRONE_VERSION=2.1.4-SNAPSHOT, +ERROR_PRONE_PLUGIN_VERSION=0.0.13, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +    // GC before delete() to release files on Windows (https://stackoverflow.com/a/4213208/253468), +    System.gc();, +  public void testWritesBytesDirectlyToDiskIfTransformationIsUnitTransformation() {, +++ b/.gitignore, +*.ipr, +*.iws, +++ b/build.gradle, +            classpath "net.ltgt.gradle:gradle-errorprone-plugin:${ERROR_PRONE_PLUGIN_VERSION}", +++ b/checkstyle.xml, +          <property name="legalComment" value="^Public API.?$|^NOPMD .*$" />, +++ b/gradle.properties, +PMD_VERSION=5.8.1, +ERROR_PRONE_VERSION=2.1.4-SNAPSHOT, +ERROR_PRONE_PLUGIN_VERSION=0.0.13, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +    // GC before delete() to release files on Windows (https://stackoverflow.com/a/4213208/253468), +    System.gc();, +  public void testWritesBytesDirectlyToDiskIfTransformationIsUnitTransformation() {, +++ b/library/build.gradle, +, +    if (project.plugins.hasPlugin('net.ltgt.errorprone')) {, +       errorprone "com.google.errorprone:error_prone_core:${ERROR_PRONE_VERSION}", +    }, +++ b/.gitignore, +*.ipr, +*.iws, +++ b/build.gradle, +            classpath "net.ltgt.gradle:gradle-errorprone-plugin:${ERROR_PRONE_PLUGIN_VERSION}", +++ b/checkstyle.xml, +          <property name="legalComment" value="^Public API.?$|^NOPMD .*$" />, +++ b/gradle.properties, +PMD_VERSION=5.8.1, +ERROR_PRONE_VERSION=2.1.4-SNAPSHOT, +ERROR_PRONE_PLUGIN_VERSION=0.0.13, +++ b/integration/gifencoder/src/test/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +    // GC before delete() to release files on Windows (https://stackoverflow.com/a/4213208/253468), +    System.gc();, +  public void testWritesBytesDirectlyToDiskIfTransformationIsUnitTransformation() {, +++ b/library/build.gradle, +, +    if (project.plugins.hasPlugin('net.ltgt.errorprone')) {, +       errorprone "com.google.errorprone:error_prone_core:${ERROR_PRONE_VERSION}", +    }, +++ b/library/pmd-ruleset.xml, +    <description>Check for flaws in Glide's codebase.</description>, +    <rule ref="rulesets/java/strings.xml"/>, +    <rule ref="rulesets/java/strings.xml/AvoidDuplicateLiterals">, +        <properties>, +            <property name="skipAnnotations" value="true" />, +        </properties>, +    <rule ref="rulesets/java/design.xml/AccessorMethodGeneration", +          message="Avoid autogenerated methods to access private fields and methods of inner / outer classes., +                   Use @Synthetic to flag members made more visible than necessary to prevent accessors.">, +        <properties>, +            <!-- Ignore references to `private static final * * = <literal>`, +                 Suppress via XPath: current node (access that generates the accessor) is ., +                 Check if there exists a FieldDeclaration (private static final), +                 which has a VariableInitializer with a Literal, +                 and the name (@Image) of the declaration is the same as the accessed member., +                 TODO calculated constants are false positive https://github.com/pmd/pmd/issues/808, +            -->, +            <property name="violationSuppressXPath" value="]
[+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +      sourceExecutor = GlideExecutor.newSourceExecutor();, +      diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +      sourceExecutor = GlideExecutor.newSourceExecutor();, +      diskCacheExecutor = GlideExecutor.newDiskCacheExecutor();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java, +import android.os.StrictMode;, +import android.os.StrictMode.ThreadPolicy;, +import java.util.concurrent.Callable;, +import java.util.concurrent.ExecutionException;, +import java.util.concurrent.Future;, +public final class GlideExecutor extends ThreadPoolExecutor {, +, +  /**, +   * The default thread name prefix for executors used to load/decode/transform data not found in, +   * cache., +   */, +  public static final String DEFAULT_SOURCE_EXECUTOR_NAME = "source";, +  /**, +   * The default thread name prefix for executors used to load/decode/transform data found in, +   * Glide's cache., +   */, +  public static final String DEFAULT_DISK_CACHE_EXECUTOR_NAME = "disk-cache";, +  /**, +   * The default thread count for executors used to load/decode/transform data found in Glide's, +   * cache., +   */, +  public static final int DEFAULT_DISK_CACHE_EXECUTOR_THREADS = 1;, +  private final boolean runAllOnMainThread;, +   * Returns a new fixed thread pool with the default thread count returned from, +   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_DISK_CACHE_EXECUTOR_NAME} thread name, +   * prefix, and the, +   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}, +   * uncaught throwable strategy., +   * <p>Disk cache executors do not allow network operations on their threads., +  public static GlideExecutor newDiskCacheExecutor() {, +    return newDiskCacheExecutor(DEFAULT_DISK_CACHE_EXECUTOR_THREADS,, +        DEFAULT_DISK_CACHE_EXECUTOR_NAME, UncaughtThrowableStrategy.DEFAULT);, +   * Returns a new fixed thread pool with the given thread count, thread name prefix,, +   * and {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}., +   * <p>Disk cache executors do not allow network operations on their threads., +   * @param threadCount The number of threads., +  public static GlideExecutor newDiskCacheExecutor(int threadCount, String name,, +    return new GlideExecutor(threadCount, name, uncaughtThrowableStrategy,, +        true /*preventNetworkOperations*/, false /*runAllOnMainThread*/);, +  /**, +   * Returns a new fixed thread pool with the default thread count returned from, +   * {@link #calculateBestThreadCount()}, the {@link #DEFAULT_SOURCE_EXECUTOR_NAME} thread name, +   * prefix, and the, +   * {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy#DEFAULT}, +   * uncaught throwable strategy., +   *, +   * <p>Source executors allow network operations on their threads., +   */, +  public static GlideExecutor newSourceExecutor() {, +    return newSourceExecutor(calculateBestThreadCount(), DEFAULT_SOURCE_EXECUTOR_NAME,, +        UncaughtThrowableStrategy.DEFAULT);, +  }, +, +  /**, +   * Returns a new fixed thread pool with the given thread count, thread name prefix,, +   * and {@link com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy}., +   *, +   * <p>Source executors allow network operations on their threads., +   *, +   * @param threadCount The number of threads., +   * @param name The prefix for each thread name., +   * @param uncaughtThrowableStrategy The {@link, +   * com.bumptech.glide.load.engine.executor.GlideExecutor.UncaughtThrowableStrategy} to use to, +   *                                  handle uncaught exceptions., +   */, +  public static GlideExecutor newSourceExecutor(int threadCount, String name,, +      UncaughtThrowableStrategy uncaughtThrowableStrategy) {, +    return new GlideExecutor(threadCount, name, uncaughtThrowableStrategy,, +        false /*preventNetworkOperations*/, false /*runAllOnMainThread*/);, +  }, +, +  // Visible for testing., +  GlideExecutor(int poolSize, String name,, +      UncaughtThrowableStrategy uncaughtThrowableStrategy, boolean preventNetworkOperations,, +      boolean runAllOnMainThread) {, +        poolSize /*corePoolSize*/,, +        poolSize /*maximumPoolSize*/,, +        new DefaultThreadFactory(name, uncaughtThrowableStrategy, preventNetworkOperations));, +    this.runAllOnMainThread = runAllOnMainThread;, +  }, +, +  @Override, +  public void execute(Runnable command) {, +    if (runAllOnMainThread) {, +      command.run();, +    } else {, +      super.execute(command);, +    }, +  }, +, +  @NonNull, +  @Override, +  public Future<?> submit(Runnable task) {]
[+++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +    public void testDoesNotThrowWhenWidthIsSizeOriginal() {, +        getNullModelRequest().override(Target.SIZE_ORIGINAL, 100);, +    }, +, +    @Test, +    public void testDoesNotThrowWhenHeightIsSizeOriginal() {, +        getNullModelRequest().override(100, Target.SIZE_ORIGINAL);, +    }, +, +    @Test, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +    public void testDoesNotThrowWhenWidthIsSizeOriginal() {, +        getNullModelRequest().override(Target.SIZE_ORIGINAL, 100);, +    }, +, +    @Test, +    public void testDoesNotThrowWhenHeightIsSizeOriginal() {, +        getNullModelRequest().override(100, Target.SIZE_ORIGINAL);, +    }, +, +    @Test, +++ b/library/src/androidTest/java/com/bumptech/glide/request/target/SimpleTargetTest.java, +    @Test, +    public void testConstructorDoesNotThrowWithSizeOriginal() {, +        getTarget(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);, +    }, +, +    @Test, +    public void testGetSizeDoesNotThrowWithSizeOriginal() {, +        getTarget(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL).getSize(mock(SizeReadyCallback.class));, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +    public void testDoesNotThrowWhenWidthIsSizeOriginal() {, +        getNullModelRequest().override(Target.SIZE_ORIGINAL, 100);, +    }, +, +    @Test, +    public void testDoesNotThrowWhenHeightIsSizeOriginal() {, +        getNullModelRequest().override(100, Target.SIZE_ORIGINAL);, +    }, +, +    @Test, +++ b/library/src/androidTest/java/com/bumptech/glide/request/target/SimpleTargetTest.java, +    @Test, +    public void testConstructorDoesNotThrowWithSizeOriginal() {, +        getTarget(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);, +    }, +, +    @Test, +    public void testGetSizeDoesNotThrowWithSizeOriginal() {, +        getTarget(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL).getSize(mock(SizeReadyCallback.class));, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +        if (!Util.isValidDimensions(width, height)) {, +            throw new IllegalArgumentException("Width and height must be Target#SIZE_ORIGINAL or > 0");, +            if (Util.isValidDimensions(overrideWidth, overrideHeight), +                    && !Util.isValidDimensions(thumbnailRequestBuilder.overrideWidth,, +                            thumbnailRequestBuilder.overrideHeight)) {, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +    public void testDoesNotThrowWhenWidthIsSizeOriginal() {, +        getNullModelRequest().override(Target.SIZE_ORIGINAL, 100);, +    }, +, +    @Test, +    public void testDoesNotThrowWhenHeightIsSizeOriginal() {, +        getNullModelRequest().override(100, Target.SIZE_ORIGINAL);, +    }, +, +    @Test, +++ b/library/src/androidTest/java/com/bumptech/glide/request/target/SimpleTargetTest.java, +    @Test, +    public void testConstructorDoesNotThrowWithSizeOriginal() {, +        getTarget(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);, +    }, +, +    @Test, +    public void testGetSizeDoesNotThrowWithSizeOriginal() {, +        getTarget(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL).getSize(mock(SizeReadyCallback.class));, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +        if (!Util.isValidDimensions(width, height)) {, +            throw new IllegalArgumentException("Width and height must be Target#SIZE_ORIGINAL or > 0");, +            if (Util.isValidDimensions(overrideWidth, overrideHeight), +                    && !Util.isValidDimensions(thumbnailRequestBuilder.overrideWidth,, +                            thumbnailRequestBuilder.overrideHeight)) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformation.java, +import com.bumptech.glide.util.Util;, +        if (!Util.isValidDimensions(outWidth, outHeight)) {, +++ b/library/src/androidTest/java/com/bumptech/glide/GenericRequestBuilderTest.java, +    public void testDoesNotThrowWhenWidthIsSizeOriginal() {, +        getNullModelRequest().override(Target.SIZE_ORIGINAL, 100);, +    }, +, +    @Test, +    public void testDoesNotThrowWhenHeightIsSizeOriginal() {, +        getNullModelRequest().override(100, Target.SIZE_ORIGINAL);, +    }, +, +    @Test, +++ b/library/src/androidTest/java/com/bumptech/glide/request/target/SimpleTargetTest.java, +    @Test, +    public void testConstructorDoesNotThrowWithSizeOriginal() {]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.content.res.Resources;, +    Resources resources = context.getResources();, +            new BitmapDrawableDecoder<>(resources, bitmapPool, new StreamBitmapDecoder(bitmapPool))), +            new BitmapDrawableDecoder<>(resources, bitmapPool,, +            new BitmapDrawableTranscoder(resources, bitmapPool)), +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.content.res.Resources;, +    Resources resources = context.getResources();, +            new BitmapDrawableDecoder<>(resources, bitmapPool, new StreamBitmapDecoder(bitmapPool))), +            new BitmapDrawableDecoder<>(resources, bitmapPool,, +            new BitmapDrawableTranscoder(resources, bitmapPool)), +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java, +import com.bumptech.glide.util.Preconditions;, +  private final ResourceDecoder<DataType, Bitmap> decoder;, +      ResourceDecoder<DataType, Bitmap> decoder) {, +    this.resources = Preconditions.checkNotNull(resources);, +    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);, +    this.decoder = Preconditions.checkNotNull(decoder);, +    return decoder.handles(source);, +    Resource<Bitmap> bitmapResource = decoder.decode(source, width, height, options);, +    return LazyBitmapDrawableResource.obtain(resources, bitmapPool, bitmapResource.get());, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.content.res.Resources;, +    Resources resources = context.getResources();, +            new BitmapDrawableDecoder<>(resources, bitmapPool, new StreamBitmapDecoder(bitmapPool))), +            new BitmapDrawableDecoder<>(resources, bitmapPool,, +            new BitmapDrawableTranscoder(resources, bitmapPool)), +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java, +import com.bumptech.glide.util.Preconditions;, +  private final ResourceDecoder<DataType, Bitmap> decoder;, +      ResourceDecoder<DataType, Bitmap> decoder) {, +    this.resources = Preconditions.checkNotNull(resources);, +    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);, +    this.decoder = Preconditions.checkNotNull(decoder);, +    return decoder.handles(source);, +    Resource<Bitmap> bitmapResource = decoder.decode(source, width, height, options);, +    return LazyBitmapDrawableResource.obtain(resources, bitmapPool, bitmapResource.get());, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/LazyBitmapDrawableResource.java, +package com.bumptech.glide.load.resource.bitmap;, +, +import android.content.Context;, +import android.content.res.Resources;, +import android.graphics.Bitmap;, +import android.graphics.drawable.BitmapDrawable;, +, +import com.bumptech.glide.Glide;, +import com.bumptech.glide.load.engine.Resource;, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import com.bumptech.glide.util.Preconditions;, +import com.bumptech.glide.util.Util;, +, +/**, + * Lazily allocates a {@link android.graphics.drawable.BitmapDrawable} from a given, + * {@link android.graphics.Bitmap} on the first call to {@link #get()}., + */, +public class LazyBitmapDrawableResource implements Resource<BitmapDrawable> {, +, +  private final Bitmap bitmap;, +  private final Resources resources;, +  private final BitmapPool bitmapPool;, +, +  public static LazyBitmapDrawableResource obtain(Context context, Bitmap bitmap) {, +    return obtain(context.getResources(), Glide.get(context).getBitmapPool(), bitmap);, +  }, +, +  public static LazyBitmapDrawableResource obtain(Resources resources, BitmapPool bitmapPool,, +      Bitmap bitmap) {, +    return new LazyBitmapDrawableResource(resources, bitmapPool, bitmap);, +  }, +, +  LazyBitmapDrawableResource(Resources resources, BitmapPool bitmapPool, Bitmap bitmap) {, +    this.resources = Preconditions.checkNotNull(resources);, +    this.bitmapPool = Preconditions.checkNotNull(bitmapPool);, +    this.bitmap = Preconditions.checkNotNull(bitmap);, +  }, +, +  @Override, +  public Class<BitmapDrawable> getResourceClass() {, +    return BitmapDrawable.class;, +  }, +, +  @Override, +  public BitmapDrawable get() {, +    return new BitmapDrawable(resources, bitmap);, +  }, +, +  @Override, +  public int getSize() {, +    return Util.getBitmapByteSize(bitmap);, +  }, +, +  @Override, +  public void recycle() {, +    if (!bitmapPool.put(bitmap)) {, +      bitmap.recycle();, +    }, +  }, +}, +++ b/library/src/main/java/com/bumptech/glide/Glide.java]
[+++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        // TODO: fixme., +//        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> firstTranscoder = mock(ResourceTranscoder.class);, +//        when(firstTranscoder.transcode(any(Resource.class))).thenReturn(firstResource);, +//        when(firstTranscoder.getId()).thenReturn("transcoder1");, +        // TODO: fixme., +//        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> secondTranscoder = mock(ResourceTranscoder.class);, +//        when(secondTranscoder.transcode(any(Resource.class))).thenReturn(secondResource);, +//        when(secondTranscoder.getId()).thenReturn("transcoder2");, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        // TODO: fixme., +//        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> firstTranscoder = mock(ResourceTranscoder.class);, +//        when(firstTranscoder.transcode(any(Resource.class))).thenReturn(firstResource);, +//        when(firstTranscoder.getId()).thenReturn("transcoder1");, +        // TODO: fixme., +//        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> secondTranscoder = mock(ResourceTranscoder.class);, +//        when(secondTranscoder.transcode(any(Resource.class))).thenReturn(secondResource);, +//        when(secondTranscoder.getId()).thenReturn("transcoder2");, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        // TODO: fixme., +//        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> firstTranscoder = mock(ResourceTranscoder.class);, +//        when(firstTranscoder.transcode(any(Resource.class))).thenReturn(firstResource);, +//        when(firstTranscoder.getId()).thenReturn("transcoder1");, +        // TODO: fixme., +//        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> secondTranscoder = mock(ResourceTranscoder.class);, +//        when(secondTranscoder.transcode(any(Resource.class))).thenReturn(secondResource);, +//        when(secondTranscoder.getId()).thenReturn("transcoder2");, +++ /dev/null, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        // TODO: fixme., +//        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> firstTranscoder = mock(ResourceTranscoder.class);, +//        when(firstTranscoder.transcode(any(Resource.class))).thenReturn(firstResource);, +//        when(firstTranscoder.getId()).thenReturn("transcoder1");, +        // TODO: fixme., +//        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> secondTranscoder = mock(ResourceTranscoder.class);, +//        when(secondTranscoder.transcode(any(Resource.class))).thenReturn(secondResource);, +//        when(secondTranscoder.getId()).thenReturn("transcoder2");, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        // TODO: fixme., +//        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> firstTranscoder = mock(ResourceTranscoder.class);, +//        when(firstTranscoder.transcode(any(Resource.class))).thenReturn(firstResource);, +//        when(firstTranscoder.getId()).thenReturn("transcoder1");, +        // TODO: fixme., +//        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> secondTranscoder = mock(ResourceTranscoder.class);, +//        when(secondTranscoder.transcode(any(Resource.class))).thenReturn(secondResource);, +//        when(secondTranscoder.getId()).thenReturn("transcoder2");, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        // TODO: fixme., +//        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> firstTranscoder = mock(ResourceTranscoder.class);, +//        when(firstTranscoder.transcode(any(Resource.class))).thenReturn(firstResource);, +//        when(firstTranscoder.getId()).thenReturn("transcoder1");, +        // TODO: fixme., +//        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> secondTranscoder = mock(ResourceTranscoder.class);, +//        when(secondTranscoder.transcode(any(Resource.class))).thenReturn(secondResource);, +//        when(secondTranscoder.getId()).thenReturn("transcoder2");, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        // TODO: fixme., +//        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> firstTranscoder = mock(ResourceTranscoder.class);, +//        when(firstTranscoder.transcode(any(Resource.class))).thenReturn(firstResource);, +//        when(firstTranscoder.getId()).thenReturn("transcoder1");, +        // TODO: fixme., +//        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> secondTranscoder = mock(ResourceTranscoder.class);, +//        when(secondTranscoder.transcode(any(Resource.class))).thenReturn(secondResource);, +//        when(secondTranscoder.getId()).thenReturn("transcoder2");, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +        // TODO: fixme., +//        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> firstTranscoder = mock(ResourceTranscoder.class);, +//        when(firstTranscoder.transcode(any(Resource.class))).thenReturn(firstResource);, +//        when(firstTranscoder.getId()).thenReturn("transcoder1");, +        // TODO: fixme., +//        ResourceTranscoder<GifBitmapWrapper, GlideDrawable> secondTranscoder = mock(ResourceTranscoder.class);, +//        when(secondTranscoder.transcode(any(Resource.class))).thenReturn(secondResource);, +//        when(secondTranscoder.getId()).thenReturn("transcoder2");, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    Downsampler downsampler =, +        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);, +    registry = new Registry(), +        .register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    Downsampler downsampler =, +        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);, +    registry = new Registry(), +        .register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    Downsampler downsampler =, +        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);, +    registry = new Registry(), +        .register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    Downsampler downsampler =, +        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);, +    registry = new Registry(), +        .register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    Downsampler downsampler =, +        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);, +    registry = new Registry(), +        .register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java, +    return new ThumbFetcher(, +        uri, new ThumbnailStreamOpener(query, byteArrayPool, context.getContentResolver()));, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    Downsampler downsampler =, +        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);, +    registry = new Registry(), +        .register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java, +    return new ThumbFetcher(, +        uri, new ThumbnailStreamOpener(query, byteArrayPool, context.getContentResolver()));, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java, +import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;, +      ThumbnailQuery query, ArrayPool byteArrayPool, ContentResolver contentResolver) {, +    this(DEFAULT_SERVICE, query, byteArrayPool, contentResolver);, +    int orientation = ImageHeaderParser.UNKNOWN_ORIENTATION;, +      orientation = new ImageHeaderParser(is, byteArrayPool).getOrientation();, +    return orientation;, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    Downsampler downsampler =, +        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);, +    registry = new Registry(), +        .register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java, +    return new ThumbFetcher(, +        uri, new ThumbnailStreamOpener(query, byteArrayPool, context.getContentResolver()));, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java, +import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;, +      ThumbnailQuery query, ArrayPool byteArrayPool, ContentResolver contentResolver) {, +    this(DEFAULT_SERVICE, query, byteArrayPool, contentResolver);, +    int orientation = ImageHeaderParser.UNKNOWN_ORIENTATION;, +      orientation = new ImageHeaderParser(is, byteArrayPool).getOrientation();, +    return orientation;, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    Downsampler downsampler =, +        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);, +    registry = new Registry(), +        .register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java, +    return new ThumbFetcher(]
[+++ b/gradle.properties, +, +APPLY_UPLOAD_SCRIPT=true, +++ b/gradle.properties, +, +APPLY_UPLOAD_SCRIPT=true, +++ b/third_party/disklrucache, +Subproject commit fbfaeb5ea614dc6d65c641dac54349de205a8330]
[+++ b/gradle.properties, +VERSION_NAME=3.7.0-SNAPSHOT, +VERSION_MINOR=7, +VERSION_CODE=13, +++ b/gradle.properties, +VERSION_NAME=3.7.0-SNAPSHOT, +VERSION_MINOR=7, +VERSION_CODE=13, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.4.0-SNAPSHOT, +VERSION_MINOR=4, +VERSION_CODE=9, +++ b/gradle.properties, +VERSION_NAME=3.7.0-SNAPSHOT, +VERSION_MINOR=7, +VERSION_CODE=13, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.4.0-SNAPSHOT, +VERSION_MINOR=4, +VERSION_CODE=9, +++ b/integration/volley/gradle.properties, +VERSION_NAME=1.4.0-SNAPSHOT, +VERSION_MINOR=4, +VERSION_CODE=9]
[+++ b/checkstyle.xml, +++ b/checkstyle.xml, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import android.widget.ImageView;, +import com.bumptech.glide.request.target.Target;, +, +    /**, +     * {@inheritDoc}, +     *, +     * <p>, +     *     Note - If no transformation is set for this load, a default transformation will be applied based on the, +     *     value returned from {@link android.widget.ImageView#getScaleType()}. To avoid this default transformation,, +     *     use {@link #dontTransform()}., +     * </p>, +     *, +     * @param view {@inheritDoc}, +     * @return {@inheritDoc}, +     */, +    @Override, +    public Target<TranscodeType> into(ImageView view) {, +        return super.into(view);, +    }, +, +    @Override, +    void applyFitCenter() {, +        fitCenter();, +    }, +, +    @Override, +    void applyCenterCrop() {, +        centerCrop();, +    }, +++ b/checkstyle.xml, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import android.widget.ImageView;, +import com.bumptech.glide.request.target.Target;, +, +    /**, +     * {@inheritDoc}, +     *, +     * <p>, +     *     Note - If no transformation is set for this load, a default transformation will be applied based on the, +     *     value returned from {@link android.widget.ImageView#getScaleType()}. To avoid this default transformation,, +     *     use {@link #dontTransform()}., +     * </p>, +     *, +     * @param view {@inheritDoc}, +     * @return {@inheritDoc}, +     */, +    @Override, +    public Target<TranscodeType> into(ImageView view) {, +        return super.into(view);, +    }, +, +    @Override, +    void applyFitCenter() {, +        fitCenter();, +    }, +, +    @Override, +    void applyCenterCrop() {, +        centerCrop();, +    }, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import android.widget.ImageView;, +import com.bumptech.glide.request.target.Target;, +, +    /**, +     * {@inheritDoc}, +     *, +     * <p>, +     *     Note - If no transformation is set for this load, a default transformation will be applied based on the, +     *     value returned from {@link android.widget.ImageView#getScaleType()}. To avoid this default transformation,, +     *     use {@link #dontTransform()}., +     * </p>, +     *, +     * @param view {@inheritDoc}, +     * @return {@inheritDoc}, +     */, +    @Override, +    public Target<Drawable> into(ImageView view) {, +        return super.into(view);, +    }, +, +    @Override, +    void applyFitCenter() {, +        fitCenter();, +    }, +, +    @Override, +    void applyCenterCrop() {, +        centerCrop();, +    }, +++ b/checkstyle.xml, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import android.widget.ImageView;, +import com.bumptech.glide.request.target.Target;, +, +    /**, +     * {@inheritDoc}]
[+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +   * <p>this will override previous calls to {@link #dontTransform()}., +   *, +   * @param context any {@link android.content.Context}., +   * @see #transform(Class, com.bumptech.glide.load.Transformation), +   * @see #optionalCenterCrop(android.content.Context), +   *, +   * @deprecated Use {@link #centerCrop()}., +   */, +  @Deprecated, +  @GlideOption(, +      staticMethodName = "centerCropTransform",, +      memoizeStaticMethod = true, +  ), +  public CHILD centerCrop(@SuppressWarnings("unused") Context context) {, +    return centerCrop();, +  }, +, +  /**, +   * Applies {@link com.bumptech.glide.load.resource.bitmap.CenterCrop} to all default types and, +   * throws an exception if asked to transform an unknown type., +   *]
[+++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +, +        /* Bitmaps */, +        resourceEncoderRegistry.add(Bitmap.class, new BitmapEncoder());, +, +        /* GlideBitmapDrawables */, +        decoderRegistry.append(new GlideBitmapDrawableDecoder<InputStream>(context.getResources(), bitmapPool,, +                new StreamBitmapDecoder(bitmapPool, decodeFormat)), InputStream.class, GlideBitmapDrawable.class);, +        resourceEncoderRegistry.add(GlideBitmapDrawable.class,, +                new GlideBitmapDrawableEncoder(bitmapPool, new BitmapEncoder()));, +        /* Gifs */, +, +        /* Gif Frames */, +        /* Files */, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +, +        /* Bitmaps */, +        resourceEncoderRegistry.add(Bitmap.class, new BitmapEncoder());, +, +        /* GlideBitmapDrawables */, +        decoderRegistry.append(new GlideBitmapDrawableDecoder<InputStream>(context.getResources(), bitmapPool,, +                new StreamBitmapDecoder(bitmapPool, decodeFormat)), InputStream.class, GlideBitmapDrawable.class);, +        resourceEncoderRegistry.add(GlideBitmapDrawable.class,, +                new GlideBitmapDrawableEncoder(bitmapPool, new BitmapEncoder()));, +        /* Gifs */, +, +        /* Gif Frames */, +        /* Files */, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +    private final DataFetcherSet sourceFetchers;, +    public DecodeJob(Class<Z> resourceClass, EngineKey resultKey, int width, int height, DataFetcherSet sourceFetchers,, +        this(resourceClass, resultKey, width, height, sourceFetchers, requestContext, transformation, transcoder,, +    DecodeJob(Class<Z> resourceClass, EngineKey resultKey, int width, int height, DataFetcherSet sourceFetchers,, +        this.sourceFetchers = sourceFetchers;, +        Resource<Z> decoded = decodeFromFetcherSet(sourceFetchers, diskCacheStrategy == DiskCacheStrategy.SOURCE);, +        return transformEncodeAndTranscode(decoded);, +    }, +, +    private Resource<Z> decodeFromFetcherSet(DataFetcherSet fetchers, boolean cacheSource) throws Exception {, +                Resource<Z> decoded = decodeSource(fetcher, cacheSource);, +                if (decoded != null) {, +                    return decoded;, +, +        sourceFetchers.cancel();, +    private <T> Resource<Z> decodeSource(DataFetcher<T> fetcher, boolean cacheSource) throws Exception {, +            return decodeFromSourceData(rewinder, cacheSource);, +    private <T> Resource<Z> decodeFromSourceData(DataRewinder<T> rewinder, boolean cacheSource) throws Exception {, +        if (cacheSource) {, +    private <T> Resource<Z> cacheAndDecodeSourceData(DataRewinder<T> rewinder) throws Exception {, +    private Resource<Z> loadFromCache(Key key) throws Exception {, +        DataFetcherSet fetchers = requestContext.getDataFetchers(cacheFile, width, height);, +            result = decodeFromFetcherSet(fetchers, false /*cacheSource*/);, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +, +        /* Bitmaps */, +        resourceEncoderRegistry.add(Bitmap.class, new BitmapEncoder());, +, +        /* GlideBitmapDrawables */, +        decoderRegistry.append(new GlideBitmapDrawableDecoder<InputStream>(context.getResources(), bitmapPool,, +                new StreamBitmapDecoder(bitmapPool, decodeFormat)), InputStream.class, GlideBitmapDrawable.class);, +        resourceEncoderRegistry.add(GlideBitmapDrawable.class,, +                new GlideBitmapDrawableEncoder(bitmapPool, new BitmapEncoder()));, +        /* Gifs */, +, +        /* Gif Frames */, +        /* Files */, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +    private final DataFetcherSet sourceFetchers;, +    public DecodeJob(Class<Z> resourceClass, EngineKey resultKey, int width, int height, DataFetcherSet sourceFetchers,, +        this(resourceClass, resultKey, width, height, sourceFetchers, requestContext, transformation, transcoder,, +    DecodeJob(Class<Z> resourceClass, EngineKey resultKey, int width, int height, DataFetcherSet sourceFetchers,, +        this.sourceFetchers = sourceFetchers;, +        Resource<Z> decoded = decodeFromFetcherSet(sourceFetchers, diskCacheStrategy == DiskCacheStrategy.SOURCE);, +        return transformEncodeAndTranscode(decoded);, +    }, +, +    private Resource<Z> decodeFromFetcherSet(DataFetcherSet fetchers, boolean cacheSource) throws Exception {, +                Resource<Z> decoded = decodeSource(fetcher, cacheSource);, +                if (decoded != null) {, +                    return decoded;, +, +        sourceFetchers.cancel();, +    private <T> Resource<Z> decodeSource(DataFetcher<T> fetcher, boolean cacheSource) throws Exception {, +            return decodeFromSourceData(rewinder, cacheSource);, +    private <T> Resource<Z> decodeFromSourceData(DataRewinder<T> rewinder, boolean cacheSource) throws Exception {, +        if (cacheSource) {, +    private <T> Resource<Z> cacheAndDecodeSourceData(DataRewinder<T> rewinder) throws Exception {, +    private Resource<Z> loadFromCache(Key key) throws Exception {, +        DataFetcherSet fetchers = requestContext.getDataFetchers(cacheFile, width, height);, +            result = decodeFromFetcherSet(fetchers, false /*cacheSource*/);, +++ /dev/null]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/samples/flickr/build.gradle, +        applicationId "com.bumptech.glide.samples.flickr", +        versionCode 1, +        versionName "1.0.0", +++ /dev/null, +++ /dev/null, +++ b/samples/flickr/build.gradle, +        applicationId "com.bumptech.glide.samples.flickr", +        versionCode 1, +        versionName "1.0.0", +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/samples/flickr/build.gradle, +        applicationId "com.bumptech.glide.samples.flickr", +        versionCode 1, +        versionName "1.0.0", +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/samples/flickr/build.gradle, +        applicationId "com.bumptech.glide.samples.flickr", +        versionCode 1, +        versionName "1.0.0", +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/samples/flickr/build.gradle, +        applicationId "com.bumptech.glide.samples.flickr", +        versionCode 1, +        versionName "1.0.0", +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/samples/flickr/build.gradle, +        applicationId "com.bumptech.glide.samples.flickr", +        versionCode 1, +        versionName "1.0.0", +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/samples/flickr/build.gradle, +        applicationId "com.bumptech.glide.samples.flickr", +        versionCode 1, +        versionName "1.0.0", +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/samples/flickr/build.gradle, +        applicationId "com.bumptech.glide.samples.flickr", +        versionCode 1, +        versionName "1.0.0", +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/samples/flickr/build.gradle, +        applicationId "com.bumptech.glide.samples.flickr", +        versionCode 1, +        versionName "1.0.0", +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/samples/flickr/build.gradle, +        applicationId "com.bumptech.glide.samples.flickr", +        versionCode 1, +        versionName "1.0.0", +++ /dev/null]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/CachingTest.java, +  private static final long TIMEOUT_MS = 5000;, +  private static final TimeUnit TIMEOUT_UNIT = TimeUnit.MILLISECONDS;, +    future.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);, +        .get(TIMEOUT_MS, TIMEOUT_UNIT);, +        .get(TIMEOUT_MS, TIMEOUT_UNIT);, +        .get(TIMEOUT_MS, TIMEOUT_UNIT);, +        .get(TIMEOUT_MS, TIMEOUT_UNIT);, +    future.get(TIMEOUT_MS, TIMEOUT_UNIT);, +    countDownLatch.await(TIMEOUT_MS, TIMEOUT_UNIT);]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java, +      throws ExecutionException, InterruptedException {, +          .appendPath(resources.getResourceTypeName(iconResourceId)), +          .appendPath(resources.getResourceEntryName(iconResourceId)), +          .appendPath(resources.getResourceTypeName(iconResourceId)), +          .appendPath(resources.getResourceEntryName(iconResourceId)), +          .appendPath(resources.getResourceTypeName(iconResourceId)), +          .appendPath(resources.getResourceEntryName(iconResourceId)), +          .appendPath(resources.getResourceTypeName(iconResourceId)), +          .appendPath(resources.getResourceEntryName(iconResourceId)), +      String packageName = info.activityInfo.packageName;, +      int iconResourceId = getResourceId(packageName);, +      if (iconResourceId != 0, +              && doesApplicationPackageNameMatchResourcePackageName(packageName, iconResourceId)) {, +, +  /**, +   * Returns {@code true} iff the resource package name is exactly the same as the containing, +   * application package name for a given resource id., +   *, +   * <p>The resource package name is the value returned by, +   * {@link Resources#getResourcePackageName(int)}. The application package name is package name of, +   * the enclosing application. If these two things are equal, then we can both construct a Context, +   * for that package and retrieve a resource id for that package from a "standard" resource Uri, +   * containing a name instead of an id. If they aren't equal, then we can do only one of the two, +   * required tasks, so our Uri load will always fail. To handle this properly, we'd need callers to, +   * include both package names in the Uri. I'm not aware of any standardized Uri format for doing, +   * so, so these requests will just be treated as unsupported for the time being., +   *, +   * <p>Take Calendar (emulators API 24 and below) as an example:, +   * <ul>, +   *     <li>package name: com.google.android.calendar</li>, +   *     <li>resource package name: com.android.calendar</li>, +   * </ul>, +   * We can construct one of two possible Uris:, +   * <ul>, +   *     <li>android.resource://com.google.android.calendar/mipmap/ic_icon_calendar.</li>, +   *     <li>android.resource://com.android.calendar/mipmap/ic_icon_calendar.<</li>, +   * </ul>, +   * From the first Uri, we can obtain the correct Context/Resources for the calendar package, but, +   * our attempts to resolve the correct resource id will fail because we do not have the resource, +   * package name. From the second Uri we cannot obtain the Context/Resources for the calendar, +   * package because the resource package name doesn't match the application package name., +   */, +  private boolean doesApplicationPackageNameMatchResourcePackageName(, +          String applicationPackageName, int iconResourceId) {, +    try {, +      Context current = context.createPackageContext(applicationPackageName, /*flags=*/ 0);, +      String resourcePackageName = current.getResources().getResourcePackageName(iconResourceId);, +      return applicationPackageName.equals(resourcePackageName);, +    } catch (NameNotFoundException e) {, +      // This should never happen, +      throw new RuntimeException(e);, +    }, +  }, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java, +      throws ExecutionException, InterruptedException {, +          .appendPath(resources.getResourceTypeName(iconResourceId)), +          .appendPath(resources.getResourceEntryName(iconResourceId)), +          .appendPath(resources.getResourceTypeName(iconResourceId)), +          .appendPath(resources.getResourceEntryName(iconResourceId)), +          .appendPath(resources.getResourceTypeName(iconResourceId)), +          .appendPath(resources.getResourceEntryName(iconResourceId)), +          .appendPath(resources.getResourceTypeName(iconResourceId)), +          .appendPath(resources.getResourceEntryName(iconResourceId)), +      String packageName = info.activityInfo.packageName;, +      int iconResourceId = getResourceId(packageName);, +      if (iconResourceId != 0, +              && doesApplicationPackageNameMatchResourcePackageName(packageName, iconResourceId)) {, +, +  /**, +   * Returns {@code true} iff the resource package name is exactly the same as the containing, +   * application package name for a given resource id., +   *, +   * <p>The resource package name is the value returned by, +   * {@link Resources#getResourcePackageName(int)}. The application package name is package name of, +   * the enclosing application. If these two things are equal, then we can both construct a Context, +   * for that package and retrieve a resource id for that package from a "standard" resource Uri, +   * containing a name instead of an id. If they aren't equal, then we can do only one of the two, +   * required tasks, so our Uri load will always fail. To handle this properly, we'd need callers to, +   * include both package names in the Uri. I'm not aware of any standardized Uri format for doing, +   * so, so these requests will just be treated as unsupported for the time being., +   *, +   * <p>Take Calendar (emulators API 24 and below) as an example:, +   * <ul>, +   *     <li>package name: com.google.android.calendar</li>, +   *     <li>resource package name: com.android.calendar</li>, +   * </ul>, +   * We can construct one of two possible Uris:, +   * <ul>, +   *     <li>android.resource://com.google.android.calendar/mipmap/ic_icon_calendar.</li>, +   *     <li>android.resource://com.android.calendar/mipmap/ic_icon_calendar.<</li>, +   * </ul>, +   * From the first Uri, we can obtain the correct Context/Resources for the calendar package, but, +   * our attempts to resolve the correct resource id will fail because we do not have the resource, +   * package name. From the second Uri we cannot obtain the Context/Resources for the calendar, +   * package because the resource package name doesn't match the application package name., +   */, +  private boolean doesApplicationPackageNameMatchResourcePackageName(, +          String applicationPackageName, int iconResourceId) {, +    try {]
[+++ b/.gitignore, +.idea/libraries, +.idea/workspace.xml, +.idea/tasks.xml, +.idea/gradle.xml, +.idea/dictionaries, +.idea/dataSources.ids, +.idea/datasources.xml, +library/.idea, +samples/**/.idea, +++ b/.gitignore, +.idea/libraries, +.idea/workspace.xml, +.idea/tasks.xml, +.idea/gradle.xml, +.idea/dictionaries, +.idea/dataSources.ids, +.idea/datasources.xml, +library/.idea, +samples/**/.idea, +++ b/.idea/.name, +glide-parent, +++ b/.gitignore, +.idea/libraries, +.idea/workspace.xml, +.idea/tasks.xml, +.idea/gradle.xml, +.idea/dictionaries, +.idea/dataSources.ids, +.idea/datasources.xml, +library/.idea, +samples/**/.idea, +++ b/.idea/.name, +glide-parent, +++ b/.idea/androidDexCompiler.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<project version="4">, +  <component name="AndroidDexCompilerConfiguration">, +    <option name="MAX_HEAP_SIZE" value="1024" />, +  </component>, +</project>, +++ b/.gitignore, +.idea/libraries, +.idea/workspace.xml, +.idea/tasks.xml, +.idea/gradle.xml, +.idea/dictionaries, +.idea/dataSources.ids, +.idea/datasources.xml, +library/.idea, +samples/**/.idea, +++ b/.idea/.name, +glide-parent, +++ b/.idea/androidDexCompiler.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<project version="4">, +  <component name="AndroidDexCompilerConfiguration">, +    <option name="MAX_HEAP_SIZE" value="1024" />, +  </component>, +</project>, +++ b/.idea/checkstyle-idea.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<project version="4">, +  <component name="CheckStyle-IDEA">, +    <option name="configuration">, +      <map>, +        <entry key="active-configuration" value="LOCAL_FILE:$PRJ_DIR$/checkstyle.xml:Glide checkstyle" />, +        <entry key="check-nonjava-files" value="false" />, +        <entry key="check-test-classes" value="false" />, +        <entry key="location-0" value="CLASSPATH:/sun_checks.xml:The default CheckStyle rules" />, +        <entry key="location-1" value="LOCAL_FILE:$PRJ_DIR$/checkstyle.xml:Glide checkstyle" />, +        <entry key="property-1.checkStyleConfigDir" value="$PROJECT_DIR$" />, +        <entry key="suppress-errors" value="false" />, +        <entry key="thirdparty-classpath" value="" />, +      </map>, +    </option>, +  </component>, +</project>, +++ b/.gitignore, +.idea/libraries, +.idea/workspace.xml, +.idea/tasks.xml, +.idea/gradle.xml, +.idea/dictionaries, +.idea/dataSources.ids, +.idea/datasources.xml, +library/.idea, +samples/**/.idea, +++ b/.idea/.name, +glide-parent, +++ b/.idea/androidDexCompiler.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<project version="4">, +  <component name="AndroidDexCompilerConfiguration">, +    <option name="MAX_HEAP_SIZE" value="1024" />, +  </component>, +</project>, +++ b/.idea/checkstyle-idea.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<project version="4">]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java, +    @NonNull, +    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java, +    @NonNull, +    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +  public void loadData(@NonNull Priority priority,, +      @NonNull final DataCallback<? super InputStream> callback) {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java, +    @NonNull, +    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +  public void loadData(@NonNull Priority priority,, +      @NonNull final DataCallback<? super InputStream> callback) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +import android.support.annotation.NonNull;, +  public boolean handles(@NonNull GlideUrl url) {, +  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl model, int width, int height,, +      @NonNull Options options) {, +    @NonNull, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java, +    @NonNull, +    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +  public void loadData(@NonNull Priority priority,, +      @NonNull final DataCallback<? super InputStream> callback) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +import android.support.annotation.NonNull;, +  public boolean handles(@NonNull GlideUrl url) {, +  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl model, int width, int height,, +      @NonNull Options options) {, +    @NonNull, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +public class OkHttpStreamFetcher implements DataFetcher<InputStream>, okhttp3.Callback {, +  public void loadData(@NonNull Priority priority,, +      @NonNull final DataCallback<? super InputStream> callback) {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java, +    @NonNull, +    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +  public void loadData(@NonNull Priority priority,, +      @NonNull final DataCallback<? super InputStream> callback) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +import android.support.annotation.NonNull;, +  public boolean handles(@NonNull GlideUrl url) {, +  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl model, int width, int height,, +      @NonNull Options options) {, +    @NonNull, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +public class OkHttpStreamFetcher implements DataFetcher<InputStream>, okhttp3.Callback {, +  public void loadData(@NonNull Priority priority,, +      @NonNull final DataCallback<? super InputStream> callback) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +  public void loadData(@NonNull Priority priority,, +      @NonNull DataCallback<? super InputStream> callback) {, +  private static Request.Priority glideToVolleyPriority(@NonNull Priority priority) {, +    public Map<String, String> getHeaders() {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java, +    @NonNull, +    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +  public void loadData(@NonNull Priority priority,, +      @NonNull final DataCallback<? super InputStream> callback) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +import android.support.annotation.NonNull;, +  public boolean handles(@NonNull GlideUrl url) {, +  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl model, int width, int height,, +      @NonNull Options options) {, +    @NonNull, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +public class OkHttpStreamFetcher implements DataFetcher<InputStream>, okhttp3.Callback {, +  public void loadData(@NonNull Priority priority,, +      @NonNull final DataCallback<? super InputStream> callback) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +  public void loadData(@NonNull Priority priority,, +      @NonNull DataCallback<? super InputStream> callback) {, +  private static Request.Priority glideToVolleyPriority(@NonNull Priority priority) {, +    public Map<String, String> getHeaders() {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java, +    @NonNull, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/WaitModelLoader.java, +    @NonNull, +    public void loadData(@NonNull Priority priority, @NonNull DataCallback<? super Data> callback) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +  public void loadData(@NonNull Priority priority,, +      @NonNull final DataCallback<? super InputStream> callback) {, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +import android.support.annotation.NonNull;, +  public boolean handles(@NonNull GlideUrl url) {, +  public LoadData<InputStream> buildLoadData(@NonNull GlideUrl model, int width, int height,, +      @NonNull Options options) {, +    @NonNull, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +public class OkHttpStreamFetcher implements DataFetcher<InputStream>, okhttp3.Callback {, +  public void loadData(@NonNull Priority priority,, +      @NonNull final DataCallback<? super InputStream> callback) {, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +  public void loadData(@NonNull Priority priority,, +      @NonNull DataCallback<? super InputStream> callback) {]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import com.bumptech.glide.util.ContentLengthInputStream;, +  private static final String CONTENT_LENGTH_HEADER = "Content-Length";, +          String contentLength = response.header(CONTENT_LENGTH_HEADER);, +          stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import com.bumptech.glide.util.ContentLengthInputStream;, +  private static final String CONTENT_LENGTH_HEADER = "Content-Length";, +          String contentLength = response.header(CONTENT_LENGTH_HEADER);, +          stream = ContentLengthInputStream.obtain(responseBody.byteStream(), contentLength);, +++ b/library/src/androidTest/java/com/bumptech/glide/util/ContentLengthInputStreamTest.java, +package com.bumptech.glide.util;, +, +import static com.google.common.truth.Truth.assertThat;, +import static org.junit.Assert.fail;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Mockito.when;, +, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +, +import java.io.IOException;, +import java.io.InputStream;, +, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +public class ContentLengthInputStreamTest {, +  @Mock InputStream wrapped;, +, +  @Before, +  public void setUp() {, +    MockitoAnnotations.initMocks(this);, +  }, +, +  @Test, +  public void testAvailable_withZeroReadsAndValidContentLength_returnsContentLength(), +      throws IOException {, +    int value = 123356;, +    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(value));, +, +    assertThat(is.available()).isEqualTo(value);, +  }, +, +  @Test, +  public void testAvailable_withNullContentLength_returnsWrappedAvailable(), +      throws IOException {, +    InputStream is = ContentLengthInputStream.obtain(wrapped, null /*contentLengthHeader*/);, +    int expected = 1234;, +    when(wrapped.available()).thenReturn(expected);, +, +    assertThat(is.available()).isEqualTo(expected);, +  }, +, +  @Test, +  public void testAvailable_withInvalidContentLength_returnsWrappedAvailable() throws IOException {, +    InputStream is = ContentLengthInputStream.obtain(wrapped, "invalid_length");, +    int expected = 567;, +    when(wrapped.available()).thenReturn(expected);, +, +    assertThat(is.available()).isEqualTo(expected);, +  }, +, +  @Test, +  public void testAvailable_withRead_returnsContentLengthOffsetByRead() throws IOException {, +    int contentLength = 999;, +    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));, +    when(wrapped.read()).thenReturn(1);, +, +    assertThat(is.read()).isEqualTo(1);, +    assertThat(is.available()).isEqualTo(contentLength - 1);, +  }, +, +  @Test, +  public void testAvailable_handlesReadValueOfZero() throws IOException {, +    int contentLength = 999;, +    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));, +    when(wrapped.read()).thenReturn(0);, +, +    assertThat(is.read()).isEqualTo(0);, +    assertThat(is.available()).isEqualTo(contentLength);, +  }, +, +  @Test, +  public void testAvailable_withReadBytes_returnsContentLengthOffsetByNumberOfBytes(), +      throws IOException {, +    int contentLength = 678;, +    InputStream is = ContentLengthInputStream.obtain(wrapped, String.valueOf(contentLength));, +    int read = 100;, +    when(wrapped.read(any(byte[].class), anyInt(), anyInt())).thenReturn(read);, +, +    assertThat(is.read(new byte[500], 0, 0)).isEqualTo(read);, +    assertThat(is.available()).isEqualTo(contentLength - read);, +  }, +]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java, +            parser.clear();, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java, +            parser.clear();, +++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/GifHeaderParser.java, +    public void clear() {, +        rawData = null;, +        header = null;, +    }, +]
[+++ /dev/null, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import static com.bumptech.glide.request.RequestOptions.placeholderOf;, +        // TODO: fixme., +//        requestManager, +//                .using(modelLoader, File.class), +//                .load(glideUrl), +//                .as(File.class), +//                .decoder(sourceDecoder), +//                .cacheDecoder(cacheDecoder), +//                .encoder(encoder), +//                .sourceEncoder(sourceEncoder), +//                .into(target);, +        requestManager.asDrawable().load(file).into(target);, +        requestManager.asDrawable().load(file).into(imageView);, +        requestManager.asDrawable().load(url).into(target);, +        requestManager.asDrawable().load(url).into(imageView);, +        requestManager.asBitmap().load(uri).into(target);, +                .to(byte[].class), +                .load(uri), +                .transcoder(transcoder), +        requestManager.asBitmap().to(byte[].class).load(uri).into(target);, +        requestManager.asDrawable().load(uri).into(target);, +        requestManager.asDrawable().load(uri).into(imageView);, +                .asGif(), +                .listener(new RequestListener<GifDrawable>() {, +                    public boolean onException(Exception e, Object model, Target target, boolean isFirstResource) {, +                    public boolean onResourceReady(GifDrawable resource, Object model, Target target,, +                            boolean isFromMemoryCache, boolean isFirstResource) {, +        requestManager.asDrawable().load(string).into(imageView);, +        requestManager.asDrawable().load(integer).into(target);, +        requestManager.asDrawable().load(integer).into(imageView);, +        requestManager.asDrawable().load(bytes).into(target);, +        requestManager.asDrawable().load(bytes).into(imageView);, +        requestManager.asDrawable().load(unregistered).into(target);, +        // TODO: fixme., +//        requestManager, +//                .using(mockLoader), +//                .load(unregistered), +//                .into(target);, +        requestManager.asDrawable().load(0.5f).into(target);, +                .load(fakeUri), +                .to(byte[].class), +                .load(fakeUri), +                .to(byte[].class), +                .load(fakeUri), +                .load(fakeUri), +                .transcoder(new ResourceTranscoder<Bitmap, Bitmap>() {, +                }), +                .asDrawable(), +                        .asDrawable(), +                .asDrawable(), +                        .asDrawable(), +                                .asDrawable(), +                                        .asDrawable(), +                .asDrawable(), +                        .asDrawable(), +        requestManager.asDrawable().load((Double) null).into(target);, +        requestManager.asDrawable().load((Float) null).into(target);, +        requestManager.asDrawable().load((Double) null).into(target);, +                .asDrawable(), +                .apply(placeholderOf(drawable)), +                .asDrawable(), +                .apply(placeholderOf(placeholder), +                    .error(error)), +        // TODO: fixme., +//        requestManager, +//                .using(modelLoader), +//                .load(nullString), +//                .placeholder(drawable), +//                .into(target);, +        requestManager.asDrawable().load(data).into(target);, +//        RequestBuilder<Drawable, Drawable> firstRequest = requestManager.from(String.class).transcoder, +//                (firstTranscoder), +//                .override(100, 100);, +//        RequestBuilder<Drawable, Drawable> secondRequest = firstRequest.clone().transcoder(secondTranscoder);, +//, +//        firstRequest.load(fakeUri).into(firstTarget);, +//        verify(firstTarget).onResourceReady(eq(firstResult), any(GlideAnimation.class));, +//, +//        secondRequest.load(fakeUri).into(secondTarget);, +//        verify(secondTarget).onResourceReady(eq(secondResult), any(GlideAnimation.class));, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import static com.bumptech.glide.request.RequestOptions.placeholderOf;, +        // TODO: fixme., +//        requestManager, +//                .using(modelLoader, File.class), +//                .load(glideUrl), +//                .as(File.class), +//                .decoder(sourceDecoder), +//                .cacheDecoder(cacheDecoder), +//                .encoder(encoder), +//                .sourceEncoder(sourceEncoder), +//                .into(target);, +        requestManager.asDrawable().load(file).into(target);, +        requestManager.asDrawable().load(file).into(imageView);, +        requestManager.asDrawable().load(url).into(target);, +        requestManager.asDrawable().load(url).into(imageView);]
[+++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java, +package com.bumptech.glide.request.target;, +, +import android.graphics.Bitmap;, +import android.graphics.drawable.BitmapDrawable;, +import android.graphics.drawable.Drawable;, +import android.widget.ImageView;, +, +/**, + * Efficiently displays multiple Bitmaps loaded serially into a single {@link android.view.View}., + */, +public class BitmapThumbnailImageViewTarget extends ThumbnailImageViewTarget<Bitmap> {, +  public BitmapThumbnailImageViewTarget(ImageView view) {, +    super(view);, +  }, +, +  @Override, +  protected Drawable getDrawable(Bitmap resource) {, +    return new BitmapDrawable(view.getResources(), resource);, +  }, +}, +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java, +package com.bumptech.glide.request.target;, +, +import android.graphics.Bitmap;, +import android.graphics.drawable.BitmapDrawable;, +import android.graphics.drawable.Drawable;, +import android.widget.ImageView;, +, +/**, + * Efficiently displays multiple Bitmaps loaded serially into a single {@link android.view.View}., + */, +public class BitmapThumbnailImageViewTarget extends ThumbnailImageViewTarget<Bitmap> {, +  public BitmapThumbnailImageViewTarget(ImageView view) {, +    super(view);, +  }, +, +  @Override, +  protected Drawable getDrawable(Bitmap resource) {, +    return new BitmapDrawable(view.getResources(), resource);, +  }, +}, +++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java, +import android.support.annotation.Nullable;, +  protected void setResource(@Nullable Drawable resource) {, +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java, +package com.bumptech.glide.request.target;, +, +import android.graphics.Bitmap;, +import android.graphics.drawable.BitmapDrawable;, +import android.graphics.drawable.Drawable;, +import android.widget.ImageView;, +, +/**, + * Efficiently displays multiple Bitmaps loaded serially into a single {@link android.view.View}., + */, +public class BitmapThumbnailImageViewTarget extends ThumbnailImageViewTarget<Bitmap> {, +  public BitmapThumbnailImageViewTarget(ImageView view) {, +    super(view);, +  }, +, +  @Override, +  protected Drawable getDrawable(Bitmap resource) {, +    return new BitmapDrawable(view.getResources(), resource);, +  }, +}, +++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableImageViewTarget.java, +import android.support.annotation.Nullable;, +  protected void setResource(@Nullable Drawable resource) {, +++ b/library/src/main/java/com/bumptech/glide/request/target/DrawableThumbnailImageViewTarget.java, +package com.bumptech.glide.request.target;, +, +import android.graphics.drawable.Drawable;, +import android.widget.ImageView;, +, +/**, + * Efficiently displays multiple Drawables loaded serially into a single {@link android.view.View}., + */, +public class DrawableThumbnailImageViewTarget extends ThumbnailImageViewTarget<Drawable> {, +  public DrawableThumbnailImageViewTarget(ImageView view) {, +    super(view);, +  }, +, +  @Override, +  protected Drawable getDrawable(Drawable resource) {, +    return resource;, +  }, +}, +++ b/library/src/main/java/com/bumptech/glide/request/target/BitmapThumbnailImageViewTarget.java, +package com.bumptech.glide.request.target;, +, +import android.graphics.Bitmap;, +import android.graphics.drawable.BitmapDrawable;, +import android.graphics.drawable.Drawable;, +import android.widget.ImageView;, +, +/**, + * Efficiently displays multiple Bitmaps loaded serially into a single {@link android.view.View}., + */, +public class BitmapThumbnailImageViewTarget extends ThumbnailImageViewTarget<Bitmap> {]
[+++ b/library/pom.xml]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +   * Applies the given options to the request., +   *, +   * <p>As with {@link RequestOptions#apply(RequestOptions)}, {@code #apply} only replaces those, +   * values that are explicitly set in the given {@link RequestOptions} object. If you need to, +   * completely reset all previously set options, create a new {@code RequestBuilder} instead of, +   * using this method., +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +   * Applies the given options to the request., +   *, +   * <p>As with {@link RequestOptions#apply(RequestOptions)}, {@code #apply} only replaces those, +   * values that are explicitly set in the given {@link RequestOptions} object. If you need to, +   * completely reset all previously set options, create a new {@code RequestBuilder} instead of, +   * using this method., +++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java, +  /**, +   * Updates this options set with any options that are explicitly set in the given, +   * {@code RequestOptions} object and returns this object if {@link #autoClone()} is disabled or, +   * a new {@code RequestOptions} object if {@link #autoClone()} is enabled., +   *, +   * <p>{@code #apply} only replaces those values that are explicitly set in the given, +   * {@code RequestOptions}. If you need to completely reset all previously set options, create a, +   * new {@code RequestOptions} object instead of using this method., +   *, +   * <p>The options that will be set to values in the returned {@code RequestOptions} object is the, +   * intersection of the set of options in this {@code RequestOptions} object and the given, +   * {@code RequestOptions} object that were explicitly set. If the values of any of the options, +   * conflict, the values in the returned {@code RequestOptions} object will be set to those in the, +   * given {@code RequestOptions} object., +   */]
[+++ b/integration/okhttp/src/main/AndroidManifest.xml, +    <application>, +        <meta-data, +            android:name="com.bumptech.glide.integration.okhttp.OkHttpGlideModule", +            android:value="GlideModule" />, +    </application>, +++ b/integration/okhttp/src/main/AndroidManifest.xml, +    <application>, +        <meta-data, +            android:name="com.bumptech.glide.integration.okhttp.OkHttpGlideModule", +            android:value="GlideModule" />, +    </application>, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +package com.bumptech.glide.integration.okhttp;, +, +import android.content.Context;, +, +import com.bumptech.glide.Glide;, +import com.bumptech.glide.load.model.GlideUrl;, +import com.bumptech.glide.module.GlideModule;, +, +import java.io.InputStream;, +, +/**, + * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default, + * {@link java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader} with an OkHttp based, + * {@link com.bumptech.glide.load.model.ModelLoader}., + *, + * <p>, + *     If you're using gradle, you can include this module simply by depending on the aar, the module will be merged, + *     in by manifest merger. For other build systems or for more more information, see, + *     {@link com.bumptech.glide.module.GlideModule}., + * </p>, + */, +public class OkHttpGlideModule implements GlideModule {, +    @Override, +    public void initialize(Context context, Glide glide) {, +        glide.register(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());, +    }, +}, +++ b/integration/okhttp/src/main/AndroidManifest.xml, +    <application>, +        <meta-data, +            android:name="com.bumptech.glide.integration.okhttp.OkHttpGlideModule", +            android:value="GlideModule" />, +    </application>, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +package com.bumptech.glide.integration.okhttp;, +, +import android.content.Context;, +, +import com.bumptech.glide.Glide;, +import com.bumptech.glide.load.model.GlideUrl;, +import com.bumptech.glide.module.GlideModule;, +, +import java.io.InputStream;, +, +/**, + * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default, + * {@link java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader} with an OkHttp based, + * {@link com.bumptech.glide.load.model.ModelLoader}., + *, + * <p>, + *     If you're using gradle, you can include this module simply by depending on the aar, the module will be merged, + *     in by manifest merger. For other build systems or for more more information, see, + *     {@link com.bumptech.glide.module.GlideModule}., + * </p>, + */, +public class OkHttpGlideModule implements GlideModule {, +    @Override, +    public void initialize(Context context, Glide glide) {, +        glide.register(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory());, +    }, +}, +++ b/integration/volley/src/main/AndroidManifest.xml, +  <application>, +      <meta-data, +          android:name="com.bumptech.glide.integration.volley.VolleyGlideModule", +          android:value="GlideModule" />, +  </application>, +++ b/integration/okhttp/src/main/AndroidManifest.xml, +    <application>, +        <meta-data, +            android:name="com.bumptech.glide.integration.okhttp.OkHttpGlideModule", +            android:value="GlideModule" />, +    </application>, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpGlideModule.java, +package com.bumptech.glide.integration.okhttp;, +, +import android.content.Context;, +, +import com.bumptech.glide.Glide;, +import com.bumptech.glide.load.model.GlideUrl;, +import com.bumptech.glide.module.GlideModule;, +, +import java.io.InputStream;, +, +/**, + * A {@link com.bumptech.glide.module.GlideModule} implementation to replace Glide's default, + * {@link java.net.HttpURLConnection} based {@link com.bumptech.glide.load.model.ModelLoader} with an OkHttp based]
[+++ b/samples/svg/build.gradle, +buildscript {, +    repositories {, +        mavenCentral(), +    }, +    dependencies {, +        classpath 'com.android.tools.build:gradle:0.12.+', +    }, +}, +apply plugin: 'com.android.application', +, +repositories {, +    mavenCentral(), +}, +, +android {, +    compileSdkVersion 19, +    buildToolsVersion "19.1.0", +, +    defaultConfig {, +        applicationId "com.bumptech.svgsample.app", +        minSdkVersion 10, +        targetSdkVersion 19, +        versionCode 1, +        versionName "1.0", +    }, +    buildTypes {, +        release {, +            runProguard false, +            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro', +        }, +    }, +}, +, +dependencies {, +    compile project(':library'), +    compile fileTree(dir: 'libs', include: ['*.jar']), +    compile 'com.android.support:appcompat-v7:19.+', +}, +++ b/samples/svg/build.gradle, +buildscript {, +    repositories {, +        mavenCentral(), +    }, +    dependencies {, +        classpath 'com.android.tools.build:gradle:0.12.+', +    }, +}, +apply plugin: 'com.android.application', +, +repositories {, +    mavenCentral(), +}, +, +android {, +    compileSdkVersion 19, +    buildToolsVersion "19.1.0", +, +    defaultConfig {, +        applicationId "com.bumptech.svgsample.app", +        minSdkVersion 10, +        targetSdkVersion 19, +        versionCode 1, +        versionName "1.0", +    }, +    buildTypes {, +        release {, +            runProguard false, +            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro', +        }, +    }, +}, +, +dependencies {, +    compile project(':library'), +    compile fileTree(dir: 'libs', include: ['*.jar']), +    compile 'com.android.support:appcompat-v7:19.+', +}, +++ b/samples/svg/proguard-rules.pro, +# Add project specific ProGuard rules here., +# By default, the flags in this file are appended to flags specified, +# in /Users/judds/dev/adt-bundle-mac-x86_64-20131030/sdk/tools/proguard/proguard-android.txt, +# You can edit the include path and order by changing the proguardFiles, +# directive in build.gradle., +#, +# For more details, see, +#   http://developer.android.com/guide/developing/tools/proguard.html, +, +# Add any project specific keep options here:, +, +# If your project uses WebView with JS, uncomment the following, +# and specify the fully qualified class name to the JavaScript interface, +# class:, +#-keepclassmembers class fqcn.of.javascript.interface.for.webview {, +#   public *;, +#}, +++ b/samples/svg/build.gradle, +buildscript {, +    repositories {, +        mavenCentral()]
[+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java]
[+++ b/library/lint.xml, +++ b/library/lint.xml, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.os.Build;, +    @TargetApi(Build.VERSION_CODES.HONEYCOMB), +++ b/library/lint.xml, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.os.Build;, +    @TargetApi(Build.VERSION_CODES.HONEYCOMB), +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {, +++ b/library/lint.xml, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.os.Build;, +    @TargetApi(Build.VERSION_CODES.HONEYCOMB), +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +import android.annotation.SuppressLint;, +    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1), +            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1) {, +    @SuppressLint("InlinedApi"), +        if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE) {, +        } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {, +        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {, +++ b/library/lint.xml, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.os.Build;, +    @TargetApi(Build.VERSION_CODES.HONEYCOMB), +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +import android.annotation.SuppressLint;, +    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1), +            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1) {, +    @SuppressLint("InlinedApi"), +        if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE) {, +        } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {, +        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java, +import android.os.Build;, + * A strategy for reusing bitmaps that relies on {@link Bitmap#reconfigure(int, int, Bitmap.Config)}., + * Requires {@link Build.VERSION_CODES#KITKAT KitKat} (API {@value Build.VERSION_CODES#KITKAT}) or higher., +@TargetApi(Build.VERSION_CODES.KITKAT), +++ b/library/lint.xml, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.os.Build;, +    @TargetApi(Build.VERSION_CODES.HONEYCOMB), +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +import android.annotation.SuppressLint;, +    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1), +            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1) {, +    @SuppressLint("InlinedApi"), +        if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE) {, +        } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {, +        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java, +import android.os.Build;, + * A strategy for reusing bitmaps that relies on {@link Bitmap#reconfigure(int, int, Bitmap.Config)}., + * Requires {@link Build.VERSION_CODES#KITKAT KitKat} (API {@value Build.VERSION_CODES#KITKAT}) or higher., +@TargetApi(Build.VERSION_CODES.KITKAT), +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java, +import android.annotation.SuppressLint;, +, +    @SuppressLint("InlinedApi"), +        if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE) {, +        } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {, +++ b/library/lint.xml, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.os.Build;, +    @TargetApi(Build.VERSION_CODES.HONEYCOMB), +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java, +import android.annotation.SuppressLint;, +    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1), +            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1) {, +    @SuppressLint("InlinedApi"), +        if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE) {, +        } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {, +        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java, +import android.os.Build;, + * A strategy for reusing bitmaps that relies on {@link Bitmap#reconfigure(int, int, Bitmap.Config)}., + * Requires {@link Build.VERSION_CODES#KITKAT KitKat} (API {@value Build.VERSION_CODES#KITKAT}) or higher., +@TargetApi(Build.VERSION_CODES.KITKAT), +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java, +import android.annotation.SuppressLint;, +, +    @SuppressLint("InlinedApi"), +        if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE) {, +        } else if (level >= android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/MemorySizeCalculator.java, +    @TargetApi(Build.VERSION_CODES.KITKAT), +        return sdkInt < Build.VERSION_CODES.HONEYCOMB, +                || (sdkInt >= Build.VERSION_CODES.KITKAT && activityManager.isLowRamDevice());, +++ b/library/lint.xml, +++ b/library/src/main/java/com/bumptech/glide/Glide.java]
[+++ b/library/src/main/java/com/bumptech/glide/Resource.java, +import com.bumptech.glide.load.Key;, +    private ResourceListener listener;, +    private Key key;, +    private boolean isCacheable;, +, +    public interface ResourceListener {, +        public void onResourceReleased(Key key, Resource resource);, +    }, +    public void setResourceListener(Key key, ResourceListener listener) {, +        this.key = key;, +        this.listener = listener;, +    }, +, +    public void setCacheable(boolean isCacheable) {, +        this.isCacheable = isCacheable;, +    }, +, +    public boolean isCacheable() {, +        return isCacheable;, +    }, +, +        if (!Looper.getMainLooper().equals(Looper.myLooper())) {, +        if (!Looper.getMainLooper().equals(Looper.myLooper())) {, +            listener.onResourceReleased(key, this);, +++ b/library/src/main/java/com/bumptech/glide/Resource.java, +import com.bumptech.glide.load.Key;, +    private ResourceListener listener;, +    private Key key;, +    private boolean isCacheable;, +, +    public interface ResourceListener {, +        public void onResourceReleased(Key key, Resource resource);, +    }, +    public void setResourceListener(Key key, ResourceListener listener) {, +        this.key = key;, +        this.listener = listener;, +    }, +, +    public void setCacheable(boolean isCacheable) {, +        this.isCacheable = isCacheable;, +    }, +, +    public boolean isCacheable() {, +        return isCacheable;, +    }, +, +        if (!Looper.getMainLooper().equals(Looper.myLooper())) {, +        if (!Looper.getMainLooper().equals(Looper.myLooper())) {, +            listener.onResourceReleased(key, this);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DefaultResourceRunnerFactory.java, +import com.bumptech.glide.load.engine.cache.DiskCache;, +import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;, +    public DefaultResourceRunnerFactory(DiskCache diskCache, Handler mainHandler,, +        EngineJob engineJob = new EngineJob(key, mainHandler, isMemoryCacheable, listener);, +++ b/library/src/main/java/com/bumptech/glide/Resource.java, +import com.bumptech.glide.load.Key;, +    private ResourceListener listener;, +    private Key key;, +    private boolean isCacheable;, +, +    public interface ResourceListener {, +        public void onResourceReleased(Key key, Resource resource);, +    }, +    public void setResourceListener(Key key, ResourceListener listener) {, +        this.key = key;, +        this.listener = listener;, +    }, +, +    public void setCacheable(boolean isCacheable) {, +        this.isCacheable = isCacheable;, +    }, +, +    public boolean isCacheable() {, +        return isCacheable;, +    }, +, +        if (!Looper.getMainLooper().equals(Looper.myLooper())) {, +        if (!Looper.getMainLooper().equals(Looper.myLooper())) {, +            listener.onResourceReleased(key, this);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DefaultResourceRunnerFactory.java, +import com.bumptech.glide.load.engine.cache.DiskCache;, +import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;, +    public DefaultResourceRunnerFactory(DiskCache diskCache, Handler mainHandler,, +        EngineJob engineJob = new EngineJob(key, mainHandler, isMemoryCacheable, listener);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +import android.os.MessageQueue;, +import java.lang.ref.ReferenceQueue;, +import java.lang.ref.WeakReference;, +public class Engine implements EngineJobListener, MemoryCache.ResourceRemovedListener, Resource.ResourceListener {, +    private final Map<Key, WeakReference<Resource>> activeResources;, +    private final ReferenceQueue<Resource> resourceReferenceQueue;, +        this(null, memoryCache, diskCache, resizeService, diskCacheService, null, null, null);, +            ExecutorService diskCacheService, Map<Key, ResourceRunner> runners, KeyFactory keyFactory,, +            Map<Key, WeakReference<Resource>> activeResources) {, +        if (activeResources == null) {, +            activeResources = new HashMap<Key, WeakReference<Resource>>();, +        }, +        this.activeResources = activeResources;, +]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleGenerator.java, +package com.bumptech.glide.annotation.compiler;, +, +import com.bumptech.glide.annotation.Excludes;, +import com.squareup.javapoet.AnnotationSpec;, +import com.squareup.javapoet.ClassName;, +import com.squareup.javapoet.MethodSpec;, +import com.squareup.javapoet.ParameterizedTypeName;, +import com.squareup.javapoet.TypeName;, +import com.squareup.javapoet.TypeSpec;, +import com.squareup.javapoet.TypeSpec.Builder;, +import com.squareup.javapoet.WildcardTypeName;, +import java.util.Collections;, +import java.util.HashSet;, +import java.util.Set;, +import javax.lang.model.element.Modifier;, +import javax.lang.model.element.TypeElement;, +, +/**, + * Generates a new implementation of a AppGlideModule that calls all included ChildGlideModules and, + * the original AppGlideModule., + *, + * <p>The generated class will always call the AppGlideModule last to give it priority over choices, + * made or classes registered in ChildGlideModules., + *, + * <p>Android logging is included to allow developers to see exactly which modules are included at, + * runtime., + *, + * <p>The generated class looks something like this:, + * <pre>, + * <code>, + *  final class GeneratedAppGlideModuleImpl extends com.bumptech.glide.GeneratedAppGlideModule {, + *    private final com.bumptech.glide.samples.giphy.GiphyGlideModule appGlideModule;, + *, + *    GeneratedAppGlideModule() {, + *      appGlideModule = new com.bumptech.glide.samples.giphy.GiphyGlideModule();, + *      if (android.util.Log.isLoggable("Glide", android.util.Log.DEBUG)) {, + *        android.util.Log.d("Glide", "Discovered AppGlideModule from annotation:", + *            + " com.bumptech.glide.samples.giphy.GiphyGlideModule");, + *        android.util.Log.d("Glide", "Discovered ChildGlideModule from annotation:", + *            + "com.bumptech.glide.integration.okhttp3.OkHttpChildGlideModule");, + *      }, + *    }, + *, + *    {@literal @java.lang.Override}, + *    public void applyOptions(android.content.Context context,, + *        com.bumptech.glide.GlideBuilder builder) {, + *      appGlideModule.applyOptions(context, builder);, + *    }, + *, + *    {@literal @java.lang.Override}, + *    public void registerComponents(android.content.Context context,, + *        com.bumptech.glide.Registry registry) {, + *      new com.bumptech.glide.integration.okhttp3.OkHttpChildGlideModule(), + *          .registerComponents(context, registry);, + *      appGlideModule.registerComponents(context, registry);, + *    }, + *, + *    {@literal @java.lang.Override}, + *    public boolean isManifestParsingEnabled() {, + *      return appGlideModule.isManifestParsingEnabled();, + *    }, + *, + *    {@literal @java.lang.Override}, + *    public java.util.Set<java.lang.Class<?>> getExcludedModuleClasses() {, + *      return appGlideModule.getExcludedModuleClasses();, + *    }, + *  }, + * </code>, + * </pre>, + */, +final class AppModuleGenerator {, +  static final String GENERATED_ROOT_MODULE_PACKAGE_NAME = "com.bumptech.glide";, +  private static final String GLIDE_LOG_TAG = "Glide";, +  private static final String GENERATED_APP_MODULE_IMPL_SIMPLE_NAME =, +      "GeneratedAppGlideModuleImpl";, +  private static final String GENERATED_ROOT_MODULE_SIMPLE_NAME = "GeneratedAppGlideModule";, +  private final ProcessorUtil processorUtil;, +, +  AppModuleGenerator(ProcessorUtil processorUtil) {, +    this.processorUtil = processorUtil;, +  }, +, +  TypeSpec generate(TypeElement appGlideModule, Set<String> childGlideModuleClassNames) {, +    ClassName appGlideModuleClassName = ClassName.get(appGlideModule);, +    Set<String> excludedGlideModuleClassNames =, +        getExcludedGlideModuleClassNames(appGlideModule);, +, +    MethodSpec constructor =, +        generateConstructor(, +            appGlideModuleClassName, childGlideModuleClassNames, excludedGlideModuleClassNames);, +, +    MethodSpec registerComponents =, +        generateRegisterComponents(childGlideModuleClassNames, excludedGlideModuleClassNames);, +, +    MethodSpec getExcludedModuleClasses =, +        generateGetExcludedModuleClasses(excludedGlideModuleClassNames);, +, +    MethodSpec applyOptions =, +        MethodSpec.methodBuilder("applyOptions")]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java, +import com.bumptech.glide.util.Util;, +        int size = Util.getSize(bitmap);, +        final Key key = keyPool.get(size);, +            final int removedSize = Util.getSize(removed);, +        return Util.getSize(bitmap);, +        int size = Util.getSize(bitmap);, +        return getBitmapString(size);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/SizeStrategy.java, +import com.bumptech.glide.util.Util;, +        int size = Util.getSize(bitmap);, +        final Key key = keyPool.get(size);, +            final int removedSize = Util.getSize(removed);, +        return Util.getSize(bitmap);, +        int size = Util.getSize(bitmap);, +        return getBitmapString(size);, +++ b/library/src/main/java/com/bumptech/glide/util/Util.java, +     * Returns the in memory size of the given {@link Bitmap} in bytes., +        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {, +            // Workaround for KitKat initial release NPE in Bitmap, fixed in MR1. See issue #148., +            try {, +            } catch (NullPointerException e) {, +                // Do nothing., +        return bitmap.getHeight() * bitmap.getRowBytes();, +    }]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java, +import javax.annotation.processing.ProcessingEnvironment;, +  private final GlideExtensionValidator extensionValidator;, +  ExtensionProcessor(, +      ProcessingEnvironment processingEnvironment,, +      ProcessorUtil processorUtil,, +      IndexerGenerator indexerGenerator) {, +    extensionValidator = new GlideExtensionValidator(processingEnvironment, processorUtil);, +      extensionValidator.validateExtension(typeElement);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java, +import javax.annotation.processing.ProcessingEnvironment;, +  private final GlideExtensionValidator extensionValidator;, +  ExtensionProcessor(, +      ProcessingEnvironment processingEnvironment,, +      ProcessorUtil processorUtil,, +      IndexerGenerator indexerGenerator) {, +    extensionValidator = new GlideExtensionValidator(processingEnvironment, processorUtil);, +      extensionValidator.validateExtension(typeElement);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, +    extensionProcessor =, +        new ExtensionProcessor(processingEnvironment, processorUtil, indexerGenerator);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ExtensionProcessor.java, +import javax.annotation.processing.ProcessingEnvironment;, +  private final GlideExtensionValidator extensionValidator;, +  ExtensionProcessor(, +      ProcessingEnvironment processingEnvironment,, +      ProcessorUtil processorUtil,, +      IndexerGenerator indexerGenerator) {, +    extensionValidator = new GlideExtensionValidator(processingEnvironment, processorUtil);, +      extensionValidator.validateExtension(typeElement);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, +    extensionProcessor =, +        new ExtensionProcessor(processingEnvironment, processorUtil, indexerGenerator);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +import java.util.ArrayList;, +import java.util.List;, +import javax.annotation.processing.ProcessingEnvironment;, +  private final ProcessingEnvironment processingEnvironment;, +  private final ProcessorUtil processorUtil;, +  GlideExtensionValidator(, +      ProcessingEnvironment processingEnvironment, ProcessorUtil processorUtil) {, +    this.processingEnvironment = processingEnvironment;, +    this.processorUtil = processorUtil;, +  }, +, +  void validateExtension(TypeElement typeElement) {, +          validateGlideOption(executableElement);, +  private void validateGlideOption(ExecutableElement executableElement) {, +    if (isVoid(executableElement)) {, +      validateDeprecatedGlideOption(executableElement);, +    } else {, +      validateNewGlideOption(executableElement);, +    }, +  }, +, +  private void validateNewGlideOption(ExecutableElement executableElement) {, +    validateGlideOptionParameters(executableElement);, +    TypeMirror returnType = executableElement.getReturnType();, +    if (!isRequestOptions(returnType)) {, +      throw new IllegalArgumentException("@GlideOption methods should return a RequestOptions", +          + " object, but given: " + returnType + ". If you're using old style @GlideOption", +          + " methods, your method may have a void return type, but doing so is deprecated and", +          + " support will be removed in a future version");, +    }, +    validateGlideOptionOverride(executableElement);, +  }, +, +  private void validateDeprecatedGlideOption(ExecutableElement executableElement) {, +    validateGlideOptionParameters(executableElement);, +    validateGlideOptionOverride(executableElement);, +  }, +, +  private static void validateGlideOptionParameters(ExecutableElement executableElement) {, +    if (!isRequestOptions(expected)) {, +  private static boolean isRequestOptions(TypeMirror typeMirror) {, +    return typeMirror.toString().equals("com.bumptech.glide.request.RequestOptions");, +  }, +, +  private void validateGlideOptionOverride(ExecutableElement element) {, +    int overrideType = processorUtil.getOverrideType(element);, +    boolean isOverridingRequestOptionsMethod = isMethodInRequestOptions(element);, +    if (isOverridingRequestOptionsMethod && overrideType == GlideOption.OVERRIDE_NONE) {, +      throw new IllegalArgumentException("Accidentally attempting to override a method in", +          + " RequestOptions. Add an 'override' value in the @GlideOption annotation", +          + " if this is intentional. Offending method: ", +          + element.getEnclosingElement() + "#" + element);, +    } else if (!isOverridingRequestOptionsMethod && overrideType != GlideOption.OVERRIDE_NONE) {, +      throw new IllegalArgumentException("Requested to override an existing method in", +          + " RequestOptions, but no such method was found. Offending method: ", +          + element.getEnclosingElement() + "#" + element);, +    }, +  }, +, +  private boolean isMethodInRequestOptions(ExecutableElement toFind) {, +    // toFind is a method in a GlideExtension whose first argument is a BaseRequestOptions<?> type., +    // Since we're comparing against methods in BaseRequestOptions itself, we need to drop that, +    // first type., +    TypeElement requestOptionsType =, +        processingEnvironment, +            .getElementUtils()]
[+++ b/.gitignore, +.gradle, +build, +*.iws, +doc/**, +bin/**, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +*.swo, +samples/flickr/target, +integration/volley/target/**, +**/local.properties, +**/out/**, +**/gen-external-apklibs/**, +++ b/.gitignore, +.gradle, +build, +*.iws, +doc/**, +bin/**, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +*.swo, +samples/flickr/target, +integration/volley/target/**, +**/local.properties, +**/out/**, +**/gen-external-apklibs/**, +++ b/.gitmodules, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +[submodule "third_party/disklrucache"], +	path = third_party/disklrucache, +	url = https://github.com/sjudd/DiskLruCache.git, +[submodule "library/src/androidTest/resources/exif-orientation-examples"], +	path = library/src/androidTest/resources/exif-orientation-examples, +++ b/.gitignore, +.gradle, +build, +*.iws, +doc/**, +bin/**, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +*.swo, +samples/flickr/target, +integration/volley/target/**, +**/local.properties, +**/out/**, +**/gen-external-apklibs/**, +++ b/.gitmodules, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +[submodule "third_party/disklrucache"], +	path = third_party/disklrucache, +	url = https://github.com/sjudd/DiskLruCache.git, +[submodule "library/src/androidTest/resources/exif-orientation-examples"], +	path = library/src/androidTest/resources/exif-orientation-examples, +++ b/.travis.yml, +language: android, +android:, +  components:, +  - build-tools-19.1.0, +  licenses: , +  - 'android-sdk-license.*', +, +script: 'travis_retry ./gradlew build', +, +after_success:, +- ./gradlew uploadGlideArchives -PNEXUS_USERNAME="${NEXUS_USERNAME}" -PNEXUS_PASSWORD="${NEXUS_PASSWORD}", +, +env:, +  global:, +  - secure: m/sb1iqIHzL/xCANDf0PHBRtX4ihiccFFWsMWby5PiGDh5ncItjI+kU+Yrgdy/PwmSwwTfB5nXzCdcJe8nLADSLF5PPccuKKO63mGH/Vsai0SJt94+wr+JnBS+T1LmTrlvtlRFEcKjFhOQsnAeJL30iNtQWsoqNSgVrYqUaBdAM=, +  - secure: dMBw5H/o1VsmFX9vama8KWpS3ZbwSgVeNdwByfBgZz82ad1AkYPFN2QNt02qZsopeHCs3w91J1+2ULkEcGpi/eCjRNV449uQyx1DXB0pGkiGq9OAgeZhO/HiRAPqqzJRC4gxgOHBvfxaKm6ZD8THfExWJKTQfXrwFrh+9R4cL3g=, +++ b/.gitignore, +.gradle, +build, +*.iws, +doc/**, +bin/**, +library/target, +library/install_dependencies/maven-android-sdk-deployer, +*.swo, +samples/flickr/target, +integration/volley/target/**, +**/local.properties, +**/out/**, +**/gen-external-apklibs/**, +++ b/.gitmodules, +[submodule "third_party/volley/volley"], +	path = third_party/volley/volley, +[submodule "third_party/disklrucache"], +	path = third_party/disklrucache, +	url = https://github.com/sjudd/DiskLruCache.git, +[submodule "library/src/androidTest/resources/exif-orientation-examples"], +	path = library/src/androidTest/resources/exif-orientation-examples, +++ b/.travis.yml, +language: android, +android:]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    apply(requestManager.getDefaultRequestOptions());, +    apply(other);]
[+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java, +    int sampleSize = this.sampleSize;, +    int downsampledWidth = this.downsampledWidth;, +    int downsampledHeight = this.downsampledHeight;, +    byte[] mainPixels = this.mainPixels;, +    int[] act = this.act;, +    boolean isFirstFrameTransparent = false;, +          } else if (isFirstFrame && !isFirstFrameTransparent) {, +    this.isFirstFrameTransparent = isFirstFrameTransparent;, +, +    byte[] mainPixels = this.mainPixels;, +    short[] prefix = this.prefix;, +    byte[] suffix = this.suffix;, +    byte[] pixelStack = this.pixelStack;, +    byte[] block = this.block;, +        block = this.block;]
[+++ b/.idea/codeStyleSettings.xml, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MAJOR=3, +VERSION_MINOR=6, +SUPPORT_V4_VERSION=19.1.0, +SUPPORT_V7_VERSION=19.1.0, +# TODO: Upgrade to latest version of Volley when we compile with Java 7., +VOLLEY_VERSION=1.0.8, +ANDROID_GRADLE_VERSION=1.0.0, +ROBOLECTRIC_GRADLE_VERSION=0.14.0, +ROBOLECTRIC_VERSION=2.4, +MOCKWEBSERVER_VERSION=1.6.0, +COMPILE_SDK_VERSION=19, +BUILD_TOOLS_VERSION=19.1.0, +TARGET_SDK_VERSION=19, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml]
[+++ b/samples/giphy/build.gradle, +    compile(project(':integration:recyclerview')) {, +        transitive = false, +    }, +    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}", +++ b/samples/giphy/build.gradle, +    compile(project(':integration:recyclerview')) {, +        transitive = false, +    }, +    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}", +++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java, +import android.support.v7.widget.LinearLayoutManager;, +import android.support.v7.widget.RecyclerView;, +import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;, +import java.util.Collections;, +    RecyclerView gifList = (RecyclerView) findViewById(R.id.gif_list);, +    LinearLayoutManager layoutManager = new LinearLayoutManager(this);, +    gifList.setLayoutManager(layoutManager);, +        new ViewPreloadSizeProvider<>();, +    RecyclerViewPreloader<Api.GifResult> preloader =, +        new RecyclerViewPreloader<>(Glide.with(this), adapter, preloadSizeProvider, 4);, +    gifList.addOnScrollListener(preloader);, +    if (adapter.getItemCount() == 0) {, +  private static class GifAdapter extends RecyclerView.Adapter<GifViewHolder>, +      implements ListPreloader.PreloadModelProvider<Api.GifResult> {, +    public GifViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {, +      View view = activity.getLayoutInflater().inflate(R.layout.gif_list_item, parent, false);, +      return new GifViewHolder(view);, +    public void onBindViewHolder(GifViewHolder holder, int position) {, +      holder.gifView.setOnClickListener(new View.OnClickListener() {, +      requestBuilder.load(result).into(holder.gifView);, +      preloadSizeProvider.setView(holder.gifView);, +    }, +    @Override, +    public long getItemId(int i) {, +      return 0;, +    }, +, +    @Override, +    public int getItemCount() {, +      return results.length;, +      return Collections.singletonList(results[position]);, +, +  private static class GifViewHolder extends RecyclerView.ViewHolder {, +    private final ImageView gifView;, +, +    public GifViewHolder(View itemView) {, +      super(itemView);, +      gifView = (ImageView) itemView.findViewById(R.id.gif_view);, +    }, +  }, +++ b/samples/giphy/build.gradle, +    compile(project(':integration:recyclerview')) {, +        transitive = false, +    }, +    compile "com.android.support:recyclerview-v7:${SUPPORT_V7_VERSION}", +++ b/samples/giphy/src/main/java/com/bumptech/glide/samples/giphy/MainActivity.java, +import android.support.v7.widget.LinearLayoutManager;, +import android.support.v7.widget.RecyclerView;, +import com.bumptech.glide.integration.recyclerview.RecyclerViewPreloader;, +import java.util.Collections;, +    RecyclerView gifList = (RecyclerView) findViewById(R.id.gif_list);, +    LinearLayoutManager layoutManager = new LinearLayoutManager(this);, +    gifList.setLayoutManager(layoutManager);, +        new ViewPreloadSizeProvider<>();, +    RecyclerViewPreloader<Api.GifResult> preloader =, +        new RecyclerViewPreloader<>(Glide.with(this), adapter, preloadSizeProvider, 4);, +    gifList.addOnScrollListener(preloader);, +    if (adapter.getItemCount() == 0) {, +  private static class GifAdapter extends RecyclerView.Adapter<GifViewHolder>, +      implements ListPreloader.PreloadModelProvider<Api.GifResult> {, +    public GifViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {, +      View view = activity.getLayoutInflater().inflate(R.layout.gif_list_item, parent, false);, +      return new GifViewHolder(view);, +    public void onBindViewHolder(GifViewHolder holder, int position) {, +      holder.gifView.setOnClickListener(new View.OnClickListener() {, +      requestBuilder.load(result).into(holder.gifView);, +      preloadSizeProvider.setView(holder.gifView);, +    }, +    @Override, +    public long getItemId(int i) {, +      return 0;, +    }, +, +    @Override, +    public int getItemCount() {, +      return results.length;, +      return Collections.singletonList(results[position]);, +, +  private static class GifViewHolder extends RecyclerView.ViewHolder {, +    private final ImageView gifView;, +, +    public GifViewHolder(View itemView) {, +      super(itemView);, +      gifView = (ImageView) itemView.findViewById(R.id.gif_view);, +    }, +  }, +++ b/samples/giphy/src/main/res/layout/activity_main.xml, +              android:layout_margin="@dimen/activity_margin", +        android:contentDescription="@string/giphy_logo_description" />]
[+++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.6.0', +  <version>3.6.0</version>, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.6.0', +  <version>3.6.0</version>, +++ b/gradle.properties, +VERSION_NAME=3.6.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.6.0', +  <version>3.6.0</version>, +++ b/gradle.properties, +VERSION_NAME=3.6.0, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.3.0, +++ b/README.md, +    compile 'com.github.bumptech.glide:glide:3.6.0', +  <version>3.6.0</version>, +++ b/gradle.properties, +VERSION_NAME=3.6.0, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.3.0, +++ b/integration/volley/gradle.properties, +VERSION_NAME=1.3.0]
[+++ b/.idea/codeStyleSettings.xml, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" external.system.module.group="com.github.bumptech.glide" external.system.module.version="3.5.0-SNAPSHOT" type="JAVA_MODULE" version="4">, +++ b/gradle.properties, +VERSION_NAME=3.6.0-SNAPSHOT, +VERSION_MAJOR=3, +VERSION_MINOR=6, +VERSION_CODE=11, +SUPPORT_V4_VERSION=19.1.0, +SUPPORT_V7_VERSION=19.1.0, +# TODO: Upgrade to latest version of Volley when we compile with Java 7., +VOLLEY_VERSION=1.0.8, +ANDROID_GRADLE_VERSION=1.0.0, +ROBOLECTRIC_GRADLE_VERSION=0.14.0, +ROBOLECTRIC_VERSION=2.4, +MOCKWEBSERVER_VERSION=1.6.0, +COMPILE_SDK_VERSION=19, +BUILD_TOOLS_VERSION=19.1.0, +TARGET_SDK_VERSION=19, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" external.system.module.group="" external.system.module.version="unspecified" type="JAVA_MODULE" version="4">, +++ b/glide/build.gradle, +    [':third_party:gif_decoder', ':third_party:gif_encoder', ':library'].collect { project(it) }]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +   * <p>This method may be inefficient aways and is definitely inefficient for large hierarchies., +   * Consider memoizing the result after the View is attached or again, prefer the Activity and, +   * Fragment variants whenever possible., +   * <p>If the support {@link FragmentActivity} class is used, this method will only attempt to, +   * discover support {@link Fragment}s. Any non-support {@link android.app.Fragment}s attached, +   * to the {@link FragmentActivity} will be ignored., +   *, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +   * <p>This method may be inefficient aways and is definitely inefficient for large hierarchies., +   * Consider memoizing the result after the View is attached or again, prefer the Activity and, +   * Fragment variants whenever possible., +   * <p>If the support {@link FragmentActivity} class is used, this method will only attempt to, +   * discover support {@link Fragment}s. Any non-support {@link android.app.Fragment}s attached, +   * to the {@link FragmentActivity} will be ignored., +   *, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java, +    // Although the user might have non-support Fragments attached to FragmentActivity, searching, +    // for non-support Fragments is so expensive pre O and that should be rare enough that we, +    // prefer to just fall back to the Activity directly., +      return fragment != null ? get(fragment) : get(activity);]
[+++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +import com.bumptech.glide.util.Util;, +            queue = Util.createQueue(size);, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +import com.bumptech.glide.util.Util;, +            queue = Util.createQueue(size);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java, +import com.bumptech.glide.util.Util;, +    private final Queue<T> keyPool = Util.createQueue(MAX_SIZE);, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +import com.bumptech.glide.util.Util;, +            queue = Util.createQueue(size);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java, +import com.bumptech.glide.util.Util;, +    private final Queue<T> keyPool = Util.createQueue(MAX_SIZE);, +++ b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java, +import com.bumptech.glide.util.Util;, +        private static final Queue<ModelKey> KEY_QUEUE = Util.createQueue(0);, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +import com.bumptech.glide.util.Util;, +            queue = Util.createQueue(size);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java, +import com.bumptech.glide.util.Util;, +    private final Queue<T> keyPool = Util.createQueue(MAX_SIZE);, +++ b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java, +import com.bumptech.glide.util.Util;, +        private static final Queue<ModelKey> KEY_QUEUE = Util.createQueue(0);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +import com.bumptech.glide.util.Util;, +    private static final Queue<BitmapFactory.Options> OPTIONS_QUEUE = Util.createQueue(0);, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +import com.bumptech.glide.util.Util;, +            queue = Util.createQueue(size);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java, +import com.bumptech.glide.util.Util;, +    private final Queue<T> keyPool = Util.createQueue(MAX_SIZE);, +++ b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java, +import com.bumptech.glide.util.Util;, +        private static final Queue<ModelKey> KEY_QUEUE = Util.createQueue(0);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +import com.bumptech.glide.util.Util;, +    private static final Queue<BitmapFactory.Options> OPTIONS_QUEUE = Util.createQueue(0);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java, +        private static final Queue<GifHeaderParser> POOL = Util.createQueue(0);, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +import com.bumptech.glide.util.Util;, +            queue = Util.createQueue(size);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java, +import com.bumptech.glide.util.Util;, +    private final Queue<T> keyPool = Util.createQueue(MAX_SIZE);, +++ b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java, +import com.bumptech.glide.util.Util;, +        private static final Queue<ModelKey> KEY_QUEUE = Util.createQueue(0);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +import com.bumptech.glide.util.Util;, +    private static final Queue<BitmapFactory.Options> OPTIONS_QUEUE = Util.createQueue(0);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java, +        private static final Queue<GifHeaderParser> POOL = Util.createQueue(0);, +++ b/library/src/main/java/com/bumptech/glide/request/GenericRequest.java, +    private static final Queue<GenericRequest> REQUEST_POOL = Util.createQueue(0);, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +import com.bumptech.glide.util.Util;, +            queue = Util.createQueue(size);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java, +import com.bumptech.glide.util.Util;, +    private final Queue<T> keyPool = Util.createQueue(MAX_SIZE);, +++ b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java, +import com.bumptech.glide.util.Util;, +        private static final Queue<ModelKey> KEY_QUEUE = Util.createQueue(0);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +import com.bumptech.glide.util.Util;, +    private static final Queue<BitmapFactory.Options> OPTIONS_QUEUE = Util.createQueue(0);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java, +        private static final Queue<GifHeaderParser> POOL = Util.createQueue(0);, +++ b/library/src/main/java/com/bumptech/glide/request/GenericRequest.java, +    private static final Queue<GenericRequest> REQUEST_POOL = Util.createQueue(0);, +++ b/library/src/main/java/com/bumptech/glide/util/ByteArrayPool.java, +    private final Queue<byte[]> tempQueue = Util.createQueue(0);, +++ b/library/src/main/java/com/bumptech/glide/ListPreloader.java, +import com.bumptech.glide.util.Util;, +            queue = Util.createQueue(size);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/BaseKeyPool.java, +import com.bumptech.glide.util.Util;, +    private final Queue<T> keyPool = Util.createQueue(MAX_SIZE);, +++ b/library/src/main/java/com/bumptech/glide/load/model/ModelCache.java, +import com.bumptech.glide.util.Util;, +        private static final Queue<ModelKey> KEY_QUEUE = Util.createQueue(0);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +import com.bumptech.glide.util.Util;, +    private static final Queue<BitmapFactory.Options> OPTIONS_QUEUE = Util.createQueue(0);, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java, +        private static final Queue<GifHeaderParser> POOL = Util.createQueue(0);, +++ b/library/src/main/java/com/bumptech/glide/request/GenericRequest.java, +    private static final Queue<GenericRequest> REQUEST_POOL = Util.createQueue(0);, +++ b/library/src/main/java/com/bumptech/glide/util/ByteArrayPool.java, +    private final Queue<byte[]> tempQueue = Util.createQueue(0);, +++ b/library/src/main/java/com/bumptech/glide/util/Util.java, +import android.annotation.SuppressLint;, +import java.util.ArrayDeque;, +import java.util.LinkedList;]
[+++ b/build.gradle, +        classpath 'com.android.tools.build:gradle:0.13.+', +    gradleVersion = '2.1', +++ b/build.gradle, +        classpath 'com.android.tools.build:gradle:0.13.+', +    gradleVersion = '2.1', +++ b/glide/build.gradle, +    archives releaseJavadocJar {, +        classifier 'javadoc', +    }, +    archives releaseSourceJar {, +        classifier 'sources', +    }, +++ b/build.gradle, +        classpath 'com.android.tools.build:gradle:0.13.+', +    gradleVersion = '2.1', +++ b/glide/build.gradle, +    archives releaseJavadocJar {, +        classifier 'javadoc', +    }, +    archives releaseSourceJar {, +        classifier 'sources', +    }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/build.gradle, +        classpath 'com.android.tools.build:gradle:0.13.+', +    gradleVersion = '2.1', +++ b/glide/build.gradle, +    archives releaseJavadocJar {, +        classifier 'javadoc', +    }, +    archives releaseSourceJar {, +        classifier 'sources', +    }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Fri Sep 19 07:33:32 PDT 2014, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.1-bin.zip, +++ b/build.gradle, +        classpath 'com.android.tools.build:gradle:0.13.+', +    gradleVersion = '2.1', +++ b/glide/build.gradle, +    archives releaseJavadocJar {, +        classifier 'javadoc', +    }, +    archives releaseSourceJar {, +        classifier 'sources', +    }, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +#Fri Sep 19 07:33:32 PDT 2014, +distributionUrl=https\://services.gradle.org/distributions/gradle-2.1-bin.zip, +++ b/scripts/upload.gradle, +            archives androidSourcesJar {, +                classifier "sources", +            }, +            archives androidJavadocsJar {, +                classifier "javadoc", +            }]
[+++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import java.io.IOException;, +    private InputStream stream;, +        stream = client.newCall(request), +                .execute(), +                .body(), +                .byteStream();, +        return stream;, +        if (stream == null) {, +            return;, +        }, +        try {, +            stream.close();, +        } catch (IOException e) {, +            // Ignored, +        }, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import java.io.IOException;, +    private InputStream stream;, +        stream = client.newCall(request), +                .execute(), +                .body(), +                .byteStream();, +        return stream;, +        if (stream == null) {, +            return;, +        }, +        try {, +            stream.close();, +        } catch (IOException e) {, +            // Ignored, +        }, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +import org.mockito.InOrder;, +import static org.mockito.Mockito.inOrder;, +    private InputStream stream;, +        HttpUrlFetcher.HttpUrlConnectionFactory connectionFactory = mock(HttpUrlFetcher.HttpUrlConnectionFactory.class);, +        when(connectionFactory.build(eq(url))).thenReturn(urlConnection);, +, +        fetcher = new HttpUrlFetcher(glideUrl, connectionFactory);, +        stream = mock(InputStream.class);, +        when(urlConnection.getInputStream()).thenReturn(stream);, +, +    @Test, +    public void testClosesStreamInCleanupIfNotNull() throws Exception {, +        fetcher.loadData(Priority.HIGH);, +        fetcher.cleanup();, +, +        verify(stream).close();, +    }, +, +    @Test, +    public void testClosesStreamBeforeDisconnectingConnection() throws Exception {, +        fetcher.loadData(Priority.NORMAL);, +        fetcher.cleanup();, +, +        InOrder order = inOrder(stream, urlConnection);, +        order.verify(stream).close();, +        order.verify(urlConnection).disconnect();, +    }, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpStreamFetcher.java, +import java.io.IOException;, +    private InputStream stream;, +        stream = client.newCall(request), +                .execute(), +                .body(), +                .byteStream();, +        return stream;, +        if (stream == null) {, +            return;, +        }, +        try {, +            stream.close();, +        } catch (IOException e) {, +            // Ignored, +        }, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/HttpUrlFetcherTest.java, +import org.mockito.InOrder;, +import static org.mockito.Mockito.inOrder;, +    private InputStream stream;, +        HttpUrlFetcher.HttpUrlConnectionFactory connectionFactory = mock(HttpUrlFetcher.HttpUrlConnectionFactory.class);, +        when(connectionFactory.build(eq(url))).thenReturn(urlConnection);, +, +        fetcher = new HttpUrlFetcher(glideUrl, connectionFactory);, +        stream = mock(InputStream.class);, +        when(urlConnection.getInputStream()).thenReturn(stream);, +, +    @Test, +    public void testClosesStreamInCleanupIfNotNull() throws Exception {, +        fetcher.loadData(Priority.HIGH);, +        fetcher.cleanup();, +, +        verify(stream).close();, +    }, +, +    @Test, +    public void testClosesStreamBeforeDisconnectingConnection() throws Exception {, +        fetcher.loadData(Priority.NORMAL);, +        fetcher.cleanup();, +]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +     * models. Typically the {@link RequestManager#using(StreamModelLoader)} or, +     * {@link RequestManager#using(FileDescriptorModelLoader)} syntax is preferred because it directly links the model, +     * @see RequestManager#using(FileDescriptorModelLoader), +     * @see RequestManager#using(StreamModelLoader), +    public static RequestManager with(Context context) {, +        return RequestManagerRetriever.get(context);, +    public static RequestManager with(Activity activity) {, +        return RequestManagerRetriever.get(activity);, +    public static RequestManager with(FragmentActivity activity) {, +        return RequestManagerRetriever.get(activity);, +    public static RequestManager with(android.app.Fragment fragment) {, +        return RequestManagerRetriever.get(fragment);, +    public static RequestManager with(Fragment fragment) {, +        return RequestManagerRetriever.get(fragment);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +     * models. Typically the {@link RequestManager#using(StreamModelLoader)} or, +     * {@link RequestManager#using(FileDescriptorModelLoader)} syntax is preferred because it directly links the model, +     * @see RequestManager#using(FileDescriptorModelLoader), +     * @see RequestManager#using(StreamModelLoader), +    public static RequestManager with(Context context) {, +        return RequestManagerRetriever.get(context);, +    public static RequestManager with(Activity activity) {, +        return RequestManagerRetriever.get(activity);, +    public static RequestManager with(FragmentActivity activity) {, +        return RequestManagerRetriever.get(activity);, +    public static RequestManager with(android.app.Fragment fragment) {, +        return RequestManagerRetriever.get(fragment);, +    public static RequestManager with(Fragment fragment) {, +        return RequestManagerRetriever.get(fragment);, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +     * models. Typically the {@link RequestManager#using(StreamModelLoader)} or, +     * {@link RequestManager#using(FileDescriptorModelLoader)} syntax is preferred because it directly links the model, +     * @see RequestManager#using(FileDescriptorModelLoader), +     * @see RequestManager#using(StreamModelLoader), +    public static RequestManager with(Context context) {, +        return RequestManagerRetriever.get(context);, +    public static RequestManager with(Activity activity) {, +        return RequestManagerRetriever.get(activity);, +    public static RequestManager with(FragmentActivity activity) {, +        return RequestManagerRetriever.get(activity);, +    public static RequestManager with(android.app.Fragment fragment) {, +        return RequestManagerRetriever.get(fragment);, +    public static RequestManager with(Fragment fragment) {, +        return RequestManagerRetriever.get(fragment);, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +import android.app.Activity;, +import android.app.Fragment;, +import android.net.Uri;, +import android.os.ParcelFileDescriptor;, +import android.provider.MediaStore;, +import android.support.v4.app.FragmentActivity;, +import com.bumptech.glide.load.ResourceDecoder;, +import com.bumptech.glide.load.ResourceEncoder;, +import com.bumptech.glide.load.model.ModelLoader;, +import com.bumptech.glide.load.model.ModelLoaderFactory;, +import com.bumptech.glide.load.model.file_descriptor.FileDescriptorModelLoader;, +import com.bumptech.glide.load.model.stream.MediaStoreStreamLoader;, +import com.bumptech.glide.load.model.stream.StreamByteArrayLoader;, +import com.bumptech.glide.load.model.stream.StreamFileLoader;, +import com.bumptech.glide.load.model.stream.StreamModelLoader;, +import com.bumptech.glide.load.model.stream.StreamResourceLoader;, +import com.bumptech.glide.load.model.stream.StreamStringLoader;, +import com.bumptech.glide.load.model.stream.StreamUriLoader;, +import com.bumptech.glide.volley.VolleyUrlLoader;, +import java.io.File;, +import java.io.InputStream;, +import java.net.URL;, +import java.util.UUID;, +, +/**, + * A class for managing and starting requests for Glide. Can use activity, fragment and connectivity lifecycle events to, + * intelligently stop, start, and restart requests. Retrieve either by instantiating a new object, or to take advantage, + * built in Activity and Fragment lifecycle handling, use the static Glide.load methods with your Fragment or Activity., + *, + * @see Glide#with(Activity), + * @see Glide#with(FragmentActivity), + * @see Glide#with(Fragment), + * @see Glide#with(android.support.v4.app.Fragment), + * @see Glide#with(Context), + */, +    private final Context context;, +    private final Glide glide;, +        this.context = context;, +        this.connectivityMonitor = factory.build(context, new RequestManagerConnectivityListener(requestTracker));, +        this.glide = Glide.get(context);, +    /**, +     * Lifecycle callback that registers for connectivity events (if the android.permission.ACCESS_NETWORK_STATE, +     * permission is present) and restarts failed or paused requests., +     */, +    /**, +     * Lifecycle callback that unregisters for connectivity events (if the android.permission.ACCESS_NETWORK_STATE, +     * permission is present) and pauses in progress loads., +     */, +    /**, +     * Lifecycle callback that cancels all in progress requests and clears and recycles resources for all completed, +     * requests., +     */]
[+++ b/library/src/main/java/com/bumptech/glide/load/HttpException.java, +package com.bumptech.glide.load;, +, +import java.io.IOException;, +, +/**, + * Thrown when an http request fails., + *, + * <p>Exposes the specific status code or {@link #UNKNOWN} via {@link #getStatusCode()} so, + * users may attempt to retry or otherwise uniformly handle certain types of errors regardless of, + * the underlying http library., + */, +public final class HttpException extends IOException {, +  public static final int UNKNOWN = -1;, +  private final int statusCode;, +, +  public HttpException(int statusCode) {, +    this("Http request failed with status code: " + statusCode, statusCode);, +  }, +, +  public HttpException(String message) {, +    this(message, UNKNOWN);, +  }, +, +  public HttpException(String message, int statusCode) {, +    this(message, statusCode, null /*cause*/);, +  }, +, +  public HttpException(String message, int statusCode, Throwable cause) {, +    super(message, cause);, +    this.statusCode = statusCode;, +  }, +, +  /**, +   * Returns the http status code, or {@link #UNKNOWN} if the request failed without providing, +   * a status code., +   */, +  public int getStatusCode() {, +    return statusCode;, +  }, +}, +++ b/library/src/main/java/com/bumptech/glide/load/HttpException.java, +package com.bumptech.glide.load;, +, +import java.io.IOException;, +, +/**, + * Thrown when an http request fails., + *, + * <p>Exposes the specific status code or {@link #UNKNOWN} via {@link #getStatusCode()} so, + * users may attempt to retry or otherwise uniformly handle certain types of errors regardless of, + * the underlying http library., + */, +public final class HttpException extends IOException {, +  public static final int UNKNOWN = -1;, +  private final int statusCode;, +, +  public HttpException(int statusCode) {, +    this("Http request failed with status code: " + statusCode, statusCode);, +  }, +, +  public HttpException(String message) {, +    this(message, UNKNOWN);, +  }, +, +  public HttpException(String message, int statusCode) {, +    this(message, statusCode, null /*cause*/);, +  }, +, +  public HttpException(String message, int statusCode, Throwable cause) {, +    super(message, cause);, +    this.statusCode = statusCode;, +  }, +, +  /**, +   * Returns the http status code, or {@link #UNKNOWN} if the request failed without providing, +   * a status code., +   */, +  public int getStatusCode() {, +    return statusCode;, +  }, +}, +++ b/library/src/main/java/com/bumptech/glide/load/data/HttpUrlFetcher.java, +import com.bumptech.glide.load.HttpException;]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java, +    if (sourceIds.isEmpty()) {, +      return false;, +    }]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java, +import static org.hamcrest.CoreMatchers.equalTo;, +import static org.hamcrest.CoreMatchers.not;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.assertNotEquals;, +import static org.junit.Assert.assertThat;, +/**, + * Tests if {@link EngineKey} {@link Object#hashCode() hashCode} and {@link Object#equals(Object) equals}, + * and SHA-1 disk cache key are different on any difference in ID or existence of a certain workflow part., + * Also checking whether the equals method is symmetric., + *, + * @see #assertDifferent, + */, +    public void testDiffersIfIdDiffers() throws Exception {, +        assertDifferent(first, second);, +    public void testDiffersIfHeightDiffers() throws Exception {, +        assertDifferent(first, second);, +    public void testDiffersIfWidthDiffers() throws Exception {, +        assertDifferent(first, second);, +    public void testDiffersIfTransformationDiffers() throws Exception {, +        assertDifferent(first, second);, +    public void testDiffersIfTransformationMissing() throws Exception {, +        EngineKey first = harness.build();, +        harness.transformation = null;, +        EngineKey second = harness.build();, +, +        assertDifferent(first, second);, +    }, +, +    @Test, +    public void testDiffersIfCacheDecoderDiffers() throws Exception {, +        assertDifferent(first, second);, +    public void testDiffersIfCacheDecoderMissing() throws Exception {, +        EngineKey first = harness.build();, +        harness.cacheDecoder = null;, +        EngineKey second = harness.build();, +, +        assertDifferent(first, second);, +    }, +, +    @Test, +    public void testDiffersIfDecoderDiffers() throws Exception {, +        assertDifferent(first, second);, +    public void testDiffersIfDecoderMissing() throws Exception {, +        EngineKey first = harness.build();, +        harness.decoder = null;, +        EngineKey second = harness.build();, +, +        assertDifferent(first, second);, +    }, +, +    @Test, +    public void testDiffersIfEncoderDiffers() throws Exception {, +        assertDifferent(first, second);, +    public void testDiffersIfEncoderMissing() throws Exception {, +        EngineKey first = harness.build();, +        harness.encoder = null;, +        EngineKey second = harness.build();, +, +        assertDifferent(first, second);, +    }, +, +    @Test, +    public void testDiffersWhenTranscoderDiffers() throws Exception {, +        // The transcoder doesn't affect the cached data,, +        // so we don't expect the key digests to updated differently even though the transcoder id isn't the same., +        assertDifferent(first, second, false);, +        assertDifferent(second, first, false);, +    public void testDiffersIfTranscoderMissing() throws Exception {, +        EngineKey first = harness.build();, +        harness.transcoder = null;, +        EngineKey second = harness.build();, +, +        assertDifferent(first, second, false);, +        assertDifferent(second, first, false);, +    }, +, +    @Test, +    public void testDiffersWhenSourceEncoderDiffers() throws Exception {, +        assertDifferent(first, second);, +    @Test, +    public void testDiffersIfSourceEncoderMissing() throws Exception {, +        EngineKey first = harness.build();, +        harness.sourceEncoder = null;, +        EngineKey second = harness.build();, +, +        assertDifferent(first, second);, +    private static void assertDifferent(EngineKey first, EngineKey second), +        assertDifferent(first, second, true);, +        assertDifferent(second, first, true);, +    }, +, +    private static void assertDifferent(EngineKey first, EngineKey second, boolean diskCacheDiffers), +            throws NoSuchAlgorithmException, UnsupportedEncodingException {, +        assertNotEquals(first, second);, +        assertNotEquals(first.hashCode(), second.hashCode());, +, +            assertThat(firstDigest.digest(), not(equalTo(secondDigest.digest())));, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineKeyTest.java, +import static org.hamcrest.CoreMatchers.equalTo;]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    if (glide != null) {, +      glide.engine.tearDown();, +    }, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    if (glide != null) {, +      glide.engine.tearDown();, +    }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +import android.support.annotation.VisibleForTesting;, +  @VisibleForTesting, +  public void tearDown() {, +    engineJobFactory.tearDown();, +  }, +, +    @VisibleForTesting, +    void tearDown() {, +      diskCacheExecutor.shutdown();, +      sourceExecutor.shutdown();, +      sourceUnlimitedExecutor.shutdown();, +      animationExecutor.shutdown();, +    }, +]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java, +  public void setUp() {, +  public void load_whenLoadSucceeds_butEncoderFails_doesNotCallOnLoadFailed() {, +  public void clearRequest_withError_afterPrimaryFails_clearsErrorRequest() {, +    @NonNull, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java, +  public void setUp() {, +  public void load_whenLoadSucceeds_butEncoderFails_doesNotCallOnLoadFailed() {, +  public void clearRequest_withError_afterPrimaryFails_clearsErrorRequest() {, +    @NonNull, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +        public void update(@NonNull byte[] keyBytes, @NonNull Boolean value,, +            @NonNull MessageDigest messageDigest) {, +  @NonNull, +    @NonNull, +    Resource<Bitmap> buildFrameResource(@NonNull Bitmap bitmap, @NonNull BitmapPool bitmapPool) {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java, +  public void setUp() {, +  public void load_whenLoadSucceeds_butEncoderFails_doesNotCallOnLoadFailed() {, +  public void clearRequest_withError_afterPrimaryFails_clearsErrorRequest() {, +    @NonNull, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +        public void update(@NonNull byte[] keyBytes, @NonNull Boolean value,, +            @NonNull MessageDigest messageDigest) {, +  @NonNull, +    @NonNull, +    Resource<Bitmap> buildFrameResource(@NonNull Bitmap bitmap, @NonNull BitmapPool bitmapPool) {, +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java, +import android.support.annotation.NonNull;, +   * A constant indicating we were unable to parse the orientation from the image either because no, +   * exif segment containing orientation data existed, or because of an I/O error attempting to read, +   * the exif segment., +    /** Unrecognized type. */, +, +  @NonNull, +  ImageType getType(@NonNull InputStream is) throws IOException;, +, +  @NonNull, +  ImageType getType(@NonNull ByteBuffer byteBuffer) throws IOException;, +  int getOrientation(@NonNull InputStream is, @NonNull ArrayPool byteArrayPool) throws IOException;, +, +  int getOrientation(@NonNull ByteBuffer byteBuffer, @NonNull ArrayPool byteArrayPool), +      throws IOException;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java, +  public void setUp() {, +  public void load_whenLoadSucceeds_butEncoderFails_doesNotCallOnLoadFailed() {, +  public void clearRequest_withError_afterPrimaryFails_clearsErrorRequest() {, +    @NonNull, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +        public void update(@NonNull byte[] keyBytes, @NonNull Boolean value,, +            @NonNull MessageDigest messageDigest) {, +  @NonNull, +    @NonNull, +    Resource<Bitmap> buildFrameResource(@NonNull Bitmap bitmap, @NonNull BitmapPool bitmapPool) {, +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java, +import android.support.annotation.NonNull;, +   * A constant indicating we were unable to parse the orientation from the image either because no, +   * exif segment containing orientation data existed, or because of an I/O error attempting to read, +   * the exif segment., +    /** Unrecognized type. */, +, +  @NonNull, +  ImageType getType(@NonNull InputStream is) throws IOException;, +, +  @NonNull, +  ImageType getType(@NonNull ByteBuffer byteBuffer) throws IOException;, +  int getOrientation(@NonNull InputStream is, @NonNull ArrayPool byteArrayPool) throws IOException;, +, +  int getOrientation(@NonNull ByteBuffer byteBuffer, @NonNull ArrayPool byteArrayPool), +      throws IOException;, +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParserUtils.java, +import android.support.annotation.NonNull;, +  @NonNull, +  public static ImageType getType(@NonNull List<ImageHeaderParser> parsers,, +      @Nullable InputStream is, @NonNull ArrayPool byteArrayPool) throws IOException {, +  @NonNull, +  public static ImageType getType(@NonNull List<ImageHeaderParser> parsers,, +      @Nullable ByteBuffer buffer), +  /**, +   * Returns the orientation for the given InputStream., +   */, +  public static int getOrientation(@NonNull List<ImageHeaderParser> parsers,, +      @Nullable InputStream is, @NonNull ArrayPool byteArrayPool) throws IOException {, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/ErrorHandlingTest.java, +  public void setUp() {, +  public void load_whenLoadSucceeds_butEncoderFails_doesNotCallOnLoadFailed() {, +  public void clearRequest_withError_afterPrimaryFails_clearsErrorRequest() {, +    @NonNull, +++ b/integration/gifencoder/src/main/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoder.java, +        public void update(@NonNull byte[] keyBytes, @NonNull Boolean value,, +            @NonNull MessageDigest messageDigest) {, +  @NonNull, +    @NonNull, +    Resource<Bitmap> buildFrameResource(@NonNull Bitmap bitmap, @NonNull BitmapPool bitmapPool) {, +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java, +import android.support.annotation.NonNull;, +   * A constant indicating we were unable to parse the orientation from the image either because no, +   * exif segment containing orientation data existed, or because of an I/O error attempting to read, +   * the exif segment., +    /** Unrecognized type. */]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java, +package com.bumptech.glide.load.resource.drawable;, +, +import android.graphics.drawable.Drawable;, +import com.bumptech.glide.Resource;, +, +public class DrawableResource extends Resource<Drawable> {, +    private final Drawable drawable;, +    private final Resource wrapped;, +, +    public DrawableResource(Drawable drawable, Resource wrapped) {, +        this.drawable = drawable;, +        this.wrapped = wrapped;, +    }, +, +    @Override, +    public Drawable get() {, +        return drawable;, +    }, +, +    @Override, +    public int getSize() {, +        return wrapped.getSize();, +    }, +, +    @Override, +    protected void recycleInternal() {, +        wrapped.recycle();, +    }, +}, +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableResource.java, +package com.bumptech.glide.load.resource.drawable;, +, +import android.graphics.drawable.Drawable;, +import com.bumptech.glide.Resource;, +, +public class DrawableResource extends Resource<Drawable> {, +    private final Drawable drawable;, +    private final Resource wrapped;, +, +    public DrawableResource(Drawable drawable, Resource wrapped) {, +        this.drawable = drawable;, +        this.wrapped = wrapped;, +    }, +, +    @Override, +    public Drawable get() {, +        return drawable;, +    }, +, +    @Override, +    public int getSize() {, +        return wrapped.getSize();, +    }, +, +    @Override, +    protected void recycleInternal() {, +        wrapped.recycle();, +    }, +}, +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/GifBitmap.java, +package com.bumptech.glide.load.resource.drawable;, +, +import android.content.res.Resources;, +import android.graphics.Bitmap;, +import android.graphics.drawable.BitmapDrawable;, +import android.graphics.drawable.Drawable;, +import com.bumptech.glide.Resource;, +import com.bumptech.glide.load.resource.gif.GifDrawable;, +, +public class GifBitmap {, +    private Resource<GifDrawable> gifResource;, +    private Resource<Bitmap> bitmapResource;, +    private Resources resources;, +, +    public GifBitmap(Resources resources, Resource<Bitmap> bitmapResource) {, +        this.resources = resources;, +        this.bitmapResource = bitmapResource;, +    }, +, +    public GifBitmap(Resource<GifDrawable> gifResource) {, +        this.gifResource = gifResource;, +    }, +, +    public int getSize() {, +        return 0;, +    }, +, +    public Resource<Bitmap> getBitmapResource() {, +        return bitmapResource;, +    }, +, +    public Resource<GifDrawable> getGifResource() {, +        return gifResource;, +    }, +, +    public Drawable getDrawable() {, +        if (gifResource != null) {, +            return gifResource.get();, +        } else {]
[+++ b/.idea/codeStyleSettings.xml, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +Proguard, +--------, +Depending on your proguard config and usage, you may need to include the following lines in your proguard.cfg:, +```, +-keep public class * implements com.bumptech.glide.module.GlideModule, +-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {, +    **[] $VALUES;, +    public *;, +}, +```, +, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +Proguard, +--------, +Depending on your proguard config and usage, you may need to include the following lines in your proguard.cfg:, +```, +-keep public class * implements com.bumptech.glide.module.GlideModule, +-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {, +    **[] $VALUES;, +    public *;, +}, +```, +, +++ b/build.gradle, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +Proguard, +--------, +Depending on your proguard config and usage, you may need to include the following lines in your proguard.cfg:, +```, +-keep public class * implements com.bumptech.glide.module.GlideModule, +-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {, +    **[] $VALUES;, +    public *;, +}, +```, +, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +Proguard, +--------, +Depending on your proguard config and usage, you may need to include the following lines in your proguard.cfg:, +```, +-keep public class * implements com.bumptech.glide.module.GlideModule, +-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {, +    **[] $VALUES;, +    public *;, +}, +```, +, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +Proguard, +--------, +Depending on your proguard config and usage, you may need to include the following lines in your proguard.cfg:, +```, +-keep public class * implements com.bumptech.glide.module.GlideModule, +-keep public enum com.bumptech.glide.load.resource.bitmap.ImageHeaderParser$** {, +    **[] $VALUES;, +    public *;, +}, +```, +, +++ b/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="120" />, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*RequestBuilder.java|ChildLoadProvider.java" checks="NoClone" />, +++ b/glide-parent.iml, +  <component name="NewModuleRootManager" inherit-compiler-output="false">, +++ b/.idea/codeStyleSettings.xml, +++ b/.travis.yml, +  - build-tools-19.1.0, +++ b/README.md, +Proguard]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/CenterCrop.java, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifBitmapProvider.java]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +import com.bumptech.glide.load.model.ModelLoader.LoadData;, +  private volatile LoadData<?> loadData;, +    loadData = null;, +      loadData =, +              helper.getOptions());, +      if (loadData != null && helper.hasLoadPath(loadData.fetcher.getDataClass())) {, +        loadData.fetcher.loadData(helper.getPriority(), this);, +    LoadData<?> local = loadData;, +      local.fetcher.cancel();, +    cb.onDataFetcherReady(sourceKey, data, loadData.fetcher, DataSource.DATA_DISK_CACHE, sourceKey);, +    cb.onDataFetcherFailed(sourceKey, e, loadData.fetcher, DataSource.DATA_DISK_CACHE);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +import com.bumptech.glide.load.model.ModelLoader.LoadData;, +  private volatile LoadData<?> loadData;, +    loadData = null;, +      loadData =, +              helper.getOptions());, +      if (loadData != null && helper.hasLoadPath(loadData.fetcher.getDataClass())) {, +        loadData.fetcher.loadData(helper.getPriority(), this);, +    LoadData<?> local = loadData;, +      local.fetcher.cancel();, +    cb.onDataFetcherReady(sourceKey, data, loadData.fetcher, DataSource.DATA_DISK_CACHE, sourceKey);, +    cb.onDataFetcherFailed(sourceKey, e, loadData.fetcher, DataSource.DATA_DISK_CACHE);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java, +import com.bumptech.glide.load.model.ModelLoader.LoadData;, +  private volatile LoadData<?> loadData;, +    loadData = null;, +      loadData =, +              helper.getOptions());, +      if (loadData != null && helper.hasLoadPath(loadData.fetcher.getDataClass())) {, +        loadData.fetcher.loadData(helper.getPriority(), this);, +    LoadData<?> local = loadData;, +      local.fetcher.cancel();, +    cb.onDataFetcherReady(sourceKey, data, loadData.fetcher, DataSource.RESOURCE_DISK_CACHE,, +        currentKey);, +    cb.onDataFetcherFailed(currentKey, e, loadData.fetcher, DataSource.RESOURCE_DISK_CACHE);]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java, +    private final ResourceTranscoder transcoder;, +    private final Encoder sourceEncoder;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java, +    private final ResourceTranscoder transcoder;, +    private final Encoder sourceEncoder;, +++ b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java, +    private static boolean isLocalUri(String scheme) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java, +    private final ResourceTranscoder transcoder;, +    private final Encoder sourceEncoder;, +++ b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java, +    private static boolean isLocalUri(String scheme) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +    private static boolean shouldUsePool(RecyclableBufferedInputStream bis) {, +    private static Bitmap.Config getConfig(RecyclableBufferedInputStream bis, DecodeFormat format) {, +    private static Bitmap decodeStream(RecyclableBufferedInputStream bis, BitmapFactory.Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java, +    private final ResourceTranscoder transcoder;, +    private final Encoder sourceEncoder;, +++ b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java, +    private static boolean isLocalUri(String scheme) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +    private static boolean shouldUsePool(RecyclableBufferedInputStream bis) {, +    private static Bitmap.Config getConfig(RecyclableBufferedInputStream bis, DecodeFormat format) {, +    private static Bitmap decodeStream(RecyclableBufferedInputStream bis, BitmapFactory.Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java, +    private static int parseExifSegment(RandomAccessReader segmentData) {, +    private static boolean handles(int imageMagicNumber) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java, +    private final ResourceTranscoder transcoder;, +    private final Encoder sourceEncoder;, +++ b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java, +    private static boolean isLocalUri(String scheme) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +    private static boolean shouldUsePool(RecyclableBufferedInputStream bis) {, +    private static Bitmap.Config getConfig(RecyclableBufferedInputStream bis, DecodeFormat format) {, +    private static Bitmap decodeStream(RecyclableBufferedInputStream bis, BitmapFactory.Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java, +    private static int parseExifSegment(RandomAccessReader segmentData) {, +    private static boolean handles(int imageMagicNumber) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java, +        private static final long serialVersionUID = -4338378848813561757L;, +, +    private static IOException streamClosed() throws IOException {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java, +    private final ResourceTranscoder transcoder;, +    private final Encoder sourceEncoder;, +++ b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java, +    private static boolean isLocalUri(String scheme) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +    private static boolean shouldUsePool(RecyclableBufferedInputStream bis) {, +    private static Bitmap.Config getConfig(RecyclableBufferedInputStream bis, DecodeFormat format) {, +    private static Bitmap decodeStream(RecyclableBufferedInputStream bis, BitmapFactory.Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java, +    private static int parseExifSegment(RandomAccessReader segmentData) {, +    private static boolean handles(int imageMagicNumber) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java, +        private static final long serialVersionUID = -4338378848813561757L;, +, +    private static IOException streamClosed() throws IOException {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java, +    private static String getGifId(byte[] data) {, +    private static byte[] inputStreamToBytes(InputStream is) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java, +    private final ResourceTranscoder transcoder;, +    private final Encoder sourceEncoder;, +++ b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java, +    private static boolean isLocalUri(String scheme) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +    private static boolean shouldUsePool(RecyclableBufferedInputStream bis) {, +    private static Bitmap.Config getConfig(RecyclableBufferedInputStream bis, DecodeFormat format) {, +    private static Bitmap decodeStream(RecyclableBufferedInputStream bis, BitmapFactory.Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java, +    private static int parseExifSegment(RandomAccessReader segmentData) {, +    private static boolean handles(int imageMagicNumber) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java, +        private static final long serialVersionUID = -4338378848813561757L;, +, +    private static IOException streamClosed() throws IOException {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifResourceDecoder.java, +    private static String getGifId(byte[] data) {, +    private static byte[] inputStreamToBytes(InputStream is) {, +++ b/library/src/main/java/com/bumptech/glide/provider/FixedLoadProvider.java, +    private final ResourceTranscoder<Z, R> transcoder;, +, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineKey.java, +    private final ResourceTranscoder transcoder;, +    private final Encoder sourceEncoder;, +++ b/library/src/main/java/com/bumptech/glide/load/model/UriLoader.java, +    private static boolean isLocalUri(String scheme) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/Downsampler.java, +    private static boolean shouldUsePool(RecyclableBufferedInputStream bis) {, +    private static Bitmap.Config getConfig(RecyclableBufferedInputStream bis, DecodeFormat format) {, +    private static Bitmap decodeStream(RecyclableBufferedInputStream bis, BitmapFactory.Options options) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/ImageHeaderParser.java, +    private static int parseExifSegment(RandomAccessReader segmentData) {, +    private static boolean handles(int imageMagicNumber) {, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/RecyclableBufferedInputStream.java]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java]
[+++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/integration/integration.iml, +<module external.linked.project.id=":integration" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/integration/integration.iml, +<module external.linked.project.id=":integration" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/integration/okhttp/okhttp.iml, +<module external.linked.project.id=":integration:okhttp" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/integration/integration.iml, +<module external.linked.project.id=":integration" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/integration/okhttp/okhttp.iml, +<module external.linked.project.id=":integration:okhttp" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/integration/volley/volley.iml, +<module external.linked.project.id=":integration:volley" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/integration/integration.iml, +<module external.linked.project.id=":integration" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/integration/okhttp/okhttp.iml, +<module external.linked.project.id=":integration:okhttp" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/integration/volley/volley.iml, +<module external.linked.project.id=":integration:volley" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/library/library.iml, +<module external.linked.project.id=":library" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/integration/integration.iml, +<module external.linked.project.id=":integration" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/integration/okhttp/okhttp.iml, +<module external.linked.project.id=":integration:okhttp" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/integration/volley/volley.iml, +<module external.linked.project.id=":integration:volley" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/library/library.iml, +<module external.linked.project.id=":library" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import static com.bumptech.glide.request.RequestOptions.placeholderOf;, +import static org.junit.Assert.assertNotNull;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.anyObject;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Matchers.notNull;, +import static org.mockito.Mockito.doAnswer;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, +, +, +++ b/glide-parent.iml, +<module external.linked.project.id="glide-parent" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$" external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/glide/glide.iml, +<module external.linked.project.id=":glide" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/integration/integration.iml, +<module external.linked.project.id=":integration" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/integration/okhttp/okhttp.iml, +<module external.linked.project.id=":integration:okhttp" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/integration/volley/volley.iml, +<module external.linked.project.id=":integration:volley" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/../.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/library/library.iml, +<module external.linked.project.id=":library" external.linked.project.path="$MODULE_DIR$" external.root.project.path="$MODULE_DIR$/.." external.system.id="GRADLE" type="JAVA_MODULE" version="4">, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import static com.bumptech.glide.request.RequestOptions.placeholderOf;, +import static org.junit.Assert.assertNotNull;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.anyObject;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Matchers.notNull;, +import static org.mockito.Mockito.doAnswer;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.times;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, +, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java, +import static com.google.common.truth.Truth.assertThat;]
[+++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrGlideExtension.java, +    return requestOptions.centerCrop();]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java, +                try {, +                } finally {, +                    editor.abortUnlessCommitted();, +                }, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapper.java, +                try {, +                } finally {, +                    editor.abortUnlessCommitted();, +                }, +++ b/library/src/test/java/com/bumptech/glide/load/engine/cache/DiskLruCacheWrapperTest.java, +        File dir = Robolectric.application.getCacheDir();, +    @Test, +    public void testEditIsAbortedIfWriterThrows() throws FileNotFoundException {, +        try {, +            cache.put(key, new DiskCache.Writer() {, +                @Override, +                public boolean write(File file) {, +                    throw new RuntimeException("test");, +                }, +            });, +        } catch (RuntimeException e) {, +            // Expected., +        }, +, +        cache.put(key, new DiskCache.Writer() {, +            @Override, +            public boolean write(File file) {, +                try {, +                    new FileOutputStream(file).write(data);, +                } catch (IOException e) {, +                    e.printStackTrace();, +                }, +                return true ;, +            }, +        });, +, +        byte[] received = isToBytes(new FileInputStream(cache.get(key)), data.length);, +, +        assertTrue(Arrays.equals(data, received));, +    }, +]
[+++ /dev/null, +++ /dev/null, +++ b/library/src/com/bumptech/photos/resize/ImageManager.java, +import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapReferenceCounter;, +    private final ConcurrentBitmapReferenceCounter bitmapTracker;, +            bitmapTracker = new ConcurrentBitmapReferenceCounter(bitmapPool, options.maxPerSize);, +++ /dev/null, +++ b/library/src/com/bumptech/photos/resize/ImageManager.java, +import com.bumptech.photos.resize.bitmap_recycle.ConcurrentBitmapReferenceCounter;, +    private final ConcurrentBitmapReferenceCounter bitmapTracker;, +            bitmapTracker = new ConcurrentBitmapReferenceCounter(bitmapPool, options.maxPerSize);, +++ b/library/src/com/bumptech/photos/resize/bitmap_recycle/ConcurrentBitmapReferenceCounter.java, +package com.bumptech.photos.resize.bitmap_recycle;, +, +import android.graphics.Bitmap;, +import com.bumptech.photos.resize.bitmap_recycle.BitmapPool;, +, +import java.util.Map;, +import java.util.concurrent.ConcurrentHashMap;, +import java.util.concurrent.ConcurrentLinkedQueue;, +, +/**, + * Created with IntelliJ IDEA., + * User: sam, + * Date: 6/4/13, + * Time: 9:54 AM, + * To change this template use File | Settings | File Templates., + */, +public class ConcurrentBitmapReferenceCounter {, +, +    private static class InnerTrackerPool {, +        private ConcurrentLinkedQueue<InnerTracker> pool = new ConcurrentLinkedQueue<InnerTracker>();, +, +        public InnerTracker get() {, +            InnerTracker result = pool.poll();, +            if (result == null) {, +                result = new InnerTracker();, +            }, +, +            return result;, +        }, +, +        public void release(InnerTracker innerTracker) {, +            pool.offer(innerTracker);, +        }, +    }, +, +    private static class InnerTracker {, +        private volatile int refs = 0;, +        private volatile boolean pending = false;, +, +        public void acquire() {, +            pending = false;, +            synchronized (this) {, +                refs++;, +            }, +        }, +, +        public boolean release() {, +            synchronized (this) {, +                refs--;, +            }, +, +            return refs == 0 && !pending;, +        }, +, +        public boolean reject() {, +            pending = false;, +            return refs == 0;, +        }, +, +        public void markPending() {, +            pending = true;, +        }, +    }, +, +    private final Map<Integer, InnerTracker> counter;, +    private final BitmapPool target;, +    private final InnerTrackerPool pool = new InnerTrackerPool();, +, +    public ConcurrentBitmapReferenceCounter(BitmapPool target, int bitmapsPerSize) {, +        this.target = target;, +        counter = new ConcurrentHashMap<Integer, InnerTracker>(bitmapsPerSize * 6, 0.75f, 4);, +    }, +, +    public void initBitmap(Bitmap toInit) {, +        counter.put(toInit.hashCode(), pool.get());, +    }, +, +    public void acquireBitmap(Bitmap bitmap) {, +        get(bitmap).acquire();, +    }, +, +    public void releaseBitmap(Bitmap bitmap) {, +        final InnerTracker tracker = get(bitmap);, +        if (tracker.release()) {, +            recycle(tracker, bitmap);, +        }, +    }, +]
[+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java]
[+++ b/annotation/gradle.properties, +GROUP=com.github.bumptech.glide.annotation]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, +        requestBuilderGenerator.generate(generatedCodePackageName, indexedClassNames.extensions);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, +        requestBuilderGenerator.generate(generatedCodePackageName, indexedClassNames.extensions);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/FieldUniqueIdGenerator.java, +package com.bumptech.glide.annotation.compiler;, +, +/**, + * Generates unique field ids for classes generated by Glide's annotation processor., + */, +final class FieldUniqueIdGenerator {, +  private static int nextStaticFieldUniqueId;, +, +  private FieldUniqueIdGenerator() {, +    // Utility class., +  }, +, +  static int next() {, +    return nextStaticFieldUniqueId++;, +  }, +}, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, +        requestBuilderGenerator.generate(generatedCodePackageName, indexedClassNames.extensions);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/FieldUniqueIdGenerator.java, +package com.bumptech.glide.annotation.compiler;, +, +/**, + * Generates unique field ids for classes generated by Glide's annotation processor., + */, +final class FieldUniqueIdGenerator {, +  private static int nextStaticFieldUniqueId;, +, +  private FieldUniqueIdGenerator() {, +    // Utility class., +  }, +, +  static int next() {, +    return nextStaticFieldUniqueId++;, +  }, +}, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +    if (!isBaseRequestOptions(returnType)) {, +      throw new IllegalArgumentException("@GlideOption methods should return a", +          + " BaseRequestOptions<?> object, but " + getQualifiedMethodName(executableElement), +          + " returns " + returnType + ". If you're using old style @GlideOption methods, your", +          + " method may have a void return type, but doing so is deprecated and support will be", +          + " removed in a future version");, +          + "BaseRequestOptions<?> object as their first parameter, but ", +    if (!isBaseRequestOptions(expected)) {, +          + " BaseRequestOptions<?> object as their first parameter, but the first parameter in ", +  private static boolean isBaseRequestOptions(TypeMirror typeMirror) {, +    return typeMirror.toString().equals("com.bumptech.glide.request.BaseRequestOptions<?>");, +    boolean isOverridingBaseRequestOptionsMethod = isMethodInBaseRequestOptions(element);, +    if (isOverridingBaseRequestOptionsMethod && overrideType == GlideOption.OVERRIDE_NONE) {, +          + " BaseRequestOptions. Add an 'override' value in the @GlideOption annotation", +    } else if (!isOverridingBaseRequestOptionsMethod && overrideType != GlideOption.OVERRIDE_NONE) {, +          + " BaseRequestOptions, but no such method was found. Offending method: ", +  private boolean isMethodInBaseRequestOptions(ExecutableElement toFind) {, +            .getTypeElement(RequestOptionsGenerator.BASE_REQUEST_OPTIONS_QUALIFIED_NAME);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/AppModuleProcessor.java, +        requestBuilderGenerator.generate(generatedCodePackageName, indexedClassNames.extensions);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/FieldUniqueIdGenerator.java, +package com.bumptech.glide.annotation.compiler;, +, +/**, + * Generates unique field ids for classes generated by Glide's annotation processor., + */, +final class FieldUniqueIdGenerator {, +  private static int nextStaticFieldUniqueId;, +, +  private FieldUniqueIdGenerator() {, +    // Utility class., +  }, +, +  static int next() {, +    return nextStaticFieldUniqueId++;, +  }, +}, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +    if (!isBaseRequestOptions(returnType)) {, +      throw new IllegalArgumentException("@GlideOption methods should return a", +          + " BaseRequestOptions<?> object, but " + getQualifiedMethodName(executableElement), +          + " returns " + returnType + ". If you're using old style @GlideOption methods, your", +          + " method may have a void return type, but doing so is deprecated and support will be", +          + " removed in a future version");, +          + "BaseRequestOptions<?> object as their first parameter, but ", +    if (!isBaseRequestOptions(expected)) {, +          + " BaseRequestOptions<?> object as their first parameter, but the first parameter in ", +  private static boolean isBaseRequestOptions(TypeMirror typeMirror) {, +    return typeMirror.toString().equals("com.bumptech.glide.request.BaseRequestOptions<?>");, +    boolean isOverridingBaseRequestOptionsMethod = isMethodInBaseRequestOptions(element);, +    if (isOverridingBaseRequestOptionsMethod && overrideType == GlideOption.OVERRIDE_NONE) {, +          + " BaseRequestOptions. Add an 'override' value in the @GlideOption annotation", +    } else if (!isOverridingBaseRequestOptionsMethod && overrideType != GlideOption.OVERRIDE_NONE) {, +          + " BaseRequestOptions, but no such method was found. Offending method: ", +  private boolean isMethodInBaseRequestOptions(ExecutableElement toFind) {, +            .getTypeElement(RequestOptionsGenerator.BASE_REQUEST_OPTIONS_QUALIFIED_NAME);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestBuilderGenerator.java, +  private final RequestOptionsOverrideGenerator requestOptionsOverrideGenerator;, +  private ClassName generatedRequestBuilderClassName;]
[+++ b/checkstyle.xml, +++ b/checkstyle.xml, +++ b/samples/giphy/.gitignore, +/build, +++ b/checkstyle.xml, +++ b/samples/giphy/.gitignore, +/build, +++ b/samples/giphy/build.gradle, +apply plugin: 'com.android.application', +, +android {, +    compileSdkVersion 19, +    buildToolsVersion "19.1.0", +, +    defaultConfig {, +        applicationId "com.bumptech.glide.giphy", +        minSdkVersion 14, +        targetSdkVersion 19, +        versionCode 1, +        versionName "1.0", +    }, +    buildTypes {, +        release {, +            runProguard false, +            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro', +        }, +    }, +}, +, +dependencies {, +    compile project(':library'), +    compile 'com.google.code.gson:gson:2.2.4', +}, +++ b/checkstyle.xml, +++ b/samples/giphy/.gitignore, +/build, +++ b/samples/giphy/build.gradle, +apply plugin: 'com.android.application', +, +android {, +    compileSdkVersion 19, +    buildToolsVersion "19.1.0", +, +    defaultConfig {, +        applicationId "com.bumptech.glide.giphy", +        minSdkVersion 14, +        targetSdkVersion 19, +        versionCode 1, +        versionName "1.0", +    }, +    buildTypes {, +        release {, +            runProguard false, +            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro', +        }, +    }, +}, +, +dependencies {, +    compile project(':library'), +    compile 'com.google.code.gson:gson:2.2.4', +}, +++ b/samples/giphy/proguard-rules.pro, +# Add project specific ProGuard rules here., +# By default, the flags in this file are appended to flags specified, +# in /Applications/Android Studio.app/sdk/tools/proguard/proguard-android.txt, +# You can edit the include path and order by changing the proguardFiles, +# directive in build.gradle., +#, +# For more details, see, +#   http://developer.android.com/guide/developing/tools/proguard.html, +, +# Add any project specific keep options here:, +, +# If your project uses WebView with JS, uncomment the following, +# and specify the fully qualified class name to the JavaScript interface, +# class:, +#-keepclassmembers class fqcn.of.javascript.interface.for.webview {, +#   public *;, +#}, +++ b/checkstyle.xml, +++ b/samples/giphy/.gitignore, +/build, +++ b/samples/giphy/build.gradle, +apply plugin: 'com.android.application', +, +android {, +    compileSdkVersion 19, +    buildToolsVersion "19.1.0", +, +    defaultConfig {, +        applicationId "com.bumptech.glide.giphy", +        minSdkVersion 14, +        targetSdkVersion 19, +        versionCode 1, +        versionName "1.0", +    }, +    buildTypes {, +        release {, +            runProguard false]
[+++ b/gradle.properties, +OK_HTTP_VERSION=3.0.0-RC1, +++ b/gradle.properties, +OK_HTTP_VERSION=3.0.0-RC1, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +    boolean isUserAgentSet = false;, +      public void onFailure(Request request, IOException e) {, +      public void onResponse(Response response) throws IOException {, +++ b/gradle.properties, +OK_HTTP_VERSION=3.0.0-RC1, +++ b/integration/okhttp3/src/main/java/com/bumptech/glide/integration/okhttp3/OkHttpStreamFetcher.java, +    boolean isUserAgentSet = false;, +      public void onFailure(Request request, IOException e) {, +      public void onResponse(Response response) throws IOException {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java, +      final Thread result = new Thread(runnable, "glide-" + name + "-thread-" + threadNum) {]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +  void removeFromManagers(Target<?> target) {, +    synchronized (managers) {, +        if (requestManager.untrack(target)) {, +    throw new IllegalStateException("Failed to remove target from managers");, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +  void removeFromManagers(Target<?> target) {, +    synchronized (managers) {, +        if (requestManager.untrack(target)) {, +    throw new IllegalStateException("Failed to remove target from managers");, +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +  public <Model, TResource, Transcode> List<Class<?>> getRegisteredResourceClasses(, +      Class<Model> modelClass, Class<TResource> resourceClass, Class<Transcode> transcodeClass) {, +          List<Class<Transcode>> registeredTranscodeClasses = transcoderRegistry, +              .getTranscodeClasses(registeredResourceClass, transcodeClass);, +          if (!registeredTranscodeClasses.isEmpty() && !result.contains(registeredResourceClass)) {, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +  void removeFromManagers(Target<?> target) {, +    synchronized (managers) {, +        if (requestManager.untrack(target)) {, +    throw new IllegalStateException("Failed to remove target from managers");, +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +  public <Model, TResource, Transcode> List<Class<?>> getRegisteredResourceClasses(, +      Class<Model> modelClass, Class<TResource> resourceClass, Class<Transcode> transcodeClass) {, +          List<Class<Transcode>> registeredTranscodeClasses = transcoderRegistry, +              .getTranscodeClasses(registeredResourceClass, transcodeClass);, +          if (!registeredTranscodeClasses.isEmpty() && !result.contains(registeredResourceClass)) {, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +import com.bumptech.glide.manager.TargetTracker;, +  private final TargetTracker targetTracker = new TargetTracker();, +  private final Runnable addSelfToLifecycle = new Runnable() {, +    @Override, +    public void run() {, +      lifecycle.addListener(RequestManager.this);, +    }, +  };, +  private final Handler mainHandler = new Handler(Looper.getMainLooper());, +  private final ConnectivityMonitor connectivityMonitor;, +    connectivityMonitor =, +      mainHandler.post(addSelfToLifecycle);, +    targetTracker.onStart();, +    targetTracker.onStop();, +    targetTracker.onDestroy();, +    for (Target<?> target : targetTracker.getAll()) {, +      clear(target);, +    }, +    targetTracker.clear();, +    lifecycle.removeListener(this);, +    lifecycle.removeListener(connectivityMonitor);, +    mainHandler.removeCallbacks(addSelfToLifecycle);, +    Glide.get(context).unregisterRequestManager(this);, +    untrackOrDelegate(target);, +  private void untrackOrDelegate(Target<?> target) {, +    boolean isOwnedByUs = untrack(target);, +      Glide.get(context).removeFromManagers(target);, +  boolean untrack(Target<?> target) {, +    Request request = target.getRequest();, +    if (requestTracker.clearRemoveAndRecycle(request)) {, +      targetTracker.untrack(target);, +      target.setRequest(null);, +      return true;, +    } else {, +      return true;, +    }, +    targetTracker.track(target);, +  @Override, +  public String toString() {, +    return super.toString() + "{tracker=" + requestTracker + ", treeNode=" + treeNode + "}";, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +  void removeFromManagers(Target<?> target) {, +    synchronized (managers) {, +        if (requestManager.untrack(target)) {, +    throw new IllegalStateException("Failed to remove target from managers");, +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +  public <Model, TResource, Transcode> List<Class<?>> getRegisteredResourceClasses(, +      Class<Model> modelClass, Class<TResource> resourceClass, Class<Transcode> transcodeClass) {, +          List<Class<Transcode>> registeredTranscodeClasses = transcoderRegistry, +              .getTranscodeClasses(registeredResourceClass, transcodeClass);, +          if (!registeredTranscodeClasses.isEmpty() && !result.contains(registeredResourceClass)) {, +++ b/library/src/main/java/com/bumptech/glide/RequestManager.java, +import com.bumptech.glide.manager.TargetTracker;, +  private final TargetTracker targetTracker = new TargetTracker();, +  private final Runnable addSelfToLifecycle = new Runnable() {, +    @Override, +    public void run() {, +      lifecycle.addListener(RequestManager.this);, +    }, +  };, +  private final Handler mainHandler = new Handler(Looper.getMainLooper());, +  private final ConnectivityMonitor connectivityMonitor;, +    connectivityMonitor =, +      mainHandler.post(addSelfToLifecycle);, +    targetTracker.onStart();, +    targetTracker.onStop();, +    targetTracker.onDestroy();, +    for (Target<?> target : targetTracker.getAll()) {, +      clear(target);, +    }]
[+++ b/gradle.properties, +VERSION_NAME=4.3.0-SNAPSHOT, +VERSION_MINOR=3]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DiskCacheStrategy.java, +public abstract class DiskCacheStrategy {, +  public static final DiskCacheStrategy ALL = new DiskCacheStrategy() {, +, +    @Override, +    public boolean decodeCachedResource() {, +      return true;, +    }, +, +    @Override, +    public boolean decodeCachedData() {, +      return true;, +    }, +  };, +, +  public static final DiskCacheStrategy NONE = new DiskCacheStrategy() {, +, +    @Override, +    public boolean decodeCachedResource() {, +      return false;, +    }, +, +    @Override, +    public boolean decodeCachedData() {, +      return false;, +    }, +  };, +, +  public static final DiskCacheStrategy DATA = new DiskCacheStrategy() {, +, +    @Override, +    public boolean decodeCachedResource() {, +      return false;, +    }, +, +    @Override, +    public boolean decodeCachedData() {, +      return true;, +    }, +  };, +, +  public static final DiskCacheStrategy RESOURCE = new DiskCacheStrategy() {, +      return true;, +, +    @Override, +    public boolean decodeCachedResource() {, +      return true;, +    }, +, +    @Override, +    public boolean decodeCachedData() {, +      return false;, +    }, +  };, +, +  public static final DiskCacheStrategy AUTOMATIC = new DiskCacheStrategy() {, +    @Override, +    public boolean decodeCachedResource() {, +      return true;, +    @Override, +    public boolean decodeCachedData() {, +      return true;, +    }, +  };, +, +   *, +   * @param dataSource Indicates where the data was originally retrieved., +   *, +   * @param isFromAlternateCacheKey {@code true} if the resource we've decoded was loaded using an, +   *                                alternative, rather than the primary, cache key., +   * @param dataSource Indicates where the data used to decode the resource was originally, +   *                   retrieved., +   * @param encodeStrategy The {@link EncodeStrategy} the {@link, +   * com.bumptech.glide.load.ResourceEncoder} will use to encode the resource., +  public abstract boolean decodeCachedResource();, +  public abstract boolean decodeCachedData();]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +import com.squareup.javapoet.AnnotationSpec;, +import com.squareup.javapoet.TypeVariableName;, +import java.util.LinkedHashSet;, +import javax.lang.model.element.TypeParameterElement;, +import javax.lang.model.type.TypeVariable;, +  static MethodSpec.Builder overriding(ExecutableElement method) {, +    String methodName = method.getSimpleName().toString();, +, +    MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName), +        .addAnnotation(Override.class);, +, +    Set<Modifier> modifiers = method.getModifiers();, +    modifiers = new LinkedHashSet<>(modifiers);, +    modifiers.remove(Modifier.ABSTRACT);, +    Modifier defaultModifier = null;, +    // Modifier.DEFAULT doesn't exist until Java 8., +    try {, +      defaultModifier = Modifier.valueOf("DEFAULT");, +    } catch (IllegalArgumentException e) {, +      // Ignored., +    }, +    modifiers.remove(defaultModifier);, +, +    builder = builder.addModifiers(modifiers);, +, +    for (TypeParameterElement typeParameterElement : method.getTypeParameters()) {, +      TypeVariable var = (TypeVariable) typeParameterElement.asType();, +      builder = builder.addTypeVariable(TypeVariableName.get(var));, +    }, +, +    builder = builder.returns(TypeName.get(method.getReturnType())), +        .addParameters(getParameters(method)), +        .varargs(method.isVarArgs());, +, +    for (TypeMirror thrownType : method.getThrownTypes()) {, +      builder = builder.addException(TypeName.get(thrownType));, +    }, +, +    return builder;, +  }, +, +  static List<ParameterSpec> getParameters(ExecutableElement method) {, +    return getParameters(method.getParameters());, +  }, +, +  static List<ParameterSpec> getParameters(List<? extends VariableElement> parameters) {, +    List<ParameterSpec> result = new ArrayList<>();, +    for (VariableElement parameter : parameters) {, +      result.add(getParameter(parameter));, +    }, +    return result;, +  }, +, +  private static ParameterSpec getParameter(VariableElement method) {, +    TypeName type = TypeName.get(method.asType());, +    String name = method.getSimpleName().toString();, +    return ParameterSpec.builder(type, name), +        .addModifiers(method.getModifiers()), +        .addAnnotations(getAnnotations(method)), +        .build();, +  }, +, +  private static List<AnnotationSpec> getAnnotations(VariableElement element) {, +    List<AnnotationSpec> result = new ArrayList<>();, +    for (AnnotationMirror mirror : element.getAnnotationMirrors()) {, +      result.add(AnnotationSpec.get(mirror));, +    }, +    return result;, +  }, +, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +import com.squareup.javapoet.AnnotationSpec;, +import com.squareup.javapoet.TypeVariableName;, +import java.util.LinkedHashSet;, +import javax.lang.model.element.TypeParameterElement;, +import javax.lang.model.type.TypeVariable;, +  static MethodSpec.Builder overriding(ExecutableElement method) {, +    String methodName = method.getSimpleName().toString();, +, +    MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName), +        .addAnnotation(Override.class);, +, +    Set<Modifier> modifiers = method.getModifiers();, +    modifiers = new LinkedHashSet<>(modifiers);, +    modifiers.remove(Modifier.ABSTRACT);, +    Modifier defaultModifier = null;, +    // Modifier.DEFAULT doesn't exist until Java 8., +    try {, +      defaultModifier = Modifier.valueOf("DEFAULT");, +    } catch (IllegalArgumentException e) {, +      // Ignored., +    }, +    modifiers.remove(defaultModifier);, +, +    builder = builder.addModifiers(modifiers);, +, +    for (TypeParameterElement typeParameterElement : method.getTypeParameters()) {, +      TypeVariable var = (TypeVariable) typeParameterElement.asType();, +      builder = builder.addTypeVariable(TypeVariableName.get(var));]
[+++ b/integration/gifencoder/gradle.properties, +++ b/integration/gifencoder/gradle.properties, +++ b/integration/okhttp/gradle.properties, +++ b/integration/gifencoder/gradle.properties, +++ b/integration/okhttp/gradle.properties, +++ b/integration/okhttp3/gradle.properties, +++ b/integration/gifencoder/gradle.properties, +++ b/integration/okhttp/gradle.properties, +++ b/integration/okhttp3/gradle.properties, +++ b/integration/recyclerview/gradle.properties, +++ b/integration/gifencoder/gradle.properties, +++ b/integration/okhttp/gradle.properties, +++ b/integration/okhttp3/gradle.properties, +++ b/integration/recyclerview/gradle.properties, +++ b/integration/volley/gradle.properties, +++ b/integration/gifencoder/gradle.properties, +++ b/integration/okhttp/gradle.properties, +++ b/integration/okhttp3/gradle.properties, +++ b/integration/recyclerview/gradle.properties, +++ b/integration/volley/gradle.properties, +++ b/third_party/gif_decoder/gradle.properties]
[+++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +   * @see #centerInside()]
[+++ b/build.gradle, +        maven {, +            url "https://plugins.gradle.org/m2/", +        }, +        classpath "net.ltgt.gradle:gradle-errorprone-plugin:${ERROR_PRONE_VERSION}", +++ b/build.gradle, +        maven {, +            url "https://plugins.gradle.org/m2/", +        }, +        classpath "net.ltgt.gradle:gradle-errorprone-plugin:${ERROR_PRONE_VERSION}", +++ b/gradle.properties, +ERROR_PRONE_VERSION=0.0.13, +++ b/build.gradle, +        maven {, +            url "https://plugins.gradle.org/m2/", +        }, +        classpath "net.ltgt.gradle:gradle-errorprone-plugin:${ERROR_PRONE_VERSION}", +++ b/gradle.properties, +ERROR_PRONE_VERSION=0.0.13, +++ b/library/build.gradle, +if (!hasProperty('DISABLE_ERROR_PRONE')) {, +    apply plugin: "net.ltgt.errorprone", +}, +, +++ b/build.gradle, +        maven {, +            url "https://plugins.gradle.org/m2/", +        }, +        classpath "net.ltgt.gradle:gradle-errorprone-plugin:${ERROR_PRONE_VERSION}", +++ b/gradle.properties, +ERROR_PRONE_VERSION=0.0.13, +++ b/library/build.gradle, +if (!hasProperty('DISABLE_ERROR_PRONE')) {, +    apply plugin: "net.ltgt.errorprone", +}, +, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import java.lang.reflect.InvocationTargetException;, +      result = clazz.getDeclaredConstructor().newInstance();, +    } catch (InstantiationException e) {, +      throwIncorrectGlideModule(e);, +      throwIncorrectGlideModule(e);, +    } catch (NoSuchMethodException e) {, +      throwIncorrectGlideModule(e);, +    } catch (InvocationTargetException e) {, +      throwIncorrectGlideModule(e);, +  private static void throwIncorrectGlideModule(Exception e) {, +    throw new IllegalStateException("GeneratedAppGlideModuleImpl is implemented incorrectly.", +        + " If you've manually implemented this class, remove your implementation. The Annotation", +        + " processor will generate a correct implementation.", e);, +  }, +, +++ b/build.gradle, +        maven {, +            url "https://plugins.gradle.org/m2/", +        }, +        classpath "net.ltgt.gradle:gradle-errorprone-plugin:${ERROR_PRONE_VERSION}", +++ b/gradle.properties, +ERROR_PRONE_VERSION=0.0.13, +++ b/library/build.gradle, +if (!hasProperty('DISABLE_ERROR_PRONE')) {, +    apply plugin: "net.ltgt.errorprone", +}, +, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import java.lang.reflect.InvocationTargetException;, +      result = clazz.getDeclaredConstructor().newInstance();, +    } catch (InstantiationException e) {, +      throwIncorrectGlideModule(e);, +      throwIncorrectGlideModule(e);, +    } catch (NoSuchMethodException e) {, +      throwIncorrectGlideModule(e);, +    } catch (InvocationTargetException e) {, +      throwIncorrectGlideModule(e);, +  private static void throwIncorrectGlideModule(Exception e) {, +    throw new IllegalStateException("GeneratedAppGlideModuleImpl is implemented incorrectly.", +        + " If you've manually implemented this class, remove your implementation. The Annotation", +        + " processor will generate a correct implementation.", e);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +  // We're checking to see if we need to clone our options object because we want to make sure the, +  // original is never modified, so we need reference equality., +  @SuppressWarnings("ReferenceEquality"), +++ b/build.gradle, +        maven {, +            url "https://plugins.gradle.org/m2/", +        }, +        classpath "net.ltgt.gradle:gradle-errorprone-plugin:${ERROR_PRONE_VERSION}", +++ b/gradle.properties, +ERROR_PRONE_VERSION=0.0.13, +++ b/library/build.gradle, +if (!hasProperty('DISABLE_ERROR_PRONE')) {, +    apply plugin: "net.ltgt.errorprone", +}, +, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import java.lang.reflect.InvocationTargetException;, +      result = clazz.getDeclaredConstructor().newInstance();, +    } catch (InstantiationException e) {]
[+++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +import com.bumptech.glide.load.UnitTransformation;, +    private Transformation<ResourceType> singleTransformation = UnitTransformation.get();, +        if (singleTransformation == UnitTransformation.get()) {, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +import com.bumptech.glide.load.UnitTransformation;, +    private Transformation<ResourceType> singleTransformation = UnitTransformation.get();, +        if (singleTransformation == UnitTransformation.get()) {, +++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +import com.bumptech.glide.load.UnitTransformation;, +    private Transformation<ResourceType> singleTransformation = UnitTransformation.get();, +        if (singleTransformation == UnitTransformation.get()) {, +++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java, +++ b/library/src/main/java/com/bumptech/glide/load/UnitTransformation.java, +package com.bumptech.glide.load;, +, +import com.bumptech.glide.load.engine.Resource;, +, +/**, + * A noop Transformation that simply returns the given resource., + */, +public class UnitTransformation<T> implements Transformation<T> {, +    private static final UnitTransformation TRANSFORMATION = new UnitTransformation();, +, +    @SuppressWarnings("unchecked"), +    public static <T> UnitTransformation<T> get() {, +        return TRANSFORMATION;, +    }, +, +    @Override, +    public Resource<T> transform(Resource<T> resource, int outWidth, int outHeight) {, +        return resource;, +    }, +, +    @Override, +    public String getId() {, +        return "";, +    }, +}, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +import com.bumptech.glide.load.UnitTransformation;, +    private Transformation<ResourceType> singleTransformation = UnitTransformation.get();, +        if (singleTransformation == UnitTransformation.get()) {, +++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java, +++ b/library/src/main/java/com/bumptech/glide/load/UnitTransformation.java, +package com.bumptech.glide.load;, +, +import com.bumptech.glide.load.engine.Resource;, +, +/**, + * A noop Transformation that simply returns the given resource., + */, +public class UnitTransformation<T> implements Transformation<T> {, +    private static final UnitTransformation TRANSFORMATION = new UnitTransformation();, +, +    @SuppressWarnings("unchecked"), +    public static <T> UnitTransformation<T> get() {, +        return TRANSFORMATION;, +    }, +, +    @Override, +    public Resource<T> transform(Resource<T> resource, int outWidth, int outHeight) {, +        return resource;, +    }, +, +    @Override, +    public String getId() {, +        return "";, +    }, +}, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifData.java, +import com.bumptech.glide.load.UnitTransformation;, +        if (frameTransformation != null) {, +            return frameTransformation;, +        } else {, +            return UnitTransformation.get();, +        }, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +import com.bumptech.glide.load.UnitTransformation;, +    private Transformation<ResourceType> singleTransformation = UnitTransformation.get();, +        if (singleTransformation == UnitTransformation.get()) {, +++ b/library/src/main/java/com/bumptech/glide/load/Transformation.java, +++ b/library/src/main/java/com/bumptech/glide/load/UnitTransformation.java, +package com.bumptech.glide.load;, +, +import com.bumptech.glide.load.engine.Resource;, +, +/**, + * A noop Transformation that simply returns the given resource., + */, +public class UnitTransformation<T> implements Transformation<T> {, +    private static final UnitTransformation TRANSFORMATION = new UnitTransformation();, +, +    @SuppressWarnings("unchecked"), +    public static <T> UnitTransformation<T> get() {, +        return TRANSFORMATION;, +    }, +, +    @Override]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    Downsampler downsampler =, +        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);, +    registry = new Registry(), +        .register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    Downsampler downsampler =, +        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);, +    registry = new Registry(), +        .register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    Downsampler downsampler =, +        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);, +    registry = new Registry(), +        .register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    Downsampler downsampler =, +        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);, +    registry = new Registry(), +        .register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    Downsampler downsampler =, +        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);, +    registry = new Registry(), +        .register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java, +    return new ThumbFetcher(, +        uri, new ThumbnailStreamOpener(query, byteArrayPool, context.getContentResolver()));, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    Downsampler downsampler =, +        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);, +    registry = new Registry(), +        .register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java, +    return new ThumbFetcher(, +        uri, new ThumbnailStreamOpener(query, byteArrayPool, context.getContentResolver()));, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java, +import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;, +      ThumbnailQuery query, ArrayPool byteArrayPool, ContentResolver contentResolver) {, +    this(DEFAULT_SERVICE, query, byteArrayPool, contentResolver);, +    int orientation = ImageHeaderParser.UNKNOWN_ORIENTATION;, +      orientation = new ImageHeaderParser(is, byteArrayPool).getOrientation();, +    return orientation;, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    Downsampler downsampler =, +        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);, +    registry = new Registry(), +        .register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java, +    return new ThumbFetcher(, +        uri, new ThumbnailStreamOpener(query, byteArrayPool, context.getContentResolver()));, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbnailStreamOpener.java, +import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;, +      ThumbnailQuery query, ArrayPool byteArrayPool, ContentResolver contentResolver) {, +    this(DEFAULT_SERVICE, query, byteArrayPool, contentResolver);, +    int orientation = ImageHeaderParser.UNKNOWN_ORIENTATION;, +      orientation = new ImageHeaderParser(is, byteArrayPool).getOrientation();, +    return orientation;, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    Downsampler downsampler =, +        new Downsampler(resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, bitmapPool, arrayPool);, +    registry = new Registry(), +        .register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/load/data/mediastore/ThumbFetcher.java, +    return new ThumbFetcher(]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java, +import com.bumptech.glide.request.GlideContext;, +    public void setUp() throws IOException, GlideContext.NoResultEncoderAvailableException,, +            GlideContext.NoSourceEncoderAvailableException, GlideContext.NoDecoderAvailableException {, +        GlideContext glideContext = mock(GlideContext.class);, +        public Harness() throws IOException, GlideContext.NoDecoderAvailableException,, +                GlideContext.NoResultEncoderAvailableException, GlideContext.NoSourceEncoderAvailableException {, +                GlideContext.NoDecoderAvailableException, GlideContext.NoResultEncoderAvailableException,, +                GlideContext.NoSourceEncoderAvailableException {, +            when(glideContext.getDecoder(any(DataRewinder.class), eq(Object.class))).thenReturn(cacheDecoder);, +            when(glideContext.getResultEncoder(any(Resource.class))).thenReturn(resultEncoder);, +            when(glideContext.getSourceEncoder(anyObject())).thenReturn(sourceEncoder);, +            return new DecodeJob<Object, Object>(Object.class, key, width, height, dataFetcherSet, glideContext,, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java, +import com.bumptech.glide.request.GlideContext;, +    public void setUp() throws IOException, GlideContext.NoResultEncoderAvailableException,, +            GlideContext.NoSourceEncoderAvailableException, GlideContext.NoDecoderAvailableException {, +        GlideContext glideContext = mock(GlideContext.class);, +        public Harness() throws IOException, GlideContext.NoDecoderAvailableException,, +                GlideContext.NoResultEncoderAvailableException, GlideContext.NoSourceEncoderAvailableException {, +                GlideContext.NoDecoderAvailableException, GlideContext.NoResultEncoderAvailableException,, +                GlideContext.NoSourceEncoderAvailableException {, +            when(glideContext.getDecoder(any(DataRewinder.class), eq(Object.class))).thenReturn(cacheDecoder);, +            when(glideContext.getResultEncoder(any(Resource.class))).thenReturn(resultEncoder);, +            when(glideContext.getSourceEncoder(anyObject())).thenReturn(sourceEncoder);, +            return new DecodeJob<Object, Object>(Object.class, key, width, height, dataFetcherSet, glideContext,, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineResourceTest.java, +        engineResource = new EngineResource<Object>(resource, true /*isMemoryCacheable*/);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java, +import com.bumptech.glide.request.GlideContext;, +    public void setUp() throws IOException, GlideContext.NoResultEncoderAvailableException,, +            GlideContext.NoSourceEncoderAvailableException, GlideContext.NoDecoderAvailableException {, +        GlideContext glideContext = mock(GlideContext.class);, +        public Harness() throws IOException, GlideContext.NoDecoderAvailableException,, +                GlideContext.NoResultEncoderAvailableException, GlideContext.NoSourceEncoderAvailableException {, +                GlideContext.NoDecoderAvailableException, GlideContext.NoResultEncoderAvailableException,, +                GlideContext.NoSourceEncoderAvailableException {, +            when(glideContext.getDecoder(any(DataRewinder.class), eq(Object.class))).thenReturn(cacheDecoder);, +            when(glideContext.getResultEncoder(any(Resource.class))).thenReturn(resultEncoder);, +            when(glideContext.getSourceEncoder(anyObject())).thenReturn(sourceEncoder);, +            return new DecodeJob<Object, Object>(Object.class, key, width, height, dataFetcherSet, glideContext,, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineResourceTest.java, +        engineResource = new EngineResource<Object>(resource, true /*isMemoryCacheable*/);, +++ b/library/src/androidTest/java/com/bumptech/glide/request/SingleRequestTest.java, +        GlideContext glideContext = mock(GlideContext.class);, +            when(glideContext.getDataFetchers(eq(model), anyInt(), anyInt())).thenReturn(dataFetcherSet);, +            return SingleRequest.obtain(model, List.class, List.class, glideContext, requestOptions, 1f, priority,, +                eq(harness.dataFetcherSet), eq(harness.glideContext), any(Transformation.class),, +                any(DataFetcherSet.class), any(GlideContext.class), any(Transformation.class),, +                (DataFetcherSet.class), any(GlideContext.class), any(Transformation.class),, +                        (DataFetcherSet.class), any(GlideContext.class), any(Transformation.class),, +                eq(harness.overrideHeight), any(DataFetcherSet.class), any(GlideContext.class),, +                        (DataFetcherSet.class), any(GlideContext.class), any(Transformation.class),, +                any(DataFetcherSet.class), any(GlideContext.class), any(Transformation.class),, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/DecodeJobTest.java, +import com.bumptech.glide.request.GlideContext;, +    public void setUp() throws IOException, GlideContext.NoResultEncoderAvailableException,, +            GlideContext.NoSourceEncoderAvailableException, GlideContext.NoDecoderAvailableException {, +        GlideContext glideContext = mock(GlideContext.class);, +        public Harness() throws IOException, GlideContext.NoDecoderAvailableException,, +                GlideContext.NoResultEncoderAvailableException, GlideContext.NoSourceEncoderAvailableException {, +                GlideContext.NoDecoderAvailableException, GlideContext.NoResultEncoderAvailableException,, +                GlideContext.NoSourceEncoderAvailableException {, +            when(glideContext.getDecoder(any(DataRewinder.class), eq(Object.class))).thenReturn(cacheDecoder);, +            when(glideContext.getResultEncoder(any(Resource.class))).thenReturn(resultEncoder);, +            when(glideContext.getSourceEncoder(anyObject())).thenReturn(sourceEncoder);, +            return new DecodeJob<Object, Object>(Object.class, key, width, height, dataFetcherSet, glideContext,, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineResourceTest.java, +        engineResource = new EngineResource<Object>(resource, true /*isMemoryCacheable*/);, +++ b/library/src/androidTest/java/com/bumptech/glide/request/SingleRequestTest.java, +        GlideContext glideContext = mock(GlideContext.class);, +            when(glideContext.getDataFetchers(eq(model), anyInt(), anyInt())).thenReturn(dataFetcherSet);, +            return SingleRequest.obtain(model, List.class, List.class, glideContext, requestOptions, 1f, priority,, +                eq(harness.dataFetcherSet), eq(harness.glideContext), any(Transformation.class),, +                any(DataFetcherSet.class), any(GlideContext.class), any(Transformation.class),, +                (DataFetcherSet.class), any(GlideContext.class), any(Transformation.class),, +                        (DataFetcherSet.class), any(GlideContext.class), any(Transformation.class),, +                eq(harness.overrideHeight), any(DataFetcherSet.class), any(GlideContext.class),, +                        (DataFetcherSet.class), any(GlideContext.class), any(Transformation.class),, +                any(DataFetcherSet.class), any(GlideContext.class), any(Transformation.class),, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.content.ComponentCallbacks2;, +import android.content.res.Configuration;, +import com.bumptech.glide.request.GlideContext;, +@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH), +public class Glide implements ComponentCallbacks2 {, +    private final GlideContext glideContext;, +    @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH), +, +        glideContext = new GlideContext(context, loaderRegistry, encoderRegistry, decoderRegistry,, +                resourceEncoderRegistry, dataRewinderRegistry, transcoderRegistry, imageViewTargetFactory, engine,, +                this);, +    GlideContext getGlideContext() {, +        return glideContext;, +    @Override, +    public void onTrimMemory(int level) {, +        trimMemory(level);, +    }, +, +    @Override]
[+++ b/checkstyle.xml, +            <property name="illegalClasses" value="org\.mockito\.ArgumentMatchers.*" />]
[+++ b/samples/flickr/src/main/AndroidManifest.xml]
[+++ b/library/AndroidManifest.xml]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestManagerGenerator.java, +         .addModifiers(Modifier.PUBLIC)]
[+++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java, +import static com.bumptech.glide.request.RequestOptions.fitCenterTransform;, +import android.graphics.drawable.Drawable;, +  private final RequestBuilder<Drawable> requestBuilder;, +    requestBuilder = requestManager, +        .asDrawable(), +        .apply(fitCenterTransform(context));, +, +    requestBuilder, +        .clone(), +        .apply(signatureOf(signature)), +    return requestBuilder, +        .clone(), +        .apply(signatureOf(signature)), +++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java, +import static com.bumptech.glide.request.RequestOptions.fitCenterTransform;, +import android.graphics.drawable.Drawable;, +  private final RequestBuilder<Drawable> requestBuilder;, +    requestBuilder = requestManager, +        .asDrawable(), +        .apply(fitCenterTransform(context));, +, +    requestBuilder, +        .clone(), +        .apply(signatureOf(signature)), +    return requestBuilder, +        .clone(), +        .apply(signatureOf(signature)), +++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerViewFragment.java, +++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerAdapter.java, +import static com.bumptech.glide.request.RequestOptions.fitCenterTransform;, +import android.graphics.drawable.Drawable;, +  private final RequestBuilder<Drawable> requestBuilder;, +    requestBuilder = requestManager, +        .asDrawable(), +        .apply(fitCenterTransform(context));, +, +    requestBuilder, +        .clone(), +        .apply(signatureOf(signature)), +    return requestBuilder, +        .clone(), +        .apply(signatureOf(signature)), +++ b/samples/gallery/src/main/java/com/bumptech/glide/samples/gallery/RecyclerViewFragment.java, +++ b/samples/gallery/src/main/res/layout/recycler_item.xml, +   android:paddingLeft="5dp", +   android:paddingRight="5dp"]
[+++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +++ b/gradle.properties, +ANDROID_X_VERSION=1.0.0, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +++ b/gradle.properties, +ANDROID_X_VERSION=1.0.0, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +  private final boolean isLoggingRequestOriginsEnabled;, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +++ b/gradle.properties, +ANDROID_X_VERSION=1.0.0, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +  private final boolean isLoggingRequestOriginsEnabled;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/CallbackException.java, +  private static final long serialVersionUID = -7530898992688511851L;, +, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +++ b/gradle.properties, +ANDROID_X_VERSION=1.0.0, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +  private final boolean isLoggingRequestOriginsEnabled;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/CallbackException.java, +  private static final long serialVersionUID = -7530898992688511851L;, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  // We need to rethrow only CallbackException, but not other types of Throwables., +  @SuppressWarnings("PMD.AvoidRethrowingException"), +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +++ b/gradle.properties, +ANDROID_X_VERSION=1.0.0, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +  private final boolean isLoggingRequestOriginsEnabled;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/CallbackException.java, +  private static final long serialVersionUID = -7530898992688511851L;, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  // We need to rethrow only CallbackException, but not other types of Throwables., +  @SuppressWarnings("PMD.AvoidRethrowingException"), +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +  @SuppressWarnings("WeakerAccess"), +  @Synthetic, +  synchronized void callCallbackOnResourceReady(ResourceCallback cb) {, +  @SuppressWarnings("WeakerAccess"), +  @Synthetic, +  synchronized void callCallbackOnLoadFailed(ResourceCallback cb) {, +  // We have to post Runnables in a loop. Typically there will be very few callbacks. AccessorMethod, +  // seems to be a false positive, +  @SuppressWarnings(, +          {"WeakerAccess", "PMD.AvoidInstantiatingObjectsInLoops", "PMD.AccessorMethodGeneration"}), +  // We have to post Runnables in a loop. Typically there will be very few callbacks. Acessor method, +  // warning seems to be false positive., +  @SuppressWarnings(, +          {"WeakerAccess", "PMD.AvoidInstantiatingObjectsInLoops", "PMD.AccessorMethodGeneration"}), +      this(new ArrayList<ResourceCallbackAndExecutor>(2));, +++ b/annotation/compiler/test/src/test/resources/EmptyAppGlideModuleTest/GlideRequests.java, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +++ b/annotation/compiler/test/src/test/resources/GlideExtensionWithTypeTest/GlideRequests.java, +  public GlideRequests addDefaultRequestListener(RequestListener<Object> listener) {, +++ b/gradle.properties, +ANDROID_X_VERSION=1.0.0, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +  private final boolean isLoggingRequestOriginsEnabled;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/CallbackException.java, +  private static final long serialVersionUID = -7530898992688511851L;, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  // We need to rethrow only CallbackException, but not other types of Throwables., +  @SuppressWarnings("PMD.AvoidRethrowingException"), +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +  @SuppressWarnings("WeakerAccess"), +  @Synthetic, +  synchronized void callCallbackOnResourceReady(ResourceCallback cb) {, +  @SuppressWarnings("WeakerAccess"), +  @Synthetic, +  synchronized void callCallbackOnLoadFailed(ResourceCallback cb) {, +  // We have to post Runnables in a loop. Typically there will be very few callbacks. AccessorMethod, +  // seems to be a false positive, +  @SuppressWarnings(, +          {"WeakerAccess", "PMD.AvoidInstantiatingObjectsInLoops", "PMD.AccessorMethodGeneration"})]
[+++ b/samples/flickr/res/layout/grid_fragment.xml, +  android:horizontalSpacing="10dp", +  android:verticalSpacing="10dp", +  android:layout_gravity="center", +  android:stretchMode="columnWidth", +  android:layout_height="fill_parent" />]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java, +import static org.junit.Assert.assertNull;, +, +    @Test, +    public void testReturnsNullIfGifDecoderReturnsNullFrame() {, +        when(gifDecoder.getNextFrame()).thenReturn(null);, +, +        assertNull(resourceDecoder.decode(gifDecoder, 100, 100));, +    }, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java, +import static org.junit.Assert.assertNull;, +, +    @Test, +    public void testReturnsNullIfGifDecoderReturnsNullFrame() {, +        when(gifDecoder.getNextFrame()).thenReturn(null);, +, +        assertNull(resourceDecoder.decode(gifDecoder, 100, 100));, +    }, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java, +    public void testReturnsNullIfGifDecoderFailsToDecodeFirstFrame() {, +        when(gifHeader.getNumFrames()).thenReturn(1);, +        when(gifHeader.getStatus()).thenReturn(GifDecoder.STATUS_OK);, +        when(gifDecoder.getNextFrame()).thenReturn(null);, +, +        assertNull(decoder.decode(new ByteArrayInputStream(new byte[0]), 100, 100));, +    }, +, +    @Test, +    public void testReturnsGifDecoderToPoolWhenGifDecoderReturnsNullFirstFrame() {, +        when(gifHeader.getNumFrames()).thenReturn(1);, +        when(gifHeader.getStatus()).thenReturn(GifDecoder.STATUS_OK);, +        when(gifDecoder.getNextFrame()).thenReturn(null);, +, +        decoder.decode(new ByteArrayInputStream(new byte[0]), 100, 100);, +, +        verify(decoderPool).release(eq(gifDecoder));, +    }, +, +    @Test, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java, +import static org.junit.Assert.assertNull;, +, +    @Test, +    public void testReturnsNullIfGifDecoderReturnsNullFrame() {, +        when(gifDecoder.getNextFrame()).thenReturn(null);, +, +        assertNull(resourceDecoder.decode(gifDecoder, 100, 100));, +    }, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java, +    public void testReturnsNullIfGifDecoderFailsToDecodeFirstFrame() {, +        when(gifHeader.getNumFrames()).thenReturn(1);, +        when(gifHeader.getStatus()).thenReturn(GifDecoder.STATUS_OK);, +        when(gifDecoder.getNextFrame()).thenReturn(null);, +, +        assertNull(decoder.decode(new ByteArrayInputStream(new byte[0]), 100, 100));, +    }, +, +    @Test, +    public void testReturnsGifDecoderToPoolWhenGifDecoderReturnsNullFirstFrame() {, +        when(gifHeader.getNumFrames()).thenReturn(1);, +        when(gifHeader.getStatus()).thenReturn(GifDecoder.STATUS_OK);, +        when(gifDecoder.getNextFrame()).thenReturn(null);, +, +        decoder.decode(new ByteArrayInputStream(new byte[0]), 100, 100);, +, +        verify(decoderPool).release(eq(gifDecoder));, +    }, +, +    @Test, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoder.java, +        if (bitmap == null) {, +            return null;, +        } else {, +    }, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifFrameResourceDecoderTest.java, +import static org.junit.Assert.assertNull;, +, +    @Test, +    public void testReturnsNullIfGifDecoderReturnsNullFrame() {, +        when(gifDecoder.getNextFrame()).thenReturn(null);, +, +        assertNull(resourceDecoder.decode(gifDecoder, 100, 100));, +    }, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceDecoderTest.java, +    public void testReturnsNullIfGifDecoderFailsToDecodeFirstFrame() {, +        when(gifHeader.getNumFrames()).thenReturn(1);, +        when(gifHeader.getStatus()).thenReturn(GifDecoder.STATUS_OK);, +        when(gifDecoder.getNextFrame()).thenReturn(null);, +, +        assertNull(decoder.decode(new ByteArrayInputStream(new byte[0]), 100, 100));, +    }, +, +    @Test, +    public void testReturnsGifDecoderToPoolWhenGifDecoderReturnsNullFirstFrame() {, +        when(gifHeader.getNumFrames()).thenReturn(1);, +        when(gifHeader.getStatus()).thenReturn(GifDecoder.STATUS_OK);, +        when(gifDecoder.getNextFrame()).thenReturn(null);, +, +        decoder.decode(new ByteArrayInputStream(new byte[0]), 100, 100);, +]
[+++ b/third_party/gif_encoder/src/main/java/com/bumptech/glide/gifencoder/AnimatedGifEncoder.java, +    // The minimum % of an images pixels that must be transparent for us to set a transparent index, +    // automatically., +     * Adds next GIF frame to the specified position. The frame is not written immediately, but is, +     * actually deferred until the next frame is received so that timing data can be inserted., +     * Invoking <code>finish()</code> flushes all frames. If <code>setSize</code> was invoked, the, +     * size is used for all subsequent frames. Otherwise, the actual size of the image is used for, +     * each frame., +     *          Column number, in pixels, of the left edge of the image, with respect to the left, +     *          edge of the Logical Screen., +     *          Row number, in pixels, of the top edge of the image with respect to the top edge of, +     *          the Logical Screen., +            } else {, +        // Assume images with greater where more than n% of the pixels are transparent actually have, +        // transparency. See issue #214., +            Log.d(TAG, "got pixels for frame with " + transparentPercentage, +                + "% transparent pixels");]
[+++ b/gradle.properties, +PMD_VERSION=6.0.0, +++ b/gradle.properties, +PMD_VERSION=6.0.0, +++ b/library/build.gradle, +        classpath = files(), +            classpath += classPathForQuality(), +        classpath = files(), +        classpath += files("${project.buildDir}/intermediates/classes/debug/"), +        doFirst {, +            classpath += classPathForQuality(), +        }, +, +        //TODO enable this once new Gradle containing this flag is out, +        //see https://github.com/gradle/gradle/pull/3125#issuecomment-352442432, +        //incrementalAnalysis = true, +def classPathForQuality() {, +    return files(, +            android.bootClasspath,, +            project.configurations.compile,, +            project.android.libraryVariants.collect { it.javaCompile.classpath }, +    ), +}, +, +++ b/gradle.properties, +PMD_VERSION=6.0.0, +++ b/library/build.gradle, +        classpath = files(), +            classpath += classPathForQuality(), +        classpath = files(), +        classpath += files("${project.buildDir}/intermediates/classes/debug/"), +        doFirst {, +            classpath += classPathForQuality(), +        }, +, +        //TODO enable this once new Gradle containing this flag is out, +        //see https://github.com/gradle/gradle/pull/3125#issuecomment-352442432, +        //incrementalAnalysis = true, +def classPathForQuality() {, +    return files(, +            android.bootClasspath,, +            project.configurations.compile,, +            project.android.libraryVariants.collect { it.javaCompile.classpath }, +    ), +}, +, +++ b/library/pmd-ruleset.xml, +    <rule ref="category/java/errorprone.xml">, +        <!-- Not using beans. -->, +        <exclude name="BeanMembersShouldSerialize" />, +        <!-- wat -->, +        <exclude name="AvoidFieldNameMatchingTypeName" />, +        <!-- This is identifying trivial cases that are clearly correct. -->, +        <exclude name="DataflowAnomalyAnalysis" />, +        <!-- Used regularly for object pooling. -->, +        <exclude name="NullAssignment" />, +        <!-- This can make the code easier to read and avoid duplicated logic in some cases. -->, +        <exclude name="AssignmentInOperand" />, +        <!-- I don't think this is confusing. -->, +        <exclude name="AvoidFieldNameMatchingMethodName" />, +        <!-- There are enough cases where this makes sense (typically related to logic around the number of items in a collection) that a blanket ban doesn't seem like a good idea. -->, +        <exclude name="AvoidLiteralsInIfCondition" />, +        <!-- It's clear that this is bad, but we have a number of cases where it makes sense and a blanket ban is irritating. -->, +        <exclude name="AvoidCatchingThrowable" />, +    <rule ref="category/java/errorprone.xml/AvoidDuplicateLiterals">, +    <rule ref="category/java/codestyle.xml">, +      <!-- Abstract classes don't need to have Abstract in the name -->, +      <exclude name="AbstractNaming" />, +      <!-- Who cares? -->, +      <exclude name="AtLeastOneConstructor" />, +      <!-- Don't need to annotate package private methods. -->, +      <exclude name="DefaultPackage" />, +      <exclude name="CommentDefaultAccessModifier" />, +      <!-- Optionally implemented default empty methods are fine. -->, +      <!-- Why make generics less clear by using shorter names? -->, +      <exclude name="GenericsNaming" />, +      <!-- No need to enforce final if it's not necessary. -->, +      <exclude name="MethodArgumentCouldBeFinal" />, +      <exclude name="LocalVariableCouldBeFinal" />, +      <!-- This isn't always the easiest way to read a method. -->, +      <exclude name="OnlyOneReturn" />, +      <!-- Obfuscated code is best code? -->, +      <exclude name="LongVariable" />, +      <!-- This is not always true. -->, +      <exclude name="ShortClassName" />, +      <!-- A good idea but we have tons of violations. FIXME. -->, +      <exclude name="ShortMethodName" />, +      <exclude name="ShortVariable" />, +      <!-- We don't use in and out to mean modified or not modified by the method, it's useful to match framework methods. -->, +      <exclude name="AvoidPrefixingMethodParameters" />, +      <!-- No idea what this is supposed to accomplish. -->, +      <exclude name="AvoidFinalLocalVariable" />, +      <!-- These are often useful for clarity and explicitly suggested by Google's code style. -->, +      <exclude name="UselessParentheses" />, +      <!-- Theoretically this might be reasonable but the number of imports probably varies from class to class and this doesn't seem worth the overhead to maintain. -->, +      <exclude name="TooManyStaticImports" />, +      <!-- Lots of existing violations, not clear that the overhead is worthwhile though there are some cases where we definitely need to call super. FIXME. -->, +      <exclude name="CallSuperInConstructor" />, +      <!-- This is a reasonable idea, but in practice often the != null case is the expected case and it makes sense for it to come first. -->, +      <exclude name="ConfusingTernary" />]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/Issue2638Test.java, +package com.bumptech.glide;, +, +import android.content.Context;, +import android.content.res.Resources;, +import android.graphics.Bitmap;, +import android.graphics.Bitmap.CompressFormat;, +import android.graphics.BitmapFactory;, +import android.graphics.Color;, +import android.graphics.drawable.BitmapDrawable;, +import android.support.test.InstrumentationRegistry;, +import android.support.test.runner.AndroidJUnit4;, +import android.widget.AbsListView.LayoutParams;, +import android.widget.ImageView;, +import com.bumptech.glide.test.BitmapSubject;, +import com.bumptech.glide.test.ConcurrencyHelper;, +import com.bumptech.glide.test.ResourceIds;, +import com.bumptech.glide.test.TearDownGlide;, +import com.google.common.io.ByteStreams;, +import java.io.ByteArrayOutputStream;, +import java.io.IOException;, +import java.io.InputStream;, +import java.util.concurrent.ExecutionException;, +import org.junit.Before;, +import org.junit.Rule;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +, +@RunWith(AndroidJUnit4.class), +public class Issue2638Test {, +  @Rule public final TearDownGlide tearDownGlide = new TearDownGlide();, +  private final ConcurrencyHelper concurrency = new ConcurrencyHelper();, +  private Context context;, +, +  @Before, +  public void setUp() {, +    context = InstrumentationRegistry.getTargetContext();, +  }, +, +  @Test, +  public void intoImageView_withDifferentByteArrays_loadsDifferentImages(), +      throws IOException, ExecutionException, InterruptedException {, +    final ImageView imageView = new ImageView(context);, +    imageView.setLayoutParams(new LayoutParams(/*w=*/ 100, /*h=*/ 100));, +, +    final byte[] canonicalBytes = getCanonicalBytes();, +    final byte[] modifiedBytes = getModifiedBytes();, +, +    Glide.with(context), +        .load(canonicalBytes), +        .submit(), +        .get();, +, +    concurrency.loadOnMainThread(Glide.with(context).load(canonicalBytes), imageView);, +    Bitmap firstBitmap = ((BitmapDrawable) imageView.getDrawable()).getBitmap();, +, +    concurrency.loadOnMainThread(Glide.with(context).load(modifiedBytes), imageView);, +    Bitmap secondBitmap = ((BitmapDrawable) imageView.getDrawable()).getBitmap();, +, +    BitmapSubject.assertThat(firstBitmap).isNotSameAs(secondBitmap);, +  }, +, +  private byte[] getModifiedBytes() throws IOException {, +    byte[] canonicalBytes = getCanonicalBytes();, +    BitmapFactory.Options options = new BitmapFactory.Options();, +    options.inMutable = true;, +    Bitmap bitmap =, +        BitmapFactory.decodeByteArray(canonicalBytes, 0, canonicalBytes.length, options);, +    bitmap.setPixel(0, 0, Color.TRANSPARENT);, +    ByteArrayOutputStream os = new ByteArrayOutputStream();, +    bitmap.compress(CompressFormat.PNG, /*quality=*/ 100, os);, +    return os.toByteArray();, +  }, +, +  private byte[] getCanonicalBytes() throws IOException {, +    int resourceId = ResourceIds.raw.canonical;, +    Resources resources = context.getResources();, +    InputStream is = resources.openRawResource(resourceId);, +    return ByteStreams.toByteArray(is);, +  }, +}, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/Issue2638Test.java, +package com.bumptech.glide;, +, +import android.content.Context;, +import android.content.res.Resources;, +import android.graphics.Bitmap;, +import android.graphics.Bitmap.CompressFormat;, +import android.graphics.BitmapFactory;, +import android.graphics.Color;, +import android.graphics.drawable.BitmapDrawable;, +import android.support.test.InstrumentationRegistry;, +import android.support.test.runner.AndroidJUnit4;, +import android.widget.AbsListView.LayoutParams;, +import android.widget.ImageView;, +import com.bumptech.glide.test.BitmapSubject;, +import com.bumptech.glide.test.ConcurrencyHelper;, +import com.bumptech.glide.test.ResourceIds;, +import com.bumptech.glide.test.TearDownGlide;, +import com.google.common.io.ByteStreams;]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +    Preconditions.checkArgument(!isRecycled, "You cannot start a recycled Drawable. Ensure that", +        + "you clear any references to the Drawable when clearing the corresponding request.");, +    Preconditions.checkArgument(!isRecycled, "Cannot change the visibility of a recycled resource.", +        + " Ensure that you unset the Drawable from your View before changing the View's", +        + " visibility.");, +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +    Preconditions.checkArgument(!isRecycled, "You cannot start a recycled Drawable. Ensure that", +        + "you clear any references to the Drawable when clearing the corresponding request.");, +    Preconditions.checkArgument(!isRecycled, "Cannot change the visibility of a recycled resource.", +        + " Ensure that you unset the Drawable from your View before changing the View's", +        + " visibility.");, +++ b/library/src/main/java/com/bumptech/glide/request/target/Target.java, +   * before the load starts (when the model object is null)., +   * restart may cause a call here., +   *, +   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,, +   * Transition)} is no longer displayed before redrawing the container (usually a View) or, +   * changing its visibility., +   * } if the model object is null., +   *, +   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,, +   * Transition)} is no longer displayed before redrawing the container (usually a View) or, +   * changing its visibility., +   * <p>You must ensure that any current Drawable received in {@link #onResourceReady(Object,, +   * Transition)} is no longer displayed before redrawing the container (usually a View) or, +   * changing its visibility., +   *]
[+++ b/.gitignore, +**/out/**, +**/gen-external-apklibs/**, +++ b/.gitignore, +**/out/**, +**/gen-external-apklibs/**, +++ b/library/install_dependencies/install-android-deps.sh, +# Also using the android sdk tool, under Android 4.4.0 (API 14), install:, +#   SDK Platform, +mvn clean install -N && cd platforms && mvn clean install -N && cd android-14 && mvn clean install || {, +  echo 'Failed to install 4.0 SDK, install relevant packages in android SDK first';, +  exit 1;, +}, +cd ../.., +mvn clean install -N && cd extras && mvn clean install -N && cd compatibility-v4 && mvn clean install || {, +  echo 'Failed to install android-support-v4, install support library in android SDK first';, +  exit 1;, +}, +cd ../../.., +rm -rf maven-android-sdk-deployer, +++ b/.gitignore, +**/out/**, +**/gen-external-apklibs/**, +++ b/library/install_dependencies/install-android-deps.sh, +# Also using the android sdk tool, under Android 4.4.0 (API 14), install:, +#   SDK Platform, +mvn clean install -N && cd platforms && mvn clean install -N && cd android-14 && mvn clean install || {, +  echo 'Failed to install 4.0 SDK, install relevant packages in android SDK first';, +  exit 1;, +}, +cd ../.., +mvn clean install -N && cd extras && mvn clean install -N && cd compatibility-v4 && mvn clean install || {, +  echo 'Failed to install android-support-v4, install support library in android SDK first';, +  exit 1;, +}, +cd ../../.., +rm -rf maven-android-sdk-deployer, +++ b/library/pom.xml, +  <packaging>aar</packaging>, +    <dependency>, +      <groupId>com.bumptech.glide</groupId>, +      <artifactId>glide-gif-decoder</artifactId>, +      <version>3.3.0-SNAPSHOT</version>, +    </dependency>, +++ b/.gitignore, +**/out/**, +**/gen-external-apklibs/**, +++ b/library/install_dependencies/install-android-deps.sh, +# Also using the android sdk tool, under Android 4.4.0 (API 14), install:, +#   SDK Platform, +mvn clean install -N && cd platforms && mvn clean install -N && cd android-14 && mvn clean install || {, +  echo 'Failed to install 4.0 SDK, install relevant packages in android SDK first';, +  exit 1;, +}, +cd ../.., +mvn clean install -N && cd extras && mvn clean install -N && cd compatibility-v4 && mvn clean install || {, +  echo 'Failed to install android-support-v4, install support library in android SDK first';, +  exit 1;, +}, +cd ../../.., +rm -rf maven-android-sdk-deployer, +++ b/library/pom.xml, +  <packaging>aar</packaging>, +    <dependency>, +      <groupId>com.bumptech.glide</groupId>, +      <artifactId>glide-gif-decoder</artifactId>, +      <version>3.3.0-SNAPSHOT</version>, +    </dependency>, +++ b/pom.xml, +      <groupId>android.support</groupId>, +      <artifactId>compatibility-v4</artifactId>, +      <version>19.1.0</version>, +    </dependency>, +    <dependency>, +        <version>3.9.0-rc.2</version>, +++ b/.gitignore, +**/out/**, +**/gen-external-apklibs/**, +++ b/library/install_dependencies/install-android-deps.sh, +# Also using the android sdk tool, under Android 4.4.0 (API 14), install:, +#   SDK Platform, +mvn clean install -N && cd platforms && mvn clean install -N && cd android-14 && mvn clean install || {, +  echo 'Failed to install 4.0 SDK, install relevant packages in android SDK first';, +  exit 1;, +}, +cd ../.., +mvn clean install -N && cd extras && mvn clean install -N && cd compatibility-v4 && mvn clean install || {, +  echo 'Failed to install android-support-v4, install support library in android SDK first';, +  exit 1;, +}, +cd ../../.., +rm -rf maven-android-sdk-deployer, +++ b/library/pom.xml, +  <packaging>aar</packaging>, +    <dependency>, +      <groupId>com.bumptech.glide</groupId>, +      <artifactId>glide-gif-decoder</artifactId>, +      <version>3.3.0-SNAPSHOT</version>, +    </dependency>, +++ b/pom.xml]
[+++ b/gradle.properties, +TRUTH_VERSION=0.36, +++ b/gradle.properties, +TRUTH_VERSION=0.36, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java, +import static org.mockito.Mockito.any;, +import static org.mockito.Mockito.anyBoolean;, +import static org.mockito.Mockito.eq;, +++ b/gradle.properties, +TRUTH_VERSION=0.36, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java, +import static org.mockito.Mockito.any;, +import static org.mockito.Mockito.anyBoolean;, +import static org.mockito.Mockito.eq;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java, +import com.google.common.truth.FailureMetadata;, +  private static final Subject.Factory<BitmapSubject, Bitmap> FACTORY =, +      new Subject.Factory<BitmapSubject, Bitmap>() {, +        public BitmapSubject createSubject(@NonNull FailureMetadata metadata, @NonNull Bitmap actual) {, +          return new BitmapSubject(metadata, actual);, +  private BitmapSubject(FailureMetadata failureMetadata, Bitmap subject) {, +    super(failureMetadata, subject);, +++ b/gradle.properties, +TRUTH_VERSION=0.36, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java, +import static org.mockito.Mockito.any;, +import static org.mockito.Mockito.anyBoolean;, +import static org.mockito.Mockito.eq;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java, +import com.google.common.truth.FailureMetadata;, +  private static final Subject.Factory<BitmapSubject, Bitmap> FACTORY =, +      new Subject.Factory<BitmapSubject, Bitmap>() {, +        public BitmapSubject createSubject(@NonNull FailureMetadata metadata, @NonNull Bitmap actual) {, +          return new BitmapSubject(metadata, actual);, +  private BitmapSubject(FailureMetadata failureMetadata, Bitmap subject) {, +    super(failureMetadata, subject);, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java, +import com.bumptech.glide.Glide;, +        Glide.with(InstrumentationRegistry.getTargetContext()), +++ b/gradle.properties, +TRUTH_VERSION=0.36, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java, +import static org.mockito.Mockito.any;, +import static org.mockito.Mockito.anyBoolean;, +import static org.mockito.Mockito.eq;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java, +import com.google.common.truth.FailureMetadata;, +  private static final Subject.Factory<BitmapSubject, Bitmap> FACTORY =, +      new Subject.Factory<BitmapSubject, Bitmap>() {, +        public BitmapSubject createSubject(@NonNull FailureMetadata metadata, @NonNull Bitmap actual) {, +          return new BitmapSubject(metadata, actual);, +  private BitmapSubject(FailureMetadata failureMetadata, Bitmap subject) {, +    super(failureMetadata, subject);, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java, +import com.bumptech.glide.Glide;, +        Glide.with(InstrumentationRegistry.getTargetContext()), +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java, +import static org.mockito.Mockito.any;, +++ b/gradle.properties, +TRUTH_VERSION=0.36, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java, +import static org.mockito.Mockito.any;, +import static org.mockito.Mockito.anyBoolean;, +import static org.mockito.Mockito.eq;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java, +import com.google.common.truth.FailureMetadata;, +  private static final Subject.Factory<BitmapSubject, Bitmap> FACTORY =, +      new Subject.Factory<BitmapSubject, Bitmap>() {, +        public BitmapSubject createSubject(@NonNull FailureMetadata metadata, @NonNull Bitmap actual) {, +          return new BitmapSubject(metadata, actual);, +  private BitmapSubject(FailureMetadata failureMetadata, Bitmap subject) {, +    super(failureMetadata, subject);, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java, +import com.bumptech.glide.Glide;, +        Glide.with(InstrumentationRegistry.getTargetContext()), +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java, +import static org.mockito.Mockito.any;, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/gradle.properties, +TRUTH_VERSION=0.36, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/RequestTest.java, +import static org.mockito.Mockito.any;, +import static org.mockito.Mockito.anyBoolean;, +import static org.mockito.Mockito.eq;, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/BitmapSubject.java, +import com.google.common.truth.FailureMetadata;, +  private static final Subject.Factory<BitmapSubject, Bitmap> FACTORY =, +      new Subject.Factory<BitmapSubject, Bitmap>() {, +        public BitmapSubject createSubject(@NonNull FailureMetadata metadata, @NonNull Bitmap actual) {, +          return new BitmapSubject(metadata, actual);, +  private BitmapSubject(FailureMetadata failureMetadata, Bitmap subject) {, +    super(failureMetadata, subject);, +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/ConcurrencyHelper.java, +import com.bumptech.glide.Glide;, +        Glide.with(InstrumentationRegistry.getTargetContext()), +++ b/instrumentation/src/androidTest/java/com/bumptech/glide/test/Matchers.java, +import static org.mockito.Mockito.any;, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +    diskCacheProvider.clearDiskCacheIfCreated();]
[+++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import static org.mockito.Mockito.times;, +    public void testReceivesThumbnails() {, +        String full = mockUri("content://full");, +        String thumb = mockUri("content://thumb");, +        requestManager, +                .load(full), +                .thumbnail(requestManager, +                        .load(thumb)), +                .into(target);, +, +        verify(target, times(2)).onResourceReady(any(Drawable.class), any(GlideAnimation.class));, +    }, +, +    @Test, +    public void testReceivesRecursiveThumbnails() {, +        requestManager, +                .load(mockUri("content://first")), +                .thumbnail(requestManager, +                        .load(mockUri("content://second")), +                        .thumbnail(requestManager, +                                .load(mockUri("content://third")), +                                .thumbnail(requestManager, +                                        .load(mockUri("content://fourth")), +                                ), +                        ), +                ), +                .into(target);, +        verify(target, times(4)).onResourceReady(any(Drawable.class), any(GlideAnimation.class));, +    }, +, +    @Test, +    public void testReceivesRecursiveThumbnailWithPercentage() {, +        requestManager, +                .load(mockUri("content://first")), +                .thumbnail(requestManager, +                        .load(mockUri("content://second")), +                        .thumbnail(0.5f), +                ), +                .into(target);, +        verify(target, times(3)).onResourceReady(any(Drawable.class), any(GlideAnimation.class));, +    }, +, +    @Test, +    private String mockUri(String uriString) {, +        return mockUri(Uri.parse(uriString), null);, +    private String mockUri(Uri uri) {, +        return mockUri(uri, null);, +    private String mockUri(Uri uri, InputStream is) {, +        return uri.toString();, +++ b/library/src/androidTest/java/com/bumptech/glide/GlideTest.java, +import static org.mockito.Mockito.times;, +    public void testReceivesThumbnails() {, +        String full = mockUri("content://full");, +        String thumb = mockUri("content://thumb");, +        requestManager, +                .load(full), +                .thumbnail(requestManager, +                        .load(thumb)), +                .into(target);, +, +        verify(target, times(2)).onResourceReady(any(Drawable.class), any(GlideAnimation.class));, +    }, +, +    @Test, +    public void testReceivesRecursiveThumbnails() {, +        requestManager, +                .load(mockUri("content://first")), +                .thumbnail(requestManager, +                        .load(mockUri("content://second")), +                        .thumbnail(requestManager, +                                .load(mockUri("content://third")), +                                .thumbnail(requestManager, +                                        .load(mockUri("content://fourth")), +                                ), +                        ), +                ), +                .into(target);, +        verify(target, times(4)).onResourceReady(any(Drawable.class), any(GlideAnimation.class));, +    }, +, +    @Test, +    public void testReceivesRecursiveThumbnailWithPercentage() {, +        requestManager, +                .load(mockUri("content://first")), +                .thumbnail(requestManager, +                        .load(mockUri("content://second")), +                        .thumbnail(0.5f), +                ), +                .into(target);, +        verify(target, times(3)).onResourceReady(any(Drawable.class), any(GlideAnimation.class));, +    }, +, +    @Test, +    private String mockUri(String uriString) {, +        return mockUri(Uri.parse(uriString), null);, +    private String mockUri(Uri uri) {, +        return mockUri(uri, null);, +    private String mockUri(Uri uri, InputStream is) {, +        return uri.toString();]
[+++ b/library/src/com/bumptech/glide/resize/load/Downsampler.java, +            orientation = new ImageHeaderParser(bis).getOrientation();, +            result = new ImageHeaderParser(bis).hasAlpha() ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;, +++ b/library/src/com/bumptech/glide/resize/load/Downsampler.java, +            orientation = new ImageHeaderParser(bis).getOrientation();, +            result = new ImageHeaderParser(bis).hasAlpha() ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;, +++ /dev/null, +++ b/library/src/com/bumptech/glide/resize/load/Downsampler.java, +            orientation = new ImageHeaderParser(bis).getOrientation();, +            result = new ImageHeaderParser(bis).hasAlpha() ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;, +++ /dev/null, +++ b/library/src/com/bumptech/glide/resize/load/ImageHeaderParser.java, +package com.bumptech.glide.resize.load;, +, +import com.bumptech.glide.util.Log;, +, +import java.io.IOException;, +import java.io.InputStream;, +import java.nio.ByteBuffer;, +import java.nio.ByteOrder;, +, +/**, + * A class for parsing the exif orientation from an InputStream for an image. Handles jpegs and tiffs., + */, +public class ImageHeaderParser {, +    private static final int GIF_HEADER = 0x474946;, +    private static final int PNG_HEADER = 0x89504E47;, +    private static final int EXIF_MAGIC_NUMBER = 0xFFD8;, +    private static final int MOTOROLA_TIFF_MAGIC_NUMBER = 0x4D4D;  // "MM", +    private static final int INTEL_TIFF_MAGIC_NUMBER = 0x4949;     // "II", +    private static final String JPEG_EXIF_SEGMENT_PREAMBLE = "Exif\0\0";, +, +    private static final int SEGMENT_SOS = 0xDA;, +    private static final int MARKER_EOI = 0xD9;, +, +    private static final int SEGMENT_START_ID = 0xFF;, +    private static final int EXIF_SEGMENT_TYPE = 0xE1;, +, +    private static final int ORIENTATION_TAG_TYPE = 0x0112;, +, +    private static final int[] BYTES_PER_FORMAT = { 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8 };, +, +    private final StreamReader streamReader;, +, +    public ImageHeaderParser(InputStream is) {, +        streamReader = new StreamReader(is);, +    }, +, +, +    // 0xD0A3C68 -> <htm, +    // 0xCAFEBABE -> <!DOCTYPE..., +    public boolean hasAlpha() throws IOException {, +        int firstByte = streamReader.getUInt8();, +, +        if (firstByte == EXIF_MAGIC_NUMBER >> 8) { //JPEG, +            return false;, +        }, +, +        final int firstTwoBytes = firstByte << 8 & 0xFF00 | streamReader.getUInt8() & 0xFF;, +        final int firstFourBytes = firstTwoBytes << 16 & 0xFFFF0000 | streamReader.getUInt16() & 0xFFFF;, +        if (firstFourBytes == PNG_HEADER) { //PNG, +            //see: http://stackoverflow.com/questions/2057923/how-to-check-a-png-for-grayscale-alpha-color-type, +            streamReader.skip(25 - 4);, +            int alpha = streamReader.getByte();, +            return alpha > 3;, +        }, +, +        if (firstFourBytes >> 8 == GIF_HEADER) { //GIF from first 3 bytes, +            return true;, +        }, +, +        return false;, +    }, +, +    /**, +     * Parse the orientation from the image header. If it doesn't handle this image type (or this is not an image), +     * it will return a default value rather than throwing an exception., +     *, +     * @return The exif orientation if present or -1 if the header couldn't be parsed or doesn't contain an orientation, +     * @throws IOException, +     */, +    public int getOrientation() throws IOException {, +        final int magicNumber = streamReader.getUInt16();, +, +        if (!handles(magicNumber)) {, +            return -1;, +        } else {, +            byte[] exifData = getExifSegment();, +            if (exifData != null && exifData.length >= JPEG_EXIF_SEGMENT_PREAMBLE.length() &&, +                new String(exifData, 0, JPEG_EXIF_SEGMENT_PREAMBLE.length()).equalsIgnoreCase(JPEG_EXIF_SEGMENT_PREAMBLE)) {, +                return parseExifSegment(new RandomAccessReader(exifData));, +            } else {, +                return -1;, +            }, +        }, +    }, +, +    private byte[] getExifSegment() throws IOException {, +        short segmentId, segmentType;, +        int segmentLength;]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java, +  public static final DownsampleStrategy CENTER_INSIDE = new DownsampleStrategy() {, +   * Downsamples, maintaining the original aspect ratio , so that one of the image's dimensions is, +   * exactly equal to the requested size and the other dimension is greater than or equal to, +   * the requested size., +   */, +  public static final DownsampleStrategy CENTER_OUTSIDE = new DownsampleStrategy() {, +    @Override, +    public int getSampleSize(int sourceWidth, int sourceHeight, int requestedWidth,, +        int requestedHeight) {, +      return AT_LEAST.getSampleSize(sourceWidth, sourceHeight, requestedWidth, requestedHeight);, +    }, +, +    @Override, +    public int getDensity(int sourceWidth, int sourceHeight, int requestedWidth,, +        int requestedHeight) {, +      if (sourceWidth * requestedHeight > sourceHeight * requestedHeight) {, +        return sourceHeight;, +      } else {, +        return sourceWidth;, +      }, +    }, +, +    @Override, +    public int getTargetDensity(int sourceWidth, int sourceHeight, int requestedWidth,, +        int requestedHeight, int sampleSize) {, +, +      final int targetDimen;, +      if (sourceWidth * requestedHeight > sourceHeight * requestedHeight) {, +        targetDimen = requestedHeight;, +      } else {, +        targetDimen = requestedWidth;, +      }, +      return targetDimen * sampleSize;, +    }, +  };, +, +  /**, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/DownsampleStrategy.java, +  public static final DownsampleStrategy CENTER_INSIDE = new DownsampleStrategy() {, +   * Downsamples, maintaining the original aspect ratio , so that one of the image's dimensions is, +   * exactly equal to the requested size and the other dimension is greater than or equal to, +   * the requested size., +   */, +  public static final DownsampleStrategy CENTER_OUTSIDE = new DownsampleStrategy() {, +    @Override, +    public int getSampleSize(int sourceWidth, int sourceHeight, int requestedWidth,, +        int requestedHeight) {, +      return AT_LEAST.getSampleSize(sourceWidth, sourceHeight, requestedWidth, requestedHeight);, +    }, +, +    @Override, +    public int getDensity(int sourceWidth, int sourceHeight, int requestedWidth,, +        int requestedHeight) {, +      if (sourceWidth * requestedHeight > sourceHeight * requestedHeight) {, +        return sourceHeight;, +      } else {, +        return sourceWidth;, +      }, +    }, +, +    @Override, +    public int getTargetDensity(int sourceWidth, int sourceHeight, int requestedWidth,, +        int requestedHeight, int sampleSize) {, +, +      final int targetDimen;, +      if (sourceWidth * requestedHeight > sourceHeight * requestedHeight) {, +        targetDimen = requestedHeight;, +      } else {, +        targetDimen = requestedWidth;, +      }, +      return targetDimen * sampleSize;, +    }, +  };, +, +  /**, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +    downsample(DownsampleStrategy.CENTER_OUTSIDE);, +    downsample(DownsampleStrategy.CENTER_OUTSIDE);, +    downsample(DownsampleStrategy.CENTER_INSIDE);, +    downsample(DownsampleStrategy.CENTER_INSIDE);]
[+++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/README.md, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml, +  - tools, +  - platform-tools, +  - build-tools-21.1.2, +  - android-21, +  - extra-android-m2repository, +  - extra-android-support, +, +jdk:, +  - openjdk7, +  - oraclejdk7, +  - oraclejdk8, +, +++ b/README.md, +++ b/build.gradle, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +// See http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html., +if (JavaVersion.current().isJava8Compatible()) {, +    allprojects {, +        tasks.withType(Javadoc) {, +            options.addStringOption('Xdoclint:none', '-quiet'), +        }, +    }, +}, +, +subprojects {, +    tasks.withType(JavaCompile) {, +        sourceCompatibility = 1.7, +        targetCompatibility = 1.7, +    }, +}, +, +        maven {, +            url "https://oss.sonatype.org/content/repositories/snapshots", +        }, +++ b/.idea/codeStyleSettings.xml, +        <option name="USE_FQ_CLASS_NAMES_IN_JAVADOC" value="false" />, +          <option name="KEEP_LINE_BREAKS" value="false" />, +          <option name="METHOD_PARAMETERS_WRAP" value="1" />, +          <option name="METHOD_CALL_CHAIN_WRAP" value="2" />, +          <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true" />, +          <option name="WRAP_LONG_LINES" value="true" />, +++ b/.travis.yml]
[+++ b/gradle.properties, +VERSION_NAME=4.7.0, +VERSION_MINOR=7, +VERSION_PATCH=0]
[+++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +  private boolean isActiveResourceRetentionAllowed = true;, +  /**, +   * If set to {@code true}, allows Glide to re-capture resources that are loaded into, +   * {@link com.bumptech.glide.request.target.Target}s which are subsequently de-referenced and, +   * garbage collected without being cleared., +   *, +   * <p>Glide's resource re-use system is permissive, which means that's acceptable for callers to, +   * load resources into {@link com.bumptech.glide.request.target.Target}s and then never clear the, +   * {@link com.bumptech.glide.request.target.Target}. To do so, Glide uses, +   * {@link java.lang.ref.WeakReference}s to track resources that belong to, +   * {@link com.bumptech.glide.request.target.Target}s that haven't yet been cleared. Setting, +   * this method to {@code true} allows Glide to also maintain a hard reference to the underlying, +   * resource so that if the {@link com.bumptech.glide.request.target.Target} is garbage collected,, +   * Glide can return the underlying resource to it's memory cache so that subsequent requests will, +   * not unexpectedly re-load the resource from disk or source. As a side affect, it will take, +   * the system slightly longer to garbage collect the underlying resource because the weak, +   * reference has to be cleared and processed first. As a result, setting this method to, +   * {@code true} may transiently increase the memory usage of an application., +   *, +   * <p>Setting this method to {@code false} will allow the platform to garbage collect resources, +   * more quickly, but will lead to unexpected memory cache misses if callers load resources into, +   * {@link com.bumptech.glide.request.target.Target}s but never clear them., +   *, +   * <p>Regardless of what value this method is set to, it's always good practice to clear, +   * {@link com.bumptech.glide.request.target.Target}s when you're done with the corresponding, +   * resource. Clearing {@link com.bumptech.glide.request.target.Target}s allows Glide to maximize, +   * resource re-use, minimize memory overhead and minimize unexpected behavior resulting from, +   * edge cases., +   *, +   * <p>Defaults to {@code true}., +   *, +   * @return This builder., +   */, +  public GlideBuilder setIsActiveResourceRetentionAllowed(, +      boolean isActiveResourceRetentionAllowed) {, +    this.isActiveResourceRetentionAllowed = isActiveResourceRetentionAllowed;, +    return this;, +  }, +, +              GlideExecutor.newAnimationExecutor(),, +              isActiveResourceRetentionAllowed);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +  private boolean isActiveResourceRetentionAllowed = true;, +  /**, +   * If set to {@code true}, allows Glide to re-capture resources that are loaded into, +   * {@link com.bumptech.glide.request.target.Target}s which are subsequently de-referenced and, +   * garbage collected without being cleared., +   *, +   * <p>Glide's resource re-use system is permissive, which means that's acceptable for callers to, +   * load resources into {@link com.bumptech.glide.request.target.Target}s and then never clear the, +   * {@link com.bumptech.glide.request.target.Target}. To do so, Glide uses, +   * {@link java.lang.ref.WeakReference}s to track resources that belong to, +   * {@link com.bumptech.glide.request.target.Target}s that haven't yet been cleared. Setting, +   * this method to {@code true} allows Glide to also maintain a hard reference to the underlying, +   * resource so that if the {@link com.bumptech.glide.request.target.Target} is garbage collected,, +   * Glide can return the underlying resource to it's memory cache so that subsequent requests will, +   * not unexpectedly re-load the resource from disk or source. As a side affect, it will take, +   * the system slightly longer to garbage collect the underlying resource because the weak, +   * reference has to be cleared and processed first. As a result, setting this method to, +   * {@code true} may transiently increase the memory usage of an application., +   *, +   * <p>Setting this method to {@code false} will allow the platform to garbage collect resources, +   * more quickly, but will lead to unexpected memory cache misses if callers load resources into, +   * {@link com.bumptech.glide.request.target.Target}s but never clear them., +   *, +   * <p>Regardless of what value this method is set to, it's always good practice to clear, +   * {@link com.bumptech.glide.request.target.Target}s when you're done with the corresponding, +   * resource. Clearing {@link com.bumptech.glide.request.target.Target}s allows Glide to maximize, +   * resource re-use, minimize memory overhead and minimize unexpected behavior resulting from, +   * edge cases., +   *, +   * <p>Defaults to {@code true}., +   *, +   * @return This builder., +   */, +  public GlideBuilder setIsActiveResourceRetentionAllowed(, +      boolean isActiveResourceRetentionAllowed) {, +    this.isActiveResourceRetentionAllowed = isActiveResourceRetentionAllowed;, +    return this;, +  }, +, +              GlideExecutor.newAnimationExecutor(),, +              isActiveResourceRetentionAllowed);, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ActiveResources.java, +  private final boolean isActiveResourceRetentionAllowed;, +  ActiveResources(boolean isActiveResourceRetentionAllowed) {, +    this.isActiveResourceRetentionAllowed = isActiveResourceRetentionAllowed;, +  }, +, +    ResourceWeakReference toPut =, +        new ResourceWeakReference(, +            key,, +            resource,, +            getReferenceQueue(),, +            isActiveResourceRetentionAllowed);, +, +    ResourceWeakReference removed = activeEngineResources.put(key, toPut);, +        @NonNull ReferenceQueue<? super EngineResource<?>> queue,, +        boolean isActiveResourceRetentionAllowed) {]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +import android.support.annotation.NonNull;, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +import android.support.annotation.NonNull;, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +import android.support.annotation.NonNull;, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java, +import android.support.annotation.NonNull;, +    @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +import android.support.annotation.NonNull;, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java, +import android.support.annotation.NonNull;, +    @NonNull, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +import android.support.annotation.NonNull;, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +import android.support.annotation.NonNull;, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java, +import android.support.annotation.NonNull;, +    @NonNull, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +import android.support.annotation.NonNull;, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java, +    public void reset(@NonNull Object object) {, +  @NonNull, +  public static <T extends Poolable> Pool<T> simple(int size, @NonNull Factory<T> factory) {, +  @NonNull, +  public static <T extends Poolable> Pool<T> threadSafe(int size, @NonNull Factory<T> factory) {, +  @NonNull, +  @NonNull, +      @NonNull, +      public void reset(@NonNull List<T> object) {, +  @NonNull, +  private static <T extends Poolable> Pool<T> build(@NonNull Pool<T> pool,, +      @NonNull Factory<T> factory) {, +  @NonNull, +  private static <T> Pool<T> build(@NonNull Pool<T> pool, @NonNull Factory<T> factory,, +      @NonNull Resetter<T> resetter) {, +  @NonNull, +    void reset(@NonNull T object);, +    @NonNull, +    FactoryPool(@NonNull Pool<T> pool, @NonNull Factory<T> factory, @NonNull Resetter<T> resetter) {, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineJob.java, +import android.support.annotation.NonNull;, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/SafeKeyGenerator.java, +import android.support.annotation.NonNull;, +    @NonNull, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +import android.support.annotation.NonNull;, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/util/pool/FactoryPools.java, +    public void reset(@NonNull Object object) {, +  @NonNull, +  public static <T extends Poolable> Pool<T> simple(int size, @NonNull Factory<T> factory) {, +  @NonNull, +  public static <T extends Poolable> Pool<T> threadSafe(int size, @NonNull Factory<T> factory) {, +  @NonNull, +  @NonNull, +      @NonNull, +      public void reset(@NonNull List<T> object) {, +  @NonNull, +  private static <T extends Poolable> Pool<T> build(@NonNull Pool<T> pool,, +      @NonNull Factory<T> factory) {, +  @NonNull, +  private static <T> Pool<T> build(@NonNull Pool<T> pool, @NonNull Factory<T> factory,, +      @NonNull Resetter<T> resetter) {, +  @NonNull]
[+++ b/checkstyle.xml, +            <property name="max" value="100" />, +++ b/checkstyle.xml, +            <property name="max" value="100" />, +++ b/integration/gifencoder/build.gradle, +++ b/checkstyle.xml, +            <property name="max" value="100" />, +++ b/integration/gifencoder/build.gradle, +++ b/integration/gifencoder/gifencoder.iml, +      <excludeFolder url="file://$MODULE_DIR$/build/docs" />, +++ b/checkstyle.xml, +            <property name="max" value="100" />, +++ b/integration/gifencoder/build.gradle, +++ b/integration/gifencoder/gifencoder.iml, +      <excludeFolder url="file://$MODULE_DIR$/build/docs" />, +++ b/integration/gifencoder/lint.xml, +++ b/checkstyle.xml, +            <property name="max" value="100" />, +++ b/integration/gifencoder/build.gradle, +++ b/integration/gifencoder/gifencoder.iml, +      <excludeFolder url="file://$MODULE_DIR$/build/docs" />, +++ b/integration/gifencoder/lint.xml, +++ b/integration/gifencoder/src/androidTest/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +  @Mock, +  Resource<GifDrawable> resource;, +  @Mock, +  GifDecoder decoder;, +  @Mock, +  GifHeaderParser parser;, +  @Mock, +  AnimatedGifEncoder gifEncoder;, +  @Mock, +  Resource<Bitmap> frameResource;, +  @Mock, +  Transformation frameTransformation;, +  @Mock, +  GifDrawable gifDrawable;, +  @Mock, +  OutputStream os;, +    when(factory.buildFrameResource(any(Bitmap.class), any(BitmapPool.class))), +        .thenReturn(frameResource);, +    when(frameTransformation.transform(any(Resource.class), anyInt(), anyInt())), +        .thenReturn(frameResource);, +  public void testEncode_withEncodeTransformationFalse_writesSourceDataToStream(), +      throws IOException {, +  public void testEncode_WithEncodeTransformationFalse_whenOsThrows_returnsFalse(), +      throws IOException {, +  public void testWritesBytesDirectlyToDiskIfTransformationIsUnitTransformation(), +      throws IOException {, +++ b/checkstyle.xml, +            <property name="max" value="100" />, +++ b/integration/gifencoder/build.gradle, +++ b/integration/gifencoder/gifencoder.iml, +      <excludeFolder url="file://$MODULE_DIR$/build/docs" />, +++ b/integration/gifencoder/lint.xml, +++ b/integration/gifencoder/src/androidTest/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +  @Mock, +  Resource<GifDrawable> resource;, +  @Mock, +  GifDecoder decoder;, +  @Mock, +  GifHeaderParser parser;, +  @Mock, +  AnimatedGifEncoder gifEncoder;, +  @Mock, +  Resource<Bitmap> frameResource;, +  @Mock, +  Transformation frameTransformation;, +  @Mock, +  GifDrawable gifDrawable;, +  @Mock, +  OutputStream os;, +    when(factory.buildFrameResource(any(Bitmap.class), any(BitmapPool.class))), +        .thenReturn(frameResource);, +    when(frameTransformation.transform(any(Resource.class), anyInt(), anyInt())), +        .thenReturn(frameResource);, +  public void testEncode_withEncodeTransformationFalse_writesSourceDataToStream(), +      throws IOException {, +  public void testEncode_WithEncodeTransformationFalse_whenOsThrows_returnsFalse(), +      throws IOException {, +  public void testWritesBytesDirectlyToDiskIfTransformationIsUnitTransformation(), +      throws IOException {, +++ b/integration/gifencoder/src/main/AndroidManifest.xml, +, +++ b/checkstyle.xml, +            <property name="max" value="100" />, +++ b/integration/gifencoder/build.gradle, +++ b/integration/gifencoder/gifencoder.iml, +      <excludeFolder url="file://$MODULE_DIR$/build/docs" />, +++ b/integration/gifencoder/lint.xml, +++ b/integration/gifencoder/src/androidTest/java/com/bumptech/glide/integration/gifencoder/ReEncodingGifResourceEncoderTest.java, +  @Mock, +  Resource<GifDrawable> resource;, +  @Mock, +  GifDecoder decoder;, +  @Mock, +  GifHeaderParser parser;, +  @Mock, +  AnimatedGifEncoder gifEncoder;, +  @Mock]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java, +import org.robolectric.RobolectricTestRunner;, +, +import com.bumptech.glide.Registry.NoModelLoaderAvailableException;, +, +import org.junit.Rule;, +import org.junit.rules.ExpectedException;, +  @Mock ModelLoaderFactory<String, String> firstFactory;, +  @Mock ModelLoader<String, String> firstModelLoader;, +  @Mock MultiModelLoaderFactory.Factory multiModelLoaderFactory;, +  @Mock ModelLoaderFactory<String, String> secondFactory;, +  @Mock ModelLoader<String, String> secondModelLoader;, +, +  public @Rule ExpectedException exception = ExpectedException.none();, +    when(firstFactory.build(anyContext(), eq(multiFactory))).thenReturn(firstModelLoader);, +    when(secondFactory.build(anyContext(), eq(multiFactory))).thenReturn(secondModelLoader);, +    multiFactory.append(String.class, String.class, firstFactory);, +    assertThat(modelLoaders).containsExactly(firstModelLoader);, +    multiFactory.append(String.class, String.class, firstFactory);, +    ModelLoader<String, String> modelLoader = multiFactory.build(String.class, String.class);, +    assertThat(modelLoader).isEqualTo(firstModelLoader);, +    multiFactory.prepend(String.class, String.class, firstFactory);, +    assertThat(modelLoaders).containsExactly(firstModelLoader);, +    multiFactory.prepend(String.class, String.class, firstFactory);, +    ModelLoader<String, String> modelLoader = multiFactory.build(String.class, String.class);, +    assertThat(modelLoader).isEqualTo(firstModelLoader);, +    multiFactory.replace(String.class, String.class, firstFactory);, +    assertThat(modelLoaders).containsExactly(firstModelLoader);, +    multiFactory.replace(String.class, String.class, firstFactory);, +    ModelLoader<String, String> modelLoader = multiFactory.build(String.class, String.class);, +    assertThat(modelLoader).isEqualTo(firstModelLoader);, +        multiFactory.replace(String.class, String.class, firstFactory);, +    multiFactory.replace(String.class, String.class, firstFactory);, +    assertThat(modelLoaders).containsExactly(firstModelLoader);, +    multiFactory.append(String.class, String.class, firstFactory);, +    assertThat(removed).containsExactly(firstFactory, other);, +    multiFactory.append(String.class, String.class, firstFactory);, +    assertThat(modelLoaders).containsExactly(otherLoader, firstModelLoader);, +    multiFactory.append(String.class, String.class, firstFactory);, +    assertThat(modelLoaders).containsExactly(otherLoader, firstModelLoader);, +    multiFactory.append(String.class, String.class, firstFactory);, +    assertThat(modelLoaders).doesNotContain(firstModelLoader);, +    multiFactory.append(String.class, String.class, firstFactory);, +    assertThat(modelLoaders).containsExactly(otherLoader, firstModelLoader);, +    multiFactory.append(String.class, String.class, firstFactory);, +, +    exception.expect(NoModelLoaderAvailableException.class);, +    multiFactory.build(String.class, Integer.class);, +    multiFactory.append(String.class, String.class, firstFactory);, +, +    exception.expect(NoModelLoaderAvailableException.class);, +    multiFactory.build(Integer.class, String.class);, +    appendFactoryFor(String.class, Object.class);, +    exception.expect(NoModelLoaderAvailableException.class);, +    multiFactory.build(Object.class, Object.class);, +    appendFactoryFor(Object.class, String.class);, +    exception.expect(NoModelLoaderAvailableException.class);, +    multiFactory.build(Object.class, Object.class);, +    ModelLoader<Object, Object> firstSuperClass = appendFactoryFor(Object.class, Object.class);, +    ModelLoader<Object, Object> secondSuperClass = appendFactoryFor(Object.class, Object.class);, +    assertThat(modelLoaders).containsExactly(firstSuperClass, secondSuperClass);, +    ModelLoader<Object, Object> firstSuperClass = appendFactoryFor(Object.class, Object.class);, +    ModelLoader<Object, Object> secondSuperClass = appendFactoryFor(Object.class, Object.class);, +    assertThat(modelLoaders).containsExactly(firstSuperClass, secondSuperClass);, +    ModelLoader<Object, Object> firstSuperclass = appendFactoryFor(Object.class, Object.class);, +    ModelLoader<Object, Object> secondSuperclass = appendFactoryFor(Object.class, Object.class);, +    assertThat(modelLoaders).containsExactly(firstSuperclass, secondSuperclass);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/model/MultiModelLoaderFactoryTest.java, +import org.robolectric.RobolectricTestRunner;, +, +import com.bumptech.glide.Registry.NoModelLoaderAvailableException;, +, +import org.junit.Rule;, +import org.junit.rules.ExpectedException;, +  @Mock ModelLoaderFactory<String, String> firstFactory;, +  @Mock ModelLoader<String, String> firstModelLoader;, +  @Mock MultiModelLoaderFactory.Factory multiModelLoaderFactory;, +  @Mock ModelLoaderFactory<String, String> secondFactory;, +  @Mock ModelLoader<String, String> secondModelLoader;, +, +  public @Rule ExpectedException exception = ExpectedException.none();, +    when(firstFactory.build(anyContext(), eq(multiFactory))).thenReturn(firstModelLoader);, +    when(secondFactory.build(anyContext(), eq(multiFactory))).thenReturn(secondModelLoader);, +    multiFactory.append(String.class, String.class, firstFactory);, +    assertThat(modelLoaders).containsExactly(firstModelLoader);, +    multiFactory.append(String.class, String.class, firstFactory);, +    ModelLoader<String, String> modelLoader = multiFactory.build(String.class, String.class);, +    assertThat(modelLoader).isEqualTo(firstModelLoader);, +    multiFactory.prepend(String.class, String.class, firstFactory);, +    assertThat(modelLoaders).containsExactly(firstModelLoader);, +    multiFactory.prepend(String.class, String.class, firstFactory);, +    ModelLoader<String, String> modelLoader = multiFactory.build(String.class, String.class);, +    assertThat(modelLoader).isEqualTo(firstModelLoader);, +    multiFactory.replace(String.class, String.class, firstFactory);, +    assertThat(modelLoaders).containsExactly(firstModelLoader);, +    multiFactory.replace(String.class, String.class, firstFactory);, +    ModelLoader<String, String> modelLoader = multiFactory.build(String.class, String.class);, +    assertThat(modelLoader).isEqualTo(firstModelLoader);, +        multiFactory.replace(String.class, String.class, firstFactory);, +    multiFactory.replace(String.class, String.class, firstFactory);]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +     * Clears disk cache., +     *, +     * <p>, +     *     This method should always be called on a background thread, since it is a blocking call., +     * </p>, +     */, +    public void clearDiskCache() {, +        Util.assertBackgroundThread();, +        getEngine().clearDiskCache();, +    }, +, +    /**, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +     * Clears disk cache., +     *, +     * <p>, +     *     This method should always be called on a background thread, since it is a blocking call., +     * </p>, +     */, +    public void clearDiskCache() {, +        Util.assertBackgroundThread();, +        getEngine().clearDiskCache();, +    }, +, +    /**, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +    public void clearDiskCache() {, +        diskCacheProvider.getDiskCache().clear();, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +     * Clears disk cache., +     *, +     * <p>, +     *     This method should always be called on a background thread, since it is a blocking call., +     * </p>, +     */, +    public void clearDiskCache() {, +        Util.assertBackgroundThread();, +        getEngine().clearDiskCache();, +    }, +, +    /**, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +    public void clearDiskCache() {, +        diskCacheProvider.getDiskCache().clear();, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java, +, +    /**, +     * Clear the cache., +     */, +    void clear();, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +     * Clears disk cache., +     *, +     * <p>, +     *     This method should always be called on a background thread, since it is a blocking call., +     * </p>, +     */, +    public void clearDiskCache() {, +        Util.assertBackgroundThread();, +        getEngine().clearDiskCache();, +    }, +, +    /**, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +    public void clearDiskCache() {, +        diskCacheProvider.getDiskCache().clear();, +    }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCache.java, +, +    /**, +     * Clear the cache., +     */, +    void clear();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/cache/DiskCacheAdapter.java, +, +    @Override, +    public void clear() {, +        // no op, default for overriders, +    }, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +     * Clears disk cache., +     *, +     * <p>, +     *     This method should always be called on a background thread, since it is a blocking call., +     * </p>, +     */, +    public void clearDiskCache() {, +        Util.assertBackgroundThread();, +        getEngine().clearDiskCache();, +    }, +, +    /**, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Engine.java, +    public void clearDiskCache() {]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapEncoder.java, +    private static final int DEFAULT_COMPRESSION_QUALITY = 90;, +        this(null, DEFAULT_COMPRESSION_QUALITY);]
[+++ b/gradle.properties, +OK_HTTP_VERSION=3.12.1]
[+++ b/library/build.gradle, +    androidTestCompile 'com.google.guava:guava-testlib:18.0', +                           '**/Manifest*.*',, +                           '**/BitmapRequestBuilder.class',, +                           '**/DrawableRequestBuilder.class',, +                           '**/GifRequestBuilder.class', ], +++ b/library/build.gradle, +    androidTestCompile 'com.google.guava:guava-testlib:18.0', +                           '**/Manifest*.*',, +                           '**/BitmapRequestBuilder.class',, +                           '**/DrawableRequestBuilder.class',, +                           '**/GifRequestBuilder.class', ], +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java, +package com.bumptech.glide.load.data;, +, +import android.content.res.AssetFileDescriptor;, +import android.content.res.AssetManager;, +import android.os.ParcelFileDescriptor;, +import com.bumptech.glide.Priority;, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +, +import java.io.IOException;, +, +import static org.junit.Assert.assertEquals;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.never;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +public class FileDescriptorAssetPathFetcherTest {, +    private FileDescriptorAssetPathFetcher fetcher;, +    private ParcelFileDescriptor expected;, +    private String assetPath;, +, +    @Before, +    public void setUp() throws IOException {, +        AssetManager assetManager = mock(AssetManager.class);, +        assetPath = "/some/asset/path";, +        fetcher = new FileDescriptorAssetPathFetcher(assetManager, assetPath);, +        expected = mock(ParcelFileDescriptor.class);, +        AssetFileDescriptor assetFileDescriptor = mock(AssetFileDescriptor.class);, +        when(assetFileDescriptor.getParcelFileDescriptor()).thenReturn(expected);, +        when(assetManager.openFd(eq(assetPath))).thenReturn(assetFileDescriptor);, +    }, +, +    @Test, +    public void testOpensInputStreamForPathWithAssetManager() throws Exception {, +        assertEquals(expected, fetcher.loadData(Priority.NORMAL));, +    }, +, +    @Test, +    public void testClosesOpenedInputStreamOnCleanup() throws Exception {, +        fetcher.loadData(Priority.NORMAL);, +        fetcher.cleanup();, +, +        verify(expected).close();, +    }, +, +    @Test, +    public void testReturnsAssetPathAsId() {, +        assertEquals(assetPath, fetcher.getId());, +    }, +, +    @Test, +    public void testDoesNothingOnCleanupIfNoDataLoaded() throws IOException {, +        fetcher.cleanup();, +        verify(expected, never()).close();, +    }, +, +    @Test, +    public void testDoesNothingOnCancel() throws Exception {, +        fetcher.loadData(Priority.NORMAL);, +        fetcher.cancel();, +        verify(expected, never()).close();, +    }, +}, +++ b/library/build.gradle, +    androidTestCompile 'com.google.guava:guava-testlib:18.0', +                           '**/Manifest*.*',, +                           '**/BitmapRequestBuilder.class',, +                           '**/DrawableRequestBuilder.class',, +                           '**/GifRequestBuilder.class', ], +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/FileDescriptorAssetPathFetcherTest.java, +package com.bumptech.glide.load.data;, +, +import android.content.res.AssetFileDescriptor;, +import android.content.res.AssetManager;, +import android.os.ParcelFileDescriptor;, +import com.bumptech.glide.Priority;, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineResourceTest.java, +    @Test(expected = NullPointerException.class), +    public void testThrowsIfWrappedResourceIsNull() {, +        new EngineResource<Object>(null, false);, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineResourceTest.java, +    @Test(expected = NullPointerException.class), +    public void testThrowsIfWrappedResourceIsNull() {, +        new EngineResource<Object>(null, false);, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/SimpleResourceTest.java, +    @Test(expected = NullPointerException.class), +    public void testThrowsIfGivenNullData() {, +        new SimpleResource<Object>(null);, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineResourceTest.java, +    @Test(expected = NullPointerException.class), +    public void testThrowsIfWrappedResourceIsNull() {, +        new EngineResource<Object>(null, false);, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/SimpleResourceTest.java, +    @Test(expected = NullPointerException.class), +    public void testThrowsIfGivenNullData() {, +        new SimpleResource<Object>(null);, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java, +    @Test(expected = NullPointerException.class), +    public void testThrowsIfBitmapIsNull() {, +        new BitmapResource(null, mock(BitmapPool.class));, +    }, +, +    @Test(expected = NullPointerException.class), +    public void testThrowsIfBitmapPoolIsNull() {, +        new BitmapResource(Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565), null);, +    }, +, +    @Test(expected = NullPointerException.class), +    public void testThrowsIfBitmapAndBitmapPoolAreNull() {, +        new BitmapResource(null, null);, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineResourceTest.java, +    @Test(expected = NullPointerException.class), +    public void testThrowsIfWrappedResourceIsNull() {, +        new EngineResource<Object>(null, false);, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/SimpleResourceTest.java, +    @Test(expected = NullPointerException.class), +    public void testThrowsIfGivenNullData() {, +        new SimpleResource<Object>(null);, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java, +    @Test(expected = NullPointerException.class), +    public void testThrowsIfBitmapIsNull() {, +        new BitmapResource(null, mock(BitmapPool.class));, +    }, +, +    @Test(expected = NullPointerException.class), +    public void testThrowsIfBitmapPoolIsNull() {, +        new BitmapResource(Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565), null);, +    }, +, +    @Test(expected = NullPointerException.class), +    public void testThrowsIfBitmapAndBitmapPoolAreNull() {, +        new BitmapResource(null, null);, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapTransformationTest.java, +                return expected;, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineResourceTest.java, +    @Test(expected = NullPointerException.class), +    public void testThrowsIfWrappedResourceIsNull() {, +        new EngineResource<Object>(null, false);, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/SimpleResourceTest.java, +    @Test(expected = NullPointerException.class), +    public void testThrowsIfGivenNullData() {, +        new SimpleResource<Object>(null);, +    }, +, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/bitmap/BitmapResourceTest.java, +    @Test(expected = NullPointerException.class), +    public void testThrowsIfBitmapIsNull() {, +        new BitmapResource(null, mock(BitmapPool.class));, +    }, +, +    @Test(expected = NullPointerException.class), +    public void testThrowsIfBitmapPoolIsNull() {, +        new BitmapResource(Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565), null);, +    }, +, +    @Test(expected = NullPointerException.class)]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java, +import android.support.v4.content.ContextCompat;, +  public static Drawable getDrawable(, +      Context ourContext, Context targetContext, @DrawableRes int id) {, +    return getDrawable(ourContext, targetContext, id, /*theme=*/ null);, +  public static Drawable getDrawable(, +      Context ourContext, @DrawableRes int id, @Nullable Theme theme) {, +    return getDrawable(ourContext, ourContext, id, theme);, +  }, +, +  private static Drawable getDrawable(, +      Context ourContext, Context targetContext, @DrawableRes int id, @Nullable Theme theme) {, +        return loadDrawableV7(targetContext, id, theme);, +    } catch (IllegalStateException e) {, +      if (ourContext.getPackageName().equals(targetContext.getPackageName())) {, +        throw e;, +      }, +      return ContextCompat.getDrawable(targetContext, id);, +    return loadDrawableV4(targetContext, id, theme != null ? theme : targetContext.getTheme());, +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/DrawableDecoderCompat.java, +import android.support.v4.content.ContextCompat;, +  public static Drawable getDrawable(, +      Context ourContext, Context targetContext, @DrawableRes int id) {, +    return getDrawable(ourContext, targetContext, id, /*theme=*/ null);, +  public static Drawable getDrawable(, +      Context ourContext, @DrawableRes int id, @Nullable Theme theme) {, +    return getDrawable(ourContext, ourContext, id, theme);, +  }, +, +  private static Drawable getDrawable(, +      Context ourContext, Context targetContext, @DrawableRes int id, @Nullable Theme theme) {, +        return loadDrawableV7(targetContext, id, theme);, +    } catch (IllegalStateException e) {, +      if (ourContext.getPackageName().equals(targetContext.getPackageName())) {, +        throw e;, +      }, +      return ContextCompat.getDrawable(targetContext, id);, +    return loadDrawableV4(targetContext, id, theme != null ? theme : targetContext.getTheme());, +++ b/library/src/main/java/com/bumptech/glide/load/resource/drawable/ResourceDrawableDecoder.java, +    Context targetContext = packageName.equals(context.getPackageName()), +    Drawable drawable = DrawableDecoderCompat.getDrawable(context, targetContext, resId);]
[+++ b/library/src/com/bumptech/glide/resize/ImageManager.java, +                        public void onStreamReady(final InputStream is) {, +                            future = executor.submit(new Runnable() {, +                                @Override, +                                public void run() {, +                            });, +                        }, +++ b/library/src/com/bumptech/glide/resize/ImageManager.java, +                        public void onStreamReady(final InputStream is) {, +                            future = executor.submit(new Runnable() {, +                                @Override, +                                public void run() {, +                            });, +                        }, +++ b/samples/flickr/res/layout/flickr_search_activity.xml, +          android:id="@+id/search_loading", +++ b/library/src/com/bumptech/glide/resize/ImageManager.java, +                        public void onStreamReady(final InputStream is) {, +                            future = executor.submit(new Runnable() {, +                                @Override, +                                public void run() {, +                            });, +                        }, +++ b/samples/flickr/res/layout/flickr_search_activity.xml, +          android:id="@+id/search_loading", +++ b/samples/flickr/res/values/strings.xml, +  <string name="search_failed">Search for \"%s\" failed, check your network connection and try again</string>, +++ b/library/src/com/bumptech/glide/resize/ImageManager.java, +                        public void onStreamReady(final InputStream is) {, +                            future = executor.submit(new Runnable() {, +                                @Override, +                                public void run() {, +                            });, +                        }, +++ b/samples/flickr/res/layout/flickr_search_activity.xml, +          android:id="@+id/search_loading", +++ b/samples/flickr/res/values/strings.xml, +  <string name="search_failed">Search for \"%s\" failed, check your network connection and try again</string>, +++ b/samples/flickr/src/com/bumptech/flickr/FlickrSearchActivity.java, +    private View searchLoading;, +        searchLoading = findViewById(R.id.search_loading);, +        searchLoading.setVisibility(View.VISIBLE);, +, +            @Override, +            public void onSearchFailed(Exception e) {, +                if (currentSearch != searchCount) return;, +                e.printStackTrace();, +, +                Log.d("SEARCH: failed :(");, +                searching.setVisibility(View.VISIBLE);, +                searchLoading.setVisibility(View.INVISIBLE);, +                searchTerm.setText(getString(R.string.search_failed, searchString));, +            }, +++ b/library/src/com/bumptech/glide/resize/ImageManager.java, +                        public void onStreamReady(final InputStream is) {, +                            future = executor.submit(new Runnable() {, +                                @Override, +                                public void run() {, +                            });, +                        }, +++ b/samples/flickr/res/layout/flickr_search_activity.xml, +          android:id="@+id/search_loading", +++ b/samples/flickr/res/values/strings.xml, +  <string name="search_failed">Search for \"%s\" failed, check your network connection and try again</string>, +++ b/samples/flickr/src/com/bumptech/flickr/FlickrSearchActivity.java, +    private View searchLoading;, +        searchLoading = findViewById(R.id.search_loading);, +        searchLoading.setVisibility(View.VISIBLE);, +, +            @Override, +            public void onSearchFailed(Exception e) {, +                if (currentSearch != searchCount) return;, +                e.printStackTrace();, +, +                Log.d("SEARCH: failed :(");, +                searching.setVisibility(View.VISIBLE);, +                searchLoading.setVisibility(View.INVISIBLE);, +                searchTerm.setText(getString(R.string.search_failed, searchString));, +            }, +++ b/samples/flickr/src/com/bumptech/flickr/api/Api.java, +        public void onSearchFailed(Exception e);, +                cb.onSearchFailed(error);]
[+++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +import android.support.annotation.NonNull;, +  boolean handles(@NonNull T source, @NonNull Options options) throws IOException;, +  Resource<Z> decode(@NonNull T source, int width, int height, @NonNull Options options), +      throws IOException;, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +import android.support.annotation.NonNull;, +  boolean handles(@NonNull T source, @NonNull Options options) throws IOException;, +  Resource<Z> decode(@NonNull T source, int width, int height, @NonNull Options options), +      throws IOException;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +import android.support.annotation.NonNull;, +  boolean handles(@NonNull T source, @NonNull Options options) throws IOException;, +  Resource<Z> decode(@NonNull T source, int width, int height, @NonNull Options options), +      throws IOException;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +import android.support.annotation.NonNull;, +  boolean handles(@NonNull T source, @NonNull Options options) throws IOException;, +  Resource<Z> decode(@NonNull T source, int width, int height, @NonNull Options options), +      throws IOException;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Resource.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +import android.support.annotation.NonNull;, +  boolean handles(@NonNull T source, @NonNull Options options) throws IOException;, +  Resource<Z> decode(@NonNull T source, int width, int height, @NonNull Options options), +      throws IOException;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Resource.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +import android.support.annotation.NonNull;, +  boolean handles(@NonNull T source, @NonNull Options options) throws IOException;, +  Resource<Z> decode(@NonNull T source, int width, int height, @NonNull Options options), +      throws IOException;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/Resource.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/resource/SimpleResource.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/BitmapDrawableDecoder.java, +  public boolean handles(@NonNull DataType source, @NonNull Options options) throws IOException {, +  public Resource<BitmapDrawable> decode(@NonNull DataType source, int width, int height,, +      @NonNull Options options), +++ b/library/src/main/java/com/bumptech/glide/load/ResourceDecoder.java, +import android.support.annotation.NonNull;, +  boolean handles(@NonNull T source, @NonNull Options options) throws IOException;, +  Resource<Z> decode(@NonNull T source, int width, int height, @NonNull Options options), +      throws IOException;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/EngineResource.java, +import android.support.annotation.NonNull;, +  @NonNull, +  @NonNull, +++ b/library/src/main/java/com/bumptech/glide/load/engine/LockedResource.java]
[+++ b/Makefile, +	cp -f third_party/disklrucache/disklrucache*.jar library/libs, +	cp -f third_party/gif_decoder/bin/gifdecoder*.jar library/libs, +	cp -f third_party/volley/volley/bin/volley.jar library/libs, +++ b/Makefile, +	cp -f third_party/disklrucache/disklrucache*.jar library/libs, +	cp -f third_party/gif_decoder/bin/gifdecoder*.jar library/libs, +	cp -f third_party/volley/volley/bin/volley.jar library/libs, +++ b/library/.gitignore, +libs/disklrucache*.jar, +++ b/Makefile, +	cp -f third_party/disklrucache/disklrucache*.jar library/libs, +	cp -f third_party/gif_decoder/bin/gifdecoder*.jar library/libs, +	cp -f third_party/volley/volley/bin/volley.jar library/libs, +++ b/library/.gitignore, +libs/disklrucache*.jar, +++ /dev/null, +++ b/Makefile, +	cp -f third_party/disklrucache/disklrucache*.jar library/libs, +	cp -f third_party/gif_decoder/bin/gifdecoder*.jar library/libs, +	cp -f third_party/volley/volley/bin/volley.jar library/libs, +++ b/library/.gitignore, +libs/disklrucache*.jar, +++ /dev/null, +++ b/third_party/disklrucache/LICENSE, +Copyright 2012 Jake Wharton, +Copyright 2011 The Android Open Source Project, +, +Licensed under the Apache License, Version 2.0 (the "License");, +you may not use this file except in compliance with the License., +You may obtain a copy of the License at, +, +   http://www.apache.org/licenses/LICENSE-2.0, +, +Unless required by applicable law or agreed to in writing, software, +distributed under the License is distributed on an "AS IS" BASIS,, +WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., +See the License for the specific language governing permissions and, +limitations under the License., +++ b/Makefile, +	cp -f third_party/disklrucache/disklrucache*.jar library/libs, +	cp -f third_party/gif_decoder/bin/gifdecoder*.jar library/libs, +	cp -f third_party/volley/volley/bin/volley.jar library/libs, +++ b/library/.gitignore, +libs/disklrucache*.jar, +++ /dev/null, +++ b/third_party/disklrucache/LICENSE, +Copyright 2012 Jake Wharton, +Copyright 2011 The Android Open Source Project, +, +Licensed under the Apache License, Version 2.0 (the "License");, +you may not use this file except in compliance with the License., +You may obtain a copy of the License at, +, +   http://www.apache.org/licenses/LICENSE-2.0, +, +Unless required by applicable law or agreed to in writing, software, +distributed under the License is distributed on an "AS IS" BASIS,, +WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., +See the License for the specific language governing permissions and, +limitations under the License., +++ b/third_party/disklrucache/README.third_party, +URL: https://github.com/JakeWharton/DiskLruCache/archive/disklrucache-2.0.2.tar.gz, +Version:c25de9c0a01974c41c75a41ba1bc4be8b3a1513a, +License: Apache 2.0, +License File: LICENSE, +, +Description:, +Java implementation of a Disk-based LRU cache which specifically targets Android compatibility., +, +Local Modifications:, +No local modifications., +++ b/Makefile, +	cp -f third_party/disklrucache/disklrucache*.jar library/libs, +	cp -f third_party/gif_decoder/bin/gifdecoder*.jar library/libs, +	cp -f third_party/volley/volley/bin/volley.jar library/libs, +++ b/library/.gitignore, +libs/disklrucache*.jar, +++ /dev/null, +++ b/third_party/disklrucache/LICENSE, +Copyright 2012 Jake Wharton, +Copyright 2011 The Android Open Source Project, +, +Licensed under the Apache License, Version 2.0 (the "License");, +you may not use this file except in compliance with the License., +You may obtain a copy of the License at, +, +   http://www.apache.org/licenses/LICENSE-2.0, +, +Unless required by applicable law or agreed to in writing, software, +distributed under the License is distributed on an "AS IS" BASIS,, +WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., +See the License for the specific language governing permissions and, +limitations under the License., +++ b/third_party/disklrucache/README.third_party, +URL: https://github.com/JakeWharton/DiskLruCache/archive/disklrucache-2.0.2.tar.gz, +Version:c25de9c0a01974c41c75a41ba1bc4be8b3a1513a, +License: Apache 2.0, +License File: LICENSE, +]
[+++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +   *, +   * @deprecated If you must disable hardware bitmaps, set, +   * {@link com.bumptech.glide.load.resource.bitmap.Downsampler#ALLOW_HARDWARE_CONFIG} to false, +   * instead., +  @Deprecated, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +   *, +   * @deprecated If you must disable hardware bitmaps, set, +   * {@link com.bumptech.glide.load.resource.bitmap.Downsampler#ALLOW_HARDWARE_CONFIG} to false, +   * instead., +  @Deprecated, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +  private boolean isScaleOnlyOrNoTransform;, +      boolean isScaleOnlyOrNoTransform,, +    this.isScaleOnlyOrNoTransform = isScaleOnlyOrNoTransform;, +  boolean isScaleOnlyOrNoTransform() {, +    return isScaleOnlyOrNoTransform;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +   *, +   * @deprecated If you must disable hardware bitmaps, set, +   * {@link com.bumptech.glide.load.resource.bitmap.Downsampler#ALLOW_HARDWARE_CONFIG} to false, +   * instead., +  @Deprecated, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +  private boolean isScaleOnlyOrNoTransform;, +      boolean isScaleOnlyOrNoTransform,, +    this.isScaleOnlyOrNoTransform = isScaleOnlyOrNoTransform;, +  boolean isScaleOnlyOrNoTransform() {, +    return isScaleOnlyOrNoTransform;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +import android.os.Build;, +import com.bumptech.glide.load.resource.bitmap.Downsampler;, +      boolean isScaleOnlyOrNoTransform,, +        isScaleOnlyOrNoTransform,, +  private Options getOptionsWithHardwareConfig(DataSource dataSource) {, +    Options options = this.options;, +    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {, +      return options;, +    }, +, +    if (options.get(Downsampler.ALLOW_HARDWARE_CONFIG) != null) {, +      return options;, +    }, +, +    if (dataSource == DataSource.RESOURCE_DISK_CACHE, +        || decodeHelper.isScaleOnlyOrNoTransform()) {, +      options = new Options();, +      options.putAll(this.options);, +      options.set(Downsampler.ALLOW_HARDWARE_CONFIG, true);, +    }, +    return options;, +  }, +, +    Options options = getOptionsWithHardwareConfig(dataSource);, +      return path.load(rewinder, options, width, height, new DecodeCallback<>(dataSource));, +++ b/library/src/main/java/com/bumptech/glide/load/DecodeFormat.java, +   *, +   * @deprecated If you must disable hardware bitmaps, set, +   * {@link com.bumptech.glide.load.resource.bitmap.Downsampler#ALLOW_HARDWARE_CONFIG} to false, +   * instead., +  @Deprecated, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +  private boolean isScaleOnlyOrNoTransform;, +      boolean isScaleOnlyOrNoTransform,, +    this.isScaleOnlyOrNoTransform = isScaleOnlyOrNoTransform;, +  boolean isScaleOnlyOrNoTransform() {, +    return isScaleOnlyOrNoTransform;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +import android.os.Build;, +import com.bumptech.glide.load.resource.bitmap.Downsampler;, +      boolean isScaleOnlyOrNoTransform,, +        isScaleOnlyOrNoTransform,, +  private Options getOptionsWithHardwareConfig(DataSource dataSource) {, +    Options options = this.options;, +    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {, +      return options;, +    }, +, +    if (options.get(Downsampler.ALLOW_HARDWARE_CONFIG) != null) {, +      return options;, +    }, +, +    if (dataSource == DataSource.RESOURCE_DISK_CACHE, +        || decodeHelper.isScaleOnlyOrNoTransform()) {, +      options = new Options();, +      options.putAll(this.options);, +      options.set(Downsampler.ALLOW_HARDWARE_CONFIG, true);, +    }, +    return options;, +  }, +, +    Options options = getOptionsWithHardwareConfig(dataSource);, +      return path.load(rewinder, options, width, height, new DecodeCallback<>(dataSource));]
[+++ b/.gitignore, +++ b/.gitignore, +++ b/README.md, +Sam Judd - <sam.a.judd@gmail.com> @samajudd, +++ b/.gitignore, +++ b/README.md, +Sam Judd - <sam.a.judd@gmail.com> @samajudd, +++ b/library/src/com/bumptech/glide/Glide.java, +        if (tag != null && tag instanceof ImageViewTarget) {, +            ImagePresenter<T> result = target.getImagePresenter();, +++ b/.gitignore, +++ b/README.md, +Sam Judd - <sam.a.judd@gmail.com> @samajudd, +++ b/library/src/com/bumptech/glide/Glide.java, +        if (tag != null && tag instanceof ImageViewTarget) {, +            ImagePresenter<T> result = target.getImagePresenter();, +++ b/library/src/com/bumptech/glide/presenter/target/ImageViewTarget.java, + * A target wrapping an ImageView that makes use of {@link ImageView#setTag(Object)} to store and retrieve, + * ImagePresenters. Also obtains the runtime dimensions of the ImageView., +    /**, +     * TODO: use {@link View#setTag(int, Object)} when we can do so and still create, +     * a jar, +     */, +++ b/.gitignore, +++ b/README.md, +Sam Judd - <sam.a.judd@gmail.com> @samajudd, +++ b/library/src/com/bumptech/glide/Glide.java, +        if (tag != null && tag instanceof ImageViewTarget) {, +            ImagePresenter<T> result = target.getImagePresenter();, +++ b/library/src/com/bumptech/glide/presenter/target/ImageViewTarget.java, + * A target wrapping an ImageView that makes use of {@link ImageView#setTag(Object)} to store and retrieve, + * ImagePresenters. Also obtains the runtime dimensions of the ImageView., +    /**, +     * TODO: use {@link View#setTag(int, Object)} when we can do so and still create, +     * a jar, +     */, +++ b/library/src/com/bumptech/glide/resize/ImageManager.java, +import java.io.UnsupportedEncodingException;, +import java.nio.ByteBuffer;, +import java.security.MessageDigest;, +import java.security.NoSuchAlgorithmException;, +import java.util.HashMap;, +import java.util.Map;, +    private final SafeKeyGenerator safeKeyGenerator = new SafeKeyGenerator();, +        final String key = safeKeyGenerator.getSafeKey(id, transformation, downsampler, width, height);, +++ b/.gitignore, +++ b/README.md, +Sam Judd - <sam.a.judd@gmail.com> @samajudd, +++ b/library/src/com/bumptech/glide/Glide.java, +        if (tag != null && tag instanceof ImageViewTarget) {, +            ImagePresenter<T> result = target.getImagePresenter();, +++ b/library/src/com/bumptech/glide/presenter/target/ImageViewTarget.java, + * A target wrapping an ImageView that makes use of {@link ImageView#setTag(Object)} to store and retrieve, + * ImagePresenters. Also obtains the runtime dimensions of the ImageView., +    /**, +     * TODO: use {@link View#setTag(int, Object)} when we can do so and still create, +     * a jar, +     */, +++ b/library/src/com/bumptech/glide/resize/ImageManager.java, +import java.io.UnsupportedEncodingException;, +import java.nio.ByteBuffer;, +import java.security.MessageDigest;, +import java.security.NoSuchAlgorithmException;, +import java.util.HashMap;, +import java.util.Map;, +    private final SafeKeyGenerator safeKeyGenerator = new SafeKeyGenerator();, +        final String key = safeKeyGenerator.getSafeKey(id, transformation, downsampler, width, height);, +++ b/library/src/com/bumptech/glide/resize/SafeKeyGenerator.java, +package com.bumptech.glide.resize;, +, +import android.os.Build;, +import com.bumptech.glide.resize.load.Downsampler;, +import com.bumptech.glide.resize.load.Transformation;, +import com.bumptech.glide.util.Util;, +, +import java.io.UnsupportedEncodingException;, +import java.nio.ByteBuffer;, +import java.security.MessageDigest;, +import java.security.NoSuchAlgorithmException;, +import java.util.ArrayDeque;, +import java.util.HashMap;, +import java.util.LinkedList;, +import java.util.Map;, +import java.util.Queue;, +, +public class SafeKeyGenerator {, +    private final Map<LoadId, String> loadIdToSafeHash = new HashMap<LoadId, String>();, +    private final ByteBuffer byteBuffer = ByteBuffer.allocate(8);, +    private final LoadIdPool loadIdPool = new LoadIdPool();, +    private MessageDigest messageDigest;, +, +    public SafeKeyGenerator() {, +        try {, +            messageDigest = MessageDigest.getInstance("SHA-256");, +        } catch (NoSuchAlgorithmException e) {, +            e.printStackTrace();, +        }, +    }, +, +    public String getSafeKey(String id, Transformation transformation, Downsampler downsampler, int width, int height) {]
[+++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +    public BitmapRequestBuilder<ModelType, TranscodeType> diskCacheStrategy(DiskCacheStrategy  strategy) {, +        super.diskCacheStrategy(strategy);, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +    public BitmapRequestBuilder<ModelType, TranscodeType> diskCacheStrategy(DiskCacheStrategy  strategy) {, +        super.diskCacheStrategy(strategy);, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +    public DrawableRequestBuilder<ModelType> listener(RequestListener<ModelType, Drawable> requestListener) {, +    public DrawableRequestBuilder<ModelType> diskCacheStrategy(DiskCacheStrategy strategy) {, +        super.diskCacheStrategy(strategy);, +        return this;, +    }, +, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +    public BitmapRequestBuilder<ModelType, TranscodeType> diskCacheStrategy(DiskCacheStrategy  strategy) {, +        super.diskCacheStrategy(strategy);, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +    public DrawableRequestBuilder<ModelType> listener(RequestListener<ModelType, Drawable> requestListener) {, +    public DrawableRequestBuilder<ModelType> diskCacheStrategy(DiskCacheStrategy strategy) {, +        super.diskCacheStrategy(strategy);, +        return this;, +    }, +, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +    private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.RESULT;, +     * Sets the {@link com.bumptech.glide.load.engine.DiskCacheStrategy} to use for this load. Defaults to, +     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESULT}., +     *     For most applications {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESULT} is ideal., +     *     Applications that use the same image multiple times in multiple sizes and are willing to trade off some, +     *     speed and disk space in return for lower bandwidth usage may want to consider using, +     *     {@link com.bumptech.glide.load.engine.DiskCacheStrategy#SOURCE} or, +     *     {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESULT}. Any download only operations should, +     *     typically use {@link com.bumptech.glide.load.engine.DiskCacheStrategy#SOURCE}., +     * @param strategy The strategy to use., +    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType>  diskCacheStrategy(, +            DiskCacheStrategy strategy) {, +        this.diskCacheStrategy = strategy;, +, +        return this;, +                diskCacheStrategy);, +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +    public BitmapRequestBuilder<ModelType, TranscodeType> diskCacheStrategy(DiskCacheStrategy  strategy) {, +        super.diskCacheStrategy(strategy);, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +    public DrawableRequestBuilder<ModelType> listener(RequestListener<ModelType, Drawable> requestListener) {, +    public DrawableRequestBuilder<ModelType> diskCacheStrategy(DiskCacheStrategy strategy) {, +        super.diskCacheStrategy(strategy);, +        return this;, +    }, +, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +    private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.RESULT;, +     * Sets the {@link com.bumptech.glide.load.engine.DiskCacheStrategy} to use for this load. Defaults to, +     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESULT}., +     *     For most applications {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESULT} is ideal., +     *     Applications that use the same image multiple times in multiple sizes and are willing to trade off some, +     *     speed and disk space in return for lower bandwidth usage may want to consider using, +     *     {@link com.bumptech.glide.load.engine.DiskCacheStrategy#SOURCE} or, +     *     {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESULT}. Any download only operations should, +     *     typically use {@link com.bumptech.glide.load.engine.DiskCacheStrategy#SOURCE}., +     * @param strategy The strategy to use., +    public GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType>  diskCacheStrategy(, +            DiskCacheStrategy strategy) {, +        this.diskCacheStrategy = strategy;, +, +        return this;, +                diskCacheStrategy);, +++ b/library/src/main/java/com/bumptech/glide/GenericTranscodeRequest.java, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +                .diskCacheStrategy(DiskCacheStrategy.SOURCE), +++ b/library/src/main/java/com/bumptech/glide/BitmapRequestBuilder.java, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +    public BitmapRequestBuilder<ModelType, TranscodeType> diskCacheStrategy(DiskCacheStrategy  strategy) {, +        super.diskCacheStrategy(strategy);, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +    public DrawableRequestBuilder<ModelType> listener(RequestListener<ModelType, Drawable> requestListener) {, +    public DrawableRequestBuilder<ModelType> diskCacheStrategy(DiskCacheStrategy strategy) {, +        super.diskCacheStrategy(strategy);, +        return this;, +    }, +, +    @Override, +++ b/library/src/main/java/com/bumptech/glide/GenericRequestBuilder.java, +import com.bumptech.glide.load.engine.DiskCacheStrategy;, +    private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.RESULT;, +     * Sets the {@link com.bumptech.glide.load.engine.DiskCacheStrategy} to use for this load. Defaults to, +     * {@link com.bumptech.glide.load.engine.DiskCacheStrategy#RESULT}.]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;, +    registry = new Registry();, +    registry.register(new DefaultImageHeaderParser());, +, +    Downsampler downsampler = new Downsampler(registry.getImageHeaderParsers(),, +        resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);, +, +    registry.register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;, +    registry = new Registry();, +    registry.register(new DefaultImageHeaderParser());, +, +    Downsampler downsampler = new Downsampler(registry.getImageHeaderParsers(),, +        resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);, +, +    registry.register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +import com.bumptech.glide.load.ImageHeaderParser;, +import com.bumptech.glide.provider.ImageHeaderParserRegistry;, +  private final ImageHeaderParserRegistry imageHeaderParserRegistry;, +    this.imageHeaderParserRegistry = new ImageHeaderParserRegistry();, +  public Registry register(ImageHeaderParser parser) {, +    imageHeaderParserRegistry.add(parser);, +    return this;, +  }, +, +  public List<ImageHeaderParser> getImageHeaderParsers() {, +    List<ImageHeaderParser> result = imageHeaderParserRegistry.getParsers();, +    if (result.isEmpty()) {, +      throw new NoImageHeaderParserException();, +    }, +    return result;, +  }, +, +, +  /**, +   * Thrown when no {@link ImageHeaderParser} is registered., +   */, +  public static final class NoImageHeaderParserException extends MissingComponentException {, +    public NoImageHeaderParserException() {, +      super("Failed to find image header parser.");, +    }, +  }, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.bitmap.DefaultImageHeaderParser;, +    registry = new Registry();, +    registry.register(new DefaultImageHeaderParser());, +, +    Downsampler downsampler = new Downsampler(registry.getImageHeaderParsers(),, +        resources.getDisplayMetrics(), bitmapPool, arrayPool);, +        new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool);, +, +    registry.register(ByteBuffer.class, new ByteBufferEncoder()), +            new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool)), +++ b/library/src/main/java/com/bumptech/glide/Registry.java, +import com.bumptech.glide.load.ImageHeaderParser;, +import com.bumptech.glide.provider.ImageHeaderParserRegistry;, +  private final ImageHeaderParserRegistry imageHeaderParserRegistry;, +    this.imageHeaderParserRegistry = new ImageHeaderParserRegistry();, +  public Registry register(ImageHeaderParser parser) {, +    imageHeaderParserRegistry.add(parser);, +    return this;, +  }, +, +  public List<ImageHeaderParser> getImageHeaderParsers() {, +    List<ImageHeaderParser> result = imageHeaderParserRegistry.getParsers();, +    if (result.isEmpty()) {, +      throw new NoImageHeaderParserException();, +    }, +    return result;, +  }, +, +, +  /**, +   * Thrown when no {@link ImageHeaderParser} is registered., +   */, +  public static final class NoImageHeaderParserException extends MissingComponentException {, +    public NoImageHeaderParserException() {, +      super("Failed to find image header parser.");, +    }, +  }, +++ b/library/src/main/java/com/bumptech/glide/load/ImageHeaderParser.java, +package com.bumptech.glide.load;, +, +import com.bumptech.glide.load.engine.bitmap_recycle.ArrayPool;, +import java.io.IOException;, +import java.io.InputStream;, +import java.nio.ByteBuffer;, +, +/**, + * Interface for the ImageHeaderParser., + */, +public interface ImageHeaderParser {, +  /**]
[+++ b/build.gradle, +        // TODO: remove this when robolectric 2.4 is released., +        maven {, +            url 'https://oss.sonatype.org/content/repositories/snapshots', +        }, +        // TODO: remove this when robolectric 2.4 is released., +        maven {, +            url 'https://oss.sonatype.org/content/repositories/snapshots', +        }, +++ b/build.gradle, +        // TODO: remove this when robolectric 2.4 is released., +        maven {, +            url 'https://oss.sonatype.org/content/repositories/snapshots', +        }, +        // TODO: remove this when robolectric 2.4 is released., +        maven {, +            url 'https://oss.sonatype.org/content/repositories/snapshots', +        }, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=2.4-SNAPSHOT, +++ b/build.gradle, +        // TODO: remove this when robolectric 2.4 is released., +        maven {, +            url 'https://oss.sonatype.org/content/repositories/snapshots', +        }, +        // TODO: remove this when robolectric 2.4 is released., +        maven {, +            url 'https://oss.sonatype.org/content/repositories/snapshots', +        }, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=2.4-SNAPSHOT, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +    public void testCacheIsChecked() {, +, +, +        boolean isMemoryCacheable;, +            when(engineJobFactory.build(eq(cacheKey), eq(isMemoryCacheable))).thenReturn(job);, +++ b/build.gradle, +        // TODO: remove this when robolectric 2.4 is released., +        maven {, +            url 'https://oss.sonatype.org/content/repositories/snapshots', +        }, +        // TODO: remove this when robolectric 2.4 is released., +        maven {, +            url 'https://oss.sonatype.org/content/repositories/snapshots', +        }, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=2.4-SNAPSHOT, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +    public void testCacheIsChecked() {, +, +, +        boolean isMemoryCacheable;, +            when(engineJobFactory.build(eq(cacheKey), eq(isMemoryCacheable))).thenReturn(job);, +++ /dev/null, +++ b/build.gradle, +        // TODO: remove this when robolectric 2.4 is released., +        maven {, +            url 'https://oss.sonatype.org/content/repositories/snapshots', +        }, +        // TODO: remove this when robolectric 2.4 is released., +        maven {, +            url 'https://oss.sonatype.org/content/repositories/snapshots', +        }, +++ b/gradle.properties, +ROBOLECTRIC_VERSION=2.4-SNAPSHOT, +++ b/library/src/androidTest/java/com/bumptech/glide/load/engine/EngineTest.java, +    public void testCacheIsChecked() {, +, +, +        boolean isMemoryCacheable;, +            when(engineJobFactory.build(eq(cacheKey), eq(isMemoryCacheable))).thenReturn(job);, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifDrawableTest.java, +    private GifFrameManager frameManager = mock(GifFrameManager.class);, +    private Drawable.Callback cb = mock(Drawable.Callback.class);, +        drawable = new GifDrawable(gifDecoder, frameManager, firstFrame, bitmapPool);, +        drawable = new GifDrawable(gifDecoder, frameManager, firstFrame, bitmapPool);, +        drawable.onFrameRead(0);, +        when(frameManager.getCurrentFrame()).thenReturn(null);, +        drawable = new GifDrawable(gifDecoder, frameManager, null, bitmapPool);, +        when(frameManager.getCurrentFrame()).thenReturn(currentFrame);, +        verify(frameManager).getNextFrame(eq(drawable));, +        verify(frameManager).getNextFrame(eq(drawable));, +        verify(frameManager, never()).getNextFrame(any(GifFrameManager.FrameCallback.class));, +        verify(frameManager, never()).getNextFrame(any(GifFrameManager.FrameCallback.class));, +        verify(frameManager, times(1)).getNextFrame(eq(drawable));, +    public void testStartsLoadingNextFrameWhenCurrentFinishes() {, +        drawable.setIsRunning(true);, +        drawable.onFrameRead(0);, +, +        verify(frameManager).getNextFrame(eq(drawable));, +    }, +, +    @Test, +        drawable.onFrameRead(0);, +    public void testDoesNotStartLoadingNextFrameWhenCurrentFinishesIfNotRunning() {, +        drawable.setIsRunning(false);, +        drawable.onFrameRead(0);, +]
[+++ b/gradle.properties, +VERSION_NAME=4.1.1, +VERSION_MINOR=1, +VERSION_PATCH=1]
[+++ b/library/AndroidManifest.xml, +          android:versionCode="5", +          android:versionName="3.2.0a" >]
[+++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, +    return SourceVersion.latestSupported();]
[+++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.image.ImageManagerLoader;, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.image.ImageManagerLoader;, +++ b/library/src/com/bumptech/glide/loader/image/ImageManagerLoader.java, +package com.bumptech.glide.loader.image;, +, +import android.content.Context;, +import android.graphics.Bitmap;, +import com.bumptech.glide.Glide;, +import com.bumptech.glide.loader.stream.StreamLoader;, +import com.bumptech.glide.resize.Downsampler;, +import com.bumptech.glide.resize.Transformation;, +import com.bumptech.glide.resize.ImageManager;, +import com.bumptech.glide.resize.LoadedCallback;, +, +import static android.view.ViewGroup.LayoutParams.WRAP_CONTENT;, +, +/**, + * A base class for loaders that user ImageManager. Primarily responsible for keeping track of bitmaps for recycling, + * purposes., + */, +public class ImageManagerLoader implements ImageLoader {, +, +    protected final ImageManager imageManager;, +    private final Downsampler downsampler;, +    private Bitmap acquired;, +    private Object loadToken;, +, +    public ImageManagerLoader(Context context) {, +        this(context, Downsampler.AT_LEAST);, +    }, +, +    public ImageManagerLoader(ImageManager imageManager) {, +        this(imageManager, Downsampler.AT_LEAST);, +    }, +, +    public ImageManagerLoader(Context context, Downsampler downsampler) {, +        this(Glide.get().getImageManager(context), downsampler);, +    }, +, +    public ImageManagerLoader(ImageManager imageManager, Downsampler downsampler) {, +        this.imageManager = imageManager;, +        this.downsampler = downsampler;, +    }, +, +    @Override, +    public Object fetchImage(String id, StreamLoader streamLoader, Transformation transformation, int width, int height, final ImageReadyCallback cb) {, +        if (!isHandled(width, height)) {, +            throw new IllegalArgumentException(getClass() + " cannot handle width=" + width + " and/or height =" +, +                    height);, +        }, +        loadToken = imageManager.getImage(id, streamLoader, transformation, downsampler, width, height, new LoadedCallback() {, +, +            @Override, +            public void onLoadCompleted(Bitmap loaded) {, +                onImageReady(loaded, cb.onImageReady(loaded));, +            }, +, +            @Override, +            public void onLoadFailed(Exception e) {, +                cb.onException(e);, +            }, +        });, +        return loadToken;, +    }, +, +    protected void onImageReady(Bitmap image, boolean isUsed) {, +        if (isUsed) {, +            releaseAcquired();, +            imageManager.acquireBitmap(image);, +            acquired = image;, +        } else {, +            imageManager.rejectBitmap(image);, +        }, +    }, +, +    @Override, +    public void clear() {, +        releaseAcquired();, +        if (loadToken != null) {, +            imageManager.cancelTask(loadToken);, +            loadToken = null;, +        }, +    }, +, +    private void releaseAcquired() {, +        if (acquired != null) {, +            imageManager.releaseBitmap(acquired);, +            acquired = null;, +        }, +    }, +, +    protected boolean isHandled(int width, int height) {, +        return width >= 0 && height >= 0 ||, +                (downsampler == Downsampler.NONE && width == WRAP_CONTENT && height == WRAP_CONTENT);, +    }, +}, +++ b/library/src/com/bumptech/glide/Glide.java, +import com.bumptech.glide.loader.image.ImageManagerLoader;]
[+++ b/samples/flickr/src/main/AndroidManifest.xml, +    <uses-sdk android:minSdkVersion="10", +      android:targetSdkVersion="19" />, +, +, +++ b/samples/flickr/src/main/AndroidManifest.xml, +    <uses-sdk android:minSdkVersion="10", +      android:targetSdkVersion="19" />, +, +, +++ b/samples/gallery/src/main/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="19", +    android:targetSdkVersion="19" />, +++ b/samples/flickr/src/main/AndroidManifest.xml, +    <uses-sdk android:minSdkVersion="10", +      android:targetSdkVersion="19" />, +, +, +++ b/samples/gallery/src/main/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="19", +    android:targetSdkVersion="19" />, +++ b/samples/giphy/src/main/AndroidManifest.xml, +    <uses-sdk android:minSdkVersion="10", +      android:targetSdkVersion="19" />, +++ b/samples/flickr/src/main/AndroidManifest.xml, +    <uses-sdk android:minSdkVersion="10", +      android:targetSdkVersion="19" />, +, +, +++ b/samples/gallery/src/main/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="19", +    android:targetSdkVersion="19" />, +++ b/samples/giphy/src/main/AndroidManifest.xml, +    <uses-sdk android:minSdkVersion="10", +      android:targetSdkVersion="19" />]
[+++ b/library/src/com/bumptech/photos/loader/opener/FileInputStreamsOpener.java, +package com.bumptech.photos.loader.opener;, +, +import java.io.File;, +import java.io.FileInputStream;, +import java.io.IOException;, +, +/**, + * Created with IntelliJ IDEA., + * User: sam, + * Date: 7/10/13, + * Time: 11:11 PM, + * To change this template use File | Settings | File Templates., + */, +public class FileInputStreamsOpener implements StreamOpener {, +    private final File file;, +, +    public FileInputStreamsOpener(String path) {, +        this(new File(path));, +    }, +, +    public FileInputStreamsOpener(File file) {, +        this.file = file;, +    }, +, +    @Override, +    public Streams openStreams() throws IOException {, +        return new Streams(new FileInputStream(file), new FileInputStream(file));, +    }, +, +    @Override, +    public void cleanup() { }, +}, +++ b/library/src/com/bumptech/photos/loader/opener/FileInputStreamsOpener.java, +package com.bumptech.photos.loader.opener;, +, +import java.io.File;, +import java.io.FileInputStream;, +import java.io.IOException;, +, +/**, + * Created with IntelliJ IDEA., + * User: sam, + * Date: 7/10/13, + * Time: 11:11 PM, + * To change this template use File | Settings | File Templates., + */, +public class FileInputStreamsOpener implements StreamOpener {, +    private final File file;, +, +    public FileInputStreamsOpener(String path) {, +        this(new File(path));, +    }, +, +    public FileInputStreamsOpener(File file) {, +        this.file = file;, +    }, +, +    @Override, +    public Streams openStreams() throws IOException {, +        return new Streams(new FileInputStream(file), new FileInputStream(file));, +    }, +, +    @Override, +    public void cleanup() { }, +}, +++ /dev/null, +++ b/library/src/com/bumptech/photos/loader/opener/FileInputStreamsOpener.java, +package com.bumptech.photos.loader.opener;, +, +import java.io.File;, +import java.io.FileInputStream;, +import java.io.IOException;, +, +/**, + * Created with IntelliJ IDEA., + * User: sam, + * Date: 7/10/13, + * Time: 11:11 PM, + * To change this template use File | Settings | File Templates., + */, +public class FileInputStreamsOpener implements StreamOpener {, +    private final File file;, +, +    public FileInputStreamsOpener(String path) {, +        this(new File(path));, +    }, +, +    public FileInputStreamsOpener(File file) {, +        this.file = file;, +    }, +, +    @Override, +    public Streams openStreams() throws IOException {, +        return new Streams(new FileInputStream(file), new FileInputStream(file));, +    }, +, +    @Override, +    public void cleanup() { }, +}]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestOptions.java]
[+++ b/library/src/main/java/com/bumptech/glide/request/target/ImageViewTarget.java, +    } else {, +      animatable = null;]
[+++ b/annotation/compiler/build.gradle, +++ b/annotation/compiler/build.gradle, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, +  private boolean isGeneratedAppGlideModulePending;, +//    if (set.isEmpty() && !isGeneratedAppGlideModulePending) {, +//      return false;, +//    }, +      isGeneratedAppGlideModulePending = true;, +++ b/annotation/compiler/build.gradle, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, +  private boolean isGeneratedAppGlideModulePending;, +//    if (set.isEmpty() && !isGeneratedAppGlideModulePending) {, +//      return false;, +//    }, +      isGeneratedAppGlideModulePending = true;, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +          + " RequestBuilder object as their first and only parameter, but given multiple for: ", +    TypeMirror argumentType = first.asType();, +    if (!argumentType.toString().startsWith("com.bumptech.glide.RequestBuilder")) {, +          + " RequestBuilder object as their first and only parameter, but given: " + argumentType);, +++ b/annotation/compiler/build.gradle, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, +  private boolean isGeneratedAppGlideModulePending;, +//    if (set.isEmpty() && !isGeneratedAppGlideModulePending) {, +//      return false;, +//    }, +      isGeneratedAppGlideModulePending = true;, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +          + " RequestBuilder object as their first and only parameter, but given multiple for: ", +    TypeMirror argumentType = first.asType();, +    if (!argumentType.toString().startsWith("com.bumptech.glide.RequestBuilder")) {, +          + " RequestBuilder object as their first and only parameter, but given: " + argumentType);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java, +    String visibleForTestingTypeQualifiedName =, +            .getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME), +            .toString();, +      String annotationQualfiedName = mirror.getAnnotationType().toString();, +      if (annotationQualfiedName.equals(visibleForTestingTypeQualifiedName)) {, +++ b/annotation/compiler/build.gradle, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, +  private boolean isGeneratedAppGlideModulePending;, +//    if (set.isEmpty() && !isGeneratedAppGlideModulePending) {, +//      return false;, +//    }, +      isGeneratedAppGlideModulePending = true;, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +          + " RequestBuilder object as their first and only parameter, but given multiple for: ", +    TypeMirror argumentType = first.asType();, +    if (!argumentType.toString().startsWith("com.bumptech.glide.RequestBuilder")) {, +          + " RequestBuilder object as their first and only parameter, but given: " + argumentType);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java, +    String visibleForTestingTypeQualifiedName =, +            .getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME), +            .toString();, +      String annotationQualfiedName = mirror.getAnnotationType().toString();, +      if (annotationQualfiedName.equals(visibleForTestingTypeQualifiedName)) {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +  void error(String toLog) {, +    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, toLog);, +  }, +, +      if (excludedModuleAnnotationValue == null, +          || excludedModuleAnnotationValue instanceof Attribute.UnresolvedClass) {, +        throw new IllegalArgumentException(, +            "Failed to find value for: " + annotationClass + " from mirrors: ", +                + clazz.getAnnotationMirrors());, +++ b/annotation/compiler/build.gradle, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideAnnotationProcessor.java, +  private boolean isGeneratedAppGlideModulePending;, +//    if (set.isEmpty() && !isGeneratedAppGlideModulePending) {, +//      return false;, +//    }, +      isGeneratedAppGlideModulePending = true;, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideExtensionValidator.java, +          + " RequestBuilder object as their first and only parameter, but given multiple for: ", +    TypeMirror argumentType = first.asType();, +    if (!argumentType.toString().startsWith("com.bumptech.glide.RequestBuilder")) {, +          + " RequestBuilder object as their first and only parameter, but given: " + argumentType);, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/GlideGenerator.java, +    String visibleForTestingTypeQualifiedName =, +            .getTypeElement(VISIBLE_FOR_TESTING_QUALIFIED_NAME), +            .toString();, +      String annotationQualfiedName = mirror.getAnnotationType().toString();, +      if (annotationQualfiedName.equals(visibleForTestingTypeQualifiedName)) {, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/ProcessorUtil.java, +  void error(String toLog) {, +    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, toLog);, +  }, +, +      if (excludedModuleAnnotationValue == null, +          || excludedModuleAnnotationValue instanceof Attribute.UnresolvedClass) {, +        throw new IllegalArgumentException(, +            "Failed to find value for: " + annotationClass + " from mirrors: ", +                + clazz.getAnnotationMirrors());, +++ b/annotation/compiler/src/main/java/com/bumptech/glide/annotation/compiler/RequestOptionsGenerator.java, +    MethodAndStaticVar methodAndVar = generateStaticMethodEquivalentForExtensionMethod(element);, +    if (methodAndVar != null) {, +      result.add(methodAndVar);, +    }, +  @Nullable]
[+++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.jar, +++ b/gradle/wrapper/gradle-wrapper.properties, +distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-all.zip]
[+++ b/checkstyle.xml, +        <module name="ImportOrder">, +          <!-- Checks for out of order import statements. -->, +, +           <property name="severity" value="error"/>, +           <property name="groups" value="com.google,*,java,javax"/>, +           <!-- This ensures that static imports go first. -->, +           <property name="option" value="top"/>, +           <property name="tokens" value="STATIC_IMPORT, IMPORT"/>, +         </module>, +++ b/checkstyle.xml, +        <module name="ImportOrder">, +          <!-- Checks for out of order import statements. -->, +, +           <property name="severity" value="error"/>, +           <property name="groups" value="com.google,*,java,javax"/>, +           <!-- This ensures that static imports go first. -->, +           <property name="option" value="top"/>, +           <property name="tokens" value="STATIC_IMPORT, IMPORT"/>, +         </module>, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +, +++ b/checkstyle.xml, +        <module name="ImportOrder">, +          <!-- Checks for out of order import statements. -->, +, +           <property name="severity" value="error"/>, +           <property name="groups" value="com.google,*,java,javax"/>, +           <!-- This ensures that static imports go first. -->, +           <property name="option" value="top"/>, +           <property name="tokens" value="STATIC_IMPORT, IMPORT"/>, +         </module>, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +, +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.google.common.truth.Truth.assertThat;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.fail;, +, +, +, +++ b/checkstyle.xml, +        <module name="ImportOrder">, +          <!-- Checks for out of order import statements. -->, +, +           <property name="severity" value="error"/>, +           <property name="groups" value="com.google,*,java,javax"/>, +           <!-- This ensures that static imports go first. -->, +           <property name="option" value="top"/>, +           <property name="tokens" value="STATIC_IMPORT, IMPORT"/>, +         </module>, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +, +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.google.common.truth.Truth.assertThat;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.fail;, +, +, +, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +++ b/checkstyle.xml, +        <module name="ImportOrder">, +          <!-- Checks for out of order import statements. -->, +, +           <property name="severity" value="error"/>, +           <property name="groups" value="com.google,*,java,javax"/>, +           <!-- This ensures that static imports go first. -->, +           <property name="option" value="top"/>, +           <property name="tokens" value="STATIC_IMPORT, IMPORT"/>, +         </module>, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +, +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.google.common.truth.Truth.assertThat;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.fail;, +, +, +, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyStreamFetcher.java, +++ b/integration/volley/src/main/java/com/bumptech/glide/integration/volley/VolleyUrlLoader.java, +, +import com.bumptech.glide.load.data.DataFetcher;, +++ b/checkstyle.xml, +        <module name="ImportOrder">, +          <!-- Checks for out of order import statements. -->, +, +           <property name="severity" value="error"/>, +           <property name="groups" value="com.google,*,java,javax"/>, +           <!-- This ensures that static imports go first. -->, +           <property name="option" value="top"/>, +           <property name="tokens" value="STATIC_IMPORT, IMPORT"/>, +         </module>, +++ b/integration/okhttp/src/main/java/com/bumptech/glide/integration/okhttp/OkHttpUrlLoader.java, +, +++ b/integration/volley/src/androidTest/java/com/bumptech/glide/integration/volley/VolleyStreamFetcherServerTest.java, +import static com.google.common.truth.Truth.assertThat;, +import static org.junit.Assert.assertEquals;, +import static org.junit.Assert.fail;]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    VideoBitmapDecoder videoBitmapDecoder = new VideoBitmapDecoder(bitmapPool);, +    ByteBufferBitmapDecoder byteBufferBitmapDecoder = new ByteBufferBitmapDecoder(downsampler);, +    StreamBitmapDecoder streamBitmapDecoder = new StreamBitmapDecoder(downsampler, arrayPool);, +    ResourceDrawableDecoder resourceDrawableDecoder =, +        new ResourceDrawableDecoder(context, bitmapPool);, +    ResourceLoader.StreamFactory resourceLoaderStreamFactory =, +        new ResourceLoader.StreamFactory(resources);, +    ResourceLoader.UriFactory resourceLoaderUriFactory =, +        new ResourceLoader.UriFactory(resources);, +    ResourceLoader.FileDescriptorFactory resourceLoaderFileDescriptorFactory =, +        new ResourceLoader.FileDescriptorFactory(resources);, +    BitmapEncoder bitmapEncoder = new BitmapEncoder();, +        .append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class, byteBufferBitmapDecoder), +        .append(Registry.BUCKET_BITMAP, InputStream.class, Bitmap.class, streamBitmapDecoder), +        .append(, +            Registry.BUCKET_BITMAP, ParcelFileDescriptor.class, Bitmap.class, videoBitmapDecoder), +        .append(Bitmap.class, bitmapEncoder), +        /* BitmapDrawables */, +        .append(, +            Registry.BUCKET_BITMAP_DRAWABLE,, +            ByteBuffer.class,, +            BitmapDrawable.class,, +            new BitmapDrawableDecoder<>(resources, bitmapPool, byteBufferBitmapDecoder)), +        .append(, +            Registry.BUCKET_BITMAP_DRAWABLE,, +            InputStream.class,, +            BitmapDrawable.class,, +            new BitmapDrawableDecoder<>(resources, bitmapPool, streamBitmapDecoder)), +        .append(, +            Registry.BUCKET_BITMAP_DRAWABLE,, +            ParcelFileDescriptor.class,, +            BitmapDrawable.class,, +            new BitmapDrawableDecoder<>(resources, bitmapPool, videoBitmapDecoder)), +        .append(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, bitmapEncoder)), +        .append(, +            Registry.BUCKET_GIF,, +            InputStream.class,, +            GifDrawable.class,, +        .append(, +            GifDecoder.class, GifDecoder.class, UnitModelLoader.Factory.<GifDecoder>getInstance()), +        .append(, +            Registry.BUCKET_BITMAP,, +            GifDecoder.class,, +            Bitmap.class,, +        .append(Uri.class, Drawable.class, resourceDrawableDecoder), +        .append(, +            Uri.class, Bitmap.class, new ResourceBitmapDecoder(resourceDrawableDecoder, bitmapPool)), +        .append(File.class, File.class, UnitModelLoader.Factory.<File>getInstance()), +        .append(int.class, InputStream.class, resourceLoaderStreamFactory), +                resourceLoaderFileDescriptorFactory), +        .append(Integer.class, InputStream.class, resourceLoaderStreamFactory), +                resourceLoaderFileDescriptorFactory), +        .append(Integer.class, Uri.class, resourceLoaderUriFactory), +        .append(int.class, Uri.class, resourceLoaderUriFactory), +        .append(Uri.class, Uri.class, UnitModelLoader.Factory.<Uri>getInstance()), +        .register(, +            Bitmap.class,, +            BitmapDrawable.class,, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +    VideoBitmapDecoder videoBitmapDecoder = new VideoBitmapDecoder(bitmapPool);, +    ByteBufferBitmapDecoder byteBufferBitmapDecoder = new ByteBufferBitmapDecoder(downsampler);, +    StreamBitmapDecoder streamBitmapDecoder = new StreamBitmapDecoder(downsampler, arrayPool);, +    ResourceDrawableDecoder resourceDrawableDecoder =, +        new ResourceDrawableDecoder(context, bitmapPool);, +    ResourceLoader.StreamFactory resourceLoaderStreamFactory =, +        new ResourceLoader.StreamFactory(resources);, +    ResourceLoader.UriFactory resourceLoaderUriFactory =, +        new ResourceLoader.UriFactory(resources);, +    ResourceLoader.FileDescriptorFactory resourceLoaderFileDescriptorFactory =, +        new ResourceLoader.FileDescriptorFactory(resources);, +    BitmapEncoder bitmapEncoder = new BitmapEncoder();, +        .append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class, byteBufferBitmapDecoder), +        .append(Registry.BUCKET_BITMAP, InputStream.class, Bitmap.class, streamBitmapDecoder), +        .append(, +            Registry.BUCKET_BITMAP, ParcelFileDescriptor.class, Bitmap.class, videoBitmapDecoder), +        .append(Bitmap.class, bitmapEncoder), +        /* BitmapDrawables */, +        .append(, +            Registry.BUCKET_BITMAP_DRAWABLE,, +            ByteBuffer.class,, +            BitmapDrawable.class,, +            new BitmapDrawableDecoder<>(resources, bitmapPool, byteBufferBitmapDecoder)), +        .append(, +            Registry.BUCKET_BITMAP_DRAWABLE,, +            InputStream.class,, +            BitmapDrawable.class,, +            new BitmapDrawableDecoder<>(resources, bitmapPool, streamBitmapDecoder)), +        .append(, +            Registry.BUCKET_BITMAP_DRAWABLE,, +            ParcelFileDescriptor.class,, +            BitmapDrawable.class,, +            new BitmapDrawableDecoder<>(resources, bitmapPool, videoBitmapDecoder)), +        .append(BitmapDrawable.class, new BitmapDrawableEncoder(bitmapPool, bitmapEncoder)), +        .append(, +            Registry.BUCKET_GIF,, +            InputStream.class,, +            GifDrawable.class,, +        .append(, +            GifDecoder.class, GifDecoder.class, UnitModelLoader.Factory.<GifDecoder>getInstance())]
[+++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]gif_encoder[/\\].*" checks=".*"/>, +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]gif_encoder[/\\].*" checks=".*"/>, +++ b/library/build.gradle, +    compile project(':third_party:gif_encoder'), +++ b/checkstyle_suppressions.xml, +    <suppress files=".*[/\\]gif_encoder[/\\].*" checks=".*"/>, +++ b/library/build.gradle, +    compile project(':third_party:gif_encoder'), +++ b/library/src/androidTest/java/com/bumptech/glide/load/resource/gif/GifResourceEncoderTest.java, +import android.graphics.Bitmap;, +import com.bumptech.glide.gifdecoder.GifDecoder;, +import com.bumptech.glide.gifdecoder.GifHeader;, +import com.bumptech.glide.gifdecoder.GifHeaderParser;, +import com.bumptech.glide.gifencoder.AnimatedGifEncoder;, +import com.bumptech.glide.load.Transformation;, +import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;, +import org.mockito.InOrder;, +import static org.mockito.Matchers.any;, +import static org.mockito.Matchers.anyInt;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.inOrder;, +import static org.mockito.Mockito.verify;, +    private GifDecoder decoder;, +    private GifHeaderParser parser;, +    private AnimatedGifEncoder gifEncoder;, +    private Resource<Bitmap> frameResource;, +    private Transformation frameTransformation;, +, +        GifResourceEncoder.Factory factory = mock(GifResourceEncoder.Factory.class);, +        decoder = mock(GifDecoder.class);, +        when(factory.buildDecoder(any(GifDecoder.BitmapProvider.class))).thenReturn(decoder);, +        parser = mock(GifHeaderParser.class);, +        when(factory.buildParser()).thenReturn(parser);, +        gifEncoder = mock(AnimatedGifEncoder.class);, +        when(factory.buildEncoder()).thenReturn(gifEncoder);, +        frameResource = mock(Resource.class);, +        when(factory.buildFrameResource(any(Bitmap.class), any(BitmapPool.class))).thenReturn(frameResource);, +, +        frameTransformation = mock(Transformation.class);, +        when(frameTransformation.transform(any(Resource.class), anyInt(), anyInt())).thenReturn(frameResource);, +, +        when(gifDrawable.getFrameTransformation()).thenReturn(frameTransformation);, +, +, +        encoder = new GifResourceEncoder(mock(BitmapPool.class), factory);, +    public void testReturnsFalseIfEncoderFailsToStart() {, +        OutputStream os = mock(OutputStream.class);, +        when(gifEncoder.start(eq(os))).thenReturn(false);, +        assertFalse(encoder.encode(resource, mock(OutputStream.class)));, +    public void testSetsDataOnParserBeforeParsingHeader() {, +        byte[] data = new byte[1];, +        when(gifDrawable.getData()).thenReturn(data);, +, +        GifHeader header = mock(GifHeader.class);, +        when(parser.parseHeader()).thenReturn(header);, +, +        encoder.encode(resource, mock(OutputStream.class));, +, +        InOrder order = inOrder(parser, decoder);, +        order.verify(parser).setData(eq(data));, +        order.verify(parser).parseHeader();, +        order.verify(decoder).setData(header, data);, +    public void testAdvancesDecoderBeforeAttemptingToGetFirstFrame() {, +        when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);, +        when(decoder.getFrameCount()).thenReturn(1);, +        when(decoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888));, +        encoder.encode(resource, mock(OutputStream.class));, +, +        InOrder order = inOrder(decoder);, +        order.verify(decoder).advance();, +        order.verify(decoder).getNextFrame();, +    }, +, +    @Test, +    public void testSetsDelayOnEncoderAfterAddingFrame() {, +        when(gifEncoder.start(any(OutputStream.class))).thenReturn(true);, +        when(gifEncoder.addFrame(any(Bitmap.class))).thenReturn(true);, +, +        when(decoder.getFrameCount()).thenReturn(1);, +        when(decoder.getNextFrame()).thenReturn(Bitmap.createBitmap(100, 100, Bitmap.Config.RGB_565));, +        int expectedIndex = 34;, +        when(decoder.getCurrentFrameIndex()).thenReturn(expectedIndex);, +        int expectedDelay = 5000;, +        when(decoder.getDelay(eq(expectedIndex))).thenReturn(expectedDelay);, +, +        encoder.encode(resource, mock(OutputStream.class));, +, +        InOrder order = inOrder(gifEncoder, decoder);, +        order.verify(decoder).advance();, +        order.verify(gifEncoder).addFrame(any(Bitmap.class));, +        order.verify(gifEncoder).setDelay(eq(expectedDelay));, +        order.verify(decoder).advance();, +    }, +, +    @Test, +    public void testWritesSingleFrameToEncoderAndReturnsTrueIfEncoderFinishes() {, +        OutputStream os = mock(OutputStream.class);, +        Bitmap frame = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);]
[+++ b/library/src/com/bumptech/photos/resize/ImageManager.java, +import com.bumptech.photos.resize.cache.DiskCache;, +import com.bumptech.photos.resize.cache.DiskCacheAdapter;, +import com.bumptech.photos.resize.cache.disk.AndroidDiskCache;, +    private static DiskCache buildDiskCacheFor(Options options, File diskCacheDir) {, +        if (options.useDiskCache && options.maxDiskCacheSize <= 0) {, +            options.maxDiskCacheSize = MAX_DISK_CACHE_SIZE;, +        }, +        final DiskCache result;, +        if (diskCacheDir == null || !options.useDiskCache) {, +            result = new DiskCacheAdapter();, +        } else {, +            result = AndroidDiskCache.get(diskCacheDir, options.maxDiskCacheSize);, +        }, +, +        return result;, +    }, +, +        this(context, buildDiskCacheFor(options, diskCacheDir), resizeService, options);, +    }, +, +    public ImageManager(Context context, DiskCache diskCache, ExecutorService resizeService, Options options) {, +        diskCacheFormat = options.diskCacheFormat;, +        this.diskCache = diskCache;, +                path = diskCache.get(String.valueOf(key));, +                    diskCache.put(String.valueOf(key), result, diskCacheFormat);, +++ b/library/src/com/bumptech/photos/resize/ImageManager.java, +import com.bumptech.photos.resize.cache.DiskCache;, +import com.bumptech.photos.resize.cache.DiskCacheAdapter;, +import com.bumptech.photos.resize.cache.disk.AndroidDiskCache;, +    private static DiskCache buildDiskCacheFor(Options options, File diskCacheDir) {, +        if (options.useDiskCache && options.maxDiskCacheSize <= 0) {, +            options.maxDiskCacheSize = MAX_DISK_CACHE_SIZE;, +        }, +        final DiskCache result;, +        if (diskCacheDir == null || !options.useDiskCache) {, +            result = new DiskCacheAdapter();, +        } else {, +            result = AndroidDiskCache.get(diskCacheDir, options.maxDiskCacheSize);, +        }, +, +        return result;, +    }, +, +        this(context, buildDiskCacheFor(options, diskCacheDir), resizeService, options);, +    }, +, +    public ImageManager(Context context, DiskCache diskCache, ExecutorService resizeService, Options options) {, +        diskCacheFormat = options.diskCacheFormat;, +        this.diskCache = diskCache;, +                path = diskCache.get(String.valueOf(key));, +                    diskCache.put(String.valueOf(key), result, diskCacheFormat);, +++ b/library/src/com/bumptech/photos/resize/cache/DiskCache.java, +package com.bumptech.photos.resize.cache;, +, +import android.graphics.Bitmap;, +, +/**, + * Created with IntelliJ IDEA., + * User: sam, + * Date: 6/5/13, + * Time: 10:21 AM, + * To change this template use File | Settings | File Templates., + */, +public interface DiskCache {, +    public String get(String key);, +    public void put(String key, Bitmap value, Bitmap.CompressFormat format);, +, +}, +++ b/library/src/com/bumptech/photos/resize/ImageManager.java, +import com.bumptech.photos.resize.cache.DiskCache;, +import com.bumptech.photos.resize.cache.DiskCacheAdapter;, +import com.bumptech.photos.resize.cache.disk.AndroidDiskCache;, +    private static DiskCache buildDiskCacheFor(Options options, File diskCacheDir) {, +        if (options.useDiskCache && options.maxDiskCacheSize <= 0) {, +            options.maxDiskCacheSize = MAX_DISK_CACHE_SIZE;, +        }, +        final DiskCache result;, +        if (diskCacheDir == null || !options.useDiskCache) {, +            result = new DiskCacheAdapter();, +        } else {, +            result = AndroidDiskCache.get(diskCacheDir, options.maxDiskCacheSize);, +        }, +, +        return result;, +    }, +, +        this(context, buildDiskCacheFor(options, diskCacheDir), resizeService, options);, +    }, +, +    public ImageManager(Context context, DiskCache diskCache, ExecutorService resizeService, Options options) {, +        diskCacheFormat = options.diskCacheFormat;, +        this.diskCache = diskCache;, +                path = diskCache.get(String.valueOf(key));, +                    diskCache.put(String.valueOf(key), result, diskCacheFormat);, +++ b/library/src/com/bumptech/photos/resize/cache/DiskCache.java, +package com.bumptech.photos.resize.cache;, +, +import android.graphics.Bitmap;, +]
[+++ b/gradle.properties, +VERSION_NAME=4.6.0-SNAPSHOT, +VERSION_MINOR=6]
[+++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    if (!requestOptions.isTransformationSet(), +        && requestOptions.isTransformationAllowed(), +        && view.getScaleType() != null) {, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    if (!requestOptions.isTransformationSet(), +        && requestOptions.isTransformationAllowed(), +        && view.getScaleType() != null) {, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +  private static final int TRANSFORMATION_ALLOWED = 1 << 16;, +  private static final int TRANSFORMATION_REQUIRED = 1 << 17;, +  private boolean isTransformationAllowed = true;, +  public final boolean isTransformationAllowed() {, +    return isTransformationAllowed;, +  }, +, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *, +    fields |= TRANSFORMATION_REQUIRED;, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *, +    fields |= TRANSFORMATION;, +    isTransformationAllowed = true;, +    fields |= TRANSFORMATION_ALLOWED;, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *, +    fields |= TRANSFORMATION_REQUIRED;, +    fields &= ~TRANSFORMATION;, +    fields &= ~TRANSFORMATION_REQUIRED;, +    isTransformationAllowed = false;, +    fields |= TRANSFORMATION_ALLOWED;, +    if (isSet(other.fields, TRANSFORMATION_ALLOWED)) {, +      isTransformationAllowed = other.isTransformationAllowed;, +    }, +    if (isSet(other.fields, TRANSFORMATION_REQUIRED)) {, +      isTransformationRequired = other.isTransformationRequired;, +    }, +    if (isSet(other.fields, TRANSFORMATION)) {, +    }, +, +    // Applying options with dontTransform() is expected to clear our transformations., +    if (!isTransformationAllowed) {, +      transformations.clear();, +      fields &= ~TRANSFORMATION;, +      isTransformationRequired = false;, +      fields &= ~TRANSFORMATION_REQUIRED;, +    }, +, +    fields |= other.fields;, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +    if (!requestOptions.isTransformationSet(), +        && requestOptions.isTransformationAllowed(), +        && view.getScaleType() != null) {, +++ b/library/src/main/java/com/bumptech/glide/request/BaseRequestOptions.java, +  private static final int TRANSFORMATION_ALLOWED = 1 << 16;, +  private static final int TRANSFORMATION_REQUIRED = 1 << 17;, +  private boolean isTransformationAllowed = true;, +  public final boolean isTransformationAllowed() {, +    return isTransformationAllowed;, +  }, +, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *, +    fields |= TRANSFORMATION_REQUIRED;, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *, +    fields |= TRANSFORMATION;, +    isTransformationAllowed = true;, +    fields |= TRANSFORMATION_ALLOWED;, +   * <p>This will override previous calls to {@link #dontTransform()}., +   *, +    fields |= TRANSFORMATION_REQUIRED;]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.view.View;, +import com.bumptech.glide.util.Preconditions;, +    Preconditions.checkNotNull(, +        "You cannot start a load on a not yet attached View or a  Fragment where getActivity() ", +            + "returns null (which usually occurs when getActivity() is called before the Fragment ", +            + "is attached or after the Fragment is destroyed).");, +  /**, +   * Begin a load with Glide that will be tied to the lifecycle of the {@link Fragment},, +   * {@link android.app.Fragment}, or {@link Activity} that contains the View., +   *, +   * <p>A {@link Fragment} or {@link android.app.Fragment} is assumed to contain a View if the View, +   * is a child of the View returned by the {@link Fragment#getView()}} method., +   *, +   * <p>This method will not work if the View is not attached. Prefer the Activity and Fragment, +   * variants unless you're loading in a View subclass., +   *, +   * <p>This method may be inefficient for large hierarchies. Consider memoizing the result after, +   * the View is attached., +   *, +   * <p>When used in Applications that use the non-support {@link android.app.Fragment} classes,, +   * calling this method will produce noisy logs from {@link android.app.FragmentManager}. Consider, +   * avoiding entirely or using the {@link Fragment}s from the support library instead., +   *, +   * @param view The view to search for a containing Fragment or Activity from., +   * @return A RequestManager that can be used to start a load., +   */, +  public static RequestManager with(View view) {, +    return getRetriever(view.getContext()).get(view);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.view.View;, +import com.bumptech.glide.util.Preconditions;, +    Preconditions.checkNotNull(, +        "You cannot start a load on a not yet attached View or a  Fragment where getActivity() ", +            + "returns null (which usually occurs when getActivity() is called before the Fragment ", +            + "is attached or after the Fragment is destroyed).");, +  /**, +   * Begin a load with Glide that will be tied to the lifecycle of the {@link Fragment},, +   * {@link android.app.Fragment}, or {@link Activity} that contains the View., +   *, +   * <p>A {@link Fragment} or {@link android.app.Fragment} is assumed to contain a View if the View, +   * is a child of the View returned by the {@link Fragment#getView()}} method., +   *, +   * <p>This method will not work if the View is not attached. Prefer the Activity and Fragment, +   * variants unless you're loading in a View subclass., +   *, +   * <p>This method may be inefficient for large hierarchies. Consider memoizing the result after, +   * the View is attached., +   *, +   * <p>When used in Applications that use the non-support {@link android.app.Fragment} classes,, +   * calling this method will produce noisy logs from {@link android.app.FragmentManager}. Consider, +   * avoiding entirely or using the {@link Fragment}s from the support library instead., +   *, +   * @param view The view to search for a containing Fragment or Activity from., +   * @return A RequestManager that can be used to start a load., +   */, +  public static RequestManager with(View view) {, +    return getRetriever(view.getContext()).get(view);, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java, +import android.os.Build.VERSION;, +import android.os.Build.VERSION_CODES;, +import android.os.Bundle;, +import android.support.v4.util.ArrayMap;, +import android.view.View;, +import com.bumptech.glide.util.Preconditions;, +import java.util.List;, +  // Hacks based on the implementation of FragmentManagerImpl in the non-support libraries that, +  // allow us to iterate over and retrieve all active Fragments in a FragmentManager., +  private static final String FRAGMENT_INDEX_KEY = "key";, +  private static final String FRAGMENT_MANAGER_GET_FRAGMENT_KEY = "i";, +, +  // Objects used to find Fragments and Activities containing views., +  private final ArrayMap<View, Fragment> tempViewToSupportFragment = new ArrayMap<>();, +  private final ArrayMap<View, android.app.Fragment> tempViewToFragment = new ArrayMap<>();, +  private final Bundle tempBundle = new Bundle();, +, +      return supportFragmentGet(activity, fm, null /*parentHint*/);, +    Preconditions.checkNotNull(fragment.getActivity(),, +          "You cannot start a load on a fragment before it is attached or after it is destroyed");, +      return fragmentGet(activity, fm, null /*parentHint*/);, +    }, +  }, +, +  public RequestManager get(View view) {, +    if (Util.isOnBackgroundThread()) {, +      return get(view.getContext().getApplicationContext());, +    }, +, +    Preconditions.checkNotNull(view);, +    Preconditions.checkNotNull(view.getContext(),, +        "Unable to obtain a request manager for a view without a Context");, +    Activity activity = findActivity(view.getContext());, +    // The view might be somewhere else, like a service., +    if (activity == null) {, +      return get(view.getContext().getApplicationContext());, +    }]
[+++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java, +package com.bumptech.glide.load.data.mediastore;, +, +import android.net.Uri;, +import android.provider.MediaStore;, +import com.bumptech.glide.Priority;, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +import org.robolectric.Robolectric;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +, +import java.io.ByteArrayInputStream;, +import java.io.InputStream;, +, +import static com.google.common.truth.Truth.assertThat;, +import static org.junit.Assert.assertEquals;, +import static org.mockito.Matchers.eq;, +import static org.mockito.Mockito.mock;, +import static org.mockito.Mockito.verify;, +import static org.mockito.Mockito.when;, +, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +public class ThumbFetcherTest {, +, +    @Mock ThumbnailStreamOpener opener;, +    private ThumbFetcher fetcher;, +    private Uri uri;, +, +    @Before, +    public void setUp() {, +        MockitoAnnotations.initMocks(this);, +, +        uri = Uri.withAppendedPath(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, "123");, +        fetcher = new ThumbFetcher(Robolectric.application, uri, opener);, +    }, +, +    @Test, +    public void testReturnsInputStreamFromThumbnailOpener() throws Exception {, +        InputStream expected = new ByteArrayInputStream(new byte[0]);, +, +        when(opener.open(eq(Robolectric.application), eq(uri))).thenReturn(expected);, +, +        InputStream result = fetcher.loadData(Priority.LOW);, +        assertEquals(expected, result);, +    }, +, +    @Test, +    public void testClosesInputStreamFromThumbnailOpenerOnCleanup() throws Exception {, +        InputStream expected = mock(InputStream.class);, +, +        when(opener.open(eq(Robolectric.application), eq(uri))).thenReturn(expected);, +, +        fetcher.loadData(Priority.HIGH);, +, +        fetcher.cleanup();, +        verify(expected).close();, +    }, +, +    @Test, +    public void testDoesNotThrowIfCleanupWithNullInputStream() {, +        fetcher.cleanup();, +    }, +, +    @Test, +    public void testContainsAllRelevantPartsInId() {, +        String id = fetcher.getId();, +        assertThat(id).contains(uri.toString());, +    }, +}, +++ /dev/null, +++ /dev/null, +++ /dev/null, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/mediastore/ThumbFetcherTest.java, +package com.bumptech.glide.load.data.mediastore;, +, +import android.net.Uri;, +import android.provider.MediaStore;, +import com.bumptech.glide.Priority;, +import org.junit.Before;, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.mockito.Mock;, +import org.mockito.MockitoAnnotations;, +import org.robolectric.Robolectric;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;]
[+++ b/gradle.properties, +VERSION_NAME=3.5.0-SNAPSHOT, +VERSION_MINOR=5, +VERSION_CODE=8, +++ b/gradle.properties, +VERSION_NAME=3.5.0-SNAPSHOT, +VERSION_MINOR=5, +VERSION_CODE=8, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.2.0-SNAPSHOT, +VERSION_MINOR=2, +VERSION_CODE=4, +++ b/gradle.properties, +VERSION_NAME=3.5.0-SNAPSHOT, +VERSION_MINOR=5, +VERSION_CODE=8, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=1.2.0-SNAPSHOT, +VERSION_MINOR=2, +VERSION_CODE=4, +++ b/integration/volley/gradle.properties, +VERSION_NAME=1.2.0-SNAPSHOT, +VERSION_MINOR=2, +VERSION_CODE=4]
[+++ b/library/custom_rules.xml, +    <xmlproperty file="AndroidManifest.xml" prefix="mymanifest" collapseAttributes="true"/>, +, +        <jar destfile="bin/glide-${mymanifest.manifest.android:versionName}.jar", +        <jar destfile="bin/glide-minus-volley-${mymanifest.manifest.android:versionName}.jar"]
[+++ b/gradle.properties, +VERSION_NAME=4.4.0]
[+++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java, +import com.bumptech.glide.load.DataSource;, +   * @param dataSource        The {@link DataSource} the resource was loaded from., +  boolean onResourceReady(R resource, Object model, Target<R> target, DataSource dataSource,, +++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java, +import com.bumptech.glide.load.DataSource;, +   * @param dataSource        The {@link DataSource} the resource was loaded from., +  boolean onResourceReady(R resource, Object model, Target<R> target, DataSource dataSource,, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +        || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource)) {, +++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java, +import com.bumptech.glide.load.DataSource;, +   * @param dataSource        The {@link DataSource} the resource was loaded from., +  boolean onResourceReady(R resource, Object model, Target<R> target, DataSource dataSource,, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +        || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource)) {, +++ b/library/src/test/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.DataSource;, +          DataSource dataSource, boolean isFirstResource) {, +++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java, +import com.bumptech.glide.load.DataSource;, +   * @param dataSource        The {@link DataSource} the resource was loaded from., +  boolean onResourceReady(R resource, Object model, Target<R> target, DataSource dataSource,, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +        || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource)) {, +++ b/library/src/test/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.DataSource;, +          DataSource dataSource, boolean isFirstResource) {, +++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java, +import static com.bumptech.glide.tests.Util.isADataSource;, +    verify(harness.cb, never()).onResourceReady(anyResource(), isADataSource());, +    }).when(existingCallback).onResourceReady(anyResource(), isADataSource());, +    }).when(cb).onResourceReady(anyResource(), isADataSource());, +    verify(cb, times(1)).onResourceReady(anyResource(), isADataSource());, +    }).when(harness.cb).onResourceReady(anyResource(), isADataSource());, +    verify(notYetCalled, never()).onResourceReady(anyResource(), isADataSource());, +    }).when(harness.cb).onResourceReady(anyResource(), isADataSource());, +    verify(notYetCalled, never()).onResourceReady(anyResource(), isADataSource());, +++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java, +import com.bumptech.glide.load.DataSource;, +   * @param dataSource        The {@link DataSource} the resource was loaded from., +  boolean onResourceReady(R resource, Object model, Target<R> target, DataSource dataSource,, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +        || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource)) {, +++ b/library/src/test/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.DataSource;, +          DataSource dataSource, boolean isFirstResource) {, +++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java, +import static com.bumptech.glide.tests.Util.isADataSource;, +    verify(harness.cb, never()).onResourceReady(anyResource(), isADataSource());, +    }).when(existingCallback).onResourceReady(anyResource(), isADataSource());, +    }).when(cb).onResourceReady(anyResource(), isADataSource());, +    verify(cb, times(1)).onResourceReady(anyResource(), isADataSource());, +    }).when(harness.cb).onResourceReady(anyResource(), isADataSource());, +    verify(notYetCalled, never()).onResourceReady(anyResource(), isADataSource());, +    }).when(harness.cb).onResourceReady(anyResource(), isADataSource());, +    verify(notYetCalled, never()).onResourceReady(anyResource(), isADataSource());, +++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java, +import static com.bumptech.glide.tests.Util.isADataSource;, +    verify(harness.cb, never()).onResourceReady(isNull(Resource.class), isADataSource());, +    verify(harness.cb, never()).onResourceReady(eq(other), isADataSource());, +    }).when(harness.cb).onResourceReady(anyResource(), isADataSource());, +    verify(harness.cb).onResourceReady(anyResource(), isADataSource());, +++ b/library/src/main/java/com/bumptech/glide/request/RequestListener.java, +import com.bumptech.glide.load.DataSource;, +   * @param dataSource        The {@link DataSource} the resource was loaded from., +  boolean onResourceReady(R resource, Object model, Target<R> target, DataSource dataSource,, +++ b/library/src/main/java/com/bumptech/glide/request/SingleRequest.java, +        || !requestListener.onResourceReady(result, model, target, dataSource, isFirstResource)) {, +++ b/library/src/test/java/com/bumptech/glide/GlideTest.java, +import com.bumptech.glide.load.DataSource;, +          DataSource dataSource, boolean isFirstResource) {, +++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineJobTest.java, +import static com.bumptech.glide.tests.Util.isADataSource;, +    verify(harness.cb, never()).onResourceReady(anyResource(), isADataSource());, +    }).when(existingCallback).onResourceReady(anyResource(), isADataSource());, +    }).when(cb).onResourceReady(anyResource(), isADataSource());, +    verify(cb, times(1)).onResourceReady(anyResource(), isADataSource());, +    }).when(harness.cb).onResourceReady(anyResource(), isADataSource());, +    verify(notYetCalled, never()).onResourceReady(anyResource(), isADataSource());, +    }).when(harness.cb).onResourceReady(anyResource(), isADataSource());, +    verify(notYetCalled, never()).onResourceReady(anyResource(), isADataSource());, +++ b/library/src/test/java/com/bumptech/glide/load/engine/EngineTest.java, +import static com.bumptech.glide.tests.Util.isADataSource;, +    verify(harness.cb, never()).onResourceReady(isNull(Resource.class), isADataSource());, +    verify(harness.cb, never()).onResourceReady(eq(other), isADataSource());, +    }).when(harness.cb).onResourceReady(anyResource(), isADataSource());, +    verify(harness.cb).onResourceReady(anyResource(), isADataSource());, +++ b/library/src/test/java/com/bumptech/glide/request/SingleRequestTest.java, +import static com.bumptech.glide.tests.Util.isADataSource;, +        .onResourceReady(any(List.class), any(Number.class), eq(harness.target), isADataSource(),, +        .onResourceReady(any(List.class), any(Number.class), eq(harness.target), isADataSource(),, +        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(), isADataSource(),, +        .onResourceReady(any(List.class), eq(harness.model), isAListTarget(), isADataSource(),, +        .onResourceReady(any(List.class), any(Number.class), eq(harness.target), isADataSource(),, +        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(),, +            eq(DataSource.MEMORY_CACHE), anyBoolean());, +        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(),, +            eq(DataSource.LOCAL), anyBoolean());, +        .onResourceReady(eq(harness.result), any(Number.class), isAListTarget(), isADataSource(),]
[+++ b/library/src/main/java/com/bumptech/glide/request/target/SimpleTarget.java, + *         public void onResourceReady(Bitmap resource, Transition<? super Bitmap> transition) {]
[+++ b/third_party/gif_decoder/src/main/java/com/bumptech/glide/gifdecoder/StandardGifDecoder.java, +    Arrays.fill(mainPixels, pi, npix, (byte) COLOR_TRANSPARENT_BLACK);]
[+++ b/build.gradle, +        toolVersion = '8.4', +++ b/build.gradle, +        toolVersion = '8.4', +++ b/checkstyle.xml, +            <message key="import.illegal" value="Import from illegal package - {0}. Use org.mockito.Matchers to instantiate argument matchers." />, +, +        <!-- ArgumentMatchers isn't available internally, the same methods are available on org.mockito.Mockito. -->, +        <module name="IllegalImport">, +            <property name="illegalClasses" value="org\.mockito\.ArgumentMatchers\..*" />, +            <property name="regexp" value="true" />, +            <message key="import.illegal" value="Import from illegal class - {0}. Use org.mockito.Mockito to statically import matcher methods." />, +        </module>, +, +           <property name="separated" value="true" />, +++ b/build.gradle, +        toolVersion = '8.4', +++ b/checkstyle.xml, +            <message key="import.illegal" value="Import from illegal package - {0}. Use org.mockito.Matchers to instantiate argument matchers." />, +, +        <!-- ArgumentMatchers isn't available internally, the same methods are available on org.mockito.Mockito. -->, +        <module name="IllegalImport">, +            <property name="illegalClasses" value="org\.mockito\.ArgumentMatchers\..*" />, +            <property name="regexp" value="true" />, +            <message key="import.illegal" value="Import from illegal class - {0}. Use org.mockito.Mockito to statically import matcher methods." />, +        </module>, +, +           <property name="separated" value="true" />, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +      @Nullable RequestBuilder<TranscodeType>... thumbnails) {, +++ b/build.gradle, +        toolVersion = '8.4', +++ b/checkstyle.xml, +            <message key="import.illegal" value="Import from illegal package - {0}. Use org.mockito.Matchers to instantiate argument matchers." />, +, +        <!-- ArgumentMatchers isn't available internally, the same methods are available on org.mockito.Mockito. -->, +        <module name="IllegalImport">, +            <property name="illegalClasses" value="org\.mockito\.ArgumentMatchers\..*" />, +            <property name="regexp" value="true" />, +            <message key="import.illegal" value="Import from illegal class - {0}. Use org.mockito.Mockito to statically import matcher methods." />, +        </module>, +, +           <property name="separated" value="true" />, +++ b/library/src/main/java/com/bumptech/glide/RequestBuilder.java, +      @Nullable RequestBuilder<TranscodeType>... thumbnails) {, +++ b/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +        public void onResourceReady(Object resource, GlideAnimation<? super Object> glideAnimation) {]
[+++ b/library/src/main/java/com/bumptech/glide/load/resource/bitmap/VideoBitmapDecoder.java, +    MediaMetadataRetriever mediaMetadataRetriever = factory.build();, +    try {, +      mediaMetadataRetriever.setDataSource(resource.getFileDescriptor());, +    } finally {, +    }]
[+++ b/library/lint.xml, +    <issue id="InlinedApi">, +        <ignore path="src/com/bumptech/glide/resize/cache/LruMemoryCache.java" />, +    </issue>]
[+++ b/library/src/com/bumptech/photos/resize/ImageResizer.java, +        RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, tempBytes[0]);, +++ b/library/src/com/bumptech/photos/resize/ImageResizer.java, +        RecyclableBufferedInputStream bis = new RecyclableBufferedInputStream(is, tempBytes[0]);, +++ b/library/src/com/bumptech/photos/resize/RecyclableBufferedInputStream.java, +package com.bumptech.photos.resize;, +, +/*, + *  Licensed to the Apache Software Foundation (ASF) under one or more, + *  contributor license agreements.  See the NOTICE file distributed with, + *  this work for additional information regarding copyright ownership., + *  The ASF licenses this file to You under the Apache License, Version 2.0, + *  (the &quot;License&quot;); you may not use this file except in compliance with, + *  the License.  You may obtain a copy of the License at, + *, + *     http://www.apache.org/licenses/LICENSE-2.0, + *, + *  Unless required by applicable law or agreed to in writing, software, + *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,, + *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied., + *  See the License for the specific language governing permissions and, + *  limitations under the License., + */, +, +, +import java.io.FilterInputStream;, +import java.io.IOException;, +import java.io.InputStream;, +, +/**, + * Wraps an existing {@link InputStream} and &lt;em&gt;buffers&lt;/em&gt; the input., + * Expensive interaction with the underlying input stream is minimized, since, + * most (smaller) requests can be satisfied by accessing the buffer alone. The, + * drawback is that some extra space is required to hold the buffer and that, + * copying takes place when filling that buffer, but this is usually outweighed, + * by the performance benefits., + *, + * &lt;p/&gt;A typical application pattern for the class looks like this:&lt;p/&gt;, + *, + * &lt;pre&gt;, + * BufferedInputStream buf = new BufferedInputStream(new FileInputStream(&amp;quot;file.java&amp;quot;));, + * &lt;/pre&gt;, + *, + */, +public class RecyclableBufferedInputStream extends FilterInputStream {, +    /**, +     * The buffer containing the current bytes read from the target InputStream., +     */, +    protected volatile byte[] buf;, +, +    /**, +     * The total number of bytes inside the byte array {@code buf}., +     */, +    protected int count;, +, +    /**, +     * The current limit, which when passed, invalidates the current mark., +     */, +    protected int marklimit;, +, +    /**, +     * The currently marked position. -1 indicates no mark has been set or the, +     * mark has been invalidated., +     */, +    protected int markpos = -1;, +, +    /**, +     * The current position within the byte array {@code buf}., +     */, +    protected int pos;, +, +    /**, +     * Constructs a new {@code BufferedInputStream}, providing {@code in} with a buffer, +     * of 8192 bytes., +     *, +     * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; passing a null source creates a closed, +     * {@code BufferedInputStream}. All read operations on such a stream will, +     * fail with an IOException., +     *, +     * @param in the {@code InputStream} the buffer reads from., +     */, +    public RecyclableBufferedInputStream(InputStream in) {, +        this(in, 8192);, +    }, +, +    /**, +     * Constructs a new {@code BufferedInputStream}, providing {@code in} with {@code size} bytes, +     * of buffer., +     *, +     * &lt;p&gt;&lt;strong&gt;Warning:&lt;/strong&gt; passing a null source creates a closed, +     * {@code BufferedInputStream}. All read operations on such a stream will, +     * fail with an IOException., +     *, +     * @param in the {@code InputStream} the buffer reads from., +     * @param size the size of buffer in bytes., +     * @throws IllegalArgumentException if {@code size &lt;= 0}., +     */, +    public RecyclableBufferedInputStream(InputStream in, int size) {, +        this(in, new byte[size]);, +    }]
[+++ b/library/findbugs-exclude.xml, +      <Class name="com.bumptech.glide.load.engine.executor.RuntimeCompat" />, +++ b/library/findbugs-exclude.xml, +      <Class name="com.bumptech.glide.load.engine.executor.RuntimeCompat" />, +++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/RuntimeCompat.java, +  private RuntimeCompat() {, +    // Utility class., +  }, +  @SuppressWarnings("PMD"), +++ b/library/findbugs-exclude.xml, +      <Class name="com.bumptech.glide.load.engine.executor.RuntimeCompat" />, +++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/RuntimeCompat.java, +  private RuntimeCompat() {, +    // Utility class., +  }, +  @SuppressWarnings("PMD"), +++ b/library/src/test/java/com/bumptech/glide/load/engine/executor/MockGlideExecutor.java, +  private MockGlideExecutor() {, +  }, +    public void execute(final Runnable command) {]
[+++ b/annotation/compiler/test/build.gradle, +, +task regenerateTestResources {, +    group 'Verification', +    description 'Regenerates all test resource files under annotation/compiler/test/src/test/resources that are compared against the current output to detect regressions', +    tasks.withType(Test) {, +        systemProperties.put("com.bumptech.glide.annotation.compiler.test.regenerate.path", projectDir), +    }, +    doFirst {, +        println("Regenerating test resources...."), +    }, +    doLast {, +        println("Finished regenerating test resources"), +    }, +}, +regenerateTestResources.finalizedBy(test), +++ b/annotation/compiler/test/build.gradle, +, +task regenerateTestResources {, +    group 'Verification', +    description 'Regenerates all test resource files under annotation/compiler/test/src/test/resources that are compared against the current output to detect regressions', +    tasks.withType(Test) {, +        systemProperties.put("com.bumptech.glide.annotation.compiler.test.regenerate.path", projectDir), +    }, +    doFirst {, +        println("Regenerating test resources...."), +    }, +    doLast {, +        println("Finished regenerating test resources"), +    }, +}, +regenerateTestResources.finalizedBy(test), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java, +import com.bumptech.glide.annotation.compiler.test.ReferencedResource;, +import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;, +import org.junit.Rule;, +  @Rule public final RegenerateResourcesRule regenerateResourcesRule =, +      new RegenerateResourcesRule(getClass());, +  @ReferencedResource, +  @ReferencedResource, +  @ReferencedResource, +  @ReferencedResource, +  @ReferencedResource, +++ b/annotation/compiler/test/build.gradle, +, +task regenerateTestResources {, +    group 'Verification', +    description 'Regenerates all test resource files under annotation/compiler/test/src/test/resources that are compared against the current output to detect regressions', +    tasks.withType(Test) {, +        systemProperties.put("com.bumptech.glide.annotation.compiler.test.regenerate.path", projectDir), +    }, +    doFirst {, +        println("Regenerating test resources...."), +    }, +    doLast {, +        println("Finished regenerating test resources"), +    }, +}, +regenerateTestResources.finalizedBy(test), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java, +import com.bumptech.glide.annotation.compiler.test.ReferencedResource;, +import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;, +import org.junit.Rule;, +  @Rule public final RegenerateResourcesRule regenerateResourcesRule =, +      new RegenerateResourcesRule(getClass());, +  @ReferencedResource, +  @ReferencedResource, +  @ReferencedResource, +  @ReferencedResource, +  @ReferencedResource, +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithMultipleExcludesTest.java, +import com.bumptech.glide.annotation.compiler.test.ReferencedResource;, +import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;, +import org.junit.Rule;, +  @Rule public final RegenerateResourcesRule regenerateResourcesRule =, +      new RegenerateResourcesRule(getClass());, +  @ReferencedResource, +  @ReferencedResource, +  @ReferencedResource, +  @ReferencedResource, +  @ReferencedResource, +++ b/annotation/compiler/test/build.gradle, +, +task regenerateTestResources {, +    group 'Verification', +    description 'Regenerates all test resource files under annotation/compiler/test/src/test/resources that are compared against the current output to detect regressions', +    tasks.withType(Test) {, +        systemProperties.put("com.bumptech.glide.annotation.compiler.test.regenerate.path", projectDir), +    }, +    doFirst {, +        println("Regenerating test resources...."), +    }, +    doLast {, +        println("Finished regenerating test resources"), +    }, +}, +regenerateTestResources.finalizedBy(test), +++ b/annotation/compiler/test/src/test/java/com/bumptech/glide/annotation/compiler/AppGlideModuleWithExcludesTest.java, +import com.bumptech.glide.annotation.compiler.test.ReferencedResource;, +import com.bumptech.glide.annotation.compiler.test.RegenerateResourcesRule;]
[+++ b/library/src/main/java/com/bumptech/glide/load/data/LoadDataSet.java, +    return "DataFetcherSet{modelLoaders=" +, +        Arrays.toString(modelLoaders.toArray(new ModelLoader[modelLoaders.size()])) + "}";, +++ b/library/src/main/java/com/bumptech/glide/load/data/LoadDataSet.java, +    return "DataFetcherSet{modelLoaders=" +, +        Arrays.toString(modelLoaders.toArray(new ModelLoader[modelLoaders.size()])) + "}";, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +  private volatile DataFetcher<?> fetcher;, +  public void cancel() {, +    DataFetcher<?> local = fetcher;, +    if (local != null) {, +      local.cancel();, +    }, +  }, +, +  @Override, +++ b/library/src/main/java/com/bumptech/glide/load/data/LoadDataSet.java, +    return "DataFetcherSet{modelLoaders=" +, +        Arrays.toString(modelLoaders.toArray(new ModelLoader[modelLoaders.size()])) + "}";, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +  private volatile DataFetcher<?> fetcher;, +  public void cancel() {, +    DataFetcher<?> local = fetcher;, +    if (local != null) {, +      local.cancel();, +    }, +  }, +, +  @Override, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java, +    void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetcher,, +        DataSource dataSource);, +, +  /**, +   * Attempts to cancel the currently running fetcher., +   *, +   * <p> This will be called on the main thread and should complete quickly. </p>, +   */, +  void cancel();, +++ b/library/src/main/java/com/bumptech/glide/load/data/LoadDataSet.java, +    return "DataFetcherSet{modelLoaders=" +, +        Arrays.toString(modelLoaders.toArray(new ModelLoader[modelLoaders.size()])) + "}";, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +  private volatile DataFetcher<?> fetcher;, +  public void cancel() {, +    DataFetcher<?> local = fetcher;, +    if (local != null) {, +      local.cancel();, +    }, +  }, +, +  @Override, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java, +    void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetcher,, +        DataSource dataSource);, +, +  /**, +   * Attempts to cancel the currently running fetcher., +   *, +   * <p> This will be called on the main thread and should complete quickly. </p>, +   */, +  void cancel();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private volatile DataFetcherGenerator generator;, +    DataFetcherGenerator local = generator;, +    if (local != null) {, +      local.cancel();, +    }, +  public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetcher,, +++ b/library/src/main/java/com/bumptech/glide/load/data/LoadDataSet.java, +    return "DataFetcherSet{modelLoaders=" +, +        Arrays.toString(modelLoaders.toArray(new ModelLoader[modelLoaders.size()])) + "}";, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +  private volatile DataFetcher<?> fetcher;, +  public void cancel() {, +    DataFetcher<?> local = fetcher;, +    if (local != null) {, +      local.cancel();, +    }, +  }, +, +  @Override, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataFetcherGenerator.java, +    void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetcher,, +        DataSource dataSource);, +, +  /**, +   * Attempts to cancel the currently running fetcher., +   *, +   * <p> This will be called on the main thread and should complete quickly. </p>, +   */, +  void cancel();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +  private volatile DataFetcherGenerator generator;, +    DataFetcherGenerator local = generator;, +    if (local != null) {, +      local.cancel();, +    }, +  public void onDataFetcherReady(Key sourceKey, Object data, DataFetcher<?> fetcher,, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java]
[+++ b/library/src/main/java/com/bumptech/glide/Glide.java, +      Context context, int logLevel, RequestOptions defaultRequestOptions) {, +, +    DecodeFormat decodeFormat = defaultRequestOptions.getOptions().get(Downsampler.DECODE_FORMAT);, +    glideContext = new GlideContext(context, registry, imageViewTargetFactory,, +        defaultRequestOptions, engine, this, logLevel);, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +      Context context, int logLevel, RequestOptions defaultRequestOptions) {, +, +    DecodeFormat decodeFormat = defaultRequestOptions.getOptions().get(Downsampler.DECODE_FORMAT);, +    glideContext = new GlideContext(context, registry, imageViewTargetFactory,, +        defaultRequestOptions, engine, this, logLevel);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.request.RequestOptions;, +  private RequestOptions defaultRequestOptions = new RequestOptions();, +   * @param diskCacheFactory The disk cache factory to use., +   * for thumbnail requests to work properly., +   * for thumbnail requests to work properly., +   * Sets the default {@link RequestOptions} to use for all loads across the app., +   *, +   * <p>Applying additional options with {@link, +   * RequestBuilder#apply(com.bumptech.glide.request.BaseRequestOptions)} will override defaults, +   * set here., +   *, +   * @param requestOptions The options to use by default., +   * @return This builder., +   */, +  public GlideBuilder setDefaultRequestOptions(RequestOptions requestOptions) {, +    this.defaultRequestOptions = requestOptions;, +    return this;, +  }, +, +  /**, +   *, +   * @deprecated Use {@link #setDefaultRequestOptions(RequestOptions)} instead., +  @Deprecated, +    defaultRequestOptions.apply(new RequestOptions().format(decodeFormat));, +    return new Glide(engine, memoryCache, bitmapPool, byteArrayPool, context, logLevel,, +        defaultRequestOptions.lock());, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +      Context context, int logLevel, RequestOptions defaultRequestOptions) {, +, +    DecodeFormat decodeFormat = defaultRequestOptions.getOptions().get(Downsampler.DECODE_FORMAT);, +    glideContext = new GlideContext(context, registry, imageViewTargetFactory,, +        defaultRequestOptions, engine, this, logLevel);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.request.RequestOptions;, +  private RequestOptions defaultRequestOptions = new RequestOptions();, +   * @param diskCacheFactory The disk cache factory to use., +   * for thumbnail requests to work properly., +   * for thumbnail requests to work properly., +   * Sets the default {@link RequestOptions} to use for all loads across the app., +   *, +   * <p>Applying additional options with {@link, +   * RequestBuilder#apply(com.bumptech.glide.request.BaseRequestOptions)} will override defaults, +   * set here., +   *, +   * @param requestOptions The options to use by default., +   * @return This builder., +   */, +  public GlideBuilder setDefaultRequestOptions(RequestOptions requestOptions) {, +    this.defaultRequestOptions = requestOptions;, +    return this;, +  }, +, +  /**, +   *, +   * @deprecated Use {@link #setDefaultRequestOptions(RequestOptions)} instead., +  @Deprecated, +    defaultRequestOptions.apply(new RequestOptions().format(decodeFormat));, +    return new Glide(engine, memoryCache, bitmapPool, byteArrayPool, context, logLevel,, +        defaultRequestOptions.lock());, +++ b/library/src/main/java/com/bumptech/glide/GlideContext.java, +  private final RequestOptions defaultRequestOptions;, +      ImageViewTargetFactory imageViewTargetFactory, RequestOptions defaultRequestOptions,, +      Engine engine, ComponentCallbacks2 componentCallbacks, int logLevel) {, +    this.defaultRequestOptions = defaultRequestOptions;, +  public RequestOptions getDefaultRequestOptions() {, +    return defaultRequestOptions;, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +      Context context, int logLevel, RequestOptions defaultRequestOptions) {, +, +    DecodeFormat decodeFormat = defaultRequestOptions.getOptions().get(Downsampler.DECODE_FORMAT);, +    glideContext = new GlideContext(context, registry, imageViewTargetFactory,, +        defaultRequestOptions, engine, this, logLevel);, +++ b/library/src/main/java/com/bumptech/glide/GlideBuilder.java, +import com.bumptech.glide.request.RequestOptions;, +  private RequestOptions defaultRequestOptions = new RequestOptions();, +   * @param diskCacheFactory The disk cache factory to use., +   * for thumbnail requests to work properly., +   * for thumbnail requests to work properly., +   * Sets the default {@link RequestOptions} to use for all loads across the app., +   *, +   * <p>Applying additional options with {@link, +   * RequestBuilder#apply(com.bumptech.glide.request.BaseRequestOptions)} will override defaults, +   * set here., +   *, +   * @param requestOptions The options to use by default., +   * @return This builder., +   */]
[+++ b/library/src/main/java/com/bumptech/glide/provider/LoadPathCache.java, +import com.bumptech.glide.load.ResourceDecoder;, +              new DecodePath<Object, Object, Object>(, +                  Collections.<ResourceDecoder<Object, Object>>emptyList(),]
[+++ b/.gitmodules, +++ b/.gitmodules, +++ /dev/null, +++ b/.gitmodules, +++ /dev/null, +++ b/samples/flickr/AndroidManifest.xml, +    android:theme="@style/Theme.AppCompat">, +++ b/.gitmodules, +++ /dev/null, +++ b/samples/flickr/AndroidManifest.xml, +    android:theme="@style/Theme.AppCompat">, +++ b/samples/flickr/build.gradle, +    compile 'com.android.support:appcompat-v7:18.0.+', +++ b/.gitmodules, +++ /dev/null, +++ b/samples/flickr/AndroidManifest.xml, +    android:theme="@style/Theme.AppCompat">, +++ b/samples/flickr/build.gradle, +    compile 'com.android.support:appcompat-v7:18.0.+', +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java, +import android.support.v4.app.Fragment;, +, +public class FlickrPhotoGrid extends Fragment implements PhotoViewer {, +++ b/.gitmodules, +++ /dev/null, +++ b/samples/flickr/AndroidManifest.xml, +    android:theme="@style/Theme.AppCompat">, +++ b/samples/flickr/build.gradle, +    compile 'com.android.support:appcompat-v7:18.0.+', +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java, +import android.support.v4.app.Fragment;, +, +public class FlickrPhotoGrid extends Fragment implements PhotoViewer {, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java, +import android.support.v4.app.Fragment;, +, +public class FlickrPhotoList extends Fragment implements PhotoViewer {, +++ b/.gitmodules, +++ /dev/null, +++ b/samples/flickr/AndroidManifest.xml, +    android:theme="@style/Theme.AppCompat">, +++ b/samples/flickr/build.gradle, +    compile 'com.android.support:appcompat-v7:18.0.+', +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoGrid.java, +import android.support.v4.app.Fragment;, +, +public class FlickrPhotoGrid extends Fragment implements PhotoViewer {, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrPhotoList.java, +import android.support.v4.app.Fragment;, +, +public class FlickrPhotoList extends Fragment implements PhotoViewer {, +++ b/samples/flickr/src/main/java/com/bumptech/glide/samples/flickr/FlickrSearchActivity.java, +import android.support.v7.app.ActionBar;, +import android.support.v7.app.ActionBarActivity;, +public class FlickrSearchActivity extends ActionBarActivity {]
[+++ b/library/src/main/java/com/bumptech/glide/request/target/CustomTarget.java, +   * @param width The requested width (> 0, or == Target.SIZE_ORIGINAL)., +   * @param height The requested height (> 0, or == Target.SIZE_ORIGINAL)., +   * @throws IllegalArgumentException if width/height doesn't meet (> 0, or == Target.SIZE_ORIGINAL)]
[+++ b/gradle.properties, +ANDROID_SUPPORT_VERSION=27.1.0]
[+++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapperTransformation;, +        GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, Drawable> {, +            LoadProvider<ModelType, ImageVideoWrapper, GifBitmapWrapper, Drawable> loadProvider, Glide glide) {, +            GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, Drawable> thumbnailRequest) {, +            ResourceDecoder<ImageVideoWrapper, GifBitmapWrapper> decoder) {, +            ResourceDecoder<InputStream, GifBitmapWrapper> cacheDecoder) {, +            ResourceEncoder<GifBitmapWrapper> encoder) {, +        return transform(new GifBitmapWrapperTransformation(context, bitmapTransformation));, +            Transformation<GifBitmapWrapper> transformation) {, +            ResourceTranscoder<GifBitmapWrapper, Drawable> transcoder) {, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapperTransformation;, +        GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, Drawable> {, +            LoadProvider<ModelType, ImageVideoWrapper, GifBitmapWrapper, Drawable> loadProvider, Glide glide) {, +            GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, Drawable> thumbnailRequest) {, +            ResourceDecoder<ImageVideoWrapper, GifBitmapWrapper> decoder) {, +            ResourceDecoder<InputStream, GifBitmapWrapper> cacheDecoder) {, +            ResourceEncoder<GifBitmapWrapper> encoder) {, +        return transform(new GifBitmapWrapperTransformation(context, bitmapTransformation));, +            Transformation<GifBitmapWrapper> transformation) {, +            ResourceTranscoder<GifBitmapWrapper, Drawable> transcoder) {, +++ b/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;, +                buildProvider(glide, streamModelLoader, fileDescriptorModelLoader, GifBitmapWrapper.class, Drawable.class,, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapperTransformation;, +        GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, Drawable> {, +            LoadProvider<ModelType, ImageVideoWrapper, GifBitmapWrapper, Drawable> loadProvider, Glide glide) {, +            GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, Drawable> thumbnailRequest) {, +            ResourceDecoder<ImageVideoWrapper, GifBitmapWrapper> decoder) {, +            ResourceDecoder<InputStream, GifBitmapWrapper> cacheDecoder) {, +            ResourceEncoder<GifBitmapWrapper> encoder) {, +        return transform(new GifBitmapWrapperTransformation(context, bitmapTransformation));, +            Transformation<GifBitmapWrapper> transformation) {, +            ResourceTranscoder<GifBitmapWrapper, Drawable> transcoder) {, +++ b/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;, +                buildProvider(glide, streamModelLoader, fileDescriptorModelLoader, GifBitmapWrapper.class, Drawable.class,, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;, +        dataLoadProviderFactory.register(ImageVideoWrapper.class, GifBitmapWrapper.class,, +        transcoderFactory.register(GifBitmapWrapper.class, Drawable.class,, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapperTransformation;, +        GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, Drawable> {, +            LoadProvider<ModelType, ImageVideoWrapper, GifBitmapWrapper, Drawable> loadProvider, Glide glide) {, +            GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, Drawable> thumbnailRequest) {, +            ResourceDecoder<ImageVideoWrapper, GifBitmapWrapper> decoder) {, +            ResourceDecoder<InputStream, GifBitmapWrapper> cacheDecoder) {, +            ResourceEncoder<GifBitmapWrapper> encoder) {, +        return transform(new GifBitmapWrapperTransformation(context, bitmapTransformation));, +            Transformation<GifBitmapWrapper> transformation) {, +            ResourceTranscoder<GifBitmapWrapper, Drawable> transcoder) {, +++ b/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;, +                buildProvider(glide, streamModelLoader, fileDescriptorModelLoader, GifBitmapWrapper.class, Drawable.class,, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;, +        dataLoadProviderFactory.register(ImageVideoWrapper.class, GifBitmapWrapper.class,, +        transcoderFactory.register(GifBitmapWrapper.class, Drawable.class,, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapperTransformation;, +        GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, Drawable> {, +            LoadProvider<ModelType, ImageVideoWrapper, GifBitmapWrapper, Drawable> loadProvider, Glide glide) {, +            GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, Drawable> thumbnailRequest) {, +            ResourceDecoder<ImageVideoWrapper, GifBitmapWrapper> decoder) {, +            ResourceDecoder<InputStream, GifBitmapWrapper> cacheDecoder) {, +            ResourceEncoder<GifBitmapWrapper> encoder) {, +        return transform(new GifBitmapWrapperTransformation(context, bitmapTransformation));, +            Transformation<GifBitmapWrapper> transformation) {, +            ResourceTranscoder<GifBitmapWrapper, Drawable> transcoder) {, +++ b/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;, +                buildProvider(glide, streamModelLoader, fileDescriptorModelLoader, GifBitmapWrapper.class, Drawable.class,, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;, +        dataLoadProviderFactory.register(ImageVideoWrapper.class, GifBitmapWrapper.class,, +        transcoderFactory.register(GifBitmapWrapper.class, Drawable.class,, +++ /dev/null, +++ /dev/null, +++ b/library/src/main/java/com/bumptech/glide/DrawableRequestBuilder.java, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapper;, +import com.bumptech.glide.load.resource.gifbitmap.GifBitmapWrapperTransformation;, +        GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, Drawable> {, +            LoadProvider<ModelType, ImageVideoWrapper, GifBitmapWrapper, Drawable> loadProvider, Glide glide) {, +            GenericRequestBuilder<ModelType, ImageVideoWrapper, GifBitmapWrapper, Drawable> thumbnailRequest) {, +            ResourceDecoder<ImageVideoWrapper, GifBitmapWrapper> decoder) {, +            ResourceDecoder<InputStream, GifBitmapWrapper> cacheDecoder) {, +            ResourceEncoder<GifBitmapWrapper> encoder) {, +        return transform(new GifBitmapWrapperTransformation(context, bitmapTransformation));, +            Transformation<GifBitmapWrapper> transformation) {, +            ResourceTranscoder<GifBitmapWrapper, Drawable> transcoder) {, +++ b/library/src/main/java/com/bumptech/glide/DrawableTypeRequest.java]
[+++ b/instrumentation/src/androidTest/java/com/bumptech/glide/NonBitmapDrawableResourcesTest.java, +import org.junit.Rule;, +import org.junit.rules.ExpectedException;, +  @Rule, +  public ExpectedException expectedException = ExpectedException.none();, +, +  public void load_withBitmapAliasResourceId_asBitmap_producesNonNullBitmap(), +      throws ExecutionException, InterruptedException {, +    Bitmap bitmap = Glide.with(context), +        .asBitmap(), +        .load(ResourceIds.drawable.bitmap_alias), +        .submit(), +        .get();, +    assertThat(bitmap).isNotNull();, +  }, +, +  @Test, +  public void load_withShapeDrawableResourceId_asBitmap_withSizeOriginal_fails(), +      throws ExecutionException, InterruptedException {, +    expectedException.expect(ExecutionException.class);, +    Glide.with(context), +        .asBitmap(), +        .load(ResourceIds.drawable.shape_drawable), +        .submit(), +        .get();, +  }, +, +  @Test, +  public void load_withShapeDrawableResourceId_asBitmap_withValidSize_returnsNonNullBitmap(), +      throws ExecutionException, InterruptedException {, +    Bitmap bitmap = Glide.with(context), +        .asBitmap(), +        .load(ResourceIds.drawable.shape_drawable), +        .submit(100, 200), +        .get();, +    assertThat(bitmap).isNotNull();, +    assertThat(bitmap.getWidth()).isEqualTo(100);, +    assertThat(bitmap.getHeight()).isEqualTo(200);, +  }, +, +  @Test, +  public void load_withStateListDrawableResourceId_asBitmap_producesNonNullBitmap(), +      throws ExecutionException, InterruptedException {, +    Bitmap bitmap = Glide.with(context), +        .asBitmap(), +        .load(ResourceIds.drawable.state_list_drawable), +        .submit(), +        .get();, +    assertThat(bitmap).isNotNull();, +  }, +, +  @Test, +  public void load_withVectorDrawableResourceId_asBitmap_producesNonNullBitmap(), +      throws ExecutionException, InterruptedException {, +    Bitmap bitmap = Glide.with(context), +        .asBitmap(), +        .load(ResourceIds.drawable.vector_drawable), +        .submit(), +        .get();, +    assertThat(bitmap).isNotNull();, +  }, +, +  @Test, +, +  @Test, +  public void load_withNinePatchResourceId_asBitmap_producesNonNullBitmap(), +      throws ExecutionException, InterruptedException {, +    Bitmap bitmap = Glide.with(context), +        .asBitmap(), +        .load(ResourceIds.drawable.googlelogo_color_120x44dp), +        .submit(), +        .get();, +, +    assertThat(bitmap).isNotNull();, +  }, +, +  public void load_withApplicationIconResourceIdUri_asBitmap_producesNonNullBitmap(), +      throws NameNotFoundException, ExecutionException, InterruptedException {, +    for (String packageName : getInstalledPackages()) {, +      int iconResourceId = getResourceId(packageName);, +, +      Uri uri = new Uri.Builder(), +          .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE), +          .authority(packageName), +          .path(String.valueOf(iconResourceId)), +          .build();, +, +      Bitmap bitmap = Glide.with(context), +          .asBitmap(), +          .load(uri), +          .submit(), +          .get();, +      assertThat(bitmap).isNotNull();, +    }, +  }, +, +  @Test, +  @Test, +  public void load_withApplicationIconResourceNameUri_asBitmap_producesNonNullBitmap(), +      throws ExecutionException, InterruptedException, NameNotFoundException {]
[+++ b/gradle.properties, +org.gradle.daemon=true, +++ b/gradle.properties, +org.gradle.daemon=true, +++ b/library/build.gradle, +        classpath 'org.robolectric:robolectric-gradle-plugin:0.11.+', +apply plugin: 'robolectric', +        minSdkVersion 10, +        targetSdkVersion 19, +++ b/gradle.properties, +org.gradle.daemon=true, +++ b/library/build.gradle, +        classpath 'org.robolectric:robolectric-gradle-plugin:0.11.+', +apply plugin: 'robolectric', +        minSdkVersion 10, +        targetSdkVersion 19, +++ b/library/lint.xml, +        <ignore path="src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java" />, +        <ignore path="src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java" />, +++ b/gradle.properties, +org.gradle.daemon=true, +++ b/library/build.gradle, +        classpath 'org.robolectric:robolectric-gradle-plugin:0.11.+', +apply plugin: 'robolectric', +        minSdkVersion 10, +        targetSdkVersion 19, +++ b/library/lint.xml, +        <ignore path="src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java" />, +        <ignore path="src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java" />, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.annotation.TargetApi;, +    @TargetApi(11), +++ b/gradle.properties, +org.gradle.daemon=true, +++ b/library/build.gradle, +        classpath 'org.robolectric:robolectric-gradle-plugin:0.11.+', +apply plugin: 'robolectric', +        minSdkVersion 10, +        targetSdkVersion 19, +++ b/library/lint.xml, +        <ignore path="src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java" />, +        <ignore path="src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java" />, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.annotation.TargetApi;, +    @TargetApi(11), +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +import android.annotation.TargetApi;, +import android.os.Build;, +, +    @TargetApi(11), +        if (Build.VERSION.SDK_INT >= 11 && getCallback() == null) {, +++ b/gradle.properties, +org.gradle.daemon=true, +++ b/library/build.gradle, +        classpath 'org.robolectric:robolectric-gradle-plugin:0.11.+', +apply plugin: 'robolectric', +        minSdkVersion 10, +        targetSdkVersion 19, +++ b/library/lint.xml, +        <ignore path="src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java" />, +        <ignore path="src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java" />, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.annotation.TargetApi;, +    @TargetApi(11), +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +import android.annotation.TargetApi;, +import android.os.Build;, +, +    @TargetApi(11), +        if (Build.VERSION.SDK_INT >= 11 && getCallback() == null) {, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java, +import android.annotation.TargetApi;, +@TargetApi(11), +public class RequestManagerFragment extends Fragment {, +++ b/gradle.properties, +org.gradle.daemon=true, +++ b/library/build.gradle, +        classpath 'org.robolectric:robolectric-gradle-plugin:0.11.+', +apply plugin: 'robolectric', +        minSdkVersion 10, +        targetSdkVersion 19, +++ b/library/lint.xml, +        <ignore path="src/main/java/com/bumptech/glide/load/engine/cache/LruResourceCache.java" />, +        <ignore path="src/main/java/com/bumptech/glide/load/engine/bitmap_recycle/LruBitmapPool.java" />, +++ b/library/src/main/java/com/bumptech/glide/Glide.java, +import android.annotation.TargetApi;, +    @TargetApi(11), +++ b/library/src/main/java/com/bumptech/glide/load/resource/gif/GifDrawable.java, +import android.annotation.TargetApi;, +import android.os.Build;, +, +    @TargetApi(11), +        if (Build.VERSION.SDK_INT >= 11 && getCallback() == null) {, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerFragment.java, +import android.annotation.TargetApi;, +@TargetApi(11), +public class RequestManagerFragment extends Fragment {, +++ b/library/src/main/java/com/bumptech/glide/manager/RequestManagerRetriever.java, +import android.annotation.TargetApi;, +import android.os.Build;]
[+++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="19" />, +++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="19" />, +++ b/library/src/com/bumptech/glide/Glide.java, +import android.os.ParcelFileDescriptor;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorFileLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorModelLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorResourceLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorStringLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorUriLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.BaseUrlLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamResourceLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamFileLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamModelLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamStringLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamUriLoader;, +import com.bumptech.glide.resize.load.VideoBitmapDecoder;, +        loaderFactory.register(File.class, ParcelFileDescriptor.class, new FileDescriptorFileLoader.Factory());, +        loaderFactory.register(File.class, InputStream.class, new StreamFileLoader.Factory());, +        loaderFactory.register(Integer.class, ParcelFileDescriptor.class, new FileDescriptorResourceLoader.Factory());, +        loaderFactory.register(Integer.class, InputStream.class, new StreamResourceLoader.Factory());, +        loaderFactory.register(String.class, ParcelFileDescriptor.class, new FileDescriptorStringLoader.Factory());, +        loaderFactory.register(String.class, InputStream.class, new StreamStringLoader.Factory());, +        loaderFactory.register(Uri.class, ParcelFileDescriptor.class, new FileDescriptorUriLoader.Factory());, +        loaderFactory.register(Uri.class, InputStream.class, new StreamUriLoader.Factory());, +        loaderFactory.register(URL.class, ParcelFileDescriptor.class, new ModelLoaderFactory<URL, ParcelFileDescriptor>() {, +            @Override, +            public ModelLoader<URL, ParcelFileDescriptor> build(Context context, GenericLoaderFactory factories) {, +                throw new IllegalArgumentException("No ModelLoaderFactory for urls and file descriptors registered " +, +                        "with Glide");, +            }, +, +            @Override, +            public Class<? extends ModelLoader<URL, ParcelFileDescriptor>> loaderClass() {, +                throw new IllegalArgumentException("No ModelLoaderFactory for urls and file descriptors registered " +, +                        "with Glide");, +            }, +, +            @Override, +            public void teardown() {, +            }, +        });, +                        throw new IllegalArgumentException("No ModelLoaderFactory for urls and InputStreams " +, +                                "registered with Glide");, +                        throw new IllegalArgumentException("No ModelLoaderFactory for urls and InputStreams " +, +                                "registered with Glide");, +    public static <T, Y> ModelRequest<T, Y> using(final ModelLoader<T, Y> modelLoader) {, +     * @param streamModelLoader The model loader to use., +    public static <T> StreamModelRequest<T> using(final StreamModelLoader<T> streamModelLoader) {, +                return streamModelLoader;, +                return (Class<StreamModelLoader<T>>) streamModelLoader.getClass();, +    public static <T> FileDescriptorModelRequest<T> using(final FileDescriptorModelLoader<T> loader) {, +        return new FileDescriptorModelRequest<T>(new ModelLoaderFactory<T, ParcelFileDescriptor>() {, +            @Override, +            public ModelLoader<T, ParcelFileDescriptor> build(Context context, GenericLoaderFactory factories) {, +                return loader;, +            }, +, +            @SuppressWarnings("unchecked"), +            @Override, +            public Class<? extends ModelLoader<T, ParcelFileDescriptor>> loaderClass() {, +                return (Class<FileDescriptorModelLoader<T>>) loader.getClass();, +            }, +, +            @Override, +            public void teardown() {, +            }, +        });, +    }, +, +     * given {@link String}. Defaults to {@link StreamStringLoader.Factory} and {@link StreamStringLoader} to load the given model., +     * @param string The string representing the image. Must be either a path, or a uri handled by {@link StreamUriLoader}, +     * Defaults to {@link StreamUriLoader.Factory} and {@link StreamUriLoader}., +     * @param uri The uri representing the image. Must be a uri handled by {@link StreamUriLoader}, +     * given {@link File}. Defaults to {@link StreamFileLoader.Factory} and {@link StreamFileLoader} to load the given model., +     * given {@link Integer} resource id. Defaults to {@link StreamResourceLoader.Factory} and {@link StreamResourceLoader} to load, +    public static class FileDescriptorModelRequest<T> {, +        private ModelLoaderFactory<T, ParcelFileDescriptor> factory;, +, +        private FileDescriptorModelRequest(ModelLoaderFactory<T, ParcelFileDescriptor> factory) {, +            this.factory = factory;, +        }, +, +        public Request<T, ParcelFileDescriptor> load(T model) {, +            return new Request<T, ParcelFileDescriptor>(model, factory).decoder(new VideoBitmapDecoder());, +        }, +    }, +, +++ b/library/AndroidManifest.xml, +  <uses-sdk android:minSdkVersion="10" android:targetSdkVersion="19" />, +++ b/library/src/com/bumptech/glide/Glide.java, +import android.os.ParcelFileDescriptor;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorFileLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorModelLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorResourceLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorStringLoader;, +import com.bumptech.glide.loader.bitmap.model.file_descriptor.FileDescriptorUriLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.BaseUrlLoader;, +import com.bumptech.glide.loader.bitmap.model.stream.StreamResourceLoader;]
[+++ b/.travis.yml, +script: 'travis_retry ./gradlew clean checkstyle build', +++ b/.travis.yml, +script: 'travis_retry ./gradlew clean checkstyle build', +++ b/build.gradle, +    apply plugin: 'checkstyle', +, +    checkstyle {, +        configFile = new File(rootDir, 'checkstyle.xml'), +    }, +, +    task checkstyle(type: Checkstyle) {, +        source 'src', +        include '**/*.java', +        exclude '**/gen/**', +, +        // empty classpath, +        classpath = files(), +    }, +++ b/.travis.yml, +script: 'travis_retry ./gradlew clean checkstyle build', +++ b/build.gradle, +    apply plugin: 'checkstyle', +, +    checkstyle {, +        configFile = new File(rootDir, 'checkstyle.xml'), +    }, +, +    task checkstyle(type: Checkstyle) {, +        source 'src', +        include '**/*.java', +        exclude '**/gen/**', +, +        // empty classpath, +        classpath = files(), +    }, +++ b/checkstyle.xml, +<?xml version="1.0" encoding="UTF-8"?>, +<!DOCTYPE module PUBLIC "-//Puppy Crawl//DTD Check Configuration 1.3//EN" "http://www.puppycrawl.com/dtds/configuration_1_3.dtd">, +<module name="Checker">, +    <module name="FileLength"/>, +    <module name="FileTabCharacter"/>, +, +    <!-- Trailing spaces -->, +    <module name="RegexpSingleline">, +        <property name="format" value="\s+$"/>, +        <property name="message" value="Line has trailing spaces."/>, +    </module>, +, +    <!-- Space after 'for' and 'if' -->, +    <module name="RegexpSingleline">, +        <property name="format" value="^\s*(for|if)\b[^ ]"/>, +        <property name="message" value="Space needed before opening parenthesis."/>, +    </module>, +, +    <!-- For each spacing -->, +    <module name="RegexpSingleline">, +        <property name="format" value="^\s*for \(.*?([^ ]:|:[^ ])"/>, +        <property name="message" value="Space needed around ':' character."/>, +    </module>, +, +    <module name="TreeWalker">, +        <!-- Checks for uncommented main() methods (debugging leftovers). -->, +        <!-- Checks that long constants are defined with an upper ell. -->, +        <!-- See http://checkstyle.sourceforge.net/config_misc.html#UpperEll -->, +        <module name="UpperEll" />, +, +        <!-- Checks the style of array type definitions. -->, +        <!-- See http://checkstyle.sourceforge.net/config_misc.html#ArrayTypeStyle -->, +        <module name="ArrayTypeStyle" />, +, +        <!-- Checks that the outer type name and the file name match. -->, +        <!-- See http://checkstyle.sourceforge.net/config_misc.html#OuterTypeFilename -->, +        <module name="OuterTypeFilename" />, +, +        <!-- Validates Javadoc comments to help ensure they are well formed. -->, +        <!-- See http://checkstyle.sourceforge.net/config_javadoc.html#JavadocStyle -->, +        <module name="JavadocStyle" />, +, +        <!-- Each of these naming modules validates identifiers for particular, +                code elements. -->, +        <!-- See http://checkstyle.sourceforge.net/config_naming.html -->, +        <module name="ConstantName">, +            <property name="format" value="^[A-Z][A-Z0-9\$]*(_[A-Z0-9\$]+)*$" />, +        </module>, +        <module name="LocalFinalVariableName" />, +        <module name="LocalVariableName" />, +        <module name="MemberName">, +            <property name="format" value="^[a-z][a-zA-Z0-9_\$]*$" />, +        </module>, +        <module name="MethodName" />, +        <module name="PackageName" />, +        <module name="ParameterName" />, +        <module name="StaticVariableName" />, +        <module name="TypeName" />, +, +        <module name="TrailingComment" />, +, +        <!-- Checks for imports. -->, +        <!-- See http://checkstyle.sourceforge.net/config_imports.html -->]
[+++ b/library/src/main/java/com/bumptech/glide/load/model/BasicHeaders.java, +package com.bumptech.glide.load.model;, +, +import android.text.TextUtils;, +, +import java.util.Collections;, +import java.util.HashMap;, +import java.util.HashSet;, +import java.util.Map;, +import java.util.Set;, +, +/**, + * A wrapper class for a set of headers to be included in a Glide request., + */, +public final class BasicHeaders implements Headers {, +, +    private final Map<String, Set<String>> headers;, +    private volatile Map<String, String> combinedHeaders;, +, +    BasicHeaders(Map<String, Set<String>> headers) {, +        this.headers = Collections.unmodifiableMap(headers);, +    }, +, +    public Map<String, String> getHeaders() {, +        if (combinedHeaders == null) {, +            synchronized (this) {, +                if (combinedHeaders == null) {, +                    this.combinedHeaders = generateCombinedHeaders();, +                }, +            }, +        }, +, +        return combinedHeaders;, +    }, +, +    private Map<String, String> generateCombinedHeaders() {, +        Map<String, String> combinedHeaders = new HashMap<String, String>();, +        for (Map.Entry<String, Set<String>> entry : headers.entrySet()) {, +            combinedHeaders.put(entry.getKey(), TextUtils.join(",", entry.getValue()));, +        }, +        return Collections.unmodifiableMap(combinedHeaders);, +    }, +, +    @Override, +    public boolean equals(Object o) {, +        if (o instanceof BasicHeaders) {, +            BasicHeaders other = (BasicHeaders) o;, +            return headers.equals(other.headers);, +        }, +        return false;, +    }, +, +    @Override, +    public int hashCode() {, +        return headers.hashCode();, +    }, +, +    /**, +     * Builder class for {@link Headers}., +     */, +    public static final class Builder {, +        private final Map<String, Set<String>> headers = new HashMap<String, Set<String>>();, +, +        public void addHeader(String key, String value) {, +            if (headers.containsKey(key)) {, +                headers.get(key).add(value);, +            } else {, +                Set<String> values = new HashSet<String>();, +                values.add(value);, +                headers.put(key, values);, +            }, +        }, +, +        public BasicHeaders build() {, +            return new BasicHeaders(headers);, +        }, +    }, +}, +++ b/library/src/main/java/com/bumptech/glide/load/model/BasicHeaders.java, +package com.bumptech.glide.load.model;, +, +import android.text.TextUtils;, +, +import java.util.Collections;, +import java.util.HashMap;, +import java.util.HashSet;, +import java.util.Map;, +import java.util.Set;, +, +/**, + * A wrapper class for a set of headers to be included in a Glide request., + */, +public final class BasicHeaders implements Headers {, +, +    private final Map<String, Set<String>> headers;, +    private volatile Map<String, String> combinedHeaders;, +, +    BasicHeaders(Map<String, Set<String>> headers) {, +        this.headers = Collections.unmodifiableMap(headers);, +    }]
[+++ b/library/src/androidTest/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java, +package com.bumptech.glide.load.data;, +, +import static com.google.common.truth.Truth.assertThat;, +, +import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;, +import com.bumptech.glide.testutil.TestResourceUtil;, +, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +, +import java.io.IOException;, +import java.io.InputStream;, +, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +public class ExifOrientationStreamTest {, +  private InputStream openOrientationExample(boolean isLandscape, int item) {, +    String filePrefix = isLandscape ? "Landscape" : "Portrait";, +    return TestResourceUtil.openResource(getClass(),, +        "exif-orientation-examples/" + filePrefix + "_" + item + ".jpg");, +  }, +, +  @Test, +  public void testIncludesGivenExifOrientation() throws IOException {, +    for (int i = 0; i < 8; i++) {, +      for (int j = 0; j < 8; j++) {, +        InputStream toWrap = openOrientationExample(true /*isLandscape*/, j + 1);, +        InputStream wrapped = new ExifOrientationStream(toWrap, i);, +        ImageHeaderParser parser = new ImageHeaderParser(wrapped);, +        assertThat(parser.getOrientation()).isEqualTo(i);, +, +        toWrap = openOrientationExample(false /*isLandscape*/, j + 1);, +        wrapped = new ExifOrientationStream(toWrap, i);, +        parser = new ImageHeaderParser(wrapped);, +        assertThat(parser.getOrientation()).isEqualTo(i);, +      }, +    }, +  }, +}, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java, +package com.bumptech.glide.load.data;, +, +import static com.google.common.truth.Truth.assertThat;, +, +import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;, +import com.bumptech.glide.testutil.TestResourceUtil;, +, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;, +import org.robolectric.annotation.Config;, +, +import java.io.IOException;, +import java.io.InputStream;, +, +@RunWith(RobolectricTestRunner.class), +@Config(manifest = Config.NONE, emulateSdk = 18), +public class ExifOrientationStreamTest {, +  private InputStream openOrientationExample(boolean isLandscape, int item) {, +    String filePrefix = isLandscape ? "Landscape" : "Portrait";, +    return TestResourceUtil.openResource(getClass(),, +        "exif-orientation-examples/" + filePrefix + "_" + item + ".jpg");, +  }, +, +  @Test, +  public void testIncludesGivenExifOrientation() throws IOException {, +    for (int i = 0; i < 8; i++) {, +      for (int j = 0; j < 8; j++) {, +        InputStream toWrap = openOrientationExample(true /*isLandscape*/, j + 1);, +        InputStream wrapped = new ExifOrientationStream(toWrap, i);, +        ImageHeaderParser parser = new ImageHeaderParser(wrapped);, +        assertThat(parser.getOrientation()).isEqualTo(i);, +, +        toWrap = openOrientationExample(false /*isLandscape*/, j + 1);, +        wrapped = new ExifOrientationStream(toWrap, i);, +        parser = new ImageHeaderParser(wrapped);, +        assertThat(parser.getOrientation()).isEqualTo(i);, +      }, +    }, +  }, +}, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/MediaStoreThumbFetcherTest.java, +import static org.junit.Assert.assertNotNull;, +        when(harness.thumbnailFetcher.open(eq(Robolectric.application), eq(harness.uri))).thenReturn(, +            expected);, +        assertNotNull(result);, +++ b/library/src/androidTest/java/com/bumptech/glide/load/data/ExifOrientationStreamTest.java, +package com.bumptech.glide.load.data;, +, +import static com.google.common.truth.Truth.assertThat;, +, +import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;, +import com.bumptech.glide.testutil.TestResourceUtil;, +, +import org.junit.Test;, +import org.junit.runner.RunWith;, +import org.robolectric.RobolectricTestRunner;]
[+++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +    boolean started = false;, +        started = true;, +    return started;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +    boolean started = false;, +        started = true;, +    return started;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +  Object getModel() {, +    return model;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +    boolean started = false;, +        started = true;, +    return started;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +  Object getModel() {, +    return model;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +        reschedule();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +    boolean started = false;, +        started = true;, +    return started;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +  Object getModel() {, +    return model;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +        reschedule();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java, +    boolean started = false;, +        started = true;, +    return started;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +    boolean started = false;, +        started = true;, +    return started;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +  Object getModel() {, +    return model;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +        reschedule();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java, +    boolean started = false;, +        started = true;, +    return started;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java, +    boolean started = false;, +        started = true;, +    return started;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DataCacheGenerator.java, +    boolean started = false;, +        started = true;, +    return started;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeHelper.java, +  Object getModel() {, +    return model;, +  }, +, +++ b/library/src/main/java/com/bumptech/glide/load/engine/DecodeJob.java, +        reschedule();, +++ b/library/src/main/java/com/bumptech/glide/load/engine/ResourceCacheGenerator.java, +    boolean started = false;, +        started = true;, +    return started;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/SourceGenerator.java, +    boolean started = false;, +        started = true;, +    return started;, +++ b/library/src/main/java/com/bumptech/glide/load/engine/executor/GlideExecutor.java, +    this(poolSize, UncaughtThrowableStrategy.LOG);, +        UncaughtThrowableStrategy.LOG);]
[+++ b/gradle.properties, +VERSION_NAME=4.0.0-SNAPSHOT, +VERSION_MAJOR=4, +VERSION_MINOR=0, +VERSION_CODE=12, +++ b/gradle.properties, +VERSION_NAME=4.0.0-SNAPSHOT, +VERSION_MAJOR=4, +VERSION_MINOR=0, +VERSION_CODE=12, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=2.0.0-SNAPSHOT, +VERSION_MAJOR=2, +VERSION_MINOR=0, +VERSION_CODE=8, +++ b/gradle.properties, +VERSION_NAME=4.0.0-SNAPSHOT, +VERSION_MAJOR=4, +VERSION_MINOR=0, +VERSION_CODE=12, +++ b/integration/okhttp/gradle.properties, +VERSION_NAME=2.0.0-SNAPSHOT, +VERSION_MAJOR=2, +VERSION_MINOR=0, +VERSION_CODE=8, +++ b/integration/volley/gradle.properties, +VERSION_NAME=2.0.0-SNAPSHOT, +VERSION_MAJOR=2, +VERSION_MINOR=0, +VERSION_CODE=8]
